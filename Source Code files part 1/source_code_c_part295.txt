**************/

// IPersistStorage::QueryInterface method

STDMETHODIMP SvrDoc_PStg_QueryInterface(
		LPPERSISTSTORAGE        lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;

	return OleDoc_QueryInterface((LPOLEDOC)lpServerDoc, riid, lplpvObj);
}


// IPersistStorage::AddRef method

STDMETHODIMP_(ULONG) SvrDoc_PStg_AddRef(LPPERSISTSTORAGE lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;

	OleDbgAddRefMethod(lpThis, "IPersistStorage");

	return OleDoc_AddRef((LPOLEDOC)lpServerDoc);
}


// IPersistStorage::Release method

STDMETHODIMP_(ULONG) SvrDoc_PStg_Release(LPPERSISTSTORAGE lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;

	OleDbgReleaseMethod(lpThis, "IPersistStorage");

	return OleDoc_Release((LPOLEDOC)lpServerDoc);
}


// IPersistStorage::GetClassID method

STDMETHODIMP SvrDoc_PStg_GetClassID(
		LPPERSISTSTORAGE        lpThis,
		LPCLSID                 lpClassID
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_PStg_GetClassID\r\n");

	/* OLE2NOTE: we must be carefull to return the correct CLSID here.
	**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
	**    operation then we need to return the class of the object
	**    written in the storage of the object. otherwise we would
	**    return our own class id.
	*/
	return ServerDoc_GetClassID(lpServerDoc, lpClassID);
}


// IPersistStorage::IsDirty method

STDMETHODIMP  SvrDoc_PStg_IsDirty(LPPERSISTSTORAGE  lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_PStg_IsDirty\r\n");

	if (OutlineDoc_IsModified((LPOUTLINEDOC)lpServerDoc))
		return NOERROR;
	else
		return ResultFromScode(S_FALSE);
}



// IPersistStorage::InitNew method

STDMETHODIMP SvrDoc_PStg_InitNew(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPSTR    lpszUserType = (LPSTR)FULLUSERTYPENAME;
	HRESULT hrErr;
	SCODE sc;

	OLEDBG_BEGIN2("SvrDoc_PStg_InitNew\r\n")

#if defined( SVR_TREATAS )
	{
		LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
		CLSID       clsid;
		CLIPFORMAT  cfFmt;
		LPSTR       lpszType;

		/* OLE2NOTE: if the Server is capable of supporting "TreatAs"
		**    (aka. ActivateAs), it must read the class that is written
		**    into the storage. if this class is NOT the app's own
		**    class ID, then this is a TreatAs operation. the server
		**    then must faithfully pretend to be the class that is
		**    written into the storage. it must also faithfully write
		**    the data back to the storage in the SAME format as is
		**    written in the storage.
		**
		**    SVROUTL and ISVROTL can emulate each other. they have the
		**    simplification that they both read/write the identical
		**    format. thus for these apps no actual conversion of the
		**    native bits is actually required.
		*/
		lpServerDoc->m_clsidTreatAs = CLSID_NULL;
		if (OleStdGetTreatAsFmtUserType(&CLSID_APP, lpStg, &clsid,
							(CLIPFORMAT FAR*)&cfFmt, (LPSTR FAR*)&lpszType)) {

			if (cfFmt == lpOutlineApp->m_cfOutline) {
				// We should perform TreatAs operation
				if (lpServerDoc->m_lpszTreatAsType)
					OleStdFreeString(lpServerDoc->m_lpszTreatAsType, NULL);

				lpServerDoc->m_clsidTreatAs = clsid;
				((LPOUTLINEDOC)lpServerDoc)->m_cfSaveFormat = cfFmt;
				lpServerDoc->m_lpszTreatAsType = lpszType;
				lpszUserType = lpServerDoc->m_lpszTreatAsType;

				OleDbgOut3("SvrDoc_PStg_InitNew: TreateAs ==> '");
				OleDbgOutNoPrefix3(lpServerDoc->m_lpszTreatAsType);
				OleDbgOutNoPrefix3("'\r\n");
			} else {
				// ERROR: we ONLY support TreatAs for CF_OUTLINE format
				OleDbgOut("SvrDoc_PStg_InitNew: INVALID TreatAs Format\r\n");
				OleStdFreeString(lpszType, NULL);
			}
		}
	}
#endif  // SVR_TREATAS

	/* OLE2NOTE: a server EXE object should write its format tag to its
	**    storage in InitNew so that the DefHandler can know the format
	**    of the object. this is particularly important if the objects
	**    uses CF_METATFILE or CF_DIB as its format. the DefHandler
	**    automatically avoids separately storing presentation cache
	**    data when the object's native data is a standard presentation
	**    format.
	*/
	WriteFmtUserTypeStgA(lpStg,lpOutlineApp->m_cfOutline,lpszUserType);

	// set the doc to a new embedded object.
	if (! ServerDoc_InitNewEmbed(lpServerDoc)) {
		sc = E_FAIL;
		goto error;
	}

	/* OLE2NOTE: An embedded object must guarantee that it can save
	**    even in low memory situations. it must be able to
	**    successfully save itself without consuming any additional
	**    memory. this means that a server is NOT supposed to open or
	**    create any streams or storages when
	**    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an
	**    embedded object should hold onto its storage and pre-open and
	**    hold open any streams that it will need later when it is time
	**    to save.
	*/
	hrErr = CallIStorageCreateStreamA(
			lpStg,
			"LineList",
			STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			0,
			0,
			&lpOleDoc->m_lpLLStm
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr==NOERROR,"Could not create LineList stream");
		OleDbgOutHResult("LineList CreateStream returned", hrErr);
		sc = GetScode(hrErr);
		goto error;
	}

	hrErr = CallIStorageCreateStreamA(
			lpStg,
			"NameTable",
			STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			0,
			0,
			&lpOleDoc->m_lpNTStm
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr==NOERROR,"Could not create NameTable stream");
		OleDbgOutHResult("NameTable CreateStream returned", hrErr);
		sc = GetScode(hrErr);
		goto error;
	}

	lpOleDoc->m_lpStg = lpStg;

	// OLE2NOTE: to be able to hold onto IStorage* pointer, we must AddRef it
	lpStg->lpVtbl->AddRef(lpStg);

	OLEDBG_END2
	return NOERROR;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


// IPersistStorage::Load method

STDMETHODIMP SvrDoc_PStg_Load(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	SCODE sc;
	HRESULT hrErr;

	OLEDBG_BEGIN2("SvrDoc_PStg_Load\r\n")

	if (OutlineDoc_LoadFromStg((LPOUTLINEDOC)lpServerDoc, lpStg)) {

		((LPOUTLINEDOC)lpServerDoc)->m_docInitType = DOCTYPE_EMBEDDED;

		/* OLE2NOTE: we need to check if the ConvertStg bit is on. if
		**    so, we need to clear the ConvertStg bit and mark the
		**    document as dirty so as to force a save when the document
		**    is closed. the actual conversion of the bits should be
		**    performed when the data is loaded from the IStorage*. in
		**    our case any conversion of data formats would be done in
		**    OutlineDoc_LoadFromStg function. in reality both SVROUTL
		**    and ISVROTL read and write the same format so no actual
		**    conversion of data bits is necessary.
		*/
		if (GetConvertStg(lpStg) == NOERROR) {
			SetConvertStg(lpStg, FALSE);

			OleDbgOut3("SvrDoc_PStg_Load: ConvertStg==TRUE\r\n");
			OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE);
		}

	} else {
		sc = E_FAIL;
		goto error;
	}

	/* OLE2NOTE: An embedded object must guarantee that it can save
	**    even in low memory situations. it must be able to
	**    successfully save itself without consuming any additional
	**    memory. this means that a server is NOT supposed to open or
	**    create any streams or storages when
	**    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an
	**    embedded object should hold onto its storage and pre-open and
	**    hold open any streams that it will need later when it is time
	**    to save.
	*/
	if (lpOleDoc->m_lpLLStm)
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpLLStm);
	hrErr = CallIStorageOpenStreamA(
			lpStg,
			"LineList",
			NULL,
			STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
			0,
			&lpOleDoc->m_lpLLStm
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr==NOERROR,"Could not create LineList stream");
		OleDbgOutHResult("LineList CreateStream returned", hrErr);
		sc = GetScode(hrErr);
		goto error;
	}

	if (lpOleDoc->m_lpNTStm)
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpNTStm);
	hrErr = CallIStorageOpenStreamA(
			lpStg,
			"NameTable",
			NULL,
			STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
			0,
			&lpOleDoc->m_lpNTStm
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr==NOERROR,"Could not create NameTable stream");
		OleDbgOutHResult("NameTable CreateStream returned", hrErr);
		sc = GetScode(hrErr);
		goto error;
	}

	lpOleDoc->m_lpStg = lpStg;

	// OLE2NOTE: to be able to hold onto IStorage* pointer, we must AddRef it
	lpStg->lpVtbl->AddRef(lpStg);

	OLEDBG_END2
	return NOERROR;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


// IPersistStorage::Save method

STDMETHODIMP SvrDoc_PStg_Save(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg,
		BOOL                    fSameAsLoad
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	BOOL fStatus;
	SCODE sc;

	OLEDBG_BEGIN2("SvrDoc_PStg_Save\r\n")

	fStatus = OutlineDoc_SaveSelToStg(
			(LPOUTLINEDOC)lpServerDoc,
			NULL,
			lpOutlineDoc->m_cfSaveFormat,
			lpStg,
			fSameAsLoad,
			FALSE
	);

	if (! fStatus) {
		OutlineApp_ErrorMessage(g_lpApp, ErrMsgPSSaveFail);
		sc = E_FAIL;
		goto error;
	}

	lpServerDoc->m_fSaveWithSameAsLoad = fSameAsLoad;
	lpServerDoc->m_fNoScribbleMode = TRUE;

	OLEDBG_END2
	return NOERROR;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}



// IPersistStorage::SaveCompleted method

STDMETHODIMP SvrDoc_PStg_SaveCompleted(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStgNew
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	HRESULT hrErr;

	OLEDBG_BEGIN2("SvrDoc_PStg_SaveCompleted\r\n")

	/* OLE2NOTE: this sample application is a pure server application.
	**    a container/server application would have to call SaveCompleted
	**    for each of its contained compound document objects. if a new
	**    storage was given, then the container/server would have to
	**    open the corresponding new sub-storage for each compound
	**    document object and pass as an argument in the SaveCompleted
	**    call.
	*/

	/* OLE2NOTE: it is only legal to perform a Save or SaveAs operation
	**    on an embedded object. if the document is a file-based document
	**    then we can not be changed to a IStorage-base object.
	**
	**      fSameAsLoad   lpStgNew     Type of Save     Send OnSave
	**    ---------------------------------------------------------
	**         TRUE        NULL        SAVE             YES
	**         TRUE        ! NULL      SAVE *           YES
	**         FALSE       ! NULL      SAVE AS          YES
	**         FALSE       NULL        SAVE COPY AS     NO
	**
	**    * this is a strange case that is possible. it is inefficient
	**    for the caller; it would be better to pass lpStgNew==NULL for
	**    the Save operation.
	*/
	if ( ((lpServerDoc->m_fSaveWithSameAsLoad && lpStgNew==NULL) || lpStgNew)
			&& (lpOutlineDoc->m_docInitType != DOCTYPE_EMBEDDED) ) {
		OLEDBG_END2
		return ResultFromScode(E_INVALIDARG);
	}

	/* OLE2NOTE: inform any linking clients that the document has been
	**    saved. in addition, any currently active pseudo objects
	**    should also inform their clients. we should only broadcast an
	**    OnSave notification if a Save or SaveAs operation was
	**    performed. we do NOT want to send the notification if a
	**    SaveCopyAs operation was performed.
	*/
	if (lpStgNew || lpServerDoc->m_fSaveWithSameAsLoad) {

		/* OLE2NOTE: if IPersistStorage::Save has been called, then we
		**    need to clear the dirty bit and send OnSave notification.
		**    if HandsOffStorage is called directly without first
		**    calling Save, then we do NOT want to clear the dirty bit
		**    and send OnSave when SaveCompleted is called.
		*/
		if (lpServerDoc->m_fNoScribbleMode) {
			OutlineDoc_SetModified(lpOutlineDoc, FALSE, FALSE, FALSE);

			ServerDoc_SendAdvise (
					lpServerDoc,
					OLE_ONSAVE,
					NULL,   /* lpmkDoc -- not relevant here */
					0       /* advf -- not relevant here */
			);
		}
		lpServerDoc->m_fSaveWithSameAsLoad = FALSE;
	}
	lpServerDoc->m_fNoScribbleMode = FALSE;

	/* OLE2NOTE: An embedded object must guarantee that it can save
	**    even in low memory situations. it must be able to
	**    successfully save itself without consuming any additional
	**    memory. this means that a server is NOT supposed to open or
	**    create any streams or storages when
	**    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an
	**    embedded object should hold onto its storage and pre-open and
	**    hold open any streams that it will need later when it is time
	**    to save. if this is a SaveAs situtation, then we want to
	**    pre-open and hold open our streams to guarantee that a
	**    subsequent save will be successful in low-memory. if we fail
	**    to open these streams then we want to force ourself to close
	**    to make sure the can't make editing changes that can't be
	**    later saved.
	*/
	if ( lpStgNew && !lpServerDoc->m_fSaveWithSameAsLoad ) {

		// release previous streams
		if (lpOleDoc->m_lpLLStm) {
			OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpLLStm);
			lpOleDoc->m_lpLLStm = NULL;
		}
		if (lpOleDoc->m_lpNTStm) {
			OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpNTStm);
			lpOleDoc->m_lpNTStm = NULL;
		}
		if (lpOleDoc->m_lpStg) {
			OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpStg);
			lpOleDoc->m_lpStg = NULL;
		}

		hrErr = CallIStorageOpenStreamA(
				lpStgNew,
				"LineList",
				NULL,
				STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
				0,
				&lpOleDoc->m_lpLLStm
		);

		if (hrErr != NOERROR) {
			OleDbgAssertSz(hrErr==NOERROR,"Could not create LineList stream");
			OleDbgOutHResult("LineList CreateStream returned", hrErr);
			goto error;
		}

		hrErr = CallIStorageOpenStreamA(
				lpStgNew,
				"NameTable",
				NULL,
				STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
				0,
				&lpOleDoc->m_lpNTStm
		);

		if (hrErr != NOERROR) {
			OleDbgAssertSz(hrErr==NOERROR,"Could not create NameTable stream");
			OleDbgOutHResult("NameTable CreateStream returned", hrErr);
			goto error;
		}

		lpOleDoc->m_lpStg = lpStgNew;

		// OLE2NOTE: to hold onto IStorage* pointer, we must AddRef it
		lpStgNew->lpVtbl->AddRef(lpStgNew);
	}

	OLEDBG_END2
	return NOERROR;

error:
	OLEDBG_END2
	return ResultFromScode(E_OUTOFMEMORY);
}


// IPersistStorage::HandsOffStorage method

STDMETHODIMP SvrDoc_PStg_HandsOffStorage(LPPERSISTSTORAGE lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;

	OLEDBG_BEGIN2("SvrDoc_PStg_HandsOffStorage\r\n")

	/* OLE2NOTE: An embedded object must guarantee that it can save
	**    even in low memory situations. it must be able to
	**    successfully save itself without consuming any additional
	**    memory. this means that a server is NOT supposed to open or
	**    create any streams or storages when
	**    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an
	**    embedded object should hold onto its storage and pre-open and
	**    hold open any streams that it will need later when it is time
	**    to save. Now when HandsOffStorage is called the object must
	**    release its storage and any streams that is holds open.
	**    later when SaveCompleted is called, it will be given back its
	**    storage.
	*/
	if (lpOleDoc->m_lpLLStm) {
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpLLStm);
		lpOleDoc->m_lpLLStm = NULL;
	}
	if (lpOleDoc->m_lpNTStm) {
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpNTStm);
		lpOleDoc->m_lpNTStm = NULL;
	}
	if (lpOleDoc->m_lpStg) {
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpStg);
		lpOleDoc->m_lpStg = NULL;
	}

	OLEDBG_END2
	return NOERROR;
}



#if defined( SVR_TREATAS )

/*************************************************************************
** ServerDoc::IStdMarshalInfo interface implementation
*************************************************************************/

// IStdMarshalInfo::QueryInterface method

STDMETHODIMP SvrDoc_StdMshl_QueryInterface(
		LPSTDMARSHALINFO        lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocStdMarshalInfoImpl FAR*)lpThis)->lpServerDoc;

	return OleDoc_QueryInterface((LPOLEDOC)lpServerDoc, riid, lplpvObj);
}


// IStdMarshalInfo::AddRef method

STDMETHODIMP_(ULONG) SvrDoc_StdMshl_AddRef(LPSTDMARSHALINFO lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocStdMarshalInfoImpl FAR*)lpThis)->lpServerDoc;

	OleDbgAddRefMethod(lpThis, "IStdMarshalInfo");

	return OleDoc_AddRef((LPOLEDOC)lpServerDoc);
}


// IStdMarshalInfo::Release method

STDMETHODIMP_(ULONG) SvrDoc_StdMshl_Release(LPSTDMARSHALINFO lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocStdMarshalInfoImpl FAR*)lpThis)->lpServerDoc;

	OleDbgReleaseMethod(lpThis, "IStdMarshalInfo");

	return OleDoc_Release((LPOLEDOC)lpServerDoc);
}


// IStdMarshalInfo::GetClassForHandler

STDMETHODIMP SvrDoc_StdMshl_GetClassForHandler(
		LPSTDMARSHALINFO        lpThis,
		DWORD                   dwDestContext,
		LPVOID                  pvDestContext,
		LPCLSID                 lpClassID
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocStdMarshalInfoImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_StdMshl_GetClassForHandler\r\n");

	// OLE2NOTE: we only handle LOCAL marshal context.
	if (dwDestContext != MSHCTX_LOCAL || pvDestContext != NULL)
		return ResultFromScode(E_INVALIDARG);

	/* OLE2NOTE: we must return our REAL clsid, NOT the clsid that we
	**    are pretending to be if a "TreatAs" is in effect.
	*/
	*lpClassID = CLSID_APP;
	return NOERROR;
}
#endif  // SVR_TREATAS



/*************************************************************************
** ServerDoc Support Functions
*************************************************************************/


/* ServerDoc_Init
 * --------------
 *
 *  Initialize the fields of a new ServerDoc object. The object is initially
 *  not associated with a file or an (Untitled) document. This function sets
 *  the docInitType to DOCTYPE_UNKNOWN. After calling this function the
 *  caller should call:
 *      1.) OutlineDoc_InitNewFile to set the ServerDoc to (Untitled)
 *      2.) OutlineDoc_LoadFromFile to associate the ServerDoc with a file.
 *  This function creates a new window for the document.
 *
 *  NOTE: the window is initially created with a NIL size. it must be
 *        sized and positioned by the caller. also the document is initially
 *        created invisible. the caller must call OutlineDoc_ShowWindow
 *        after sizing it to make the document window visible.
 */
BOOL ServerDoc_Init(LPSERVERDOC lpServerDoc, BOOL fDataTransferDoc)
{
	lpServerDoc->m_cPseudoObj                   = 0;
	lpServerDoc->m_lpOleClientSite              = NULL;
	lpServerDoc->m_lpOleAdviseHldr              = NULL;
	lpServerDoc->m_lpDataAdviseHldr             = NULL;

	// initialy doc does not have any storage
	lpServerDoc->m_fNoScribbleMode              = FALSE;
	lpServerDoc->m_fSaveWithSameAsLoad          = FALSE;
	lpServerDoc->m_szContainerApp[0]            = '\0';
	lpServerDoc->m_szContainerObj[0]            = '\0';
	lpServerDoc->m_nNextRangeNo                 = 0L;
	lpServerDoc->m_lrSrcSelOfCopy.m_nStartLine  = -1;
	lpServerDoc->m_lrSrcSelOfCopy.m_nEndLine    = -1;
	lpServerDoc->m_fDataChanged                 = FALSE;
	lpServerDoc->m_fSizeChanged                 = FALSE;
	lpServerDoc->m_fSendDataOnStop              = FALSE;

#if defined( SVR_TREATAS )
	lpServerDoc->m_clsidTreatAs                 = CLSID_NULL;
	lpServerDoc->m_lpszTreatAsType              = NULL;
#endif  // SVR_TREATAS

#if defined( INPLACE_SVR )
	lpServerDoc->m_hWndHatch                    =
			CreateHatchWindow(
					OutlineApp_GetWindow(g_lpApp),
					OutlineApp_GetInstance(g_lpApp)
			);
	if (!lpServerDoc->m_hWndHatch)
		return FALSE;

	lpServerDoc->m_fInPlaceActive               = FALSE;
	lpServerDoc->m_fInPlaceVisible              = FALSE;
	lpServerDoc->m_fUIActive                    = FALSE;
	lpServerDoc->m_lpIPData                     = NULL;
	lpServerDoc->m_fMenuHelpMode                = FALSE; // F1 pressed in menu

	INIT_INTERFACEIMPL(
			&lpServerDoc->m_OleInPlaceObject,
			&g_SvrDoc_OleInPlaceObjectVtbl,
			lpServerDoc
	);
	INIT_INTERFACEIMPL(
			&lpServerDoc->m_OleInPlaceActiveObject,
			&g_SvrDoc_OleInPlaceActiveObjectVtbl,
			lpServerDoc
	);
#endif // INPLACE_SVR

	INIT_INTERFACEIMPL(
			&lpServerDoc->m_OleObject,
			&g_SvrDoc_OleObjectVtbl,
			lpServerDoc
	);

	INIT_INTERFACEIMPL(
			&lpServerDoc->m_PersistStorage,
			&g_SvrDoc_PersistStorageVtbl,
			lpServerDoc
	);

#if defined( SVR_TREATAS )

	INIT_INTERFACEIMPL(
			&lpServerDoc->m_StdMarshalInfo,
			&g_SvrDoc_StdMarshalInfoVtbl,
			lpServerDoc
	);
#endif  // SVR_TREATAS
	return TRUE;
}


/* ServerDoc_InitNewEmbed
 * ----------------------
 *
 *  Initialize the ServerDoc object to be a new embedded object document.
 *  This function sets the docInitType to DOCTYPE_EMBED.
 */
BOOL ServerDoc_InitNewEmbed(LPSERVERDOC lpServerDoc)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;

	OleDbgAssert(lpOutlineDoc->m_docInitType == DOCTYPE_UNKNOWN);

	lpOutlineDoc->m_docInitType = DOCTYPE_EMBEDDED;

	/* The Window title for an embedded object is constructed as
	**    follows:
	**      <server app name> - <obj short type> in <cont. doc name>
	**
	**    here we construct the current document title portion of the
	**    name which follows the '-'. OutlineDoc_SetTitle prepends the
	**    "<server app name> - " to the document title.
	*/
	// REVIEW: this string should be loaded from string resource
	wsprintf(lpOutlineDoc->m_szFileName, "%s in %s",
		(LPSTR)SHORTUSERTYPENAME,
		(LPSTR)DEFCONTAINERNAME);
	lpOutlineDoc->m_lpszDocTitle = lpOutlineDoc->m_szFileName;


	/* OLE2NOTE: an embedding should be marked as initially dirty so
	**    that on close we always call IOleClientSite::SaveObject.
	*/
	OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE);

	OutlineDoc_SetTitle(lpOutlineDoc, FALSE /*fMakeUpperCase*/);

	return TRUE;
}


/* ServerDoc_SendAdvise
 * --------------------
 *
 * This function sends an advise notification on behalf of a specific
 *  doc object to all its clients.
 */
void ServerDoc_SendAdvise(
		LPSERVERDOC     lpServerDoc,
		WORD            wAdvise,
		LPMONIKER       lpmkDoc,
		DWORD           dwAdvf
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;

	switch (wAdvise) {

		case OLE_ONDATACHANGE:

			// inform clients that the data of the object has changed

			if (lpOutlineDoc->m_nDisableDraw == 0) {
				/* drawing is currently enabled. inform clients that
				**    the data of the object has changed
				*/

				lpServerDoc->m_fDataChanged = FALSE;

				/* OLE2NOTE: we must note the time of last change
				**    for our object in the RunningObjectTable.
				**    this is used as the basis to answer
				**    IOleObject::IsUpToDate. we only want to note
				**    the change time when an actual change takes
				**    place. we do NOT want to set it when we are
				**    notifying clients of ADVF_DATAONSTOP
				*/
				if (dwAdvf == 0)
					OleStdNoteObjectChangeTime(lpOleDoc->m_dwRegROT);

				if (lpServerDoc->m_lpDataAdviseHldr) {
					OLEDBG_BEGIN2("IDataAdviseHolder::SendOnDataChange called\r\n");
					lpServerDoc->m_lpDataAdviseHldr->lpVtbl->SendOnDataChange(
							lpServerDoc->m_lpDataAdviseHldr,
							(LPDATAOBJECT)&lpOleDoc->m_DataObject,
							0,
							dwAdvf
					);
					OLEDBG_END2

				}

#if defined( INPLACE_SVR )
				/* OLE2NOTE: if the ServerDoc is currently in-place UI active,
				**    then is it important to renegotiate the size for the
				**    in-place document window BEFORE sending OnDataChange
				**    (which will cause the window to repaint).
				*/
				if (lpServerDoc->m_fSizeChanged) {
					lpServerDoc->m_fSizeChanged = FALSE;
					if (lpServerDoc->m_fInPlaceActive)
						ServerDoc_UpdateInPlaceWindowOnExtentChange(lpServerDoc);
				}
#endif

				/* OLE2NOTE: we do NOT need to tell our pseudo objects to
				**    broadcast OnDataChange notification because
				**    they will do it automatically when an editing
				**    change in the document affects a PseudoObj.
				**    (see OutlineNameTable_AddLineUpdate,
				**         OutlineNameTable_DeleteLineUpdate,
				**    and  ServerNameTable_EditLineUpdate)
				*/

			} else {
				/* drawing is currently disabled. do not send
				**    notifications or call
				**    IOleInPlaceObject::OnPosRectChange until drawing
				**    is re-enabled.
				*/
			}
			break;

		case OLE_ONCLOSE:

			// inform clients that the document is shutting down

			if (lpServerDoc->m_lpOleAdviseHldr) {
				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnClose called\r\n");
				lpServerDoc->m_lpOleAdviseHldr->lpVtbl->SendOnClose(
						lpServerDoc->m_lpOleAdviseHldr
				);
				OLEDBG_END2
			}

			/* OLE2NOTE: we do NOT need to tell our pseudo objects to
			**    broadcast OnClose notification because they will do
			**    it automatically when the pseudo object is closed.
			**    (see PseudoObj_Close)
			*/

			break;

		case OLE_ONSAVE:

			// inform clients that the object has been saved

			OLEDBG_BEGIN3("ServerDoc_SendAdvise ONSAVE\r\n");

			if (lpServerDoc->m_lpOleAdviseHldr) {
				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnSave called\r\n");
				lpServerDoc->m_lpOleAdviseHldr->lpVtbl->SendOnSave(
						lpServerDoc->m_lpOleAdviseHldr
				);
				OLEDBG_END2
			}

			/* OLE2NOTE: inform any clients of pseudo objects
			**    within our document, that our document has been
			**    saved.
			*/
			ServerNameTable_InformAllPseudoObjectsDocSaved(
					(LPSERVERNAMETABLE)lpOutlineDoc->m_lpNameTable,
					lpmkDoc
			);
			OLEDBG_END3
			break;

		case OLE_ONRENAME:

			// inform clients that the object's name has changed

			OLEDBG_BEGIN3("ServerDoc_SendAdvise ONRENAME\r\n");

			if (lpmkDoc && lpServerDoc->m_lpOleAdviseHldr) {
				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnRename called\r\n");
				lpServerDoc->m_lpOleAdviseHldr->lpVtbl->SendOnRename(
						lpServerDoc->m_lpOleAdviseHldr,
						lpmkDoc
				);
				OLEDBG_END2
			}

			OLEDBG_END3
			break;
	}
}


/* ServerDoc_GetClassID
** --------------------
**    Return the class ID corresponding to the bits in the storage.
**    normally this will be our application's given CLSID. but if a
**    "TreateAs (aka. ActivateAs)" operation is taking place, then our
**    application needs to pretend to be the class of the object that
**    we are emulating. this is also the class that will be written
**    into the storage.
*/
HRESULT ServerDoc_GetClassID(LPSERVERDOC lpServerDoc, LPCLSID lpclsid)
{
#if defined( SVR_TREATAS )
	if (! IsEqualCLSID(&lpServerDoc->m_clsidTreatAs, &CLSID_NULL))
		*lpclsid = lpServerDoc->m_clsidTreatAs;
	else
#endif  // SVR_TREATAS
		*lpclsid = CLSID_APP;

	return NOERROR;
}



/* ServerDoc_UpdateMenu
 * --------------------
 *
 *  Update menu for embedding mode. the changes include:
 *      1 Remove File/New and File/Open (SDI ONLY)
 *      2 Change File/Save As.. to File/Save Copy As..
 *      3 Change File menu so it contains "Update" instead of "Save"
 *      4 Change File/Exit to File/Exit & Return to <client doc>"
 */
void ServerDoc_UpdateMenu(LPSERVERDOC lpServerDoc)
{
	char    str[256];
	HWND    hWndMain;
	HMENU   hMenu;
	OleDbgOut2("ServerDoc_UpdateMenu\r\n");

	hWndMain=g_lpApp->m_hWndApp;
	hMenu=GetMenu(hWndMain);

#if defined( SDI_VERSION )
	/* SDI ONLY: Remove File/New and File/Open */
	DeleteMenu(hMenu, IDM_F_NEW, MF_BYCOMMAND);
	DeleteMenu(hMenu, IDM_F_OPEN, MF_BYCOMMAND);
#endif

	// Change File.Save As.. to File.Save Copy As.. */
	ModifyMenu(hMenu,IDM_F_SAVEAS, MF_STRING, IDM_F_SAVEAS, "Save Copy As..");

	// Change File.Save to "&Update <container doc>"
	wsprintf(str, g_szUpdateCntrDoc, lpServerDoc->m_szContainerObj);
	ModifyMenu(hMenu, IDM_F_SAVE, MF_STRING, IDM_F_SAVE, str);

	// Change File/Exit to File/Exit & Return to <container doc>" */
	wsprintf(str, g_szExitNReturnToCntrDoc, lpServerDoc->m_szContainerObj);
	ModifyMenu(hMenu, IDM_F_EXIT, MF_STRING, IDM_F_EXIT, str);

	DrawMenuBar(hWndMain);
}

#if defined( MDI_VERSION )

// NOTE: ServerDoc_RestoreMenu is actually redundant because the
//          app is dying when the function is called.  (In SDI, the
//          app will terminate when the ref counter of the server doc
//          is zero). However, it is important for MDI.

/* ServerDoc_RestoreMenu
 * ---------------------
 *
 *      Reset the menu to non-embedding mode
 */
void ServerDoc_RestoreMenu(LPSERVERDOC lpServerDoc)
{
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	HWND            hWndMain;
	HMENU           hMenu;
	OleDbgOut2("ServerDoc_RestoreMenu\r\n");

	hWndMain = lpOutlineApp->m_hWndApp;
	hMenu = GetMenu(hWndMain);

	/* Add back File/New, File/Open.. and File/Save */
	InsertMenu(hMenu, IDM_F_SAVEAS, MF_BYCOMMAND | MF_ENABLED | MF_STRING,
		IDM_F_NEW, "&New");
	InsertMenu(hMenu, IDM_F_SAVEAS, MF_BYCOMMAND | MF_ENABLED | MF_STRING,
		IDM_F_OPEN, "&Open...");

	/* Change File menu so it contains "Save As..." instead of */
	/* "Save Copy As..." */
	ModifyMenu(hMenu, IDM_F_SAVEAS, MF_STRING, IDM_F_SAVEAS, "Save &As..");

	/* Change File menu so it contains "Save" instead of "Update" */
	ModifyMenu(hMenu, IDM_F_SAVE, MF_STRING, IDM_F_SAVE, "&Save");

	/* Change File menu so it contains "Exit" */
	/* instead of just "Exit & Return to <client doc>" */
	ModifyMenu(hMenu, IDM_F_EXIT, MF_STRING, IDM_F_EXIT, "E&xit");

	DrawMenuBar (hWndMain);
}

#endif  // MDI_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\svrinpl.c ===
/*************************************************************************
**
**    OLE 2 Server Sample Code
**
**    svrinpl.c
**
**    This file contains all interfaces, methods and related support
**    functions for an In-Place Object (Server) application (aka. Visual
**    Editing). The in-place Object application includes the following
**    implementation objects:
**
**    ServerDoc Object
**      exposed interfaces:
**          IOleInPlaceObject
**          IOleInPlaceActiveObject
**
**    ServerApp Object
**      exposed interfaces:
**          IUnknown
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP             g_lpApp;


/* OLE2NOTE: the object should compose a string that is used by
**    in-place containers to be used for the window titles. this string
**    is passed to the container application via
**    IOleInPlaceUIWindow::SetActiveObject. the string should have the
**    following form:
**          <application name> - <object short type name>
**    SDI containers can use the string directly to display in the
**    frame window title. the container would concatenate the string
**    " in <container doc name>".
**    an MDI container with the MDI child window maximized can do the
**    same as the SDI container. an MDI container with the MDI child
**    windows NOT maximized can look for the " - " in the string from
**    the object. the first part of the string (app name) would be put
**    as the frame window title; the second part would be composed with
**    " in <container doc name>" and used as the MDI child window
**    title.
*/

// REVIEW: should use string resource for messages
char g_szIPObjectTitle[] = APPNAME " - " SHORTUSERTYPENAME;

extern RECT g_rectNull;



/*************************************************************************
** ServerDoc::IOleInPlaceObject interface implementation
*************************************************************************/

// IOleInPlaceObject::QueryInterface method

STDMETHODIMP SvrDoc_IPObj_QueryInterface(
		LPOLEINPLACEOBJECT  lpThis,
		REFIID              riid,
		LPVOID FAR *        lplpvObj
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	return OleDoc_QueryInterface((LPOLEDOC)lpServerDoc, riid, lplpvObj);
}


// IOleInPlaceObject::AddRef method

STDMETHODIMP_(ULONG) SvrDoc_IPObj_AddRef(LPOLEINPLACEOBJECT lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OleDbgAddRefMethod(lpThis, "IOleInPlaceObject");

	return OleDoc_AddRef((LPOLEDOC)lpServerDoc);
}


// IOleInPlaceObject::Release method

STDMETHODIMP_(ULONG) SvrDoc_IPObj_Release(LPOLEINPLACEOBJECT lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OleDbgReleaseMethod(lpThis, "IOleInPlaceObject");

	return OleDoc_Release((LPOLEDOC)lpServerDoc);
}


// IOleInPlaceObject::GetWindow method

STDMETHODIMP SvrDoc_IPObj_GetWindow(
		LPOLEINPLACEOBJECT  lpThis,
		HWND FAR*           lphwnd
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OLEDBG_BEGIN2("SvrDoc_IPObj_GetWindow\r\n")

	*lphwnd = ((LPOUTLINEDOC)lpServerDoc)->m_hWndDoc;

	OLEDBG_END2
	return S_OK;
}


// IOleInPlaceObject::ContextSensitiveHelp method

STDMETHODIMP SvrDoc_IPObj_ContextSensitiveHelp(
		LPOLEINPLACEOBJECT  lpThis,
		BOOL                fEnable
)
{
	LPOLEDOC lpOleDoc =
			(LPOLEDOC)((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_IPObj_ContextSensitiveHelp\r\n");

	/* OLE2NOTE: see context sensitive help technote (CSHELP.DOC).
	**    This method is called when SHIFT-F1 context sensitive help is
	**    entered. the cursor should then change to a question mark
	**    cursor and the app should enter a modal state where the next
	**    mouse click does not perform its normal action but rather
	**    gives help corresponding to the location clicked. if the app
	**    does not implement a help system, it should at least eat the
	**    click and do nothing.
	*/
	lpOleDoc->m_fCSHelpMode = fEnable;

	return S_OK;
}


// IOleInPlaceObject::InPlaceDeactivate method

STDMETHODIMP SvrDoc_IPObj_InPlaceDeactivate(LPOLEINPLACEOBJECT lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	HRESULT hrErr;

	OLEDBG_BEGIN2("SvrDoc_IPObj_InPlaceDeactivate\r\n")

	hrErr = ServerDoc_DoInPlaceDeactivate(lpServerDoc);

	OLEDBG_END2
	return hrErr;
}


// IOleInPlaceObject::UIDeactivate method

STDMETHODIMP SvrDoc_IPObj_UIDeactivate(LPOLEINPLACEOBJECT lpThis)
{
	LPSERVERDOC     lpServerDoc =
						((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPSERVERAPP     lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
	LPLINELIST      lpLL = (LPLINELIST)&((LPOUTLINEDOC)lpServerDoc)->m_LineList;
	HWND            hWndApp = OutlineApp_GetWindow(g_lpApp);

	OLEDBG_BEGIN2("SvrDoc_IPObj_UIDeactivate\r\n");

	if (!lpServerDoc->m_fUIActive) {
		OLEDBG_END2
		return NOERROR;
	}

	lpServerDoc->m_fUIActive = FALSE;

	// Clip the hatch window to the size of pos rect so, that the object
	// adornments and hatch border will not be visible.
	ServerDoc_ResizeInPlaceWindow(lpServerDoc,
			(LPRECT)&(lpServerDoc->m_lpIPData->rcPosRect),
			(LPRECT)&(lpServerDoc->m_lpIPData->rcPosRect)
	);

	if (lpIPData->lpDoc)
		lpIPData->lpDoc->lpVtbl->SetActiveObject(lpIPData->lpDoc, NULL, NULL);

	if (lpIPData->lpFrame) {
		lpIPData->lpFrame->lpVtbl->SetActiveObject(
			lpIPData->lpFrame,
			NULL,
			NULL
		);
	}

#if defined( USE_FRAMETOOLS )
	/* OLE2NOTE: we must hide our frame tools here but NOT call
	**    IOleInPlaceFrame::SetBorderSpace(NULL) or SetMenu(NULL).
	**    we must hide our tools BEFORE calling
	**    IOleInPlaceSite::OnUIDeactivate. the container will put
	**    his menus and tools back when OnUIDeactivate is called.
	*/
	ServerDoc_RemoveFrameLevelTools(lpServerDoc);
#endif

	OLEDBG_BEGIN2("IOleInPlaceSite::OnUIDeactivate called\r\n");
	lpIPData->lpSite->lpVtbl->OnUIDeactivate(lpIPData->lpSite, FALSE);
	OLEDBG_END2

	/* Reset to use our normal app's accelerator table */
	g_lpApp->m_hAccelApp = lpServerApp->m_hAccelBaseApp;
	g_lpApp->m_hAccel = lpServerApp->m_hAccelBaseApp;
	g_lpApp->m_hWndAccelTarget = hWndApp;

	OLEDBG_END2

#if !defined( SVR_INSIDEOUT )
	/* OLE2NOTE: an "outside-in" style in-place server would hide its
	**    window here. an "inside-out" style server leaves its window
	**    visible when it is UIDeactivated. it would only hide its
	**    window when InPlaceDeactivated. this app is an "inside-out"
	**    style server. it is recommended for most server to support
	**    inside-out behavior if possible.
	*/
	ServerDoc_DoInPlaceHide(lpServerDoc);
#endif // INSIEDOUT

	return NOERROR;
}


// IOleInPlaceObject::SetObjectRects method

STDMETHODIMP SvrDoc_IPObj_SetObjectRects(
		LPOLEINPLACEOBJECT  lpThis,
		LPCRECT             lprcPosRect,
		LPCRECT             lprcClipRect
)
{
	LPSERVERDOC  lpServerDoc =
					((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPINPLACEDATA lpIPData = lpServerDoc->m_lpIPData;
	LPLINELIST   lpLL = OutlineDoc_GetLineList((LPOUTLINEDOC)lpServerDoc);
	OLEDBG_BEGIN2("SvrDoc_IPObj_SetObjectRects\r\n")

#if defined( _DEBUG )
	OleDbgOutRect3("SvrDoc_IPObj_SetObjectRects (PosRect)",
			(LPRECT)lprcPosRect);
	OleDbgOutRect3("SvrDoc_IPObj_SetObjectRects (ClipRect)",
			(LPRECT)lprcClipRect);
#endif
	// save the current PosRect and ClipRect
	lpIPData->rcPosRect = *lprcPosRect;
	lpIPData->rcClipRect = *lprcClipRect;

	if (! lpServerDoc->m_fUIActive) // hatch and adornaments must not be drawn
		lprcClipRect = lprcPosRect;

	ServerDoc_ResizeInPlaceWindow(
			lpServerDoc, (LPRECT)lprcPosRect, (LPRECT)lprcClipRect);

	OLEDBG_END2
	return NOERROR;
}


// IOleInPlaceObject::ReactivateAndUndo method

STDMETHODIMP SvrDoc_IPObj_ReactivateAndUndo(LPOLEINPLACEOBJECT lpThis)
{
	OLEDBG_BEGIN2("SvrDoc_IPObj_ReactivateAndUndo\r\n")

	// We do not support support UNDO.

	/* REVIEW: for debugging purposes it would be useful to give a
	**    message box indicating that this method has been called.
	*/

	OLEDBG_END2
	return NOERROR;
}


/*************************************************************************
** ServerDoc::IOleInPlaceActiveObject interface implementation
*************************************************************************/

// IOleInPlaceActiveObject::QueryInterface method

STDMETHODIMP SvrDoc_IPActiveObj_QueryInterface(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		REFIID                      riid,
		LPVOID FAR *                lplpvObj
)
{
	SCODE sc = E_NOINTERFACE;
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	/* The container should not be able to access the other interfaces
	** of our object by doing QI on this interface.
	*/

	*lplpvObj = NULL;
	if (IsEqualIID(riid, &IID_IUnknown) ||
		IsEqualIID(riid, &IID_IOleWindow) ||
		IsEqualIID(riid, &IID_IOleInPlaceActiveObject)) {
		OleDbgOut4("OleDoc_QueryInterface: IOleInPlaceActiveObject* RETURNED\r\n");

		*lplpvObj = lpThis;
		OleDoc_AddRef((LPOLEDOC)lpServerDoc);
		sc = NOERROR;
	}

	OleDbgQueryInterfaceMethod(*lplpvObj);

	return ResultFromScode(sc);
}


// IOleInPlaceActiveObject::AddRef method

STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_AddRef(
		LPOLEINPLACEACTIVEOBJECT lpThis
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OleDbgAddRefMethod(lpThis, "IOleInPlaceActiveObject");

	return OleDoc_AddRef((LPOLEDOC)lpServerDoc);
}


// IOleInPlaceActiveObject::Release method

STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_Release(
		LPOLEINPLACEACTIVEOBJECT lpThis
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OleDbgReleaseMethod(lpThis, "IOleInPlaceActiveObject");

	return OleDoc_Release((LPOLEDOC)lpServerDoc);
}


// IOleInPlaceActiveObject::GetWindow method

STDMETHODIMP SvrDoc_IPActiveObj_GetWindow(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		HWND FAR*                   lphwnd
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OLEDBG_BEGIN2("SvrDoc_IPActiveObj_GetWindow\r\n")

	*lphwnd = ((LPOUTLINEDOC)lpServerDoc)->m_hWndDoc;

	OLEDBG_END2
	return NOERROR;
}


// IOleInPlaceActiveObject::ContextSensitiveHelp method

STDMETHODIMP SvrDoc_IPActiveObj_ContextSensitiveHelp(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fEnterMode
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_IPActiveObj_ContextSensitiveHelp\r\n");

	/* OLE2NOTE: see context sensitive help technote (CSHELP.DOC)
	**    This method is called when F1 is pressed when a menu item is
	**    selected. this tells the in-place server application to give
	**    help rather than execute the next menu command. at a minimum,
	**    even if the in-place server application does not implement a
	**    help system, it should NOT execute the next command when
	**    fEnable==TRUE. We set the active object's m_fMenuMode flag here.
	**    later, in WM_COMMAND processing in the DocWndProc, if this
	**    flag is set then the command is NOT executed (and help could
	**    be given if we had a help system....but we don't.)
	*/
	lpServerDoc->m_fMenuHelpMode = fEnterMode;

#if !defined( HACK )
	((LPOLEDOC)lpServerDoc)->m_fCSHelpMode = fEnterMode;
#endif
	return NOERROR;
}


// IOleInPlaceActiveObject::TranslateAccelerator method

STDMETHODIMP SvrDoc_IPActiveObj_TranslateAccelerator(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		LPMSG                       lpmsg
)
{
	// This will never be called because this server is implemented as an EXE
	return NOERROR;
}


// IOleInPlaceActiveObject::OnFrameWindowActivate method

STDMETHODIMP SvrDoc_IPActiveObj_OnFrameWindowActivate(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fActivate
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	HWND hWndDoc = OutlineDoc_GetWindow(lpOutlineDoc);
#if defined( _DEBUG )
	if (fActivate)
		OleDbgOut2("SvrDoc_IPActiveObj_OnFrameWindowActivate(TRUE)\r\n");
	else
		OleDbgOut2("SvrDoc_IPActiveObj_OnFrameWindowActivate(FALSE)\r\n");
#endif  // _DEBUG

	/* OLE2NOTE: this is a notification of the container application's
	**    WM_ACTIVATEAPP status. some applications may find this
	**    important. we need to update the enable/disable status of our
	**    tool bar buttons.
	*/

	// OLE2NOTE: We can't call OutlineDoc_UpdateFrameToolButtons
	//           right away which
	//           would generate some OLE calls and eventually
	//           WM_ACTIVATEAPP and a loop was formed. Therefore, we
	//           should delay the frame tool initialization until
	//           WM_ACTIVATEAPP is finished by posting a message
	//           to ourselves.

	/* Update enable/disable state of buttons in toolbar */
	if (fActivate)
		PostMessage(hWndDoc, WM_U_INITFRAMETOOLS, 0, 0L);

	return NOERROR;
}


// IOleInPlaceActiveObject::OnDocWindowActivate method

STDMETHODIMP SvrDoc_IPActiveObj_OnDocWindowActivate(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fActivate
)
{
	LPSERVERDOC     lpServerDoc =
						((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
#if defined( _DEBUG )
	if (fActivate)
		OleDbgOut2("SvrDoc_IPActiveObj_OnDocWindowActivate(TRUE)\r\n");
	else
		OleDbgOut2("SvrDoc_IPActiveObj_OnDocWindowActivate(FALSE)\r\n");
#endif

	if (fActivate) {
		ServerDoc_AddFrameLevelUI(lpServerDoc);
	}
	else {
#if defined( USE_FRAMETOOLS )
		/* OLE2NOTE: we must NOT call IOleInPlaceFrame::SetBorderSpace(NULL)
		**    or SetMenu(NULL) here. we should simply hide our tools.
		*/
		ServerDoc_RemoveFrameLevelTools(lpServerDoc);
#endif
	}

	OLEDBG_END2
	return NOERROR;
}


// IOleInPlaceActiveObject::ResizeBorder method

STDMETHODIMP SvrDoc_IPActiveObj_ResizeBorder(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		LPCRECT                     lprectBorder,
		LPOLEINPLACEUIWINDOW        lpIPUiWnd,
		BOOL                        fFrameWindow
)
{
	LPSERVERDOC lpServerDoc =
					((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;

	OLEDBG_BEGIN2("SvrDoc_IPActiveObj_ResizeBorder\r\n")


#if defined( USE_FRAMETOOLS )

	if (fFrameWindow) {
		FrameTools_NegotiateForSpaceAndShow(
				lpOutlineDoc->m_lpFrameTools,
				(LPRECT)lprectBorder,
				(LPOLEINPLACEFRAME)lpIPUiWnd
		);
	}

#endif

	OLEDBG_END2
	return NOERROR;
}


// IOleInPlaceActiveObject::EnableModeless method

STDMETHODIMP SvrDoc_IPActiveObj_EnableModeless(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fEnable
)
{
#if defined( USE_FRAMETOOLS )
	LPSERVERDOC lpServerDoc =
				((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPFRAMETOOLS lptb;

	/* OLE2NOTE: we must enable/disable mouse and keyboard input to our
	**    floating tool palette
	*/
	if (lpOutlineDoc) {
		lptb = lpOutlineDoc->m_lpFrameTools;
		if (lptb)
			FrameTools_EnableWindow(lptb, fEnable);
	}
#endif  // USE_FRAMETOOLS

#if defined( _DEBUG )
	if (fEnable)
		OleDbgOut2("SvrDoc_IPActiveObj_EnableModeless(TRUE)\r\n");
	else
		OleDbgOut2("SvrDoc_IPActiveObj_EnableModeless(FALSE)\r\n");
#endif  // _DEBUG

	/* OLE2NOTE: this method is called when the top-level, in-place
	**    container puts up a modal dialog. it tells the UIActive
	**    object to disable it modeless dialogs for the duration that
	**    the container is displaying a modal dialog.
	**
	**    ISVROTL does not use any modeless dialogs, thus we can
	**    ignore this method.
	*/
	return NOERROR;
}


/*************************************************************************
** Support Functions
*************************************************************************/


HRESULT ServerDoc_DoInPlaceActivate(
		LPSERVERDOC     lpServerDoc,
		LONG            lVerb,
		LPMSG           lpmsg,
		LPOLECLIENTSITE lpActiveSite
)
{
	LPOUTLINEAPP            lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPSERVERAPP             lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOLEAPP                lpOleApp = (LPOLEAPP)g_lpApp;
	SCODE                   sc = E_FAIL;
	RECT                    rcPos;
	RECT                    rcClip;
	LPINPLACEDATA           lpIPData = lpServerDoc->m_lpIPData;
	LPOUTLINEDOC            lpOutlineDoc=(LPOUTLINEDOC)lpServerDoc;
	HWND                    hWndDoc = lpOutlineDoc->m_hWndDoc;
	HWND                    hWndHatch = lpServerDoc->m_hWndHatch;
	HRESULT                 hrErr;
	LPLINELIST              lpLL=(LPLINELIST)&lpOutlineDoc->m_LineList;
	LPOLEINPLACESITE    lpIPSite = NULL;

	/* OLE2NOTE: lpActiveSite should be used only for InPlace PLAYing.
	**    This app does not do inplace PLAYing, so it never uses
	**    lpActiveSite.
	*/

	/* InPlace activation can only be done if the ClientSite is non-NULL. */
	if (! lpServerDoc->m_lpOleClientSite)
		return NOERROR;

	if (! lpServerDoc->m_fInPlaceActive) {

		// if the object is in open mode then we do not want to do inplace
		// activation.
		if (IsWindowVisible(lpOutlineDoc->m_hWndDoc))
			return NOERROR;

		lpIPSite = (LPOLEINPLACESITE)OleStdQueryInterface(
				(LPUNKNOWN)lpServerDoc->m_lpOleClientSite,
				&IID_IOleInPlaceSite
		);

		if (! lpIPSite)
			goto errActivate;

		OLEDBG_BEGIN2("IOleInPlaceSite::CanInPlaceActivate called\r\n");
		hrErr = lpIPSite->lpVtbl->CanInPlaceActivate(lpIPSite);
		OLEDBG_END2
		if (hrErr != NOERROR)
			goto errActivate;

		lpServerDoc->m_fInPlaceActive = TRUE;
		OLEDBG_BEGIN2("IOleInPlaceSite::OnInPlaceActivate called\r\n");
		hrErr = lpIPSite->lpVtbl->OnInPlaceActivate(lpIPSite);
		OLEDBG_END2
		if (hrErr != NOERROR)
			goto errActivate;

		if (! ServerDoc_AllocInPlaceData(lpServerDoc)) {
			sc = E_OUTOFMEMORY;
			OLEDBG_BEGIN2("IOleInPlaceSite::OnInPlaceDeactivate called\r\n");
			lpIPSite->lpVtbl->OnInPlaceDeactivate(lpIPSite);
			OLEDBG_END2
			goto errActivate;
		}

		(lpIPData = lpServerDoc->m_lpIPData)->lpSite = lpIPSite;
		goto InPlaceActive;

	errActivate:
		lpServerDoc->m_fInPlaceActive = FALSE;
		if (lpIPSite)
			OleStdRelease((LPUNKNOWN)lpIPSite);
		return ResultFromScode(sc);
	}


InPlaceActive:

	if (! lpServerDoc->m_fInPlaceVisible) {
		lpServerDoc->m_fInPlaceVisible = TRUE;

		OLEDBG_BEGIN2("IOleInPlaceSite::GetWindow called\r\n");
		hrErr = lpIPData->lpSite->lpVtbl->GetWindow(
					lpIPData->lpSite, &lpServerDoc->m_hWndParent);
		OLEDBG_END2
		if (hrErr != NOERROR) {
			sc = GetScode(hrErr);
			goto errRtn;
		}

		if (! lpServerDoc->m_hWndParent)
			goto errRtn;

		/* OLE2NOTE: The server should fill in the "cb" field so that the
		**    container can tell what size structure the server is
		**    expecting. this enables this structure to be easily extended
		**    in future releases of OLE. the container should check this
		**    field so that it doesn't try to use fields that do not exist
		**    since the server may be using an old structure definition.
		*/
		_fmemset(
			(LPOLEINPLACEFRAMEINFO)&lpIPData->frameInfo,
			0,
			sizeof(OLEINPLACEFRAMEINFO)
		);
		lpIPData->frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);

		OLEDBG_BEGIN2("IOleInPlaceSite::GetWindowContext called\r\n");
		hrErr = lpIPData->lpSite->lpVtbl->GetWindowContext(lpIPData->lpSite,
					(LPOLEINPLACEFRAME FAR*) &lpIPData->lpFrame,
					(LPOLEINPLACEUIWINDOW FAR*)&lpIPData->lpDoc,
					(LPRECT)&rcPos,
					(LPRECT)&rcClip,
					(LPOLEINPLACEFRAMEINFO)&lpIPData->frameInfo);
		OLEDBG_END2

		if (hrErr != NOERROR) {
			sc = GetScode(hrErr);
			goto errRtn;
		}

		lpServerApp->m_lpIPData = lpIPData;
		ShowWindow(hWndDoc, SW_HIDE);   // make sure we are hidden

		/* OLE2NOTE: reparent in-place server document's window to the
		**    special in-place hatch border window. set the in-place site's
		**    window as the parent of the hatch window. position the
		**    in-place and hatch border windows using the PosRect and
		**    ClipRect.
		**    it is important to properly parent and position the in-place
		**    server window BEFORE calling IOleInPlaceFrame::SetMenu and
		**    SetBorderSpace.
		*/
		ShowWindow(lpServerDoc->m_hWndHatch, SW_SHOW);
		// make sure App busy/blocked dialogs are parented to our
		// new hWndFrame
		OleStdMsgFilter_SetParentWindow(
			lpOleApp->m_lpMsgFilter,lpIPData->frameInfo.hwndFrame);
		SetParent(lpServerDoc->m_hWndHatch, lpServerDoc->m_hWndParent);
		SetParent(hWndDoc, lpServerDoc->m_hWndHatch);

#if defined( _DEBUG )
		OleDbgOutRect3("IOleInPlaceSite::GetWindowContext (PosRect)",
				(LPRECT)&rcPos);
		OleDbgOutRect3("IOleInPlaceSite::GetWindowContext (ClipRect)",
				(LPRECT)&rcClip);
#endif
		// save the current PosRect and ClipRect
		lpIPData->rcPosRect  = rcPos;
		lpIPData->rcClipRect = rcClip;

		/* OLE2NOTE: build the shared menu for the in-place container and
		**    the server.
		*/
		if (ServerDoc_AssembleMenus (lpServerDoc) != NOERROR)
			goto errRtn;

#if defined( SVR_INSIDEOUT )
		if (lVerb == OLEIVERB_INPLACEACTIVATE) {
			// Clip the hatch window to the size of pos rect so, that
			// hatch and object adornments  will not be visible.
			ServerDoc_ResizeInPlaceWindow(lpServerDoc,
				(LPRECT)&(lpServerDoc->m_lpIPData->rcPosRect),
				(LPRECT)&(lpServerDoc->m_lpIPData->rcPosRect)
			);
		}
#endif  // SVR_INSIDEOUT
	}

#if defined( SVR_INSIDEOUT )
	// OLE2NOTE: if verb is OLEIVERB_INPLACEACTIVATE we do NOT want to
	// show our UI
	if (lVerb == OLEIVERB_INPLACEACTIVATE) {
		return NOERROR;
	}
#endif  // SVR_INSIDEOUT

	if (! lpServerDoc->m_fUIActive) {
		lpServerDoc->m_fUIActive = TRUE;
		OLEDBG_BEGIN2("IOleInPlaceSite::OnUIActivate called\r\n");
		hrErr = lpIPData->lpSite->lpVtbl->OnUIActivate(lpIPData->lpSite);
		OLEDBG_END2
		if (hrErr != NOERROR) {
			lpServerDoc->m_fUIActive = FALSE;
			goto errRtn;
		}

		SetFocus(hWndDoc);

		// Show the object adornments and hacth border around them.
		ServerDoc_ResizeInPlaceWindow(lpServerDoc,
					(LPRECT)&lpIPData->rcPosRect,
					(LPRECT)&lpIPData->rcClipRect
		);

		/* OLE2NOTE: IOleInPlaceFrame::SetActiveObject must be called BEFORE
		**    IOleInPlaceFrame::SetMenu.
		*/
		OLEDBG_BEGIN2("IOleInPlaceSite::SetActiveObject called\r\n");
		CallIOleInPlaceUIWindowSetActiveObjectA(
			(struct IOleInPlaceUIWindow *) lpIPData->lpFrame,
			(LPOLEINPLACEACTIVEOBJECT) &lpServerDoc->m_OleInPlaceActiveObject,
			(LPSTR)g_szIPObjectTitle
		);
		OLEDBG_END2

		/* OLE2NOTE: If the container wants to give ownership of the
		**    palette then he would sendmessage WM_QUEYNEWPALETTE to
		**    the object window proc, before returning from
		**    IOleInPlaceFrame::SetActiveObject. Those objects which
		**    want to be edited inplace only if they have the ownership of
		**    the palette, can check at this point in the code whether
		**    they got WM_QUERYNEWPALETTE or not. If they didn't get
		**    the message, then they can inplace deactivate and do open
		**    editing instead.
		*/



		if (lpIPData->lpDoc) {
			CallIOleInPlaceUIWindowSetActiveObjectA(
				lpIPData->lpDoc,
				(LPOLEINPLACEACTIVEOBJECT)&lpServerDoc->m_OleInPlaceActiveObject,
				(LPSTR)g_szIPObjectTitle
			);
		}

		/* OLE2NOTE: install the menu and frame-level tools on the in-place
		**    frame.
		*/
		ServerDoc_AddFrameLevelUI(lpServerDoc);
	}

	return NOERROR;

errRtn:
	ServerDoc_DoInPlaceDeactivate(lpServerDoc);
	return ResultFromScode(sc);
}



HRESULT ServerDoc_DoInPlaceDeactivate(LPSERVERDOC lpServerDoc)
{
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;

	if (!lpServerDoc->m_fInPlaceActive)
		return S_OK;

	lpServerDoc->m_fInPlaceActive = FALSE;

	SvrDoc_IPObj_UIDeactivate(
			(LPOLEINPLACEOBJECT)&lpServerDoc->m_OleInPlaceObject);

	/* OLE2NOTE: an inside-out style in-place server will
	**    NOT hide its window in UIDeactive (an outside-in
	**    style object will hide its window in UIDeactivate).
	**    thus, an inside-out server must explicitly hide
	**    its window in InPlaceDeactivate. it is ALSO important for an
	**    outside-in style object to call ServerDoc_DoInPlaceHide here
	**    BEFORE freeing the InPlaceData structure. it will be common
	**    for in-place containers to call IOleInPlaceObject::
	**    InPlaceDeactivate in their IOleInPlaceSite::OnUIDeactiate
	**    implementation.
	*/
	ServerDoc_DoInPlaceHide(lpServerDoc);

	OLEDBG_BEGIN2("IOleInPlaceSite::OnInPlaceDeactivate called\r\n");
	lpIPData->lpSite->lpVtbl->OnInPlaceDeactivate(lpIPData->lpSite);
	OLEDBG_END2

	OleStdRelease((LPUNKNOWN)lpIPData->lpSite);
	lpIPData->lpSite = NULL;

	ServerDoc_FreeInPlaceData(lpServerDoc);

	return NOERROR;
}


HRESULT ServerDoc_DoInPlaceHide(LPSERVERDOC lpServerDoc)
{
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp;
	HWND            hWndApp = OutlineApp_GetWindow(g_lpApp);

	if (! lpServerDoc->m_fInPlaceVisible)
		return NOERROR;

	// Set the parent back to server app's window
	OleDoc_HideWindow((LPOLEDOC)lpServerDoc, FALSE /* fShutdown */);

	/* we need to enusure that our window is set to normal 100% zoom.
	**    if the window is next shown in open mode it should start out
	**    at normal zoom factor. our window may have been set to a
	**    different zoom factor while it was in-place active.
	*/
	OutlineDoc_SetCurrentZoomCommand(lpOutlineDoc,IDM_V_ZOOM_100);

	lpServerDoc->m_fInPlaceVisible = FALSE;

	lpServerDoc->m_hWndParent = hWndApp;
	SetParent(
		lpOutlineDoc->m_hWndDoc,
		lpServerDoc->m_hWndParent
	);

	// make sure App busy/blocked dialogs are parented to our own hWndApp
	OleStdMsgFilter_SetParentWindow(lpOleApp->m_lpMsgFilter, hWndApp);

	// Hide the in-place hatch border window.
	ShowWindow(lpServerDoc->m_hWndHatch, SW_HIDE);

	ServerDoc_DisassembleMenus(lpServerDoc);

	/* we no longer need the IOleInPlaceFrame* or the doc's
	**    IOleInPlaceWindow* interface pointers.
	*/
	if (lpIPData->lpDoc) {
		OleStdRelease((LPUNKNOWN)lpIPData->lpDoc);
		lpIPData->lpDoc = NULL;
	}

	if (lpIPData->lpFrame) {
		OleStdRelease((LPUNKNOWN)lpIPData->lpFrame);
		lpIPData->lpFrame = NULL;
	}

	((LPSERVERAPP)g_lpApp)->m_lpIPData = NULL;

	return NOERROR;
}


BOOL ServerDoc_AllocInPlaceData(LPSERVERDOC lpServerDoc)
{
	LPINPLACEDATA   lpIPData;

	if (!(lpIPData = (LPINPLACEDATA) New(sizeof(INPLACEDATA))))
		return FALSE;

	lpIPData->lpFrame       = NULL;
	lpIPData->lpDoc         = NULL;
	lpIPData->lpSite        = NULL;
	lpIPData->hOlemenu      = NULL;
	lpIPData->hMenuShared   = NULL;

	lpServerDoc->m_lpIPData = lpIPData;
	return TRUE;
}


void ServerDoc_FreeInPlaceData(LPSERVERDOC lpServerDoc)
{
	Delete(lpServerDoc->m_lpIPData);
	lpServerDoc->m_lpIPData = NULL;
}


HRESULT ServerDoc_AssembleMenus(LPSERVERDOC lpServerDoc)
{
	HMENU           hMenuShared;
	LONG FAR*       lpWidths;
	UINT            uPosition;
	UINT            uPositionStart;
	LPSERVERAPP     lpServerApp = (LPSERVERAPP) g_lpApp;
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
	HRESULT         hresult;
	BOOL            fNoError = TRUE;

	lpWidths = lpIPData->menuGroupWidths.width;
	hMenuShared = CreateMenu();

	if (hMenuShared &&
		(hresult = lpIPData->lpFrame->lpVtbl->InsertMenus(
			lpIPData->lpFrame, hMenuShared,
			&lpIPData->menuGroupWidths)) == NOERROR) {

	   /* Insert EDIT group menus */

	   uPosition = (UINT)lpWidths[0]; /* # of menus in the FILE group */
	   uPositionStart = uPosition;

	   fNoError &= InsertMenu(
			   hMenuShared,
			   (UINT)uPosition,
			   (UINT)(MF_BYPOSITION | MF_POPUP),
			   (UINT)lpServerApp->m_hMenuEdit,
			   (LPCSTR)"&Edit"
	   );
	   uPosition++;

	   lpWidths[1] = uPosition - uPositionStart;

	   /* Insert OBJECT group menus */

	   uPosition += (UINT)lpWidths[2];
	   uPositionStart = uPosition;

	   fNoError &= InsertMenu(
			   hMenuShared,
			   (UINT)uPosition,
			   (UINT)(MF_BYPOSITION | MF_POPUP),
			   (UINT)lpServerApp->m_hMenuLine,
			   (LPCSTR)"&Line"
	   );
	   uPosition++;

	   fNoError &= InsertMenu(
			   hMenuShared,
			   (UINT)uPosition,
			   (UINT)(MF_BYPOSITION | MF_POPUP),
			   (UINT)lpServerApp->m_hMenuName,
			   (LPCSTR)"&Name"
	   );
	   uPosition++;

	   fNoError &= InsertMenu(
			   hMenuShared,
			   (UINT)uPosition,
			   (UINT)(MF_BYPOSITION | MF_POPUP),
			   (UINT)lpServerApp->m_hMenuOptions,
			   (LPCSTR)"&Options"
	   );
	   uPosition++;

	   fNoError &= InsertMenu(
			   hMenuShared,
			   (UINT)uPosition,
			   (UINT)(MF_BYPOSITION | MF_POPUP),
			   (UINT)lpServerApp->m_hMenuDebug,
			   (LPCSTR)"DbgI&Svr"
		);
		uPosition++;

		lpWidths[3] = uPosition - uPositionStart;

		/* Insert HELP group menus */

		uPosition += (UINT) lpWidths[4]; /* # of menus in WINDOW group */
		uPositionStart = uPosition;

		fNoError &= InsertMenu(
				hMenuShared,
				(UINT)uPosition,
				(UINT)(MF_BYPOSITION | MF_POPUP),
				(UINT)lpServerApp->m_hMenuHelp,
				(LPCSTR)"&Help"
		);
		uPosition++;

		lpWidths[5] = uPosition - uPositionStart;

		OleDbgAssert(fNoError == TRUE);

	} else {
		/* In-place container does not allow us to add menus to the
		**    frame.
		** OLE2NOTE: even when the in-place container does NOT allow
		**    the building of a merged menu bar, it is CRITICAL that
		**    the in-place server still call OleCreateMenuDescriptor
		**    passing NULL for hMenuShared.
		*/
		if (hMenuShared) {
			DestroyMenu(hMenuShared);
			hMenuShared = NULL;
		}
	}

	lpIPData->hMenuShared = hMenuShared;

	if (!(lpIPData->hOlemenu = OleCreateMenuDescriptor(hMenuShared,
											&lpIPData->menuGroupWidths)))
		return ResultFromScode(E_OUTOFMEMORY);

	return NOERROR;
}


void ServerDoc_DisassembleMenus(LPSERVERDOC lpServerDoc)
{
	UINT             uCount;
	UINT            uGroup;
	UINT            uDeleteAt;
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
	LONG FAR*       lpWidths = lpIPData->menuGroupWidths.width;
	BOOL            fNoError = TRUE;

	/* OLE2NOTE: even when hMenuShared is NULL (ie. the server has no
	**    Menu), there is still an hOleMenu created that must be destroyed.
	*/
	if (lpIPData->hOlemenu) {
		OleDestroyMenuDescriptor (lpIPData->hOlemenu);
		lpIPData->hOlemenu = NULL;
	}

	if (! lpIPData->hMenuShared)
		return;     // no menus to be destroyed

	/* Remove server group menus. */
	uDeleteAt = 0;
	for (uGroup = 0; uGroup < 6; uGroup++) {
		uDeleteAt += (UINT)lpWidths[uGroup++];
		for (uCount = 0; uCount < (UINT)lpWidths[uGroup]; uCount++)
			fNoError &= RemoveMenu(lpIPData->hMenuShared, uDeleteAt,
								MF_BYPOSITION);
	}

	/* Remove container group menus */
	fNoError &= (lpIPData->lpFrame->lpVtbl->RemoveMenus(
		lpIPData->lpFrame,
		lpIPData->hMenuShared) == NOERROR);

	OleDbgAssert(fNoError == TRUE);

	DestroyMenu(lpIPData->hMenuShared);
	lpIPData->hMenuShared = NULL;
}


/* ServerDoc_UpdateInPlaceWindowOnExtentChange
** -------------------------------------------
**    The size of the in-place window needs to be changed.
**    calculate the size required in Client coordinates (taking into
**    account the current scale factor imposed by the in-place
**    container) and ask our in-place container to allow us to resize.
**    our container must call us back via
**    IOleInPlaceObject::SetObjectRects for the actual sizing to take
**    place.
**
**    OLE2NOTE: the rectangle that we ask for from our in-place
**    container is always the rectangle required for the object display
**    itself (in our case the size of the LineList contents). it does
**    NOT include the space we require for object frame adornments.
*/
void ServerDoc_UpdateInPlaceWindowOnExtentChange(LPSERVERDOC lpServerDoc)
{
	SIZEL       sizelHim;
	SIZEL       sizelPix;
	RECT        rcPosRect;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPLINELIST  lpLL=(LPLINELIST)&lpOutlineDoc->m_LineList;
	HWND        hWndLL = lpLL->m_hWndListBox;
	LPSCALEFACTOR lpscale = (LPSCALEFACTOR)&lpOutlineDoc->m_scale;

	if (!lpServerDoc->m_fInPlaceActive)
		return;

	OleDoc_GetExtent((LPOLEDOC)lpServerDoc, (LPSIZEL)&sizelHim);

	// apply current scale factor
	sizelHim.cx = sizelHim.cx * lpscale->dwSxN / lpscale->dwSxD;
	sizelHim.cy = sizelHim.cy * lpscale->dwSxN / lpscale->dwSxD;
	XformSizeInHimetricToPixels(NULL, (LPSIZEL)&sizelHim, (LPSIZEL)&sizelPix);

	GetWindowRect(hWndLL, (LPRECT)&rcPosRect);
	ScreenToClient(lpServerDoc->m_hWndParent, (POINT FAR *)&rcPosRect);

	rcPosRect.right = rcPosRect.left + (int) sizelPix.cx;
	rcPosRect.bottom = rcPosRect.top + (int) sizelPix.cy;
	OleDbgOutRect3("ServerDoc_UpdateInPlaceWindowOnExtentChange: (PosRect)", (LPRECT)&rcPosRect);

	OLEDBG_BEGIN2("IOleInPlaceSite::OnPosRectChange called\r\n");
	lpServerDoc->m_lpIPData->lpSite->lpVtbl->OnPosRectChange(
			lpServerDoc->m_lpIPData->lpSite,
			(LPRECT) &rcPosRect
	);
	OLEDBG_END2
}


/* ServerDoc_CalcInPlaceWindowPos
 * ------------------------------
 *
 *  Move (and re-scale) the ServerDoc to the specified rectangle.
 *
 *  Parameters:
 *      lprcListBox - rect in client coordinate in which the listbox will fit
 *      lprcDoc     - corresponding size of the Doc in client coordinate
 *
 */
void ServerDoc_CalcInPlaceWindowPos(
		LPSERVERDOC         lpServerDoc,
		LPRECT              lprcListBox,
		LPRECT              lprcDoc,
		LPSCALEFACTOR       lpscale
)
{
	SIZEL sizelHim;
	SIZEL sizelPix;
	LPLINELIST lpLL;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPHEADING lphead;

	if (!lpServerDoc || !lprcListBox || !lprcDoc)
		return;

	lphead = (LPHEADING)&lpOutlineDoc->m_heading;

	lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	OleDoc_GetExtent((LPOLEDOC)lpServerDoc, (LPSIZEL)&sizelHim);
	XformSizeInHimetricToPixels(NULL, &sizelHim, &sizelPix);

	if (sizelHim.cx == 0 || sizelPix.cx == 0) {
		lpscale->dwSxN = 1;
		lpscale->dwSxD = 1;
	} else {
		lpscale->dwSxN = lprcListBox->right - lprcListBox->left;
		lpscale->dwSxD = sizelPix.cx;
	}

	if (sizelHim.cy == 0 || sizelPix.cy == 0) {
		lpscale->dwSyN = 1;
		lpscale->dwSyD = 1;
	} else {
		lpscale->dwSyN = lprcListBox->bottom - lprcListBox->top;
		lpscale->dwSyD = sizelPix.cy;
	}

	lprcDoc->left = lprcListBox->left - Heading_RH_GetWidth(lphead,lpscale);
	lprcDoc->right = lprcListBox->right;
	lprcDoc->top = lprcListBox->top - Heading_CH_GetHeight(lphead,lpscale);
	lprcDoc->bottom = lprcListBox->bottom;
}


/* ServerDoc_ResizeInPlaceWindow
** -----------------------------
**    Actually resize the in-place ServerDoc windows according to the
**    PosRect and ClipRect allowed by our in-place container.
**
**    OLE2NOTE: the PosRect rectangle that our in-place container tells
**    us is always the rectangle required for the object display
**    itself (in our case the size of the LineList contents). it does
**    NOT include the space we require for object frame adornments.
*/
void ServerDoc_ResizeInPlaceWindow(
		LPSERVERDOC         lpServerDoc,
		LPCRECT             lprcPosRect,
		LPCRECT             lprcClipRect
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPLINELIST   lpLL = (LPLINELIST)&lpOutlineDoc->m_LineList;
	SCALEFACTOR  scale;
	RECT         rcDoc;
	POINT        ptOffset;

	/* OLE2NOTE: calculate the space needed for our object frame
	**    adornments. our in-place container tells us the size that our
	**    object should take in window client coordinates
	**    (lprcPosRect). the rectangle cooresponds to the size that our
	**    LineList ListBox should be. our Doc window must the correct
	**    amount larger to accomodate our row/column headings.
	**    then move all windows into position.
	*/
	ServerDoc_CalcInPlaceWindowPos(
			lpServerDoc,
			(LPRECT)lprcPosRect,
			(LPRECT)&rcDoc,
			(LPSCALEFACTOR)&scale
	);

	/* OLE2NOTE: we need to honor the lprcClipRect specified by our
	**    in-place container. we must NOT draw outside of the ClipRect.
	**    in order to achieve this, we will size the hatch window to be
	**    exactly the size that should be visible (rcVisRect). the
	**    rcVisRect is defined as the intersection of the full size of
	**    the in-place server window and the lprcClipRect.
	**    the ClipRect could infact clip the HatchRect on the
	**    right/bottom and/or on the top/left. if it is clipped on the
	**    right/bottom then it is sufficient to simply resize the hatch
	**    window. but if the HatchRect is clipped on the top/left then
	**    we must "move" the ServerDoc window (child of HatchWindow) by
	**    the delta that was clipped. the window origin of the
	**    ServerDoc window will then have negative coordinates relative
	**    to its parent HatchWindow.
	*/
	SetHatchWindowSize(
			lpServerDoc->m_hWndHatch,
			(LPRECT)&rcDoc,
			(LPRECT)lprcClipRect,
			(LPPOINT)&ptOffset
	);

	// shift Doc window to account for hatch frame being drawn
	OffsetRect((LPRECT)&rcDoc, ptOffset.x, ptOffset.y);

	// move/size/set scale factor of ServerDoc window.
	OutlineDoc_SetScaleFactor(
			lpOutlineDoc, (LPSCALEFACTOR)&scale, (LPRECT)&rcDoc);

	/* reset the horizontal extent of the listbox. this makes
	**    the listbox realize that a scroll bar is not needed.
	*/
	SendMessage(
			lpLL->m_hWndListBox,
			LB_SETHORIZONTALEXTENT,
			(int) 0,
			0L
	);
	SendMessage(
			lpLL->m_hWndListBox,
			LB_SETHORIZONTALEXTENT,
			(int) (lprcPosRect->right - lprcPosRect->left),
			0L
	);
}


/* ServerDoc_SetStatusText
**    Tell the active in-place frame to display a status message.
*/
void ServerDoc_SetStatusText(LPSERVERDOC lpServerDoc, LPSTR lpszMessage)
{
	if (lpServerDoc && lpServerDoc->m_fUIActive &&
		lpServerDoc->m_lpIPData != NULL) {

		OLEDBG_BEGIN2("IOleInPlaceFrame::SetStatusText called\r\n")
		CallIOleInPlaceFrameSetStatusTextA
			(lpServerDoc->m_lpIPData->lpFrame, lpszMessage);
		OLEDBG_END2
	}
}


/* ServerDoc_GetTopInPlaceFrame
** ----------------------------
**    returns NON-AddRef'ed pointer to Top In-Place Frame interface
*/
LPOLEINPLACEFRAME ServerDoc_GetTopInPlaceFrame(LPSERVERDOC lpServerDoc)
{
	if (lpServerDoc->m_lpIPData)
		return lpServerDoc->m_lpIPData->lpFrame;
	else
		return NULL;
}

void ServerDoc_GetSharedMenuHandles(
		LPSERVERDOC lpServerDoc,
		HMENU FAR*      lphSharedMenu,
		HOLEMENU FAR*   lphOleMenu
)
{
	if (lpServerDoc->m_lpIPData) {
		*lphSharedMenu = lpServerDoc->m_lpIPData->hMenuShared;
		*lphOleMenu = lpServerDoc->m_lpIPData->hOlemenu;
	} else {
		*lphSharedMenu = NULL;
		*lphOleMenu = NULL;
	}
}


void ServerDoc_AddFrameLevelUI(LPSERVERDOC lpServerDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPOLEINPLACEFRAME lpTopIPFrame=ServerDoc_GetTopInPlaceFrame(lpServerDoc);
	HMENU           hSharedMenu;            // combined obj/cntr menu
	HOLEMENU        hOleMenu;               // returned by OleCreateMenuDesc.

	ServerDoc_GetSharedMenuHandles(
			lpServerDoc,
			&hSharedMenu,
			&hOleMenu
	);

	lpTopIPFrame->lpVtbl->SetMenu(
			lpTopIPFrame,
			hSharedMenu,
			hOleMenu,
			lpOutlineDoc->m_hWndDoc
	);

	// save normal accelerator table
	lpServerApp->m_hAccelBaseApp = lpOutlineApp->m_hAccelApp;

	// install accelerator table for UIActive server (w/ active editor cmds)
	lpOutlineApp->m_hAccel = lpServerApp->m_hAccelIPSvr;
	lpOutlineApp->m_hAccelApp = lpServerApp->m_hAccelIPSvr;
	lpOutlineApp->m_hWndAccelTarget = lpOutlineDoc->m_hWndDoc;

#if defined( USE_FRAMETOOLS )
	ServerDoc_AddFrameLevelTools(lpServerDoc);

	// update toolbar button enable states
	OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
#endif
}


void ServerDoc_AddFrameLevelTools(LPSERVERDOC lpServerDoc)
{
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPSERVERAPP     lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPOLEINPLACEFRAME lpTopIPFrame=ServerDoc_GetTopInPlaceFrame(lpServerDoc);

#if defined( USE_FRAMETOOLS )
	HWND            hWndFrame;

	FrameTools_Enable(lpOutlineDoc->m_lpFrameTools, TRUE);

	// if not in-place UI active, add our tools to our own frame.
	if (! lpServerDoc->m_fUIActive) {
		OutlineDoc_AddFrameLevelTools(lpOutlineDoc);
		return;
	}

	if ((hWndFrame = OutlineApp_GetFrameWindow(lpOutlineApp)) == NULL) {
		/* we could NOT get a valid frame window, so POP our tools up. */

		/* OLE2NOTE: since we are poping up our tools, we MUST inform
		**    the top in-place frame window that we need NO tool space
		**    BUT that it should NOT put its own tools up. if we were
		**    to pass NULL instead of (0,0,0,0), then the container
		**    would have the option to leave its own tools up.
		*/
		lpTopIPFrame->lpVtbl->SetBorderSpace(
				lpTopIPFrame,
				(LPCBORDERWIDTHS)&g_rectNull
		);
		FrameTools_PopupTools(lpOutlineDoc->m_lpFrameTools);
	} else {

		/* OLE2NOTE: we need to negotiate for space and attach our frame
		**    level tools to the top-level in-place container's frame window.
		*/
		FrameTools_AttachToFrame(lpOutlineDoc->m_lpFrameTools, hWndFrame);

		FrameTools_NegotiateForSpaceAndShow(
				lpOutlineDoc->m_lpFrameTools,
				NULL,
				lpTopIPFrame
		);
	}

#else   // ! USE_FRAMETOOLS
	/* OLE2NOTE: if you do NOT use frame tools, you MUST inform the top
	**    in-place frame window so that it can put back its own tools.
	*/
	lpTopIPFrame->lpVtbl->SetBorderSpace(lpIPData->lpFrame, NULL);
#endif  // ! USE_FRAMETOOLS
}


#if defined( USE_FRAMETOOLS )

void ServerDoc_RemoveFrameLevelTools(LPSERVERDOC lpServerDoc)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	OleDbgAssert(lpOutlineDoc->m_lpFrameTools != NULL);

    // Reparent our tools back to one of our own windows
    FrameTools_AttachToFrame(lpOutlineDoc->m_lpFrameTools,g_lpApp->m_hWndApp);

	FrameTools_Enable(lpOutlineDoc->m_lpFrameTools, FALSE);
}
#endif  // USE_FRAMETOOLS



void ServerDoc_UIActivate (LPSERVERDOC lpServerDoc)
{
	if (lpServerDoc->m_fInPlaceActive && !lpServerDoc->m_fUIActive) {
		ServerDoc_DoInPlaceActivate(lpServerDoc,
				OLEIVERB_UIACTIVATE,
				NULL /*lpmsg*/,
				lpServerDoc->m_lpOleClientSite
		);
		OutlineDoc_ShowWindow((LPOUTLINEDOC)lpServerDoc);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\cntroutl\daytona\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\svroutl.h ===
/*************************************************************************
**
**    OLE 2.0 Server Sample Code
**
**    svroutl.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. used by the OLE 2.0 server
**    app version of the Outline series of sample applications:
**          Outline -- base version of the app (without OLE functionality)
**          SvrOutl -- OLE 2.0 Server sample app
**          CntrOutl -- OLE 2.0 Containter sample app
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#if !defined( _SVROUTL_H_ )
#define _SVROUTL_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING SVROUTL.H from " __FILE__)
#endif  /* RC_INVOKED */

#include "oleoutl.h"

/* Defines */

// Enable SVROUTL and ISVROTL to emulate each other (TreatAs aka. ActivateAs)
#define SVR_TREATAS     1

// Enable SVROUTL and ISVROTL to convert each other (TreatAs aka. ActivateAs)
#define SVR_CONVERTTO   1

// Enable ISVROTL to operate as in inside-out style in-place object
#define SVR_INSIDEOUT   1

/* Default name used for container of the embedded object. used if
**    container forgets to call IOleObject::SetHostNames
*/
// REVIEW: should load from string resource
#define DEFCONTAINERNAME    "Unknown Document"

/* Default prefix for auto-generated range names. This is used with
**    links to unnamed ranges (pseudo objects).
*/
// REVIEW: should load from string resource
#define DEFRANGENAMEPREFIX  "Range"

// Maximum length of strings accepted through IOleObject::SetHostNames
//      (note: this is rather arbitrary; a better strategy would be to
//             dynamically allocated buffers for these strings.)
#define MAXAPPNAME  80
#define MAXCONTAINERNAME    80

// Menu option in embedding mode
#define IDM_F_UPDATE    1151

/* Types */

/* Codes for CallBack events */
typedef enum tagOLE_NOTIFICATION {
	OLE_ONDATACHANGE,        // 0
	OLE_ONSAVE,              // 1
	OLE_ONRENAME,            // 2
	OLE_ONCLOSE              // 3
} OLE_NOTIFICATION;

/* Codes to indicate mode of storage for an object.
**    Mode of the storage is modified by the IPersistStorage methods:
**      Save, HandsOffStorage, and SaveCompleted.
*/
typedef enum tagSTGMODE {
	STGMODE_NORMAL      = 0,
	STGMODE_NOSCRIBBLE  = 1,
	STGMODE_HANDSOFF    = 2
} STGMODE;


/* Forward type definitions */
typedef struct tagSERVERAPP FAR* LPSERVERAPP;
typedef struct tagSERVERDOC FAR* LPSERVERDOC;
typedef struct tagPSEUDOOBJ FAR* LPPSEUDOOBJ;

typedef struct tagINPLACEDATA {
	OLEMENUGROUPWIDTHS      menuGroupWidths;
	HOLEMENU                hOlemenu;
	HMENU                   hMenuShared;
	LPOLEINPLACESITE        lpSite;
	LPOLEINPLACEUIWINDOW    lpDoc;
	LPOLEINPLACEFRAME       lpFrame;
	OLEINPLACEFRAMEINFO     frameInfo;
	HWND                    hWndFrame;
	BOOL                    fBorderOn;
	RECT                    rcPosRect;
	RECT                    rcClipRect;
} INPLACEDATA, FAR* LPINPLACEDATA;


/*************************************************************************
** class SERVERDOC : OLEDOC
**    SERVERDOC is an extention to the abstract base OLEDOC class.
**    The OLEDOC class defines the fields, methods and interfaces that
**    are common to both server and client implementations. The
**    SERVERDOC class adds the fields, methods and interfaces that are
**    specific to OLE 2.0 Server functionality. There is one instance
**    of SERVERDOC object created per document open in the app. The SDI
**    version of the app supports one SERVERDOC at a time. The MDI
**    version of the app can manage multiple documents at one time.
**    The SERVERDOC class inherits all fields from the OLEDOC class.
**    This inheritance is achieved by including a member variable of
**    type OLEDOC as the first field in the SERVERDOC structure. Thus a
**    pointer to a SERVERDOC object can be cast to be a pointer to a
**    OLEDOC object or an OUTLINEDOC object
*************************************************************************/

typedef struct tagSERVERDOC {
	OLEDOC              m_OleDoc;           // ServerDoc inherits from OleDoc
	ULONG               m_cPseudoObj;       // total count of pseudo obj's
	LPOLECLIENTSITE     m_lpOleClientSite;  // Client associated with the obj
	LPOLEADVISEHOLDER   m_lpOleAdviseHldr;  // helper obj to hold ole advises
	LPDATAADVISEHOLDER  m_lpDataAdviseHldr; // helper obj to hold data advises
	BOOL                m_fNoScribbleMode;  // was IPS::Save called
	BOOL                m_fSaveWithSameAsLoad;  // was IPS::Save called with
											// fSameAsLoad==TRUE.
	char                m_szContainerApp[MAXAPPNAME];
	char                m_szContainerObj[MAXCONTAINERNAME];
	ULONG               m_nNextRangeNo;     // next no. for unnamed range
	LINERANGE           m_lrSrcSelOfCopy;   // src sel if doc created for copy
	BOOL                m_fDataChanged;     // data changed when draw disabled
	BOOL                m_fSizeChanged;     // size changed when draw disabled
	BOOL                m_fSendDataOnStop;  // did data ever change?
#if defined( SVR_TREATAS )
	CLSID               m_clsidTreatAs;     // clsid to pretend to be
	LPSTR               m_lpszTreatAsType;  // user type name to pretend to be
#endif  // SVR_TREATAS

#if defined( LATER )
	// REVIEW: is it necessary to register a WildCard Moniker
	DWORD               m_dwWildCardRegROT; // key if wildcard reg'ed in ROT
#endif

#if defined( INPLACE_SVR )
	BOOL                m_fInPlaceActive;
	BOOL                m_fInPlaceVisible;
	BOOL                m_fUIActive;
	HWND                m_hWndParent;
	HWND                m_hWndHatch;
	LPINPLACEDATA       m_lpIPData;
	BOOL                m_fMenuHelpMode;// is F1 pressed in menu, give help

	struct CDocOleInPlaceObjectImpl {
		IOleInPlaceObjectVtbl FAR*  lpVtbl;
		LPSERVERDOC                 lpServerDoc;
		int                         cRef;   // interface specific ref count.
	} m_OleInPlaceObject;

	struct CDocOleInPlaceActiveObjectImpl {
		IOleInPlaceActiveObjectVtbl FAR* lpVtbl;
		LPSERVERDOC                      lpServerDoc;
		int                              cRef;// interface specific ref count.
	} m_OleInPlaceActiveObject;
#endif // INPLACE_SVR

	struct CDocOleObjectImpl {
		IOleObjectVtbl FAR*         lpVtbl;
		LPSERVERDOC                 lpServerDoc;
		int                         cRef;   // interface specific ref count.
	} m_OleObject;

	struct CDocPersistStorageImpl {
		IPersistStorageVtbl FAR*    lpVtbl;
		LPSERVERDOC                 lpServerDoc;
		int                         cRef;   // interface specific ref count.
	} m_PersistStorage;

#if defined( SVR_TREATAS )
	struct CDocStdMarshalInfoImpl {
		IStdMarshalInfoVtbl FAR*    lpVtbl;
		LPSERVERDOC                 lpServerDoc;
		int                         cRef;   // interface specific ref count.
	} m_StdMarshalInfo;
#endif  // SVR_TREATAS

} SERVERDOC;

/* ServerDoc methods (functions) */
BOOL ServerDoc_Init(LPSERVERDOC lpServerDoc, BOOL fDataTransferDoc);
BOOL ServerDoc_InitNewEmbed(LPSERVERDOC lpServerDoc);
void ServerDoc_PseudoObjUnlockDoc(
		LPSERVERDOC         lpServerDoc,
		LPPSEUDOOBJ         lpPseudoObj
);
void ServerDoc_PseudoObjLockDoc(LPSERVERDOC lpServerDoc);
BOOL ServerDoc_PasteFormatFromData(
		LPSERVERDOC             lpServerDoc,
		CLIPFORMAT              cfFormat,
		LPDATAOBJECT            lpSrcDataObj,
		BOOL                    fLocalDataObj,
		BOOL                    fLink
);
BOOL ServerDoc_QueryPasteFromData(
		LPSERVERDOC             lpServerDoc,
		LPDATAOBJECT            lpSrcDataObj,
		BOOL                    fLink
);
HRESULT ServerDoc_GetClassID(LPSERVERDOC lpServerDoc, LPCLSID lpclsid);
void ServerDoc_UpdateMenu(LPSERVERDOC lpServerDoc);
void ServerDoc_RestoreMenu(LPSERVERDOC lpServerDoc);
HRESULT ServerDoc_GetData (
		LPSERVERDOC             lpServerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpMedium
);
HRESULT ServerDoc_GetDataHere (
		LPSERVERDOC             lpServerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpMedium
);
HRESULT ServerDoc_QueryGetData(LPSERVERDOC lpServerDoc,LPFORMATETC lpformatetc);
HRESULT ServerDoc_EnumFormatEtc(
		LPSERVERDOC             lpServerDoc,
		DWORD                   dwDirection,
		LPENUMFORMATETC FAR*    lplpenumFormatEtc
);
HANDLE ServerDoc_GetMetafilePictData(
		LPSERVERDOC             lpServerDoc,
		LPLINERANGE             lplrSel
);
void ServerDoc_SendAdvise(
		LPSERVERDOC     lpServerDoc,
		WORD            wAdvise,
		LPMONIKER       lpmkDoc,
		DWORD           dwAdvf
);
HRESULT ServerDoc_GetObject(
		LPSERVERDOC             lpServerDoc,
		LPOLESTR		lpszItem,
		REFIID                  riid,
		LPVOID FAR*             lplpvObject
);
HRESULT ServerDoc_IsRunning(LPSERVERDOC lpServerDoc, LPOLESTR lpszItem);
LPMONIKER ServerDoc_GetSelRelMoniker(
		LPSERVERDOC             lpServerDoc,
		LPLINERANGE             lplrSel,
		DWORD                   dwAssign
);
LPMONIKER ServerDoc_GetSelFullMoniker(
		LPSERVERDOC             lpServerDoc,
		LPLINERANGE             lplrSel,
		DWORD                   dwAssign
);


#if defined( INPLACE_SVR )
HRESULT ServerDoc_DoInPlaceActivate(
		LPSERVERDOC     lpServerDoc,
		LONG            lVerb,
		LPMSG           lpmsg,
		LPOLECLIENTSITE lpActiveSite
);
HRESULT ServerDoc_DoInPlaceDeactivate(LPSERVERDOC lpServerDoc);
HRESULT ServerDoc_DoInPlaceHide(LPSERVERDOC lpServerDoc);
BOOL ServerDoc_AllocInPlaceData(LPSERVERDOC lpServerDoc);
void ServerDoc_FreeInPlaceData(LPSERVERDOC lpServerDoc);

HRESULT ServerDoc_AssembleMenus(LPSERVERDOC lpServerDoc);
void    ServerDoc_DisassembleMenus(LPSERVERDOC lpServerDoc);
void ServerDoc_CalcInPlaceWindowPos(
		LPSERVERDOC         lpServerDoc,
		LPRECT              lprcListBox,
		LPRECT              lprcDoc,
		LPSCALEFACTOR       lpscale
);
void ServerDoc_UpdateInPlaceWindowOnExtentChange(LPSERVERDOC lpServerDoc);
void ServerDoc_ResizeInPlaceWindow(
		LPSERVERDOC         lpServerDoc,
		LPCRECT             lprcPosRect,
		LPCRECT             lprcClipRect
);
void ServerDoc_ShadeInPlaceBorder(LPSERVERDOC lpServerDoc, BOOL fShadeOn);
void ServerDoc_SetStatusText(LPSERVERDOC lpServerDoc, LPSTR lpszMessage);
LPOLEINPLACEFRAME ServerDoc_GetTopInPlaceFrame(LPSERVERDOC lpServerDoc);
void ServerDoc_GetSharedMenuHandles(
		LPSERVERDOC lpServerDoc,
		HMENU FAR*      lphSharedMenu,
		HOLEMENU FAR*   lphOleMenu
);
void ServerDoc_AddFrameLevelUI(LPSERVERDOC lpServerDoc);
void ServerDoc_AddFrameLevelTools(LPSERVERDOC lpServerDoc);
void ServerDoc_UIActivate (LPSERVERDOC lpServerDoc);

#if defined( USE_FRAMETOOLS )
void ServerDoc_RemoveFrameLevelTools(LPSERVERDOC lpServerDoc);
#endif // USE_FRAMETOOLS

#endif // INPLACE_SVR


/* ServerDoc::IOleObject methods (functions) */
STDMETHODIMP SvrDoc_OleObj_QueryInterface(
		LPOLEOBJECT             lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
);
STDMETHODIMP_(ULONG) SvrDoc_OleObj_AddRef(LPOLEOBJECT lpThis);
STDMETHODIMP_(ULONG) SvrDoc_OleObj_Release(LPOLEOBJECT lpThis);
STDMETHODIMP SvrDoc_OleObj_SetClientSite(
		LPOLEOBJECT             lpThis,
		LPOLECLIENTSITE         lpclientSite
);
STDMETHODIMP SvrDoc_OleObj_GetClientSite(
		LPOLEOBJECT             lpThis,
		LPOLECLIENTSITE FAR*    lplpClientSite
);
STDMETHODIMP SvrDoc_OleObj_SetHostNames(
		LPOLEOBJECT             lpThis,
		LPCOLESTR		szContainerApp,
		LPCOLESTR		szContainerObj
);
STDMETHODIMP SvrDoc_OleObj_Close(
		LPOLEOBJECT             lpThis,
		DWORD                   dwSaveOption
);
STDMETHODIMP SvrDoc_OleObj_SetMoniker(
		LPOLEOBJECT             lpThis,
		DWORD                   dwWhichMoniker,
		LPMONIKER               lpmk
);
STDMETHODIMP SvrDoc_OleObj_GetMoniker(
		LPOLEOBJECT             lpThis,
		DWORD                   dwAssign,
		DWORD                   dwWhichMoniker,
		LPMONIKER FAR*          lplpmk
);
STDMETHODIMP SvrDoc_OleObj_InitFromData(
		LPOLEOBJECT             lpThis,
		LPDATAOBJECT            lpDataObject,
		BOOL                    fCreation,
		DWORD                   reserved
);
STDMETHODIMP SvrDoc_OleObj_GetClipboardData(
		LPOLEOBJECT             lpThis,
		DWORD                   reserved,
		LPDATAOBJECT FAR*       lplpDataObject
);
STDMETHODIMP SvrDoc_OleObj_DoVerb(
		LPOLEOBJECT             lpThis,
		LONG                    lVerb,
		LPMSG                   lpmsg,
		LPOLECLIENTSITE         lpActiveSite,
		LONG                    lindex,
		HWND                    hwndParent,
		LPCRECT                 lprcPosRect
);
STDMETHODIMP SvrDoc_OleObj_EnumVerbs(
		LPOLEOBJECT             lpThis,
		LPENUMOLEVERB FAR*      lplpenumOleVerb
);
STDMETHODIMP SvrDoc_OleObj_Update(LPOLEOBJECT lpThis);
STDMETHODIMP SvrDoc_OleObj_IsUpToDate(LPOLEOBJECT lpThis);
STDMETHODIMP SvrDoc_OleObj_GetUserClassID(
		LPOLEOBJECT             lpThis,
		LPCLSID                 lpclsid
);
STDMETHODIMP SvrDoc_OleObj_GetUserType(
		LPOLEOBJECT             lpThis,
		DWORD                   dwFormOfType,
		LPOLESTR FAR*		lpszUserType
);
STDMETHODIMP SvrDoc_OleObj_SetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lplgrc
);
STDMETHODIMP SvrDoc_OleObj_GetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lplgrc
);
STDMETHODIMP SvrDoc_OleObj_Advise(
		LPOLEOBJECT             lpThis,
		LPADVISESINK            lpAdvSink,
		LPDWORD                 lpdwConnection
);
STDMETHODIMP SvrDoc_OleObj_Unadvise(LPOLEOBJECT lpThis, DWORD dwConnection);
STDMETHODIMP SvrDoc_OleObj_EnumAdvise(
		LPOLEOBJECT             lpThis,
		LPENUMSTATDATA FAR*     lplpenumAdvise
);
STDMETHODIMP SvrDoc_OleObj_GetMiscStatus(
		LPOLEOBJECT             lpThis,
		DWORD                   dwAspect,
		DWORD FAR*              lpdwStatus
);
STDMETHODIMP SvrDoc_OleObj_SetColorScheme(
		LPOLEOBJECT             lpThis,
		LPLOGPALETTE            lpLogpal
);
STDMETHODIMP SvrDoc_OleObj_LockObject(
		LPOLEOBJECT             lpThis,
		BOOL                    fLock
);

/* ServerDoc::IPersistStorage methods (functions) */
STDMETHODIMP SvrDoc_PStg_QueryInterface(
		LPPERSISTSTORAGE        lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
);
STDMETHODIMP_(ULONG) SvrDoc_PStg_AddRef(LPPERSISTSTORAGE lpThis);
STDMETHODIMP_(ULONG) SvrDoc_PStg_Release(LPPERSISTSTORAGE lpThis);
STDMETHODIMP SvrDoc_PStg_GetClassID(
		LPPERSISTSTORAGE        lpThis,
		LPCLSID                 lpClassID
);
STDMETHODIMP  SvrDoc_PStg_IsDirty(LPPERSISTSTORAGE  lpThis);
STDMETHODIMP SvrDoc_PStg_InitNew(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg
);
STDMETHODIMP SvrDoc_PStg_Load(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg
);
STDMETHODIMP SvrDoc_PStg_Save(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg,
		BOOL                    fSameAsLoad
);
STDMETHODIMP SvrDoc_PStg_SaveCompleted(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStgNew
);
STDMETHODIMP SvrDoc_PStg_HandsOffStorage(LPPERSISTSTORAGE lpThis);


#if defined( SVR_TREATAS )

/* ServerDoc::IStdMarshalInfo methods (functions) */
STDMETHODIMP SvrDoc_StdMshl_QueryInterface(
		LPSTDMARSHALINFO        lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
);
STDMETHODIMP_(ULONG) SvrDoc_StdMshl_AddRef(LPSTDMARSHALINFO lpThis);
STDMETHODIMP_(ULONG) SvrDoc_StdMshl_Release(LPSTDMARSHALINFO lpThis);
STDMETHODIMP SvrDoc_StdMshl_GetClassForHandler(
		LPSTDMARSHALINFO        lpThis,
		DWORD                   dwDestContext,
		LPVOID                  pvDestContext,
		LPCLSID                 lpClassID
);
#endif  // SVR_TREATAS

/*************************************************************************
** class SERVERAPP : OLEAPP
**    SERVERAPP is an extention to the abstract base OLEAPP class.
**    The OLEAPP class defines the fields, methods and interfaces that
**    are common to both server and client implementations. The
**    SERVERAPP class adds the fields and methods that are specific to
**    OLE 2.0 Server functionality. There is one instance of
**    SERVERAPP object created per running application instance. This
**    object holds many fields that could otherwise be organized as
**    global variables. The SERVERAPP class inherits all fields
**    from the OLEAPP class. This inheritance is achieved by including a
**    member variable of type OLEAPP as the first field in the SERVERAPP
**    structure. OLEAPP inherits from OLEAPP. This inheritance is
**    achieved in the same manner. Thus a pointer to a SERVERAPP object
**    can be cast to be a pointer to an OLEAPP or an OUTLINEAPP object
*************************************************************************/

typedef struct tagSERVERAPP {
	OLEAPP      m_OleApp;       // ServerApp inherits all fields of OleApp

#if defined( INPLACE_SVR )
	HACCEL  m_hAccelIPSvr; // accelerators for server's active object commands
	HACCEL  m_hAccelBaseApp;    // normal accel for non-inplace server mode
	HMENU   m_hMenuEdit;   // handle to Edit menu of the server app
	HMENU   m_hMenuLine;   // handle to Line menu of the server app
	HMENU   m_hMenuName;   // handle to Name menu of the server app
	HMENU   m_hMenuOptions; // handle to Options menu of the server app
	HMENU   m_hMenuDebug;       // handle to Debug menu of the server app
	HMENU   m_hMenuHelp;   // handle to Help menu of the server app
	LPINPLACEDATA   m_lpIPData;
#endif

} SERVERAPP;

/* ServerApp methods (functions) */
BOOL ServerApp_InitInstance(
		LPSERVERAPP             lpServerApp,
		HINSTANCE               hInst,
		int                     nCmdShow
);
BOOL ServerApp_InitVtbls (LPSERVERAPP lpServerApp);



/*************************************************************************
** class SERVERNAME : OUTLINENAME
**    SERVERNAME class is an extension to the OUTLINENAME base class that
**    adds functionallity required to support linking to ranges (pseudo
**    objects). Pseudo objects are used to allow linking to a range
**    (sub-selection) of a SERVERDOC document. The base class OUTLINENAME
**    stores a particular named selection in the document. The
**    NAMETABLE class holds all of the names defined in a particular
**    document. Each OUTLINENAME object has a string as its key and a
**    starting line index and an ending line index for the named range.
**    The SERVERNAME class, also, stores a pointer to a PSEUDOOBJ if one
**    has been allocated that corresponds to the named selection.
**    The SERVERNAME class inherits all fields from the OUTLINENAME class.
**    This inheritance is achieved by including a member variable of
**    type OUTLINENAME as the first field in the SERVERNAME
**    structure. Thus a pointer to an SERVERNAME object can be cast to be
**    a pointer to a OUTLINENAME object.
*************************************************************************/

typedef struct tagSERVERNAME {
	OUTLINENAME     m_Name;         // ServerName inherits all fields of Name
	LPPSEUDOOBJ m_lpPseudoObj;  // ptr to pseudo object if allocated
} SERVERNAME, FAR* LPSERVERNAME;

/* ServerName methods (functions) */
void ServerName_SetSel(
		LPSERVERNAME            lpServerName,
		LPLINERANGE             lplrSel,
		BOOL                    fRangeModified
);
void ServerName_SendPendingAdvises(LPSERVERNAME lpServerName);
LPPSEUDOOBJ ServerName_GetPseudoObj(
		LPSERVERNAME            lpServerName,
		LPSERVERDOC             lpServerDoc
);
void ServerName_ClosePseudoObj(LPSERVERNAME lpServerName);


/*************************************************************************
** class PSEUDOOBJ
**    The PSEUDOOBJ (pseudo object) is a concrete class. A pseudo object
**    is created when a link is made to a range of lines within an
**    SERVERDOC document. A pseudo object is dependent on the existance
**    of the SERVERDOC which represents the whole document.
*************************************************************************/

typedef struct tagPSEUDOOBJ {
	ULONG               m_cRef;             // total ref count for obj
	BOOL                m_fObjIsClosing;    // flag to guard recursive close
	LPSERVERNAME        m_lpName;           // named range for this pseudo obj
	LPSERVERDOC         m_lpDoc;            // ptr to whole document
	LPOLEADVISEHOLDER   m_lpOleAdviseHldr;  // helper obj to hold ole advises
	LPDATAADVISEHOLDER  m_lpDataAdviseHldr; // helper obj to hold data advises
	BOOL                m_fDataChanged;     // data changed when draw disabled

	struct CPseudoObjUnknownImpl {
		IUnknownVtbl FAR*       lpVtbl;
		LPPSEUDOOBJ             lpPseudoObj;
		int                     cRef;   // interface specific ref count.
	} m_Unknown;

	struct CPseudoObjOleObjectImpl {
		IOleObjectVtbl FAR*     lpVtbl;
		LPPSEUDOOBJ             lpPseudoObj;
		int                     cRef;   // interface specific ref count.
	} m_OleObject;

	struct CPseudoObjDataObjectImpl {
		IDataObjectVtbl FAR*    lpVtbl;
		LPPSEUDOOBJ             lpPseudoObj;
		int                     cRef;   // interface specific ref count.
	} m_DataObject;

} PSEUDOOBJ;

/* PseudoObj methods (functions) */
void PseudoObj_Init(
		LPPSEUDOOBJ             lpPseudoObj,
		LPSERVERNAME            lpServerName,
		LPSERVERDOC             lpServerDoc
);
ULONG PseudoObj_AddRef(LPPSEUDOOBJ lpPseudoObj);
ULONG PseudoObj_Release(LPPSEUDOOBJ lpPseudoObj);
HRESULT PseudoObj_QueryInterface(
		LPPSEUDOOBJ         lpPseudoObj,
		REFIID              riid,
		LPVOID FAR*         lplpUnk
);
BOOL PseudoObj_Close(LPPSEUDOOBJ lpPseudoObj);
void PseudoObj_Destroy(LPPSEUDOOBJ lpPseudoObj);
void PseudoObj_GetSel(LPPSEUDOOBJ lpPseudoObj, LPLINERANGE lplrSel);
void PseudoObj_GetExtent(LPPSEUDOOBJ lpPseudoObj, LPSIZEL lpsizel);
void PseudoObj_GetExtent(LPPSEUDOOBJ lpPseudoObj, LPSIZEL lpsizel);
void PseudoObj_SendAdvise(
		LPPSEUDOOBJ lpPseudoObj,
		WORD        wAdvise,
		LPMONIKER   lpmkObj,
		DWORD       dwAdvf
);
LPMONIKER PseudoObj_GetFullMoniker(LPPSEUDOOBJ lpPseudoObj, LPMONIKER lpmkDoc);

/* PseudoObj::IUnknown methods (functions) */
STDMETHODIMP PseudoObj_Unk_QueryInterface(
		LPUNKNOWN         lpThis,
		REFIID            riid,
		LPVOID FAR*       lplpvObj
);
STDMETHODIMP_(ULONG) PseudoObj_Unk_AddRef(LPUNKNOWN lpThis);
STDMETHODIMP_(ULONG) PseudoObj_Unk_Release (LPUNKNOWN lpThis);

/* PseudoObj::IOleObject methods (functions) */
STDMETHODIMP PseudoObj_OleObj_QueryInterface(
		LPOLEOBJECT     lpThis,
		REFIID          riid,
		LPVOID FAR*     lplpvObj
);
STDMETHODIMP_(ULONG) PseudoObj_OleObj_AddRef(LPOLEOBJECT lpThis);
STDMETHODIMP_(ULONG) PseudoObj_OleObj_Release(LPOLEOBJECT lpThis);
STDMETHODIMP PseudoObj_OleObj_SetClientSite(
		LPOLEOBJECT         lpThis,
		LPOLECLIENTSITE     lpClientSite
);
STDMETHODIMP PseudoObj_OleObj_GetClientSite(
		LPOLEOBJECT             lpThis,
		LPOLECLIENTSITE FAR*    lplpClientSite
);
STDMETHODIMP PseudoObj_OleObj_SetHostNames(
		LPOLEOBJECT             lpThis,
		LPCOLESTR		szContainerApp,
		LPCOLESTR		szContainerObj
);
STDMETHODIMP PseudoObj_OleObj_Close(
		LPOLEOBJECT             lpThis,
		DWORD                   dwSaveOption
);
STDMETHODIMP PseudoObj_OleObj_SetMoniker(
		LPOLEOBJECT lpThis,
		DWORD       dwWhichMoniker,
		LPMONIKER   lpmk
);
STDMETHODIMP PseudoObj_OleObj_GetMoniker(
		LPOLEOBJECT     lpThis,
		DWORD           dwAssign,
		DWORD           dwWhichMoniker,
		LPMONIKER FAR*  lplpmk
);
STDMETHODIMP PseudoObj_OleObj_InitFromData(
		LPOLEOBJECT             lpThis,
		LPDATAOBJECT            lpDataObject,
		BOOL                    fCreation,
		DWORD                   reserved
);
STDMETHODIMP PseudoObj_OleObj_GetClipboardData(
		LPOLEOBJECT             lpThis,
		DWORD                   reserved,
		LPDATAOBJECT FAR*       lplpDataObject
);
STDMETHODIMP PseudoObj_OleObj_DoVerb(
		LPOLEOBJECT             lpThis,
		LONG                    lVerb,
		LPMSG                   lpmsg,
		LPOLECLIENTSITE         lpActiveSite,
		LONG                    lindex,
		HWND                    hwndParent,
		LPCRECT                 lprcPosRect
);
STDMETHODIMP PseudoObj_OleObj_EnumVerbs(
		LPOLEOBJECT         lpThis,
		LPENUMOLEVERB FAR*  lplpenumOleVerb
);
STDMETHODIMP PseudoObj_OleObj_Update(LPOLEOBJECT lpThis);
STDMETHODIMP PseudoObj_OleObj_IsUpToDate(LPOLEOBJECT lpThis);
STDMETHODIMP PseudoObj_OleObj_GetUserClassID(
		LPOLEOBJECT             lpThis,
		LPCLSID                 lpclsid
);
STDMETHODIMP PseudoObj_OleObj_GetUserType(
		LPOLEOBJECT             lpThis,
		DWORD                   dwFormOfType,
		LPOLESTR FAR*		lpszUserType
);
STDMETHODIMP PseudoObj_OleObj_SetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lplgrc
);
STDMETHODIMP PseudoObj_OleObj_GetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lplgrc
);
STDMETHODIMP PseudoObj_OleObj_Advise(
		LPOLEOBJECT lpThis,
		LPADVISESINK lpAdvSink,
		LPDWORD lpdwConnection
);
STDMETHODIMP PseudoObj_OleObj_Unadvise(LPOLEOBJECT lpThis,DWORD dwConnection);
STDMETHODIMP PseudoObj_OleObj_EnumAdvise(
		LPOLEOBJECT lpThis,
		LPENUMSTATDATA FAR* lplpenumAdvise
);
STDMETHODIMP PseudoObj_OleObj_GetMiscStatus(
		LPOLEOBJECT             lpThis,
		DWORD                   dwAspect,
		DWORD FAR*              lpdwStatus
);
STDMETHODIMP PseudoObj_OleObj_SetColorScheme(
		LPOLEOBJECT             lpThis,
		LPLOGPALETTE            lpLogpal
);
STDMETHODIMP PseudoObj_OleObj_LockObject(
		LPOLEOBJECT             lpThis,
		BOOL                    fLock
);

/* PseudoObj::IDataObject methods (functions) */
STDMETHODIMP PseudoObj_DataObj_QueryInterface (
		LPDATAOBJECT      lpThis,
		REFIID            riid,
		LPVOID FAR*       lplpvObj
);
STDMETHODIMP_(ULONG) PseudoObj_DataObj_AddRef(LPDATAOBJECT lpThis);
STDMETHODIMP_(ULONG) PseudoObj_DataObj_Release (LPDATAOBJECT lpThis);
STDMETHODIMP PseudoObj_DataObj_GetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpMedium
);
STDMETHODIMP PseudoObj_DataObj_GetDataHere (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpMedium
);
STDMETHODIMP PseudoObj_DataObj_QueryGetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc
);
STDMETHODIMP PseudoObj_DataObj_GetCanonicalFormatEtc (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPFORMATETC     lpformatetcOut
);
STDMETHODIMP PseudoObj_DataObj_SetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpmedium,
		BOOL            fRelease
);
STDMETHODIMP PseudoObj_DataObj_EnumFormatEtc(
		LPDATAOBJECT            lpThis,
		DWORD                   dwDirection,
		LPENUMFORMATETC FAR*    lplpenumFormatEtc
);
STDMETHODIMP PseudoObj_DataObj_DAdvise(
		LPDATAOBJECT    lpThis,
		FORMATETC FAR*  lpFormatetc,
		DWORD           advf,
		LPADVISESINK    lpAdvSink,
		DWORD FAR*      lpdwConnection
);
STDMETHODIMP PseudoObj_DataObj_DUnadvise(LPDATAOBJECT lpThis, DWORD dwConnection);
STDMETHODIMP PseudoObj_DataObj_EnumAdvise(
		LPDATAOBJECT lpThis,
		LPENUMSTATDATA FAR* lplpenumAdvise
);


/*************************************************************************
** class SERVERNAMETABLE : OUTLINENAMETABLE
**    SERVERNAMETABLE class is an extension to the OUTLINENAMETABLE
**    base class that adds functionallity required to support linking
**    to ranges (pseudo objects). The name table manages the table of
**    named selections in the document. Each name table entry has a
**    string as its key and a starting line index and an ending line
**    index for the named range. The SERVERNAMETABLE entries, in
**    addition, maintain a pointer to a PSEUDOOBJ pseudo object if one
**    has been already allocated. There is always one instance of
**    SERVERNAMETABLE for each SERVERDOC object created.
**    The SERVERNAME class inherits all fields from the NAME class.
**    This inheritance is achieved by including a member variable of
**    type NAME as the first field in the SERVERNAME
**    structure. Thus a pointer to an SERVERNAME object can be cast to be
**    a pointer to a NAME object.
*************************************************************************/

typedef struct tagSERVERNAMETABLE {
	OUTLINENAMETABLE    m_NameTable;    // we inherit from OUTLINENAMETABLE

	// ServerNameTable does NOT add any fields

} SERVERNAMETABLE, FAR* LPSERVERNAMETABLE;

/* ServerNameTable methods (functions) */
void ServerNameTable_EditLineUpdate(
		LPSERVERNAMETABLE       lpServerNameTable,
		int                     nEditIndex
);
void ServerNameTable_InformAllPseudoObjectsDocRenamed(
		LPSERVERNAMETABLE       lpServerNameTable,
		LPMONIKER               lpmkDoc
);
void ServerNameTable_InformAllPseudoObjectsDocSaved(
		LPSERVERNAMETABLE       lpServerNameTable,
		LPMONIKER               lpmkDoc
);
void ServerNameTable_SendPendingAdvises(LPSERVERNAMETABLE lpServerNameTable);
LPPSEUDOOBJ ServerNameTable_GetPseudoObj(
		LPSERVERNAMETABLE       lpServerNameTable,
		LPSTR                   lpszItem,
		LPSERVERDOC             lpServerDoc
);
void ServerNameTable_CloseAllPseudoObjs(LPSERVERNAMETABLE lpServerNameTable);


#if defined( INPLACE_SVR)

/* ServerDoc::IOleInPlaceObject methods (functions) */

STDMETHODIMP SvrDoc_IPObj_QueryInterface(
		LPOLEINPLACEOBJECT  lpThis,
		REFIID              riid,
		LPVOID FAR *        lplpvObj
);
STDMETHODIMP_(ULONG) SvrDoc_IPObj_AddRef(LPOLEINPLACEOBJECT lpThis);
STDMETHODIMP_(ULONG) SvrDoc_IPObj_Release(LPOLEINPLACEOBJECT lpThis);
STDMETHODIMP SvrDoc_IPObj_GetWindow(
		LPOLEINPLACEOBJECT  lpThis,
		HWND FAR*           lphwnd
);
STDMETHODIMP SvrDoc_IPObj_ContextSensitiveHelp(
		LPOLEINPLACEOBJECT  lpThis,
		BOOL                fEnable
);
STDMETHODIMP SvrDoc_IPObj_InPlaceDeactivate(LPOLEINPLACEOBJECT lpThis);
STDMETHODIMP SvrDoc_IPObj_UIDeactivate(LPOLEINPLACEOBJECT lpThis);
STDMETHODIMP SvrDoc_IPObj_SetObjectRects(
		LPOLEINPLACEOBJECT  lpThis,
		LPCRECT             lprcPosRect,
		LPCRECT             lprcClipRect
);
STDMETHODIMP SvrDoc_IPObj_ReactivateAndUndo(LPOLEINPLACEOBJECT lpThis);

/* ServerDoc::IOleInPlaceActiveObject methods (functions) */

STDMETHODIMP SvrDoc_IPActiveObj_QueryInterface(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		REFIID                      riidReq,
		LPVOID FAR *                lplpUnk
);
STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_AddRef(
		LPOLEINPLACEACTIVEOBJECT lpThis
);
STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_Release(
		LPOLEINPLACEACTIVEOBJECT lpThis
);
STDMETHODIMP SvrDoc_IPActiveObj_GetWindow(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		HWND FAR*                   lphwnd
);
STDMETHODIMP SvrDoc_IPActiveObj_ContextSensitiveHelp(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fEnable
);
STDMETHODIMP SvrDoc_IPActiveObj_TranslateAccelerator(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		LPMSG                       lpmsg
);
STDMETHODIMP SvrDoc_IPActiveObj_OnFrameWindowActivate(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fActivate
);
STDMETHODIMP SvrDoc_IPActiveObj_OnDocWindowActivate(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fActivate
);
STDMETHODIMP SvrDoc_IPActiveObj_ResizeBorder(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		LPCRECT                     lprectBorder,
		LPOLEINPLACEUIWINDOW        lpIPUiWnd,
		BOOL                        fFrameWindow
);
STDMETHODIMP SvrDoc_IPActiveObj_EnableModeless(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fEnable
);

#endif // INPLACE_SVR

#endif // _SVROUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\isvrotl\chicago\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\isvrotl\daytona\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\svroutl\chicago\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\cntroutl\chicago\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\icntrotl\chicago\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\svroutl\daytona\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\svrpsobj.c ===
/*************************************************************************
**
**    OLE 2 Server Sample Code
**
**    svrpsobj.c
**
**    This file contains all PseudoObj methods and related support
**    functions.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP             g_lpApp;
extern IUnknownVtbl             g_PseudoObj_UnknownVtbl;
extern IOleObjectVtbl           g_PseudoObj_OleObjectVtbl;
extern IDataObjectVtbl          g_PseudoObj_DataObjectVtbl;


/* PseudoObj_Init
** --------------
**  Initialize fields in a newly constructed PseudoObj.
**  NOTE: ref cnt of PseudoObj initialized to 0
*/
void PseudoObj_Init(
		LPPSEUDOOBJ             lpPseudoObj,
		LPSERVERNAME            lpServerName,
		LPSERVERDOC             lpServerDoc
)
{
	OleDbgOut2("++PseudoObj Created\r\n");

	lpPseudoObj->m_cRef             = 0;
	lpPseudoObj->m_lpName           = lpServerName;
	lpPseudoObj->m_lpDoc            = lpServerDoc;
	lpPseudoObj->m_lpOleAdviseHldr  = NULL;
	lpPseudoObj->m_lpDataAdviseHldr = NULL;
	lpPseudoObj->m_fObjIsClosing    = FALSE;

	INIT_INTERFACEIMPL(
			&lpPseudoObj->m_Unknown,
			&g_PseudoObj_UnknownVtbl,
			lpPseudoObj
	);

	INIT_INTERFACEIMPL(
			&lpPseudoObj->m_OleObject,
			&g_PseudoObj_OleObjectVtbl,
			lpPseudoObj
	);

	INIT_INTERFACEIMPL(
			&lpPseudoObj->m_DataObject,
			&g_PseudoObj_DataObjectVtbl,
			lpPseudoObj
	);

	/* OLE2NOTE: Increment the refcnt of the Doc on behalf of the
	**    PseudoObj. the Document should not shut down unless all
	**    pseudo objects are closed. when a pseudo object is destroyed,
	**    it calls ServerDoc_PseudoObjUnlockDoc to release this hold on
	**    the document.
	*/
	ServerDoc_PseudoObjLockDoc(lpServerDoc);
}



/* PseudoObj_AddRef
** ----------------
**
**  increment the ref count of the PseudoObj object.
**
**    Returns the new ref count on the object
*/
ULONG PseudoObj_AddRef(LPPSEUDOOBJ lpPseudoObj)
{
	++lpPseudoObj->m_cRef;

#if defined( _DEBUG )
	OleDbgOutRefCnt4(
			"PseudoObj_AddRef: cRef++\r\n",
			lpPseudoObj,
			lpPseudoObj->m_cRef
	);
#endif
	return lpPseudoObj->m_cRef;
}


/* PseudoObj_Release
** -----------------
**
**  decrement the ref count of the PseudoObj object.
**    if the ref count goes to 0, then the PseudoObj is destroyed.
**
**    Returns the remaining ref count on the object
*/
ULONG PseudoObj_Release(LPPSEUDOOBJ lpPseudoObj)
{
	ULONG cRef;

	/*********************************************************************
	** OLE2NOTE: when the obj refcnt == 0, then destroy the object.     **
	**     otherwise the object is still in use.                        **
	*********************************************************************/

	cRef = --lpPseudoObj->m_cRef;

#if defined( _DEBUG )
	OleDbgAssertSz(lpPseudoObj->m_cRef >= 0,"Release called with cRef == 0");

	OleDbgOutRefCnt4(
			"PseudoObj_Release: cRef--\r\n", lpPseudoObj,cRef);
#endif

	if (cRef == 0)
		PseudoObj_Destroy(lpPseudoObj);

	return cRef;
}


/* PseudoObj_QueryInterface
** ------------------------
**
** Retrieve a pointer to an interface on the PseudoObj object.
**
**    Returns S_OK if interface is successfully retrieved.
**            E_NOINTERFACE if the interface is not supported
*/
HRESULT PseudoObj_QueryInterface(
		LPPSEUDOOBJ         lpPseudoObj,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	SCODE sc = E_NOINTERFACE;

	/* OLE2NOTE: we must make sure to set all out ptr parameters to NULL. */
	*lplpvObj = NULL;

	if (IsEqualIID(riid, &IID_IUnknown)) {
		OleDbgOut4("PseudoObj_QueryInterface: IUnknown* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpPseudoObj->m_Unknown;
		PseudoObj_AddRef(lpPseudoObj);
		sc = S_OK;
	}
	else if (IsEqualIID(riid, &IID_IOleObject)) {
		OleDbgOut4("PseudoObj_QueryInterface: IOleObject* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpPseudoObj->m_OleObject;
		PseudoObj_AddRef(lpPseudoObj);
		sc = S_OK;
	}
	else if (IsEqualIID(riid, &IID_IDataObject)) {
		OleDbgOut4("PseudoObj_QueryInterface: IDataObject* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpPseudoObj->m_DataObject;
		PseudoObj_AddRef(lpPseudoObj);
		sc = S_OK;
	}

	OleDbgQueryInterfaceMethod(*lplpvObj);

	return ResultFromScode(sc);
}


/* PseudoObj_Close
 * ---------------
 *
 *  Close the pseudo object. Force all external connections to close
 *      down. This causes link clients to release this PseudoObj. when
 *      the refcount actually reaches 0, then the PseudoObj will be
 *      destroyed.
 *
 *  Returns:
 *      FALSE -- user canceled the closing of the doc.
 *      TRUE -- the doc was successfully closed
 */

BOOL PseudoObj_Close(LPPSEUDOOBJ lpPseudoObj)
{
	LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpPseudoObj->m_lpDoc;
	LPSERVERNAME lpServerName = (LPSERVERNAME)lpPseudoObj->m_lpName;
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	BOOL fStatus = TRUE;

	if (lpPseudoObj->m_fObjIsClosing)
		return TRUE;    // Closing is already in progress

	lpPseudoObj->m_fObjIsClosing = TRUE;   // guard against recursive call

	OLEDBG_BEGIN3("PseudoObj_Close\r\n")

	/* OLE2NOTE: in order to have a stable App, Doc, AND pseudo object
	**    during the process of closing, we intially AddRef the App,
	**    Doc, and PseudoObj ref counts and later Release them. These
	**    initial AddRefs are artificial; they are simply done to
	**    guarantee that these objects do not get destroyed until the
	**    end of this routine.
	*/
	OleApp_AddRef(lpOleApp);
	OleDoc_AddRef(lpOleDoc);
	PseudoObj_AddRef(lpPseudoObj);

	if (lpPseudoObj->m_lpDataAdviseHldr) {
		/* OLE2NOTE: send last OnDataChange notification to clients
		**    that have registered for data notifications when object
		**    stops running (ADVF_DATAONSTOP)
		*/
		PseudoObj_SendAdvise(
				lpPseudoObj,
				OLE_ONDATACHANGE,
				NULL,   /* lpmkObj -- not relevant here */
				ADVF_DATAONSTOP
		);

		/* OLE2NOTE: we just sent the last data notification that we
		**    need to send; release our DataAdviseHolder. we SHOULD be
		**    the only one using it.
		*/
		OleStdVerifyRelease(
				(LPUNKNOWN)lpPseudoObj->m_lpDataAdviseHldr,
				"DataAdviseHldr not released properly"
		);
		lpPseudoObj->m_lpDataAdviseHldr = NULL;
	}

	if (lpPseudoObj->m_lpOleAdviseHldr) {
		// OLE2NOTE: inform all of our linking clients that we are closing.
		PseudoObj_SendAdvise(
				lpPseudoObj,
				OLE_ONCLOSE,
				NULL,   /* lpmkObj -- not relevant here */
				0       /* advf -- not relevant here */
		);

		/* OLE2NOTE: OnClose is the last notification that we need to
		**    send; release our OleAdviseHolder. we SHOULD be the only
		**    one using it. this will make our destructor realize that
		**    OnClose notification has already been sent.
		*/
		OleStdVerifyRelease(
				(LPUNKNOWN)lpPseudoObj->m_lpOleAdviseHldr,
				"OleAdviseHldr not released properly"
		);
		lpPseudoObj->m_lpOleAdviseHldr = NULL;
	}

	/* OLE2NOTE: this call forces all external connections to our
	**    object to close down and therefore guarantees that we receive
	**    all releases associated with those external connections.
	*/
	OLEDBG_BEGIN2("CoDisconnectObject called\r\n")
	CoDisconnectObject((LPUNKNOWN)&lpPseudoObj->m_Unknown, 0);
	OLEDBG_END2

	PseudoObj_Release(lpPseudoObj);     // release artificial AddRef above
	OleDoc_Release(lpOleDoc);           // release artificial AddRef above
	OleApp_Release(lpOleApp);           // release artificial AddRef above

	OLEDBG_END3
	return fStatus;
}


/* PseudoObj_Destroy
** -----------------
**    Destroy (Free) the memory used by a PseudoObj structure.
**    This function is called when the ref count of the PseudoObj goes
**    to zero. the ref cnt goes to zero after PseudoObj_Delete forces
**    the OleObject to unload and release its pointers to the
**    PseudoObj IOleClientSite and IAdviseSink interfaces.
*/

void PseudoObj_Destroy(LPPSEUDOOBJ lpPseudoObj)
{
	LPSERVERDOC lpServerDoc = lpPseudoObj->m_lpDoc;
	LPOLEAPP    lpOleApp = (LPOLEAPP)g_lpApp;
	LPOLEDOC    lpOleDoc = (LPOLEDOC)lpServerDoc;

	OLEDBG_BEGIN3("PseudoObj_Destroy\r\n")

	/* OLE2NOTE: in order to have a stable App, Doc, AND pseudo object
	**    during the process of closing, we intially AddRef the App,
	**    Doc ref counts and later Release them. These
	**    initial AddRefs are artificial; they are simply done to
	**    guarantee that these objects do not get destroyed until the
	**    end of this routine.
	*/
	OleApp_AddRef(lpOleApp);
	OleDoc_AddRef(lpOleDoc);

	/******************************************************************
	** OLE2NOTE: we no longer need the advise and enum holder objects,
	**    so release them.
	******************************************************************/

	if (lpPseudoObj->m_lpDataAdviseHldr) {
		/* release DataAdviseHldr; we SHOULD be the only one using it. */
		OleStdVerifyRelease(
				(LPUNKNOWN)lpPseudoObj->m_lpDataAdviseHldr,
				"DataAdviseHldr not released properly"
			);
		lpPseudoObj->m_lpDataAdviseHldr = NULL;
	}

	if (lpPseudoObj->m_lpOleAdviseHldr) {
		/* release OleAdviseHldr; we SHOULD be the only one using it. */
		OleStdVerifyRelease(
				(LPUNKNOWN)lpPseudoObj->m_lpOleAdviseHldr,
				"OleAdviseHldr not released properly"
			);
		lpPseudoObj->m_lpOleAdviseHldr = NULL;
	}

	/* forget the pointer to destroyed PseudoObj in NameTable */
	if (lpPseudoObj->m_lpName)
		lpPseudoObj->m_lpName->m_lpPseudoObj = NULL;

	/* OLE2NOTE: release the lock on the Doc held on behalf of the
	**    PseudoObj. the Document should not shut down unless all
	**    pseudo objects are closed. when a pseudo object is first
	**    created, it calls ServerDoc_PseudoObjLockDoc to guarantee
	**    that the document stays alive (called from PseudoObj_Init).
	*/
	ServerDoc_PseudoObjUnlockDoc(lpServerDoc, lpPseudoObj);

	Delete(lpPseudoObj);        // Free the memory for the structure itself

	OleDoc_Release(lpOleDoc);       // release artificial AddRef above
	OleApp_Release(lpOleApp);       // release artificial AddRef above

	OLEDBG_END3
}


/* PseudoObj_GetSel
** ----------------
**    Return the line range for the pseudo object
*/
void PseudoObj_GetSel(LPPSEUDOOBJ lpPseudoObj, LPLINERANGE lplrSel)
{
	LPOUTLINENAME lpOutlineName = (LPOUTLINENAME)lpPseudoObj->m_lpName;
	lplrSel->m_nStartLine = lpOutlineName->m_nStartLine;
	lplrSel->m_nEndLine = lpOutlineName->m_nEndLine;
}


/* PseudoObj_GetExtent
 * -------------------
 *
 *      Get the extent (width, height) of the entire document.
 */
void PseudoObj_GetExtent(LPPSEUDOOBJ lpPseudoObj, LPSIZEL lpsizel)
{
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpPseudoObj->m_lpDoc;
	LPLINELIST lpLL = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;
	LINERANGE lrSel;

	PseudoObj_GetSel(lpPseudoObj, (LPLINERANGE)&lrSel);

	LineList_CalcSelExtentInHimetric(lpLL, (LPLINERANGE)&lrSel, lpsizel);
}


/* PseudoObj_SendAdvise
 * --------------------
 *
 * This function sends an advise notification on behalf of a specific
 *  doc object to all its clients.
 */
void PseudoObj_SendAdvise(
		LPPSEUDOOBJ lpPseudoObj,
		WORD        wAdvise,
		LPMONIKER   lpmkObj,
		DWORD       dwAdvf
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpPseudoObj->m_lpDoc;

	switch (wAdvise) {

		case OLE_ONDATACHANGE:

			// inform clients that the data of the object has changed

			if (lpOutlineDoc->m_nDisableDraw == 0) {
				/* drawing is currently enabled. inform clients that
				**    the data of the object has changed
				*/

				lpPseudoObj->m_fDataChanged = FALSE;
				if (lpPseudoObj->m_lpDataAdviseHldr) {

					OLEDBG_BEGIN2("IDataAdviseHolder::SendOnDataChange called\r\n");
					lpPseudoObj->m_lpDataAdviseHldr->lpVtbl->SendOnDataChange(
							lpPseudoObj->m_lpDataAdviseHldr,
							(LPDATAOBJECT)&lpPseudoObj->m_DataObject,
							0,
							dwAdvf
					);
					OLEDBG_END2
				}

			} else {
				/* drawing is currently disabled. do not send
				**    notifications until drawing is re-enabled.
				*/
				lpPseudoObj->m_fDataChanged = TRUE;
			}
			break;

		case OLE_ONCLOSE:

			// inform clients that the object is shutting down

			if (lpPseudoObj->m_lpOleAdviseHldr) {

				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnClose called\r\n");
				lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->SendOnClose(
						lpPseudoObj->m_lpOleAdviseHldr
				);
				OLEDBG_END2
			}
			break;

		case OLE_ONSAVE:

			// inform clients that the object has been saved

			if (lpPseudoObj->m_lpOleAdviseHldr) {

				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnClose called\r\n");
				lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->SendOnSave(
						lpPseudoObj->m_lpOleAdviseHldr
				);
				OLEDBG_END2
			}
			break;

		case OLE_ONRENAME:

			// inform clients that the object's name has changed
			if (lpmkObj && lpPseudoObj->m_lpOleAdviseHldr) {

				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnRename called\r\n");
				if (lpPseudoObj->m_lpOleAdviseHldr)
					lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->SendOnRename(
							lpPseudoObj->m_lpOleAdviseHldr,
							lpmkObj
					);
				OLEDBG_END2
			}
			break;
	}
}


/* PseudoObj_GetFullMoniker
 * ------------------------
 *
 * Returns the Full, absolute Moniker which identifies this pseudo object.
 */
LPMONIKER PseudoObj_GetFullMoniker(LPPSEUDOOBJ lpPseudoObj, LPMONIKER lpmkDoc)
{
	LPOUTLINENAME lpOutlineName = (LPOUTLINENAME)lpPseudoObj->m_lpName;
	LPMONIKER lpmkItem = NULL;
	LPMONIKER lpmkPseudoObj = NULL;

	if (lpmkDoc != NULL) {
		CreateItemMonikerA(OLESTDDELIM,lpOutlineName->m_szName,&lpmkItem);

		/* OLE2NOTE: create an absolute moniker which identifies the
		**    pseudo object. this moniker is created as a composite of
		**    the absolute moniker for the entire document appended
		**    with an item moniker which identifies the selection of
		**    the pseudo object relative to the document.
		*/
		CreateGenericComposite(lpmkDoc, lpmkItem, &lpmkPseudoObj);

		if (lpmkItem)
			OleStdRelease((LPUNKNOWN)lpmkItem);

		return lpmkPseudoObj;
	} else {
		return NULL;
	}
}


/*************************************************************************
** PseudoObj::IUnknown interface implementation
*************************************************************************/

STDMETHODIMP PseudoObj_Unk_QueryInterface(
		LPUNKNOWN         lpThis,
		REFIID            riid,
		LPVOID FAR*       lplpvObj
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjUnknownImpl FAR*)lpThis)->lpPseudoObj;

	return PseudoObj_QueryInterface(lpPseudoObj, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) PseudoObj_Unk_AddRef(LPUNKNOWN lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjUnknownImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgAddRefMethod(lpThis, "IUnknown");

	return PseudoObj_AddRef(lpPseudoObj);
}


STDMETHODIMP_(ULONG) PseudoObj_Unk_Release (LPUNKNOWN lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjUnknownImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgReleaseMethod(lpThis, "IUnknown");

	return PseudoObj_Release(lpPseudoObj);
}


/*************************************************************************
** PseudoObj::IOleObject interface implementation
*************************************************************************/

STDMETHODIMP PseudoObj_OleObj_QueryInterface(
		LPOLEOBJECT     lpThis,
		REFIID          riid,
		LPVOID FAR*     lplpvObj
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;

	return PseudoObj_QueryInterface(lpPseudoObj, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) PseudoObj_OleObj_AddRef(LPOLEOBJECT lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgAddRefMethod(lpThis, "IOleObject");

	return PseudoObj_AddRef((LPPSEUDOOBJ)lpPseudoObj);
}


STDMETHODIMP_(ULONG) PseudoObj_OleObj_Release(LPOLEOBJECT lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgReleaseMethod(lpThis, "IOleObject");

	return PseudoObj_Release((LPPSEUDOOBJ)lpPseudoObj);
}


STDMETHODIMP PseudoObj_OleObj_SetClientSite(
		LPOLEOBJECT         lpThis,
		LPOLECLIENTSITE     lpClientSite
)
{
	OleDbgOut2("PseudoObj_OleObj_SetClientSite\r\n");

	// OLE2NOTE: a pseudo object does NOT support SetExtent

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_GetClientSite(
		LPOLEOBJECT             lpThis,
		LPOLECLIENTSITE FAR*    lplpClientSite
)
{
	OleDbgOut2("PseudoObj_OleObj_GetClientSite\r\n");

	*lplpClientSite = NULL;

	// OLE2NOTE: a pseudo object does NOT support SetExtent

	return ResultFromScode(E_FAIL);
}



STDMETHODIMP PseudoObj_OleObj_SetHostNamesA(
		LPOLEOBJECT             lpThis,
		LPCSTR                  szContainerApp,
		LPCSTR                  szContainerObj
)
{
	OleDbgOut2("PseudoObj_OleObj_SetHostNamesA\r\n");

	// OLE2NOTE: a pseudo object does NOT support SetExtent

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_SetHostNames(
		LPOLEOBJECT             lpThis,
		LPCOLESTR		szContainerApp,
		LPCOLESTR		szContainerObj
)
{
	OleDbgOut2("PseudoObj_OleObj_SetHostNames\r\n");

	// OLE2NOTE: a pseudo object does NOT support SetExtent

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_Close(
		LPOLEOBJECT             lpThis,
		DWORD                   dwSaveOption
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	BOOL fStatus;

	OLEDBG_BEGIN2("PseudoObj_OleObj_Close\r\n")

	/* OLE2NOTE: a pseudo object's implementation of IOleObject::Close
	**    should ignore the dwSaveOption parameter. it is NOT
	**    applicable to pseudo objects.
	*/

	fStatus = PseudoObj_Close(lpPseudoObj);
	OleDbgAssertSz(fStatus == TRUE, "PseudoObj_OleObj_Close failed\r\n");

	OLEDBG_END2
	return NOERROR;
}


STDMETHODIMP PseudoObj_OleObj_SetMoniker(
		LPOLEOBJECT lpThis,
		DWORD       dwWhichMoniker,
		LPMONIKER   lpmk
)
{
	OleDbgOut2("PseudoObj_OleObj_SetMoniker\r\n");

	// OLE2NOTE: a pseudo object does NOT support SetMoniker

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_GetMoniker(
		LPOLEOBJECT     lpThis,
		DWORD           dwAssign,
		DWORD           dwWhichMoniker,
		LPMONIKER FAR*  lplpmk
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpPseudoObj->m_lpDoc;
	LPMONIKER lpmkDoc;

	OLEDBG_BEGIN2("PseudoObj_OleObj_GetMoniker\r\n")

	lpmkDoc = OleDoc_GetFullMoniker(lpOleDoc, GETMONIKER_ONLYIFTHERE);
	*lplpmk = PseudoObj_GetFullMoniker(lpPseudoObj, lpmkDoc);

	OLEDBG_END2

	if (*lplpmk != NULL)
		return NOERROR;
	else
		return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_InitFromData(
		LPOLEOBJECT             lpThis,
		LPDATAOBJECT            lpDataObject,
		BOOL                    fCreation,
		DWORD                   reserved
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	OleDbgOut2("PseudoObj_OleObj_InitFromData\r\n");

	// REVIEW: NOT YET IMPLEMENTED

	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP PseudoObj_OleObj_GetClipboardData(
		LPOLEOBJECT             lpThis,
		DWORD                   reserved,
		LPDATAOBJECT FAR*       lplpDataObject
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	OleDbgOut2("PseudoObj_OleObj_GetClipboardData\r\n");

	// REVIEW: NOT YET IMPLEMENTED

	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP PseudoObj_OleObj_DoVerb(
		LPOLEOBJECT             lpThis,
		LONG                    lVerb,
		LPMSG                   lpmsg,
		LPOLECLIENTSITE         lpActiveSite,
		LONG                    lindex,
		HWND                    hwndParent,
		LPCRECT                 lprcPosRect
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpPseudoObj->m_lpDoc;
	LPSERVERDOC lpServerDoc = lpPseudoObj->m_lpDoc;
	LINERANGE lrSel;
	HRESULT hrErr;

	OLEDBG_BEGIN2("PseudoObj_OleObj_DoVerb\r\n");

	/* OLE2NOTE: we must first ask our Document to perform the same
	**    verb. then if the verb is NOT OLEIVERB_HIDE we should also
	**    select the range of our pseudo object.
	**    however, we must give our document its own embedding site as
	**    its active site.
	*/
	hrErr = SvrDoc_OleObj_DoVerb(
			(LPOLEOBJECT)&lpServerDoc->m_OleObject,
			lVerb,
			lpmsg,
			lpServerDoc->m_lpOleClientSite,
			lindex,
			NULL,   /* we have no hwndParent to give */
			NULL    /* we have no lprcPosRect to give */
	);
	if (FAILED(hrErr)) {
		OLEDBG_END2
		return hrErr;
	}

	if (lVerb != OLEIVERB_HIDE) {
		PseudoObj_GetSel(lpPseudoObj, &lrSel);
		OutlineDoc_SetSel(lpOutlineDoc, &lrSel);
	}

	OLEDBG_END2
	return NOERROR;
}



STDMETHODIMP PseudoObj_OleObj_EnumVerbs(
		LPOLEOBJECT         lpThis,
		LPENUMOLEVERB FAR*  lplpenumOleVerb
)
{
	OleDbgOut2("PseudoObj_OleObj_EnumVerbs\r\n");

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpenumOleVerb = NULL;

	/* A pseudo object may NOT return OLE_S_USEREG; they must call the
	**    OleReg* API or provide their own implementation. Because this
	**    pseudo object does NOT implement IPersist, simply a low-level
	**    remoting handler (ProxyManager) object as opposed to a
	**    DefHandler object is used as the handler for the pseudo
	**    object in a clients process space. The ProxyManager does NOT
	**    handle the OLE_S_USEREG return values.
	*/
	return OleRegEnumVerbs((REFCLSID)&CLSID_APP, lplpenumOleVerb);
}


STDMETHODIMP PseudoObj_OleObj_Update(LPOLEOBJECT lpThis)
{
	OleDbgOut2("PseudoObj_OleObj_Update\r\n");

	/* OLE2NOTE: a server-only app is always "up-to-date".
	**    a container-app which contains links where the link source
	**    has changed since the last update of the link would be
	**    considered "out-of-date". the "Update" method instructs the
	**    object to get an update from any out-of-date links.
	*/

	return NOERROR;
}


STDMETHODIMP PseudoObj_OleObj_IsUpToDate(LPOLEOBJECT lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	OleDbgOut2("PseudoObj_OleObj_IsUpToDate\r\n");

	/* OLE2NOTE: a server-only app is always "up-to-date".
	**    a container-app which contains links where the link source
	**    has changed since the last update of the link would be
	**    considered "out-of-date".
	*/
	return NOERROR;
}


STDMETHODIMP PseudoObj_OleObj_GetUserClassID(
		LPOLEOBJECT             lpThis,
		LPCLSID                 lpclsid
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpPseudoObj->m_lpDoc;
	OleDbgOut2("PseudoObj_OleObj_GetUserClassID\r\n");

	/* OLE2NOTE: we must be carefull to return the correct CLSID here.
	**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
	**    operation then we need to return the class of the object
	**    written in the storage of the object. otherwise we would
	**    return our own class id.
	*/
	return ServerDoc_GetClassID(lpServerDoc, lpclsid);
}


STDMETHODIMP PseudoObj_OleObj_GetUserTypeA(
		LPOLEOBJECT             lpThis,
		DWORD                   dwFormOfType,
		LPSTR FAR*              lpszUserType
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpPseudoObj->m_lpDoc;
	OleDbgOut2("PseudoObj_OleObj_GetUserType\r\n");

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lpszUserType = NULL;

	/* OLE2NOTE: we must be carefull to return the correct user type here.
	**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
	**    operation then we need to return the user type name that
	**    corresponds to the class of the object we are currently
	**    emmulating. otherwise we should return our normal user type
	**    name corresponding to our own class. This routine determines
	**    the current clsid in effect.
	**
	**    A pseudo object may NOT return OLE_S_USEREG; they must call the
	**    OleReg* API or provide their own implementation. Because this
	**    pseudo object does NOT implement IPersist, simply a low-level
	**    remoting handler (ProxyManager) object as opposed to a
	**    DefHandler object is used as the handler for the pseudo
	**    object in a clients process space. The ProxyManager does NOT
	**    handle the OLE_S_USEREG return values.
	*/
#if defined( SVR_TREATAS )
	if (! IsEqualCLSID(&lpServerDoc->m_clsidTreatAs, &CLSID_NULL) )
		return OleRegGetUserTypeA(
			&lpServerDoc->m_clsidTreatAs,dwFormOfType,lpszUserType);
	else
#endif  // SVR_TREATAS

	return OleRegGetUserTypeA(&CLSID_APP, dwFormOfType, lpszUserType);
}

STDMETHODIMP PseudoObj_OleObj_GetUserType(
		LPOLEOBJECT             lpThis,
		DWORD                   dwFormOfType,
		LPOLESTR FAR*		lpszUserType
)
{
    LPSTR pstr;

    HRESULT hr = PseudoObj_OleObj_GetUserTypeA(lpThis, dwFormOfType, &pstr);

    CopyAndFreeSTR(pstr, lpszUserType);

    return hr;
}



STDMETHODIMP PseudoObj_OleObj_SetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lplgrc
)
{
	OleDbgOut2("PseudoObj_OleObj_SetExtent\r\n");

	// OLE2NOTE: a pseudo object does NOT support SetExtent

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_GetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lpsizel
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	OleDbgOut2("PseudoObj_OleObj_GetExtent\r\n");

	/* OLE2NOTE: it is VERY important to check which aspect the caller
	**    is asking about. an object implemented by a server EXE MAY
	**    fail to return extents when asked for DVASPECT_ICON.
	*/
	if (dwDrawAspect == DVASPECT_CONTENT) {
		PseudoObj_GetExtent(lpPseudoObj, lpsizel);
		return NOERROR;
	}
	else
	{
		return ResultFromScode(E_FAIL);
	}
}


STDMETHODIMP PseudoObj_OleObj_Advise(
		LPOLEOBJECT lpThis,
		LPADVISESINK lpAdvSink,
		LPDWORD lpdwConnection
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;
	OLEDBG_BEGIN2("PseudoObj_OleObj_Advise\r\n");

	if (lpPseudoObj->m_lpOleAdviseHldr == NULL &&
		CreateOleAdviseHolder(&lpPseudoObj->m_lpOleAdviseHldr) != NOERROR) {
		sc = E_OUTOFMEMORY;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::Advise called\r\n")
	hrErr = lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->Advise(
			lpPseudoObj->m_lpOleAdviseHldr,
			lpAdvSink,
			lpdwConnection
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_OleObj_Unadvise(LPOLEOBJECT lpThis, DWORD dwConnection)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("PseudoObj_OleObj_Unadvise\r\n");

	if (lpPseudoObj->m_lpOleAdviseHldr == NULL) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::Unadvise called\r\n")
	hrErr = lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->Unadvise(
			lpPseudoObj->m_lpOleAdviseHldr,
			dwConnection
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_OleObj_EnumAdvise(
		LPOLEOBJECT lpThis,
		LPENUMSTATDATA FAR* lplpenumAdvise
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("PseudoObj_OleObj_EnumAdvise\r\n");

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpenumAdvise = NULL;

	if (lpPseudoObj->m_lpOleAdviseHldr == NULL) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::EnumAdvise called\r\n")
	hrErr = lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->EnumAdvise(
			lpPseudoObj->m_lpOleAdviseHldr,
			lplpenumAdvise
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_OleObj_GetMiscStatus(
		LPOLEOBJECT             lpThis,
		DWORD                   dwAspect,
		DWORD FAR*              lpdwStatus
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpPseudoObj->m_lpDoc;
	OleDbgOut2("PseudoObj_OleObj_GetMiscStatus\r\n");

	/* Get our default MiscStatus for the given Aspect. this
	**    information is registered in the RegDB. We query the RegDB
	**    here to guarantee that the value returned from this method
	**    agrees with the values in RegDB. in this way we only have to
	**    maintain the info in one place (in the RegDB). Alternatively
	**    we could have the values hard coded here.
	**
	** OLE2NOTE: A pseudo object may NOT return OLE_S_USEREG; they must
	**    call the
	**    OleReg* API or provide their own implementation. Because this
	**    pseudo object does NOT implement IPersist, simply a low-level
	**    remoting handler (ProxyManager) object as opposed to a
	**    DefHandler object is used as the handler for the pseudo
	**    object in a clients process space. The ProxyManager does NOT
	**    handle the OLE_S_USEREG return values.
	*/
	OleRegGetMiscStatus((REFCLSID)&CLSID_APP, dwAspect, lpdwStatus);

	/* OLE2NOTE: check if the pseudo object is compatible to be
	**    linked by an OLE 1.0 container. it is compatible if
	**    either the pseudo object is an untitled document or a
	**    file-based document. if the pseudo object is part of
	**    an embedded object, then it is NOT compatible to be
	**    linked by an OLE 1.0 container. if it is compatible then
	**    we should include OLEMISC_CANLINKBYOLE1 as part of the
	**    dwStatus flags.
	*/
	if (lpOutlineDoc->m_docInitType == DOCTYPE_NEW ||
		lpOutlineDoc->m_docInitType == DOCTYPE_FROMFILE)
		*lpdwStatus |= OLEMISC_CANLINKBYOLE1;

	return NOERROR;
}


STDMETHODIMP PseudoObj_OleObj_SetColorScheme(
		LPOLEOBJECT             lpThis,
		LPLOGPALETTE            lpLogpal
)
{
	OleDbgOut2("PseudoObj_OleObj_SetColorScheme\r\n");

	// REVIEW: NOT YET IMPLEMENTED

	return ResultFromScode(E_NOTIMPL);
}


/*************************************************************************
** PseudoObj::IDataObject interface implementation
*************************************************************************/

STDMETHODIMP PseudoObj_DataObj_QueryInterface (
		LPDATAOBJECT      lpThis,
		REFIID            riid,
		LPVOID FAR*       lplpvObj
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;

	return PseudoObj_QueryInterface(lpPseudoObj, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) PseudoObj_DataObj_AddRef(LPDATAOBJECT lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgAddRefMethod(lpThis, "IDataObject");

	return PseudoObj_AddRef((LPPSEUDOOBJ)lpPseudoObj);
}


STDMETHODIMP_(ULONG) PseudoObj_DataObj_Release (LPDATAOBJECT lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgReleaseMethod(lpThis, "IDataObject");

	return PseudoObj_Release((LPPSEUDOOBJ)lpPseudoObj);
}


STDMETHODIMP PseudoObj_DataObj_GetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpMedium
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC  lpServerDoc = lpPseudoObj->m_lpDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOLEAPP  lpOleApp = (LPOLEAPP)lpServerApp;
	LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpServerApp;
	LINERANGE lrSel;
	SCODE sc = S_OK;
	OLEDBG_BEGIN2("PseudoObj_DataObj_GetData\r\n")

	PseudoObj_GetSel(lpPseudoObj, &lrSel);

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	lpMedium->tymed = TYMED_NULL;
	lpMedium->pUnkForRelease = NULL;    // we transfer ownership to caller
	lpMedium->hGlobal = NULL;

	if (lpformatetc->cfFormat == lpOutlineApp->m_cfOutline) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_HGLOBAL)) {
			sc = DATA_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal = OutlineDoc_GetOutlineData (lpOutlineDoc,&lrSel);
		if (! lpMedium->hGlobal) return ResultFromScode(E_OUTOFMEMORY);
		lpMedium->tymed = TYMED_HGLOBAL;
		OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_OUTLINE\r\n");

	} else if(lpformatetc->cfFormat == CF_METAFILEPICT &&
		(lpformatetc->dwAspect & DVASPECT_CONTENT) ) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_MFPICT)) {
			sc = DATA_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal=ServerDoc_GetMetafilePictData(lpServerDoc,&lrSel);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}
		lpMedium->tymed = TYMED_MFPICT;
		OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_METAFILEPICT\r\n");

	} else if (lpformatetc->cfFormat == CF_METAFILEPICT &&
		(lpformatetc->dwAspect & DVASPECT_ICON) ) {
		CLSID clsid;
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_MFPICT)) {
			sc = DATA_E_FORMATETC;
			goto error;
		}

		/* OLE2NOTE: we should return the default icon for our class.
		**    we must be carefull to use the correct CLSID here.
		**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
		**    operation then we need to use the class of the object
		**    written in the storage of the object. otherwise we would
		**    use our own class id.
		*/
		if (ServerDoc_GetClassID(lpServerDoc, (LPCLSID)&clsid) != NOERROR) {
			sc = DATA_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal=GetIconOfClass(
				g_lpApp->m_hInst,(REFCLSID)&clsid, NULL, FALSE);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}

		lpMedium->tymed = TYMED_MFPICT;
		OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_METAFILEPICT (icon)\r\n");
		return NOERROR;

	} else if (lpformatetc->cfFormat == CF_TEXT) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_HGLOBAL)) {
			sc = DATA_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal = OutlineDoc_GetTextData (lpOutlineDoc, &lrSel);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}
		lpMedium->tymed = TYMED_HGLOBAL;
		OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_TEXT\r\n");

	} else {
		sc = DATA_E_FORMATETC;
		goto error;
	}

	OLEDBG_END2
	return NOERROR;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_DataObj_GetDataHere (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpMedium
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC  lpServerDoc = lpPseudoObj->m_lpDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOLEAPP  lpOleApp = (LPOLEAPP)lpServerApp;
	LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpServerApp;
	OleDbgOut("PseudoObj_DataObj_GetDataHere\r\n");

	/* Caller is requesting data to be returned in Caller allocated
	**    medium, but we do NOT support this. we only support
	**    global memory blocks that WE allocate for the caller.
	*/
	return ResultFromScode(DATA_E_FORMATETC);
}


STDMETHODIMP PseudoObj_DataObj_QueryGetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC  lpServerDoc = lpPseudoObj->m_lpDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOLEAPP  lpOleApp = (LPOLEAPP)lpServerApp;
	LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpServerApp;
	OleDbgOut2("PseudoObj_DataObj_QueryGetData\r\n");

	/* Caller is querying if we support certain format but does not
	**    want any data actually returned.
	*/
	if (lpformatetc->cfFormat == CF_METAFILEPICT &&
		(lpformatetc->dwAspect & (DVASPECT_CONTENT | DVASPECT_ICON)) ) {
		return OleStdQueryFormatMedium(lpformatetc, TYMED_MFPICT);

	} else if (lpformatetc->cfFormat == (lpOutlineApp)->m_cfOutline ||
			lpformatetc->cfFormat == CF_TEXT) {
		return OleStdQueryFormatMedium(lpformatetc, TYMED_HGLOBAL);
	}

	return ResultFromScode(DATA_E_FORMATETC);
}


STDMETHODIMP PseudoObj_DataObj_GetCanonicalFormatEtc(
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPFORMATETC     lpformatetcOut
)
{
	HRESULT hrErr;
	OleDbgOut2("PseudoObj_DataObj_GetCanonicalFormatEtc\r\n");

	if (!lpformatetcOut)
		return ResultFromScode(E_INVALIDARG);

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	lpformatetcOut->ptd = NULL;

	if (!lpformatetc)
		return ResultFromScode(E_INVALIDARG);

	// OLE2NOTE: we must validate that the format requested is supported
	if ((hrErr=lpThis->lpVtbl->QueryGetData(lpThis,lpformatetc)) != NOERROR)
		return hrErr;

	/* OLE2NOTE: an app that is insensitive to target device (as the
	**    Outline Sample is) should fill in the lpformatOut parameter
	**    but NULL out the "ptd" field; it should return NOERROR if the
	**    input formatetc->ptd what non-NULL. this tells the caller
	**    that it is NOT necessary to maintain a separate screen
	**    rendering and printer rendering. if should return
	**    DATA_S_SAMEFORMATETC if the input and output formatetc's are
	**    identical.
	*/

	*lpformatetcOut = *lpformatetc;
	if (lpformatetc->ptd == NULL)
		return ResultFromScode(DATA_S_SAMEFORMATETC);
	else {
		lpformatetcOut->ptd = NULL;
		return NOERROR;
	}
}


STDMETHODIMP PseudoObj_DataObj_SetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpmedium,
		BOOL            fRelease
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC  lpServerDoc = lpPseudoObj->m_lpDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp;

	OleDbgOut2("PseudoObj_DataObj_SetData\r\n");

	// REVIEW: NOT-YET-IMPLEMENTED
	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP PseudoObj_DataObj_EnumFormatEtc(
		LPDATAOBJECT            lpThis,
		DWORD                   dwDirection,
		LPENUMFORMATETC FAR*    lplpenumFormatEtc
)
{
	SCODE sc;
	OleDbgOut2("PseudoObj_DataObj_EnumFormatEtc\r\n");

	/* OLE2NOTE: a pseudo object only needs to enumerate the static list
	**    of formats that are registered for our app in the
	**    registration database. it is NOT
	**    required that a pseudo object (ie. non-DataTransferDoc)
	**    enumerate the OLE formats: CF_LINKSOURCE, CF_EMBEDSOURCE, or
	**    CF_EMBEDDEDOBJECT. we do NOT use pseudo objects for data
	**    transfers.
	**
	**    A pseudo object may NOT return OLE_S_USEREG; they must call the
	**    OleReg* API or provide their own implementation. Because this
	**    pseudo object does NOT implement IPersist, simply a low-level
	**    remoting handler (ProxyManager) object as opposed to a
	**    DefHandler object is used as the handler for the pseudo
	**    object in a clients process space. The ProxyManager does NOT
	**    handle the OLE_S_USEREG return values.
	*/
	if (dwDirection == DATADIR_GET)
		return OleRegEnumFormatEtc(
				(REFCLSID)&CLSID_APP, dwDirection, lplpenumFormatEtc);
	else if (dwDirection == DATADIR_SET)
		sc = E_NOTIMPL;
	else
		sc = E_INVALIDARG;

	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_DataObj_DAdvise(
		LPDATAOBJECT    lpThis,
		FORMATETC FAR*  lpFormatetc,
		DWORD           advf,
		LPADVISESINK    lpAdvSink,
		DWORD FAR*      lpdwConnection
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("PseudoObj_DataObj_DAdvise\r\n")

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lpdwConnection = 0;

	/* OLE2NOTE: we should validate if the caller is setting up an
	**    Advise for a data type that we support. we must
	**    explicitly allow an advise for the "wildcard" advise.
	*/
	if ( !( lpFormatetc->cfFormat == 0 &&
		lpFormatetc->ptd == NULL &&
		lpFormatetc->dwAspect == -1L &&
		lpFormatetc->lindex == -1L &&
		lpFormatetc->tymed == -1L) &&
		(hrErr = PseudoObj_DataObj_QueryGetData(lpThis, lpFormatetc))
			!= NOERROR) {
		sc = GetScode(hrErr);
		goto error;
	}

	if (lpPseudoObj->m_lpDataAdviseHldr == NULL &&
		CreateDataAdviseHolder(&lpPseudoObj->m_lpDataAdviseHldr) != NOERROR) {
		sc = E_OUTOFMEMORY;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::Advise called\r\n")
	hrErr = lpPseudoObj->m_lpDataAdviseHldr->lpVtbl->Advise(
			lpPseudoObj->m_lpDataAdviseHldr,
			(LPDATAOBJECT)&lpPseudoObj->m_DataObject,
			lpFormatetc,
			advf,
			lpAdvSink,
			lpdwConnection
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_DataObj_DUnadvise(LPDATAOBJECT lpThis, DWORD dwConnection)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("PseudoObj_DataObj_Unadvise\r\n");

	// no one registered
	if (lpPseudoObj->m_lpDataAdviseHldr == NULL) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::DUnadvise called\r\n")
	hrErr = lpPseudoObj->m_lpDataAdviseHldr->lpVtbl->Unadvise(
			lpPseudoObj->m_lpDataAdviseHldr,
			dwConnection
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_DataObj_EnumAdvise(
		LPDATAOBJECT lpThis,
		LPENUMSTATDATA FAR* lplpenumAdvise
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("PseudoObj_DataObj_EnumAdvise\r\n");

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpenumAdvise = NULL;

	if (lpPseudoObj->m_lpDataAdviseHldr == NULL) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::EnumAdvise called\r\n")
	hrErr = lpPseudoObj->m_lpDataAdviseHldr->lpVtbl->EnumAdvise(
			lpPseudoObj->m_lpDataAdviseHldr,
			lplpenumAdvise
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\icntrotl\daytona\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\outline\tests.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	tests.c
//
//  Contents:  	unit tests for 32bit OLE
//
//  Classes:
//
//  Functions:	StartClipboardTest1
//
//  History:    dd-mmm-yy Author    Comment
//		16-Jun-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "outline.h"

//+-------------------------------------------------------------------------
//
//  Function:  	StartClipboardTest1
//
//  Synopsis:  	copies the loaded object to the clipboard
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		16-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void StartClipboardTest1( LPOUTLINEAPP lpOutlineApp)
{
        static char FileName[] = "letest12.olc";
	BOOL fStatus;
	HRESULT	hresult = ResultFromScode(E_FAIL);

	lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
	if (! lpOutlineApp->m_lpDoc)
	{
		goto errRtn;
	}

	fStatus = OutlineDoc_LoadFromFile(lpOutlineApp->m_lpDoc,
			FileName);

	if( !fStatus )
	{
		hresult = ResultFromScode(STG_E_FILENOTFOUND);
		goto errRtn;
	}



	// position and size the new doc window
	OutlineApp_ResizeWindows(lpOutlineApp);
	OutlineDoc_ShowWindow(lpOutlineApp->m_lpDoc);


	// we post a message here to give outline a chance to setup its
	// UI before we do the copy.

	UpdateWindow(lpOutlineApp->m_hWndApp);
	OutlineDoc_SelectAllCommand(lpOutlineApp->m_lpDoc);

	PostMessage(lpOutlineApp->m_hWndApp, WM_TEST2, 0, 0);

	return;

errRtn:

	// we should abort if error
	PostMessage(g_hwndDriver, WM_TESTEND, TEST_FAILURE, hresult);
	PostMessage(lpOutlineApp->m_hWndApp, WM_SYSCOMMAND, SC_CLOSE, 0L);


}

//+-------------------------------------------------------------------------
//
//  Function: 	ContinueClipboardTest1
//
//  Synopsis:	finishes up the clipboard test
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	   	16-Jun-94 alexgo    author
//  Notes:
//
//--------------------------------------------------------------------------

void ContinueClipboardTest1( LPOUTLINEAPP lpOutlineApp )
{
	OutlineDoc_CopyCommand(lpOutlineApp->m_lpDoc);

	OleApp_FlushClipboard((LPOLEAPP)lpOutlineApp);

	//flushing will make the app dirty, just reset that here ;-)

	lpOutlineApp->m_lpDoc->m_fModified = FALSE;
	
	PostMessage(g_hwndDriver, WM_TEST1, NOERROR, 0);
	PostMessage(lpOutlineApp->m_hWndApp, WM_SYSCOMMAND, SC_CLOSE, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\memalloc\headers.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	headers.cxx
//
//  Contents:	Memory allocation unit test headers
//
//  History:	13-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\memalloc\cairo\makefile.inc ===
!if $(386)
CPP_CMD=cl386
!endif

!if $(MIPS)
CPP_CMD=mcl
!endif

!if $(ALPHA)
CPP_CMD=$(ALPHA_CC)
!endif

allidl:     test.h

clean:
    erase test.h 1>nul 2>nul

test.h:     ..\test.idl
    midl ..\test.idl               \
          -cswtch test_z.c         \
          -Zp8                     \
          -I$(INCLUDES)            \
          -no_warn                 \
          -char unsigned           \
          -mode c_port             \
          -DMIDL_PASS              \
          $(C_DEFINES)             \
          -cpp_cmd "$(CPP_CMD)"    \
          -cpp_opt "-nologo -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES) -E -Tc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\memalloc\memtest.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	memtest.cxx
//
//  Contents:	Memory allocation API unit test
//
//  Functions:
//
//  History:	13-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop

#include <stdlib.h>
#include <stdio.h>


static DWORD	g_grfGlobal  = GLOBAL_RUN | GLOBAL_CLEANUP;
static DWORD	g_grfPreInit = 0;
static DWORD	g_grfMemory  = 0;
static DWORD	g_grfMIDL    = MIDL_AUTOGO | MIDL_AUTOEND;
static DWORD	g_grfCompat  = 0;

static BOOL	g_fServer = FALSE;


static BOOL	ParseArguments(char *pszName, int cpsz, char **ppsz);
static BOOL	Initialize(void);
static BOOL	Uninitialize(void);

static void	PrintUsage(char *pszName);


//+-------------------------------------------------------------------------
//
//  Function:	main, public
//
//  Synopsis:	Memory allocation test entry point
//
//  Arguments:	[argc] - count of arguments
//		[argv] - list of arguments
//
//  Returns:	Zero if successful, non-zero otherwise
//
//  History:	19-May-93   CarlH	Created
//
//--------------------------------------------------------------------------
int _cdecl main(int argc, char *argv[])
{
    DWORD   grfOptions;
    BOOL    fPassed;

    if (!(fPassed = ParseArguments(argv[0], argc - 1, argv + 1)))
	goto done;

    if (g_fServer)
    {
	if (!(fPassed = Initialize()))
	    goto done;

	grfOptions = g_grfGlobal | g_grfMIDL;
	if (grfOptions & GLOBAL_RUN)
	{
	    if (!(fPassed = TestMIDLServer(grfOptions)))
		goto done;
	}
    }
    else
    {
	//  This test has to be run before initialization since that is
	//  its point.	It tests the memory allocation APIs functionality
	//  before CoInitialize() is called.
	//
	grfOptions = g_grfGlobal | g_grfPreInit;
	if (grfOptions & GLOBAL_RUN)
	{
	    if (!(fPassed = TestPreInit(grfOptions)))
		goto done;
	}

	if (!(fPassed = Initialize()))
	    goto done;

	grfOptions = g_grfGlobal | g_grfMemory;
	if (grfOptions & GLOBAL_RUN)
	{
	    if (!(fPassed = TestMemory(grfOptions)))
		goto done;
	}

	grfOptions = g_grfGlobal | g_grfMIDL;
	if (grfOptions & GLOBAL_RUN)
	{
	    WCHAR   wszServer[MAX_PATH + 1];

	    mbstowcs(wszServer, argv[0], MAX_PATH);
	    if (!(fPassed = TestMIDLClient(wszServer, grfOptions)))
		goto done;
	}

#ifdef LINKED_COMPATIBLE
	grfOptions = g_grfGlobal | g_grfCompat;
	if (grfOptions & GLOBAL_RUN)
	{
	    if (!(fPassed = TestCompatibility(grfOptions)))
		goto done;
	}
#endif // LINKED_COMPATIBLE
    }

    if (!(fPassed = Uninitialize()))
	goto done;

done:
    fprintf(stdout, "%s: %s\n", argv[0], fPassed ? "PASSED" : "FAILED");

    return (fPassed ? 0 : 1);
}


//+-------------------------------------------------------------------------
//
//  Function:	Initialize, public
//
//  Synopsis:	Global initialization routine
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	07-May-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL Initialize(void)
{
    return (SUCCEEDED(CoInitialize(NULL)));
}


//+-------------------------------------------------------------------------
//
//  Function:	Uninitialize, public
//
//  Synopsis:	Global clean-up routine
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	07-May-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL Uninitialize(void)
{
    CoUninitialize();

    return (TRUE);
}


//+-------------------------------------------------------------------------
//
//  Function:	PrintHeader, public
//
//  Synopsis:	Prints the header for a component's test
//
//  Arguments:	[pszComponent] - component test to print header for
//
//  History:	28-Feb-93   CarlH	Created
//
//--------------------------------------------------------------------------
void PrintHeader(char const *pszComponent)
{
    if (g_grfGlobal & GLOBAL_STATUS)
    {
	fprintf(stdout, "%s - running tests\n", pszComponent);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:	PrintResult, public
//
//  Synopsis:	Prints the result of a component's test
//
//  Arguments:	[pszComponent] - component test to print result for
//
//  History:	28-Feb-93   CarlH	Created
//
//--------------------------------------------------------------------------
void PrintResult(char const *pszComponent, BOOL fPassed)
{
    if (g_grfGlobal & GLOBAL_STATUS)
    {
	fprintf(
	    stdout,
	    "%s - tests %s\n",
	    pszComponent,
	    fPassed ? "passed" : "failed");
    }
}


//+-------------------------------------------------------------------------
//
//  Function:	PrintTrace, public
//
//  Synopsis:	Prints a trace message if verbose mode on
//
//  Arguments:	[pszComponent] - component name issuing trace
//		[pszFormat]    - format string
//		[...]	       - arguments for format string
//
//  History:	24-Feb-93   CarlH   Created
//
//--------------------------------------------------------------------------
void PrintTrace(char const *pszComponent, char const *pszFormat, ...)
{
    if (g_grfGlobal & GLOBAL_VERBOSE)
    {
	va_list va;

	fprintf(stdout, "trace: %s - ", pszComponent);

	va_start(va, pszFormat);
	vfprintf(stdout, pszFormat, va);
	va_end(va);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:	PrintError, public
//
//  Synopsis:	Prints an error message
//
//  Arguments:	[pszComponent] - component name issuing trace
//		[pszFormat]    - format string
//		[...]	       - arguments for format string
//
//  History:	24-Feb-93   CarlH   Created
//
//--------------------------------------------------------------------------
void PrintError(char const *pszComponent, char const *pszFormat, ...)
{
    va_list va;

    fprintf(stderr, "error: %s - ", pszComponent);

    va_start(va, pszFormat);
    vfprintf(stderr, pszFormat, va);
    va_end(va);
}


//+-------------------------------------------------------------------------
//
//  Function:	PrintUsage, private
//
//  Synopsis:	Prints a the usage message for this test
//
//  Arguments:	[pszName] - name of the executable
//
//  History:	24-Feb-93   CarlH   Created
//
//--------------------------------------------------------------------------
void PrintUsage(char *pszName)
{
    fprintf(stdout, "Usage: %s {<flag>|<comp>}*\n", pszName);
    fprintf(stdout, "Where: <flag> = {+|-}{?dgecsv}+\n");
    fprintf(stdout, "       <comp> = {preinit|memory|compat|midl}\n");
    fprintf(stdout, "       ? - displays this message\n");
    fprintf(stdout, "       d - turns MIDL debugging on/OFF\n");
    fprintf(stdout, "       g - turns MIDL debugging auto go ON/off\n");
    fprintf(stdout, "       e - turns MIDL debugging auto end ON/off\n");
    fprintf(stdout, "       c - turns cleanup ON/off\n");
    fprintf(stdout, "       s - turns status messages on/OFF\n");
    fprintf(stdout, "       v - turns verbosity on/OFF\n");
}


//+-------------------------------------------------------------------------
//
//  Function:	ParseArguments, private
//
//  Synopsis:	Parses command line arguments
//
//  Arguments:	[pszName] - name of executable
//		[cpsz]	  - number of strings in [ppsz]
//		[ppsz]	  - array of command line arguments
//
//  Returns:	TRUE if successfull, FALSE otherwise
//
//  History:	24-Feb-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL ParseArguments(char *pszName, int cpsz, char **ppsz)
{
    BOOL    fOK = TRUE;

    //	As long as we haven't encountered an error, we want to loop
    //	through all of the arguments, excluding the first, which is
    //	the name of the program (argv[0]).
    //
    for (int ipsz = 0; fOK && (ipsz < cpsz); ipsz++)
    {
	//  If the first character of the argument is a plus or minus,
	//  this argument must be a series of flags.
	//
	if ((ppsz[ipsz][0] == '+') || (ppsz[ipsz][0] == '-'))
	{
	    BOOL    fFlag = (ppsz[ipsz][0] == '+');

	    //	We want to check the rest of the characters in the
	    //	argument.
	    //
	    for (int ich = 1; fOK && (ppsz[ipsz][ich] != '\0'); ich++)
	    {
		switch (ppsz[ipsz][ich])
		{
		case '?':
		    //	User is requesting help, so print the usage
		    //	message and stop parsing.
		    //
		    PrintUsage(pszName);
		    fOK = FALSE;
		    break;

		case 'D':
		case 'd':
		    g_grfMIDL = (fFlag ?
			g_grfMIDL |  MIDL_DEBUG :
			g_grfMIDL & ~MIDL_DEBUG);
		    break;

		case 'G':
		case 'g':
		    g_grfMIDL = (fFlag ?
			g_grfMIDL |  MIDL_AUTOGO :
			g_grfMIDL & ~MIDL_AUTOGO);
		    break;

		case 'E':
		case 'e':
		    g_grfMIDL = (fFlag ?
			g_grfMIDL |  MIDL_AUTOEND :
			g_grfMIDL & ~MIDL_AUTOEND);
		    break;

		case 'C':
		case 'c':
		    //	Turn test cleanup on or off depending on the
		    //	first character of this argument.
		    //
		    g_grfGlobal = (fFlag ?
			g_grfGlobal |  GLOBAL_CLEANUP :
			g_grfGlobal & ~GLOBAL_CLEANUP);
		    break;

		case 'S':
		case 's':
		    //	Turn status messages on or off depending on the
		    //	first character of this argument.
		    //
		    g_grfGlobal = (fFlag ?
			g_grfGlobal |  GLOBAL_STATUS :
			g_grfGlobal & ~GLOBAL_STATUS);
		    break;

		case 'V':
		case 'v':
		    //	Turn verbose mode on or off depending on the
		    //	first character of this argument.
		    //
		    g_grfGlobal = (fFlag ?
			g_grfGlobal |  GLOBAL_VERBOSE :
			g_grfGlobal & ~GLOBAL_VERBOSE);
		    break;

		default:
		    //	We don't know what this is, so tell
		    //	the user and stop parsing.
		    //
		    PrintError(
			pszName,
			"unrecognized switch '%c'\n",
			ppsz[ipsz][ich]);
		    fOK = FALSE;
		    break;
		}
	    }
	}
	else
	if (stricmp(ppsz[ipsz], "preinit") == 0)
	{
	    g_grfGlobal  &= ~GLOBAL_RUN;
	    g_grfPreInit |=  GLOBAL_RUN;
	}
	else
	if (stricmp(ppsz[ipsz], "memory") == 0)
	{
	    g_grfGlobal &= ~GLOBAL_RUN;
	    g_grfMemory |=  GLOBAL_RUN;
	}
	else
	if (stricmp(ppsz[ipsz], "compat") == 0)
	{
	    g_grfGlobal &= ~GLOBAL_RUN;
	    g_grfCompat |=  GLOBAL_RUN;
	}
	else
	if (stricmp(ppsz[ipsz], "midl") == 0)
	{
	    g_grfGlobal &= ~GLOBAL_RUN;
	    g_grfMIDL	|=  GLOBAL_RUN;
	}
	else
	if (stricmp(ppsz[ipsz], "midlserver") == 0)
	{
	    g_fServer = TRUE;
	}
	else
	{
	    PrintError(
		pszName,
		"unrecognized argument \"%s\"\n",
		ppsz[ipsz]);
	    fOK = FALSE;
	}
    }

    return (fOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\memalloc\midl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	midl.cxx
//
//  Contents:	MIDL memory allocation tests
//
//  Functions:
//
//  History:	29-Sep-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop
#include <rpc.h>
#include "test.h"


static const char   g_szMIDLClient[] = "midl";
static const char   g_szMIDLServer[] = "server";

static const WCHAR  g_wszMIDLSignal[] = L"testsignal";
static const WCHAR  g_wszStopSignal[] = L"stopsignal";

static const DWORD  g_ccallMin	    = 1;
static const DWORD  g_ccallMax	    = 1;

static CSignal	    g_sigStop(g_wszStopSignal);


BYTE		g_ab0[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
BYTE		g_ab1[] = {0x00, 0xFF};
BYTE		g_ab2[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
BYTE		g_ab3[] = {0x69};

SCountedBytes	g_acbIn[] =
{
    {(sizeof(g_ab0) / sizeof(g_ab0[0])), g_ab0},
    {(sizeof(g_ab1) / sizeof(g_ab1[0])), g_ab1},
    {(sizeof(g_ab2) / sizeof(g_ab2[0])), g_ab2},
    {(sizeof(g_ab3) / sizeof(g_ab3[0])), g_ab3}
};


SCountedCountedBytes	g_ccbIn =
{
    sizeof(g_acbIn) / sizeof(g_acbIn[0]),
    g_acbIn
};


DWORD	StartServer(WCHAR *pwszServer, DWORD grfOptions);
DWORD	ConnectServer(void);
DWORD	DisconnectServer(void);

BOOL	CompareBytes(SCountedCountedBytes *pccbA, SCountedCountedBytes *pccbB);
BOOL	FreeBytes(SCountedCountedBytes *pccb);

BOOL TestMIDLClient(WCHAR *pwszServer, DWORD grfOptions)
{
    CSignal		    sig(g_wszMIDLSignal);
    SCountedCountedBytes    ccbOut = {0, NULL};
    RPC_STATUS		    stat;
    BOOL		    fPassed;

    PrintHeader(g_szMIDLClient);

    PrintTrace(g_szMIDLClient, "starting server\n");
    stat = StartServer(pwszServer, grfOptions);
    if (!(fPassed = (stat == 0)))
	goto done;

    PrintTrace(g_szMIDLClient, "waiting for server\n");
    stat = sig.Wait(grfOptions & MIDL_DEBUG ? INFINITE : 10000);
    if (!(fPassed = (stat == 0)))
	goto done;

    PrintTrace(g_szMIDLClient, "connecting to server\n");
    stat = ConnectServer();
    if (!(fPassed = (stat == 0)))
	goto done;

    PrintTrace(g_szMIDLClient, "copying bytes\n");
    fPassed = _CopyBytes(&g_ccbIn, &ccbOut);
    if (!fPassed)
	goto done;

    PrintTrace(g_szMIDLClient, "stopping server\n");
    fPassed = _StopServer();
    if (!fPassed)
	goto done;

    PrintTrace(g_szMIDLClient, "comparing bytes\n");
    fPassed = CompareBytes(&g_ccbIn, &ccbOut);
    if (!fPassed)
	goto done;

    PrintTrace(g_szMIDLClient, "freeing bytes\n");
    fPassed = FreeBytes(&ccbOut);
    if (!fPassed)
	goto done;

    PrintTrace(g_szMIDLClient, "disconnecting from server\n");
    stat = DisconnectServer();
    if (!(fPassed = (stat == 0)))
	goto done;

done:
    PrintResult(g_szMIDLClient, fPassed);

    return (fPassed);
}


BOOL TestMIDLServer(DWORD grfOptions)
{
    CSignal	sig(g_wszMIDLSignal);
    RPC_STATUS	stat;
    BOOL	fPassed;

    PrintHeader(g_szMIDLServer);

    PrintTrace(g_szMIDLServer, "registering protocol\n");
    stat = RpcServerUseAllProtseqsIf(g_ccallMax, Test_ServerIfHandle, NULL);
    if (!(fPassed = (stat == 0)))
	goto done;

    PrintTrace(g_szMIDLServer, "registering interface\n");
    stat = RpcServerRegisterIf(Test_ServerIfHandle, NULL, NULL);
    if (!(fPassed = (stat == 0)))
	goto done;

#ifdef NO_OLE_RPC
    PrintTrace(g_szMIDLServer, "listening\n");
    stat = RpcServerListen(
	g_ccallMin,
	g_ccallMax,
	TRUE);
    if (!(fPassed = ((stat == 0) || (stat == RPC_S_ALREADY_LISTENING))))
	goto done;
#endif // NO_OLE_RPC

    PrintTrace(g_szMIDLServer, "signaling client\n");
    stat = sig.Signal();
    if (!(fPassed = (stat == 0)))
	goto done;

    PrintTrace(g_szMIDLServer, "waiting...\n");
#ifdef NO_OLE_RPC
    stat = RpcMgmtWaitServerListen();
    if (!(fPassed = ((stat == 0) || (stat == RPC_S_ALREADY_LISTENING))))
	goto done;
#else
    g_sigStop.Wait();
#endif // NO_OLE_RPC


done:
    PrintResult(g_szMIDLServer, fPassed);

    return (fPassed);
}


boolean CopyBytes(SCountedCountedBytes *pccbIn, SCountedCountedBytes *pccbOut)
{
    HRESULT hr;
    BOOL    fPassed;
    long    ccb = pccbIn->ccb;
    long    icb;

    PrintTrace(g_szMIDLServer, "copying bytes\n");

    pccbOut->ccb = ccb;

    pccbOut->pcb = (SCountedBytes *)CoTaskMemAlloc(ccb * sizeof(*pccbOut->pcb));
    if (!(fPassed = (pccbOut != 0)))
	goto done;

    for (icb = 0; icb < ccb; icb++)
    {
	long	cb = pccbIn->pcb[icb].cb;

	pccbOut->pcb[icb].cb = cb;

	pccbOut->pcb[icb].pb = (byte *)CoTaskMemAlloc(cb);
	if (!(fPassed = (pccbOut->pcb[icb].pb != 0)))
	    goto done;

	memcpy(pccbOut->pcb[icb].pb, pccbIn->pcb[icb].pb, cb);
    }

done:
    return (fPassed);
}


BOOL CompareBytes(SCountedCountedBytes *pccbA, SCountedCountedBytes *pccbB)
{
    BOOL    fPassed;
    long    icb;

    if (!(fPassed = (pccbA->ccb == pccbB->ccb)))
	goto done;

    for (icb = 0; icb < pccbA->ccb; icb++)
    {
	if (!(fPassed = (pccbA->pcb[icb].cb == pccbB->pcb[icb].cb)))
	    goto done;

	int cmp = memcmp(
	    pccbA->pcb[icb].pb,
	    pccbB->pcb[icb].pb,
	    pccbB->pcb[icb].cb);
	if (!(fPassed = (cmp == 0)))
	    goto done;
    }

done:
    return (fPassed);
}


BOOL FreeBytes(SCountedCountedBytes *pccb)
{
    BOOL    fPassed = TRUE;

    for (long icb = 0; icb < pccb->ccb; icb++)
    {
	CoTaskMemFree(pccb->pcb[icb].pb);
    }

    CoTaskMemFree(pccb->pcb);

done:
    return (fPassed);
}


boolean StopServer(void)
{
    BOOL    fPassed;

    PrintTrace(g_szMIDLServer, "stopping\n");

#ifdef NO_OLE_RPC
    fPassed = (RpcMgmtStopServerListening(NULL) == 0);
#else
    g_sigStop.Signal();
    fPassed = TRUE;
#endif // NO_OLE_RPC

    return (fPassed);
}


DWORD StartServer(WCHAR *pwszServer, DWORD grfOptions)
{
    WCHAR	wszCommandLine[MAX_PATH + 1];
    ULONG	cwchDebug;
    BOOL	fOK;
    DWORD	stat;

    if (grfOptions & MIDL_DEBUG)
    {
	cwchDebug = wsprintf(
	    wszCommandLine,
	    L"ntsd %ws %ws ",
	    (grfOptions & MIDL_AUTOGO  ? L"-g" : L""),
	    (grfOptions & MIDL_AUTOEND ? L"-G" : L""));
    }
    else
    {
	cwchDebug = 0;
    }

    wsprintf(
	wszCommandLine + cwchDebug,
	L"%ws midlserver %cc %cs %cv",
	pwszServer,
	(grfOptions & GLOBAL_CLEANUP ? '+' : '-'),
	(grfOptions & GLOBAL_STATUS  ? '+' : '-'),
	(grfOptions & GLOBAL_VERBOSE ? '+' : '-'));

    PrintTrace(g_szMIDLClient, "server command line: %ws\n", wszCommandLine);

    STARTUPINFO 	sui;
    PROCESS_INFORMATION pi;

    sui.cb	    = sizeof(sui);
    sui.lpReserved  = 0;
    sui.lpDesktop   = 0;
    sui.lpTitle     = wszCommandLine;
    sui.dwFlags     = 0;
    sui.cbReserved2 = 0;
    sui.lpReserved2 = 0;

    fOK = CreateProcess(
	NULL,
	wszCommandLine,
	NULL,
	NULL,
	FALSE,
	CREATE_NEW_CONSOLE,
	NULL,
	NULL,
	&sui,
	&pi);
    if (fOK)
    {
	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);

	stat = 0;
    }
    else
    {
	stat = GetLastError();
    }

    return (stat);
}


DWORD ConnectServer(void)
{
    RPC_STATUS	stat;
    WCHAR      *pwszBinding;

    stat = RpcStringBindingCompose(
	NULL,
	PWSZ_PROTOCOL,
	NULL,
	PWSZ_ENDPOINT,
	NULL,
	&pwszBinding);
    if (stat == 0)
    {
	stat = RpcBindingFromStringBinding(pwszBinding, &g_hbindTest);
	RpcStringFree(&pwszBinding);
    }

    return (stat);
}


DWORD DisconnectServer(void)
{
    RPC_STATUS	stat;

    stat = RpcBindingFree(&g_hbindTest);

    return (stat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\memalloc\daytona\makefile.inc ===
!if $(386)
CPP_CMD=cl386
!endif

!if $(MIPS)
CPP_CMD=mcl
!endif

!if $(ALPHA)
CPP_CMD=$(ALPHA_CC)
!endif

allidl:     test.h

clean:
    erase test.h 1>nul 2>nul

test.h:     ..\test.idl
    midl ..\test.idl               \
          -cswtch test_z.c         \
          -Zp8                     \
          -I$(INCLUDES)            \
          -no_warn                 \
          -char unsigned           \
          -mode c_port             \
          -DMIDL_PASS              \
          $(C_DEFINES)             \
          -cpp_cmd "$(CPP_CMD)"    \
          -cpp_opt "-nologo -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES) -E -Tc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\memalloc\memtask.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	memtask.cxx
//
//  Contents:	Memory task functions
//
//  Functions:	RunMemoryTasks
//
//  History:	17-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop


#ifdef LINKED_COMPATIBLE
#include <memalloc.h>
#endif


//+-------------------------------------------------------------------------
//
//  Function:	RunMemoryTasks, public
//
//  Synopsis:	Runs through a series of memory tasks
//
//  Arguments:	[pszComponent] - current test component name
//		[pmemtsk]      - pointer to memory tasks to run
//		[cmemtsk]      - count of memory tasks
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  Algorithm:	A buffer is first allocated and cleared to hold the
//		blocks returned by any allocations.  The array of
//		tasks is then iterated through an each memory task
//		is performed.  The given task array should be
//		constructed so that all allocated memory is freed.
//
//  History:	17-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL RunMemoryTasks(char *pszComponent, SMemTask *pmemtsk, ULONG cmemtsk)
{
    void      **ppvMemory;
    HRESULT	hr;
    BOOL	fPassed = TRUE;

    //	Allocate and clear an array of void *'s to hold the pointers
    //	returned by any allocations made during the test.
    //
    ppvMemory = new void *[cmemtsk];
    for (ULONG ipv = 0; ipv < cmemtsk; ipv++)
    {
	ppvMemory[ipv] = NULL;
    }

    //	For each entry in the array of tasks, figure out what type
    //	of operation is being requested and do it.
    //
    for (ULONG imemtsk = 0; (imemtsk < cmemtsk) && fPassed; imemtsk++)
    {
	switch (pmemtsk[imemtsk].memop)
	{
#ifdef LINKED_COMPATIBLE
	case memopOldAlloc:
	    PrintTrace(
		pszComponent,
		"old allocating a block of %lu bytes\n",
		pmemtsk[imemtsk].cb);
	    hr = MemAlloc(pmemtsk[imemtsk].cb, ppvMemory + imemtsk);
	    PrintTrace(
		pszComponent,
		"old allocated block at %p\n",
		ppvMemory[imemtsk]);
	    break;

	case memopOldAllocLinked:
	    PrintTrace(
		pszComponent,
		"old allocating a linked block of %lu bytes on %p\n",
		pmemtsk[imemtsk].cb,
		ppvMemory[pmemtsk[imemtsk].imemtsk]);
	    hr = MemAllocLinked(
		ppvMemory[pmemtsk[imemtsk].imemtsk],
		pmemtsk[imemtsk].cb,
		ppvMemory + imemtsk);
	    PrintTrace(
		pszComponent,
		"old allocated block at %p\n",
		ppvMemory[imemtsk]);
	    break;

	case memopOldFree:
	    PrintTrace(
		pszComponent,
		"old freeing block at %p\n",
		ppvMemory[pmemtsk[imemtsk].imemtsk]);
	    hr = MemFree(ppvMemory[pmemtsk[imemtsk].imemtsk]);
	    break;

#ifdef TEST_MIDL
	case memopMIDLAlloc:
	    TRY
	    {
		PrintTrace(
		    pszComponent,
		    "MIDL allocating a block of %lu bytes\n",
		    pmemtsk[imemtsk].cb);
		ppvMemory[imemtsk] = MIDL_user_allocate(pmemtsk[imemtsk].cb);
		PrintTrace(
		    pszComponent,
		    "MIDL allocated block at %p\n",
		    ppvMemory[imemtsk]);
		hr = NO_ERROR;
	    }
	    CATCH(CException, e)
	    {
		hr = e.GetErrorCode();
	    }
	    END_CATCH;
	    break;

	case memopMIDLFree:
	    TRY
	    {
		PrintTrace(
		    pszComponent,
		    "MIDL freeing block at %p\n",
		    ppvMemory[pmemtsk[imemtsk].imemtsk]);
		MIDL_user_free(ppvMemory[pmemtsk[imemtsk].imemtsk]);
		hr = NO_ERROR;
	    }
	    CATCH(CException, e)
	    {
		hr = e.GetErrorCode();
	    }
	    END_CATCH;
	    break;
#endif // TEST_MIDL

#endif // LINKED_COMPATIBLE
	case memopAlloc:
	    //	A standard memory allocation is being requested.
	    //	Allocate the number of bytes given in the task
	    //	description and store the block in our array of
	    //	void *'s.
	    //
	    PrintTrace(
		pszComponent,
		"allocating a block of %lu bytes\n",
		pmemtsk[imemtsk].cb);
	    ppvMemory[imemtsk] = CoTaskMemAlloc(pmemtsk[imemtsk].cb);
	    PrintTrace(
		pszComponent,
		"allocated block at %p\n",
		ppvMemory[imemtsk]);
	    hr = (ppvMemory[imemtsk] != 0 ? S_OK : -1);
	    break;

	case memopFree:
	    //	A standard memory free is being requested.  Free
	    //	the block found in our array of void *'s specified
	    //	by the index found in the task description.
	    //
	    PrintTrace(
		pszComponent,
		"freeing block at %p\n",
		ppvMemory[pmemtsk[imemtsk].imemtsk]);
	    CoTaskMemFree(ppvMemory[pmemtsk[imemtsk].imemtsk]);
	    hr = S_OK;
	    break;

	default:
	    //	Uh oh.	We found a memory operation that we don't
	    //	understand.  Set the result code to a value that
	    //	we know will cause the test to fail.
	    //
	    PrintError(pszComponent, "unknown memory operation\n");
	    hr = pmemtsk[imemtsk].hr + 1;
	    break;
	}

	//  Make sure that the returned error code was what we expected
	//  for this task.
	//
	fPassed = (hr == pmemtsk[imemtsk].hr);
    }

    delete ppvMemory;

    return (fPassed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\memalloc\signal.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	signal.cxx
//
//  Contents:	Signal class implementation
//
//  Classes:	CSignal
//
//  History:	29-Sep-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include <windows.h>
#include "signal.hxx"
#pragma  hdrstop


CSignal::CSignal(WCHAR const *pwszName) :
    _pwszName(new WCHAR[wcslen(pwszName) + 1]),
    _hevent(0)
{
    wcscpy(_pwszName, pwszName);
}


CSignal::~CSignal(void)
{
    delete _pwszName;
    if (_hevent != 0)
    {
	CloseHandle(_hevent);
    }
}


DWORD CSignal::Wait(DWORD dwTimeout)
{
    DWORD   stat = 0;

    if (_hevent == 0)
    {
	_hevent = CreateEvent(NULL, TRUE, FALSE, _pwszName);
	if (_hevent == 0)
	{
	    stat = GetLastError();
	}
    }

    if (stat == 0)
    {
	stat = WaitForSingleObject(_hevent, dwTimeout);
	if (stat == 0)
	{
	    ResetEvent(_hevent);
	}
    }

    return (stat);
}


DWORD CSignal::Signal(void)
{
    DWORD   stat = 0;

    if (_hevent == 0)
    {
	_hevent = CreateEvent(NULL, TRUE, FALSE, _pwszName);
	if (_hevent == 0)
	{
	    stat = GetLastError();
	}
    }

    if (stat == 0)
    {
	if (!SetEvent(_hevent))
	{
	    stat = GetLastError();
	}
    }

    return (stat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\memalloc\memory.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	memory.cxx
//
//  Contents:	Memory allocation tests
//
//  Functions:
//
//  History:	13-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop


static char g_szMemory[] = "memory";

//  WARNING:	Do not just start whacking on the elements of this
//		array.	The third element of each structure may hold
//		the index of another entry in the array.  If elements
//		are inserted, these indices may get hosed!
//
static SMemTask g_amemtskStandard[] =
{
    {memopAlloc,	 128,  0, S_OK},
    {memopFree, 	   0,  0, S_OK},
    {memopAlloc,	  12,  0, S_OK},
    {memopAlloc,	1423,  0, S_OK},
    {memopFree, 	   0,  2, S_OK},
    {memopAlloc,	  12,  0, S_OK},
    {memopFree, 	   0,  3, S_OK},
    {memopFree, 	   0,  5, S_OK}
};

static ULONG	g_cmemtskStandard =
    sizeof(g_amemtskStandard) / sizeof(g_amemtskStandard[0]);


//  WARNING:	See warning on the above array definition.
//
static SMemTask g_amemtskMIDL[] =
{
    {memopMIDLAlloc,	 128,  0, S_OK},
    {memopMIDLFree,	   0,  0, S_OK},
    {memopMIDLAlloc,	  12,  0, S_OK},
    {memopMIDLAlloc,	1423,  0, S_OK},
    {memopMIDLFree,	   0,  2, S_OK},
    {memopMIDLAlloc,	  12,  0, S_OK},
    {memopMIDLFree,	   0,  3, S_OK},
    {memopMIDLFree,	   0,  5, S_OK}
};

static ULONG	g_cmemtskMIDL =
    sizeof(g_amemtskMIDL) / sizeof(g_amemtskMIDL[0]);


BOOL TestStandard(DWORD grfOptions);
BOOL TestMIDL(DWORD grfOptions);


//+-------------------------------------------------------------------------
//
//  Function:	TestMemory, public
//
//  Synopsis:	Tests simple memory allocation functionality
//
//  Arguments:	[grfOptions] - options for test
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	17-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL TestMemory(DWORD grfOptions)
{
    BOOL    fPassed;

    PrintHeader(g_szMemory);

    if (!(fPassed = TestStandard(grfOptions)))
	goto done;

#ifdef TEST_MIDL
    if (!(fPassed = TestMIDL(grfOptions)))
	goto done;
#endif // TEST_MIDL

done:
    PrintResult(g_szMemory, fPassed);

    return (fPassed);
}


//+-------------------------------------------------------------------------
//
//  Function:	TestStandard, public
//
//  Synopsis:	Tests standard memory allocation routines (not linked)
//
//  Arguments:	[grfOptions] - options for test
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	17-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL TestStandard(DWORD grfOptions)
{
    PrintTrace(g_szMemory, "testing standard allocations\n");

    return (RunMemoryTasks(g_szMemory, g_amemtskStandard, g_cmemtskStandard));
}


//+-------------------------------------------------------------------------
//
//  Function:	TestMIDL, public
//
//  Synopsis:	Tests RPC memory allocation routines (not linked)
//
//  Arguments:	[grfOptions] - options for test
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	17-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL TestMIDL(DWORD grfOptions)
{
    PrintTrace(g_szMemory, "testing MIDL allocations\n");

    return (RunMemoryTasks(g_szMemory, g_amemtskMIDL, g_cmemtskMIDL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\memalloc\preinit.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	preinit.cxx
//
//  Contents:	Pre-initialization memory allocation tests
//
//  Functions:	TestPreInit
//
//  History:	24-Jan-94   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop


static char g_szPreInit[] = "preinit";

//  WARNING:	Do not just start whacking on the elements of this
//		array.	The third element of each structure may hold
//		the index of another entry in the array.  If elements
//		are inserted, these indices may get hosed!
//
static SMemTask g_amemtskPreInitialize[] =
{
    {memopAlloc,	 128,  0, S_OK},
    {memopFree, 	   0,  0, S_OK},
    {memopAlloc,	  12,  0, S_OK},
    {memopAlloc,	1423,  0, S_OK},
    {memopFree, 	   0,  2, S_OK},
    {memopAlloc,	  12,  0, S_OK},
    {memopFree, 	   0,  3, S_OK},
    {memopFree, 	   0,  5, S_OK}
};

static ULONG	g_cmemtskPreInitialize =
    sizeof(g_amemtskPreInitialize) / sizeof(g_amemtskPreInitialize[0]);


BOOL	TestGetAllocator(DWORD grfOptions);
BOOL	TestPreInitialize(DWORD grfOptions);


//+-------------------------------------------------------------------------
//
//  Function:	TestPreInitialize, public
//
//  Synopsis:	Tests pre-initialization memory allocation functionality
//
//  Arguments:	[grfOptions] - options for test
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	24-Jan-94   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL TestPreInit(DWORD grfOptions)
{
    BOOL    fPassed;

    PrintHeader(g_szPreInit);

    if (!(fPassed = TestGetAllocator(grfOptions)))
	goto done;

    if (!(fPassed = TestPreInitialize(grfOptions)))
	goto done;

done:
    PrintResult(g_szPreInit, fPassed);

    return (fPassed);
}


BOOL TestGetAllocator(DWORD grfOptions)
{
    IMalloc    *pmalloc;
    HRESULT	hr;
    BOOL	fPassed;

    PrintTrace(g_szPreInit, "testing default allocator\n");

    hr = CoGetMalloc(MEMCTX_TASK, &pmalloc);
    if (fPassed = SUCCEEDED(hr))
    {
	pmalloc->Release();
    }

    return (fPassed);
}


//+-------------------------------------------------------------------------
//
//  Function:	TestPreInitialize, public
//
//  Synopsis:	Tests standard memory allocation routines
//
//  Arguments:	[grfOptions] - options for test
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	24-Jan-94   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL TestPreInitialize(DWORD grfOptions)
{
    PrintTrace(g_szPreInit, "testing standard allocations\n");

    return (
	RunMemoryTasks(
	    g_szPreInit,
	    g_amemtskPreInitialize,
	    g_cmemtskPreInitialize));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\memalloc\chicago\makefile.inc ===
!if $(386)
CPP_CMD=cl386
!endif

!if $(MIPS)
CPP_CMD=mcl
!endif

!if $(ALPHA)
CPP_CMD=$(ALPHA_CC)
!endif

allidl:     test.h

clean:
    erase test.h 1>nul 2>nul

test.h:     ..\test.idl
    midl ..\test.idl               \
          -cswtch test_z.c         \
          -Zp8                     \
          -I$(INCLUDES)            \
          -no_warn                 \
          -char unsigned           \
          -mode c_port             \
          -DMIDL_PASS              \
          $(C_DEFINES)             \
          -cpp_cmd "$(CPP_CMD)"    \
          -cpp_opt "-nologo -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES) -E -Tc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\demorc.h ===
/*
 * demorc.h - Header file for OLE demo's resource file.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

/* Application resource ID */

#define ID_APPLICATION 1

#define POS_FILEMENU    0
/* File menu */
#define IDM_NEW         0x100
#define IDM_OPEN        0x101
#define IDM_SAVE        0x102
#define IDM_SAVEAS      0x103
#define IDM_EXIT        0x104
#define IDM_ABOUT       0x105

#define POS_EDITMENU    1
/* Edit menu */
#define IDM_CUT         0x200
#define IDM_COPY        0x201
#define IDM_PASTE       0x202
#define IDM_PASTELINK   0x203
#define IDM_CLEAR       0x204
#define IDM_CLEARALL    0x205
#define IDM_LINKS       0x206

/* Object popup menu */
#define POS_OBJECT	   9	// position of Object item in Edit menu
#define IDM_OBJECT      0x210
#define IDM_VERBMIN     0x211
#define IDM_VERBMAX     0x220	// Put this up to 220 (15 verbs) !!!
#define CVERBSMAX       (IDM_VERBMAX - IDM_VERBMIN + 1)

#define POS_OBJECTMENU  2
#define IDM_INSERT	   0x300
#define IDM_INSERTFILE  0x301

#define IDM_UNDO        0x400	/* Only used internally */
#define IDM_LOAD	      0x401
#define IDM_UPDATE      0x402


/* Dialog box ids */
#define DTPROP          1
#define DTINVALIDLINK   2
#define DTCREATE        3

#define IDD_LINKNAME    0x200
#define IDD_AUTO	      0x201	// Auto update
#define IDD_MANUAL	   0x202	// Manual update
#define IDD_EDIT	      0x203	// Edit Object button
#define IDD_FREEZE	   0x204	// Cancel Link button
#define IDD_UPDATE	   0x205	// Update Now Button
#define IDD_CHANGE	   0x206	// Change Links Button
#define IDD_LINKDONE	   0x207	// ???
#define IDD_PLAY	      0x208	// Activate Button
#define IDD_LISTBOX	   0x209	// List of Links List Box
#define IDD_DESTROY     0x20A

#define IDD_YES         0x210
#define IDD_NO          0x211	
#define IDD_RETRY       0x212	
#define IDD_SWITCH      0x213
#define IDD_RETRY_TEXT1 0x214
#define IDD_RETRY_TEXT2 0x215

/* String table constants */
#define CBMESSAGEMAX       80
#define IDS_APPNAME        0x100
#define IDS_UNTITLED       0x101
#define IDS_MAYBESAVE      0x102
#define IDS_OPENFILE	      0x103
#define IDS_SAVEFILE	      0x104
#define IDS_INSERTFILE	   0x105
#define IDS_FILTER	      0x106
#define IDS_EXTENSION	   0x107
#define IDS_CHANGELINK     0x108
#define IDS_ALLFILTER      0x109
#define IDS_EMBEDDED       0x10a
#define IDS_UPDATELINKS    0x10b
#define IDS_RENAME         0x10c
#define IDS_INVALID_LINK   0x10d
#define IDS_SAVE_CHANGES   0x10e
#define IDS_UPDATE_OBJ     0x110
#define IDS_RETRY_TEXT1    0x111
#define IDS_RETRY_TEXT2    0x112

/* Error messages */
#define E_FAILED_TO_OPEN_FILE           0x200
#define E_FAILED_TO_READ_FILE           0x201
#define E_FAILED_TO_SAVE_FILE           0x202
#define E_INVALID_FILENAME              0x203
#define E_CREATE_FROM_TEMPLATE          0x204
#define E_FAILED_TO_WRITE_OBJECT        0x205
#define E_FAILED_TO_READ_OBJECT         0x206
#define E_FAILED_TO_DELETE_OBJECT       0x207
#define E_CLIPBOARD_CUT_FAILED          0x208
#define E_CLIPBOARD_COPY_FAILED         0x209
#define E_GET_FROM_CLIPBOARD_FAILED     0x20a
#define E_FAILED_TO_CREATE_CHILD_WINDOW 0x20b
#define E_FAILED_TO_CREATE_OBJECT	    0x20c
#define E_OBJECT_BUSY			          0x20d
#define E_UNEXPECTED_RELEASE            0x20e
#define E_FAILED_TO_LAUNCH_SERVER       0x20f
#define E_FAILED_TO_UPDATE              0x210
#define E_FAILED_TO_FREEZE              0x211
#define E_FAILED_TO_UPDATE_LINK         0x212
#define E_SERVER_BUSY                   0x213
#define E_FAILED_TO_RECONNECT_OBJECT    0x214
#define E_FAILED_TO_CONNECT		       0x215
#define E_FAILED_TO_RELEASE_OBJECT      0x216
#define E_FAILED_TO_ALLOC               0x217
#define E_FAILED_TO_LOCK                0x218     
#define E_FAILED_TO_DO_VERB             0x219

#define W_IMPROPER_LINK_OPTIONS         0x300
#define W_STATIC_OBJECT                 0x301
#define W_FAILED_TO_CLONE_UNDO          0x302
#define W_FAILED_TO_NOTIFY              0x303

#define SZAUTO    0x400
#define SZMANUAL  0x401
#define SZFROZEN  0x402

#define E_OLE_ERROR_PROTECT_ONLY          3 
#define E_OLE_ERROR_MEMORY                4
#define E_OLE_ERROR_STREAM                5
#define E_OLE_ERROR_STATIC                6
#define E_OLE_ERROR_BLANK                 7
#define E_OLE_ERROR_DRAW                  8
#define E_OLE_ERROR_METAFILE              9
#define E_OLE_ERROR_ABORT                 10
#define E_OLE_ERROR_CLIPBOARD             11
#define E_OLE_ERROR_FORMAT                12
#define E_OLE_ERROR_OBJECT                13
#define E_OLE_ERROR_OPTION                14
#define E_OLE_ERROR_PROTOCOL              15
#define E_OLE_ERROR_ADDRESS               16
#define E_OLE_ERROR_NOT_EQUAL             17
#define E_OLE_ERROR_HANDLE                18
#define E_OLE_ERROR_GENERIC               19
#define E_OLE_ERROR_CLASS                 20
#define E_OLE_ERROR_SYNTAX                21
#define E_OLE_ERROR_DATATYPE              22
#define E_OLE_ERROR_PALETTE               23
#define E_OLE_ERROR_NOT_LINK              24
#define E_OLE_ERROR_NOT_EMPTY             25
#define E_OLE_ERROR_SIZE                  26
#define E_OLE_ERROR_DRIVE                 27
#define E_OLE_ERROR_NETWORK               28
#define E_OLE_ERROR_NAME                  29
#define E_OLE_ERROR_TEMPLATE              30
#define E_OLE_ERROR_NEW                   31
#define E_OLE_ERROR_EDIT                  32
#define E_OLE_ERROR_OPEN                  33
#define E_OLE_ERROR_NOT_OPEN              34
#define E_OLE_ERROR_LAUNCH                35
#define E_OLE_ERROR_COMM                  36
#define E_OLE_ERROR_TERMINATE             37
#define E_OLE_ERROR_COMMAND               38
#define E_OLE_ERROR_SHOW                  39
#define E_OLE_ERROR_DOVERB                40
#define E_OLE_ERROR_ADVISE_NATIVE         41 
#define E_OLE_ERROR_ADVISE_PICT           42
#define E_OLE_ERROR_ADVISE_RENAME         43
#define E_OLE_ERROR_POKE_NATIVE           44
#define E_OLE_ERROR_REQUEST_NATIVE        45
#define E_OLE_ERROR_REQUEST_PICT          46
#define E_OLE_ERROR_SERVER_BLOCKED        47
#define E_OLE_ERROR_REGISTRATION          48
#define E_OLE_ERROR_ALREADY_REGISTERED    49
#define E_OLE_ERROR_TASK                  50
#define E_OLE_ERROR_OUTOFDATE             51
#define E_OLE_ERROR_CANT_UPDATE_CLIENT    52
#define E_OLE_ERROR_UPDATE                53
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\cliver.h ===
#define CLIVER_DEBUG    0
#define CLIVER_PRERELEASE   1

#define CLIVER_FILEFLAGS    (CLIVER_PRERELEASE|CLIVER_DEBUG)

#define CLIVER_FILEOS           VOS_DOS_WINDOWS16
#define CLIVER_FILEVERSION      1,01
#define CLIVER_PRODUCTVERSION   1,01,0,00
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\clidemo.c ===
/*
 * clidemo.c - OLE client application sample code
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 *
 */

 /***************************************************************************
 * IMPORTANT - README:
 * OLE client applications are windows programs which use the OLE client
 * APIs.  Therefore it is imperative that you understand how these APIs
 * operate. Most importantly it is essential that you keep in mind which
 * procedure calls result in asynchronous states: a state where the operation
 * is not truely complete after a return from the call.
 *
 * Many functions produce asynchronous states, for example, OleActivate,
 * OleClose, OleCopyFromLink, OleCreate ... Reference your SDK manual for
 * a complete list.
 *
 * So whenever you call any of these library functions keep in mind that
 * the operation is not necessarily complete once a return is made.
 * These operations require communications with a server application.  With
 * OLE the inter-application communication is done through DDE.  In order
 * for a DDE conversation to complete several DDE messages need to be
 * sent and recieved by both the server and client OLE DLLs.  So, the
 * asynchronous operations will not complete until the client application
 * enters a message dipatch loop.  Therefore, it is necessary to enter
 * a dispatch loop and wait for completion.  It is not necessary to block
 * all other operation; however, it is very important to coordinate the
 * user activity to prevent disastrous re-entry cases.
 *
 * In this application I have written a macro to prevent re-entry
 * problems.  Namely: ANY_OBJECT_BUSY which prevents a user from initiating
 * an action which will result in an asynchronous call if there is an object
 * already in an asynchronous state.
 *
 * The following is brief summary of the three macros:
 *
 * ANY_OBJECT_BUSY: checks to see if any object in the document is busy.
 *              This prevents a new document from being saved to file if there are
 *              objects in asynchronous states.
 *
 * So, the problem is that we have to enter a message dispatch loop in order
 * to let DDE messages get through so that asynchronous operations can finish.
 * And while we are in the message dispatch loops (WaitForObject or WaitForAllObjects)
 * we have to prevent the user from doing things that can't be done when an
 * object(s) is busy.  Yes, it is confusing , but, the end result is a super
 * cool application that can have linked and embbeded objects!
 ***************************************************************************/

//*** INCLUDES ***

#include <windows.h>                   //* WINDOWS
#include <ole.h>                       //* OLE structs and defines
#include <shellapi.h>                  //* Shell, drag and drop headers

#include "demorc.h"                    //* header for resource file
#include "global.h"                    //* global app variables
#include "clidemo.h"                   //* app includes:
#include "register.h"
#include "stream.h"
#include "object.h"
#include "dialog.h"
#include "utility.h"

//*** VARIABLES ***

//** Global
HANDLE            hInst;
BOOL              fRetry = FALSE;
HWND              hwndFrame;           //* main window
HANDLE            hAccTable;           //* accelerator table
CHAR              szFrameClass[] = "CliDemo";//* main window class name
CHAR              szItemClass[]  = "ItemClass";//* item window class name
CHAR              szAppName[CBMESSAGEMAX];//* Application name
INT               iObjects = 0;        //* object count
INT               iObjectNumber = 0;   //* object number for object name
CHAR              szFileName[CBPATHMAX];

extern INT giXppli ;
extern INT giYppli ;
                                       //* ClipBoard formats:
OLECLIPFORMAT     vcfLink;             //* "ObjectLink"
OLECLIPFORMAT     vcfNative;           //* "Native"
OLECLIPFORMAT     vcfOwnerLink;        //* "OwnerLink"


/***************************************************************************
 * WinMain() - Main Windows routine
 ***************************************************************************/
int APIENTRY WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInst,
   LPSTR  lpCmdLine,
   INT    nCmdLine
){
    hInst = hInstance;

    if (!InitApplication(hInst))   //* register window classes
      return FALSE;

    if (!InitInstance(hInst))          //* create window instance
        return FALSE;

    OfnInit(hInst);                    //* setup to use <commdlg.dll>

                                       //* register clipboard formats
                                       //* used for OLE
    vcfLink      = RegisterClipboardFormat("ObjectLink");
    vcfNative    = RegisterClipboardFormat("Native");
    vcfOwnerLink = RegisterClipboardFormat("OwnerLink");


    ShowWindow(hwndFrame, SW_SHOWNORMAL);
    UpdateWindow(hwndFrame);
    ProcessCmdLine(lpCmdLine);

    while (ProcessMessage(hwndFrame, hAccTable)) ;

    return FALSE;
}

/***************************************************************************
 * InitApplication()
 *
 * registers the window classes used by the application.
 *
 * Returns BOOL:      - TRUE if successful.
 ***************************************************************************/

static BOOL InitApplication(           //* ENTRY:
   HANDLE         hInst                //* instance handle
){                                     //* LOCAL:
   WNDCLASS       wc;                  //* temp wind-class structure

   wc.style          = 0;
   wc.lpfnWndProc    = FrameWndProc;
   wc.cbClsExtra     = 0;
   wc.cbWndExtra     = 0;
   wc.hInstance      = hInst;
   wc.hIcon          = LoadIcon(hInst, MAKEINTRESOURCE(ID_APPLICATION));
   wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground  = (HBRUSH)(COLOR_APPWORKSPACE + 1);
   wc.lpszMenuName   = MAKEINTRESOURCE(ID_APPLICATION);
   wc.lpszClassName  = szFrameClass;

   if (!RegisterClass(&wc))
      return FALSE;
                                       //* application item class
   wc.style          = CS_DBLCLKS | CS_VREDRAW | CS_HREDRAW;
   wc.lpfnWndProc    = ItemWndProc;
   wc.hIcon          = NULL;
   wc.cbWndExtra     = sizeof(APPITEMPTR);
   wc.lpszMenuName   = NULL;
   wc.lpszClassName  = szItemClass;

   if (!RegisterClass(&wc))
      return FALSE;

   return TRUE;

}

/***************************************************************************
 * InitInstance()
 *
 * create the main application window.
 *
 * Returns BOOL:      - TRUE if successful else FALSE.
 ***************************************************************************/

static BOOL InitInstance(              //* ENTRY:
   HANDLE         hInst                //* instance handel
){
	HDC hDC ;

   hAccTable = LoadAccelerators(hInst, MAKEINTRESOURCE(ID_APPLICATION));

   if (!(hwndFrame =
      CreateWindow(
         szFrameClass, "",
         WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
         CW_USEDEFAULT, CW_USEDEFAULT,
         CW_USEDEFAULT, CW_USEDEFAULT,
         NULL,
         NULL,
         hInst,
         NULL
      )))
      return FALSE;                    //* ERROR return

   LoadString(hInst, IDS_APPNAME, szAppName, CBMESSAGEMAX);
   DragAcceptFiles(hwndFrame, TRUE);   //* allow dragged and dropped files

   hDC    = GetDC (NULL);       // Get the hDC of the desktop window
   giXppli = GetDeviceCaps (hDC, LOGPIXELSX);
   giYppli = GetDeviceCaps (hDC, LOGPIXELSY);
   ReleaseDC (NULL, hDC);
	


   return TRUE;                        //* SUCCESS return

}

/***************************************************************************
 *  ProcessCmdLine()
 *
 *  process command line getting any command arguments.
 ***************************************************************************/

VOID ProcessCmdLine(LPSTR lpCmdLine)
{                                     //* LOCAL:
   OFSTRUCT       ofs;


   if (*lpCmdLine)
   {                                   //* look for file extension
      LPSTR lpstrExt = lpCmdLine;      //* pointer to file extension

      while (*lpstrExt && *lpstrExt != '.')
         lpstrExt = AnsiNext(lpstrExt);

      lstrcpy(szFileName, lpCmdLine);
      if (!(*lpstrExt))                //* append default extension
      {
         lstrcat(szFileName,".");
         lstrcat(szFileName,szDefExtension);
      }
                                       //* get the files fully
      OpenFile(szFileName, &ofs, OF_PARSE);//* qualified name
      lstrcpy(szFileName, ofs.szPathName);
   }
   else
      *szFileName = 0;
                                       //* pass filename to main winproc
   SendMessage(hwndFrame,WM_INIT,(WPARAM)0,(LPARAM)0);

}


/***************************************************************************
 *  FrameWndProc()
 *
 *  Message handler for the application frame window.
 *
 *  Returns long - Variable, depends on message.
 ***************************************************************************/

LONG  APIENTRY FrameWndProc(           //* ENTRY:
   HWND           hwnd,                //* standard wind-proc parameters
   UINT           msg,
   DWORD          wParam,
   LONG           lParam
){                                     //* LOCAL:
                                       //* ^ Document file name
   static LHCLIENTDOC   lhcDoc;        //* Document Handle
   static LPOLECLIENT   lpClient;      //* pointer to client
   static LPAPPSTREAM   lpStream;      //* pointer to stream vtbl
   APPITEMPTR           pItem;         //* application item pointer

   switch (msg)
   {
      case WM_INIT:                    //* user defined message
         if (!InitAsOleClient(hInst, hwnd, szFileName, &lhcDoc, &lpClient, &lpStream))
            DestroyWindow(hwnd);
         break;
                                       //* the following three messages are
                                       //* used to avoid problems with OLE
                                       //* see the comment in object.h
      case WM_DELETE:                  //* user defined message
         pItem = (APPITEMPTR) lParam;  //* delete object
         WaitForObject(pItem);
         ObjDelete(pItem,OLE_OBJ_DELETE);
         if (wParam)
            cOleWait--;
         break;

      case WM_ERROR:                   //* user defined message
         ErrorMessage(wParam);         //* display error message
         break;

      case WM_RETRY:                   //* user defined message
         RetryMessage((APPITEMPTR)lParam, RD_RETRY | RD_CANCEL);
         break;

      case WM_INITMENU:
         UpdateMenu((HMENU)wParam);
         break;

      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         pItem = GetTopItem();

         switch (wID)
         {
            case IDM_NEW:
               ANY_OBJECT_BUSY;
               NewFile(szFileName,&lhcDoc,lpStream);
               break;

            case IDM_OPEN:
               ANY_OBJECT_BUSY;
               MyOpenFile(szFileName,&lhcDoc,lpClient,lpStream);
               break;

            case IDM_SAVE:
               ANY_OBJECT_BUSY;
               SaveFile(szFileName,lhcDoc,lpStream);
               break;

            case IDM_SAVEAS:
               ANY_OBJECT_BUSY;
               SaveasFile(szFileName,lhcDoc,lpStream);
               break;

            case IDM_ABOUT:
               AboutBox();
               break;

            case IDM_INSERT:
               ANY_OBJECT_BUSY;
               ObjInsert(lhcDoc, lpClient);
               break;

            case IDM_INSERTFILE:
               ANY_OBJECT_BUSY;
               ObjCreateFromTemplate(lhcDoc,lpClient);
               break;

            case IDM_PASTE:
            case IDM_PASTELINK:
               ANY_OBJECT_BUSY;
               ObjPaste(wID == IDM_PASTE,lhcDoc,lpClient);
               break;

            case IDM_LINKS:
               ANY_OBJECT_BUSY;
               pItem = GetTopItem();
               LinkProperties();
               break;

            case IDM_EXIT:
               ANY_OBJECT_BUSY;
               SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
               break;

            case IDM_COPY:
            case IDM_CUT:
               ANY_OBJECT_BUSY;

               if (!ObjCopy(pItem))
               {
                  ErrorMessage((wParam == IDM_CUT) ?
                     E_CLIPBOARD_CUT_FAILED : E_CLIPBOARD_COPY_FAILED);
                  break;
               }

               if (wParam == IDM_COPY)
                  break;

            case IDM_CLEAR:            //* CUT falls through to clear
               ANY_OBJECT_BUSY;
               ClearItem(pItem);
               break;

            case IDM_CLEARALL:
               ANY_OBJECT_BUSY;
               ClearAll(lhcDoc,OLE_OBJ_DELETE);
               Dirty(DOC_DIRTY);
               break;

            default:
               if( (wParam >= IDM_VERBMIN) && (wParam <= IDM_VERBMAX) )
               {
                  ANY_OBJECT_BUSY;
                  ExecuteVerb(wParam - IDM_VERBMIN,pItem);
                  break;
               }
               return DefWindowProc(hwnd, msg, wParam, lParam);
         }
         break;
      }

      case WM_DROPFILES:
         ANY_OBJECT_BUSY;
         ObjCreateWrap((HANDLE)wParam, lhcDoc, lpClient);
         break;

      case WM_CLOSE:
         ANY_OBJECT_BUSY;
         if (!SaveAsNeeded(szFileName, lhcDoc, lpStream))
            break;
         DeregDoc(lhcDoc);
         DestroyWindow(hwnd);
         break;

      case WM_DESTROY:
         EndStream(lpStream);
         EndClient(lpClient);
         PostQuitMessage(0);
         break;

      case WM_QUERYENDSESSION:         //* don't let windows terminate
         return (QueryEndSession(szFileName,lhcDoc, lpStream));

      default:
         return DefWindowProc(hwnd, msg, wParam, lParam);
   }
   return 0L;

}

/***************************************************************************
 * InitAsOleClient()
 *
 * Initiates the creation of stream and client vtbls.  These vtbls are very
 * important for the proper operation of this application.  The stream vtbl
 * lets the OLE librarys know where the location of the stream I/O routines
 * reside.  The stream routines are used by OleLoadFromStream and the like.
 * The client vtbl is used to hold the pointer to the CallBack function.
 * IMPORTANT: both the client and the stream structures have pointers to
 * vtbls which have the pointers to the functions.  Therefore, it is
 * necessary to allocate space for the vtbl and the client structure
 * which has the pointer to the vtbl.
 **************************************************************************/

static BOOL InitAsOleClient(           //* ENTRY:
   HANDLE         hInstance,           //* applicaion instance handle
   HWND           hwnd,                //* main window handle
   PSTR           pFileName,           //* document file name
   LHCLIENTDOC    *lhcDoc,             //* pointer to document Handle
   LPOLECLIENT    *lpClient,           //* pointer to client pointer
   LPAPPSTREAM    *lpStream            //* pointer to APPSTREAM pointer
){
                                       //* initiate client vtbl creation
   if (!(*lpClient = InitClient(hInstance)))
   {
      SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
      return FALSE;                    //* ERROR return
   }
                                       //* initiate stream vtbl creation
   if (!(*lpStream = InitStream(hInstance)))
   {
      SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
      return FALSE;                    //* ERROR return
   }

   if (*pFileName && RegDoc(pFileName,lhcDoc)
       && LoadFile(pFileName,*lhcDoc,*lpClient,*lpStream))
   {
      SetTitle(pFileName);
      return TRUE;                     //* SUCCESS return
   }

   NewFile(pFileName, lhcDoc, *lpStream);
   return TRUE;                        //* SUCCESS return

}                                      //* SUCCESS return

/****************************************************************************
 *  InitClient()
 *
 *  Initialize the OLE client structure, create and fill the OLECLIENTVTBL
 *  structure.
 *
 *  Returns LPOLECLIENT - if successful a pointer to a client structure
 *                        , otherwise NULL.
 ***************************************************************************/

static LPOLECLIENT InitClient(         //* ENTRY:
   HANDLE hInstance                    //* application instance handle
){                                     //* LOCAL:
   LPOLECLIENT lpClient=NULL;          //* pointer to client struct
                                       //* Allocate vtbls
   if (!(lpClient = (LPOLECLIENT)GlobalLock(
         GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(OLECLIENT))
      )))
      goto Error;                      //* ERROR jump

   if (!(lpClient->lpvtbl = (LPOLECLIENTVTBL)GlobalLock(
            GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(OLECLIENTVTBL))
      )))
      goto Error;                      //* ERROR jump
                                       //* set the CALLBACK function
                                       //* pointer
   lpClient->lpvtbl->CallBack  = CallBack;

   return lpClient;                    //* SUCCESS return

Error:                                 //* ERROR Tag

   ErrorMessage(E_FAILED_TO_ALLOC);
   EndClient(lpClient);                //* free any allocated space

   return NULL;                        //* ERROR return

}

/****************************************************************************
 *  InitStream()
 *
 *  Create and fill the STREAMVTBL. Create a stream structure and initialize
 *  pointer to stream vtbl.
 *
 *  Returns LPAPPSTREAM - if successful a pointer to a stream structure
 *                        , otherwise NULL .
 ***************************************************************************/

static LPAPPSTREAM InitStream(         //* ENTRY:
   HANDLE hInstance                    //* handle to application instance
){                                     //* LOCAL:
   LPAPPSTREAM lpStream = NULL;        //* pointer to stream structure

   if (!(lpStream = (LPAPPSTREAM)GlobalLock(
         GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(APPSTREAM))
      )))
      goto Error;                      //* ERROR jump

   if (!(lpStream->olestream.lpstbl = (LPOLESTREAMVTBL)GlobalLock(
         GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(OLESTREAMVTBL))
      )))
      goto Error;                      //* ERROR jump

                                       //* set stream func. pointers
   lpStream->olestream.lpstbl->Get = (DWORD ( CALLBACK *)(LPOLESTREAM, VOID FAR *, DWORD)) ReadStream;
   lpStream->olestream.lpstbl->Put = (DWORD ( CALLBACK *)(LPOLESTREAM, OLE_CONST VOID FAR *, DWORD)) WriteStream;

   return lpStream;                    //* SUCCESS return

Error:                                 //* ERROR Tag

   ErrorMessage(E_FAILED_TO_ALLOC);
   EndStream(lpStream);

   return NULL;                        //* ERROR return

}

/***************************************************************************
 *  UpdateMenu()
 *
 *  Enabling or disable menuitems based upon program state.
 ***************************************************************************/

static VOID UpdateMenu(                //* ENTRY:
   HMENU       hMenu                   //* menu handle to updated
){                                     //* LOCAL:
   INT         mf;                     //* generic menu flag
   APPITEMPTR  paItem;                 //* app item pointer
   HMENU       hSub;
                                       //* there must be at least on object
                                       //* for the following to be enabled

   paItem = GetTopItem() ;

   mf = (paItem ? MF_ENABLED : MF_GRAYED);
   EnableMenuItem(hMenu, IDM_CUT, mf); //* i.e. Cut,Copy,Clear,Clearall...
   EnableMenuItem(hMenu, IDM_COPY, mf);
   EnableMenuItem(hMenu, IDM_CLEAR, mf);
   EnableMenuItem(hMenu, IDM_CLEARALL, mf);
                                       //* enable links option only if there
                                       //* is at least one linked object
   EnableMenuItem(hMenu, IDM_LINKS, MF_GRAYED);
   for (; paItem; paItem = GetNextItem(paItem))
   {
      if (paItem->otObject == OT_LINK)
      {
         EnableMenuItem(hMenu, IDM_LINKS, MF_ENABLED);
         break;
      }
   }

   if (hSub = GetSubMenu(hMenu,POS_EDITMENU))
      UpdateObjectMenuItem(hSub);

   if (OleQueryCreateFromClip(STDFILEEDITING, olerender_draw, 0) == OLE_OK)
      EnableMenuItem(hMenu, IDM_PASTE, MF_ENABLED);
   else if (OleQueryCreateFromClip(STATICP, olerender_draw, 0) == OLE_OK)
      EnableMenuItem(hMenu, IDM_PASTE, MF_ENABLED);
   else
      EnableMenuItem(hMenu, IDM_PASTE, MF_GRAYED);

   if (OleQueryLinkFromClip(STDFILEEDITING, olerender_draw, 0) == OLE_OK)
      EnableMenuItem(hMenu, IDM_PASTELINK, MF_ENABLED);
   else
      EnableMenuItem(hMenu, IDM_PASTELINK, MF_GRAYED);

}

/***************************************************************************
 *  NewFile()
 *
 *  Save the present document and open a new blank one.
 ***************************************************************************/

static VOID NewFile(                   //* ENTRY:
   PSTR           pFileName,           //* open file name
   LHCLIENTDOC    *lhcptrDoc,          //* pointer to client doc. handle
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
   static CHAR  szUntitled[CBMESSAGEMAX] = "";//* "(Untitled)" string
   LHCLIENTDOC lhcDocNew;              //* handle for new doc.

   if (!(*szUntitled))
      LoadString(hInst, IDS_UNTITLED, (LPSTR)szUntitled, CBMESSAGEMAX);

   if (SaveAsNeeded(pFileName, *lhcptrDoc, lpStream))
   {                                   //* try to register new document
      if (!RegDoc(szUntitled, &lhcDocNew))
         return;                       //* before deregistring the old one
      DeregDoc(*lhcptrDoc);
      *lhcptrDoc = lhcDocNew;
      Dirty(DOC_CLEAN);                //* new document is clean
      lstrcpy(pFileName,szUntitled);
      SetTitle(pFileName);
      iObjectNumber = 0;
   }

}

/***************************************************************************
 *  MyOpenFile()
 *
 *  Open a file and load it.  Notice that the new file is loaded before
 *  the old is removed.  This is done to assure a succesful file load
 *  before removing an existing document.
 ***************************************************************************/

static VOID MyOpenFile(                //* ENTRY:
   PSTR           pFileName,           //* open file name
   LHCLIENTDOC    *lhcptrDoc,          //* pointer to document handle
   LPOLECLIENT    lpClient,            //* pointer to client structure
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
   CHAR           szNewFile[CBPATHMAX];//* new file name buffer
   LHCLIENTDOC    lhcDocNew;           //* handle of new document
   APPITEMPTR     pItem;               //* hold top item

   if (SaveAsNeeded(pFileName, *lhcptrDoc, lpStream))
   {
      *szNewFile = 0;

      if (!OfnGetName(hwndFrame, szNewFile, IDM_OPEN))
         return;                       //* ERROR return

      if (!RegDoc(szNewFile,&lhcDocNew))
         return;                       //* ERROR return

      pItem = GetTopItem();
      ShowDoc(*lhcptrDoc,0);           //* make old doc objects hidden.
                                       //* try to load the new file before
      if (!LoadFile(szNewFile, lhcDocNew, lpClient, lpStream))
      {                                //* before removing the old.
         DeregDoc(lhcDocNew);          //* restore old document if new
         SetTopItem(pItem);            //* file did not load
         ShowDoc(*lhcptrDoc,1);
         return;                       //* ERROR return
      }

      DeregDoc(*lhcptrDoc);            //* deregister old document
      *lhcptrDoc = lhcDocNew;
      lstrcpy(pFileName,szNewFile);
      SetTitle(pFileName);             //* set new title
      Dirty(DOC_CLEAN);
   }

}                                      //* SUCCESS return

/***************************************************************************
 *  SaveasFile()
 *
 * Prompt the user for a new file name.  Write the document to the new
 * filename.
 ***************************************************************************/

static VOID SaveasFile(                //* ENTRY:
   PSTR           pFileName,           //* old filename
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){
   CHAR           szNewFile[CBPATHMAX];//* new file name

   *szNewFile = 0;                  //* prompt user for new file name
   if (!OfnGetName(hwndFrame, szNewFile, IDM_SAVEAS))
      return;                          //* ERROR return
                                       //* rename document
   if (!SaveFile(szNewFile, lhcDoc, lpStream))
      return;

   if (Error(OleRenameClientDoc(lhcDoc, szNewFile)))
   {
      ErrorMessage(W_FAILED_TO_NOTIFY);
      return;                          //* ERROR return
   }

   lstrcpy(pFileName,szNewFile);
   SetTitle(pFileName);

}                                      //* SUCCESS return

/***************************************************************************
 *  SaveFile()
 *
 * Save a compound document file.  If the file is untitled, ask the user
 * for a name and save the document to that file.
 ***************************************************************************/

static BOOL SaveFile(                  //* ENTRY:
   PSTR           pFileName,           //* file to save document to
   LHCLIENTDOC    lhcDoc,              //* OLE document handle
   LPAPPSTREAM    lpStream             //* pointer to app. stream struct
){                                     //* LOCAL:
   CHAR           szNewFile[CBPATHMAX];//* New file name strings
   CHAR           szOemFileName[2*CBPATHMAX];
   static CHAR    szUntitled[CBMESSAGEMAX] = "";
   int            fh;                  //* file handle

   *szNewFile = 0;
   if (!(*szUntitled))
      LoadString(hInst, IDS_UNTITLED, (LPSTR)szUntitled, CBMESSAGEMAX);

   if (!lstrcmp(szUntitled, pFileName))//* get filename for the untitled case
   {
      if (!OfnGetName(hwndFrame, szNewFile, IDM_SAVEAS))
         return FALSE;                 //* CANCEL return
      lstrcpy(pFileName,szNewFile);
      SetTitle(pFileName);
   }

   AnsiToOem(pFileName, szOemFileName);
   if ((fh = _lcreat((LPSTR)szOemFileName, 0)) <= 0)
   {
      ErrorMessage(E_INVALID_FILENAME);
      return FALSE;                    //* ERROR return
   }

   lpStream->fh = fh;
                                       //* save file on disk
   if (!WriteToFile(lpStream))
   {
      _lclose(fh);
      ErrorMessage(E_FAILED_TO_SAVE_FILE);
      return FALSE;                    //* ERROR return
   }
   _lclose(fh);

   if (Error(OleSavedClientDoc(lhcDoc)))
   {
      ErrorMessage(W_FAILED_TO_NOTIFY);
      return FALSE;                    //* ERROR return
   }

   Dirty(DOC_CLEAN);
   return TRUE;                        //* SUCCESS return

}

/***************************************************************************
 *  LoadFile()
 *
 *  Load a document file from disk.
 ***************************************************************************/

static BOOL LoadFile(                  //* ENTRY:
   PSTR           pFileName,           //* file name
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient,            //* pointer to client structure
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
                                       //* OEM file name
   CHAR           szOemFileName[2*CBPATHMAX];
   int            fh;                  //* file handle
   INT            iObjectNumberHold;   //* hold object number

   AnsiToOem(pFileName, szOemFileName);
   if ((fh = _lopen(szOemFileName, OF_READ | OF_SHARE_DENY_WRITE)) == -1)
   {
      ErrorMessage(E_FAILED_TO_READ_FILE);
      return FALSE;                    //* ERROR return
   }

   lpStream->fh = fh;

   iObjectNumberHold = iObjectNumber;  //* save object number so it can
   iObjectNumber     = 0;              //* be restored if read from file
                                       //* fails
   if (!ReadFromFile(lpStream, lhcDoc, lpClient))
   {
      _lclose(fh);
      ErrorMessage(E_FAILED_TO_READ_FILE);
      iObjectNumber = iObjectNumberHold;
      return FALSE;                    //* ERROR return
   }
   _lclose(fh);
   return TRUE;                        //* SUCCESS return

}

/***************************************************************************
 *  RegDoc()
 *
 * Register the client document with the OLE library.
 **************************************************************************/

static BOOL RegDoc(                    //* ENTRY:
   PSTR           pFileName,           //* file name
   LHCLIENTDOC    *lhcptrDoc           //* pointer to client document handle
){

   if (Error(OleRegisterClientDoc(szAppName, (LPSTR)pFileName, 0L, lhcptrDoc)))
   {
      ErrorMessage(W_FAILED_TO_NOTIFY);
      return FALSE;                    //* ERROR return
   }
   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 *  DeregDoc()
 *
 *  This function initiates the removal of all OLE objects from the
 *  current document and deregisters the document with the OLE library.
 ***************************************************************************/

static VOID DeregDoc(                  //* ENTRY:
   LHCLIENTDOC    lhcDoc               //* client document handle
){

    if (lhcDoc)
    {                                  //* release all OLE objects
        ClearAll(lhcDoc,OLE_OBJ_RELEASE);      //* and remove them from the screen
        WaitForAllObjects();
        if (Error(OleRevokeClientDoc(lhcDoc)))
            ErrorMessage(W_FAILED_TO_NOTIFY);
    }

}                                      //* SUCCESS return

/***************************************************************************
 *  ClearAll()
 *
 * This function will destroy all of the item windows in the current
 * document and delete all OLE objects.  The loop is basically an enum
 * of all child windows.
 **************************************************************************/

static VOID ClearAll(                  //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* application document handle
   BOOL           fDelete              //* Delete / Release
){                                     //* LOCAL:
   APPITEMPTR     pItemNext;           //* working handles
   APPITEMPTR     pItem;               //* pointer to application item

   pItem = GetTopItem();

   while (pItem)
   {
      pItemNext = GetNextItem(pItem);
      if (pItem->lhcDoc == lhcDoc)
         ObjDelete(pItem, fDelete);
      pItem = pItemNext;
   }

}
                                    //* SUCCESS return
/***************************************************************************
 * ClearItem()
 *
 * This function will destroy an item window, and make the
 * next window active.
 **************************************************************************/

VOID  FAR ClearItem(                 //* ENTRY:
   APPITEMPTR     pItem                //* application item pointer
){

   pItem->fVisible = FALSE;
   SetTopItem(GetNextActiveItem());
   ObjDelete(pItem, OLE_OBJ_DELETE);
   Dirty(DOC_DIRTY);

}

/****************************************************************************
 *  SaveAsNeeded()
 *
 *  This function will have the file saved if and only
 *  if the document has been modified. If the fDirty flag has
 *  been set to TRUE, then the document needs to be saved.
 *
 *  Returns: BOOL -  TRUE if document doesn't need saving or if the
 *                   document has been saved successfully.
 ***************************************************************************/

static BOOL SaveAsNeeded(              //* ENTRY:
   PSTR           pFileName,           //* file to save
   LHCLIENTDOC    lhcDoc,              //* OLE doc handle
   LPAPPSTREAM    lpStream             //* pointer to OLE stream vtbl ...
){                                     //* LOCAL:
   CHAR           sz[CBMESSAGEMAX];    //* work strings
   CHAR           sz2[CBMESSAGEMAX + CBPATHMAX];

   if (Dirty(DOC_QUERY))               //* if doc is clean don't bother
   {

      LoadString(hInst, IDS_MAYBESAVE, sz, CBMESSAGEMAX);
      wsprintf(sz2, sz, (LPSTR)pFileName );

      switch (MessageBox(hwndFrame, sz2, szAppName, MB_YESNOCANCEL | MB_ICONQUESTION))
      {

         case IDCANCEL:
            return FALSE;              //* CANCEL return

         case IDYES:
            return (SaveFile(pFileName,lhcDoc,lpStream));

         default:
            break;
      }
   }
   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 *  SetTitle()
 *
 *  Set the window caption to the current file name. If szFileName is
 *  NULL, the caption will be set to "(Untitled)".
 ***************************************************************************/

static VOID SetTitle(                  //* ENTRY:
   PSTR           pFileName            //* file name
){                                     //* LOCAL
                                       //* window title string
   CHAR           szTitle[CBMESSAGEMAX + CBPATHMAX];

   wsprintf(szTitle, "%s - %s", (LPSTR)szAppName, (LPSTR)pFileName);
   SetWindowText(hwndFrame, szTitle);

}

/***************************************************************************
 *  EndClient()
 *
 *  Perform cleanup prior to app termination. The OLECLIENT
 *  memory blocks and procedure instance thunks freed.
 **************************************************************************/

static VOID EndStream(                 //* ENTRY:
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
   HANDLE         hGeneric;            //* temp handle

    if (lpStream)                      //* is there a STREAM struct?
    {
      if (lpStream->olestream.lpstbl)
      {
         FreeProcInstance((FARPROC)lpStream->olestream.lpstbl->Get);
         FreeProcInstance((FARPROC)lpStream->olestream.lpstbl->Put);
         hGeneric = GlobalHandle((LPSTR)lpStream->olestream.lpstbl);
         GlobalUnlock(hGeneric);
         GlobalFree(hGeneric);
      }
      hGeneric = GlobalHandle((LPSTR)lpStream);
      GlobalUnlock(hGeneric);
      GlobalFree(hGeneric);
    }

}                                      //* SUCCESS return

/***************************************************************************
 *  EndClient()
 *
 *  Perform cleanup prior to app termination. The OLECLIENT
 *  memory blocks and procedure instance thunks are freed.
 **************************************************************************/

static VOID EndClient(                 //* ENTRY:
   LPOLECLIENT    lpClient             //* pointer to client structure
){                                     //* LOCAL:
   HANDLE         hGeneric;            //* temp handle

   if (lpClient)                       //* is there a client structure
   {
      if (lpClient->lpvtbl)
      {
         FreeProcInstance(lpClient->lpvtbl->CallBack);
         hGeneric = GlobalHandle((LPSTR)lpClient->lpvtbl);
         GlobalUnlock(hGeneric);
         GlobalFree(hGeneric);
      }
      hGeneric = GlobalHandle((LPSTR)lpClient);
      GlobalUnlock(hGeneric);
      GlobalFree(hGeneric);
   }

}                                      //* SUCCESS return

/****************************************************************************
 * QueryEndSession()
 ***************************************************************************/

static LONG QueryEndSession(           //* ENTRY:
   PSTR           pFileName,           //* document name
   LHCLIENTDOC    lhcDoc,              //* client document handle
   LPAPPSTREAM    lpStream             //* application stream pointer
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer


   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (OleQueryOpen(pItem->lpObject) == OLE_OK)
      {
         MessageBox(hwndFrame,"Exit CliDemo1 before closing Windows",
               szAppName, MB_OK | MB_ICONSTOP);
         return 0L;
      }

   if (!SaveAsNeeded(pFileName, lhcDoc, lpStream))
      return 0L;
   DeregDoc(lhcDoc);
   return 1L;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\dialog.c ===
/*
 * dialog.c - Handles the Windows 3.1 common dialogs.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ****

#include <windows.h>                   //* WINDOWS
#include <ole.h>                       //* OLE

#include "global.h"                    //* global
#include "demorc.h"                    //* String table constants
#include "register.h"                  //* Class registration library
#include "utility.h"
#include "dialog.h"
#include "object.h"

//*** GLOBALS ***
                                       //* strings used with commdlg
CHAR        szDefExtension[CBMESSAGEMAX];
CHAR        szFilterSpec[CBFILTERMAX];
CHAR        szInsertFilter[CBFILTERMAX];
CHAR        szLastDir[CBPATHMAX];
OPENFILENAME OFN;
HWND        hwndProp = NULL;
HWND        hRetry;

/***************************************************************************
 * OfnInit()
 * Initializes the standard file dialog OFN structure.
 **************************************************************************/

VOID FAR OfnInit(                      //* ENTRY:
   HANDLE         hInst                //* instance handle
){                                     //* LOCAL:
   LPSTR          lpstr;               //* string pointer

   LoadString(hInst, IDS_FILTER, szFilterSpec, CBMESSAGEMAX);
   LoadString(hInst, IDS_EXTENSION, szDefExtension, CBMESSAGEMAX);

   OFN.lStructSize    = sizeof(OPENFILENAME);
   OFN.hInstance      = hInst;
   OFN.nMaxCustFilter = CBFILTERMAX;
   OFN.nMaxFile       = CBPATHMAX;
   OFN.lCustData      = 0;
   OFN.lpfnHook       = NULL;
   OFN.lpTemplateName = NULL;
   OFN.lpstrFileTitle = NULL;
                                       //* Construct the filter string
                                       //* for the Open and Save dialogs
   lpstr = (LPSTR)szFilterSpec;
   lstrcat(lpstr, " (*.");
   lstrcat(lpstr, szDefExtension);
   lstrcat(lpstr, ")");
   lpstr += lstrlen(lpstr) + 1;

   lstrcpy(lpstr, "*.");
   lstrcat(lpstr, szDefExtension);
   lpstr += lstrlen(lpstr) + 1;
   *lpstr = 0;

   RegMakeFilterSpec(NULL, NULL, (LPSTR)szInsertFilter);

}

/***************************************************************************
 * OfnGetName()
 *
 * Calls the standard file dialogs to get a file name
 **************************************************************************/

BOOL FAR OfnGetName(                   //* ENTRY:
   HWND           hwnd,                //* parent window handle
   LPSTR          szFileName,          //* File name
   WORD           msg                  //* operation
){                                     //* LOCAL:
   BOOL           frc;                 //* return flag
   CHAR           szCaption[CBMESSAGEMAX];//* dialog caption

   OFN.hwndOwner       = hwnd;               //* window
   OFN.nFilterIndex    = 1;
   OFN.lpstrInitialDir = (LPSTR)szLastDir;
   OFN.Flags           = OFN_HIDEREADONLY;

   switch (msg)                        //* message
   {
      case IDM_OPEN:                   //* open file
         Normalize(szFileName);
         OFN.lpstrDefExt = (LPSTR)szDefExtension;
         OFN.lpstrFile   = (LPSTR)szFileName;
         OFN.lpstrFilter = (LPSTR)szFilterSpec;
         LoadString(hInst, IDS_OPENFILE, szCaption, CBMESSAGEMAX);
         OFN.lpstrTitle  = (LPSTR)szCaption;
         OFN.Flags       |= OFN_FILEMUSTEXIST;
         return GetOpenFileName((LPOPENFILENAME)&OFN);
         break;

      case IDM_SAVEAS:                 //* save as file
         Normalize(szFileName);
         OFN.lpstrDefExt = (LPSTR)szDefExtension;
         OFN.lpstrFile   = (LPSTR)szFileName;
         OFN.lpstrFilter = (LPSTR)szFilterSpec;
         LoadString(hInst, IDS_SAVEFILE, szCaption, CBMESSAGEMAX);
         OFN.lpstrTitle  = (LPSTR)szCaption;
         OFN.Flags       |= OFN_PATHMUSTEXIST;
         return GetSaveFileName((LPOPENFILENAME)&OFN);
         break;

      case IDM_INSERTFILE:             //* insert file
         OFN.lpstrDefExt = NULL;
         OFN.lpstrFile   = (LPSTR)szFileName;
         OFN.lpstrFilter = (LPSTR)szInsertFilter;
         LoadString(hInst, IDS_INSERTFILE, szCaption, CBMESSAGEMAX);
         OFN.lpstrTitle  = (LPSTR)szCaption;
         OFN.Flags      |= OFN_FILEMUSTEXIST;
         frc             = GetOpenFileName((LPOPENFILENAME)&OFN);
         AddExtension(&OFN);
         return frc;
         break;

      default:                         //* default
         break;
   }

}

/***************************************************************************
 * OfnGetNewLinkName() - Sets up the "Change Link..." dialog box
 *
 * returns LPSTR - fully qualified filename
 **************************************************************************/

LPSTR FAR OfnGetNewLinkName(           //* ENTRY:
   HWND           hwnd,                //* calling window or dialog
   LPSTR          lpstrData            //* link data
){                                     //* LOCAL:
   LPSTR          lpReturn = NULL;     //* return string
   LPSTR          lpstrFile = NULL;    //* non-qualified file name
   LPSTR          lpstrPath = NULL;    //* pathname
   LPSTR          lpstrTemp = NULL;    //* work string
   CHAR           szDocFile[CBPATHMAX];//* document name
   CHAR           szDocPath[CBPATHMAX];//* document path name
   CHAR           szServerFilter[CBPATHMAX];
   CHAR           szCaption[CBMESSAGEMAX];

                                       //* Figure out the link's path
                                       //* name and file name
   lpstrTemp = lpstrData;
   while (*lpstrTemp++);
   lpstrPath = lpstrFile = lpstrTemp;

   while (*(lpstrTemp = AnsiNext(lpstrTemp)))
      if (*lpstrTemp == '\\')
         lpstrFile = lpstrTemp + 1;
                                        //* Copy the document name
   lstrcpy(szDocFile, lpstrFile);
   *(lpstrFile - 1) = 0;
                                          //* Copy the path name
   lstrcpy(szDocPath, ((lpstrPath != lpstrFile) ? lpstrPath : ""));
   if (lpstrPath != lpstrFile)           //* Restore the backslash
      *(lpstrFile - 1) = '\\';
   while (*lpstrFile != '.' && *lpstrFile)//* Get the extension
   lpstrFile++;
                                          //* Make a filter that respects
                                          //* the link's class name
   OFN.hwndOwner       = hwnd;
   OFN.nFilterIndex    = RegMakeFilterSpec(lpstrData, lpstrFile, szServerFilter);
   OFN.lpstrDefExt     = NULL;
   OFN.lpstrFile       = (LPSTR)szDocFile;
   OFN.lpstrFilter     = (LPSTR)szServerFilter;
   OFN.lpstrInitialDir = (LPSTR)szDocPath;
   LoadString(hInst, IDS_CHANGELINK, szCaption, CBMESSAGEMAX);
   OFN.lpstrTitle     = (LPSTR)szCaption;
   OFN.lpstrCustomFilter = NULL;
   OFN.Flags          = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;

                                           //* If we get a file... */
   if (GetOpenFileName((LPOPENFILENAME)&OFN))
   {
      if (!(lpReturn = GlobalLock(GlobalAlloc(LHND, CBPATHMAX))))
         goto Error;

      AddExtension(&OFN);
      lstrcpy(lpReturn, szDocFile);

      OFN.lpstrInitialDir = (LPSTR)szLastDir;
   }

   return lpReturn;                    //* SUCCESS return

Error:                                 //* ERROR Tag

   return NULL;                        //* ERROR return

}

/***************************************************************************
 * Normalize()
 * Removes the path specification from the file name.
 *
 * Note:  It isn't possible to get "<drive>:<filename>" as input because
 *        the path received will always be fully qualified.
 **************************************************************************/

VOID Normalize(                        //* ENTRY:
   LPSTR          lpstrFile            //* file name
){                                     //* LOCAL:
   LPSTR          lpstrBackslash = NULL;//* back slash
   LPSTR          lpstrTemp = lpstrFile;//* file name

   while (*lpstrTemp)
   {
      if (*lpstrTemp == '\\')
         lpstrBackslash = lpstrTemp;

      lpstrTemp = AnsiNext(lpstrTemp);
   }
   if (lpstrBackslash)
      lstrcpy(lpstrFile, lpstrBackslash + 1);

}

/***************************************************************************
 * AddExtension()
 *
 * Adds the extension corresponding to the filter dropdown.
 **************************************************************************/

VOID AddExtension(                     //* ENTRY:
   LPOPENFILENAME lpOFN                //* open file structure
){

   if (lpOFN->nFileExtension == (WORD)lstrlen(lpOFN->lpstrFile)
         && lpOFN->nFilterIndex)
   {
      LPSTR   lpstrFilter = (LPSTR)lpOFN->lpstrFilter;

      while (*lpstrFilter && --lpOFN->nFilterIndex)
      {
         while (*lpstrFilter++) ;
         while (*lpstrFilter++) ;
      }
                                       //* If we got to the filter,
      if (*lpstrFilter)                //* retrieve the extension
      {
         while (*lpstrFilter++) ;
         lpstrFilter++;
                                       //* Copy the extension
         if (lpstrFilter[1] != '*')
            lstrcat(lpOFN->lpstrFile, lpstrFilter);
      }
   }

}
/****************************************************************************
 *  fnInsertNew()
 *
 *  Dialog procedure for the Insert New dialog.
 *
 *  Returns int - TRUE if message processed, FALSE otherwise
 ***************************************************************************/

BOOL  APIENTRY fnInsertNew(            //* ENTRY:
   HWND           hDlg,                //* standard dialog box paramters
   UINT           msg,
   WPARAM         wParam,
   LPARAM         lParam               //* (LPSTR) class name
){                                     //* LOCAL:
   HWND           hwndList;            //* handle to listbox
   static LPSTR   lpClassName;         //* classname for return value

   hwndList = GetDlgItem(hDlg, IDD_LISTBOX);

   switch (msg)
   {
      case WM_INITDIALOG:
         if (!RegGetClassNames(hwndList))
            EndDialog(hDlg, IDCANCEL);

         lpClassName = (LPSTR)lParam;
         SetFocus(hwndList);
         SendMessage(hwndList, LB_SETCURSEL, 0, 0L);
         return (FALSE);

      case WM_COMMAND:
      {
         WORD wID  = LOWORD(wParam);
         WORD wCmd = HIWORD(wParam);

         switch (wID)
         {
            case IDD_LISTBOX:
               if (wCmd != LBN_DBLCLK)
               break;

            case IDOK:
               if (!RegCopyClassName(hwndList, lpClassName))
                  wParam = IDCANCEL;

            case IDCANCEL:
               EndDialog(hDlg, wParam);
               break;
         }
         break;
      }
   }
   return FALSE;

}

/***************************************************************************
 * LinkProperties();
 *
 * Manage the link properties dialog box.
 **************************************************************************/

VOID FAR LinkProperties()
{                                      //* LOCAL

   DialogBox (
      hInst,
      MAKEINTRESOURCE(DTPROP),
      hwndFrame,
      fnProperties
   );

}

/***************************************************************************
 * fnProperties()
 *
 * Dialog procedure for link properties. The Links dialog allows the user to
 * change the link options, edit/play the object, cancel the link as
 * well change links.
 *
 * returns BOOL - TRUE if processed, FALSE otherwise
 **************************************************************************/

BOOL  APIENTRY fnProperties(           //* ENTRY:
   HWND           hDlg,                //* standard dialog box parameters
   UINT           msg,
   WPARAM         wParam,
   LPARAM         lParam               //* (HWND) child window with focus
){                                     //* LOCAL:
  static APPITEMPTR *pLinks;           //* pointer to links (associated windows)
  static INT      nLinks;              //* number of links
  static HWND     hwndList;            //* handle to listbox window
  static BOOL     fTry;

   switch (msg)
   {
      case WM_INITDIALOG:
         hwndProp = hDlg;
         hwndList = GetDlgItem(hDlg, IDD_LINKNAME);
         if (!(InitLinkDlg(hDlg, &nLinks, hwndList, &pLinks)))
            EndDialog(hDlg, TRUE);
         UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
         break;

      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         switch (wID)
         {
           case IDD_CHANGE:            //* change links
               BLOCK_BUSY(fTry);
               if (ChangeLinks(hDlg,nLinks,hwndList,pLinks))
                  DisplayUpdate(nLinks,hwndList,pLinks, FALSE);
               return TRUE;

           case IDD_FREEZE:            //* cancel links
               BLOCK_BUSY(fTry);
               CancelLinks(hDlg,nLinks,hwndList,pLinks);
               UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               return TRUE;

           case IDD_UPDATE:            //* update links
               BLOCK_BUSY(fTry);
               DisplayUpdate(nLinks,hwndList,pLinks,TRUE);
               UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               return TRUE;

            case IDD_AUTO:
            case IDD_MANUAL:           //* change link update options
               BLOCK_BUSY(fTry);
               if (!SendMessage(GetDlgItem(hDlg,wParam),BM_GETCHECK, 0, 0L))
               {
                  CheckRadioButton(hDlg, IDD_AUTO ,IDD_MANUAL ,wParam);
                  ChangeUpdateOptions(hDlg,nLinks,hwndList,pLinks,
                     (wParam == IDD_AUTO ? oleupdate_always : oleupdate_oncall));
                  UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               }
               return TRUE;

           case IDD_LINKNAME:
               if (HIWORD(wParam) == LBN_SELCHANGE)
                  UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               return TRUE;

            case IDCANCEL:
               BLOCK_BUSY(fTry);
               UndoObjects();
               END_PROP_DLG(hDlg,pLinks);
               return TRUE;

            case IDOK:
               BLOCK_BUSY(fTry);
               DelUndoObjects(FALSE);
               END_PROP_DLG(hDlg,pLinks);
               return TRUE;
         }
      }
   }
   return FALSE;
}


/****************************************************************************
 * InitLinkDlg();
 *
 * Initialize the list box of links.
 ***************************************************************************/

static BOOL InitLinkDlg (              //* ENTRY:
   HWND           hDlg,                //* dialog box handle
   INT            *nLinks,             //* pointer to number of links
   HWND           hwndList,            //* listbox handle
   APPITEMPTR     **pLinks             //* list of window handles of links
){                                     //* LOCAL
   APPITEMPTR     pItem;               //* application item pointer
   LPSTR          lpstrData = NULL;    //* pointer to link data
   CHAR           szFull[CBMESSAGEMAX * 4];//* list box entry string
   CHAR           pLinkData[OBJECT_LINK_MAX];//* holder of link data
   BOOL           fSelect = FALSE;     //* item selected flag
   HANDLE         hWork;               //* working memory handle
   APPITEMPTR     pTop;                //* pointer to the top object

   if (!(*pLinks = (APPITEMPTR *)LocalLock(LocalAlloc(LHND,sizeof(APPITEMPTR)*10))))
   {
      ErrorMessage(E_FAILED_TO_ALLOC);
      return 0;
   }
   *nLinks = 0;
                                       //* set tabs
   SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);
                                       //* enumerate child windows
   for (pTop = pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->otObject == OT_LINK && pItem->fVisible)
      {
         *(*pLinks + *nLinks) = pItem;
         if (!((*nLinks += 1)%10))
         {                             //* add blocks of ten
            hWork = LocalHandle((LPSTR)(*pLinks));
            LocalUnlock(hWork);
            if (!(hWork = LocalReAlloc(hWork,(*nLinks+10)*sizeof(APPITEMPTR),0)))
            {
               ErrorMessage(E_FAILED_TO_ALLOC);
               return FALSE;           //* ERROR return
            }
            *pLinks = (APPITEMPTR *)LocalLock(hWork);
         }

         if (pTop == pItem)
            fSelect = TRUE;

         if (!ObjGetData(pItem, pLinkData))
            continue;
                                       //* make listbox entry
         MakeListBoxString(pLinkData, szFull, pItem->uoObject);
                                       //* add listbox entry
         SendMessage(hwndList, LB_ADDSTRING, 0, (LONG)(LPSTR)szFull);
      }
   }

   if (fSelect)
      SendMessage(hwndList, LB_SETSEL, 1, 0L);

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   UpdateWindow(hwndList);

   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 * MakeListBoxString()
 *
 * build an listbox entry string
 ***************************************************************************/

static VOID MakeListBoxString(         //* ENTRY:
   LPSTR          lpLinkData,          //* pointer to link data
   LPSTR          lpBoxData,           //* return string
   OLEOPT_UPDATE  oleopt_update        //* OLE update option
){                                     //* LOCAL:
   CHAR           szType[CBMESSAGEMAX];//* holds update option string
   LPSTR          lpTemp;              //* working string pointer
   INT            i;                   //* index

                                       //* get classname
   RegGetClassId(lpBoxData, lpLinkData);
   lstrcat(lpBoxData, " - ");           //* ads tab

   while (*lpLinkData++);              //* skip to document name

   lpTemp = lpLinkData;
   while (*lpTemp)                     //* copy document name;
   {                                   //* strip drive an directory
      if (*lpTemp == '\\' || *lpTemp == ':')
         lpLinkData = lpTemp + 1;
      lpTemp = AnsiNext(lpTemp);
   }
   lstrcat(lpBoxData, lpLinkData);
   lstrcat(lpBoxData, " - ");

   while (*lpLinkData++);              //* copy item data
   lstrcat(lpBoxData, lpLinkData);
   lstrcat(lpBoxData, " - ");
                                       //* add update option string
   switch (oleopt_update)
   {
      case oleupdate_always: i = SZAUTO; break;
      case oleupdate_oncall: i = SZMANUAL; break;
      default: i = SZFROZEN;
   }
   LoadString(hInst, i, szType, CBMESSAGEMAX);
   lstrcat(lpBoxData, szType);

}                                      //* SUCCESS return

/***************************************************************************
 * UpdateLinkButtons()
 *
 * Keep link buttons active as appropriate.  This routine is called after
 * a selection is made so the buttons reflect the selected items.
 **************************************************************************/

static VOID UpdateLinkButtons(         //* ENTRY:
   HWND           hDlg,                //* dialog box handle
   INT            nLinks,              //* number of links
   HWND           hwndList,            //* listbox handle
   APPITEMPTR     *pLinks              //* pointer to link's window handles
){                                     //* LOCAL:
   ATOM           aCurName=0;          //* atom of current doc
   BOOL           fChangeLink = TRUE;  //* enable/disable changelink button
   INT            iAuto,iManual,i;     //* count of manual and auto links
   APPITEMPTR     pItem;               //* application item pointer
   INT            iStatic;

   iStatic = iAuto = iManual = 0;

   for (i = 0; i < nLinks; i++)        //* enum selected links
   {
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         if (pItem->otObject == OT_STATIC)
            iStatic++;
         else
         {
            switch(pItem->uoObject)
            {                          //* count number of manual and
               case oleupdate_always:  //* automatic links selected
                  iAuto++;
                  break;
               case oleupdate_oncall:
                  iManual++;
                  break;
            }
                                       //* check if all selected links are
            if (!aCurName)             //* linked to same file
               aCurName = pItem->aLinkName;
            else if (aCurName != pItem->aLinkName)
               fChangeLink = FALSE;
         }
      }
   }

   if (!(iAuto || iManual || iStatic)  //* if no links disable all buttons
      || (!iAuto && !iManual && iStatic))
   {
      EnableWindow(GetDlgItem(hDlg, IDD_FREEZE), FALSE );
      EnableWindow(GetDlgItem(hDlg, IDD_CHANGE), FALSE );
      EnableWindow(GetDlgItem(hDlg, IDD_UPDATE), FALSE );
      CheckDlgButton(hDlg, IDD_AUTO, FALSE);
      EnableWindow(GetDlgItem(hDlg, IDD_AUTO),FALSE);
      CheckDlgButton(hDlg, IDD_MANUAL, FALSE);
      EnableWindow(GetDlgItem(hDlg, IDD_MANUAL),FALSE);
   }
   else
   {
      EnableWindow(GetDlgItem(hDlg, IDD_UPDATE), TRUE );
      EnableWindow(GetDlgItem(hDlg, IDD_FREEZE), TRUE );

      if (iAuto && iManual || !(iAuto || iManual))
      {                                //* Set update buttons
         CheckDlgButton(hDlg, IDD_AUTO, FALSE);
         EnableWindow(GetDlgItem(hDlg, IDD_AUTO),FALSE);
         CheckDlgButton(hDlg, IDD_MANUAL, FALSE);
         EnableWindow(GetDlgItem(hDlg, IDD_MANUAL),FALSE);
      }
      else
      {
         EnableWindow(GetDlgItem(hDlg, IDD_MANUAL), TRUE);
         EnableWindow(GetDlgItem(hDlg, IDD_AUTO), TRUE);
         if (iAuto)
         {
            CheckDlgButton(hDlg, IDD_AUTO, TRUE);
            CheckDlgButton(hDlg, IDD_MANUAL, FALSE);
         }
         else
         {
            CheckDlgButton(hDlg, IDD_AUTO, FALSE);
            CheckDlgButton(hDlg, IDD_MANUAL, TRUE);
         }
      }
   }

   EnableWindow(GetDlgItem(hDlg, IDD_CHANGE),fChangeLink && aCurName);

}

/****************************************************************************
 * ChangeLinks()
 *
 * This routine changes the linked data if the user chooses a new file to
 * replace the old document data portion of the linked date.  The routine
 * does nothing if the user cancels.
 *
 * returns TRUE - if data changed FALSE if user cancel or err.
 ***************************************************************************/

static BOOL ChangeLinks(               //* ENTRY:
   HWND           hDlg,                //* dialog handle
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks              //* list of application link handles
){                                     //* LOCAL
   INT            i;                   //* general index
   HANDLE         hWork;               //* work
   APPITEMPTR     pItem;               //* application item
   LPSTR          lpNewDoc = NULL;     //* new document
   ATOM           aOldDoc;             //* atom of old doc. name
   ATOM           aCurDoc = 0;      //* atom of change-to doc. name
   BOOL           fMessage = FALSE;    //* error message flag
   LPSTR          lpLinkData;          //* pointer to link data

   lpLinkData = NULL;
                                       //* This loop finds all selected links
   for (i = 0; i < nLinks; i++)        //* and updates them
   {
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);

         pItem->lpLinkData = lpLinkData;
         if (!ObjGetData(pItem,NULL))
            continue;

         if (!lpNewDoc)
         {
            if (!(lpNewDoc = OfnGetNewLinkName(hDlg, pItem->lpLinkData)))
              return FALSE;            //* ERROR jump
            aOldDoc = pItem->aLinkName;
            aCurDoc = AddAtom(lpNewDoc);
            SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);
         }

         ObjSaveUndo(pItem);
         ObjChangeLinkData(pItem,lpNewDoc);
         pItem->aLinkName = aCurDoc;
         lpLinkData = pItem->lpLinkData;

         CHANGE_LISTBOX_STRING(hwndList, i, pItem, pItem->lpLinkData);

         pItem->lpLinkData = NULL;
      }
   }

   /*************************************************************************
   * now deal with non-selected links and look for a match...
   *************************************************************************/

                                       //* this loop finds non-selected links
   for (i = 0; i < nLinks; i++)        //* and asks the user to update these?
   {
      if (!SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         if (pItem->otObject == OT_STATIC)
            continue;

         if (!ObjGetData(pItem,NULL))
            continue;

         if (pItem->aLinkName == aOldDoc)
         {
            if (!fMessage)
            {
               CHAR szMessage[2*CBMESSAGEMAX+3*CBPATHMAX];
               CHAR szRename[2*CBMESSAGEMAX];
               CHAR szOldDoc[CBMESSAGEMAX];
               LPSTR pOldDoc;

               GetAtomName(aOldDoc,szOldDoc,CBMESSAGEMAX);
               pOldDoc =(LPSTR)UnqualifyPath(szOldDoc);
               LoadString(hInst, IDS_RENAME, szRename, 2*CBMESSAGEMAX);
               wsprintf(
                     szMessage,
                     szRename,
                     pOldDoc,
                     (LPSTR)UnqualifyPath(szFileName),
                     pOldDoc
               );

               if (MessageBox(hDlg, szMessage,
                  szAppName, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
                  break;
               fMessage = TRUE;
            }

            ObjSaveUndo(pItem);
            ObjChangeLinkData(pItem,lpNewDoc);
            CHANGE_LISTBOX_STRING(hwndList, i, pItem, pItem->lpLinkData);

            pItem->aLinkName = aCurDoc;
         }
      }
   }

   if(lpNewDoc)
   {
      hWork = GlobalHandle(lpNewDoc);
      GlobalUnlock(hWork);
      GlobalFree(hWork);
   }

#if 0
// This is bogus -- this memory is owned by OLECLI32.DLL, not this app,
// so it should not be freed here.
   if (lpLinkData)
      FreeLinkData(lpLinkData);
#endif

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   InvalidateRect(hwndList,NULL,TRUE);
   UpdateWindow(hwndList);

   WaitForAllObjects();

   if (aCurDoc)
      DeleteAtom(aCurDoc);

   return(TRUE);
}

/****************************************************************************
 * DisplayUpdate()
 *
 * Get the most up to date rendering information and show it.
 ***************************************************************************/

static VOID DisplayUpdate(             //* ENTRY:
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks,             //* list of application link handles
   BOOL           fSaveUndo            //* save undo objects
){                                     //* LOCAL:
   INT            i;                   //* index
   APPITEMPTR     pItem;               //* temporary item pointer


   for (i = 0; i < nLinks; i++)
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);
         if (fSaveUndo)
            ObjSaveUndo(pItem);
         Error(OleUpdate(pItem->lpObject));
      }

   WaitForAllObjects();

}

/****************************************************************************
 * UndoObjects()
 *
 * Bring objects back to their original state.
 ***************************************************************************/

static VOID UndoObjects()
{
   APPITEMPTR     pItem;               //* application item pointer
                                       //* enum objects
   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (pItem->lpObjectUndo)
         ObjUndo(pItem);

   WaitForAllObjects();

}


/****************************************************************************
 * DelUndoObjects()
 *
 * remove all objects created for undo operation.
 ***************************************************************************/

static VOID DelUndoObjects(            //* ENTRY:
   BOOL           fPrompt              //* prompt user?
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   BOOL           fPrompted = FALSE;   //* prompted user?

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->lpObjectUndo)
      {
         if (fPrompt && !fPrompted)    //* prompt user in activation case
         {
            CHAR szPrompt[CBMESSAGEMAX];

            LoadString(hInst, IDS_SAVE_CHANGES, szPrompt, CBMESSAGEMAX);

            if (MessageBox(hwndFrame, szPrompt,
                  szAppName, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
            {
               UndoObjects();
               return;                 //* user canceled operation
            }
            fPrompted = TRUE;
         }
        ObjDelUndo(pItem);             //* delete udo object
      }
   }

   WaitForAllObjects();

}                                      //* SUCCESS return

/****************************************************************************
 * CancelLinks()
 ***************************************************************************/

static VOID CancelLinks(               //* ENTRY:
   HWND           hDlg,                //* calling dialog
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks              //* list of application link handles
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   INT            i;                   //* index
   CHAR           pLinkData[OBJECT_LINK_MAX];//* holder of link data

   SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);
   for (i = 0; i < nLinks; i++)
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);
         ObjGetData(pItem,pLinkData);
         ObjSaveUndo(pItem);
         ObjFreeze(pItem);

         CHANGE_LISTBOX_STRING(hwndList, i, pItem, pLinkData);
      }

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   InvalidateRect(hwndList,NULL,TRUE);
   UpdateWindow(hwndList);

}


/****************************************************************************
 * ChangeUpdateOptions()
 *
 * Change the update options for all selected objects.
 ***************************************************************************/

static VOID ChangeUpdateOptions(       //* ENTRY:
   HWND           hDlg,                //* calling dialog
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks,             //* list of application link handles
   OLEOPT_UPDATE  lUpdate              //* update option
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item
   INT            i;                   //* index
   CHAR           pLinkData[OBJECT_LINK_MAX];

   SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);

   for (i = 0; i < nLinks; i++)        //* enum selected objects
   {
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);
         ObjGetData(pItem,pLinkData);
         ObjSaveUndo(pItem);
         if (Error(OleSetLinkUpdateOptions(pItem->lpObject,lUpdate)))
            continue;
         pItem->uoObject = lUpdate;

         CHANGE_LISTBOX_STRING(hwndList, i, pItem, pLinkData);
      }
   }

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   InvalidateRect(hwndList,NULL,TRUE);
   UpdateWindow(hwndList);
   WaitForAllObjects();

}
/****************************************************************************
 * InvalidLink()
 *
 * Deal with letting the user know that the program has inadvertently come
 * across an invalid link.
 *
 * Global fPropBoxActive - flag to determine whether or not the link dialog
 *                         box is active.  If it is not active we give the
 *                         user an opportunity to enter the links property
 *                         dialog directly from here.
 ***************************************************************************/

VOID FAR InvalidLink()
{

   if (!hwndProp)
      DialogBox(hInst, "InvalidLink", hwndFrame, fnInvalidLink);
   else
      ErrorMessage(E_FAILED_TO_CONNECT);

}

/****************************************************************************
 *  fnABout()
 *
 *  About box dialog box procedure.
 ***************************************************************************/

BOOL  APIENTRY fnInvalidLink(        //* ENTRY:
   HWND           hDlg,              //* standard windows dialog box
   UINT           message,
   WPARAM         wParam,
   LPARAM         lParam
){

   switch (message)
   {
      case WM_INITDIALOG:
         return (TRUE);

      case WM_COMMAND:
         if (LOWORD(wParam) == IDD_CHANGE)
            LinkProperties();
         EndDialog(hDlg, TRUE);
         return (TRUE);
    }
    return (FALSE);

}

/****************************************************************************
 *  AboutBox()
 *
 *  Show the About Box dialog.
 ***************************************************************************/

VOID FAR AboutBox()
{

   DialogBox(hInst, "AboutBox", hwndFrame, fnAbout);

}

/****************************************************************************
 *  fnABout()
 *
 *  About box dialog box procedure.
 ***************************************************************************/

BOOL  APIENTRY fnAbout(               //* ENTRY:
   HWND         hDlg,                 //* standard windows dialog box
   UINT         message,
   WPARAM       wParam,
   LPARAM       lParam
){

   switch (message)
   {
      case WM_INITDIALOG:
         return (TRUE);

      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         if (wID == IDOK || wID == IDCANCEL)
         {
            EndDialog(hDlg, TRUE);
            return (TRUE);
         }
         break;
      }
    }
    return (FALSE);

}



/***************************************************************************
 * RetryMessage()
 *
 * give the user the chance to abort when a server is in retry case.
 *
 * Returns BOOL - TRUE if user chooses to cancel
 **************************************************************************/

VOID FAR RetryMessage (                //* ENTRY:
   APPITEMPTR     paItem,              //* application item pointer
   LONG lParam
){
   RETRYPTR    pRetry;
   LONG        objectType;
   HANDLE      hData;
   static CHAR szServerName[KEYNAMESIZE];
   HWND        hwnd;                   //* window handle

   if (IsWindow(hwndProp))
      hwnd = hwndProp;
   else if (IsWindow(hwndFrame))
      hwnd = hwndFrame;
   else
      return;                          //* should not happen
                                       //* get the busy servers name
   lstrcpy(szServerName, "server application");

   if (paItem)
   {
      if (!paItem->aServer)
      {
         OleQueryType(paItem->lpObject, &objectType );
         if (OLE_OK == OleGetData(paItem->lpObject, (OLECLIPFORMAT) (objectType == OT_LINK ? vcfLink : vcfOwnerLink), &hData ))
         {
            RegGetClassId(szServerName, GlobalLock(hData));
            paItem->aServer = AddAtom(szServerName);
            GlobalUnlock( hData );
         }
      }
      else
         GetAtomName(paItem->aServer,szServerName,KEYNAMESIZE);

   }

   hData = LocalAlloc(LHND,sizeof(RETRYSTRUCT));
   if(!(pRetry = (RETRYPTR)LocalLock(hData)))
     return;

   pRetry->lpserver = (LPSTR)szServerName;
   pRetry->bCancel  = (BOOL)(lParam & RD_CANCEL);
   pRetry->paItem   = paItem;

   DialogBoxParam(hInst, "RetryBox", hwnd, fnRetry, (LPARAM)pRetry );

   LocalUnlock(hData);
   LocalFree(hData);

   hRetry = NULL;

}

/****************************************************************************
 *  fnRetry()
 *
 * Retry message box nothing to tricky; however, when a server becomes
 * unbusy a message is posted to automatically get rid of this dialog.
 * I send a no.
 ***************************************************************************/

BOOL  APIENTRY fnRetry(               //* ENTRY
   HWND   hDlg,                       //* standard dialog entry
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
){
   static RETRYPTR   pRetry;

   switch (message)
   {
      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         switch (wParam)
         {
               case IDD_SWITCH:
                  DefWindowProc( hDlg, WM_SYSCOMMAND, SC_TASKLIST, 0);
                  break;

               case IDCANCEL:
                  if (pRetry->paItem)
                     pRetry->paItem->fRetry = FALSE;
                  EndDialog(hDlg, TRUE);
                  return TRUE;

               default:
                   break;
         }
         break;
      }

      case WM_INITDIALOG:
      {
          CHAR       szBuffer[CBMESSAGEMAX];
          CHAR       szText[2*CBMESSAGEMAX];

          pRetry = (RETRYPTR)lParam;
          hRetry = hDlg;

          LoadString(hInst, IDS_RETRY_TEXT1, szBuffer, CBMESSAGEMAX);
          wsprintf(szText, szBuffer, pRetry->lpserver);
          SetWindowText (GetDlgItem(hDlg, IDD_RETRY_TEXT1), szText);

          LoadString(hInst, IDS_RETRY_TEXT2, szBuffer, CBMESSAGEMAX);
          wsprintf(szText, szBuffer, pRetry->lpserver);
          SetWindowText (GetDlgItem(hDlg, IDD_RETRY_TEXT2), szText);

          EnableWindow (GetDlgItem(hDlg, IDCANCEL), pRetry->bCancel);

          return TRUE;
      }

      default:
           break;
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\clidemo.h ===
/*
 * clidemo.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** CONSTANTS ***

#define CXDEFAULT       400     //* Default object size:  400 x 300 
#define CYDEFAULT       300
#define COBJECTSMAX     50      //* max number of objects in our app 

//*** PROTOTYPES ***

//*** Exported window procedures 

LONG  APIENTRY  FrameWndProc(HWND, UINT, DWORD, LONG);

//*** FAR 

VOID FAR             FixObjectBounds(LPRECT lprc);

//*** Local

static LPOLECLIENT   InitClient(HANDLE);
static VOID          EndClient(LPOLECLIENT);
static LPAPPSTREAM   InitStream(HANDLE);
static VOID          EndStream(LPAPPSTREAM);
static VOID          ProcessCmdLine(LPSTR);
static BOOL          InitApplication(HANDLE); 
static BOOL          InitInstance(HANDLE);
static VOID          SetTitle(PSTR);
static VOID          MyOpenFile(PSTR,LHCLIENTDOC *, LPOLECLIENT, LPAPPSTREAM);
static VOID          NewFile(PSTR,LHCLIENTDOC *, LPAPPSTREAM); 
static BOOL          SaveFile(PSTR, LHCLIENTDOC, LPAPPSTREAM);
static VOID          SaveasFile(PSTR, LHCLIENTDOC, LPAPPSTREAM);
static BOOL          LoadFile(PSTR, LHCLIENTDOC, LPOLECLIENT, LPAPPSTREAM); 
static VOID          ClearAll(LHCLIENTDOC, BOOL);
static VOID          EndInstance(VOID);
static BOOL          SaveAsNeeded(PSTR,LHCLIENTDOC,LPAPPSTREAM);
static VOID          UpdateMenu(HMENU);
static BOOL          RegDoc(PSTR, LHCLIENTDOC *);
static VOID          DeregDoc(LHCLIENTDOC);
static BOOL          InitAsOleClient(HANDLE, HWND, PSTR, LHCLIENTDOC *, LPOLECLIENT *,  LPAPPSTREAM *);
VOID FAR             ClearItem(APPITEMPTR);
static LONG          QueryEndSession(PSTR, LHCLIENTDOC, LPAPPSTREAM);

//*** MACROS *** 

/*
 * ANY_OBJECT_BUSY
 * checks to see if any object in the document is busy. This prevents 
 * a new document from being saved to file if there are objects in 
 * asynchronous states.
 */

#define ANY_OBJECT_BUSY  {\
    if (ObjectsBusy()) \
         break; \
}
   

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\global.h ===
/* 
 * global.h
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** CONSTANTS ***

#define PROTOCOL_STRLEN    15          //* protocol name string size
#define CFILTERMAX         20	         //* Max # filters 
                                       //* Max # chars/filter
#define CBFILTERMAX        (100 * CFILTERMAX)
#define CBPATHMAX          250         //* max qualified file name
#define CBOBJNAMEMAX       14          //* maximum length of object name
#define CBVERBTEXTMAX      30          //* maximum length of verb text 
#define CBVERBNUMBMAX      8           //* maximum number of verbs 
#define OBJECT_LINK_MAX    256*3       //* maximum size of object link data
#define CDIGITSMAX         5
#define KEYNAMESIZE        300         //* Maximum registration key length
#define RETRY              3
                                       //* protocol name strings
#define STDFILEEDITING     ((LPSTR)"StdFileEditing")
#define STATICP            ((LPSTR)"Static")
                                       //* object name prefixes
#define OBJPREFIX          ((LPSTR)"CliDemo #")
#define OBJCLONE           ((LPSTR)"CliDemo1#")
#define OBJTEMP            ((LPSTR)"CliDemo2#")

#define DOC_CLEAN          0           //* Dirty() methods
#define DOC_DIRTY          1
#define DOC_UNDIRTY        2
#define DOC_QUERY          3

#define OLE_OBJ_RELEASE   FALSE       //* object deletion type
#define OLE_OBJ_DELETE    TRUE

#define WM_ERROR           WM_USER + 1 //* user defined messages 
#define WM_INIT            WM_USER + 2
#define WM_DELETE          WM_USER + 3
#define WM_RETRY           WM_USER + 4
#define WM_CHANGE          WM_USER + 5

#define RD_CANCEL          0x00000001
#define RD_RETRY           0x00000002

//*** TYPES ***

typedef struct _APPSTREAM FAR *LPAPPSTREAM;

typedef struct _APPSTREAM {
    OLESTREAM        olestream;
    INT              fh;
} APPSTREAM;

typedef struct _APPITEM *APPITEMPTR;

typedef struct _APPITEM {              //* Application item
   OLECLIENT         oleclient;
   HWND              hwnd; 
   LPOLEOBJECT       lpObject;         //* OLE object pointers
   LPOLEOBJECT       lpObjectUndo;     //* undo object
   LONG              otObject;         //* OLE object type
   LONG              otObjectUndo;
   OLEOPT_UPDATE     uoObject;         //* OLE object update option
   OLEOPT_UPDATE     uoObjectUndo;     //* link name atom
   ATOM              aLinkName;        //* Save the link's document name 
   ATOM              aLinkUndo;        //* Save the link's document name 
   LPSTR             lpLinkData;       //* pointer to link data
   BOOL              fVisible;         //* TRUE: item is to be displayed
   BOOL              fOpen;            //* server open? --for undo objects
   BOOL              fRetry;           //* retry flag for busy servers
   BOOL              fNew;
   BOOL              fServerChangedBounds;
   RECT              rect;             //* bounding rectangle
   LHCLIENTDOC       lhcDoc;           //* client document handle
   ATOM              aServer;
} APPITEM;                             


typedef struct _RETRY *RETRYPTR;

typedef struct _RETRY {                //* Application item
   LPSTR       lpserver;
   BOOL        bCancel;
   APPITEMPTR  paItem;
} RETRYSTRUCT;
                 
//*** GLOBALS ***

extern OLECLIPFORMAT vcfLink;          //* ObjectLink clipboard format 
extern OLECLIPFORMAT vcfNative;        //* Native clipboard format 
extern OLECLIPFORMAT vcfOwnerLink;     //* OwnerLink clipboard format 

extern HANDLE        hInst;            //* instance handle
extern HWND        hwndFrame;        //* main window handle
extern HANDLE        hAccTable;        //* accelerator table
extern HWND          hwndProp;         //* link properties dialog
extern HWND          hRetry;           //* retry dialog box handle
extern INT           cOleWait;         //* wait for asyncc commands
extern INT           iObjects;         //* object count
extern INT           iObjectNumber;    //* unique name id
extern CHAR          szItemClass[];    //* item class name    
extern CHAR          szDefExtension[]; //* default file extension       
extern CHAR          szAppName[];      //* application name
extern BOOL          fLoadFile;        //* load file flag
extern CHAR          szFileName[];     //* open file name
extern FARPROC       lpfnTimerProc;    //* pointer to timer callback function

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\object.c ===
/*
 * object.c - OLE object support routines
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ****

#include <windows.h>                   //* WINDOWS
#include <shellapi.h>                  //* SHELL
#include <ole.h>                       //* OLE

#include "global.h"                    //* global variables and structures
#include "stream.h"                    //* application includes:
#include "dialog.h"
#include "object.h"
#include "clidemo.h"
#include "demorc.h"
#include "utility.h"
#include "register.h"

#define HIMETRIC_PER_INCH       2540

//*** VARIABLES ***

//*** Globals
INT     cOleWait     = 0;

INT giXppli ;
INT giYppli ;



/***************************************************************************
 * CallBack()
 *
 * This routine will be called whenever an object has been changed,
 * saved, renamed, is being painted, or an  asynchronous operation has
 * completed. This routine is called by the OLE client DLL in the
 * above situations.  A pointer to this function is kept in the client
 * vtbl.  It is our obligation as a client application to insure that a
 * pointer to this procedure is in the vtbl.
 *
 * IMMPORTANT: notice that we are posting messages here rather that doing
 * the work right away.  Well, this is done to avoid any possibility of
 * getting into another dispatch message loop.  A MessageBox woul do this!
 *
 * Returns int - see below
 *
 * The return value is generally ignored, except for these notifications:
 * OLE_QUERY_PAINT and  OLE_QUERY_RETRY. For these two notifications,
 * returning TRUE means continue the current operation(eg painting or retry)
 * Returning FALSE means stop the current operation. This is useful as an
 * object which takes a long time to paint can be interrupted in order to
 * perform other operations.
 ***************************************************************************/

INT  APIENTRY CallBack(               //* ENTRY:
   LPOLECLIENT      lpClient,         //* client application pointer
   OLE_NOTIFICATION flags,            //* notification code being sent
   LPOLEOBJECT      lpObject          //* OLE object pointer
){                                    //* LOCAL:
   APPITEMPTR     pItem;              //* application item pointer


   pItem = (APPITEMPTR)lpClient;
   switch (flags)
   {
      case OLE_CLOSED:                 //* server has closed
         if (!pItem->fVisible)
         {
            PostMessage(hwndFrame, WM_DELETE, 0L, (DWORD)pItem);
            Dirty(DOC_UNDIRTY);
         }
         SetFocus( hwndFrame );
         break;

      case OLE_SAVED:                  //* server has saved object
      case OLE_CHANGED:                //* object has changes
         cOleWait++;
         pItem->fServerChangedBounds = pItem->fVisible = TRUE;
         PostMessage(pItem->hwnd, WM_CHANGE, 0, 0L);
         break;

      case OLE_RELEASE:                //* notification that an asynchronous
         ToggleBlockTimer(FALSE);      //* toggle timer off
         if (hRetry)
            PostMessage(hRetry,WM_COMMAND,IDCANCEL,0L);

         if (cOleWait)                 //* operation has completed
         {
            pItem->fRetry = TRUE;
            if (!--cOleWait)
               Hourglass(FALSE);
            Release(pItem);
         }
         break;

      case OLE_QUERY_RETRY:          //* Continue retrying.
         ToggleBlockTimer(FALSE);    //* toggle timer off
         if (!hRetry && pItem->fRetry)
            PostMessage(hwndFrame,WM_RETRY,0L, (DWORD)pItem);
         return (pItem->fRetry);

      case OLE_QUERY_PAINT:          //* continue repainting
         return TRUE;                //* a false return terminates either

        default:
            break;
    }
    return 0;                          //* return value is ignored in
                                       //* most cases, see header
}

/***************************************************************************
 * Release()
 *
 * Check for an error on the OLE_RELEASE notification.
 **************************************************************************/

static VOID Release(                   //* ENTRY:
   APPITEMPTR     pItem                //* Item pointer
){                                     //* LOCAL:
   DWORD wParam;              //* error code parameter

   if ((wParam = OleQueryReleaseError(pItem->lpObject)) == OLE_OK)
      return;

   switch (OleQueryReleaseMethod(pItem->lpObject))
   {
      case OLE_LNKPASTE:
         pItem->fVisible = FALSE;
         break;

      case OLE_CREATEFROMTEMPLATE:
      case OLE_CREATE:
         pItem->fVisible = FALSE;
         cOleWait++;
         PostMessage(hwndFrame, WM_DELETE,1L, (DWORD)pItem);
         Dirty(DOC_UNDIRTY);
   }
                                  //* post a message to the main window
                                  //* which will display a message box
   PostMessage(hwndFrame,WM_ERROR,wParam,0);

}

/***************************************************************************
 *  Error()
 *
 *  This function checks for error conditions
 *  generated by OLE API callsFor OLE_WAIT_FOR_RELEASE,
 *  we keep track of the number of objects waiting, when
 *  this count is zero, it is safe to exit the application.
 *
 *  Returns OLESTATUS -  0 if OLE_WAIT_FOR_RELEASE or OLE_OK
 *                       otherwise the OLESTATUS returned after an action
 *                       is taken.
 *************************************************************************/

OLESTATUS FAR Error(                   //* ENTRY
   OLESTATUS      olestat              //* OLE status
){

   switch (olestat)
   {
      case OLE_WAIT_FOR_RELEASE:
         if (!cOleWait)
            Hourglass(TRUE);
         cOleWait++;                   //* increment wait count

      case OLE_OK:
         return 0;

      case OLE_ERROR_STATIC:           //* static object
         ErrorMessage(W_STATIC_OBJECT);
         break;

      case OLE_ERROR_REQUEST_PICT:
      case OLE_ERROR_ADVISE_RENAME:
      case OLE_ERROR_DOVERB:
      case OLE_ERROR_SHOW:
      case OLE_ERROR_OPEN:
      case OLE_ERROR_NETWORK:
      case OLE_ERROR_ADVISE_PICT:
      case OLE_ERROR_COMM:             //* Invalid links
         InvalidLink();
         break;

      case OLE_BUSY:
         RetryMessage(NULL,RD_CANCEL);

      default:
         break;
    }
    return olestat;
}


/****************************************************************************
 * PreItemCreate()
 *
 * This routine allocates an application item structure. A pointer to this
 * structure is passed as the client structure, therefore we need to
 * have a pointer to the vtbl as the first entry. We are doing this
 * to allow acess to the application item information during a OLE
 * DLL callback.  This approach simplifies matters.
 *
 * Returns APPITEMPTR - a pointer to a new application item structure
 *                      which can operate as a client structure.
 ***************************************************************************/

APPITEMPTR FAR PreItemCreate(          //* ENTRY:
   LPOLECLIENT    lpClient,            //* OLE client pointer
   BOOL           fShow,               //* show/no-show flag
   LHCLIENTDOC    lhcDoc               //* client document handle
){                                     //* LOCAL:
   HANDLE         hitem;               //* temp handle for new item
   APPITEMPTR     pItem;               //* application item pointer


   if (hitem = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof(APPITEM)))
      if (pItem = (APPITEMPTR)LocalLock(hitem))
      {                                //* set the vtbl pointer
         pItem->oleclient.lpvtbl     = lpClient->lpvtbl;
         pItem->lpObjectUndo         = NULL;
         pItem->fVisible             = fShow;
         pItem->fServerChangedBounds = FALSE;
         pItem->lhcDoc               = lhcDoc;

         return pItem;                 //* SUCCESS return
      }

   ErrorMessage(E_FAILED_TO_ALLOC);
   return NULL;                        //* ERROR return

}


/***************************************************************************
 * ItemWndProc()
 *
 * This function handles item window message processing.
 * There is an item window for each OLE object. This was done to
 * to simplify hit testing and repainting. These windows are child
 * windows.

 * returns long - standard child routine
 **************************************************************************/

LONG  APIENTRY ItemWndProc(           //* ENTRY:
   HWND           hwnd,                //* standard windows parameters
   UINT           msg,
   DWORD          wParam,
   LONG           lParam
){                                     //* LOCAL:
   static POINT   dragPt;              //* Mouse drag point
   static RECT    dragRect;            //* Mouse drag rectangle
   static BOOL    fCaptured;           //* captured flag
   APPITEMPTR     pItem;               //* application item pointer
   PAINTSTRUCT    ps;                  //* paint structure
   POINT          pt;                  //* point
   RECT           rc;                  //* bounding rectangle
//   char lpstr[256];

   switch (msg)
   {
      case WM_SIZE:
         if (pItem = (APPITEMPTR)GetWindowLong(hwnd,0))
         {
            if (!pItem->fServerChangedBounds && pItem->otObject == OT_EMBEDDED)
               ObjSetBounds(pItem);
            else
               pItem->fServerChangedBounds = FALSE;
         }
         break;

      case WM_CHANGE:
         --cOleWait;
         pItem = (APPITEMPTR)GetWindowLong(hwnd,0);
         if (!Error(OleQueryBounds(pItem->lpObject, &rc)))
         {
            ConvertToClient(&rc);

            SetWindowPos(
               hwnd,
               NULL,
               0,
               0,
               rc.right - rc.left + 2*GetSystemMetrics(SM_CXFRAME),
               rc.bottom - rc.top + 2*GetSystemMetrics(SM_CYFRAME),
               SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME
            );

            if (!pItem->fNew && !fLoadFile)
               ShowNewWindow(pItem);
            else
               InvalidateRect(hwnd, NULL, TRUE);

            Dirty(DOC_DIRTY);
         }
         break;

      case WM_NCLBUTTONDOWN:
         SetTopItem((APPITEMPTR)GetWindowLong(hwnd,0));
         return (DefWindowProc(hwnd, msg, wParam, lParam));

      case WM_PAINT:
         BeginPaint(hwnd, (LPPAINTSTRUCT)&ps);
         GetClientRect(hwnd, &rc);
         pItem = (APPITEMPTR)GetWindowLong(hwnd, 0);
                                       //* Call OLE draw
         Error(OleDraw(pItem->lpObject, ps.hdc, &rc, NULL, NULL));

         EndPaint(hwnd, (LPPAINTSTRUCT)&ps);
         break;

      case WM_LBUTTONDBLCLK:           //* execute a verb
         ANY_OBJECT_BUSY;
         ExecuteVerb(OLEVERB_PRIMARY,(APPITEMPTR)GetWindowLong(hwnd,0));
         break;

      case WM_LBUTTONDOWN:
         GetWindowRect(hwnd, (LPRECT)&dragRect);
         ScreenToClient(hwndFrame, (LPPOINT)&dragRect);
         ScreenToClient(hwndFrame, (LPPOINT)&dragRect.right);

         dragPt.x = (LONG)(SHORT)LOWORD(lParam);
         dragPt.y = (LONG)(SHORT)HIWORD(lParam);

         ClientToScreen(hwnd, (LPPOINT)&dragPt);
         ScreenToClient(hwndFrame, (LPPOINT)&dragPt);

         SetCapture(hwnd);
         fCaptured = TRUE;
         SetTopItem((APPITEMPTR)GetWindowLong(hwnd,0));
         break;

      case WM_LBUTTONUP:
         if (!fCaptured)
                break;
         ReleaseCapture();
         fCaptured = FALSE;
         Dirty(DOC_DIRTY);
         break;

      case WM_MOUSEMOVE:
         if (!fCaptured)
            break;
         pt.x = (LONG)(SHORT)LOWORD(lParam);
         pt.y = (LONG)(SHORT)HIWORD(lParam);

         ClientToScreen(hwnd, (LPPOINT)&pt);
         ScreenToClient(hwndFrame, (LPPOINT)&pt);

         OffsetRect(
               (LPRECT)&dragRect,
               pt.x - dragPt.x,
               pt.y - dragPt.y
         );

         MoveWindow(
            hwnd,
            dragRect.left, dragRect.top,
            dragRect.right - dragRect.left,
            dragRect.bottom - dragRect.top, TRUE
         );

         dragPt.x = pt.x;
         dragPt.y = pt.y;
         break;

      default:
         return (DefWindowProc(hwnd, msg, wParam, lParam));
   }
   return 0L;

}

/****************************************************************************
 * PostItemCreate()
 *
 * This function creates a child window which will contain the newly
 * created OLE object. A pointer to our item information is stored in the
 * extra bytes of this window. This is where we internally keep track
 * of information related to the object as well as the
 * pointer to the object for subsequent OLE API calls.  This routine is
 * called after an OLE object has been created by the client library.
 *
 * Returns BOOL - TRUE if application item has been created.
 ****************************************************************************/

BOOL FAR PostItemCreate(               //* ENTRY:
   LPOLEOBJECT    lpObject,            //* OLE object pointer
   LONG           otObject,            //* OLE object type
   LPRECT         lprcObject,          //* object bounding rect
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   INT            i;                   //* index
   RECT           rc;                  //* bounding rectangle
   CHAR           pData[OBJECT_LINK_MAX];//* copy of link data

   if (lprcObject)                     //* if the size of the objects
      rc = *lprcObject;                //* bounding rectangle is not
   else if (OleQueryBounds(lpObject, &rc) == OLE_OK)
      ConvertToClient(&rc);
   else
      SetRect(&rc, 0, 0, 0, 0);

   if (!(pItem->hwnd = CreateWindow(   //* Create the child window
         szItemClass, "",
         WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_THICKFRAME,
         rc.left,rc.top,
         rc.right - rc.left + 2 * GetSystemMetrics(SM_CXFRAME),
         rc.bottom - rc.top + 2 * GetSystemMetrics(SM_CYFRAME),
         hwndFrame, NULL, hInst, NULL
   ))) goto Error;

                                       //* in windows extra bytes
   SetWindowLong(pItem->hwnd, 0, (LONG)pItem);

   pItem->otObject = otObject;
   pItem->lpObject = lpObject;
   pItem->fRetry  = TRUE;

   if( pItem->otObject == OT_EMBEDDED )//* if object is embedded tell library
   {                                   //* the container name and object name.
      UINT  cb=CBOBJNAMEMAX;           //* The name will be the server window title.
      CHAR  sz[CBOBJNAMEMAX];          //* when the object is edited.

      OleQueryName(lpObject, (LPSTR)sz, (UINT FAR *)&cb );


      WaitForObject(pItem);
      Error(OleSetHostNames(lpObject, (LPSTR)szAppName, (LPSTR)sz ));
      WaitForObject(pItem);
   }
   else if (pItem->otObject == OT_LINK)//* if the object is linked
   {                                   //* retrieve update options

      WaitForObject(pItem);
      if(Error(OleGetLinkUpdateOptions(pItem->lpObject, &pItem->uoObject)))
         goto Error;

      if (ObjGetData(pItem,pData))
      {
         for (i=0; pData[i];i++);      //* Skip past the server name
         pItem->aLinkName = AddAtom(&pData[++i]);
      }
      else
         pItem->aLinkName = AddAtom("");
   }
   iObjects++;
   Dirty(DOC_DIRTY);
                                       //* a user interface recommendations.
   return TRUE;                        //* SUCCESS return

Error:                                 //* ERROR Tag

   ErrorMessage(E_FAILED_TO_CREATE_CHILD_WINDOW);
   FreeAppItem(pItem);

   return FALSE;                       //* ERROR return

}

/***************************************************************************
 * ConvertToClient()
 *
 * This function will convert to client from himetric.
 **************************************************************************/

VOID FAR ConvertToClient(              //* ENTRY:
   LPRECT         lprc                 //* pointer to bounding rectangle
){                                     //* LOCAL

   //* If we have an empty rectangle then set the default size
   if (!(lprc->left || lprc->top || lprc->right || lprc->bottom))
      SetRect(lprc, 0, 0, CXDEFAULT, CYDEFAULT);
   else
   {
      //* We got the himetric units, converts them to pixels now.
      lprc->right   = MulDiv (giXppli, (lprc->right - lprc->left),
                          HIMETRIC_PER_INCH);

      lprc->bottom  = MulDiv (giYppli, (lprc->top - lprc->bottom),
                          HIMETRIC_PER_INCH);

      lprc->left    = 0;
      lprc->top     = 0;
    }
}

/***************************************************************************
 * ObjInsert()
 *
 * Query the user for object type to insert and insert the new OLE object
 ***************************************************************************/

VOID FAR ObjInsert(                    //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* OLE document handle
   LPOLECLIENT    lpClient             //* pointer to OLE client structure
){                                     //* LOCAL:
   LPOLEOBJECT    lpObject;            //* pointer to OLE object
   APPITEMPTR     pItem;               //* item pointer
   CHAR           szServerName[CBPATHMAX];//* Class name for OleCreate()
   CHAR           szClassName[CBPATHMAX];//* Class name for OleCreate()
   CHAR           szTmp[CBOBJNAMEMAX]; //* buffer to unique object name

   if (DialogBoxParam(hInst, MAKEINTRESOURCE(DTCREATE),hwndFrame,
            fnInsertNew, (LPARAM)((LPSTR)szClassName)) != IDCANCEL)
   {
      if (pItem = PreItemCreate(lpClient, FALSE, lhcDoc))
      {
         RegGetClassId(szServerName, szClassName);
         pItem->aServer = AddAtom(szServerName);
         if ( Error( OleCreate(STDFILEEDITING,(LPOLECLIENT)&(pItem->oleclient),
            (LPSTR)szClassName, lhcDoc,CreateNewUniqueName(szTmp),
            &lpObject,olerender_draw, 0)))
         {
            ErrorMessage(E_FAILED_TO_CREATE_OBJECT);
            FreeAppItem(pItem);
         }
         else
            PostItemCreate(lpObject, OT_EMBEDDED, NULL, pItem);
      }
   }


}

/***************************************************************************
 *  ObjDelete()
 *
 * Delete an OLE object. For this application, all OLE objects
 * are associated with a child window; therefore the window must be
 * destroyed.
 *
 * NOTE: There is one case when we call OleRelease and the other when
 * we call OleDelete.  We call OleRelease when we are deregistering
 * a document and OleDelete when removing an object from a document.
 **************************************************************************/

VOID FAR ObjDelete(                    //* ENTRY:
   APPITEMPTR     pItem,               //* pointer to application item
   BOOL           fDelete              //* delete or release flag
){                                     //* LOCAL:

   if (pItem->lpObjectUndo)
   {
      Error(OleDelete(pItem->lpObjectUndo));
                                       //* wait for asynchronous operation
      WaitForObject(pItem);
   }

   if (fDelete ? Error(OleDelete(pItem->lpObject))
                     : Error(OleRelease(pItem->lpObject)))
   {
      ErrorMessage(E_FAILED_TO_DELETE_OBJECT);
      return;                          //* ERROR return
   }

   if (pItem->fVisible)
   {
      ShowWindow(pItem->hwnd, SW_HIDE);
      pItem->fVisible = FALSE;
   }
                                       //* the operation has to complete
   WaitForObject(pItem);               //* before the application structure

   FreeAppItem(pItem);
   iObjects--;

}


/***************************************************************************
 *  ObjPaste()
 *
 *  This function obtains an object from the clipboard.
 *  Handles both embedded and linked objects. An item window is
 *  created for each new object.
 *
 *  Returns BOOL  - TRUE if object was pasted succesfully.
 **************************************************************************/

VOID FAR ObjPaste(                     //* ENTRY:
   BOOL           fPaste,              //* Paste/PasteLink flag
   LHCLIENTDOC    lhcDoc,              //* client document handle
   LPOLECLIENT    lpClient             //* pointer to client
){                                     //* LOCAL:
   LPOLEOBJECT    lpObject;            //* object pointer
   LONG           otObject;            //* object type
   APPITEMPTR     pItem;               //* application item pointer
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary object name string

   if (!(pItem = PreItemCreate(lpClient, TRUE, lhcDoc)))
      return;                          //* ERROR return

   if (!OpenClipboard(hwndFrame))
      goto Error;                      //* ERROR jump


   if (fPaste)                         //* PASTE the object.
   {                                   //* Try "StdFileEditing" protocol
      if (Error(OleCreateFromClip(STDFILEEDITING,(LPOLECLIENT)&(pItem->oleclient),lhcDoc,
         CreateNewUniqueName(szTmp),&lpObject, olerender_draw,0)))
      {
                                       //* next try "Static" protocol
         if (Error(OleCreateFromClip(
                  STATICP, (LPOLECLIENT)&(pItem->oleclient), lhcDoc,
                  CreateNewUniqueName(szTmp), &lpObject, olerender_draw, 0)))
            goto Error;               //* ERROR jump
      }
   }
   else
   {                                   //* LINK therefore must be
                                       // "STdFileEditing" protocol
        if (Error(OleCreateLinkFromClip(
            STDFILEEDITING,(LPOLECLIENT)&(pItem->oleclient), lhcDoc,
            CreateNewUniqueName(szTmp), &lpObject, olerender_draw, 0)))
            goto Error;                //* ERROR jump
   }

   OleQueryType(lpObject, &otObject);
   CloseClipboard();

   if (!PostItemCreate(lpObject, otObject, NULL, pItem))
      return;                          //* ERROR return

   ShowNewWindow(pItem);
   return;                             //* SUCCESS return


Error:                                 //* TAG Error

   ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
   CloseClipboard();
   FreeAppItem(pItem);

   return;                             //* ERROR return

}

/***************************************************************************
 * ObjCopy()
 *
 * This function places an OLE object on the clipboard via the \
 * OleCopyToClipboard() function.
 *
 * Returns BOOL - TRUE if object successfully placed on clipboard
 **************************************************************************/

BOOL FAR ObjCopy(                      //* ENTRY:
   APPITEMPTR     pItem                //* pointer to app item
){                                     //* LOCAL:
   BOOL           fReturn = TRUE;      //* return value

   if (!OpenClipboard(hwndFrame))
      return FALSE;                    //* ERROR return

   EmptyClipboard();

   if (Error(OleCopyToClipboard(pItem->lpObject)))
      fReturn = FALSE;                 //* prepare for ERROR out

   CloseClipboard();
   return fReturn;                     //* ERROR or SUCCESS

}

/***************************************************************************
 *  ObjCreateFromTemplate()
 *
 *  Creates an embedded object from file.
 **************************************************************************/

VOID FAR ObjCreateFromTemplate(        //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* client document handle
   LPOLECLIENT    lpClient             //* client vtbl. pointer
){                                     //* LOCAL:
   LPOLEOBJECT    lpObject;            //* OLE object pointer
   APPITEMPTR     pItem;               //* application item pointer
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary object name string
   CHAR           szFileName[CBPATHMAX];//* file name string

   *szFileName = 0;

   if (!OfnGetName(hwndFrame, szFileName, IDM_INSERTFILE))
      return;                          //* ERROR operation aborted by user

   if (!(pItem = PreItemCreate(lpClient, FALSE, lhcDoc)))
      return;                          //* ERROR

   if (Error(OleCreateFromTemplate(STDFILEEDITING, (LPOLECLIENT)pItem, szFileName,
         lhcDoc, CreateNewUniqueName(szTmp), &lpObject, olerender_draw, 0)))
   {
      ErrorMessage(E_CREATE_FROM_TEMPLATE);
      FreeAppItem(pItem);
      return;                          //* ERROR
   }

   PostItemCreate(lpObject, OT_EMBEDDED, NULL, pItem);

}                                      //* SUCCESS


/****************************************************************************
 * ObjGetData()
 *
 * Get the object link data.  The data that is retrieved from OLE is copied
 * into lpLinkData if lpLinkData is not NULL.  Otherwise, space is dynamically
 * allocated or reallocated; space is allocated if pItem->lpLinkData is NULL
 * otherwise the pointer is reallocated. The data is returned is freed if
 * there has been an OLE_WARN_DELETE_DATA error.
 ***************************************************************************/

BOOL FAR ObjGetData(                   //* ENTRY:
   APPITEMPTR     pItem,               //* OLE object
   LPSTR          lpLinkData           //* pointer to linkdata
){                                     //* LOCAL:
   HANDLE         hData;               //* handle to OLE link data
   LPSTR          lpData;              //* pointer to OLE link data
   LPSTR          lpWork;              //* copy of OLE link data
   BOOL           fFree = FALSE;       //* free OLE memory flag
   LONG           lSize;               //* size of OLE link data
   INT            i;

   switch (Error(OleGetData(pItem->lpObject,
      (OLECLIPFORMAT)(pItem->otObject == OT_LINK ? vcfLink : vcfOwnerLink), &hData)))
   {
      case OLE_WARN_DELETE_DATA:
         fFree = TRUE;
      case OLE_OK:
         if(lpData = GlobalLock(hData))
         {
                                       //* copy the link data to new buffer
            lSize=SizeOfLinkData(lpData);

            if (!lpLinkData)
            {
               if (!pItem->lpLinkData)  //* allocate
                  AllocLinkData(pItem,lSize);
               else                     //* otherwise reallocate
                  ReallocLinkData(pItem,lSize);
               lpWork = pItem->lpLinkData;
            }
            else
               lpWork = lpLinkData;

            if (lpWork)
               for (i=0L; i<(INT)lSize; i++)
                  *(lpWork+i)=*(lpData+i);

            GlobalUnlock(hData);       //* free the linked data as needed
            if (fFree)
               GlobalFree(hData);

            return TRUE;               //* SUCCESS
         }
      default:
         return FALSE;                 //* FAILURE
   }

}

/***************************************************************************
 * ObjChangeLink()
 *
 * Change the linkdata.  This routine will change the document portion of
 * link data to lpDoc.  The old linkdata is expected to be in
 * lpaItem->lpLinkData
 **************************************************************************/

VOID FAR ObjChangeLinkData(            //* ENTRY:
   APPITEMPTR     pItem,               //* OLE object
   LPSTR          lpDoc                //* document name
){                                     //* LOCAL:
   LONG           lSize;               //* used to link data size
   LPSTR          lpLinkData;          //* OLE link data pointer
   static CHAR    pWork[OBJECT_LINK_MAX]; //* used to construct new link data
   INT            i;                   //* index
   HANDLE         hData;

   pItem->aLinkName = AddAtom(lpDoc);

   for (
      lpLinkData = pItem->lpLinkData, i=0;
      pWork[i] = *lpLinkData;
      lpLinkData++, i++
   );
                                       //* into working buffer.
   lstrcpy((LPSTR)&pWork[++i],lpDoc);  //* copy new document name.

   for (; pWork[i]; i++);              //* skip to end of document name
   for (++lpLinkData;*lpLinkData;lpLinkData++);
                                       //* copy item name.
   lstrcpy((LPSTR)&pWork[++i],++lpLinkData);
   for (; pWork[i]; i++);              //* skip to end of buffer
                                       //* which is the end of item info.
   pWork[++i] = 0;                  //* add extra null.

   lSize = SizeOfLinkData(pWork);      //* reallocate space so there is
   ReallocLinkData(pItem,lSize);       //* a properly sized block of info
                                       //* to send the linked data to the
   if (lpLinkData = pItem->lpLinkData) //* OLE DLL.
      for (i=0; i<(INT)lSize; i++)     //* copy new linkdata into this space
         *lpLinkData++ = pWork[i];
   else
      return;                          //* ERROR return

   Error(OleSetData(pItem->lpObject, vcfLink, GlobalHandle(pItem->lpLinkData)));

   /*
    * The handle passed into OleSetData is owned by the OLE client library
    * and should not be used after the call.  On win32s, it is inaccessible
    * after the call, so restore it by calling OleGetData.  Note that the
    * data is *still* owned by the library, but we will now have access
    * to the memory.
    */
   Error(OleGetData(pItem->lpObject, vcfLink, &hData));
   if (hData) {
       pItem->lpLinkData = GlobalLock(hData);
   }
}                                      //* SUCCESS return

/****************************************************************************
 * ObjSaveUndo()
 *
 * Clone the OLE object so that any changes to object can be undone if the
 * user choses to exit without update.
 ***************************************************************************/

VOID FAR ObjSaveUndo(                  //* ENTRY:
   APPITEMPTR     pItem                //* application item
){                                     //* LOCAL:
   CHAR           szTmp[CBOBJNAMEMAX]; //* holder of object name
   LPSTR          lpClone;             //* pointer to clond object name
   UINT           i=CBOBJNAMEMAX;

   if (!pItem->lpObjectUndo)
   {
      OleQueryName(pItem->lpObject, szTmp, &i);
                                       //* give clone a unique name by
                                       //* altering object name prefix.
      for (lpClone = OBJCLONE, i=0; *lpClone; szTmp[i++] = *lpClone++);

      if (Error(OleClone(pItem->lpObject, (LPOLECLIENT)pItem,
         pItem->lhcDoc, szTmp, &(pItem->lpObjectUndo))))
      return;                          //* ERROR return

      pItem->otObjectUndo  = pItem->otObject;
      pItem->uoObjectUndo  = pItem->uoObject;
      pItem->aLinkUndo     = pItem->aLinkName;

      GetClientRect(pItem->hwnd, &pItem->rect);

      if (OleQueryOpen(pItem->lpObject) == OLE_OK)
         pItem->fOpen = TRUE;

   }

}                                      //* SUCCESS return

/****************************************************************************
 * ObjUndo()
 *
 * Restore an object to its state before changes.  The lpObject Undo is a
 * clone to the original object with a different name, therefore, all we
 * have to do is rename that object and ditch the changed object.
 ***************************************************************************/

VOID FAR ObjUndo(                      //* ENTRY:
   APPITEMPTR     pItem                //* application item
){                                     //* LOCAL:
   CHAR           szTmp[CBOBJNAMEMAX]; //* object name holder
   UINT           i = CBOBJNAMEMAX;

   OleQueryName(pItem->lpObject, szTmp, &i);
   if (Error(OleDelete(pItem->lpObject)))
      return;                          //* ERROR return
                                       //* reset app item vars
   pItem->lpObject      = pItem->lpObjectUndo;
   pItem->otObject      = pItem->otObjectUndo;
   pItem->uoObject      = pItem->uoObjectUndo;
   pItem->aLinkName     = pItem->aLinkUndo;
   pItem->lpObjectUndo  = (LPOLEOBJECT)NULL;
   pItem->otObjectUndo  = (LONG)NULL;

   if (Error(OleRename(pItem->lpObject,szTmp)))
      return;                          //* ERROR return

   if (pItem->fOpen)
   {
      Error(OleReconnect(pItem->lpObject));
      pItem->fOpen = FALSE;
   }

   SetWindowPos(
      pItem->hwnd,
      NULL, 0, 0,
      pItem->rect.right - pItem->rect.left + 2*GetSystemMetrics(SM_CXFRAME),
      pItem->rect.bottom - pItem->rect.top + 2*GetSystemMetrics(SM_CYFRAME),
      SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME
   );

   InvalidateRect(pItem->hwnd,NULL,TRUE);

}                                      //* SUCCESS return


/****************************************************************************
 * ObjDelUndo()
 *
 * Delete the undo object if the user is happy with the changes he/she made.
 ***************************************************************************/

VOID FAR ObjDelUndo(                   //* ENTRY:
   APPITEMPTR     pItem                //* application item
){

   if (Error(OleDelete(pItem->lpObjectUndo)))
      return;                          //* ERROR return

   pItem->lpObjectUndo = (LPOLEOBJECT)NULL;
   pItem->otObjectUndo = (LONG)NULL;
   DeleteAtom(pItem->aLinkUndo);
   pItem->lpObjectUndo = NULL;

}                                      //* SUCCESS return

/****************************************************************************
 * ObjFreeze()
 *
 * Convert an object to a static object.
 ***************************************************************************/

VOID FAR ObjFreeze(                    //* ENTRY:
   APPITEMPTR     pItem                //* application item
){                                     //* LOCAL:
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary object name
   LPSTR          lpTemp;              //* temporary prefix string
   LPOLEOBJECT    lpObjectTmp;         //* temporary object pointer
   UINT           i=CBOBJNAMEMAX;

   OleQueryName(pItem->lpObject, szTmp, &i);
                                       //* create a unique name by changing
                                       //* the object name prefix
   for (lpTemp = OBJTEMP, i=0; *lpTemp; szTmp[i++] = *lpTemp++);

                                       //* this API creates a static object
   if (Error(OleObjectConvert(pItem->lpObject, STATICP, (LPOLECLIENT)pItem,
      pItem->lhcDoc, szTmp, &lpObjectTmp)))
      return;
                                       //* delete old object
   if (Error(OleDelete(pItem->lpObject)))
      return;

   WaitForObject(pItem);

   pItem->lpObject = lpObjectTmp;
   pItem->otObject = OT_STATIC;
   pItem->uoObject = -1L;

   for (lpTemp = OBJPREFIX, i=0; *lpTemp; szTmp[i++] = *lpTemp++);
   if (Error(OleRename(pItem->lpObject,szTmp)))
      return;


}

/***************************************************************************
 *  ObjCreateWrap()
 *
 * Create a wrapped object from the drag and drop feature of the 3.1 shell.
 * NOTE: We are assuming that only one file has been dropped.  See the SDK
 * documentation for instructions on how to deal with multiple files.
 ***************************************************************************/

VOID FAR ObjCreateWrap(                //* ENTRY:
   HANDLE         hdrop,               //* handle to dropped object
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient             //* pointer to client structure
){                                     //* LOCAL:
   CHAR           szDragDrop[CBPATHMAX];//* Drag and drop file name
   LPOLEOBJECT    lpObject;            //* pointer to OLE object
   POINT          pt;                  //* position of dropped object
   RECT           rc;                  //* object size and position
   CHAR           szTmp[CBOBJNAMEMAX]; //* buffer for unique object name
   APPITEMPTR     pItem;               //* application item pointer
   INT            x,y;                 //* icon sizes

   x = GetSystemMetrics(SM_CXICON) / 2;
   y = GetSystemMetrics(SM_CYICON) / 2;
                                       //* Get the drag and drop filename
                                       //* position
   DragQueryPoint(hdrop, &pt);
   DragQueryFile(hdrop, 0, szDragDrop, CBPATHMAX);
   DragFinish(hdrop);

   SetRect(&rc, pt.x - x, pt.y - y, pt.x + x, pt.y + y);

   if (!(pItem = PreItemCreate(lpClient, TRUE, lhcDoc)))
      return;                          //* ERROR return
                                       //* create OLE object
   if (Error(OleCreateFromFile(STDFILEEDITING, (LPOLECLIENT)pItem,
         "Package", szDragDrop, lhcDoc, CreateNewUniqueName(szTmp),
         &lpObject, olerender_draw, 0)))
   {
      ErrorMessage(E_FAILED_TO_CREATE_OBJECT);
      FreeAppItem(pItem);
      return;                          //* ERROR return
   }

   if (PostItemCreate(lpObject, OT_EMBEDDED, &rc, pItem))
      ShowNewWindow(pItem);

}                                      //* SUCCESS return

/***************************************************************************
 *  UpdateObjectMenuItem()
 *
 *  Add an object popup menu for the chosen object if multiple verbs exist.
 *  The registration system is used to determine which verbs exist for the
 *   given object.
 **************************************************************************/

VOID FAR UpdateObjectMenuItem(         //* ENTRY:
   HMENU       hMenu                   //* main menu
){                                     //* LOCAL
   INT         cVerbs;                 //* verb
   APPITEMPTR  pItem;                  //* application item ponter
   DWORD       dwSize = KEYNAMESIZE;
   CHAR        szClass[KEYNAMESIZE], szBuffer[200];
   CHAR        szVerb[KEYNAMESIZE];
   HMENU       hPopupNew=NULL;
   HKEY        hkeyTemp;
   CHAR        pLinkData[OBJECT_LINK_MAX];
                                       //* delete current item and submenu
   DeleteMenu(hMenu, POS_OBJECT, MF_BYPOSITION );

   if (!(pItem = GetTopItem()) )
      goto Error;                      //* ERROR jump
   else if (!pItem->fVisible)
      goto Error;                      //* ERROR jump
                                       //* if STATIC ?
   if ((pItem->otObject != OT_EMBEDDED) && (pItem->otObject != OT_LINK))
      goto Error;                      //* ERROR jump

   if (!ObjGetData(pItem, pLinkData))  //* get linkdata as key reg database
      goto Error;                      //* ERROR jump
                                       //* open reg database
   szClass[0] = 0;
   if (RegOpenKey(HKEY_CLASSES_ROOT, szClass, &hkeyTemp))
      goto Error;                      //* ERROR jump
                                       //* check if class is reg-db
   if (RegQueryValue(HKEY_CLASSES_ROOT, pLinkData, szClass, &dwSize))
   {
      RegCloseKey(hkeyTemp);
      goto Error;                      //* ERROR jump
   }

   for (cVerbs=0; ;++cVerbs)           //* extract all verbs from reg-db
   {
      dwSize = KEYNAMESIZE;
      wsprintf(szBuffer, "%s\\protocol\\StdFileEditing\\verb\\%d",
                                     (LPSTR)pLinkData,cVerbs);

      if (RegQueryValue(HKEY_CLASSES_ROOT, szBuffer, szVerb, &dwSize))
         break;

      if (!hPopupNew)
         hPopupNew = CreatePopupMenu();

      InsertMenu(hPopupNew, (UINT)-1, MF_BYPOSITION, IDM_VERBMIN+cVerbs, szVerb);
   }

   //* NOTE: For International versions the following  verb menu
   //* may need to be formatted differently.

   switch (cVerbs)                     //* determine how many verbs found
   {
      case 0:                          //* none
         wsprintf(szBuffer, "Edit %s %s", (LPSTR)szClass, (LPSTR)"&Object");
         InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION, IDM_VERBMIN, szBuffer);
         break;

      case 1:                          //* one
         wsprintf(szBuffer, "%s %s %s", (LPSTR)szVerb, (LPSTR)szClass,
            (LPSTR)"&Object");
         DestroyMenu(hPopupNew);
         InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION, IDM_VERBMIN, szBuffer);
         break;

     default:                          //* > 1
         wsprintf(szBuffer, "%s %s", (LPSTR)szClass, (LPSTR)"&Object");
         InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION | MF_POPUP, (UINT)hPopupNew, szBuffer);
         EnableMenuItem(hMenu, POS_OBJECT, MF_ENABLED|MF_BYPOSITION);
         break;
   }

   RegCloseKey(hkeyTemp);              //* close reg-db
   return;                             //* SUCCESS return

Error:                                 //* ERROR tag
   InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION, 0, "&Object");
   EnableMenuItem(hMenu, POS_OBJECT, MF_GRAYED | MF_BYPOSITION);

}                                      //* ERROR return

/***************************************************************************
 *  ExecuteVerb()
 *
 *  Execute the verb for the given object.
 ***************************************************************************/

VOID FAR ExecuteVerb(                  //* ENTRY:
   UINT iVerb,                          //* verb
   APPITEMPTR pItem                    //* application item pointer
){                                     //* LOCAL
   RECT        rc;                     //* holds client area bounding rect

   if (pItem->otObject == OT_STATIC)   //* if the object is static beep
   {
      ErrorMessage(W_STATIC_OBJECT);
      return;                          //* return
   }
                                       //* get cliet area rectangle
   GetClientRect(hwndFrame, (LPRECT)&rc);
                                       //* execute OLE verb
   if (Error(OleActivate(pItem->lpObject, iVerb, TRUE, TRUE, hwndFrame, &rc)))
      return;

   WaitForObject(pItem);               //* wait for async. operation

   ObjSetBounds(pItem);


}                                      //* SUCCESS return

/****************************************************************************
 * ObjSetBounds
 *
 * Set the object bounds.  The object bounds are the child windos bounding
 * rectangle.  OLE servers recieve need the bounding rectangle in HIMETRIC
 * coordinates.  So, we convert from screen coordinates to HIMETRIC.
 *
 * Returns BOOL - TRUE if successful.
 ***************************************************************************/
BOOL FAR ObjSetBounds(                 //* ENTRY:
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   RECT           itemRect;            //* bounding rectangle

   GetWindowRect(pItem->hwnd,&itemRect);//* get item window react

   itemRect.right -= GetSystemMetrics(SM_CXFRAME);
   itemRect.left += GetSystemMetrics(SM_CXFRAME);
   itemRect.top += GetSystemMetrics(SM_CYFRAME);
   itemRect.bottom -= GetSystemMetrics(SM_CYFRAME);

   itemRect.right  = MulDiv ((itemRect.right - itemRect.left),
                        HIMETRIC_PER_INCH, giXppli);
   itemRect.bottom = - MulDiv((itemRect.bottom - itemRect.top),
                        HIMETRIC_PER_INCH, giYppli);
   itemRect.top    = 0;
   itemRect.left   = 0;
                                       //* set the rect for the server
   if (Error(OleSetBounds(pItem->lpObject,(LPRECT)&itemRect)))
      return FALSE;                    //* ERROR return

   WaitForObject(pItem);               //* wait for async. operation
   return TRUE;                        //* SUCCESS return

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\dialog.h ===
/*
 * dialog.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ***

#include <commdlg.h>

//*** PROTOTYPES ***

//*** FAR 
BOOL FAR          FullyQualify(LPSTR, LPSTR);
BOOL FAR          OfnGetName(HWND, LPSTR, WORD);
LPSTR FAR         OfnGetNewLinkName(HWND, LPSTR);
VOID FAR          OfnInit(HANDLE);
INT_PTR CALLBACK  fnInsertNew(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK  fnProperties(HWND, UINT, WPARAM, LPARAM);
VOID FAR          LinkProperties(VOID);
VOID FAR          AboutBox(VOID);
INT_PTR CALLBACK  fnAbout( HWND, UINT, WPARAM, LPARAM);
VOID FAR          RetryMessage (APPITEMPTR, LONG);
INT_PTR CALLBACK  fnRetry(HWND, UINT, WPARAM, LPARAM);
VOID FAR          InvalidLink(VOID);
INT_PTR CALLBACK  fnInvalidLink(HWND, UINT, WPARAM, LPARAM);

//*** Local
static VOID       AddExtension(LPOPENFILENAME);
static VOID       Normalize(LPSTR);
static BOOL       InitLinkDlg (HWND, INT *, HWND, APPITEMPTR **);
static VOID       UpdateLinkButtons(HWND, INT, HWND, APPITEMPTR *);
static BOOL       ChangeLinks(HWND, INT, HWND, APPITEMPTR *);
static VOID       CancelLinks(HWND, INT, HWND, APPITEMPTR *);
static VOID       DisplayUpdate(INT, HWND, APPITEMPTR *, BOOL);
static VOID       UndoObjects(VOID);
static VOID       DelUndoObjects(BOOL);
static VOID       ChangeUpdateOptions(HWND, INT, HWND, APPITEMPTR *, OLEOPT_UPDATE);
static VOID       MakeListBoxString(LPSTR, LPSTR, OLEOPT_UPDATE);

//*** MACROS ***

#define END_PROP_DLG(hDlg,pLinks) { \
   HANDLE handle; \
   handle = LocalHandle((LPSTR)pLinks); \
   LocalUnlock(handle); \
   LocalFree(handle); \
   Hourglass(FALSE); \
   hwndProp = (HWND)NULL; \
   EndDialog(hDlg, TRUE); \
}

#define CHANGE_LISTBOX_STRING(hwnd,i,pItem,lpLinkData) {\
   char pString[CBMESSAGEMAX*4];\
   MakeListBoxString(lpLinkData,pString,pItem->uoObject);\
   SendMessage(hwndList,LB_DELETESTRING, i , 0L);\
   SendMessage(hwndList,LB_INSERTSTRING, i , (long)((LPSTR)pString));\
   SendMessage(hwndList,LB_SETSEL, 1, (long)i);\
}

#define CHECK_IF_STATIC(pItem) {\
   if (pItem->otObject == OT_STATIC)\
      continue;\
}

#define BLOCK_BUSY(fTest) {\
   if (fTest)\
   {\
      fTest = FALSE;\
      return TRUE;\
   }\
   if (cOleWait)\
   {\
      fTest = TRUE;\
      RetryMessage(NULL,RD_CANCEL);\
      fTest = FALSE;\
      return TRUE;\
   }\
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\register.c ===
/*
 * register.c - Handles the Win 3.1 registration library.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ***

#include <windows.h>
#include <ole.h>

#include "global.h"
#include "register.h"
#include "clidemo.h"	 
#include "demorc.h"   

/****************************************************************************
 * RegGetClassId() - Retrieves the string name of a class.
 *
 * Retrieve the string name of a class. Classes are guarenteed to be 
 * in ASCII, but should not be used directly as a rule because they
 * might be meaningless if running non-English Windows.
 ***************************************************************************/

VOID FAR RegGetClassId(                //* ENTRY:
   LPSTR    lpstrName,                 //* destination string name of class
   LPSTR    lpstrClass                 //* source name of class
){                                     //* LOCAL:
   DWORD    dwSize = KEYNAMESIZE;      //* size of keyname string 
   CHAR     szName[KEYNAMESIZE];       //* string name for class 

   if (!RegQueryValue(HKEY_CLASSES_ROOT, lpstrClass, (LPSTR)szName, &dwSize))
	   lstrcpy(lpstrName, (LPSTR)szName);
   else
	   lstrcpy(lpstrName, lpstrClass);

}



/***************************************************************************
 *  RegMakeFilterSpec() - Retrieves class-associated default extensions.
 *
 * Get the class-associated default extensions, and build a filter spec, 
 * to be used in the "Change Link" standard dialog box, which contains 
 * all the default extensions which are associated with the given class 
 * name.  Again, the class names are guaranteed to be in ASCII.
 *
 * Returns int - The index idFilterIndex states which filter item 
 *               matches the extension, or 0 if none is found.
 ***************************************************************************/

INT FAR RegMakeFilterSpec(             //* ENTRY:
   LPSTR          lpstrClass,          //* class name
   LPSTR          lpstrExt,            //* file extension
   LPSTR          lpstrFilterSpec      //* destination filter spec
){                                     //* LOCAL:
   DWORD          dwSize;              //* size of reg request
   CHAR           szClass[KEYNAMESIZE];//* class name 
   CHAR           szName[KEYNAMESIZE]; //* name of subkey 
   CHAR           szString[KEYNAMESIZE];//* name of subkey 
   INT            i;                    //* index of subkey query 
   INT            idWhich = 0;          //* index of combo box item 
   INT            idFilterIndex = 0;    //* index to filter matching extension 

   for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szName, KEYNAMESIZE); ) 
   {
      if (  *szName == '.'             //* Default Extension...
            && (dwSize = KEYNAMESIZE)
            && !RegQueryValue(HKEY_CLASSES_ROOT, szName, szClass, &dwSize)
            && (!lpstrClass || !lstrcmpi(lpstrClass, szClass))
            && (dwSize = KEYNAMESIZE)
            && !RegQueryValue(HKEY_CLASSES_ROOT, szClass, szString, &dwSize)) 
      {
         idWhich++;	

         if (lpstrExt && !lstrcmpi(lpstrExt, szName))
            idFilterIndex = idWhich;
                                       //* Copy over "<Class Name String> 
                                       //* (*<Default Extension>)"
                                       //* e.g. "Server Picture (*.PIC)"
         lstrcpy(lpstrFilterSpec, szString);
         lstrcat(lpstrFilterSpec, " (*");
         lstrcat(lpstrFilterSpec, szName);
         lstrcat(lpstrFilterSpec, ")");
         lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;
                                       //* Copy over "*<Default Extension>" 
                                       //* (e.g. "*.PIC") */
         lstrcpy(lpstrFilterSpec, "*");
         lstrcat(lpstrFilterSpec, szName);
         lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;
      }
   }
   
   *lpstrFilterSpec = 0;

   return idFilterIndex;

}



/***************************************************************************
 *  RegCopyClassName()
 *
 *  Get the class name from the registration data base.  We have the
 *  descriptive name and we search for the class name.
 *
 *  returns BOOL - TRUE if class name was found and retrieved from the
 *                 registration database.
 ***************************************************************************/

BOOL FAR RegCopyClassName(             //* ENTRY:
   HWND           hwndList,            //* HANDLE to list box 
   LPSTR          lpstrClassName       //* destination character string
){                                     //* LOCAL:
   DWORD          dwSize;              //* key name size
   HKEY           hkeyTemp;            //* temp key
   CHAR           szClass[KEYNAMESIZE];//* class name string
   CHAR           szKey[KEYNAMESIZE];  //* key name string
   INT            i;                   //* index

   szClass[0] = '\0';

   if (!RegOpenKey(HKEY_CLASSES_ROOT, szClass, &hkeyTemp)) 
   {
      i = (INT)SendMessage(hwndList, LB_GETCURSEL, 0, 0L);
      SendMessage(hwndList, LB_GETTEXT, i, (DWORD)(LPSTR)szKey);

      for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szClass, KEYNAMESIZE); )
         if (*szClass != '.') 
         {
            dwSize = KEYNAMESIZE;
            if (!RegQueryValue(HKEY_CLASSES_ROOT, szClass, lpstrClassName, &dwSize))
               if (!lstrcmp(lpstrClassName, szKey))
               {
                    RegCloseKey(hkeyTemp);
                    lstrcpy(lpstrClassName,szClass);    
                    return TRUE;
                }
         }
      RegCloseKey(hkeyTemp);
   }

   *lpstrClassName = 0;
   return FALSE;

}



/***************************************************************************
 *  RegGetClassNames()
 *
 *  Fills in the list box in the Insert New dialog with the names of 
 *  OLE Servers.
 *
 *  returns TRUE if the listbox filled successfully.
 **************************************************************************/

BOOL FAR RegGetClassNames(       //* ENTRY:
   HWND hwndList                 //* HANDLE to the listbox being filled
){                               //* LOCAL:
   DWORD    dwSize;              //* sixe of data
   HKEY     hkeyTemp;            //* temporary registration key
   CHAR     szExec[KEYNAMESIZE]; //* executables name 
   CHAR     szClass[KEYNAMESIZE];//* class name
   CHAR     szName[KEYNAMESIZE]; //* key name
   INT      i;                   

   SendMessage(hwndList, LB_RESETCONTENT, 0, 0L);

   szClass[0]='\0';

   if (!RegOpenKey(HKEY_CLASSES_ROOT, szClass, &hkeyTemp)) 
   {
      for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szClass, KEYNAMESIZE); )
         if (*szClass != '.') 
         {         
            lstrcpy(szExec, szClass);
            lstrcat(szExec, "\\protocol\\StdFileEditing\\server");
            dwSize = KEYNAMESIZE;
            if (!RegQueryValue(HKEY_CLASSES_ROOT, szExec, szName, &dwSize)) 
            {
               dwSize = KEYNAMESIZE;
               if (!RegQueryValue(HKEY_CLASSES_ROOT, szClass, szName, &dwSize)) 
                  SendMessage(hwndList, LB_ADDSTRING, 0, (DWORD)(LPSTR)szName);
            }
         }
      RegCloseKey(hkeyTemp);
      return TRUE;
   }
   return FALSE;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\stream.h ===
/*
 * stream.h - OLE stream I/O headers.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** CONSTANTS ***

#define MAXREAD   ((LONG)  (60L * 1024L))

//*** GLOBALS ***

extern DWORD    vcbObject;

//*** PROTOTYPES ***

//* OLE callbacks

DWORD  APIENTRY ReadStream(LPAPPSTREAM, LPSTR, DWORD);
DWORD  APIENTRY WriteStream(LPAPPSTREAM, LPSTR, DWORD);

//* Far

BOOL FAR          WriteToFile(LPAPPSTREAM);
BOOL FAR          ObjWrite(LPAPPSTREAM, APPITEMPTR);
BOOL FAR          ReadFromFile(LPAPPSTREAM, LHCLIENTDOC, LPOLECLIENT);
BOOL FAR          ObjRead(LPAPPSTREAM, LHCLIENTDOC, LPOLECLIENT);

//* Local

DWORD             lread(int, VOID FAR *, DWORD);
DWORD             lwrite(int, VOID FAR *, DWORD);
static VOID       UpdateLinks(LHCLIENTDOC);
static VOID       UpdateFromOpenServers(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\object.h ===
/*
 * object.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** PROTOTYPES ***

//* OLE Callbacks

INT  APIENTRY CallBack(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);

//* Exported Windows procedures

LONG  APIENTRY ItemWndProc(HWND, UINT, DWORD, LONG);

//* Far
VOID FAR       ObjDelete(APPITEMPTR, BOOL);
VOID FAR       ConvertToClient(LPRECT);
OLESTATUS FAR  Error(OLESTATUS);
APPITEMPTR FAR PreItemCreate(LPOLECLIENT, BOOL, LHCLIENTDOC);
BOOL FAR       PostItemCreate(LPOLEOBJECT, LONG, LPRECT, APPITEMPTR);
VOID FAR       ObjPaste(BOOL, LHCLIENTDOC, LPOLECLIENT);
BOOL FAR       ObjCopy(APPITEMPTR);
BOOL FAR       ObjGetData (APPITEMPTR, LPSTR);
VOID FAR       ObjChangeLinkData(APPITEMPTR, LPSTR);
VOID FAR       ObjSaveUndo(APPITEMPTR);
VOID FAR       ObjDelUndo(APPITEMPTR); 
VOID FAR       ObjUndo(APPITEMPTR);
VOID FAR       ObjFreeze(APPITEMPTR);
VOID FAR       ObjInsert(LHCLIENTDOC, LPOLECLIENT);
VOID FAR       ObjCreateFromTemplate(LHCLIENTDOC, LPOLECLIENT);
VOID FAR       ObjCreateWrap(HANDLE, LHCLIENTDOC, LPOLECLIENT);
VOID FAR       UpdateObjectMenuItem(HMENU);
VOID FAR       ExecuteVerb(UINT, APPITEMPTR);

//* Local
static VOID    Release(APPITEMPTR);
BOOL FAR       ObjSetBounds(APPITEMPTR);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\utility.c ===
/* 
 * utility.c - general purpose utility routines
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 *
 */

//*** INCLUDES ****

#include <windows.h>
#include <ole.h>

#include "global.h"
#include "demorc.h"
#include "utility.h"
#include "object.h"
#include "dialog.h"

static INT        iTimerID = 0;
static APPITEMPTR lpaItemHold;


/****************************************************************************
 *  ErrorMessage()
 *
 *  Display a message box containing the specified string from the table.
 *
 *  id WORD       - Index into string table.
 ***************************************************************************/

VOID FAR ErrorMessage(                 //* ENTRY:
   DWORD          id                   //* message ID
){                                     //* LOCAL:
   CHAR           sz[CBMESSAGEMAX];    //* string 
   HWND           hwnd;                //* parent window handle

   if (IsWindow(hwndProp))
      hwnd = hwndProp;
   else if (IsWindow(hwndFrame))
      hwnd = hwndFrame; 
   else
      return;

   LoadString(hInst, id, sz, CBMESSAGEMAX);
   MessageBox(hwnd, sz, szAppName, MB_OK | MB_ICONEXCLAMATION);

}


/****************************************************************************
 *  Hourglass()
 *
 *  Put up or takes down the hourglass cursor as needed.
 *
 *  int  bToggle  - TRUE turns the hour glass on
 *                  HG_OFF turn it off  
 ***************************************************************************/

VOID FAR Hourglass(                    //* ENTRY:
   BOOL           bOn                  //* hourglass on/off
){                                     //* LOCAL:
   static HCURSOR hcurWait = NULL;     //* hourglass cursor
   static HCURSOR hcurSaved;           //* old cursor
   static         iCount = 0;


   if (bOn)
   {
      iCount++;
      if (!hcurWait) 
         hcurWait = LoadCursor(NULL, IDC_WAIT);
      if (!hcurSaved) 
         hcurSaved = SetCursor(hcurWait);
   }
   else if (!bOn)
   {  
      if (--iCount < 0 )
         iCount = 0;
      else if (!iCount)
      {
         SetCursor(hcurSaved);
         hcurSaved = NULL;
      }
   }

}

/***************************************************************************
 *  WaitForObject()
 *
 *  Dispatch messagee until the specified object is not busy. 
 *  This allows asynchronous processing to occur.
 *
 *  lpObject    LPOLEOBJECT - pointer to object
 **************************************************************************/

void FAR WaitForObject(                //* ENTRY:
   APPITEMPTR    paItem                //* pointer to OLE object
){                                     //* LOCAL
   BOOL bTimerOn = FALSE;

   while (OleQueryReleaseStatus(paItem->lpObject) == OLE_BUSY)
   {
      lpaItemHold = paItem;
      if (!bTimerOn)
         bTimerOn = ToggleBlockTimer(TRUE);//* set timer
      ProcessMessage(hwndFrame, hAccTable);
   }

   if (bTimerOn)
       ToggleBlockTimer(FALSE);//* toggle timer off
}

/***************************************************************************
 *  WaitForAllObjects()
 *
 *  Wait for all asynchronous operations to complete. 
 **************************************************************************/

VOID FAR WaitForAllObjects(VOID)
{
   BOOL bTimerOn = FALSE;

   while (cOleWait) 
   {
      if (!bTimerOn)
         bTimerOn = ToggleBlockTimer(TRUE);//* set timer

      ProcessMessage(hwndFrame, hAccTable) ;
   }

   if (bTimerOn)
       ToggleBlockTimer(FALSE);//* toggle timer off
     
}

/****************************************************************************
 * ProcessMessage()
 *
 * Obtain and dispatch a message. Used when in a message dispatch loop. 
 *
 *  Returns BOOL - TRUE if message other than WM_QUIT retrieved
 *                 FALSE if WM_QUIT retrieved.
 ***************************************************************************/

BOOL FAR ProcessMessage(               //* ENTRY:
   HWND           hwndFrame,           //* main window handle
   HANDLE         hAccTable            //* accelerator table handle
){                                     //* LOCAL:
   BOOL           fReturn;             //* return value
   MSG            msg;                 //* message

   if (fReturn = GetMessage(&msg, NULL, 0, 0)) 
   {
      if (cOleWait || !TranslateAccelerator(hwndFrame, hAccTable, &msg)) 
      {
            TranslateMessage(&msg);
            DispatchMessage(&msg); 
      }
   }
   return fReturn;

}


/****************************************************************************
 *  Dirty()
 *
 *  Keep track of weather modifications have been made 
 *  to the document or not.
 *
 *  iAction - action type:
 *            DOC_CLEAN set document clean flag true
 *            DOC_DIRTY the opposite
 *            DOC_UNDIRTY undo one dirty op
 *            DOC_QUERY return present state
 *
 *  Returs int - present value of fDirty; 0 is clean.
 ***************************************************************************/

INT FAR Dirty(                         //* ENTRY:
   INT            iAction              //* see above comment
){                                     //* LOCAL:
   static INT     iDirty = 0;          //* dirty state >0 is dirty

   switch (iAction)
   {
      case DOC_CLEAN:
         iDirty = 0;
         break;
      case DOC_DIRTY:
         iDirty++;
         break;
      case DOC_UNDIRTY:
         iDirty--;
         break;
      case DOC_QUERY:
         break;
   }
   return(iDirty);

}

/***************************************************************************
 *  ObjectsBusy()
 *
 *  This function enumerates the OLE objects in the current document 
 *  and displays a message box stating whether an object is busy. 
 *  This function calls  the DisplayBusyMessage() function which 
 *  performs most of the work. This function is only used by the macro
 *  BUSY_CHECK(), defined in object.h.
 *
 *  fSelectionOnly  BOOL -NOT USED?
 *
 *  BOOL - TRUE if one or more objects found to be busy
 *             FALSE otherwise
 *
 ***************************************************************************/

BOOL FAR ObjectsBusy ()
{
   APPITEMPTR pItem;

   if (iTimerID)
   {
      RetryMessage(NULL,RD_CANCEL);
      return TRUE;
   }

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (DisplayBusyMessage(pItem))
         return TRUE;

   return FALSE;

}

/***************************************************************************
 *  DisplayBusyMessage()
 *
 *  This function determines if an object is busy and displays 
 *  a message box stating this status. 
 *
 *  Returns BOOL - TRUE if object is busy
 **************************************************************************/

BOOL FAR DisplayBusyMessage (          //* ENTRY:
   APPITEMPTR     paItem               //* application item pointer
){                                     //* LOCAL:
    
   if (OleQueryReleaseStatus(paItem->lpObject) == OLE_BUSY) 
   {
      RetryMessage(paItem,RD_CANCEL);
      return TRUE;    
   }
   return FALSE;

}

/***************************************************************************
 * CreateNewUniqueName()
 *
 * Create a string name unique to this document. This is done by using the
 * prefix string("OleDemo #") and appending a counter to the end of the 
 * prefix string. The counter is incremented  whenever a new object is added. 
 * String will be 14 bytes long.
 *
 * Return LPSTR - pointer to unique object name.
 ***************************************************************************/

LPSTR FAR CreateNewUniqueName(         //* ENTRY:
   LPSTR          lpstr                //* destination pointer
){

    wsprintf( lpstr, "%s%04d", OBJPREFIX, iObjectNumber++ );
    return( lpstr );

}

/***************************************************************************
 *  ValidateName()
 *
 *  This function ensures that the given object name is valid and unique.
 *
 *  Returns: BOOL - TRUE if object name valid
 **************************************************************************/

BOOL FAR ValidateName(                 //* ENTRY:
   LPSTR          lpstr                //* pointer to object name
){                                     //* LOCAL:
   LPSTR          lp;                  //* worker string
   INT            n;
                                       //* check for "OleDemo #" prefix
   lp = OBJPREFIX;

   while( *lp ) 
   {
      if( *lpstr != *lp )
         return( FALSE );

      lpstr++; lp++;
   }
                                       //* convert string number to int
   for (n = 0 ; *lpstr ; n = n*10 + (*lpstr - '0'),lpstr++);

   if( n > 9999 )                      //* 9999 is largest legal number
      return FALSE;

   if( iObjectNumber <= n)             //* Make count > than any current
      iObjectNumber = n + 1;           //* object to ensure uniqueness

    return TRUE;
}

/***************************************************************************
 * FreeAppItem()
 *
 * Free application item structure and destroy the associated structure.
 **************************************************************************/

VOID FAR FreeAppItem(                  //* ENTRY:
   APPITEMPTR     pItem                //* pointer to application item
){                                     //* LOCAL:
   HANDLE         hWork;               //* handle used to free
   
   if (pItem)
   {                                   //* destroy the window
      if (pItem->hwnd)
         DestroyWindow(pItem->hwnd);

      hWork = LocalHandle((LPSTR)pItem);//* get handle from pointer

      if (pItem->aLinkName)
         DeleteAtom(pItem->aLinkName);

      if (pItem->aServer)
         DeleteAtom(pItem->aServer);

      LocalUnlock(hWork);
      LocalFree(hWork);
   }

}

/***************************************************************************
 * SizeOfLinkData()
 *
 * Find the size of a linkdata string.
 **************************************************************************/

LONG FAR SizeOfLinkData(               //* ENTRY:
   LPSTR          lpData               //* pointer to link data
){                                     //* LOCAL:
   LONG           lSize;               //* total size

   lSize = (LONG)lstrlen(lpData)+1;       //* get size of classname
   lSize += (LONG)lstrlen(lpData+lSize)+1; //* get size of doc.
   lSize += (LONG)lstrlen(lpData+lSize)+2;//* get size of item
   return lSize;

}

/****************************************************************************
 * ShowDoc()
 *
 * Display all the child windows associated with a document, or make all the
 * child windows hidden.
 ***************************************************************************/

VOID FAR ShowDoc(                      //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* document handle
   INT            iShow                //* show/hide
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   APPITEMPTR     pItemTop = NULL;

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->lhcDoc == lhcDoc)
      {
         if (!pItemTop)
            pItemTop = pItem;
         ShowWindow(pItem->hwnd,(iShow ? SW_SHOW : SW_HIDE)); 
         pItem->fVisible = (BOOL)iShow;
      }
   }
   
   if (pItemTop)
      SetTopItem(pItemTop);

}           
      
/****************************************************************************
 * GetNextActiveItem()
 *
 * Returns HWND - the next visible window. 
 ***************************************************************************/

APPITEMPTR FAR GetNextActiveItem()
{                                      //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (pItem->fVisible)
         break;

   return pItem;

}
 
/****************************************************************************
 * GetTopItem()
 ***************************************************************************/

APPITEMPTR FAR GetTopItem()
{
   HWND hwnd;

   if (hwnd = GetTopWindow(hwndFrame))
      return ((APPITEMPTR)GetWindowLong(hwnd,0));
   else
      return NULL;

}
/****************************************************************************
 * GetNextItem()
 ***************************************************************************/

APPITEMPTR FAR GetNextItem(            //* ENTRY:
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   HWND           hwnd;                //* next item window handle

   if (hwnd = GetNextWindow(pItem->hwnd, GW_HWNDNEXT))
      return((APPITEMPTR)GetWindowLong(hwnd,0));
   else
      return NULL;

}

/****************************************************************************
 * SetTopItem()
 ***************************************************************************/

VOID FAR SetTopItem(
   APPITEMPTR     pItem
){
   APPITEMPTR     pLastItem;

   pLastItem = GetTopItem();
   if (pLastItem && pLastItem != pItem)
      SendMessage(pLastItem->hwnd,WM_NCACTIVATE, 0, 0L);

   if (!pItem)
      return;

   if (pItem->fVisible)
   {
      BringWindowToTop(pItem->hwnd);
      SendMessage(pItem->hwnd,WM_NCACTIVATE, 1, 0L);
   }

}

/***************************************************************************
 * ReallocLinkData()
 *
 * Reallocate link data in order to avoid creating lots and lots of global
 * memory thunks.
 **************************************************************************/

BOOL FAR ReallocLinkData(              //* ENTRY:
   APPITEMPTR     pItem,               //* application item pointer
   LONG           lSize                //* new link data size
){                                     //* LOCAL:
   HANDLE         handle;              //* temporary memory handle

   handle = GlobalHandle(pItem->lpLinkData);
   GlobalUnlock(handle);

   if (!(pItem->lpLinkData = GlobalLock(GlobalReAlloc(handle, lSize, 0)))) 
   {
      ErrorMessage(E_FAILED_TO_ALLOC); 
      return FALSE;
   }

   return TRUE;

}

/***************************************************************************
 * AllocLinkData()
 *
 * Allocate link data space.
 **************************************************************************/

BOOL FAR AllocLinkData(                //* ENTRY:
   APPITEMPTR     pItem,               //* application item pointer
   LONG           lSize                //* link data size
){

   if (!(pItem->lpLinkData = GlobalLock(
         GlobalAlloc(GMEM_DDESHARE | GMEM_ZEROINIT ,lSize)
      )))
   {
      ErrorMessage(E_FAILED_TO_ALLOC);
      return FALSE;
   }

   return TRUE;
}

/***************************************************************************
 * FreeLinkData()
 *
 * Free the space associated with a linkdata pointer.
 **************************************************************************/

VOID FAR FreeLinkData(                 //* ENTRY:
   LPSTR          lpLinkData           //* pointer to linkdata
){                                     //* LOCAL:
   HANDLE         handle;              //* temporary memory handle

   if (lpLinkData)
   {
      handle = GlobalHandle(lpLinkData);
      GlobalUnlock(handle);
      GlobalFree(handle);
   }
}

/****************************************************************************
 * ShowNewWindow()
 *
 * Show a new application item window.
 ***************************************************************************/

VOID FAR ShowNewWindow(                //* ENTRY:
   APPITEMPTR     pItem
){

   if (pItem->fVisible)
   {
      pItem->fNew = TRUE;
      SetTopItem(pItem);
      ShowWindow(pItem->hwnd,SW_SHOW);
   }
   else
      ObjDelete(pItem,OLE_OBJ_DELETE);

}

/****************************************************************************
 * UnqualifyPath()
 *
 * return pointer to unqualified path name.
 ***************************************************************************/

PSTR FAR UnqualifyPath(PSTR pPath)
{
   PSTR pReturn;

   for (pReturn = pPath; *pPath; pPath++)  
      if (*pPath == ':' || *pPath == '\\')
         pReturn = pPath+1;

   return pReturn;

}

/****************************************************************************
 * ToggleBlockTimer()
 *
 * Toggle a timer used to check for blocked servers.
 ***************************************************************************/

BOOL FAR ToggleBlockTimer(BOOL bSet)
{     
   if (bSet && !iTimerID)
   {
      if (iTimerID = SetTimer(hwndFrame,1, 3000, (TIMERPROC) fnTimerBlockProc))
          return TRUE;
   }
   else if (iTimerID)
   {
      KillTimer(hwndFrame,1);
      iTimerID = 0;
      return TRUE;
   }
   
   return FALSE;
}

/****************************************************************************
 *  fnTimerBlockProc()
 *
 *  Timer callback procedure
 ***************************************************************************/

VOID CALLBACK fnTimerBlockProc(      //* ENTRY: 
   HWND     hWnd,
   UINT     wMsg,
   UINT     iTimerID,
   DWORD    dwTime
){

   if (!hRetry)
      RetryMessage(lpaItemHold, RD_RETRY | RD_CANCEL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\register.h ===
/*
 * <register.h>
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** PROTOTYPES ***

//* Far

BOOL FAR    RegCopyClassName(HWND hwndList, LPSTR lpstrClassName);
VOID FAR    RegGetClassId(LPSTR lpstrName, LPSTR lpstrClass);
BOOL FAR    RegGetClassNames(HWND hwndList);
VOID FAR    RegInit(HANDLE hInst);
INT  FAR    RegMakeFilterSpec(LPSTR lpstrClass, LPSTR lpstrExt, LPSTR lpstrFilterSpec);
VOID FAR    RegTerm(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\stream.c ===
/*
 * stream.c - io stream function callbacks
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

/***************************************************************************
 * This file contains all routines that directly and indirectly deal with
 * file i/o.  The OLE stream call back functions exist in this file.     
 **************************************************************************/

//*** INCLUDES ***

#include <windows.h>
#include <ole.h>

#include "global.h"
#include "utility.h"
#include "stream.h"
#include "object.h"
#include "demorc.h"

//*** Globals ***

BOOL fLoadFile = FALSE;

/***************************************************************************
 *  ReadStream() - OLE Callback Function (Get)       
 *
 *  This function is pointed to from the OLESTREAM vtbl; it is Get.
 *
 *  returns DWORD  - number of bytes actually read
 **************************************************************************/

DWORD  APIENTRY ReadStream(           //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   LPSTR          lpstr,               //* string pointer
   DWORD          cb                   //* byte count
){

   return _lread(lpStream->fh, lpstr, cb);

}

/***************************************************************************
 *  WriteStream() - OLE Callback function (Put)
 *
 *  This function is pointed to from the OLESTREAM vtbl; it is Put.
 *
 *  Returns DWORD  - number of bytes actually written
 **************************************************************************/

DWORD  APIENTRY WriteStream(           //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer 
   LPSTR          lpstr,               //* string pointer
   DWORD          cb                   //* number of bytes to write
){

   return _lwrite(lpStream->fh, lpstr, cb);

}

/****************************************************************************
 *  ReadFromFile()
 *
 *  This function reads OLE objects from a file. If the document 
 *  contains manual links, the user will be prompted to update those links.
 *
 *  Returns BOOL  - TRUE if the read(s) were successful
 ***************************************************************************/

BOOL FAR ReadFromFile(                 //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient             //* pointer to OLE client structure
){                                     //* LOCAL:
   BOOL           bReturn = FALSE;     //* return value
   INT            cFileObjects;        //* number of file objects

   Hourglass(TRUE);
   fLoadFile = TRUE;

   SetFilePointer((HANDLE)lpStream->fh, 0, NULL, 0);
                                       //* in the file
   if (_lread(lpStream->fh, (LPSTR)&cFileObjects, sizeof(INT)) < sizeof(INT))
      goto Error;

   for (; cFileObjects; --cFileObjects) 
   {
      if (!ObjRead(lpStream,lhcDoc,lpClient)) 
      {
         ErrorMessage(E_FAILED_TO_READ_OBJECT);
         goto Error;
      }
   }
   
   ShowDoc(lhcDoc,1);
   UpdateLinks(lhcDoc);

   bReturn = TRUE;                     //* SUCCESS

Error:                                 //* ERROR Tag
    
   Hourglass(FALSE);
   fLoadFile = FALSE;
   return bReturn;                     //* return

}

/****************************************************************************
 *  ObjRead()
 *
 *  Rread an object from the specified file. The file pointer will 
 *  be advanced past the object.
 *
 *  HANDLE fh     - DOS file handle of file to be read from
 *
 *  returns HWND  - window handle to item window containing the OLE object
 ***************************************************************************/

BOOL FAR ObjRead(                      //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient             //* pointer to OLE client structure
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   LPOLEOBJECT    lpObject;            //* pointer ole object 
   LONG           otObject;            //* type of object 
   RECT           rcObject;            //* object rect 
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary string buffer
   CHAR           szProto[PROTOCOL_STRLEN+1];//* protocol string
   INT            i;                   //* index

   if (_lread(lpStream->fh, szTmp, CBOBJNAMEMAX) < CBOBJNAMEMAX )
      return FALSE;

   if (_lread(lpStream->fh, szProto, PROTOCOL_STRLEN) < PROTOCOL_STRLEN )
      return FALSE;

   for (i=0; szProto[i] != ' '; i++);
   szProto[i] = 0;

   ValidateName( szTmp );

   if (!(pItem = PreItemCreate(lpClient, TRUE, lhcDoc))) 
      return FALSE;

   if (Error(OleLoadFromStream((LPOLESTREAM)&(lpStream->olestream), 
         szProto,(LPOLECLIENT)&(pItem->oleclient), lhcDoc, szTmp, &lpObject))) 
      goto Error;

   if (_lread(lpStream->fh, (LPSTR)&rcObject, sizeof(RECT)) < sizeof(RECT))
      goto Error;
   
   if (_lread(lpStream->fh, (LPSTR)&otObject, sizeof(LONG)) < sizeof(LONG))
      goto Error;

   if (PostItemCreate(lpObject, otObject, &rcObject, pItem))
   {
      pItem->fNew = TRUE;
      ObjSetBounds(pItem);
      return TRUE;                     //* SUCCESS return
   }
   else
      return FALSE;

Error:                                 //* ERROR Tag

   FreeAppItem(pItem);
   return FALSE;

}

/*************************************************************************
 *  WriteToFile()
 *
 *  Write current document to a file.
 *
 *  returns BOOL - TRUE if file successfully written
 ************************************************************************/

BOOL FAR WriteToFile(                  //* ENTRY:
   LPAPPSTREAM    lpStream             //* application stream pointer
){                                     //* LOCAL:
   INT            iObjectsWritten=0;   //* counter of objects written to file
   APPITEMPTR     pItem;               //* application Item pointer
   
   UpdateFromOpenServers();
      
   SetFilePointer((HANDLE)lpStream->fh, 0, NULL, 0);
   
   Hourglass(TRUE);

   if (_lwrite(lpStream->fh, (LPSTR)&iObjects, sizeof(INT)) < sizeof(INT))
      goto Error;

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (!ObjWrite(lpStream, pItem)) 
         goto Error;
      iObjectsWritten++;
   }

   if (iObjectsWritten != iObjects) 
      goto Error;


   Dirty(DOC_CLEAN);
   Hourglass(FALSE);
   return(TRUE);                       //* SUCCESS return

Error:                                 //* ERROR Tag
    
   Hourglass(FALSE);
   return(FALSE);                      //* ERROR return

}

/****************************************************************************
 *  ObjWrite()
 *
 *  This function writes an object to the specified
 *  file. The file pointer will be advanced past the end of
 *  the written object.

 *  Returns BOOL - TRUE if object written successfully
 ***************************************************************************/

BOOL FAR ObjWrite(                     //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   POINT           pt;                  //* center of rec point
   RECT            rc;                  //* bounding rectangle
   UINT            cbTmp = CBOBJNAMEMAX;
   CHAR            szTmp[PROTOCOL_STRLEN];//* protocol string

   OleQueryName(pItem->lpObject, szTmp, &cbTmp);

   if (_lwrite(lpStream->fh, szTmp, CBOBJNAMEMAX) < CBOBJNAMEMAX )
      return FALSE;

   if (pItem->otObject == OT_STATIC)
      wsprintf(szTmp, "%-15s", STATICP);
   else   
      wsprintf(szTmp, "%-15s", STDFILEEDITING);

   if (_lwrite(lpStream->fh, szTmp, PROTOCOL_STRLEN) < PROTOCOL_STRLEN )
      return FALSE;

   if (Error(OleSaveToStream(pItem->lpObject, (LPOLESTREAM)&(lpStream->olestream))))
      return FALSE;

   GetClientRect(pItem->hwnd, (LPRECT)&rc);
   pt = *(LPPOINT)&rc;
   ClientToScreen(pItem->hwnd, (LPPOINT)&pt);
   ScreenToClient(hwndFrame, (LPPOINT)&pt);
   OffsetRect(
      &rc, 
      pt.x - rc.left - GetSystemMetrics(SM_CXFRAME),
      pt.y - rc.top  - GetSystemMetrics(SM_CYFRAME) 
   );

   if (_lwrite(lpStream->fh, (LPSTR)&rc, sizeof(RECT)) < sizeof(RECT)
         || _lwrite(lpStream->fh, (LPSTR)&(pItem->otObject), sizeof(LONG)) < sizeof(LONG))
      return FALSE;

   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 * UpdateLinks()
 *
 * Get the most up to date rendering information and show it.  
 ***************************************************************************/

static VOID UpdateLinks(               //* ENTRY
   LHCLIENTDOC    lhcDoc               //* client document handle
){                                     //* LOCAL:
   INT            i=0;                 //* index
   APPITEMPTR     pItem;               //* temporary item pointer
   CHAR           szUpdate[CBMESSAGEMAX];//* update message?

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->lhcDoc == lhcDoc && pItem->otObject == OT_LINK)
      {   
         if (!i)
         {
            LoadString(hInst, IDS_UPDATELINKS, szUpdate, CBMESSAGEMAX);
            if (MessageBox(hwndFrame, szUpdate, szAppName,
               MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
               break; 
            i++;
         }
         Error(OleUpdate(pItem->lpObject));
      }
   }

   WaitForAllObjects();

}

/****************************************************************************
 * UpdateFromOpenServers()
 *
 * Get the most up to date rendering information before storing it.  
 ***************************************************************************/

static VOID UpdateFromOpenServers(VOID)
{                                      //* LOCAL:
   APPITEMPTR pItem;                   //* temporary item pointer
   APPITEMPTR pItemNext;

   for (pItem = GetTopItem(); pItem; pItem = pItemNext) 
   {
      pItemNext = GetNextItem(pItem); 
      if (pItem->otObject == OT_EMBEDDED || 
         (pItem->uoObject == oleupdate_oncall 
               && pItem->otObject == OT_LINK ))  

         if (OleQueryOpen(pItem->lpObject) == OLE_OK)
         {  
            CHAR szMessage[2*CBMESSAGEMAX];
            CHAR szBuffer[CBMESSAGEMAX];
            UINT cb = CBOBJNAMEMAX;       //* The name will be the server window title.
            CHAR szTmp[CBOBJNAMEMAX];     //* when the object is edited. 

            Error(OleQueryName(pItem->lpObject,szTmp,&cb));
            LoadString(hInst, IDS_UPDATE_OBJ, szBuffer, CBMESSAGEMAX);
            wsprintf(szMessage, szBuffer, (LPSTR)szTmp);

            if (MessageBox(hwndFrame, szMessage, szAppName, MB_YESNO | MB_ICONEXCLAMATION) == IDYES) 
            {
               Error(OleUpdate(pItem->lpObject));
               WaitForObject(pItem);
            }
            if (!pItem->fVisible)
               ObjDelete(pItem, OLE_OBJ_DELETE);
         }

   }

   WaitForAllObjects();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\srvrdemo\doc.c ===
/*
  OLE SERVER DEMO           
  Doc.c             
                                                                     
  This file contains document methods and various document-related support 
  functions.
                                                                     
  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved   
*/                                                                     
 
/* 
   Important Note:

   No method should ever dispatch a DDE message or allow a DDE message to
   be dispatched.
   Therefore, no method should ever enter a message dispatch loop.
   Also, a method should not show a dialog or message box, because the 
   processing of the dialog box messages will allow DDE messages to be
   dispatched.
*/



#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"

/* AssociateClient
 * ---------------
 *
 * Add a client to the list of clients associated with an object.
 *
 * This function is necessary only because ServerDemo does not create object
 * structures as they are requested, but rather has a fixed set of objects.
 * When DocGetObject is called with a NULL object name, the entire 
 * document is requested, but ServerDemo does not currently support making
 * the entire document an object, so DocGetObject returns one object.
 * That object now goes by two names: NULL and its real name.  Therefore
 * we need to keep track of both lpoleclient's that were passed to 
 * DocGetObject.  Ideally, DocGetObject should always create a new OBJ 
 * structure containing a pointer (or some reference) to the object's native
 * data and also containing one lpoleclient.
 *
 * LPOLECLIENT lpoleclient - the client to be associated with the object.
 * LPOBJ lpobj             - the object 
 *
 * RETURNS: TRUE if successful
 *          FALSE if out of memory
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
static BOOL AssociateClient (LPOLECLIENT lpoleclient, LPOBJ lpobj)
{
   INT i;
   for (i=0; i < clpoleclient; i++)
   {
      if (lpobj->lpoleclient[i]==lpoleclient)
      {
         return TRUE;
      }
      if (lpobj->lpoleclient[i]==NULL)
      {
         lpobj->lpoleclient[i]=lpoleclient;
         return TRUE;
      }
   }
   return FALSE;
}



/* CreateNewDoc
 * ------------
 *
 * If lhdoc == NULL then we must register the new document by calling
 * OleRegisterServerDoc, which will return a new handle which will be stored
 * in docMain.lhdoc.
 * Also if lhdoc==NULL then this document is being created at the request of
 * the user, not of the client library.
 *
 * LONG lhdoc      - Document handle
 * LPSTR lpszDoc   - Title of the new document
 * DOCTYPE doctype - What type of document is being created
 * 
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
BOOL CreateNewDoc (LONG lhdoc, LPSTR lpszDoc, DOCTYPE doctype)
{
   INT i;

   // Fill in the fields of the document structure.

   docMain.doctype      = doctype;
   docMain.oledoc.lpvtbl= &docvtbl;

   if (lhdoc == 0)
   {
      if (OLE_OK != OleRegisterServerDoc 
                     (srvrMain.lhsrvr, 
                      lpszDoc,
                      (LPOLESERVERDOC) &docMain, 
                      (LHSERVERDOC FAR *) &docMain.lhdoc))
         return FALSE;
   }
   else
      docMain.lhdoc = lhdoc;

   // Reset all the flags because no object numbers have been used.
   for (i=1; i <= cfObjNums; i++)
      docMain.rgfObjNums[i] = FALSE;

   fDocChanged = FALSE;

   SetTitle (lpszDoc, doctype == doctypeEmbedded);
   return TRUE;
}



/* DestroyDoc
 * ----------
 *
 * Free all memory that had been allocated for a document.
 *
 *
 * CUSTOMIZATION: Re-implement.  Your application will probably use some
 *                other method for enumerating all the objects in a document.
 *                ServerDemo enumerates the child windows, but if each object 
 *                does not have its own window, this will not work.
 *
 */
VOID DestroyDoc (VOID)
{
   HWND hwnd;
   HWND hwndNext;

   // Delete all object windows.  
   hwnd = SelectedObjectWindow();
   while (hwnd) 
   {
      hwndNext = GetWindow (hwnd, GW_HWNDNEXT);
      // Each object window frees its own memory upon receiving WM_DESTROY.
      DestroyWindow (hwnd);
      hwnd = hwndNext;
   } 

   if (docMain.aName)
   {
      GlobalDeleteAtom (docMain.aName);
      docMain.aName = '\0';
   }

   if (docMain.hpal)
      DeleteObject (docMain.hpal);
}



/* DocClose                DOCUMENT "Close" METHOD
 * --------
 *
 * The library calls this method to unconditionally close the document.
 *
 * LPOLESERVERDOC lpoledoc - The server document to close
 * 
 * RETURNS: Return value from RevokeDoc.
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocClose (LPOLESERVERDOC lpoledoc)
{
   return RevokeDoc();
}



/* DocExecute                DOCUMENT "Execute" METHOD
 * ----------
 *
 * This application does not support the execution of DDE execution commands.
 * 
 * LPOLESERVERDOC lpoledoc - The server document
 * HANDLE hCommands        - DDE execute commands
 * 
 * RETURNS: OLE_ERROR_COMMAND
 *
 * CUSTOMIZATION: Re-implement if your application supports the execution of
 *                DDE commands.
 *
 */
OLESTATUS  APIENTRY DocExecute (LPOLESERVERDOC lpoledoc, HANDLE hCommands)
{
   return OLE_ERROR_COMMAND;
}



/* DocGetObject                DOCUMENT "GetObject" METHOD
 * ------------
 *
 * The library uses this method to get an object's structure for the
 * client.  Memory needs to be allocated and initialized here for this.
 * A NULL string indicates that the client has an embedded object
 * which was started from Create, CreateFromTemplate, or Edit, but not Open.
 *
 * First see if the object name is NULL.  If so, you would ordinarily
 * return the entire document, but Server Demo returns the selected object.
 * If the object name is not NULL, then go through the list of objects, 
 * searching for one with that name.  Return an error if there is not one.
 *
 * LPOLESERVERDOC lpoledoc        - The server document
 * OLE_LPCSTR lpszObjectName           - The name of the object to get data for
 * LPOLEOBJECT FAR *lplpoleobject - The object's data is put here
 * LPOLECLIENT lpoleclient        - The client structure
 * 
 * RETURNS:        OLE_OK
 *                 OLE_ERROR_NAME if object not found
 *                 OLE_ERROR_MEMORY if no more memory to store lpoleclient
 *
 * CUSTOMIZATION: Re-implement.
 *                lpszObjectName == "" indicates that the whole document 
 *                should be the object returned.
 *
 */
OLESTATUS  APIENTRY DocGetObject
   (LPOLESERVERDOC lpoledoc, OLE_LPCSTR lpszObjectName, 
    LPOLEOBJECT FAR *lplpoleobject, LPOLECLIENT lpoleclient)
{
    HWND  hwnd;
    ATOM  aName;
    LPOBJ lpobj;


    if (lpszObjectName == NULL || lpszObjectName[0] == '\0')
    {   
        // Return a new object or the selected object.
        hwnd = SelectedObjectWindow();
        lpobj = hwnd ? HwndToLpobj (hwnd) : CreateNewObj (FALSE);
        *lplpoleobject = (LPOLEOBJECT) lpobj;
        // Associate client with object.
        if (!AssociateClient (lpoleclient, lpobj))
            return OLE_ERROR_MEMORY;
        return OLE_OK;
    }

    if (!(aName = GlobalFindAtom (lpszObjectName)))
        return OLE_ERROR_NAME;

    hwnd = SelectedObjectWindow();

    // Go through all the child windows and find the window whose name
    // matches the given object name.

    while (hwnd)
    {
         lpobj = HwndToLpobj (hwnd);

         if (aName == lpobj->aName)
         {
            // Return the object with the matching name.
            *lplpoleobject = (LPOLEOBJECT) lpobj;
            // Associate client with the object.
            if (!AssociateClient (lpoleclient, lpobj))
               return OLE_ERROR_MEMORY;
            return OLE_OK;
         }
         hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }

   if (((DOCPTR)lpoledoc)->doctype ==  doctypeEmbedded)
   {
      lpobj = CreateNewObj (FALSE);
      *lplpoleobject = (LPOLEOBJECT) lpobj;
      
      // Associate client with object.
      if (!AssociateClient (lpoleclient, lpobj))
         return OLE_ERROR_MEMORY;
      return OLE_OK;
    }

    // Object with name lpszObjName was not found.
    return OLE_ERROR_NAME;
}

/* DocRelease                DOCUMENT "Release" METHOD
 * ----------
 *
 * The library uses this method to notify the server that a revoked
 * document has finally finished all conversations, and can be 
 * destroyed.
 * It sets fWaitingForDocRelease to FALSE so a new document can be created
 * and the user can continue working.
 *
 * LPOLESERVERDOC lpoledoc        - The server document
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocRelease (LPOLESERVERDOC lpoledoc)
{
   fWaitingForDocRelease = FALSE;
   // Free all memory that has been allocated for the document.
   DestroyDoc();

   return OLE_OK;
}



/* DocSave                DOCUMENT "Save" METHOD
 * -------
 *
 * Save document to a file.
 *
 * LPOLESERVERDOC lpoledoc - The document to save
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocSave (LPOLESERVERDOC lpoledoc)
{
    if (docMain.doctype == doctypeFromFile)
    {
         // No "File Save As" dialog box will be brought up because the
         // file name is already known.
         return SaveDoc() ? OLE_OK : OLE_ERROR_GENERIC;
    }
    else
      return OLE_ERROR_GENERIC;
}



/* DocSetDocDimensions        DOCUMENT "SetDocDimensions" METHOD
 * -------------------
 *
 * The library calls this method to tell the server the bounds on
 * the target device for rendering the document.
 * A call to this method is ignored for linked objects because the size of
 * a linked document depends only on the source file.
 *
 * LPOLESERVERDOC lpoledoc - The server document
 * CONST LPRECT         lprect   - The target size in MM_HIMETRIC units
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: Re-implement
 *                How an object is sized is application-specific. (Server Demo
 *                uses MoveWindow.)
 *                     
 */
OLESTATUS  APIENTRY DocSetDocDimensions 
   (LPOLESERVERDOC lpoledoc, OLE_CONST RECT FAR * lprect)
{
   if (docMain.doctype == doctypeEmbedded)
   {
      RECT rect = *lprect;
      
      // the units are in HIMETRIC
      rect.right   = rect.right - rect.left;
		// the following was bottom - top
		rect.bottom  = rect.top -  rect.bottom;
		
      HiMetricToDevice ( (LPPOINT) &rect.right );
      MoveWindow (SelectedObjectWindow(), 0, 0, 
                  rect.right + 2 * GetSystemMetrics(SM_CXFRAME), 
                  rect.bottom + 2 * GetSystemMetrics(SM_CYFRAME), 
                  TRUE);
      /* If for some reason your application needs to notify the client that
         the data has changed because DocSetDocDimensions has been called,
         then notify the client here.
         SendDocMsg (OLE_CHANGED);
      */
   }
   return OLE_OK;
}



/* DocSetHostNames        DOCUMENT "SetHostNames" METHOD
 * ---------------
 *
 * The library uses this method to set the name of the document
 * window.
 * All this function does is change the title bar text, although it could
 * do more if necesary. 
 * This function is only called for embedded objects; linked objects
 * use their filenames for the title bar text.
 *
 * LPOLESERVERDOC lpoledoc    - The server document
 * OLE_LPCSTR lpszClient           - The name of the client
 * OLE_LPCSTR lpszDoc              - The client's name for the document
 * 
 * RETURNS:        OLE_OK
 * 
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocSetHostNames 
   (LPOLESERVERDOC lpoledoc, OLE_LPCSTR lpszClient, OLE_LPCSTR lpszDoc)
{
   SetTitle ((LPSTR)lpszDoc, TRUE);
   lstrcpy ((LPSTR) szClient, lpszClient);
   lstrcpy ((LPSTR) szClientDoc, Abbrev((LPSTR)lpszDoc));
   UpdateFileMenu (IDM_UPDATE);   
   return OLE_OK;
}



/* DocSetColorScheme                DOCUMENT "SetColorScheme" METHOD
 * -----------------
 *
 * The client calls this method to suggest a color scheme (palette) for
 * the server to use.
 * In Server Demo the document's palette is never actually used because each 
 * object has its own palette.  See ObjSetColorScheme.
 *
 * LPOLESERVERDOC lpoledoc - The server document
 * CONST LOGPALETTE FAR * lppal    - Suggested palette
 *
 * RETURNS: OLE_ERROR_PALETTE if CreatePalette fails, 
 *          OLE_OK otherwise
 *
 * 
 * CUSTOMIZATION: If your application supports color schemes, then this 
 *                function is a good example of how to create and store
 *                a palette.
 */
OLESTATUS  APIENTRY DocSetColorScheme 
   (LPOLESERVERDOC lpoledoc, OLE_CONST LOGPALETTE FAR * lppal)
{
   HPALETTE hpal = CreatePalette (lppal);

   if (hpal==NULL)
      return OLE_ERROR_PALETTE;

   if (docMain.hpal) 
   {
      // Delete old palette
      DeleteObject (docMain.hpal);
   }
   // Store handle to new palette
   docMain.hpal = hpal;
   return OLE_OK;
}



/* RevokeDoc
 * ---------
 *
 * Call OleRevokeServerDoc.
 * If the return value is OLE_WAIT_FOR_BUSY, then set fWaitingForDocRelease
 * and enter a message-dispatch loop until fWaitingForDocRelease is reset.
 * As long as fWaitingForDocRelease is set, the user interface will be 
 * disabled so that the user will not be able to manipulate the document.
 * When the DocRelease method is called, it will reset fWaitingForDocRelease,
 * allowing RevokeDoc to free the document's memory and return.
 *
 * This is essentially a way to make an asynchronous operation synchronous.
 * We need to wait until the old document is revoked before we can delete
 * its data and create a new one.
 *
 * Note that we cannot call RevokeDoc from a method because it is illegal to
 * enter a message-dispatch loop within a method.
 *
 * RETURNS: The return value of OleRevokeServerDoc.
 *
 * CUSTOMIZATION: lhdoc may need to be passed in as a parameter if your 
 *                application does not have a global variable corresponding 
 *                to docMain.
 * 
 */
OLESTATUS RevokeDoc (VOID)
{
   OLESTATUS olestatus;

   if ((olestatus = OleRevokeServerDoc(docMain.lhdoc)) > OLE_WAIT_FOR_RELEASE)
      DestroyDoc();

   docMain.lhdoc = 0; // A NULL handle indicates that the document 
                         // has been revoked or is being revoked.
   return olestatus;

}



/* SaveChangesOption
 * -----------------
 *
 * Give the user the opportunity to save changes to the current document
 * before continuing.
 *
 * BOOL *pfUpdateLater - Will be set to TRUE if the client does not accept
 *                       the update and needs to be updated when the document
 *                       is closed.  In that case, OLE_CLOSED will be sent.
 *
 * RETURNS: IDYES, IDNO, or IDCANCEL
 *
 * CUSTOMIZATION: None
 *
 */
INT SaveChangesOption (BOOL *pfUpdateLater)
{
   INT  nReply;
   CHAR szBuf[cchFilenameMax];
   
   *pfUpdateLater = FALSE;
   
   if (fDocChanged)
   {
       CHAR szTmp[cchFilenameMax];
       
       if (docMain.aName) 
           GlobalGetAtomName (docMain.aName, szTmp, cchFilenameMax);
       else 
           szTmp[0] = '\0';

       if (docMain.doctype == doctypeEmbedded)
           wsprintf (szBuf, "The object has been changed.\n\nUpdate %s before closing the object?", Abbrev (szTmp));        
       else
           lstrcpy (szBuf, (LPSTR) "Save changes?");         
     
       nReply = MessageBox (hwndMain, szBuf, szAppName, 
                      MB_ICONEXCLAMATION | MB_YESNOCANCEL);
                  
       switch (nReply)
       {
          case IDYES:
              if (docMain.doctype != doctypeEmbedded)
                  SaveDoc();
              else
                  switch (OleSavedServerDoc (docMain.lhdoc))
                  {
                      case OLE_ERROR_CANT_UPDATE_CLIENT:
                          *pfUpdateLater = TRUE;
                          break;
                      case OLE_OK:
                          break;
                      default:
                          ErrorBox ("Fatal Error: Cannot update.");
                  }                                      
              return IDYES;
          case IDNO:
              return IDNO;
         case IDCANCEL:
              return IDCANCEL;
       }
   }
   return TRUE;
}



/* SendDocMsg
 * ----------
 *
 * This function sends messages to all the objects in a document when
 * the document has changed.
 *
 * WORD wMessage - The message to send
 * 
 * CUSTOMIZATION: The means of enumerating all the objects in a document
 *                is application specific.
 */
VOID SendDocMsg (WORD wMessage)
{
    HWND    hwnd;

    // Get handle to first object window.
    hwnd = SelectedObjectWindow();

    // Send message to all object windows.
    while (hwnd)
    {
        SendObjMsg (HwndToLpobj(hwnd), wMessage);
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\srvrdemo\obj.c ===
/*
  OLE SERVER DEMO           
  Obj.c             
                                                                     
  This file contains object methods and various object-related support 
  functions.
                                                                     
  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved   
*/                                                                     

/* 
   Important Note:

   No method should ever dispatch a DDE message or allow a DDE message to
   be dispatched.
   Therefore, no method should ever enter a message dispatch loop.
   Also, a method should not show a dialog or message box, because the 
   processing of the dialog box messages will allow DDE messages to be
   dispatched.
*/


#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"



// Static functions.
static HBITMAP GetBitmap (LPOBJ lpobj);
static HANDLE  GetLink (LPOBJ lpobj);
static HANDLE  GetMetafilePict (LPOBJ lpobj);
static HANDLE  GetEnhMetafile (LPOBJ lpobj);
static HANDLE  GetNative (LPOBJ lpobj);
static INT     GetObjNum (LPOBJ lpobj);
static HANDLE  GetText (LPOBJ lpobj);
static VOID    DrawObj (HDC hdc, LPOBJ lpobj, RECT rc, INT dctype);



/* CreateNewObj
 * ------------
 *
 * BOOL fDoc_Changed - The new value for the global variable fDocChanged.
 *                     When initializing a new document, we need to create 
 *                     a new object without the creation counting as a 
 *                     change to the document.
 *
 * RETURNS: A pointer to the new object
 *
 * 
 * CUSTOMIZATION: Re-implement
 *                Some applications (like Server Demo) have a finite number of
 *                fixed, distinct, non-overlapping objects.  Other applications
 *                allow the user to create an object from any section of the
 *                document.  For example, the user might select a portion of
 *                a bitmap from a paint program, or a few lines of text from
 *                a word processor.  This latter type of application probably
 *                will not have a function like CreateNewObj.
 *
 */
LPOBJ CreateNewObj (BOOL fDoc_Changed)
{
    HANDLE hObj = NULL;
    LPOBJ  lpobj = NULL;
    // index into an array of flags indicating if that object number is used.
    INT    ifObj = 0;    

    if ((hObj = LocalAlloc (LMEM_MOVEABLE|LMEM_ZEROINIT, sizeof (OBJ))) == NULL)
      return NULL;

    if ((lpobj = (LPOBJ) LocalLock (hObj)) == NULL)
    {
      LocalFree (hObj);
      return NULL;
    }

    // Fill the fields in the object structure.
    
    // Find an unused number.
    for (ifObj=1; ifObj <= cfObjNums; ifObj++)
    {
      if (docMain.rgfObjNums[ifObj]==FALSE)
      {
         docMain.rgfObjNums[ifObj]=TRUE;
         break;
      }
    }

    if (ifObj==cfObjNums+1)
    {
      // Cannot create any more objects.
      MessageBeep(0);
      return NULL;
    }

    wsprintf (lpobj->native.szName, "Object %d", ifObj);

    lpobj->aName            = GlobalAddAtom (lpobj->native.szName);
    lpobj->hObj             = hObj;
    lpobj->oleobject.lpvtbl = &objvtbl;
    lpobj->native.idmColor  = IDM_RED;    // Default color 
    lpobj->native.version   = version;
    lpobj->native.nWidth    = OBJECT_WIDTH;          // Default size
    lpobj->native.nHeight   = OBJECT_HEIGHT;
    SetHiMetricFields (lpobj);

    // Place object in a location corrsponding to its number, for aesthetics.
    lpobj->native.nX = (ifObj - 1) * 20;
    lpobj->native.nY = (ifObj - 1) * 20;

    if (!CreateWindow (
        "ObjClass",
        "Obj",
        WS_BORDER | WS_THICKFRAME | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE,
        lpobj->native.nX,
        lpobj->native.nY,
        lpobj->native.nWidth,
        lpobj->native.nHeight,
        hwndMain,
        NULL,
        hInst,
        (LPSTR) lpobj ))
         return FALSE;

    fDocChanged = fDoc_Changed;

    return lpobj;
}



/* CutOrCopyObj
 * ------------
 *
 * Put data onto clipboard in all the formats supported.  If the 
 * fOpIsCopy is TRUE, the operation is COPY, otherwise it is CUT.
 * This is important, because we cannot put the Object Link format
 * onto the clipboard if the object was cut from the document (there is
 * no longer anything to link to).
 *
 * BOOL fOpIsCopy - TRUE if the operation is COPY; FALSE if CUT
 * 
 * CUSTOMIZATION: None
 *
 *
 */
VOID CutOrCopyObj (BOOL fOpIsCopy)
{
    LPOBJ       lpobj;
    HANDLE      hData;
//	 UINT     hBit;

    if (OpenClipboard (hwndMain))
    {
        EmptyClipboard ();

        lpobj = SelectedObject();

        if ((hData = GetNative (lpobj)) != NULL)
            SetClipboardData(cfNative, hData);

        if ((hData = GetLink(lpobj)) != NULL)
            SetClipboardData(cfOwnerLink, hData);

        if (fOpIsCopy && docMain.doctype == doctypeFromFile)
        {
            // Can create a link if object exists in a file.
            if ((hData = GetLink(lpobj)) != NULL)
               SetClipboardData(cfObjectLink, hData);
        }

        if ((hData = GetEnhMetafile(lpobj)) != NULL)
        {
            SetClipboardData(CF_ENHMETAFILE, hData);
              GlobalFree(hData);
        }

        if ((hData = GetBitmap(lpobj)) != NULL)
        {
        //	  SetClipboardData(CF_BITMAP, GetBitmap(lpobj));
              SetClipboardData(CF_BITMAP, hData);
              DeleteObject(hData);
        }


        CloseClipboard ();
    }
}


/* DestroyObj
 * ----------
 *
 * Revoke an object, and free all memory that had been allocated for it.
 *
 * HWND hwnd - The object's window
 * 
 * CUSTOMIZATION: Re-implement, making sure you free all the memory that
 *                had been allocated for the OBJ structure and each of its
 *                fields.
 * 
 */
VOID DestroyObj (HWND hwnd)
{
   LPOBJ lpobj = HwndToLpobj (hwnd);

   if(lpobj->aName)
   {
      GlobalDeleteAtom (lpobj->aName);
      lpobj->aName = '\0';
   }

   if (lpobj->hpal) 
      DeleteObject (lpobj->hpal);
   // Allow the object's number to be reused.
   docMain.rgfObjNums [GetObjNum(lpobj)] = FALSE;


   // Free the memory that had been allocated for the object structure itself.
   LocalUnlock (lpobj->hObj);
   LocalFree (lpobj->hObj);
}



/* DrawObj
 * -------
 *
 * This function draws an object onto the screen, into a metafile, or into
 * a bitmap.
 * The object will always look the same.
 *
 * HDC    hdc    - The device context to render the object into
 * LPOBJ  lpobj  - The object to render
 * RECT   rc     - The rectangle bounds of the object
 * DCTYPE dctype - The type of device context.
 * 
 * CUSTOMIZATION: Server Demo specific
 *
 */
static VOID DrawObj (HDC hdc, LPOBJ lpobj, RECT rc, INT dctype)
{
   HPEN     hpen;
   HPEN     hpenOld;
   HPALETTE hpalOld = NULL;


   if (dctype == dctypeMetafile)
   {
      SetWindowOrgEx (hdc, 0, 0, NULL);
      // Paint entire object into the given rectangle.
      SetWindowExtEx (hdc, rc.right, rc.bottom, NULL);
   }
 
   if (lpobj->hpal)
   {
      hpalOld = SelectPalette (hdc, lpobj->hpal, TRUE);
      RealizePalette (hdc);
   }

   // Select brush of the color specified in the native data.
   SelectObject (hdc, hbrColor [lpobj->native.idmColor - IDM_RED] );

   hpen = CreatePen (PS_SOLID, 
                     /* Width */ (rc.bottom-rc.top) / 10,
                     /* Gray */ 0x00808080);
   hpenOld = SelectObject (hdc, hpen);

   // Draw rectangle with the gray pen and fill it in with the selected brush.
   Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

   // Print name of object inside rectangle.
   SetBkMode (hdc, TRANSPARENT);
   SetTextAlign (hdc, TA_BASELINE | TA_CENTER);
   TextOut (hdc, 
            rc.right/2, 
            (rc.top+rc.bottom)/2, 
            lpobj->native.szName, 
            lstrlen (lpobj->native.szName));

   // Restore original objects
   SelectObject (hdc, 
                 (dctype == dctypeMetafile || dctype == dctypeEnhMetafile) 
                     ? GetStockObject (BLACK_PEN) : hpenOld);
   if (hpalOld)
   {
      SelectPalette (hdc, 
                     (dctype == dctypeMetafile || dctype == dctypeEnhMetafile) 
                        ? GetStockObject (DEFAULT_PALETTE) : hpalOld,
                     TRUE);
   }

   DeleteObject (hpen);
}



/* GetBitmap
 * ---------
 *
 * Return a handle to an object's picture data in bitmap format.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's picture data
 * 
 * CUSTOMIZATION: Re-implement
 * 
 */
static HBITMAP GetBitmap (LPOBJ lpobj)
{
    HDC         hdcObj;
    HDC         hdcMem;
    RECT        rc;
    HBITMAP     hbitmap;
    HBITMAP    hbitmapOld;


    hdcObj = GetDC (lpobj->hwnd);
    // Create a memory device context.
    hdcMem = CreateCompatibleDC (hdcObj);
    GetClientRect (lpobj->hwnd, (LPRECT)&rc);
    // Create new bitmap object based on the bitmap of the OLE object.
    hbitmap = CreateCompatibleBitmap 
      (hdcObj, rc.right - rc.left, rc.bottom - rc.top);
    // Select new bitmap as the bitmap object for the memory device context.
    hbitmapOld = SelectObject (hdcMem, hbitmap);

    // Paint directly into the memory dc using the new bitmap object.
    DrawObj (hdcMem, lpobj, rc, dctypeBitmap);

    // Restore old bitmap object.
    hbitmap = SelectObject (hdcMem, hbitmapOld);
    DeleteDC (hdcMem);
    ReleaseDC (lpobj->hwnd, hdcObj);

    // convert width and height to HIMETRIC units
    rc.right  = rc.right - rc.left;
    rc.bottom = rc.bottom - rc.top;
    DeviceToHiMetric ( (LPPOINT) &rc.right );
    
    // Set the 1/10 of HIMETRIC units for the bitmap
    SetBitmapDimensionEx (hbitmap, (DWORD) (rc.right/10), (DWORD) (rc.bottom/10), NULL);

//    if (OpenClipboard (hwndMain))
//    {
//  //      EmptyClipboard ();
//          SetClipboardData(CF_BITMAP, hbitmap);
//          CloseClipboard();
//    }
	 return hbitmap;
}



/* GetLink
 * -------
 *
 * Return a handle to an object's object or owner link data.
 * Link information is in the form of three zero-separated strings,
 * terminated with two zero bytes:  CLASSNAME\0DOCNAME\0OBJNAME\0\0
 *
 * LPOBJ lpobj - The object 
 * 
 * RETURNS: A handle to the object's link data
 * 
 * CUSTOMIZATION: Re-implement
 *
 */
static HANDLE GetLink (LPOBJ lpobj)
{

    CHAR   sz[cchFilenameMax];
    LPSTR  lpszLink = NULL;
    HANDLE hLink = NULL;
    INT    cchLen;
    INT    i;

    // First make the class name.
    lstrcpy (sz, szClassName);
    cchLen = lstrlen (sz) + 1;

    // Then the document name.
    cchLen += GlobalGetAtomName 
               (docMain.aName, (LPSTR)sz + cchLen, 
                cchFilenameMax - cchLen) + 1;

    // Then the object name.
    lstrcpy (sz + cchLen, lpobj->native.szName);
    cchLen += lstrlen (lpobj->native.szName) + 1;

    // Add a second null to the end.
    sz[cchLen++] = 0;       


    hLink = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, cchLen);
    if (hLink == NULL)
      return NULL;
    if ((lpszLink = GlobalLock (hLink)) == NULL)
    {
      GlobalFree (hLink);
      return NULL;
    }

    for (i=0; i < cchLen; i++)
        lpszLink[i] = sz[i];

    GlobalUnlock (hLink);

    return hLink;
}



/* GetMetafilePict
 * ---------------
 *
 * Return a handle to an object's picture data in metafile format.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's data in metafile format.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static HANDLE GetMetafilePict (LPOBJ lpobj)
{

    LPMETAFILEPICT  lppict = NULL;
    HANDLE          hpict = NULL;
    HANDLE          hMF = NULL;
    RECT            rc;
    HDC             hdc;

    hdc = CreateMetaFile(NULL);

    GetClientRect (lpobj->hwnd, (LPRECT)&rc);

    // Paint directly into the metafile.
    DrawObj (hdc, lpobj, rc, dctypeMetafile);

    // Get handle to the metafile.
    if ((hMF = CloseMetaFile (hdc)) == NULL)
      return NULL;

    if(!(hpict = GlobalAlloc (GMEM_DDESHARE, sizeof (METAFILEPICT))))
    {
        DeleteMetaFile (hMF);
        return NULL;
    }

    if ((lppict = (LPMETAFILEPICT)GlobalLock (hpict)) == NULL)
    {
        DeleteMetaFile (hMF);
        GlobalFree (hpict);
        return NULL;
    }

    rc.right  = rc.right - rc.left;
    rc.bottom = rc.bottom - rc.top;
    
    DeviceToHiMetric ( (LPPOINT) &rc.right);

    lppict->mm   =  MM_ANISOTROPIC;
    lppict->hMF  =  hMF;
    lppict->xExt =  rc.right;
    lppict->yExt =  rc.bottom;
    GlobalUnlock (hpict);
    return hpict;
}

/* GetEnhMetafile
 * ---------------
 *
 * Return a handle to an object's picture data in metafile format.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's data in metafile format.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static HANDLE GetEnhMetafile (LPOBJ lpobj)
{

    LPMETAFILEPICT  lppict = NULL;
    HANDLE          hemf   = NULL;
    HANDLE          hMF    = NULL;
    RECT            rc;
    HDC             hdc, hdc2;


    GetClientRect (lpobj->hwnd, (LPRECT)&rc);

    rc.right   -= rc.left;
    rc.bottom  -= rc.top;
    rc.left     = rc.top  = 0;
	 
    DeviceToHiMetric ( (LPPOINT) &rc.right );
	 
    hdc = CreateEnhMetaFile ( NULL, NULL, &rc, NULL );
    
                                       //* this is necessary because
                                       //* we need to draw the object
                                       //* in device coordinates that are
                                       //* the same physical size as the HIMETRIC
                                       //* logical space used in CreateEnhMetaFile.
                                       //* In this case we have scaled the HIMETRIC
                                       //* units down in order to use the logical
                                       //* pixel ratio (which is recommended UI)
                                       //* so we therefore have to convert the
                                       //* scaled HIMETRIC units back to Device.
                                      
    hdc2 = GetDC(NULL);				

    SetMapMode(hdc2, MM_HIMETRIC);
    LPtoDP (hdc2, (LPPOINT)&rc.right, 1);
    if (rc.bottom < 0) rc.bottom *= -1;

    ReleaseDC(NULL,hdc2);

	DrawObj (hdc, lpobj, rc, dctypeMetafile);

    if ((hemf = (HANDLE)CloseEnhMetaFile (hdc)) == NULL)
      return NULL;

    return hemf;
}


/* GetNative
 * ---------
 *
 * Return a handle to an object's native data.
 *
 * LPOBJ lpobj - The object whose native data is to be retrieved.
 * 
 * RETURNS: a handle to the object's native data.
 *
 * CUSTOMIZATION: The line "*lpnative = lpobj->native;" will change to 
 *                whatever code is necessary to copy an object's native data.
 *
 */
static HANDLE GetNative (LPOBJ lpobj)
{
   LPNATIVE lpnative = NULL;
   HANDLE   hNative  = NULL;

   hNative = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, sizeof (NATIVE));
   if (hNative == NULL)
      return NULL;
   if ((lpnative = (LPNATIVE) GlobalLock (hNative)) == NULL)
   {
      GlobalFree (hNative);
      return NULL;
   }

   // Copy the native data.
   *lpnative = lpobj->native;

   GlobalUnlock (hNative);
   return hNative;
}



/* GetObjNum
 * ---------
 *
 * LPSTR lpobj - The object whose number is desired
 *
 * RETURNS: The number of the object, i.e., the numerical portion of its name.
 *
 * CUSTOMIZATION: Server Demo specific
 */
static INT GetObjNum (LPOBJ lpobj)
{
   LPSTR lpsz;
   INT n=0;

   lpsz = lpobj->native.szName + 7;
   while (*lpsz && *lpsz>='0' && *lpsz<='9')
      n = 10*n + *lpsz++ - '0';
   return n;
}



/* GetText
 * -------
 *
 * Return a handle to an object's data in text form.
 * This function simply returns the name of the object.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's text.
 *
 * CUSTOMIZATION: Re-implement, if your application supports CF_TEXT as a 
 *                presentation format.
 *
 */
static HANDLE GetText (LPOBJ lpobj)
{
    HANDLE hText    = NULL;
    LPSTR  lpszText = NULL;

    if(!(hText = GlobalAlloc (GMEM_DDESHARE, sizeof (lpobj->native.szName))))
      return NULL;

    if (!(lpszText = GlobalLock (hText)))
      return NULL;

    lstrcpy (lpszText, lpobj->native.szName);

    GlobalUnlock (hText);

    return hText;
}



/* ObjDoVerb                OBJECT "DoVerb" METHOD
 * ---------
 *
 * This method is called by the client, through the library, to either
 * PLAY, or EDIT the object.  PLAY is implemented as a beep, and
 * EDIT will bring up the server and show the object for editing.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * WORD wVerb              - The verb acting on the object: PLAY or EDIT
 * BOOL fShow              - Should the object be shown?
 * BOOL fTakeFocus         - Should the object window get the focus?
 * 
 * RETURNS:        OLE_OK
 *
 * CUSTOMIZATION: Add any more verbs your application supports.
 *                Implement verbPlay if your application supports it.
 *
 */
OLESTATUS  APIENTRY ObjDoVerb 
   (LPOLEOBJECT lpoleobject, UINT wVerb, BOOL fShow, BOOL fTakeFocus)
{
    switch (wVerb) 
    {
         case verbPlay:
         {  // The application can do whatever is appropriate for the object.
            INT i;
            for (i=0; i<25;i++) MessageBeep (0);
            return OLE_OK;
         }

         case verbEdit:
            if (fShow)
               return objvtbl.Show (lpoleobject, fTakeFocus);
            else
               return OLE_OK;
         default:
            // Unknown verb.
            return OLE_ERROR_DOVERB;
    }
}



/* ObjEnumFormats        OBJECT "EnumFormats" METHOD
 * ---------------
 *
 * This method is used to enumerate all supported clipboard formats.
 * Terminate by returning NULL.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * OLECLIPFORMAT cfFormat  - The 'current' clipboard format
 * 
 * RETURNS: The 'next' clipboard format which is supported.
 *
 * CUSTOMIZATION: Verify that the list of formats this function 
 *                returns matches the list of formats your application 
 *                supports.
 *
 */
OLECLIPFORMAT  APIENTRY ObjEnumFormats
   (LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat)
{
      if (cfFormat == 0)
        return cfNative;

      if (cfFormat == cfNative)
         return cfOwnerLink;

      if (cfFormat == cfOwnerLink)
         return CF_ENHMETAFILE;

      if (cfFormat == CF_ENHMETAFILE)
         return CF_METAFILEPICT;

      if (cfFormat == CF_METAFILEPICT)
         return CF_BITMAP;

      if (cfFormat == CF_BITMAP)
         return cfObjectLink;

      if (cfFormat == cfObjectLink)
         return 0;

      return 0;
}



/* ObjGetData                OBJECT "GetData" METHOD
 * -----------
 *
 * Return the data requested for the specified object in the specified format.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * WORD cfFormat           - The data type requested in standard
 *                           clipboard format
 * LPHANDLE lphandle       - Pointer to handle to memory where data
 *                           will be stored
 * 
 * RETURNS: OLE_OK           if successful
 *          OLE_ERROR_MEMORY if there was an error getting the data.
 *          OLE_ERROR_FORMAT if the requested format is unknown.
 *
 * 
 * CUSTOMIZATION: Add any additional formats your application supports, and
 *                remove any formats it does not support.
 *
 */
OLESTATUS  APIENTRY ObjGetData
   (LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat, LPHANDLE lphandle)
{

   LPOBJ lpobj;

   lpobj = (LPOBJ) lpoleobject;

   if (cfFormat ==  cfNative)
   {
      if (!(*lphandle = GetNative (lpobj)))
         return OLE_ERROR_MEMORY;
      // The client has requested the data in native format, therefore
      // the data in the client and server are in sync.
      fDocChanged = FALSE;
      return OLE_OK; 
   }                

   if (cfFormat == CF_ENHMETAFILE)
   {
      if (!(*lphandle = GetEnhMetafile (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == CF_METAFILEPICT)
   {
      if (!(*lphandle = GetMetafilePict (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == CF_BITMAP)
   {
      if (!(*lphandle = (HANDLE)GetBitmap (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == CF_TEXT) 
   {
      if (!(*lphandle = GetText (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == cfObjectLink)
   {
      if (!(*lphandle = GetLink (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat ==  cfOwnerLink)
   {
      if (!(*lphandle = GetLink (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   return OLE_ERROR_FORMAT;
}



/* ObjQueryProtocol                OBJECT "QueryProtocol" METHOD
 * ----------------
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * OLE_LPCSTR lpszProtocol      - The protocol name, either "StdFileEditing"
 *                           or "StdExecute"
 * 
 * RETURNS: If lpszProtocol is supported, return a pointer to an OLEOBJECT 
 *          structure with an appropriate method table for that protocol.
 *          Otherwise, return NULL.
 *
 * CUSTOMIZATION: Allow any additional protocols your application supports.
 *
 *
 */
LPVOID  APIENTRY ObjQueryProtocol 
   (LPOLEOBJECT lpoleobject, OLE_LPCSTR lpszProtocol)
{
   return lstrcmp (lpszProtocol, "StdFileEditing") ? NULL : lpoleobject ;
}



/* ObjRelease                OBJECT "Release" METHOD
 * -----------
 *
 * The server application should not destroy data when the library calls the 
 * ReleaseObj method.
 * The library calls the ReleaseObj method when no clients are connected 
 * to the object.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * 
 * RETURNS: OLE_OK
 * 
 * CUSTOMIZATION: Re-implement.  Do whatever needs to be done, if anything,
 *                when no clients are connected to an object.
 *
 */
OLESTATUS  APIENTRY ObjRelease (LPOLEOBJECT lpoleobject)
{
   INT i;
   /* No client is connected to the object so break all assocaiations
      between clients and the object. */
   for (i=0; i < clpoleclient; i++)
      ((LPOBJ)lpoleobject)->lpoleclient[i] = NULL;
   return OLE_OK;
}



/* ObjSetBounds        OBJECT "SetBounds" METHOD
 * ------------
 *
 * This method is called to set new bounds for an object.
 * The bounds are in HIMETRIC units.
 * A call to this method is ignored for linked objects because the size of
 * a linked object depends only on the source file.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * OLE_CONST RECT FAR* lprect           - The new bounds
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: Re-implement
 *                How an object is sized is application-specific. (Server Demo
 *                uses MoveWindow.)
 *
 */
OLESTATUS  APIENTRY ObjSetBounds (LPOLEOBJECT lpoleobj, OLE_CONST RECT FAR * lprect)
{
   if (docMain.doctype == doctypeEmbedded)
   {
      RECT rect = *lprect;
      LPOBJ lpobj = (LPOBJ) lpoleobj;
      
      // the units are in HIMETRIC
      rect.right   = rect.right - rect.left;
      rect.bottom  = rect.top - rect.bottom;
      HiMetricToDevice ( (LPPOINT) &rect.right);
      MoveWindow (lpobj->hwnd, lpobj->native.nX, lpobj->native.nY, 
                  rect.right + 2 * GetSystemMetrics(SM_CXFRAME), 
                  rect.bottom + 2 * GetSystemMetrics(SM_CYFRAME), 
                  TRUE);
   }
   return OLE_OK;
}



/* ObjSetColorScheme                OBJECT "SetColorScheme" METHOD
 * -----------------
 *
 * The client calls this method to suggest a color scheme (palette) for
 * the server to use for the object.
 *
 * LPOLEOBJECT  lpoleobject       - The OLE object
 * OLE_CONST LOGPALETTE FAR * lppal             - Suggested palette
 *
 * RETURNS: OLE_ERROR_PALETTE if CreatePalette fails, 
 *          OLE_OK otherwise
 *
 * 
 * CUSTOMIZATION: If your application supports color schemes, then this 
 *                function is a good example of how to create and store
 *                a palette.
 *
 */
OLESTATUS  APIENTRY ObjSetColorScheme 
   (LPOLEOBJECT lpoleobject, OLE_CONST LOGPALETTE FAR *lppal)
{
   HPALETTE hpal = CreatePalette (lppal);
   LPOBJ lpobj   = (LPOBJ) lpoleobject;

   if (hpal==NULL)
      return OLE_ERROR_PALETTE;

   if (lpobj->hpal) 
      DeleteObject (lpobj->hpal);
   lpobj->hpal = hpal;
   return OLE_OK;
}



/* ObjSetData                OBJECT "SetData" METHOD
 * ----------
 *
 * This method is used to store data into the object in the specified
 * format.  This will be called with Native format after an embedded
 * object has been opened by the Edit method.
 *
 * LPOLEOBJECT lpoleobject      - The OLE object
 * WORD cfFormat                - Data type, i.e., clipboard format
 * HANDLE hdata                 - Handle to the data.
 * 
 * RETURNS:       OLE_OK if the data was stored properly
 *                OLE_ERROR_FORMAT if format was not cfNative.
 *                OLE_ERROR_MEMORY if memory could not be locked.
 * 
 * CUSTOMIZATION: The large then-clause will need to be re-implemented for
 *                your application.  You may wish to support additional
 *                formats besides cfNative.
 *
 */
OLESTATUS  APIENTRY ObjSetData 
   (LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat, HANDLE hdata)
{
    LPNATIVE lpnative;
    LPOBJ    lpobj;

    lpobj = (LPOBJ)lpoleobject;

    if (cfFormat != cfNative)
    {
      return OLE_ERROR_FORMAT;
    }

    lpnative = (LPNATIVE) GlobalLock (hdata);

    if (lpnative)
    {
        lpobj->native = *lpnative;
        if (lpobj->aName)
            GlobalDeleteAtom (lpobj->aName);
        lpobj->aName = GlobalAddAtom (lpnative->szName);
        // CreateNewObj made an "Object 1" but we may be changing its number.
        docMain.rgfObjNums[1] = FALSE;
        docMain.rgfObjNums [GetObjNum(lpobj)] = TRUE;

        MoveWindow (lpobj->hwnd, 0, 0,
//                    lpobj->native.nWidth + 2 * GetSystemMetrics(SM_CXFRAME), 
//                    lpobj->native.nHeight+ 2 * GetSystemMetrics(SM_CYFRAME),
                    lpobj->native.nWidth, 
                    lpobj->native.nHeight,

                    FALSE);
        GlobalUnlock (hdata);
    }
    // Server is responsible for deleting the data.
    GlobalFree(hdata);           
    return lpnative ? OLE_OK : OLE_ERROR_MEMORY;
}



/* ObjSetTargetDevice        OBJECT "SetTargetDevice" METHOD
 * -------------------
 *
 * This method is used to indicate the device type that an object
 * will be rendered on.  It is the server's responsibility to free hdata.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * HANDLE hdata            - Handle to memory containing
 *                           a StdTargetDevice structure
 * 
 * RETURNS: OLE_OK
 * 
 * CUSTOMIZATION: Implement.  Server Demo currently does not do anything.
 *
 */
OLESTATUS  APIENTRY ObjSetTargetDevice (LPOLEOBJECT lpoleobject, HANDLE hdata)
{
    if (hdata == NULL)
    {
      // Rendering for the screen is requested.
    }
    else
    {
      LPSTR lpstd = (LPSTR) GlobalLock (hdata);
      // lpstd points to a StdTargetDevice structure.
      // Use it to do whatever is appropriate to generate the best results 
      // on the specified target device.
      GlobalUnlock (hdata);
      // Server is responsible for freeing the data.
      GlobalFree (hdata);  
    }
    return OLE_OK;
}



/* ObjShow                OBJECT "Show" METHOD
 * --------
 *
 * This method is used to display the object.  
 * The server application should be activated and brought to the top.
 * Also, in a REAL server application, the object should be scrolled
 * into view.  The object should be selected.
 *
 * LPOLEOBJECT lpoleobject - Pointer to the OLE object
 * BOOL fTakeFocus         - Should server window get the focus?
 * 
 * RETURNS:        OLE_OK
 *
 * 
 * CUSTOMIZATION: In your application, the document should be scrolled 
 *                to bring the object into view.  Server Demo brings the 
 *                object to the front, in case it is a linked object inside a 
 *                document with other objects obscuring it.
 *
 */
OLESTATUS  APIENTRY ObjShow (LPOLEOBJECT lpoleobject, BOOL fTakeFocus)
{
    LPOBJ lpobj;
    HWND hwndOldFocus;

    hwndOldFocus = GetFocus();
    lpobj = (LPOBJ) lpoleobject;
    
    if (fTakeFocus)
       SetForegroundWindow (lpobj->hwnd);

    ShowWindow(hwndMain, SW_SHOWNORMAL);

    SetFocus (fTakeFocus ? lpobj->hwnd : hwndOldFocus);
    return OLE_OK;
}



/* PaintObj
 * ---------
 *
 * This function is called by the WM_PAINT message to paint an object 
 * on the screen.  
 *
 * HWND hwnd - The object window in which to paint the object
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
VOID PaintObj (HWND hwnd)
{
    LPOBJ       lpobj;
    RECT        rc;
    HDC         hdc;
    PAINTSTRUCT paintstruct;

    BeginPaint (hwnd, &paintstruct);
    hdc = GetDC (hwnd);

    lpobj = HwndToLpobj (hwnd);
    GetClientRect (hwnd, (LPRECT) &rc);

    DrawObj (hdc, lpobj, rc, dctypeScreen);

    ReleaseDC (hwnd, hdc);
    EndPaint (hwnd, &paintstruct);
}



/* RevokeObj
 * ---------
 *
 * Call OleRevokeObject because the user has destroyed the object.
 *
 * LPOBJ lpobj - The object which has been destroyed
 *
 * 
 * CUSTOMIZATION: You will only need to call OleRevokeObject once if there
 *                is only one LPOLECLIENT in your OBJ structure, which there
 *                should be.
 *
 */
VOID RevokeObj (LPOBJ lpobj)
{
   INT i;

   for (i=0; i< clpoleclient; i++)
   {
      if (lpobj->lpoleclient[i])
         OleRevokeObject (lpobj->lpoleclient[i]);
      else 
         /* if lpobj->lpoleclient[i]==NULL then there are no more non-NULLs
            in the array. */
         break;
   }
}



/* SendObjMsg
 * ----------
 *
 * This function sends a message to a specific object.
 *
 * LPOBJ lpobj   - The object
 * WORD wMessage - The message to send
 * 
 * CUSTOMIZATION: You will only need to call CallBack once if there
 *                is only one LPOLECLIENT in your OBJ structure, which there
 *                should be.
 *
 */
VOID SendObjMsg (LPOBJ lpobj, WORD wMessage)
{
   INT i;
   for (i=0; i < clpoleclient; i++)
   {
      if (lpobj->lpoleclient[i])
      {
         // Call the object's Callback function.
         lpobj->lpoleclient[i]->lpvtbl->CallBack 
            (lpobj->lpoleclient[i], wMessage, (LPOLEOBJECT) lpobj);
      }
      else
         break;
   }
}



/* SizeObj
 * -------
 *
 * Change the size of an object.
 *
 * HWND hwnd  - The object's window
 * RECT rect  - The requested new size in device units
 * BOOL fMove - Should the object be moved? (or just resized?)
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
VOID SizeObj (HWND hwnd, RECT rect, BOOL fMove)
{
   LPOBJ lpobj;

   lpobj = HwndToLpobj (hwnd);
   if (fMove)
   {
      lpobj->native.nX   = rect.left;
      lpobj->native.nY   = rect.top;
   }
   lpobj->native.nWidth  = rect.right  - rect.left;
   lpobj->native.nHeight = rect.bottom - rect.top ;
   SetHiMetricFields (lpobj);
   InvalidateRect (hwnd, (LPRECT)NULL, TRUE);
   fDocChanged = TRUE;
   if (docMain.doctype == doctypeFromFile)
   {
      // If object is linked, update it in client now. 
      SendObjMsg (lpobj, OLE_CHANGED);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\srvrdemo\file.c ===
/*
  OLE SERVER DEMO
  File.c

  This file contains file input/output functions for for the OLE server demo.

  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
*/



#include <windows.h>
#include <commDlg.h>
#include <ole.h>

#include "srvrdemo.h"

// File signature stored in the file.
#define szSignature "ServerDemo"
#define cchSigLen (10+1)

// Delimiter for fields in the file
#define chDelim ':'

// Default file extension
#define szDefExt "sd1"

// File header structure
typedef struct
{
   CHAR szSig [cchSigLen];
   CHAR chDelim1;
   VERSION version;
   CHAR chDelim2;
   CHAR rgfObjNums [cfObjNums+1];
} HEADER;

// BOOL  GetFileSaveFilename (LPSTR lpszFilename);
static VOID  InitOfn (OPENFILENAME *pofn);
static BOOL  SaveDocIntoFile (PSTR);
static LPOBJ ReadObj (INT fh);



/* CreateDocFromFile
 * -----------------
 *
 * Read a document from the specified file.
 *
 * LPSTR lpszDoc     - Name of the file containing the document
 * LHSERVERDOC lhdoc - Handle to the document
 * DOCTYPE doctype   - In what state the document is created
 *
 * RETURNS: TRUE if successful, FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement
 *                This function will need to be completely re-implemented
 *                to support your application's file format.
 *
 */
BOOL CreateDocFromFile (LPSTR lpszDoc, LHSERVERDOC lhdoc, DOCTYPE doctype)
{
    INT     fh;        // File handle
    HEADER  hdr;
    INT     i;

    if ((fh =_lopen(lpszDoc, OF_READ)) == -1)
        return FALSE;

    // Read header from file.
    if (_lread(fh, (LPSTR) &hdr, (UINT)sizeof(HEADER)) < sizeof (HEADER))
      goto Error;

    // Check to see if file is a server demo file.
    if (lstrcmp(hdr.szSig, szSignature))
      goto Error;

    if (hdr.chDelim1 != chDelim)
      goto Error;

    // Check to see if file was saved under the most recent version.
    // Here is where you would handle reading in old versions.
    if (hdr.version != version)
      goto Error;

    if (hdr.chDelim2 != chDelim)
      goto Error;

    if (!CreateNewDoc (lhdoc, lpszDoc, doctype))
      goto Error;

    // Get the array indicating which object numbers have been used.
    for (i=1; i <= cfObjNums; i++)
      docMain.rgfObjNums[i] = hdr.rgfObjNums[i];

    // Read in object data.
    for (i=0; ReadObj (fh); i++);

    if (!i)
    {
         OLESTATUS olestatus;

         fRevokeSrvrOnSrvrRelease = FALSE;

         if ((olestatus = RevokeDoc()) > OLE_WAIT_FOR_RELEASE)
            goto Error;
         else if (olestatus == OLE_WAIT_FOR_RELEASE)
            Wait (&fWaitingForDocRelease);

         fRevokeSrvrOnSrvrRelease = TRUE;
         EmbeddingModeOff();
         goto Error;
    }

    _lclose(fh);

    fDocChanged = FALSE;
    return TRUE;

Error:
    _lclose(fh);
    return FALSE;

}



/* OpenDoc
 * -------
 *
 * Prompt the user for which document he wants to open
 *
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: None, except your application may or may not call
 *                CreateNewObj to create a default object.
 *
 */
BOOL OpenDoc (VOID)
{
   CHAR        szDoc[cchFilenameMax];
   BOOL        fUpdateLater;
   OLESTATUS   olestatus;

   if (SaveChangesOption (&fUpdateLater) == IDCANCEL)
      return FALSE;

   if (!GetFileOpenFilename (szDoc))
   {
      if (fUpdateLater)
      {
         // The user chose the "Yes, Update" button but the
         // File Open dialog box failed for some reason
         // (perhaps the user chose Cancel).
         // Even though the user chose "Yes, Update", there is no way
         // to update a client that does not accept updates
         // except when the document is closed.
      }
      return FALSE;
   }

   if (fUpdateLater)
   {
      // The non-standard OLE client did not accept the update when
      // we requested it, so we are sending the client OLE_CLOSED now that
      // we are closing the document.
      SendDocMsg (OLE_CLOSED);
   }

   fRevokeSrvrOnSrvrRelease = FALSE;

   if ((olestatus = RevokeDoc()) > OLE_WAIT_FOR_RELEASE)
      return FALSE;
   else if (olestatus == OLE_WAIT_FOR_RELEASE)
      Wait (&fWaitingForDocRelease);

   fRevokeSrvrOnSrvrRelease = TRUE;
   EmbeddingModeOff();

   if (!CreateDocFromFile (szDoc, 0, doctypeFromFile))
   {
      MessageBox (hwndMain,
                  "Reading from file failed.\r\nFile may not be in proper file format.",
                  szAppName,
                  MB_ICONEXCLAMATION | MB_OK);
      // We already revoked the document, so give the user a new one to edit.
      CreateNewDoc (0, "(Untitled)", doctypeNew);
      CreateNewObj (FALSE);
      return FALSE;
   }
   fDocChanged = FALSE;
   return TRUE;
}



/* ReadObj
 * --------
 *
 * Read the next object from a file, allocate memory for it, and return
 * a pointer to it.
 *
 * int fh - File handle
 *
 * RETURNS: A pointer to the object
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
static LPOBJ ReadObj (INT fh)
{
    HANDLE hObj = NULL;
    LPOBJ   lpobj = NULL;

    hObj = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (OBJ));

    if (hObj == NULL)
      return NULL;

    lpobj = (LPOBJ) LocalLock (hObj);

    if (lpobj==NULL)
    {
      LocalFree (hObj);
      return NULL;
    }

    if (_lread(fh, (LPSTR) &lpobj->native, (UINT)sizeof(NATIVE)) < sizeof (NATIVE))
    {
        LocalUnlock (hObj);
        LocalFree (hObj);
        return NULL;
    }

    lpobj->hObj             = hObj;
    lpobj->oleobject.lpvtbl = &objvtbl;
    lpobj->aName            = GlobalAddAtom (lpobj->native.szName);

    if (!CreateWindow(
        "ObjClass",
        "Obj",
        WS_THICKFRAME | WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE ,
        lpobj->native.nX,
        lpobj->native.nY,
        lpobj->native.nWidth,
        lpobj->native.nHeight,
        hwndMain,
        NULL,
        hInst,
        (LPSTR) lpobj ))
    {
        LocalUnlock (hObj);
        LocalFree (hObj);
        return NULL;
    }

    return lpobj;
}



/* SaveDoc
 * -------
 *
 * Save the document.
 *
 * CUSTOMIZATION: None
 *
 */

BOOL SaveDoc (VOID)
{
    if (docMain.doctype == doctypeNew)
        return SaveDocAs();
    else
    {
        CHAR     szDoc [cchFilenameMax];

        GlobalGetAtomName (docMain.aName, szDoc, cchFilenameMax);
        return SaveDocIntoFile(szDoc);
    }
}



/* SaveDocAs
 * ---------
 *
 * Prompt the user for a filename, and save the document under that filename.
 *
 * RETURNS: TRUE if successful or user chose CANCEL
 *          FALSE if SaveDocIntoFile fails
 *
 * CUSTOMIZATION: None
 *
 */
BOOL SaveDocAs (VOID)
{
   CHAR        szDoc[cchFilenameMax];
   BOOL        fUpdateLater;
   CHAR szDocOld[cchFilenameMax];

   // If document is embedded, give user a chance to update.
   // Save old document name in case the save fails.
   if (!GlobalGetAtomName (docMain.aName, szDocOld, cchFilenameMax))
      ErrorBox ("Fatal Error: Document name is invalid.");

   if (GetFileSaveFilename (szDoc))

   {

      if (docMain.doctype == doctypeEmbedded)
         return SaveDocIntoFile(szDoc);

      if (fUpdateLater)
      {
         // The non-standard OLE client did not accept the update when
         // we requested it, so we are sending the client OLE_CLOSED now that
         // we are closing the document.
         SendDocMsg (OLE_CLOSED);
      }

      // Set the window title bar.
      SetTitle (szDoc, FALSE);
      OleRenameServerDoc(docMain.lhdoc, szDoc);

      if (SaveDocIntoFile(szDoc))
         return TRUE;
      else
      {  // Restore old name
         SetTitle (szDocOld, FALSE);
         OleRenameServerDoc(docMain.lhdoc, szDocOld);
         return FALSE;
      }
   }
   else  // user chose Cancel
      return FALSE;
         // The user chose the "Yes, Update" button but the
         // File Open dialog box failed for some reason
         // (perhaps the user chose Cancel).
         // Even though the user chose "Yes, Update", there is no way
         // to update a non-standard OLE client that does not accept updates
         // except when the document is closed.
}



/* SaveDocIntoFile
 * ---------------
 *
 * Save the document into a file whose name is determined from docMain.aName.
 *
 * RETURNS: TRUE if successful
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static BOOL SaveDocIntoFile (PSTR pDoc)
{
    HWND     hwnd;
    INT      fh;    // File handle
    LPOBJ    lpobj;
    HEADER   hdr;
    INT      i;

    hwnd = GetWindow (hwndMain, GW_CHILD);

    if (!hwnd)
    {
        ErrorBox ("Could not save NULL file.");
        return FALSE;
    }

    // Get document name.
    if ((fh =_lcreat(pDoc, 0)) == -1)
    {
        ErrorBox ("Could not save file.");
        return FALSE;
    }

    // Fill in header.
    lstrcpy (hdr.szSig, szSignature);
    hdr.chDelim1 = chDelim;
    hdr.version  = version;
    hdr.chDelim2 = chDelim;
    for (i=1; i <= cfObjNums; i++)
      hdr.rgfObjNums[i] = docMain.rgfObjNums[i];

    // Write header to file.
    if (_lwrite(fh, (LPSTR) &hdr, (UINT)sizeof(HEADER)) < sizeof(HEADER))
         goto Error; // Error writing file header

    // Write each object's native data.
    while (hwnd)
    {
      lpobj = (LPOBJ) GetWindowLong (hwnd, ibLpobj);
      if (_lwrite(fh, (LPSTR)&lpobj->native, (UINT)sizeof (NATIVE))
          < sizeof(NATIVE))
         goto Error; // Error writing file header

      hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    _lclose(fh);


    if (docMain.doctype != doctypeEmbedded)
    {
         docMain.doctype = doctypeFromFile;
         OleSavedServerDoc(docMain.lhdoc);
         fDocChanged = FALSE;
    }

    return TRUE;

Error:
      _lclose(fh);
      ErrorBox ("Could not save file.");
      return FALSE;

}



/* Common Dialog functions */


/* InitOfn
 * -------
 *
 * Initialize an OPENFILENAME structure with default values.
 * OPENFILENAME is defined in CommDlg.h.
 *
 *
 * CUSTOMIZATION: Change lpstrFilter.  You may also customize the common
 *                dialog box if you wish.  (See the Windows SDK documentation.)
 *
 */
static VOID InitOfn (OPENFILENAME *pofn)
{
   // GetOpenFileName or GetSaveFileName will put the 8.3 filename into
   // szFileTitle[].
   // SrvrDemo does not use this filename, but rather uses the fully qualified
   // pathname in pofn->lpstrFile[].
   static CHAR szFileTitle[13];

   pofn->Flags          = 0;
   pofn->hInstance      = hInst;
   pofn->hwndOwner      = hwndMain;
   pofn->lCustData      = 0;
   pofn->lpfnHook       = NULL;
   pofn->lpstrCustomFilter = NULL;
   pofn->lpstrDefExt    = szDefExt;
   // lpstrFile[] is the initial filespec that appears in the edit control.
   // Must be set to non-NULL before calling the common dialog box function.
   // On return, lpstrFile[] will contain the fully-qualified pathname
   // corresponding to the file the user chose.
   pofn->lpstrFile      = NULL;
   pofn->lpstrFilter    = "Server Demo (*." szDefExt ")\0*." szDefExt "\0" ;
   // lpstrFileTitle[] will contain the user's chosen filename without a path.
   pofn->lpstrFileTitle = szFileTitle;
   pofn->lpstrInitialDir= NULL;
   // Title Bar.  NULL means use default title.
   pofn->lpstrTitle     = NULL;
   pofn->lpTemplateName = NULL;
   pofn->lStructSize    = sizeof (OPENFILENAME);
   pofn->nFilterIndex   = 1L;
   pofn->nFileOffset    = 0;
   pofn->nFileExtension = 0;
   pofn->nMaxFile       = cchFilenameMax;
   pofn->nMaxCustFilter = 0L;
}




/* GetFileOpenFilename
 * -------------------
 *
 * Call the common dialog box function GetOpenFileName to get a file name
 * from the user when the user chooses the "File Open" menu item.
 *
 * LPSTR lpszFilename - will contain the fully-qualified pathname on exit.
 *
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: None
 *
 */
BOOL GetFileOpenFilename (LPSTR lpszFilename)
{
   OPENFILENAME ofn;
   InitOfn (&ofn);
   ofn.Flags |= OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
   // Create initial filespec.
   wsprintf (lpszFilename, "*.%s", (LPSTR) szDefExt);
   // Have the common dialog function return the filename in lpszFilename.
   ofn.lpstrFile = lpszFilename;
   if (!GetOpenFileName (&ofn))
      return FALSE;
   return TRUE;
}



/* GetFileSaveFilename
 * -------------------
 *
 * Call the common dialog box function GetSaveFileName to get a file name
 * from the user when the user chooses the "File Save As" menu item, or the
 * "File Save" menu item for an unnamed document.
 *
 * LPSTR lpszFilename - will contain the fully-qualified pathname on exit.
 *
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: None
 *
 */
BOOL GetFileSaveFilename (LPSTR lpszFilename)
{
   OPENFILENAME ofn;
   InitOfn (&ofn);
   ofn.Flags |= OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
   // Create initial filespec.
   wsprintf (lpszFilename, "*.%s", (LPSTR) szDefExt);
   // Have the common dialog function return the filename in lpszFilename.
   ofn.lpstrFile = lpszFilename;
   if (!GetSaveFileName (&ofn))
      return FALSE;
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\clidemo\utility.h ===
/* 
 * utility.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** PROTO TYPES ***

//* FAR  
BOOL FAR          ObjectsBusy(VOID);
VOID FAR          WaitForAllObjects(VOID);
VOID FAR          WaitForObject(APPITEMPTR);
VOID FAR          ErrorMessage(DWORD);
VOID FAR          Hourglass(BOOL);
BOOL FAR          DisplayBusyMessage (APPITEMPTR);
BOOL FAR          Dirty(INT);
LPSTR FAR         CreateNewUniqueName(LPSTR);
BOOL FAR          ValidateName(LPSTR);
BOOL FAR          ProcessMessage(HWND, HANDLE);
VOID FAR          FreeAppItem(APPITEMPTR);
LONG FAR          SizeOfLinkData (LPSTR);
VOID FAR          ShowDoc(LHCLIENTDOC, INT);
APPITEMPTR FAR    GetTopItem(VOID);
VOID FAR          SetTopItem(APPITEMPTR);
APPITEMPTR FAR    GetNextActiveItem(VOID);
APPITEMPTR FAR    GetNextItem(APPITEMPTR);
BOOL FAR          ReallocLinkData(APPITEMPTR,LONG);
BOOL FAR          AllocLinkData(APPITEMPTR,LONG);
VOID FAR          FreeLinkData(LPSTR);
VOID FAR          ShowNewWindow(APPITEMPTR);
PSTR FAR          UnqualifyPath(PSTR);
VOID CALLBACK     fnTimerBlockProc(HWND, UINT, UINT, DWORD);
BOOL FAR          ToggleBlockTimer(BOOL);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\olebind\olebind.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       olebind.cxx
//
//  Contents:   Test OLE COM
//
//  Classes:
//
//  Functions:  TestSetMoniker
//      `       DoTest
//              ConvertPath
//              CreateFile
//              CleanUpFiles
//              InitFiles
//              main
//
//  History:    31-Dec-93   ErikGav    Chicago port
//              15-Nov-94   BruceMa    Added this header
//              15-Nov-94   BruceMa    Make long file name test work on
//                                      Chicago
//              11-Jan-95   BruceMa    Chicago now use the NT alorithm for
//                                      short file names
//              17-Jan-95   BruceMa    Modify registry so olebind works on
//                                      Cairo when running multi-threaded
//
//----------------------------------------------------------------------

#include <windows.h>
#include "widewrap.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>

#include <ole2.h>
#include <com.hxx>
#include "olebind.hxx"
#include "tmoniker.h"
#include <tchar.h>

const char *szOleBindError = "OLEBIND - Fatal Error";
char wszErrBuf[512];

#pragma hdrstop

BOOL SetRegistryThreadingModel(WCHAR *peszFile, WCHAR *pwszThreadingModel);
BOOL ResetRegistryThreadingModel(WCHAR *pwszFile);

#define FILE_SHARE_DELETE               0x00000004

#define INPROC_PATH1 L"p1.ut1"
#define INPROC_PATH2 L"p2.ut1"
#define LOCAL_SERVER_PATH1 L"p1.ut2"
#define LOCAL_SERVER_PATH2 L"p2.ut2"
#define LOCAL_SERVER_PATH4 L"p2.ut4"

WCHAR InprocPath1[MAX_PATH];
WCHAR InprocPath2[MAX_PATH];
WCHAR LocalServerPath1[MAX_PATH];
WCHAR LocalServerPath2[MAX_PATH];
WCHAR LocalServerPath4[MAX_PATH];

#define LONG_SHORT_DIR          L"\\LongDire"
#define LONG_DIR                L"\\LongDirectory"
#define LONG_SHORT_NAME         L"\\Short.Fil"
#define LONG_LONG_NAME          L"\\LongFileName.File"
#define LONG_LONG_SHORT_EQUIV   L"\\LongFi~1.Fil"

WCHAR LongDir[MAX_PATH];
WCHAR LongDirShort[MAX_PATH];
WCHAR LongDirLong[MAX_PATH];
WCHAR LongDirLongSe[MAX_PATH];

// DON"T MODIFY THIS
const DWORD dwRESERVED = 0l;

//  string version of process id
WCHAR wszPid[10];


int TestSetMoniker(IUnknown *punk)
{
    HRESULT	hr;
    XOleObject	poleobject;
    XMoniker	pmk;
    XMalloc	pIMalloc;
    XBindCtx	pbc;


    hr = punk->QueryInterface(IID_IOleObject, (void **) &poleobject);

    // Create an item moniker to the object
    hr = CreateItemMoniker(L"\\", L"1", &pmk);

    TEST_FAILED_HR(FAILED(hr), "TestSetMoniker:CreateItemMoniker failed")

    // Set the moniker
    hr = poleobject->SetMoniker(OLEWHICHMK_CONTAINER, pmk);

    TEST_FAILED_HR(FAILED(hr), "TestSetMoniker:SetMoniker failed")

    pmk.Set(NULL);

    // Get the moniker back
    hr = poleobject->GetMoniker(OLEGETMONIKER_ONLYIFTHERE,
	OLEWHICHMK_CONTAINER, &pmk);

    TEST_FAILED_HR(FAILED(hr), "TestSetMoniker:GetMoniker failed")

    // Get & Verify name is as expected
    WCHAR *pwszName;


    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
	"CreateBindCtx TestSetMoniker:GetDisplayName failed!")

    hr = pmk->GetDisplayName(pbc, NULL, &pwszName);

    TEST_FAILED_HR(FAILED(hr), "TestSetMoniker:GetDisplayName failed")

    TEST_FAILED((wcscmp(pwszName, L"\\1") != 0),
	"TestSetMoniker: Returned name mismatch!\n")

    // Test OleIsRunning
    hr = OleIsRunning(poleobject);

    TEST_FAILED_HR(FAILED(hr), "OleIsRunning call failed")

    // Free resources
    hr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);

    TEST_FAILED_HR(FAILED(hr), "CoGetMalloc failed")

    pIMalloc->Free(pwszName);

    return 0;
}

static GUID CLSID_Invalid =
    {0xfffffffe,0xffff,0xffff,{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}};


//  prototypes for private entry points. These are here to support VB94.
STDAPI	CoGetState(IUnknown **ppUnkState);
STDAPI	CoSetState(IUnknown *pUnkState);

int DoTest(
    GUID guidToTest,
    LPWSTR pszPath1,
    LPWSTR pszPath2)
{
    XMoniker	       pmnk;	       // ptr to moniker
    XUnknown	       pUnk;
    XUnknown	       punk;
    XUnknown	       pUnkTheSame;
    XOleItemContainer  poleitmcon;
    XDispatch	       pdispatch;

    XBindCtx	       pbc1;
    XBindCtx	       pbc2;
    XUnknown	       pUnkState1;
    XUnknown	       pUnkState2;
    XUnknown	       pUnkState3;
    XUnknown	       pUnkState4;
    XUnknown	       pUnkState5;

    HRESULT hr;
    DWORD grfOpt = 0;


    // Test the private CoSetState/CoGetState APIs.  We just need an
    // IUnknown so we will use a BindCtx for this.

    //	test Set/Get
    hr = CreateBindCtx(0, &pbc1);
    TEST_FAILED_HR(FAILED(hr), "Create BindCtx 1 failed");
    hr = pbc1->QueryInterface(IID_IUnknown, (void **)&pUnkState1);
    TEST_FAILED_HR(FAILED(hr), "QI for IUnknown 1 failed.");

    hr = CoSetState(pUnkState1);
    TEST_FAILED_HR(hr != S_OK, "CoSetState failed.");

    hr = CoGetState(&pUnkState2);
    TEST_FAILED_HR(hr != S_OK, "CoGetState failed.");
    if ((IUnknown *)pUnkState2 != (IUnknown *)pUnkState1)
	TEST_FAILED(TRUE, "GetState returned wrong value.\n");


    //	test replacement
    hr = CreateBindCtx(0, &pbc2);
    TEST_FAILED_HR(FAILED(hr), "Create BindCtx 2 failed");
    hr = pbc2->QueryInterface(IID_IUnknown, (void **)&pUnkState3);
    TEST_FAILED_HR(FAILED(hr), "QI for IUnknown 2 failed.");

    hr = CoSetState(pUnkState3);
    TEST_FAILED_HR(hr != S_OK, "CoSetState failed.");

    hr = CoGetState(&pUnkState4);
    TEST_FAILED_HR(hr != S_OK, "CoGetState failed.");
    if ((IUnknown *)pUnkState4 != (IUnknown *)pUnkState3)
	TEST_FAILED(TRUE, "GetState returned wrong value.");


    //	test Set/Get NULL
    hr = CoSetState(NULL);
    TEST_FAILED_HR(hr != S_OK, "CoSetState NULL failed.");

    hr = CoGetState(&pUnkState5);
    TEST_FAILED_HR(hr != S_FALSE, "CoGetState NULL failed.");
    if ((IUnknown *)pUnkState5 != NULL)
	TEST_FAILED(TRUE, "GetState NULL returned wrong value.");




    // Test for a bogus class
    hr = CoGetClassObject(CLSID_Invalid, CLSCTX_SERVER, NULL,
	IID_IClassFactory, (void **) &pUnk);

    TEST_FAILED_HR(SUCCEEDED(hr),
	"CoGetClassObject succeed on invalid class!");

    // Bind to something that does not exist either in the registry
    // or anywhere else.
    hr = CreateFileMoniker(L"C:\\KKK.KKK", &pmnk);
    hr = BindMoniker(pmnk, grfOpt, IID_IUnknown, (void **)&pUnk);
    pmnk.Set(NULL);

    TEST_FAILED_HR(SUCCEEDED(hr),
	"Succeeded binding a moniker to a file that doesn't exist!");

/*
 *  Create a file moniker to start with
 */

    hr = CreateFileMoniker(pszPath1, &pmnk);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker Failed");

    hr = BindMoniker(pmnk, grfOpt, IID_IUnknown, (void **)&pUnk);

    TEST_FAILED_HR(FAILED(hr),
	"BindMoniker to file Failed")

    // Confirm bind to same object produces same object pointer

    hr = BindMoniker(pmnk, grfOpt, IID_IUnknown, (void **)&pUnkTheSame);

    TEST_FAILED_HR(FAILED(hr),
	"BindMoniker to file Failed")
#ifdef NOT_YET
    TEST_FAILED((pUnkTheSame != pUnk), "Object pointers not ==\n")
#endif // NOT_YET
    pUnkTheSame.Set(NULL);
    pmnk.Set(NULL);

/*
 *  OK - we've bound to the IUnknown interface, lets
 *  QueryInterface to something more interesting (for test reasons)
 */
    hr = pUnk->QueryInterface(IID_IOleItemContainer,
	(LPVOID FAR*) &poleitmcon);

    TEST_FAILED_HR(FAILED(hr), "Query Interface Failed")

/*
 *  Make sure we get an error when QI'ing for something the server
 *  does not support.
 */
    hr = pUnk->QueryInterface(IID_IDispatch,
	(LPVOID FAR*) &pdispatch);

    TEST_FAILED_HR(SUCCEEDED(hr),
	"QueryInterface to unsupported interface")

    pdispatch.Set(NULL);
    pUnk.Set(NULL);


/*
 * Call get the class ID using IPersistFile
 */

    hr = poleitmcon->GetObject(L"1", 1, NULL, IID_IUnknown,
	(void **) &punk);

    TEST_FAILED_HR(FAILED(hr), "GetObject Failed")

    TEST_FAILED((punk == NULL),
	"GetObject returned a NULL for punk\n")

    poleitmcon.Set(NULL);

    if (TestSetMoniker(punk))
    {
	return 1;
    }

    hr = punk->QueryInterface(IID_IOleLink, (LPVOID FAR*) &poleitmcon);

    TEST_FAILED_HR(SUCCEEDED(hr),
	"Query Interface to invalid interface succeeded")

    punk.Set(NULL);

    // Do moniker tests:
    if (TestBindCtx())
    {
	return TRUE;
    }

    if (TestROT(guidToTest))
    {
	return TRUE;
    }

    return TestMoniker(pszPath1, pszPath2);
}

// TRUE on failure
BOOL TestPrematureDeath()
{
    XMoniker pmnk;
    XUnknown pUnk;
    HRESULT hr;
    TCHAR   tszFileName[MAX_PATH+1];
    HANDLE hTouchFile;
    SYSTEMTIME st1, st2;
    FILETIME ft1, ft2;
    LONG l;
    DWORD dw;

    ZeroMemory(&st1, sizeof(st1));
    ZeroMemory(&st2, sizeof(st2));

    hr = CreateFileMoniker(LocalServerPath4, &pmnk);
    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker Failed")

    GetSystemDirectory(tszFileName, MAX_PATH+1);
    _tcscat(tszFileName, TEXT("\\failtst.tst"));

    hTouchFile = CreateFileT(tszFileName,
                                   GENERIC_READ|GENERIC_WRITE,
                                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                                   NULL,
                                   OPEN_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);
    if(hTouchFile == INVALID_HANDLE_VALUE)
    {
        wsprintfA(&wszErrBuf[0], "Couldn't open touch file - err = %x.\n", GetLastError());
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        return TRUE;
    }

    GetSystemTime(&st1);
    WriteFile(hTouchFile, &st1, sizeof(st1), &dw, NULL);

    l = GetTickCount();

    // This takes awhile, so tell the user
    printf("SCM dead server test (60 sec) started\n");

    hr = BindMoniker(pmnk, 0, IID_IUnknown, (void **)&pUnk);

    TEST_FAILED_HR((hr != CO_E_SERVER_EXEC_FAILURE),
        "Unexpected hr from BindMoniker in premature death test")

    // Tell the BVT guys
    printf("SCM dead server test succeeded\n");

    //
    // The above bind should have caused fail.exe to execute and write a new
    // time to the file as proof of execution.
    //

    SetFilePointer(hTouchFile, 0, NULL, FILE_BEGIN);
    ReadFile(hTouchFile, &st2, sizeof(st2), &dw, NULL);
    CloseHandle(hTouchFile);

    DeleteFileT(tszFileName);

    SystemTimeToFileTime(&st1, &ft1);
    SystemTimeToFileTime(&st2, &ft2);
    if (0 == CompareFileTime(&ft1, &ft2))
    {
        wsprintfA(&wszErrBuf[0], "Test not configured properly: PROGID50(fail.exe) did not run.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        return TRUE;
    }

    if (GetTickCount() - l > 2*60*1000)
    {
        wsprintfA(&wszErrBuf[0], "Premature death test failed: too long to detect death.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        return TRUE;
    }

    return FALSE;
}

char * ConvertPath(LPWSTR pwsz)
{
    static char szPath[MAX_PATH];
    wcstombs(szPath, pwsz, wcslen(pwsz) + 1);
    return szPath;
}

int CreateFile(LPWSTR pwszPath)
{
    // Try to create the file
    int fh = _creat(ConvertPath(pwszPath), _S_IWRITE|S_IREAD);

    // Did file create fail?
    if (fh != -1)
    {
	// Write some data to file -- makes sure docfile won't delete
	// the file.
	_write(fh, "This is a test file\n", sizeof("This is a test file\n"));

	// No -- then set to success and close the newly created file
	_close(fh);
	fh = 0;
    }

    return fh;
}


void CleanUpFiles(void)
{
    // Delete all the test files.
    remove(ConvertPath(InprocPath1));
    remove(ConvertPath(InprocPath2));
    remove(ConvertPath(LocalServerPath1));
    remove(ConvertPath(LocalServerPath2));
    remove(ConvertPath(LocalServerPath4));
    remove(ConvertPath(LongDirShort));
    remove(ConvertPath(LongDirLong));
#if !defined(_CHICAGO_)
    RemoveDirectory(LongDir);
#else
    RemoveDirectory(ConvertPath(LongDir));
#endif
}

int InitFiles(void)
{
    BOOL fRet;

    TCHAR szCurDir[MAX_PATH];
    TCHAR szTmpLongDir[MAX_PATH];
    WCHAR wcCurDir[MAX_PATH];
    WCHAR wcLong[MAX_PATH], *pwcEnd;

    DWORD cCurDir = GetCurrentDirectory(MAX_PATH, szCurDir);

    #ifdef UNICODE
    wcscpy(wcCurDir, szCurDir);
    #else
    mbstowcs(wcCurDir, szCurDir, MAX_PATH);
    #endif

    // Is the current directory the root of a drive?
    if (wcCurDir[cCurDir - 1] == '\\')
    {
	// We bring the string on char back to take into account
	// the fact the string we will concatenate begins with a slash.
	wcCurDir[cCurDir - 1] = 0;
    }

    //	get the pid. we use the pid to identify the files for a particular
    //	run of the test (so we may run multiple instances simultaneously
    //	without interference).

    DWORD dwPid = GetCurrentProcessId();
    char szPid[9];
    _itoa(dwPid, szPid, 16);
    wszPid[0] = L'\\';
#if defined(_CHICAGO_)
    szPid[4] = '\0';   // This is an all platform bug, but zap for Chicago.
#endif
    mbstowcs(&wszPid[1], szPid, strlen(szPid)+1);

    wcscpy(InprocPath1, wcCurDir);
    wcscat(InprocPath1, wszPid);
    wcscat(InprocPath1, INPROC_PATH1);

    wcscpy(InprocPath2, wcCurDir);
    wcscat(InprocPath2, wszPid);
    wcscat(InprocPath2, INPROC_PATH2);

    wcscpy(LocalServerPath1, wcCurDir);
    wcscat(LocalServerPath1, wszPid);
    wcscat(LocalServerPath1, LOCAL_SERVER_PATH1);

    wcscpy(LocalServerPath2, wcCurDir);
    wcscat(LocalServerPath2, wszPid);
    wcscat(LocalServerPath2, LOCAL_SERVER_PATH2);

    wcscpy(LocalServerPath4, wcCurDir);
    wcscat(LocalServerPath4, wszPid);
    wcscat(LocalServerPath4, LOCAL_SERVER_PATH4);

    wcscpy(wcLong, wcCurDir);
    wcscat(wcLong, LONG_DIR);
    wcscpy(LongDir, wcLong);
    pwcEnd = wcLong+wcslen(wcLong);

    wcscpy(pwcEnd, LONG_SHORT_NAME);
    wcscpy(LongDirShort, wcLong);

    wcscpy(pwcEnd, LONG_LONG_NAME);
    wcscpy(LongDirLong, wcLong);

#ifdef _CHICAGO_
        wcscpy(LongDirLongSe, wcCurDir);
        wcscat(LongDirLongSe, LONG_DIR);

#else
    wcscpy(pwcEnd, LONG_LONG_SHORT_EQUIV);
    wcscpy(LongDirLongSe, wcLong);
#endif // _CHICAGO_

    // Delete any files that exist
    CleanUpFiles();

    // Create a file for each test file needed.
    TEST_FAILED(CreateFile(InprocPath1),
	"Couldn't create first test file!\n");
    TEST_FAILED(CreateFile(InprocPath2),
	"Couldn't create second test file!\n");
    TEST_FAILED(CreateFile(LocalServerPath1),
	"Couldn't create third test file!\n");
    TEST_FAILED(CreateFile(LocalServerPath2),
	"Couldn't create fourth test file!\n");
    TEST_FAILED(CreateFile(LocalServerPath4),
	"Couldn't create fifth test file!\n");

#if !defined(_CHICAGO_)
    fRet = CreateDirectory(LongDir, NULL);
#else
    fRet = CreateDirectory(ConvertPath(LongDir), NULL);
#endif
    TEST_FAILED(!fRet, "Couldn't create long directory\n");
    TEST_FAILED(CreateFile(LongDirShort),
	"Couldn't create short file in long directory\n");
    TEST_FAILED(CreateFile(LongDirLong),
	"Couldn't create long file in long directory\n");

    #ifdef UNICODE
    TEST_FAILED(!GetShortPathName(LongDirLong,
				 LongDirLongSe,
				 sizeof(LongDirLongSe)),
		"Couldn't GetShortPathname of long directory\n");
    #else

    TEST_FAILED(!GetShortPathNameT(ConvertPath(LongDirLong),
				 szCurDir,
				 sizeof(szCurDir)),
		"Couldn't GetShortPathname of long directory\n");

    mbstowcs(LongDirLongSe, szCurDir, strlen(szCurDir)+1);

    #endif

    return 0;
}


DWORD CallCoInitUninit(void *)
{
    // Initialize
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        // Uninitialize
        CoUninitialize();
    }

    // Return value from function. Note that this is not really used because
    // there is a potential race
    return (DWORD) hr;
}

BOOL DoFreeThreadMultiInitTest(void)
{
    //
    // Get an OLE object in another process
    //
    IClassFactory *pIClassFactory;

    HRESULT hr = CoGetClassObject(
        CLSID_AdvBnd,
        CLSCTX_LOCAL_SERVER,
        NULL,
        IID_IClassFactory,
        (void **) &pIClassFactory);

    TEST_FAILED_HR((hr != NOERROR),
        "DoFreeThreadMultiInitTest CoGetClassObject")

    //
    // Create another thread which does a matching call to
    // CoInitialize/Uninitialize and then exits.
    //

    // Create the thread
    DWORD dwIdUnused;

    HANDLE hInitThread = CreateThread(
        NULL,           // Security - none
        0,              // Stack - use the same as the primary thread
        CallCoInitUninit, // Entry point for thread
        NULL,           // Parameter to the thread - not used.
        0,              // Run this thread immediately (if not sooner).
        &dwIdUnused);   // Id of thread - not used.

    // Did the create succeed?
    TEST_FAILED_LAST_ERROR((NULL == hInitThread),
        "DoFreeThreadMultiInitTest CreateThread")

    // Wait for the thread to do its work
    DWORD dwRes = WaitForSingleObject(hInitThread, INFINITE);

    // Did something terrible happen?
    TEST_FAILED_LAST_ERROR((WAIT_FAILED == dwRes),
        "DoFreeThreadMultiInitTest WaitForSingleObject")

    // Get the result from the thread
    BOOL fGetExitCode = GetExitCodeThread(hInitThread, (DWORD *) &hr);

    TEST_FAILED_LAST_ERROR(!fGetExitCode,
        "DoFreeThreadMultiInitTest GetExitCodeThread")

    // Free handles we no longer need
    CloseHandle(hInitThread);

    //
    // Validate the object we originally got is still alive and well.
    //
    IUnknown *punk;

    hr = pIClassFactory->CreateInstance(NULL, IID_IUnknown, (void **) &punk);

    TEST_FAILED_HR((hr != NOERROR),
        "DoFreeThreadMultiInitTest CoGetClassObject")

    // Free the objects we got in this routine.
    pIClassFactory->Release();
    punk->Release();

    return FALSE;
}




//+--------------------------------------------------------------
// Function:    Main
//
// Synopsis:    Executes the BasicBnd test
//
// Effects:     None
//
//
// Returns:     Exits with exit code 0 if success, 1 otherwise
//
// History:     05-Mar-92   Sarahj   Created
//
//---------------------------------------------------------------

int _cdecl main(int argc, char *argv[])
{
    BOOL          fFailed = FALSE;
    HRESULT       hr;

    if (argc > 1)
    {
	if (!strcmp(argv[1], "M"))
	    goto multithreading;
    }

    // BUGBUG: 1-18-95 To be implemented    BruceMa
    // Correlate the platform we're running on and the platform
    // we built for


    // Write thread mode to initialization file.
    fFailed = !WriteProfileString(
                    TEXT("TestSrv"),
                    TEXT("ThreadMode"),
		    TEXT("ApartmentThreaded"));

    if (fFailed)
    {
        wsprintfA(&wszErrBuf[0], "Failed writing TestSrv profile string.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        goto exit_main;
    }

    fFailed = !WriteProfileString(
                    TEXT("OleSrv"),
                    TEXT("ThreadMode"),
		    TEXT("ApartmentThreaded"));

    if (fFailed)
    {
        wsprintfA(&wszErrBuf[0], "Failed writing OleSrv profile string.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        goto exit_main;
    }

    // Set up test files
    fFailed = InitFiles();
    if (fFailed)
    {
	goto exit_main;
    }

    // Test repeated calls to CoInitialize
    hr = CoInitialize(NULL);

    TEST_FAILED_HR(FAILED(hr), "CoInitialize Failed")

    // must be called before any other OLE API
    hr = OleInitialize(NULL);

    TEST_FAILED_HR(FAILED(hr), "OleInitialize Failed")

    // Call CoUnitialize and see how the rest of the program works!
    CoUninitialize();

    // Test stdmalloc
    if (fFailed = TestStdMalloc())
    {
	goto exit_init;
    }

    fFailed =
	DoTest(CLSID_BasicBnd, InprocPath1, InprocPath2);

    if (fFailed)
    {
	printf( "\nOLE failed in Single Threaded Apartment pass.\n" );
	goto exit_init;
    }

    printf("BasicBnd tests succeeded\n");

    fFailed =
	DoTest(CLSID_AdvBnd, LocalServerPath1, LocalServerPath1);

    if (fFailed)
    {
	printf( "\nOLE failed in Single Threaded Apartment pass.\n" );
	goto exit_init;
    }

    printf("AdvBnd tests succeeded\n");

    if (TestPrematureDeath())
    {
	printf("\nOLE failed testing server premature death.\n");
        goto exit_init;
    }

    OleUninitialize();

    CleanUpFiles();

multithreading:

#ifdef MULTI_THREADING
    // Run the whole thing all over again.

    // Write thread mode to initialization file.
    fFailed = !WriteProfileString(
                    TEXT("TestSrv"),
                    TEXT("ThreadMode"),
		    TEXT("ApartmentThreaded"));

    if (fFailed)
    {
	wsprintfA(&wszErrBuf[0], "Failed writing TestSrv profile string.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        goto exit_main;
    }

    fFailed = !WriteProfileString(
                    TEXT("OleSrv"),
                    TEXT("ThreadMode"),
                    TEXT("MultiThreaded"));

    if (fFailed)
    {
	wsprintfA(&wszErrBuf[0], "Failed writing OleSrv profile string.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        goto exit_main;
    }

    // Set up test files
    if (InitFiles())
    {
        fFailed = TRUE;
	goto exit_main;
    }

    // Mark the dll in the registry as "ThreadingdModel: Free"
    if (!SetRegistryThreadingModel(InprocPath1, L"Free"))
    {
        wsprintfA(&wszErrBuf[0], "Failed trying to set reg ThreadingModel.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        goto exit_main;
    }

    // Test repeated calls to CoInitialize
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    TEST_FAILED_HR(FAILED(hr), "CoInitializeEx Multi Threaded Failed")

    // must be called before any other OLE API
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    TEST_FAILED_HR(FAILED(hr), "CoInitializeEx Multi Threaded Failed")

    // Call CoUnitialize and see how the rest of the program works!
    CoUninitialize();

    // Test stdmalloc
    if (fFailed = TestStdMalloc())
    {
	goto exit_init;
    }

    fFailed =
	DoTest(CLSID_BasicBnd, InprocPath1, InprocPath2);
    if (fFailed)
    {
	printf( "\nOLE failed in Multi Threaded Apartment pass.\n" );
	goto exit_init;
    }

    fFailed =
	DoTest(CLSID_AdvBnd, LocalServerPath1, LocalServerPath1);

    if (fFailed)
    {
	printf( "\nOLE failed in Multi Threaded Apartment pass.\n" );
	goto exit_init;
    }

    // Do CoInitialize/Uninitialize on second thread to make sure
    // that other threads initialize/uninitialize do not effect
    // the running of the test.
    if (fFailed = DoFreeThreadMultiInitTest())
    {
	printf( "\nOLE failed in Multi Threaded InitTest.\n" );
        goto exit_init;
    }

#endif // MULTI_THREADING


exit_init:

    CoUninitialize();

    // Remove the dll's threading model registration
    ResetRegistryThreadingModel(InprocPath1);


exit_main:

    CleanUpFiles();

    if (!fFailed)
    {
	printf("\nOLE: PASSED\n");
    }
    else
    {
	printf("\nOLE: FAILED\n");
    }

    return fFailed;
}



//+--------------------------------------------------------
//
//  Function:  SetRegistryThreadingModel
//
//  Algorithm: Set the threading model for the InprocServer32 associated
//             with the file pwszFile tp pwszThreadingModel
//
//  History:   17-Jan-95  BruceMa       Created
//
//---------------------------------------------------------
BOOL SetRegistryThreadingModel(WCHAR *pwszFile, WCHAR *pwszThreadingModel)
{
    DWORD  dwRESERVED = 0;
    WCHAR  wszExt[8];
    HKEY   hKey;
    WCHAR  wszProgId[32];
    DWORD  dwValueType;
    WCHAR  wszCLSID[64];
    HKEY   hClsidKey;
    HKEY   hInproc32Key;
    ULONG  cbValue;


    // Strip the extension off the file name
    int k = wcslen(pwszFile) - 1;
    while (k > 0  &&  pwszFile[k] != L'.')
    {
        k--;
    }
    if (k >= 0  &&  pwszFile[k] == L'.')
    {
        for (int j = 0; pwszFile[k]; j++, k++)
        {
            wszExt[j] = pwszFile[k];
        }
        wszExt[j] = L'\0';
    }
    else
    {
        return FALSE;
    }

    // Open the key for the specified extension
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, wszExt, dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Read the ProgId for the extension
    cbValue = 32;
    if (RegQueryValueEx(hKey, NULL, NULL, &dwValueType,
                        (LPBYTE) wszProgId, &cbValue) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the ProgIdKey
    CloseHandle(hKey);
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, wszProgId, dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Open the associated CLSID key
    if (RegOpenKeyEx(hKey, L"CLSID", dwRESERVED,
                     KEY_READ, &hClsidKey) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Read the CLSID associated with the ProgId
    cbValue = 128;
    if (RegQueryValueEx(hClsidKey, NULL, NULL, &dwValueType,
                        (LPBYTE) wszCLSID, &cbValue) != ERROR_SUCCESS)
    {
        CloseHandle(hClsidKey);
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the HKEY_CLASSES_ROOT\CLSID key
    CloseHandle(hClsidKey);
    CloseHandle(hKey);
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, L"CLSID", dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Open the key to our clsid
    if (RegOpenKeyEx(hKey, wszCLSID, dwRESERVED,
                     KEY_READ, &hClsidKey) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the InprocServer32 key
    CloseHandle(hKey);
    if (RegOpenKeyEx(hClsidKey, L"InprocServer32", dwRESERVED,
                     KEY_SET_VALUE, &hInproc32Key) != ERROR_SUCCESS)
    {
        CloseHandle(hClsidKey);
        return FALSE;
    }

    // Set the threading model for this InprocServer32 key
    CloseHandle(hClsidKey);
    if (RegSetValueEx(hInproc32Key, L"ThreadingModel", dwRESERVED,
                      REG_SZ, (LPBYTE) pwszThreadingModel,
                      (wcslen(pwszThreadingModel)+1) * sizeof(WCHAR))
        != ERROR_SUCCESS)
    {
        CloseHandle(hInproc32Key);
        return FALSE;
    }

    // Close the InprocServer32 key and return success
    CloseHandle(hInproc32Key);
    return TRUE;
}









//+--------------------------------------------------------
//
//  Function:  ResetRegistryThreadingModel
//
//  Algorithm: Remove the threading model for the InprocServer32 associated
//             with the file pwszFile
//
//  History:   17-Jan-95  BruceMa       Created
//
//---------------------------------------------------------
BOOL ResetRegistryThreadingModel(WCHAR *pwszFile)
{
    DWORD  dwRESERVED = 0;
    WCHAR  wszExt[8];
    HKEY   hKey;
    WCHAR  wszProgId[32];
    DWORD  dwValueType;
    WCHAR  wszCLSID[64];
    HKEY   hClsidKey;
    HKEY   hInproc32Key;
    ULONG  cbValue;


    // Strip the extension off the file name
    int k = wcslen(pwszFile) - 1;
    while (k > 0  &&  pwszFile[k] != L'.')
    {
        k--;
    }
    if (k >= 0  &&  pwszFile[k] == L'.')
    {
        for (int j = 0; pwszFile[k]; j++, k++)
        {
            wszExt[j] = pwszFile[k];
        }
        wszExt[j] = L'\0';
    }
    else
    {
        return FALSE;
    }

    // Open the key for the specified extension
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, wszExt, dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Read the ProgId for the extension
    cbValue = 32;
    if (RegQueryValueEx(hKey, NULL, NULL, &dwValueType,
                        (LPBYTE) wszProgId, &cbValue) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the ProgIdKey
    CloseHandle(hKey);
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, wszProgId, dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Open the associated CLSID key
    if (RegOpenKeyEx(hKey, L"CLSID", dwRESERVED,
                     KEY_READ, &hClsidKey) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Read the CLSID associated with the ProgId
    cbValue = 128;
    if (RegQueryValueEx(hClsidKey, NULL, NULL, &dwValueType,
                        (LPBYTE) wszCLSID, &cbValue) != ERROR_SUCCESS)
    {
        CloseHandle(hClsidKey);
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the HKEY_CLASSES_ROOT\CLSID key
    CloseHandle(hClsidKey);
    CloseHandle(hKey);
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, L"CLSID", dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Open the key to our clsid
    if (RegOpenKeyEx(hKey, wszCLSID, dwRESERVED,
                     KEY_READ, &hClsidKey) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the InprocServer32 key
    CloseHandle(hKey);
    if (RegOpenKeyEx(hClsidKey, L"InprocServer32", dwRESERVED,
                     KEY_SET_VALUE, &hInproc32Key) != ERROR_SUCCESS)
    {
        CloseHandle(hClsidKey);
        return FALSE;
    }

    // Reset the threading model for this InprocServer32 key
    CloseHandle(hClsidKey);
    if (RegDeleteValue(hInproc32Key, TEXT("ThreadingModel")) != ERROR_SUCCESS)
    {
        CloseHandle(hInproc32Key);
        return FALSE;
    }

    // Close the InprocServer32 key and return success
    CloseHandle(hInproc32Key);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\srvrdemo\srvrdemo.c ===
/*                     
  OLE SERVER DEMO
  SrvrDemo.c                                               
                                                                         
  This file contains the window handlers, and various initialization and
  utility functions.
                                                                         
  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved        
*/


#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"

/* Global variable definitions */

HWND   hwndMain = 0;

// Used in converting units from pixels to Himetric and vice-versa
int    giXppli = 0;       // pixels per logical inch along width
int    giYppli = 0;       // pixels per logical inch along height 



// Since this is a not an MDI app, there can be only one server and one doc.
SRVR   srvrMain;
DOC    docMain;
CHAR   szClient[cchFilenameMax];
CHAR   szClientDoc[cchFilenameMax];

// Has the user made changes to the document? 
BOOL   fDocChanged = FALSE;

// Is this the first instance of this application currently running? 
BOOL   fFirstInstance = TRUE;

// This flag is used when OleRevokeServerDoc returns OLE_WAIT_FOR_RELEASE,
// and we must wait until DocRelease is called.
BOOL   fWaitingForDocRelease = FALSE;

// This flag is used when OleRevokeServer returns OLE_WAIT_FOR_RELEASE,
// and we must wait until SrvrRelease is called.
BOOL   fWaitingForSrvrRelease = FALSE;

// This flag is set to TRUE after an application has called OleBlockServer
// and now wishes to unblock the queued messages.  See WinMain.
// Server Demo never sets fUnblock to TRUE because it never calls 
// OleBlockServer.
BOOL fUnblock = FALSE;

// Set this to FALSE if you want to guarantee that the server will not revoke
// itself when SrvrRelease is called.  This is used in the IDM_NEW case and
// the IDM_OPEN case (in OpenDoc).
BOOL fRevokeSrvrOnSrvrRelease = TRUE;

// Version number, which is stored in the native data.
VERSION version = 1;

HBRUSH hbrColor[chbrMax];

// Clipboard formats
OLECLIPFORMAT cfObjectLink;
OLECLIPFORMAT cfOwnerLink;
OLECLIPFORMAT cfNative;

// Method tables.
OLESERVERDOCVTBL docvtbl;
OLEOBJECTVTBL    objvtbl;
OLESERVERVTBL    srvrvtbl;

HANDLE hInst;
HANDLE hAccelTable;
HMENU  hMainMenu = NULL;

// Window dimensions saved in private profile.
static struct
{
   INT nX;
   INT nY;
   INT nWidth;
   INT nHeight;
} dimsSaved, dimsCurrent;


static enum
{
   // Corresponds to the order of the menus in the .rc file.
   menuposFile,
   menuposEdit,
   menuposColor,
   menuposObject
};               


// Static functions.
static VOID  DeleteInstance (VOID);
static BOOL  ExitApplication (BOOL);
static VOID  GetWord (LPSTR *plpszSrc, LPSTR lpszDst);
static BOOL  InitApplication( HANDLE hInstance);
static BOOL  InitInstance (HANDLE hInstance);
static BOOL  ProcessCmdLine (LPSTR,HWND);
static VOID  SaveDimensions (VOID);
static VOID  SkipBlanks (LPSTR *plpsz);
static VOID  UpdateObjMenus (VOID);
static BOOL  FailedUpdate(HWND);

/* WinMain
 * -------
 *
 * Standard windows entry point
 *
 * CUSTOMIZATION: None
 *
 */
int APIENTRY WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPSTR  lpCmdLine,
   INT    nCmdShow  
){
    MSG    msg;

    if (!InitApplication(hInstance))
      return FALSE;

    msg.wParam = FALSE;
    
    if (!InitInstance(hInstance))
        goto errRtn;

    if (!InitServer (hwndMain, hInstance))
        goto errRtn;

    if (!ProcessCmdLine(lpCmdLine,hwndMain))
    {
        ExitApplication(FALSE);
        goto errRtn;
    }

    for (;;)
    {
         // Your application should set fUnblock to TRUE when it decides
         // to unblock.
         if (fUnblock)
         {
            BOOL fMoreMsgs = TRUE;
            while (fMoreMsgs)
            {
				if (srvrMain.lhsrvr == 0)
               OleUnblockServer (srvrMain.lhsrvr, &fMoreMsgs);
            }
            // We have taken care of all the messages in the OLE queue
            fUnblock = FALSE;
         }
      
         if (!GetMessage(&msg, NULL, 0, 0)) 
            break;
         if( !TranslateAccelerator(hwndMain, hAccelTable, &msg)) 
         {
               TranslateMessage(&msg);
               DispatchMessage(&msg); 
         }
    }

    
errRtn:

    DeleteInstance ();
    return (msg.wParam);
}



/* InitApplication
 * ---------------
 *
 * Initialize the application - register the window classes
 *
 * HANDLE hInstance
 * 
 * RETURNS: TRUE if classes are properly registered.
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static BOOL InitApplication( HANDLE hInstance )
{
    WNDCLASS  wc;

    wc.lpszClassName = "MainClass";
    wc.lpfnWndProc   = MainWndProc;
    wc.style         = 0;
    wc.cbClsExtra    = 4;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(hInstance, "DocIcon");
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  = "MainMenu";

    if (!RegisterClass(&wc))
        return FALSE;

    wc.lpszClassName = "ObjClass";
    wc.lpfnWndProc   = ObjWndProc;
    wc.hIcon         = NULL;
    wc.cbWndExtra    = cbWindExtra;
    wc.lpszMenuName  = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_CROSS);

    if (!RegisterClass(&wc))
        return FALSE;

    return TRUE;
}



/* InitInstance
 * ------------
 *
 * Create brushes used by the program, the main window, and 
 * do any other per-instance initialization.
 *
 * HANDLE hInstance
 * 
 * RETURNS: TRUE if successful 
 *          FALSE otherwise.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static BOOL InitInstance (HANDLE hInstance)
{
    LONG rglColor [chbrMax] = 
    {
      0x000000ff,  // Red
      0x0000ff00,  // Green
      0x00ff0000,  // Blue
      0x00ffffff,  // White
      0x00808080,  // Gray
      0x00ffff00,  // Cyan
      0x00ff00ff,  // Magenta
      0x0000ffff   // Yellow
    };


    INT iColor;
	 HDC hDC ;
    
    hInst = hInstance;

    // Initialize the method tables.
    InitVTbls ();

    // Initialize the brushes used.
    for (iColor = 0; iColor < chbrMax; iColor++)
      hbrColor[iColor] = CreateSolidBrush (rglColor[iColor]);

    // Register clipboard formats.
    cfObjectLink= RegisterClipboardFormat ("ObjectLink");
    cfOwnerLink = RegisterClipboardFormat ("OwnerLink");
    cfNative    = RegisterClipboardFormat ("Native");

    hAccelTable = LoadAccelerators(hInst, "Accelerators");
//    hMainMenu   = LoadMenu(hInst, "MainMenu");


    hwndMain = CreateWindow(
        "MainClass",
        szAppName,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        3*OBJECT_WIDTH, 3*OBJECT_HEIGHT,
        NULL,
        NULL,
        hInstance,
        NULL
    );


    if (!hwndMain)
        return FALSE;

    szClient[0] = '\0';
    lstrcpy (szClientDoc, "Client Document");
    
    // Initialize global variables with LOGPIXELSX and LOGPIXELSY
        
    hDC    = GetDC (NULL);       // Get the hDC of the desktop window
    giXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    giYppli = GetDeviceCaps (hDC, LOGPIXELSY);
    ReleaseDC (NULL, hDC);
	 
        
    return TRUE;

}



/* DeleteInstance
 * --------------
 *
 * Deallocate the VTables, and the brushes created for this instance
 *
 *
 * CUSTOMIZATION: The call to FreeVTbls must remain.
 *
 */
static VOID DeleteInstance (VOID)
{
    INT i;

    for (i = 0; i < chbrMax; i++)
        DeleteObject (hbrColor[i]);

}



/* ExitApplication
 * ---------------
 *
 * Handles the WM_CLOSE and WM_COMMAND/IDM_EXIT messages.
 *
 * RETURNS: TRUE if application should really terminate
 *          FALSE if not
 *
 *
 * CUSTOMIZATION: None
 *
 */
static BOOL ExitApplication (BOOL fUpdateLater)
{

   if (fUpdateLater)
   {
      // The non-standard OLE client did not accept the update
      // when we requested it, so we are sending the client 
      // OLE_CLOSED now that we are closing the document.
      SendDocMsg (OLE_CLOSED);
   }

   if (StartRevokingServer() == OLE_WAIT_FOR_RELEASE)
      Wait (&fWaitingForSrvrRelease);
   /* SrvrRelease will not necessarily post a WM_QUIT message.
      If the document is not embedded, SrvrRelease by itself does
      not cause the application to terminate.  But now we want it to.
   */
   if (docMain.doctype != doctypeEmbedded)
      PostQuitMessage(0);
   SaveDimensions();
   return TRUE;
}



/* MainWndProc
 * -----------
 *
 * Main window message handler.
 *
 *
 * CUSTOMIZATION: Remove the color menu and the object menu entirely.  
 *                Add handlers for your application's menu items and any 
 *                Windows messages your application needs to handle.  
 *                The handlers for the menu items that involve OLE
 *                can be added to, but no logic should be removed.
 *                    
 *
 */
LONG  APIENTRY MainWndProc
   (HWND hwnd, UINT message, WPARAM wParam, LONG lParam )
{
    LPOBJ     lpobj;

    switch (message) 
    {
        case WM_COMMAND:
        {
            WORD wID = LOWORD(wParam);

            if (fWaitingForDocRelease)
            {
               ErrorBox ("Waiting for a document to be revoked.\n\rPlease wait.");
               return 0;
            }

            switch (wID) 
            {
               case IDM_EXIT:
                  SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                  break;

               case IDM_ABOUT:
                  DialogBox(hInst, "AboutBox", hwnd, About);
                  break;
   
               case IDM_NEW:
               {
                  BOOL fUpdateLater;
                  OLESTATUS olestatus;

                  if (SaveChangesOption (&fUpdateLater) == IDCANCEL)
                     break;
                  else if (fUpdateLater)
                     SendDocMsg (OLE_CLOSED);

                  // We want to revoke the doc but not the server, so if
                  // SrvrRelease is called, do not revoke server.
                  fRevokeSrvrOnSrvrRelease = FALSE;

                  if ((olestatus = RevokeDoc()) > OLE_WAIT_FOR_RELEASE) 
                  {   
                     ErrorBox ("Serious Error: Cannot revoke document.");
                     break;
                  }
                  else if (olestatus == OLE_WAIT_FOR_RELEASE)
                     Wait (&fWaitingForDocRelease);
  
                  fRevokeSrvrOnSrvrRelease = TRUE;

                  if (!CreateNewDoc (0, "(Untitled)", doctypeNew))
                  {
                     ErrorBox ("Serious Error: Cannot create new document.");
                     break;
                  }
                  // Your application need not create a default object.
                  CreateNewObj (FALSE);
                  EmbeddingModeOff();
                  break;
               }
               case IDM_OPEN:
                  OpenDoc();
                  UpdateObjMenus();
                  break;

               case IDM_SAVE:
                  SaveDoc();
                  break;

               case IDM_SAVEAS:
                  if (!SaveDocAs ())
                     break;
                  if (docMain.doctype != doctypeEmbedded)
                     EmbeddingModeOff();
                  break;

               case IDM_UPDATE:
                  switch (OleSavedServerDoc (docMain.lhdoc))
                  {
                     case OLE_ERROR_CANT_UPDATE_CLIENT:
                        if (!FailedUpdate(hwnd))
                           ExitApplication(TRUE);
                        break;
                     case OLE_OK:
                        break;
                     default:
                        ErrorBox ("Serious Error: Cannot update.");
                  }
                  break;

               /* Color menu */

               case IDM_RED:
               case IDM_GREEN:
               case IDM_BLUE:
               case IDM_WHITE:
               case IDM_GRAY:
               case IDM_CYAN:
               case IDM_MAGENTA:
               case IDM_YELLOW:
                  lpobj = SelectedObject();
                  lpobj->native.idmColor = wID;
                  // Recolor the object on the screen.
                  InvalidateRect (lpobj->hwnd, (LPRECT)NULL,  TRUE);
                  UpdateWindow (lpobj->hwnd);
                  fDocChanged = TRUE;
                  if (docMain.doctype == doctypeFromFile)
                     // If object is linked, update it in client now. 
                     SendObjMsg (lpobj, OLE_CHANGED);
                  break;

               /* Edit menu */

               case IDM_COPY:
                  CutOrCopyObj (TRUE);
                  break;

               case IDM_CUT:
                  CutOrCopyObj (FALSE);
                  // Fall through.

               case IDM_DELETE:
                  RevokeObj (SelectedObject());
                  DestroyWindow (SelectedObjectWindow());
                  UpdateObjMenus();
                  break;

               /* Object menu */

               case IDM_NEXTOBJ:
                  lpobj = SelectedObject();
                  /* The 1 in the second parameter puts the current window
                     at the bottom of the current window list. */
                  SetWindowPos(lpobj->hwnd, (HANDLE)1, 0,0,0,0,
                              SWP_NOMOVE | SWP_NOSIZE);
                  break;

               case IDM_NEWOBJ:
                  lpobj = CreateNewObj (TRUE);
                  BringWindowToTop(lpobj->hwnd);
                  break;

               default:
                  ErrorBox ("Unknown Command.");
                  break;
            }         
            break;
         }

        case WM_NCCALCSIZE:
            if (!IsIconic(hwnd) && !IsZoomed(hwnd))
            {
                dimsCurrent.nX = ((LPRECT)lParam)->left;
                dimsCurrent.nWidth = ((LPRECT)lParam)->right - dimsCurrent.nX;
                dimsCurrent.nY = ((LPRECT)lParam)->top;
                dimsCurrent.nHeight = ((LPRECT)lParam)->bottom - dimsCurrent.nY;
            }
            return DefWindowProc(hwnd, message, wParam, lParam);
            break;

        case WM_QUERYENDSESSION:
        {
            BOOL fUpdateLater;

            if (SaveChangesOption(&fUpdateLater) == IDCANCEL)
               return FALSE;

            if (fUpdateLater)
            {
               // The non-standard OLE client did not accept the update
               // when we requested it, so we are sending the client 
               // OLE_CLOSED now that we are closing the document.
               SendDocMsg (OLE_CLOSED);
            }                          
            return TRUE;
        }

        case WM_CLOSE:
         {
            BOOL fUpdateLater;

            if (SaveChangesOption(&fUpdateLater) != IDCANCEL)
               ExitApplication(fUpdateLater);
            break;
         }

        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}



/* About
 * -----
 *
 * "About Box" dialog handler.
 *
 * CUSTOMIZATION: None
 *
 */
INT_PTR CALLBACK About (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) 
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
        {
            WORD wID = LOWORD(wParam);

            if (wID == IDOK || wID == IDCANCEL) 
            {
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
        }
    }
    return FALSE;
}




/* ObjWndProc
 * ----------
 *
 * Message handler for the object windows.
 *
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
LONG  APIENTRY ObjWndProc 
   (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static BOOL    fCapture = FALSE;
    static struct  {RECT rect; POINT pt;} drag;
    static RECT    rectMain;

    switch (message) 
    {
        case WM_CREATE:
        {
            LPOBJ          lpobj;
            LPCREATESTRUCT lpcs;
            // The call to CreateWindow puts lpobj into lpCreateParams
            lpcs = (LPCREATESTRUCT) lParam;
            lpobj = (LPOBJ) lpcs->lpCreateParams;
            // Associate the window just created with the object.
            lpobj->hwnd = hwnd;
            /* Store pointer to object in the window structure. */
            SetWindowLong(hwnd, ibLpobj, (LONG) lpobj);
            UpdateObjMenus ();
            break;
        }
        case WM_SIZE:
        {
            RECT rect;
            if (fWaitingForDocRelease)
            {   
               ErrorBox ("Waiting for a document to be revoked.\n\rPlease wait.");
               return 0;
            }
            // Get coordinates of object relative to main window's client area.
            GetWindowRect (hwnd, (LPRECT)&rect);
            ScreenToClient (hwndMain, (LPPOINT)&rect);
            ScreenToClient (hwndMain, (LPPOINT)&rect.right);
            SizeObj (hwnd, rect, TRUE);
            // Fall through.
        }
        case WM_PAINT:
            PaintObj (hwnd);
            break;

        case WM_LBUTTONDOWN:
            if (fWaitingForDocRelease)
            {   
               ErrorBox ("Waiting for a document to be revoked.\n\rPlease wait.");
               return 0;
            }
            BringWindowToTop (hwnd);

            GetWindowRect (hwnd, (LPRECT) &drag.rect);
            ScreenToClient (hwndMain, (LPPOINT)&drag.rect.left);
            ScreenToClient (hwndMain, (LPPOINT)&drag.rect.right);

            drag.pt.x = LOWORD(lParam);
            drag.pt.y = HIWORD(lParam);

            // Convert drag.pt to the main window's client coordinates.
            ClientToScreen (hwnd, (LPPOINT)&drag.pt);
            ScreenToClient (hwndMain, (LPPOINT)&drag.pt);

            // Remember the coordinates of the main window so we do not drag
            // an object outside the main window.
            GetClientRect (hwndMain, (LPRECT) &rectMain);

            SetCapture (hwnd);
            fCapture = TRUE;
            break;

        case WM_MOUSEMOVE:
        {
            HDC   hdc;
            POINT pt;

            if (!fCapture)
                break;

            fDocChanged = TRUE;
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);

            // Convert pt to the main window's client coordinates.
            ClientToScreen (hwnd, (LPPOINT)&pt);
            ScreenToClient (hwndMain, (LPPOINT)&pt);

            if (!PtInRect (&rectMain, pt))
               break;

            hdc = GetDC(hwndMain);

            // Erase old drag rectangle
            InvertRect (hdc, (LPRECT)&drag.rect);
                  
            // Update drag.rect
            OffsetRect (&drag.rect, pt.x - drag.pt.x, pt.y - drag.pt.y);

            // Update drag.pt
            drag.pt.x = pt.x;
            drag.pt.y = pt.y;

            // Show new drag rectangle
            InvertRect (hdc, (LPRECT)&drag.rect);
            ReleaseDC (hwndMain, hdc);
            break;
        }

        case WM_LBUTTONUP:
        {
            LPOBJ          lpobj;
            if (!fCapture)
                return TRUE;

            fCapture = FALSE;
            ReleaseCapture ();

            MoveWindow (hwnd, drag.rect.left, drag.rect.top,
                        drag.rect.right - drag.rect.left,
                        drag.rect.bottom - drag.rect.top, TRUE);
            InvalidateRect (hwnd, (LPRECT)NULL, TRUE);
            lpobj = HwndToLpobj (hwnd);
            lpobj->native.nX = drag.rect.left;
            lpobj->native.nY = drag.rect.top;
            break;
        }
        case WM_DESTROY:
            DestroyObj (hwnd);
            return DefWindowProc(hwnd, message, wParam, lParam);

        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}



/* DeviceToHiMetric
 * ----------------
 *
 * Converts a point from device units to HiMetric units.
 * This function is designed to be generic enough to be reused.
 *
 * HWND hwnd    - The window whose display context is to be used
 * LPPOINT lppt - The point to be converted.
 *
 * CUSTOMIZATION: None
 *
 */
void DeviceToHiMetric ( LPPOINT lppt)
{
    lppt->x = MulDiv (lppt->x, HIMETRIC_PER_INCH, giXppli);
    lppt->y = MulDiv (lppt->y, HIMETRIC_PER_INCH, giYppli);
}


/* UpdateFileMenu
 * --------------
 *
 * Updates the "Update <Client doc>" and "Exit & Return to <Client doc>" 
 * with the currently set client document name
 *
 * CUSTOMIZATION: Re-implement
 *
 */
VOID UpdateFileMenu (INT iSaveUpdateId)
{
    CHAR    str[cchFilenameMax];
    HMENU   hMenu = GetMenu(hwndMain);    

    /* Change File menu so it contains "Update" instead of "Save". */
    
    lstrcpy (str, "&Update ");
    lstrcat (str, szClientDoc);
    ModifyMenu(hMenu, iSaveUpdateId, MF_BYCOMMAND|MF_STRING, IDM_UPDATE, str);
    
    /* Change File menu so it contains "Exit & Return to <client doc>" */
    /* instead of just "Exit" */
    
    lstrcpy (str, "E&xit && Return to ");
    lstrcat (str, szClientDoc);
    ModifyMenu(hMenu, IDM_EXIT, MF_BYCOMMAND|MF_STRING, IDM_EXIT, str);
}



/* EmbeddingModeOn
 * ---------------
 *
 * Do whatever is necessary for the application to start "embedding mode."
 *
 * CUSTOMIZATION: Re-implement
 *
 */
VOID EmbeddingModeOn(VOID) 
{
    HMENU hMenu = GetMenu(hwndMain);

    UpdateFileMenu (IDM_SAVE);

    /* Change File menu so it contains "Save Copy As..." instead of */
    /* "Save As..." */
    ModifyMenu(hMenu, IDM_SAVEAS, MF_BYCOMMAND|MF_STRING, IDM_SAVEAS, 
        "Save Copy As..");
    
    /* In embedded mode, the user can edit only the embedded object, not
       create new ones. */
    EnableMenuItem(hMenu, menuposObject, MF_BYPOSITION | MF_GRAYED);
    EnableMenuItem(hMenu, IDM_CUT,     MF_BYCOMMAND | MF_GRAYED);
    EnableMenuItem(hMenu, IDM_DELETE,  MF_BYCOMMAND | MF_GRAYED);
    DrawMenuBar (hwndMain);
}




/* EmbeddingModeOff
 * ----------------
 *
 * Do whatever is necessary for the application to end "embedding mode."
 *
 * CUSTOMIZATION: Re-implement
 *
 */
VOID EmbeddingModeOff (VOID) 
{
    HMENU hMenu = GetMenu(hwndMain);

    /* Change File menu so it contains "Save" instead of "Update". */
    ModifyMenu(hMenu, IDM_UPDATE, MF_BYCOMMAND | MF_STRING, IDM_SAVE, "&Save");
    /* Change File menu so it contains "Exit & Return to <client doc>" */
    /* instead of just "Exit" */
    ModifyMenu(hMenu, IDM_EXIT, MF_BYCOMMAND | MF_STRING, IDM_EXIT, "E&xit");

    /* Change File menu so it contains "Save As..." instead of */
    /* "Save Copy As..." */
    ModifyMenu(hMenu, IDM_SAVEAS, MF_BYCOMMAND|MF_STRING, IDM_SAVEAS, 
        "Save &As..");
    
    /* In non-embedded mode, the user can create new objects. */
    EnableMenuItem(hMenu, menuposObject, MF_BYPOSITION | MF_ENABLED);
    
    lstrcpy (szClientDoc, "Client Document");
    DrawMenuBar (hwndMain);
}



/* ErrorBox
 * --------
 *
 * char *szMessage - String to display inside message box.
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
VOID ErrorBox (CHAR *szMessage)
{
   MessageBox (hwndMain, szMessage, szAppName, MB_OK);
}



/* GetWord
 * -------
 *
 * LPSTR *plpszSrc - Pointer to a pointer to a source string
 * LPSTR lpszDst   - Pointer to destination buffer
 *
 * Will copy one space-terminated or null-terminated word from the source
 * string to the destination buffer.
 * When done, *plpszSrc will point to the character after the word. 
 * 
 * CUSTOMIZATION: Server Demo specific
 *
 */
static VOID GetWord (LPSTR *plpszSrc, LPSTR lpszDst)
{
   INT i = 0;
   while (**plpszSrc && **plpszSrc != ' ')
   {
         lpszDst[i++] = *(*plpszSrc)++;
   }
   lpszDst[i] = '\0';
}



/* HiMetricToDevice 
 * ----------------
 *
 * Converts a point from HiMetric units to device units.
 * This function is designed to be generic enough to be reused.
 *
 * HWND hwnd    - The window whose display context is to be used
 * LPPOINT lppt - The point to be converted.
 *
 * CUSTOMIZATION: None
 *
 */
void HiMetricToDevice ( LPPOINT lppt )
{
    lppt->x = MulDiv (giXppli, lppt->x, HIMETRIC_PER_INCH);
    lppt->y = MulDiv (giYppli, lppt->y, HIMETRIC_PER_INCH);
}



/* HwndToLpobj
 * -----------
 *
 * Given an object's window, return a pointer to the object.
 * The GetWindowLong call extracts an LPOBJ from the extra data stored with
 * the window.
 *
 * HWND hwndObj - Handle to the object's window
 *
 * RETURNS: A pointer to the object
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
LPOBJ HwndToLpobj (HWND hwndObj)
{
   return (LPOBJ) GetWindowLong (hwndObj, ibLpobj);
}



/* CreateUntitledDoc
 * -----------------
 *
 * Create a fresh document with one object.
 *
 * RETURNS: TRUE if successful
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement 
 *
 */
static BOOL CreateUntitledDoc (INT nCmdShow)
{
      if (!CreateNewDoc (0, "(Untitled)", doctypeNew))
         return FALSE;
      CreateNewObj (FALSE);
      ShowWindow(hwndMain, nCmdShow);
      UpdateWindow(hwndMain);
      return TRUE;
}


/* ProcessCmdLine
 * --------------
 *
 * Parses the Windows command line which was passed to WinMain.
 *
 * Case One: SrvrDemo.exe 
 *   fEmbedding = FALSE
 *   Create an untitled document.
 *
 * Case two: SrvrDemo.exe filename
 *   fEmbedding = FALSE
 *   Create a new document from the file.
 *
 * Case three: SrvrDemo.exe -Embedding
 *   fEmbedding = TRUE
 *   Do not create or register a document.
 *   Do not show window until client requests it.
 * 
 * Case four: SrvrDemo.exe -Embedding filename
 *   fEmbedding = TRUE
 *   Load file.
 *   Call OleRegisterServerDoc.
 *   Do not show window until client requests it.
 *
 * 
 * LPSTR lpszLine - The Windows command line
 * int nCmdShow   - Parameter to WinMain
 * HWND hwndMain  - The application's main window
 * 
 * RETURNS: TRUE  if the command line was processed correctly.
 *          FALSE if a filename was specified which did not
 *                contain a proper document.
 *
 * CUSTOMIZATION: None.
 *
 */
 
static BOOL ProcessCmdLine (LPSTR lpszLine, HWND hwndMain)
{
   CHAR     szBuf[cchFilenameMax];
   BOOL     fEmbedding = FALSE;  // Is "-Embedding" on the command line?
   INT      i=0;
   OFSTRUCT of;
        
   if (!*lpszLine)    // No filename or options, so start a fresh document.
   {
      return CreateUntitledDoc(SW_SHOWNORMAL);
   }
    
   SkipBlanks (&lpszLine);

   // Check for "-Embedding" or "/Embedding" and set fEmbedding.
   if(*lpszLine == '-' || *lpszLine == '/')
   {
      lpszLine++;
      GetWord (&lpszLine, szBuf);
      fEmbedding = !lstrcmp(szBuf, szEmbeddingFlag);
   }

   SkipBlanks (&lpszLine);

   if (*lpszLine) // if there is a filename
   {
      // Put filename into szBuf.
      GetWord (&lpszLine, szBuf);

      if (-1 == OpenFile(szBuf, &of, OF_READ | OF_EXIST))
      {
         // File not found
         if (fEmbedding)
            return FALSE;       
         else
         {
            CHAR sz[100];
            wsprintf (sz, "File %s not found.", (LPSTR) szBuf);
            ErrorBox (sz);
            return CreateUntitledDoc(SW_SHOWNORMAL);
         }
      }

      if (!CreateDocFromFile (szBuf, 0, doctypeFromFile))
      {
         // File not in proper format.
         if (fEmbedding)
            return FALSE;       
         else
         {
            CHAR sz[100];
            wsprintf (sz, "File %s not in proper format.", (LPSTR) szBuf);
            ErrorBox (sz);
            return CreateUntitledDoc(SW_SHOWNORMAL);
         }
      }
   }

   if (fEmbedding)
   {
      /* Do not show window until told to do so by client. */
      ShowWindow(hwndMain, SW_HIDE);
   }
   else
   {
      ShowWindow(hwndMain, SW_SHOWNORMAL);
      UpdateWindow(hwndMain);
   }
   return TRUE;
}



/* SaveDimensions
 * --------------
 *
 * Save the dimensions of the main window in a private profile file.
 *
 * CUSTOMIZATION: This function may be removed.  If you wish to support
 *                intelligent window placement, then the only necessary
 *                change is to change the string "SrvrDemo.Ini" to a filename
 *                appropriate for your application.
 */
static VOID SaveDimensions (VOID)
{
   if ((dimsCurrent.nX != dimsSaved.nX) || 
         (dimsCurrent.nY != dimsSaved.nY) ||
         (dimsCurrent.nWidth != dimsSaved.nWidth) || 
         (dimsCurrent.nHeight != dimsSaved.nHeight) )
   {
         // Save current window dimensions to private profile.
         CHAR szBuf[7];
         wsprintf (szBuf, "%d", dimsCurrent.nX);
         WritePrivateProfileString
         (szAppName, "x", szBuf, "SrvrDemo.Ini");
         wsprintf (szBuf, "%d", dimsCurrent.nY);
         WritePrivateProfileString
         (szAppName, "y", szBuf, "SrvrDemo.Ini");
         wsprintf (szBuf, "%d", dimsCurrent.nWidth);
         WritePrivateProfileString
         (szAppName, "w", szBuf, "SrvrDemo.Ini");
         wsprintf (szBuf, "%d", dimsCurrent.nHeight);
         WritePrivateProfileString
         (szAppName, "h", szBuf, "SrvrDemo.Ini");
   }
}



/* SelectedObject
 * --------------
 *
 * Return a pointer to the currently selected object.
 *
 * CUSTOMIZATION: What a "selected object" is will vary from application
 *                to application.  You may find it useful to have a function
 *                like this.  In your application it may be necessary to
 *                actually create an OBJ structure based on what data the
 *                user has selected from the document (by highlighting some
 *                text for example).  
 *
 */
LPOBJ SelectedObject (VOID)
{
   return HwndToLpobj (SelectedObjectWindow());
}
 



/* SelectedObjectWindow
 * --------------------
 *
 * Return a handle to the window for the currently selected object.
 * The GetWindow calls returns a handle to the main window's first child,
 * which is the selected object's window.  
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
HWND SelectedObjectWindow (VOID)
{
   return GetWindow (hwndMain, GW_CHILD);
}



/* SetHiMetricFields
 * -----------------
 *
 * Adjust the nHiMetricWidth and nHiMetricHeight fields of a NATIVE structure
 * so that they are equivalent to the nWidth and nHeight fields.
 * The negative sign in the last line is necessary because the positive 
 * y direction is toward the top of the screen in MM_HIMETRIC mode.
 *
 * LPOBJ lpobj - Pointer to the object whose native data will be adjusted
 *
 * CUSTOMIZATION: Server Demo specific, although you may need a function like
 *                this if you keep track of the size of an object, and an 
 *                object handler needs to know the object's size in 
 *                HiMetric units.
 *
 *
 */
VOID SetHiMetricFields (LPOBJ lpobj)
{
   POINT pt;
   
   pt.x = lpobj->native.nWidth;
   pt.y = lpobj->native.nHeight;
   DeviceToHiMetric ( &pt);
   lpobj->native.nHiMetricWidth  = pt.x;
   lpobj->native.nHiMetricHeight = pt.y;
}



/* SkipBlanks
 * ----------
 * 
 * LPSTR *plpsz - Pointer to a pointer to a character
 *
 * Increment *plpsz past any blanks in the character string.
 * This function is used in ProcessCmdLine.
 *
 */
static VOID SkipBlanks (LPSTR *plpsz)
{
   while (**plpsz && **plpsz == ' ')
      (*plpsz)++;
}



/* UpdateObjMenus
 * ---------------
 *
 * Grey or Ungrey menu items depending on the existence of at least one 
 * object in the document.
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
static VOID UpdateObjMenus (VOID)
{
    static BOOL fObjMenusEnabled = TRUE;
    BOOL        fOneObjExists; // Does at least one object exist?
    WORD        wEnable;
    HMENU       hMenu;

    fOneObjExists = (SelectedObjectWindow() != NULL);
    if (fOneObjExists == fObjMenusEnabled)
    {
         // Nothing has changed.
         return;
    }

    wEnable = (WORD)(fOneObjExists ? MF_ENABLED : MF_GRAYED);

    hMenu = GetMenu(hwndMain);
    EnableMenuItem(hMenu, menuposColor, MF_BYPOSITION | wEnable);

    hMenu = GetSubMenu(GetMenu(hwndMain), menuposFile);
    EnableMenuItem(hMenu, IDM_SAVE,   MF_BYCOMMAND | wEnable);
    EnableMenuItem(hMenu, IDM_SAVEAS, MF_BYCOMMAND | wEnable);

    hMenu = GetSubMenu(GetMenu(hwndMain), menuposEdit);
    EnableMenuItem(hMenu, IDM_CUT,     MF_BYCOMMAND | wEnable);
    EnableMenuItem(hMenu, IDM_COPY,    MF_BYCOMMAND | wEnable);
    EnableMenuItem(hMenu, IDM_DELETE,  MF_BYCOMMAND | wEnable);

    hMenu = GetSubMenu(GetMenu(hwndMain), menuposObject);
    EnableMenuItem(hMenu, IDM_NEXTOBJ, MF_BYCOMMAND | wEnable);

    DrawMenuBar (hwndMain);
    fObjMenusEnabled = fOneObjExists;
}



/* Wait
 * ----
 *
 * Dispatch messages until the given flag is set to FALSE.
 * One use of this function is to wait until a Release method is called
 * after a function has returned OLE_WAIT_FOR_RELEASE.
 *
 * BOOL *pf - Pointer to the flag being waited on.
 *
 * CUSTOMIZATION: The use of OleUnblockServer is for illustration only.
 *                Since Server Demo does not call OleBlockServer, there 
 *                will never be any messages in the OLE queue.
 *
 */
VOID Wait (BOOL *pf)
{
   MSG msg;
   BOOL fMoreMsgs = FALSE;

   *pf = TRUE;
   while (*pf==TRUE)
   {
      OleUnblockServer (srvrMain.lhsrvr, &fMoreMsgs);
      if (!fMoreMsgs)
      // if there are no more messages in the OLE queue, go to system queue
      {
         if (GetMessage (&msg, NULL, 0, 0))
         {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
         }
      }
   }
}

static BOOL FailedUpdate(HWND hwnd)
{

  return(DialogBox(hInst, "FailedUpdate", hwnd, fnFailedUpdate));

}

INT_PTR CALLBACK fnFailedUpdate (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

   switch (message) 
   {
      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         switch (wID) 
         {
               case IDCANCEL:
               case IDD_CONTINUEEDIT:
                   EndDialog(hDlg, TRUE);
                   break;

               case IDD_UPDATEEXIT:
                   EndDialog(hDlg, FALSE);
                   break;

               default:
                   break;
         }
         break;
       }

       case WM_INITDIALOG:
       {
          CHAR szMsg[200];

          szMsg[0] = '\0';

          wsprintf(
               szMsg, 
               "This %s document can only be updated when you exit %s.",
               (LPSTR) szClient,
               (LPSTR) szAppName
          );

          SetDlgItemText(hDlg, IDD_TEXT, szMsg);
          return TRUE; 
       }
       
      default:
           break;
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\srvrdemo\server.c ===
/*
  OLE SERVER DEMO
  Server.c

  This file contains server methods and various server-related support
  functions.

  (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
*/



#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"

CLASS_STRINGS  ClassStrings = {
    "SrvrDemo10", "*.sd1", "Srvr Demo10", "svrdemo1.exe"
};

/*
   Important Note:

   No method should ever dispatch a DDE message or allow a DDE message to
   be dispatched.
   Therefore, no method should ever enter a message dispatch loop.
   Also, a method should not show a dialog or message box, because the
   processing of the dialog box messages will allow DDE messages to be
   dispatched.
*/
BOOL RegServer(){

    LONG        fRet;
    HKEY        hKey;
    CHAR        szKeyName[300]; //Get better value
    BOOL        retVal = FALSE;

    lstrcpy(szKeyName, ClassStrings.pClassName);
    lstrcat(szKeyName, "\\protocol\\StdFileEditing\\verb");

    //Check if Class is installed, following should hold correct if class is installed.
    if ((fRet = RegOpenKey(HKEY_CLASSES_ROOT, szKeyName, &hKey)) == ERROR_SUCCESS)
        return FALSE;

    RegCloseKey(hKey);

    if ((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)(ClassStrings.pFileSpec+1),
            REG_SZ, ClassStrings.pClassName, 7)) != ERROR_SUCCESS)
		return FALSE;

    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, ClassStrings.pClassName, REG_SZ,
                  ClassStrings.pHumanReadable, 7)) != ERROR_SUCCESS)
		return FALSE;

    lstrcat(szKeyName, "\\0");
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, "PLAY", 4))
                  != ERROR_SUCCESS)
		return FALSE;

    szKeyName[lstrlen(szKeyName) - 1] = '1';
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, "EDIT", 4))
         != ERROR_SUCCESS)
		return FALSE;

    lstrcpy(szKeyName, ClassStrings.pClassName);
    lstrcat(szKeyName, "\\protocol\\StdFileEditing\\Server");
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, ClassStrings.pExeName, 11))
         != ERROR_SUCCESS)
		return FALSE;

    lstrcpy(szKeyName, ClassStrings.pClassName);
    lstrcat(szKeyName, "\\protocol\\StdExecute\\Server");
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, ClassStrings.pExeName, 11))
         != ERROR_SUCCESS)
		return FALSE;

	
    return TRUE;

}


/* Abbrev
 * ------
 *
 * Return a pointer to the filename part of a fully-qualified pathname.
 *
 * LPSTR lpsz - Fully qualified pathname
 *
 * CUSTOMIZATION: May be useful, but not necessary.
 *
 */
LPSTR Abbrev (LPSTR lpsz)
{
   LPSTR lpszTemp;

   lpszTemp = lpsz + lstrlen(lpsz) - 1;
   while (lpszTemp > lpsz && lpszTemp[-1] != '\\')
      lpszTemp--;
   return lpszTemp;
}





/* InitServer
 * ----------
 *
 * Initialize the server by allocating memory for it, and calling
 * the OleRegisterServer method.  Requires that the server method table
 * has been properly initialized.
 *
 * HWND hwnd      - Handle to the main window
 * LPSTR lpszLine - The Windows command line
 *
 * RETURNS: TRUE if the memory could be allocated, and the server
 *          was properly registered.
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Your application might not use a global variable
 *                for srvrMain.
 *
 */
BOOL InitServer (HWND hwnd, HANDLE hInst)
{
    RegServer();
    srvrMain.olesrvr.lpvtbl = &srvrvtbl;

    if (OLE_OK != OleRegisterServer
         (szClassName, (LPOLESERVER) &srvrMain, &srvrMain.lhsrvr, hInst,
          OLE_SERVER_MULTI))
      return FALSE;
    else
      return TRUE;
}



/* InitVTbls
 * ---------
 *
 * Create procedure instances for all the OLE methods.
 *
 *
 * CUSTOMIZATION: Your application might not use global variables for srvrvtbl,
 *                docvtbl, and objvtbl.
 */
VOID InitVTbls (VOID)
{
   typedef LPVOID ( APIENTRY *LPVOIDPROC) (LPOLEOBJECT, LPSTR);

   // Server method table
   srvrvtbl.Create          = SrvrCreate;
   srvrvtbl.CreateFromTemplate = SrvrCreateFromTemplate;
   srvrvtbl.Edit            = SrvrEdit;
   srvrvtbl.Execute         = SrvrExecute;
   srvrvtbl.Exit            = SrvrExit;
   srvrvtbl.Open            = SrvrOpen;
   srvrvtbl.Release         = SrvrRelease;

   // Document method table
   docvtbl.Close            = DocClose;
   docvtbl.GetObject        = DocGetObject;
   docvtbl.Execute          = DocExecute;
   docvtbl.Release          = DocRelease;
   docvtbl.Save             = DocSave;
   docvtbl.SetColorScheme   = DocSetColorScheme;
   docvtbl.SetDocDimensions = DocSetDocDimensions;
   docvtbl.SetHostNames     = DocSetHostNames;

   // Object method table
   objvtbl.DoVerb           = ObjDoVerb;
   objvtbl.EnumFormats      = ObjEnumFormats;
   objvtbl.GetData          = ObjGetData;
   objvtbl.QueryProtocol    = ObjQueryProtocol;
   objvtbl.Release          = ObjRelease;
   objvtbl.SetBounds        = ObjSetBounds;
   objvtbl.SetColorScheme   = ObjSetColorScheme;
   objvtbl.SetData          = ObjSetData;
   objvtbl.SetTargetDevice  = ObjSetTargetDevice;
   objvtbl.Show             = ObjShow;

}



/* SetTitle
 * --------
 *
 * Sets the main window's title bar. The format of the title bar is as follows
 *
 * If embedded
 *        <Server App name> - <object type> in <client doc name>
 *
 *      Example:  "Server Demo - SrvrDemo Shape in OLECLI.DOC"
 *                where OLECLI.DOC is a Winword document
 *
 * otherwise
 *        <Server App name> - <server document name>
 *
 *      Example:  "Srvr Demo10 - OLESVR.SD1"
 *                where OLESVR.SD1 is a Server demo document
 *
 * LPSTR lpszDoc    - document name
 * BOOL  fEmbedded  - If TRUE embedded document, else normal document
 *
 * RETURNS: OLE_OK
 *
 *
 * CUSTOMIZATION: Your application may store the document's name somewhere
 *                other than docMain.aName.  Other than that, you may
 *                find this a useful utility function as is.
 *
 */
VOID SetTitle (LPSTR lpszDoc, BOOL fEmbedded)
{
   CHAR szBuf[cchFilenameMax];

   if (lpszDoc && lpszDoc[0])
   {
      // Change document name.
      if (docMain.aName)
         GlobalDeleteAtom (docMain.aName);
      docMain.aName = GlobalAddAtom (lpszDoc);
   }

   if (fEmbedded)
   {
     //
      if (lpszDoc && lpszDoc[0])
      {
         wsprintf (szBuf, "%s - SrvrDemo10 Shape in %s", (LPSTR) szAppName,
             Abbrev (lpszDoc));
      }
      else
      {
         // Use name from docMain
         CHAR szDoc [cchFilenameMax];

         GlobalGetAtomName (docMain.aName, szDoc, cchFilenameMax);
         wsprintf (szBuf, "%s - SrvrDemo Shape10 in %s", (LPSTR) szAppName,
             Abbrev (szDoc));
      }
      SetWindowText (hwndMain, (LPSTR)szBuf);
   }
   else if (lpszDoc && lpszDoc[0])
   {
      wsprintf (szBuf, "%s - %s", (LPSTR) szAppName, Abbrev(lpszDoc));
      SetWindowText (hwndMain, szBuf);
   }
}




/* SrvrCreate                SERVER "Create" METHOD
 * ----------
 *
 * Create a document, allocate and initialize the OLESERVERDOC structure,
 * and associate the library's handle with it.
 * In this demo server, we also create an object for the user to edit.
 *
 * LPOLESERVER lpolesrvr          - The server structure registered by
 *                                  the application
 * LHSERVERDOC lhdoc              - The library's handle
 * OLE_LPCSTR lpszClassName            - The class of document to create
 * OLE_LPCSTR lpszDoc                  - The name of the document
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates the server doc structure to be
 *                                  created
 *
 * RETURNS:        OLE_OK if the named document was created.
 *                 OLE_ERROR_NEW if the document could not be created.
 *
 * CUSTOMIZATION: Your application might not call CreateNewObj.
 *
 */
OLESTATUS  APIENTRY SrvrCreate
   (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, OLE_LPCSTR lpszClassName,
    OLE_LPCSTR lpszDoc, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateNewDoc (lhdoc, (LPSTR) lpszDoc, doctypeEmbedded))
        return OLE_ERROR_NEW;

    // Although the document has not actually been changed, the client has not
    // received any data from the server yet, so the client will need to be
    // updated.  Therefore, CreateNewObj sets fDocChanged to TRUE.
    CreateNewObj (TRUE);
    *lplpoledoc = (LPOLESERVERDOC) &docMain;
    EmbeddingModeOn();
    return OLE_OK;
}



/* SrvrCreateFromTemplate        SERVER "CreateFromTemplate" METHOD
 * ----------------------
 *
 * Create a document, allocate and initialize the OLESERVERDOC structure,
 * initializing the document with the contents named in the template name,
 * and associate the library's handle with the document structure.
 *
 * LPOLESERVER lpolesrvr        - The server structure registered by
 *                                the application
 * LHSERVERDOC lhdoc            - The library's handle
 * OLE_LPCSTR lpszClassName          - The class of document to create
 * OLE_LPCSTR lpszDoc                - The name of the document
 * OLE_LPCSTR lpszTemplate           - The name of the template
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates the server doc structure
 *                                  to be created
 *
 * RETURNS:        OLE_OK if the named document was created.
 *                 OLE_ERROR_TEMPLATE if the document could not be created.
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrCreateFromTemplate
   (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, OLE_LPCSTR lpszClassName,
    OLE_LPCSTR lpszDoc, OLE_LPCSTR lpszTemplate, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateDocFromFile((LPSTR) lpszTemplate, (LHSERVERDOC) lhdoc, doctypeEmbedded))
        return OLE_ERROR_TEMPLATE;

    *lplpoledoc = (LPOLESERVERDOC) &docMain;

    // Although the document has not actually been changed, the client has not
    // received any data from the server yet, so the client will need to be
    // updated.
    fDocChanged = TRUE;
    EmbeddingModeOn();
    return OLE_OK;
}



/* SrvrEdit                SERVER "Edit" METHOD
 * --------
 *
 * A request by the libraries to create a document, allocate and
 * initialize the OLESERVERDOC structure, and associate the
 * library's handle with the document structure.
 * We create an object which will be modified by the SetData method
 * before the user has a chance to touch it.
 *
 * LPOLESERVER lpolesrvr          - The server structure registered by
 *                                  the application
 * LHSERVERDOC lhdoc              - The library's handle
 * OLE_LPCSTR lpszClassName            - The class of document to create
 * OLE_LPCSTR lpszDoc                  - The name of the document
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates the server doc structure to be
 *                                  created
 *
 * RETURNS:        OLE_OK if the named document was created.
 *                 OLE_ERROR_EDIT if the document could not be created.
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrEdit
   (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, OLE_LPCSTR lpszClassName,
    OLE_LPCSTR lpszDoc, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateNewDoc ((LONG)lhdoc, (LPSTR)lpszDoc, doctypeEmbedded))
        return OLE_ERROR_EDIT;

    // The client is creating an embedded object for the server to edit,
    // so initially the client and server are in sync.
    fDocChanged = FALSE;
    *lplpoledoc = (LPOLESERVERDOC) &docMain;
    EmbeddingModeOn();
    return OLE_OK;

}


/* SrvrExecute                SERVER "Execute" METHOD
 * --------
 *
 * This application does not support the execution of DDE execution commands.
 *
 * LPOLESERVER lpolesrvr - The server structure registered by
 *                         the application
 * HANDLE hCommands      - DDE execute commands
 *
 * RETURNS: OLE_ERROR_COMMAND
 *
 * CUSTOMIZATION: Re-implement if your application supports the execution of
 *                DDE commands.
 *
 */
OLESTATUS  APIENTRY SrvrExecute (LPOLESERVER lpolesrvr, HANDLE hCommands)
{
   return OLE_ERROR_COMMAND;
}



/* SrvrExit                SERVER "Exit" METHOD
 * --------
 *
 * This method is called the library to instruct the server to exit.
 *
 * LPOLESERVER lpolesrvr - The server structure registered by
 *                         the application
 *
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrExit (LPOLESERVER lpolesrvr)
{
   if (srvrMain.lhsrvr)
   // If we haven't already tried to revoke the server.
   {
      StartRevokingServer();
   }
   return OLE_OK;
}



/* SrvrOpen                SERVER "Open" METHOD
 * --------
 *
 * Open the named document, allocate and initialize the OLESERVERDOC
 * structure, and associate the library's handle with it.
 *
 * LPOLESERVER lpolesrvr          - The server structure registered by
 *                                  the application
 * LHSERVERDOC lhdoc              - The library's handle
 * OLE_LPCSTR lpszDoc                  - The name of the document
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates server doc structure to be
 *                                  created
 *
 * RETURNS:        OLE_OK if the named document was opened.
 *                 OLE_ERROR_OPEN if document could not be opened correctly.
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrOpen (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc,
                               OLE_LPCSTR lpszDoc, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateDocFromFile ((LPSTR)lpszDoc, (LHSERVERDOC)lhdoc, doctypeFromFile))
        return OLE_ERROR_OPEN;

    *lplpoledoc = (LPOLESERVERDOC) &docMain;
    return OLE_OK;
}



/* SrvrRelease                SERVER "Release" METHOD
 * -----------
 *
 * This library calls the SrvrRelease method when it is safe to quit the
 * application.  Note that the server application is not required to quit.
 *
 * srvrMain.lhsrvr != NULL indicates that SrvrRelease has been called
 * because the client is no longer connected, not because the server called
 * OleRevokeServer.
 * Therefore, only start the revoking process if the document is of type
 * doctypeEmbedded or if the server was opened for an invisible update.
 *
 * srvrmain.lhsrvr == NULL indicates that OleRevokeServer has already
 * been called (by the server application), and srvrMain is bad.
 * It is safe to quit now because SrvrRelease has just been called.
 *
 * Note that this method may be called twice: when OleRevokeServer is
 * called in StartRevokingServer, SrvrRelease is called again.
 * Therefore we need to be reentrant.
 *
 * LPOLESERVER lpolesrvr - The server structure to release
 *
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrRelease (LPOLESERVER lpolesrvr)
{
   if (srvrMain.lhsrvr)
   {
      if (fRevokeSrvrOnSrvrRelease
          && (docMain.doctype == doctypeEmbedded
              || !IsWindowVisible (hwndMain)))
         StartRevokingServer();
   }
   else
   {
      fWaitingForSrvrRelease = FALSE;
      // Here you should free any memory that had been allocated for the server.
      PostQuitMessage (0);
   }
   return OLE_OK;
}



/* StartRevokingServer
 * -------------------
 *
 * Hide the window, and start to revoke the server.
 * Revoking the server will let the library close any registered documents.
 * OleRevokeServer may return OLE_WAIT_FOR_RELEASE.
 * Calling StartRevokingServer starts a chain of events that will eventually
 * lead to the application being terminated.
 *
 * RETURNS: The return value from OleRevokeServer
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS StartRevokingServer (VOID)
{
   OLESTATUS olestatus;

   if (srvrMain.lhsrvr)
   {
      LHSERVER lhserver;
      // Hide the window so user can do nothing while we are waiting.
      ShowWindow (hwndMain, SW_HIDE);
      lhserver = srvrMain.lhsrvr;
      // Set lhsrvr to NULL to indicate that srvrMain is a bad and that
      // if SrvrRelease is called, then it is ok to quit the application.
      srvrMain.lhsrvr = 0;
      olestatus = OleRevokeServer (lhserver);
   }
   else
      // The programmer should ensure that this never happens.
      ErrorBox ("Fatal Error: StartRevokingServer called on NULL server.");
   return olestatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\olebind\tmoniker.h ===
#ifndef __TMONIKER_H__
#define __TMONIKER_H__

BOOL TestBindCtx(void);

BOOL TestROT(REFCLSID clsid);

BOOL TestMoniker(LPWSTR pszPath1, LPWSTR pszPath2);

#endif // __TMONIKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\olebind\rot.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	rotut.cxx
//
//  Contents:	Unit Test for ROT
//
//  Classes:	MISSING
//
//  Functions:	MISSING
//
//  History:	16-Oct-93 Ricksa    Created
//              31-Dec-93 ErikGav   Chicago port
//
//--------------------------------------------------------------------------
#include    <windows.h>
#include    <ole2.h>
#include    <olebind.hxx>
#include    <stdio.h>


class CRotTestObject : public IUnknown
{
public:
			CRotTestObject(WCHAR *pwszID);

    // IUnknown Interface
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);

    STDMETHOD_(ULONG, AddRef)(void);

    STDMETHOD_(ULONG, Release)(void);

private:

    WCHAR		_awcID[256];

    ULONG		_cRefs;

};




CRotTestObject::CRotTestObject(WCHAR *pwszID) : _cRefs(1)
{
    wcscpy(_awcID, pwszID);
}




STDMETHODIMP CRotTestObject::QueryInterface(REFIID riid, void **ppv)
{
    if (memcmp((void *) &riid, (void *) &IID_IUnknown, sizeof(GUID)) == 0)
    {
	_cRefs++;
	*ppv = (IUnknown *) this;
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}



STDMETHODIMP_(ULONG) CRotTestObject::AddRef(void)
{
    _cRefs++;
    return (ULONG) _awcID;
}



STDMETHODIMP_(ULONG) CRotTestObject::Release(void)
{
    ULONG cRefs = --_cRefs;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}



//
//	Test Running Object Table
//
//  BUGBUG: Need to test enumerator
BOOL TestROT(REFCLSID clsid)
{
    XUnknown		 punk2;
    XMoniker		 pmk;
    XMoniker		 pmk2;
    XRunningObjectTable  prot;
    XEnumMoniker	 penummk;


    HRESULT hr = GetRunningObjectTable(0, &prot);

    TEST_FAILED_HR(FAILED(hr), "GetRunningObjectTable failed!")

    // Make sure that we can do something on the pointer that
    // we got back.
    prot->AddRef();
    prot->Release();

    // Create an IUnknown pointer for the class.
    IUnknown *punk = new CRotTestObject(L"First Test Object");

    hr = CreateItemMoniker(L"\\", wszPid, &pmk2);

    TEST_FAILED_HR(FAILED(hr), "CreateItemMoniker for \\Bob failed")

    // Do a get object to make sure that this is not in the ROT already

    hr = prot->GetObject(pmk2, &punk2);

    TEST_FAILED_HR(SUCCEEDED(hr), "GetObject on nonexistent succeeded")

    // Cookie for deregistering object
    DWORD dwRegister;

    hr = prot->Register(0, punk, pmk2, &dwRegister);

    TEST_FAILED_HR(FAILED(hr), "Register in ROT for \\PID failed")

    hr = prot->IsRunning(pmk2);

    TEST_FAILED_HR((hr != S_OK),
	"Unexpected return from IsRunning")

    // Test Get Object
    hr = prot->GetObject(pmk2, &punk2);

    TEST_FAILED_HR((hr != S_OK), "Unexpected from GetObject")

    // Confirm object identity
    WCHAR *pwszID = (WCHAR *) punk2->AddRef();

    TEST_FAILED_HR((wcscmp(pwszID, L"First Test Object") != 0),
	"GetObject ID is invalid");

    // Make sure pointer == original pointer
    TEST_FAILED((punk2 != punk), "GetObject Pointers are not equal!")

    // Clean up punk2 -- two releases because +1 on return and +1 on
    // addref to get id string
    punk2->Release();
    punk2.Set(NULL);


    // Test set the time
    FILETIME filetime;

    memset(&filetime, 'A', sizeof(filetime));

    hr = prot->NoteChangeTime(dwRegister, &filetime);

    TEST_FAILED_HR((hr != S_OK), "NoteChangeTime Failed")

    // Test get the time
    FILETIME filetime2;

    hr = prot->GetTimeOfLastChange(pmk2, &filetime2);

    TEST_FAILED_HR((hr != S_OK), "NoteChangeTime Failed")

    TEST_FAILED((memcmp(&filetime, &filetime2, sizeof(filetime)) != 0),
	"GetTimeOfLastChange != NoteChangeTime value")

    // Enumerate all the running monikers

    hr = prot->EnumRunning(&penummk);

    TEST_FAILED_HR(FAILED(hr), "EnumRunning Failed")

    // Cycle through running object table
    BOOL fFound = FALSE;
    int cIdx = 0;
    int cOurMoniker;

    while (SUCCEEDED(hr = penummk->Next(1, &pmk, NULL))
	&& (hr != S_FALSE))
    {
	if (pmk2->IsEqual(pmk) == S_OK)
	{
	    fFound = TRUE;
	    cOurMoniker = cIdx;
	}

	pmk.Set(NULL);
	cIdx++;
    }

    TEST_FAILED_HR(FAILED(hr), "ROT Moniker Enumeration ended in failure")

    TEST_FAILED((!fFound), "Did not find our moniker in the table");

    // Reset the pointer
    hr = penummk->Reset();

    TEST_FAILED_HR(FAILED(hr), "ROT IEnumMoniker::Reset Failed");

    // Skip to our moniker
    hr = penummk->Skip(cOurMoniker);

    TEST_FAILED_HR(FAILED(hr), "ROT IEnumMoniker::Skip Failed");

    // Read it from the enumerator
    hr = penummk->Next(1, &pmk, NULL);

    TEST_FAILED_HR(FAILED(hr), "ROT IEnumMoniker::Next Failed");

    TEST_FAILED((pmk2->IsEqual(pmk) != S_OK),
	"ROT IEnumMoniker::Next after skip monikers !=");

    pmk.Set(NULL);

    // Clean up enumerator
    penummk.Set(NULL);

    // Test duplicate registration
    DWORD dwRegister2;

    hr = prot->Register(0, punk, pmk2, &dwRegister2);

    TEST_FAILED_HR((hr != MK_S_MONIKERALREADYREGISTERED),
	"2nd Register in ROT for \\PID failed")

    // Revoke non-existent object
    DWORD dwDummy = (DWORD) &dwRegister2;

    hr = prot->Revoke(dwDummy);

    TEST_FAILED_HR((hr != E_INVALIDARG), "Revoke for bad item wrong result")

    // Revoke the object
    hr = prot->Revoke(dwRegister);

    TEST_FAILED_HR(FAILED(hr), "Revoke of first reg in ROT failed")

    // Revoke duplicate registration
    hr = prot->Revoke(dwRegister2);

    TEST_FAILED_HR(FAILED(hr), "2nd Revoke in ROT failed")

    // Make sure it is no longer running
    hr = prot->IsRunning(pmk2);

    TEST_FAILED_HR((hr != S_FALSE),
	"Revoked ROT entry unexpected error")

    // If we get to here the test passed
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\olebind\tmoniker.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       tmoniker.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-31-93   ErikGav   Chicago port
//
//----------------------------------------------------------------------------

// moniker.cxx : various tests related to monikers...
//

#pragma optimize("",off)
#include <stdio.h>
#include <windows.h>
#include <ole2.h>
#include "olebind.hxx"
#include "tmoniker.h"

STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phdl);

//  BUGBUG: Make this test more extensive -- all operations on a
//          bind context should be verified.
BOOL TestBindCtx( void )
{
        XBindCtx pbc;
        XUnknown punk;
        XUnknown punk2;

        HRESULT hr = CreateBindCtx(0, &pbc);

        TEST_FAILED_HR(FAILED(hr), "CreateBindCtx Failed")

        hr = pbc->RegisterObjectParam(L"Key1", pbc);

        TEST_FAILED_HR(FAILED(hr), "RegisterObjectParam Failed")

        hr = pbc->GetObjectParam(L"Key1", &punk2);

        TEST_FAILED_HR(FAILED(hr), "GetObjectParam Failed")

        TEST_FAILED((pbc != punk2),
            "Failure to get registered object parameter")

        // BUGBUG:  What do we test for here?
        punk2.Set(NULL);

        hr = pbc->GetObjectParam(L"Key2", &punk2);

        TEST_FAILED_HR((hr != E_FAIL),
            "GetObjectParam with bad key did not return an error")

        TEST_FAILED((punk2 != NULL),
            "Bad GetObjectParam did not return NULL for object")

        hr = pbc->RegisterObjectParam(L"Key2", pbc);

        TEST_FAILED_HR(FAILED(hr), "Second RegisterObjectParam Failed")

        hr = pbc->GetObjectParam(L"Key2", &punk);

        TEST_FAILED_HR(FAILED(hr), "GetObjectParam on second Failed")

        TEST_FAILED((pbc != punk),
            "Failure on second to get registered object parameter")

        // BUGBUG:  What do we check?
        punk.Set(NULL);

        hr = pbc->RevokeObjectParam(L"Key2");

        TEST_FAILED_HR(FAILED(hr),
            "RevokeObjectParam of Key2 Failed")

        hr = pbc->GetObjectParam(L"Key2", &punk);

        TEST_FAILED_HR((hr != E_FAIL),
            "Get of revoked Key2 returned success")

        TEST_FAILED((punk != NULL),
            "Value returned on get of revoked key2")

        hr = pbc->RevokeObjectParam(L"Key1");

        TEST_FAILED_HR(FAILED(hr),
            "RevokeObjectParam of Key1 Failed")

        return FALSE;
}

BOOL VerifyFileMoniker(LPWSTR wcsFile)
{
    HRESULT hr;
    XMoniker   pmk;
    XBindCtx   pbc;
    LPWSTR wcsDisplayName = NULL;

    hr = CreateBindCtx(0,&pbc);
    TEST_FAILED_HR(FAILED(hr), "CreateBindCtx");

    hr = CreateFileMoniker(wcsFile,&pmk);
    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker failed");

    hr = pmk->GetDisplayName(pbc,NULL,&wcsDisplayName);
    TEST_FAILED_HR(FAILED(hr), "GetDisplayName failed");

    if (0 != wcscmp(wcsFile,wcsDisplayName))
    {
        wsprintfA(&wszErrBuf[0], "(%S) doesn't match displayname (%S)",wcsFile,wcsDisplayName);
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
	hr = E_FAIL;
    }

    CoTaskMemFree(wcsDisplayName);
    return(hr);
}
BOOL TestMoniker(LPWSTR pszPath1, LPWSTR pszPath2)
{
    XUnknown   pUnk;
    XUnknown   pUnk1;
    XBindCtx   pbc;
    XMoniker   pmk1;
    XMoniker   pmk2;
    XMoniker   pmk3;
    XMoniker   pmk4;
    XMoniker   pmk5;
    XMoniker   pmk6;
    XMoniker   pmkItem1;
    XMoniker   pmkItem2;
    XMoniker   pmkAnti;
    XStream    pStm;
    XOleObject pObj;
    XMalloc    pIMalloc;
    XMoniker   pmkLong1;
    XMoniker   pmkLong2;
    XRunningObjectTable prot;

    ULONG chEaten;
    LPWSTR szName;
    LARGE_INTEGER large_int;
    HRESULT hr;

    //
    // Test the dotdot eating methods
    //
    VerifyFileMoniker(L".");
    VerifyFileMoniker(L"..\\");

    VerifyFileMoniker(L"foo.bar");
    VerifyFileMoniker(L".foo.bar");
    VerifyFileMoniker(L".foo..bar");
    VerifyFileMoniker(L"..foo.bar");
    VerifyFileMoniker(L"..foo..bar");

    VerifyFileMoniker(L"foo\\bar");
    VerifyFileMoniker(L"foo\\.bar");
    VerifyFileMoniker(L"foo\\..bar");

    VerifyFileMoniker(L".foo\\bar");
    VerifyFileMoniker(L".foo\\.bar");
    VerifyFileMoniker(L".foo\\..bar");

    VerifyFileMoniker(L"..foo\\bar");
    VerifyFileMoniker(L"..foo\\.bar");
    VerifyFileMoniker(L"..foo\\..bar");

    VerifyFileMoniker(L"...foo\\bar");
    VerifyFileMoniker(L"...foo\\.bar");
    VerifyFileMoniker(L"...foo\\..bar");

    VerifyFileMoniker(L"\\foo\\bar");
    VerifyFileMoniker(L"\\.foo\\bar");
    VerifyFileMoniker(L"\\..foo\\bar");

    VerifyFileMoniker(L"..\\foo\\bar");
    VerifyFileMoniker(L"..\\.foo\\bar");
    VerifyFileMoniker(L"..\\..foo\\bar");

    hr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);

    TEST_FAILED_HR(FAILED(hr), "CoGetMalloc failed");

    hr = CreateFileMoniker(pszPath1, &pmk1);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker for path1 failed!")

    TEST_FAILED((pmk1 == NULL),
        "CreateFileMoniker returned a null moniker ptr")

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx File Moniker GetDisplayName failed!")

    hr = pmk1->GetDisplayName(pbc, NULL, &szName);

    //  release it
    pbc.Set(NULL, FALSE);

    TEST_FAILED_HR(FAILED(hr), "File Moniker GetDisplayName failed!");

    // BUGBUG: The following is an inappropriate test.
    // TEST_FAILED((lstrcmp(szName, pszPath1) != 0), "Wrong path from file mon");

    // Free the path
    pIMalloc->Free(szName);

    LAST_RELEASE(pmk1)

    CreateFileMoniker(pszPath1, &pmk1);

    hr = CreateFileMoniker(pszPath2, &pmk6);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker for path2 failed")

    //
    //  Test Item Monikers
    //
    hr = CreateItemMoniker(L"\\", L"1", &pmk2);

    TEST_FAILED_HR(FAILED(hr), "CreateItemMoniker 1 failed")

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx Item Moniker GetDisplayName failed!")

    hr = pmk2->GetDisplayName(pbc, NULL, &szName);

    pbc.Set(NULL);

    TEST_FAILED_HR(FAILED(hr), "Item Moniker GetDisplayName failed!");

    TEST_FAILED((wcscmp(szName, L"\\1") != 0), "Wrong path from item mon");

    // Free the path
    pIMalloc->Free(szName);

    hr = CreateItemMoniker(L"\\", L"2", &pmk3);

    TEST_FAILED_HR(FAILED(hr), "CreateItemMoniker 0 failed")

    hr = pmk3->Inverse(&pmk4);

    TEST_FAILED_HR(FAILED(hr), "Inverse of 0 failed")

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr), "CreateBindCtx after inverse failed")

    hr = pmk4->GetDisplayName(pbc, NULL, &szName);

    TEST_FAILED_HR(FAILED(hr), "GetDisplayName on AntiMoniker failed")

    TEST_FAILED((memcmp(szName, L"\\..", sizeof(L"\\..")) != 0),
        "GetDisplayName on AntiMoniker name wrong\n")

    // Free memory API allocated.
    pIMalloc->Free(szName);

    // Release interfaces we are finished with
    LAST_RELEASE(pbc)
    LAST_RELEASE(pmk4)

    //
    //  Test composition of file moniker & item moniker
    //
    hr = pmk1->ComposeWith(pmk2, FALSE, &pmk4);

    TEST_FAILED_HR(FAILED(hr), "ComposeWith failed")

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx Composite Moniker GetDisplayName failed!")

    hr = pmk4->GetDisplayName(pbc, NULL, &szName);

    pbc.Set(NULL);

    TEST_FAILED_HR(FAILED(hr), "GetDisplayName on Composite moniker failed")

    // Free memory API allocated.
    pIMalloc->Free(szName);

    Sleep(10);
    hr = BindMoniker(pmk4, 0, IID_IUnknown, (LPVOID FAR*) &pUnk);

    TEST_FAILED_HR(FAILED(hr), "BindMoniker with composed moniker failed")

    TEST_FAILED((pUnk == NULL),
        "BindMoniker with composed moniker returned NULL punk\n")

    hr = pUnk->QueryInterface(IID_IOleObject, (LPVOID FAR*) &pObj);

    TEST_FAILED_HR(FAILED(hr), "QI to IID_IOleObject failed")

    TEST_FAILED((pObj == NULL),
        "pObj returned from QI invalid")

    hr = pmk6->ComposeWith(pmk3, FALSE, &pmk5);

    TEST_FAILED_HR(FAILED(hr), "ComposedWith of pmk6 failed")

    hr = BindMoniker(pmk5, 0, IID_IUnknown, (LPVOID FAR*) &pUnk1);

    TEST_FAILED_HR(FAILED(hr), "BindMoniker of pmk5 failed")

    hr = OleRun(pUnk1);

    TEST_FAILED_HR(FAILED(hr), "OleRun call failed")

    TEST_FAILED_HR(FAILED(hr), "GetObject Failed");

    // Clean up objects
    pObj.Set(NULL);
    LAST_RELEASE(pUnk1);
    LAST_RELEASE(pmk5);
    LAST_RELEASE(pUnk);
    LAST_RELEASE(pmk6);

    //
    //  Test Marshal/Unmarshal Moniker
    //
    // Make a moniker to marshal
    hr = pmk4->ComposeWith(pmk3, FALSE, &pmk6);

    TEST_FAILED_HR(FAILED(hr), "Compose of moniker for marshal test failed");

    // Create a shared memory stream for the marshaled moniker
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);

    TEST_FAILED((FAILED(hr)), "CreateStreamOnHGlobal")

    // Marshal the interface into the stream
    hr = CoMarshalInterface(pStm, IID_IMoniker, pmk6, 0, NULL, MSHLFLAGS_NORMAL);

    TEST_FAILED_HR(FAILED(hr), "CoMarshalInterface failed")

    LISet32(large_int, 0);
    hr = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);

    TEST_FAILED_HR(FAILED(hr), "Seek on shared stream failed")

    hr = CoUnmarshalInterface(pStm, IID_IMoniker, (LPVOID FAR*)&pmk5);

    TEST_FAILED_HR(FAILED(hr), "CoUnmarshalInterface failed")

    // Dump interfaces we are done with
    LAST_RELEASE(pmk6);
    LAST_RELEASE(pmk3);
    LAST_RELEASE(pmk4);
    LAST_RELEASE(pmk1);
    LAST_RELEASE(pmk2);
    LAST_RELEASE(pStm);
    LAST_RELEASE(pmk5);

    //
    //  Test Moniker Composition
    //
    //  BUGBUG: Check result
    hr = CreateFileMoniker(L"\\ole2\\test\\breadth\\servers\\ellipswt",
        &pmk1);

    TEST_FAILED_HR(FAILED(hr),
        "First CreateFileMoniker in composition test failed")

    hr = CreateFileMoniker(L"..\\..\\..\\dll\\sdemo1.exe",&pmk2);

    TEST_FAILED_HR(FAILED(hr),
        "Second CreateFileMoniker in composition test failed")

    hr = pmk1->ComposeWith(pmk2, FALSE, &pmk4);

    TEST_FAILED_HR(FAILED(hr), "ComposeWith of file monikers failed")

    // Dump interfaces we are done with
    LAST_RELEASE(pmk4);
    LAST_RELEASE(pmk1);
    LAST_RELEASE(pmk2);

    //
    //  Testing file moniker CommonPrefixWith
    //
    //	BUGBUG: Check result
    hr = CreateFileMoniker(L"\\Ole2\\Test\\Breadth\\Servers\\Ellipswt",
        &pmk1);

    TEST_FAILED_HR(FAILED(hr),
        "CommonPrefixWith First CreateFileMoniker failed")

    hr = CreateFileMoniker(
	L"\\ole2\\test\\breadth\\serverandthensome\\bar", &pmk2);

    TEST_FAILED_HR(FAILED(hr),
        "CommonPrefixWith second CreateFileMoniker failed")


    hr = pmk1->CommonPrefixWith(pmk2, &pmk4);

    TEST_FAILED_HR(FAILED(hr), "CommonPrefixWith failed")

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx CommonPrefixWith GetDisplayName failed!")

    hr = pmk4->GetDisplayName(pbc, NULL, &szName);

    pbc.Set(NULL);

    TEST_FAILED_HR(FAILED(hr), "CommonPrefixWith: GetDisplayName failed!");

    TEST_FAILED((_wcsicmp(szName, L"\\ole2\\test\\breadth") != 0),
                        "Common prefix with: Wrong Output Path\n");

    // Free the path
    pIMalloc->Free(szName);

    // Dump monikers we are done with
    LAST_RELEASE(pmk4);
    LAST_RELEASE(pmk2);
    LAST_RELEASE(pmk1);

    //
    //  Testing file moniker RelativePathTo
    //
    //	BUGBUG: Check result.
    hr = CreateFileMoniker(L"\\Ole2\\Test\\Breadth\\Servers\\Ellipswt",
        &pmk1);

    TEST_FAILED_HR(FAILED(hr), "RelativePathTo first CreateFileMoniker failed")

    hr = CreateFileMoniker(
	L"\\ole2\\test\\breadth\\serverandthensome\\bar", &pmk2);

    TEST_FAILED_HR(FAILED(hr),
        "RelativePathTo Second CreateFileMoniker failed")

    hr = pmk1->RelativePathTo(pmk2, &pmk4);

    TEST_FAILED_HR(FAILED(hr), "RelativePathTo failed")


    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx RelativePathTo GetDisplayName failed!")

    hr = pmk4->GetDisplayName(pbc, NULL, &szName);

    pbc.Set(NULL);

    TEST_FAILED_HR(FAILED(hr), "RelativePathTo: GetDisplayName failed!");

    TEST_FAILED((wcscmp(szName, L"..\\..\\serverandthensome\\bar") != 0),
                        "RelativePathTo: Wrong Output Path");

    // Free the path
    pIMalloc->Free(szName);


    LAST_RELEASE(pmk2);
    LAST_RELEASE(pmk1);
    LAST_RELEASE(pmk4);

    //
    //  Testing MkParseDisplayName
    //
    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr), "MkParseDisplayName CreatebindCtx failed")

    // make a path to the object
    WCHAR szBuf[256];
    int cPath1;
    cPath1 = wcslen(pszPath1);
    memcpy(szBuf, pszPath1, cPath1 * sizeof(WCHAR));
    memcpy(szBuf + cPath1, L"\\1", sizeof(L"\\1"));

    hr = MkParseDisplayName(pbc, szBuf, &chEaten, &pmk1);

    TEST_FAILED_HR(FAILED(hr), "MkParseDisplayName failed")

    LAST_RELEASE(pmk1);
    LAST_RELEASE(pbc);

    //
    //  Test Moniker IsEqual function on equivalent paths
    //  The moniker code should catch some forms of equivalent
    //  paths, but doesn't handle all of them.
    //
    //

    hr = CreateFileMoniker(L"first",&pmk1);

    TEST_FAILED_HR(FAILED(hr),
        "First CreateFileMoniker in IsEqual test failed")

    hr = CreateFileMoniker(L".\\first",&pmk2);

    TEST_FAILED_HR(FAILED(hr),
        "Second CreateFileMoniker in IsEqual test failed")

    hr = CreateFileMoniker(L"..\\first",&pmk3);

    TEST_FAILED_HR(FAILED(hr),
        "Third CreateFileMoniker in IsEqual test failed")

        //  This moniker variation has been disabled for Cairo
        //    until the moniker code gets unified.
#ifndef _CAIRO_
    hr = CreateFileMoniker(L"..\\.first",&pmk4);

    TEST_FAILED_HR(FAILED(hr),
        "Fourth CreateFileMoniker in IsEqual test failed")
#endif

    hr = pmk1->IsEqual(pmk2);
    TEST_FAILED_HR((hr != S_OK), "pmk1->IsEqual(pmk2) failed")

    hr = pmk2->IsEqual(pmk3);
    TEST_FAILED_HR((hr != S_FALSE), "pmk2->IsEqual(pmk3) failed")

#ifndef _CAIRO_
    hr = pmk3->IsEqual(pmk4);
    TEST_FAILED_HR((hr != S_FALSE), "pmk3->IsEqual(pmk4) failed")

    hr = pmk4->IsEqual(pmk4);
    TEST_FAILED_HR((hr != S_OK), "pmk4->IsEqual(pmk4) failed")
#endif

    // Dump interfaces we are done with
    LAST_RELEASE(pmk1);
    LAST_RELEASE(pmk2);
    LAST_RELEASE(pmk3);

#ifndef _CAIRO_
    LAST_RELEASE(pmk4);
#endif

    //
    // Test IsRunning
    //

    //  we make up a name based on the pid and an arbitrary string,
    //  so that the name is unique to this process.

    WCHAR   wszMkName[MAX_PATH];
    wcscpy(wszMkName, L"YourStockOptionsDependOnThis");
    wcscat(wszMkName, &wszPid[1]);  //  skip leading backslash

    hr = CreateFileMoniker(wszMkName, &pmk1);

    TEST_FAILED_HR(FAILED(hr),
        "First CreateFileMoniker in IsRunning failed")

    hr = CreateBindCtx(0, &pbc);
    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx in IsRunning failed")

    //
    // We shouldn't find the moniker in the ROT
    //
    hr = pmk1->IsRunning(pbc,NULL,NULL);
    TEST_FAILED_HR((hr != S_FALSE),
        "IsRunning returns other than S_FALSE");

    //
    // The FileMoniker should ignore pmk1
    //

    hr = pmk1->IsRunning(pbc,pmk1,NULL);
    TEST_FAILED_HR((hr != S_FALSE),
        "IsRunning #2 returns other than S_FALSE");


    hr = GetRunningObjectTable(0, &prot);

    TEST_FAILED_HR(FAILED(hr),"IsRunning GetRunningObjectTable failed!");


    //
    // Just for kicks, we are going to register this moniker itself
    // as running. We needed an IUnknown pointer here, and the moniker
    // just happens to have one.
    //

    DWORD dwRegister;
    DWORD dwRegister2;

    hr = prot->Register(0,pmk1,pmk1,&dwRegister);
    TEST_FAILED_HR(FAILED(hr),
        "Register with ROT failed in IsRunning");

    //
    // We should find the moniker as running
    //
    hr = pmk1->IsRunning(pbc,NULL,NULL);
    TEST_FAILED_HR((hr != S_OK),
        "IsRunning returns other than S_OK");

    hr = prot->IsRunning(pmk1);
    TEST_FAILED_HR((hr != S_OK),
        "IsRunning returns other than S_OK");

    //
    // Register it again, and we should get notice that it is running
    //
    // This test the ROT, and also test the moniker comparision
    // functions
    //

    hr = prot->Register(0,pmk1,pmk1,&dwRegister2);
    TEST_FAILED_HR(hr != MK_S_MONIKERALREADYREGISTERED,
        "Register with ROT failed in IsRunning");

    hr = prot->IsRunning(pmk1);
    TEST_FAILED_HR((hr != S_OK),
                "IsRunning #1 has returned != S_OK");

    hr = prot->Revoke(dwRegister2);
    TEST_FAILED_HR(FAILED(hr),
        "Revoke dwRegister2 with ROT failed");

    hr = prot->Revoke(dwRegister2);
    TEST_FAILED_HR(hr == S_OK,
        "Revoke dwRegister2 with ROT should have failed");

    //
    // It is registered twice, it should still be there from the original
    // registration
    //
    hr = pmk1->IsRunning(pbc,NULL,NULL);
    TEST_FAILED_HR((hr != S_OK),
                "IsRunning #2 has returned != S_OK");

    //
    // Cram in a ItemMoniker to test its comparision stuff.
    //
    hr = CreateItemMoniker(L"!",L"KevinRo",&pmkItem1);
    TEST_FAILED_HR(FAILED(hr),
                "Creating Item Moniker KevinRo");

    hr = CreateItemMoniker(L"!",L"SueA",&pmkItem2);
    TEST_FAILED_HR(FAILED(hr),
                "Creating Item Moniker SueA");

    DWORD dwKevinRo;
    DWORD dwSueA;

    hr = prot->Register(0,pmkItem1,pmkItem1,&dwKevinRo);
    TEST_FAILED_HR(FAILED(hr),
        "Register KevinRo with ROT failed in IsRunning");

    hr = prot->Register(0,pmkItem2,pmkItem2,&dwSueA);
    TEST_FAILED_HR(FAILED(hr),
        "Register SueA with ROT failed in IsRunning");

    //
    // Now revoke monikers
    //
    hr = prot->Revoke(dwRegister);
    TEST_FAILED_HR(FAILED(hr),
        "Revoke with ROT failed in IsRunning");
    //
    // We shouldn't find the moniker in the ROT
    //
    hr = pmk1->IsRunning(pbc,NULL,NULL);
    TEST_FAILED_HR((hr != S_FALSE),
                "IsRunning returns other than S_FALSE");

    //
    // Now revoke the item monikers.
    //
    hr = prot->Revoke(dwKevinRo);
    TEST_FAILED_HR(FAILED(hr),
        "Revoke with ROT failed in for KevinRo");

    hr = prot->Revoke(dwSueA);
    TEST_FAILED_HR(FAILED(hr),
        "Revoke with ROT failed in for SueA");

    //
    // An AntiMoniker
    //
    hr = CreateAntiMoniker(&pmkAnti);
    TEST_FAILED_HR(FAILED(hr),
    	"Failed creating AntiMoniker in Comparison Data Test");

    DWORD dwAnti;

    hr = prot->Register(0,pmkAnti,pmkAnti,&dwAnti);
    TEST_FAILED_HR(FAILED(hr),
        "Register Anti with ROT failed in IsRunning");

    hr = prot->IsRunning(pmkAnti);
    TEST_FAILED_HR((hr != S_OK),
        "IsRunning pmkAnti returns other than S_OK");

    //
    // Now revoke the 'other' monikers.
    //
    hr = prot->Revoke(dwAnti);
    TEST_FAILED_HR(FAILED(hr),
        "Revoke with ROT failed in for Anti");

    //
    // Test file monikers with long file names
    //

    // Creation
    hr = CreateFileMoniker(LongDirShort, &pmkLong1);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker for long short failed!")

    TEST_FAILED((pmkLong1 == NULL),
        "CreateFileMoniker returned a null moniker ptr\n")

    LAST_RELEASE(pmkLong1);

    // Equivalence with short name version
    hr = CreateFileMoniker(LongDirLong, &pmkLong1);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker for long long failed!")

    TEST_FAILED((pmkLong1 == NULL),
        "CreateFileMoniker returned a null moniker ptr\n")

#if 0
    // Debug code to print out the display name to check that long
    // names are handled correctly

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx File Moniker GetDisplayName failed!")

    hr = pmkLong1->GetDisplayName(pbc, NULL, &szName);

    //  release it
    pbc.Set(NULL, FALSE);

    TEST_FAILED_HR(FAILED(hr), "File Moniker GetDisplayName failed!");

    wprintf(L"Display name: '%s', %d\n", szName, wcslen(szName));

    // Free the path
    pIMalloc->Free(szName);
#endif

    hr = CreateFileMoniker(LongDirLongSe, &pmkLong2);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker for long long se failed!")

    TEST_FAILED((pmkLong2 == NULL),
        "CreateFileMoniker returned a null moniker ptr\n")

    TEST_FAILED(pmkLong1->IsEqual(pmkLong2) != S_OK,
        "Long file monikers not equal\n");

#if 0


    // Debug code to print out the display name to check that long
    // names are handled correctly

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx File Moniker GetDisplayName failed!")

    hr = pmkLong2->GetDisplayName(pbc, NULL, &szName);

    //  release it
    pbc.Set(NULL, FALSE);

    TEST_FAILED_HR(FAILED(hr), "File Moniker GetDisplayName failed!");

    wprintf(L"Display name: '%s', %d\n", szName, wcslen(szName));

    // Free the path
    pIMalloc->Free(szName);
#endif

    LAST_RELEASE(pmkLong1);
    LAST_RELEASE(pmkLong2);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\olebind\tmalloc.cxx ===
#include    <windows.h>
#include    <stdio.h>
#include    <ole2.h>
#include    <olebind.hxx>

BOOL TestStdMalloc(void)
{
    // Get the allocator
    IMalloc *pIMalloc;
    HRESULT hr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);

    TEST_FAILED_HR(FAILED(hr), "CoGetMalloc failed");

    // Test AddRef/Release
    ULONG cOrigRefs = pIMalloc->AddRef();

#ifdef WIN32
    //  On Win32, we only guarantee that the reference count will be either
    //  zero (if we released the object) or nonzero (if we didn't)
    TEST_FAILED((pIMalloc->Release() == 0),
	"IMalloc: Wrong refcount");
#else
    TEST_FAILED((pIMalloc->Release() != cOrigRefs - 1),
	"IMalloc: Wrong refcount");
#endif

    // Test query interface
    IUnknown *punk;

    hr = pIMalloc->QueryInterface(IID_IMalloc, (void **) &punk);

    TEST_FAILED_HR(FAILED(hr), "IMalloc QueryInterface failed");

    punk->Release();

    // Test allocation
    BYTE *pb = (BYTE *) pIMalloc->Alloc(2048);

    // Test get size
    TEST_FAILED((pIMalloc->GetSize(pb) < 2048), "GetSize failed");

    TEST_FAILED((pb == NULL), "Alloc returned NULL");

    for (int i = 0; i < 2048; i++)
    {
	pb[i] = 'A';
    }

    // Test reallocation to larger buffer
    pb = (BYTE *) pIMalloc->Realloc(pb, 4096);

    TEST_FAILED((pb == NULL), "Realloc larger returned NULL");

    for (i = 0; i < 2048; i++)
    {
	TEST_FAILED((pb[i] != 'A'), "Buffer corrupt on larger realloc");
    }

    // Test reallocation to smaller buffer
    pb = (BYTE *) pIMalloc->Realloc(pb, 990);

    TEST_FAILED((pb == NULL), "Realloc smaller returned NULL");

    for (i = 0; i < 990; i++)
    {
	TEST_FAILED((pb[i] != 'A'), "Buffer corrupt on smaller realloc");
    }

    // Test get size (size is allowed to be larger, but not smaller)
    TEST_FAILED((pIMalloc->GetSize(pb) < 990), "GetSize failed");

    // Test DidAllocate
    TEST_FAILED((pIMalloc->DidAlloc(pb) == 0), "Didalloc failed");

    // Test freeing the buffer
    pIMalloc->Free(pb);

    // Do last release
    pIMalloc->Release();

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\ole1\srvrdemo\srvrdemo.h ===
/*
  OLE SERVER DEMO
  SrvrDemo.h

  This file contains typedefs, defines, global variable declarations, and
  function prototypes.

  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
*/



/*
   Explanation of Function Comments.

   Every function has a comment preceding it which gives the following
   information:

   1) Function name.
   2) A description of what the function does.
   3) A list of parameters, each with its type and a short description.
   4) A list of return values, each with an explanation of the condition that
      will cause the function to return that value.
   5) A customization section giving tips on how to customize this function
      for your OLE application.
      If the customization section says "None" then you may find the function
      usable as is.
      If the customization section says "Re-implement" then the function
      should still serve the same purpose and do what is indicated in the
      function comment, but will probably need to be re-implemented for
      your particular application.  Any Server Demo code relating to OLE
      will be useful as a guide in your re-implementation.
      If the customization section says "Server Demo specific" then the
      function will probably have no counterpart in your application.
*/


/* Menu Identifiers */

// File menu

#define IDM_NEW      100
#define IDM_OPEN     101
#define IDM_SAVE     102
#define IDM_SAVEAS   103
#define IDM_EXIT     104
#define IDM_ABOUT    105
#define IDM_UPDATE   106

// Edit menu

#define IDM_CUT      107
#define IDM_COPY     108
#define IDM_DELETE   109

// Color menu

#define IDM_RED      110
#define IDM_GREEN    111
#define IDM_BLUE     112
#define IDM_WHITE    113
#define IDM_GRAY     114
#define IDM_CYAN     115
#define IDM_MAGENTA  116
#define IDM_YELLOW   117

// New object menu

#define IDM_NEWOBJ   118
#define IDM_NEXTOBJ  119

#define IDD_CONTINUEEDIT    120
#define IDD_UPDATEEXIT      121
#define IDD_TEXT            122

#define OBJECT_WIDTH        120
#define OBJECT_HEIGHT       60

// number HIMETRIC units per inch
#define  HIMETRIC_PER_INCH  2540

/* Types */

// Document type

typedef enum
{
    doctypeNew,      // The document is untitled.
    doctypeFromFile, // The document exists in a file and may be linked.
    doctypeEmbedded  // The document is an embedded document.
} DOCTYPE;


// Device context type, passed to DrawObj.

typedef enum
{
   dctypeScreen,
   dctypeBitmap,
   dctypeMetafile,
   dctypeEnhMetafile
} DCTYPE ;


// Version

typedef WORD VERSION;


// Verb

typedef enum
{
   verbPlay = OLEVERB_PRIMARY,
   verbEdit
} VERB;


// Server structure

typedef struct
{
    OLESERVER     olesrvr;        // This must be the first field so that
                                  //   an LPOLESERVER can be cast to a SRVR*.
    LHSERVER      lhsrvr;         // Registration handle
} SRVR ;


// How many objects (distinct numbers) will we allow?
#define cfObjNums 20

// How many distinct clients can be associated with the object?
#define clpoleclient 20


// Document structure

typedef struct
{
    OLESERVERDOC oledoc;      // This must be the first field so that an
                              //   LPOLESERVERDOC can be cast to an DOC*.
    LHSERVERDOC  lhdoc;       // Registration handle
    DOCTYPE      doctype;     // Document type
    ATOM         aName;       // Document name
    HPALETTE     hpal;        // Handle to a logical color palette
    BYTE         rgfObjNums[cfObjNums+1]; // What object numbers have been used
} DOC, *DOCPTR ;


// Native data structure

typedef struct
{
    INT         idmColor;
    INT         nWidth;
    INT         nHeight;
    INT         nX;
    INT         nY;
    INT         nHiMetricWidth;  // Used by an object handler.  These two fields
    INT         nHiMetricHeight; // always correspond to nWidth and nHeight.
    VERSION     version;
    CHAR        szName[10];      // "Object nn"
} NATIVE, FAR *LPNATIVE;


// Object structure

/* Ordinarily, an OBJ structure would not contain native data.  Rather, it
   would contain a pointer (or some other reference) to the native data.
   This method would allow multiple objects containing the same native data.
   Each OBJ structure would be created on the fly when some portion of the
   document was to be made into an object.  Each OBJ structure would have
   only one LPOLECLIENT, which would be passed in to DocGetObject.
*/

typedef struct
{
    OLEOBJECT   oleobject;   // This must be the first field so that an
                             //   LPOLEOBJECT can be cast to a LPOBJ.
    HANDLE      hObj;        // A circular handle to this structure,
                             //   used to delete this structure.
    LPOLECLIENT lpoleclient[clpoleclient];
                             // Clients associated with the object.
                             //   The array is NULL terminated.
    HWND        hwnd;        // The object's own window
    ATOM        aName;       // Unique identifier for each object within a doc
    HPALETTE    hpal;        // Logical palette to use in drawing object
    NATIVE      native;      // Object data in native format
} OBJ, FAR *LPOBJ ;

typedef struct {
    CHAR     *pClassName;
    CHAR     *pFileSpec;
    CHAR     *pHumanReadable;
    CHAR     *pExeName;
}  CLASS_STRINGS;



/* Defines */

// The name of the application, used in message boxes and title bars.
#define szAppName        "Server Demo10"

// THe class name in the registration database.
#define szClassName      "SrvrDemo10"

// Used to check for "-Embedding" on command line.
#define szEmbeddingFlag  "Embedding"

// Maximum length of a fully-qualified pathname.
#define cchFilenameMax   256

// Maximum number of HBRUSHes.
#define chbrMax          9

// Number of extra bytes in the window structure for an object
#define cbWindExtra 4

// Offset (in the extra space) of the pointer to the object
#define ibLpobj          0



/* Global variable declarations.  (See SrvrDemo.c for descriptions.) */

extern HANDLE           hInst;
extern HWND             hwndMain;
extern SRVR             srvrMain;
extern DOC              docMain;
extern BOOL             fDocChanged;
extern BOOL             fEmbedding;
extern BOOL             fRevokeSrvrOnSrvrRelease;
extern BOOL             fWaitingForDocRelease;
extern BOOL             fWaitingForSrvrRelease;
extern BOOL             fUnblock;
extern CHAR             szClient[];
extern CHAR             szClientDoc[];
extern HBRUSH           hbrColor[chbrMax];
extern VERSION          version;
extern OLECLIPFORMAT    cfObjectLink;
extern OLECLIPFORMAT    cfOwnerLink;
extern OLECLIPFORMAT    cfNative;
extern OLESERVERDOCVTBL docvtbl;
extern OLEOBJECTVTBL    objvtbl;
extern OLESERVERVTBL    srvrvtbl;



/* Function Prototypes */

// Various functions

BOOL  CreateDocFromFile (LPSTR lpszDoc, LHSERVERDOC lhdoc, DOCTYPE doctype);
BOOL  CreateNewDoc (LONG lhdoc, LPSTR lpszDoc, DOCTYPE doctype);
LPOBJ CreateNewObj (BOOL fDoc_Changed);
VOID  CutOrCopyObj (BOOL fOpIsCopy);
VOID  DestroyDoc (VOID);
VOID  DestroyObj (HWND hwnd);
VOID  DeviceToHiMetric ( LPPOINT lppt);
VOID  EmbeddingModeOff (VOID) ;
VOID  EmbeddingModeOn (VOID);
VOID  UpdateFileMenu (INT);
VOID  ErrorBox (CHAR *jwf);
BOOL  GetFileOpenFilename (LPSTR lpszFilename);
BOOL  GetFileSaveFilename (LPSTR lpszFilename);
VOID  HiMetricToDevice ( LPPOINT lppt);
LPOBJ HwndToLpobj (HWND hwndObj);
BOOL  InitServer (HWND hwnd, HANDLE hInst);
VOID  InitVTbls (VOID);
BOOL  OpenDoc (VOID);
VOID  PaintObj (HWND hwnd);
OLESTATUS RevokeDoc (VOID);
VOID  RevokeObj (LPOBJ lpobj);
INT   SaveChangesOption (BOOL *pfUpdateLater);
BOOL  SaveDoc (VOID);
BOOL  SaveDocAs (VOID);
VOID  SavedServerDoc (VOID);
LPOBJ SelectedObject (VOID);
HWND  SelectedObjectWindow (VOID);
VOID  SendDocMsg (WORD wMessage );
VOID  SendObjMsg (LPOBJ lpobj, WORD wMessage);
VOID  SetTitle (LPSTR lpszDoc, BOOL bEmbedded);
VOID  SetHiMetricFields (LPOBJ lpobj);
VOID  SizeClientArea (HWND hwndMain, RECT rectReq, BOOL fFrame);
VOID  SizeObj (HWND hwnd, RECT rect, BOOL fMove);
OLESTATUS StartRevokingServer (VOID);
VOID  Wait (BOOL *pf);
LPSTR Abbrev (LPSTR lpsz);
INT_PTR CALLBACK fnFailedUpdate (HWND, UINT, WPARAM, LONG);
int   Main(USHORT argc, CHAR **argv) ;

// Window handlers

INT_PTR CALLBACK About       (HWND, UINT, WPARAM, LPARAM);
LONG  APIENTRY MainWndProc (HWND, UINT, WPARAM, LPARAM);
LONG  APIENTRY ObjWndProc  (HWND, UINT, WPARAM, LPARAM);


// Server methods

OLESTATUS  APIENTRY SrvrCreate (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS  APIENTRY SrvrCreateFromTemplate (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS  APIENTRY SrvrEdit (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR * );
OLESTATUS  APIENTRY SrvrExecute (LPOLESERVER, HANDLE);
OLESTATUS  APIENTRY SrvrExit (LPOLESERVER);
OLESTATUS  APIENTRY SrvrOpen (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS  APIENTRY SrvrRelease (LPOLESERVER);

// Document methods

OLESTATUS  APIENTRY DocClose (LPOLESERVERDOC);
OLESTATUS  APIENTRY DocExecute (LPOLESERVERDOC, HANDLE);
OLESTATUS  APIENTRY DocGetObject (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR *, LPOLECLIENT);
OLESTATUS  APIENTRY DocRelease (LPOLESERVERDOC);
OLESTATUS  APIENTRY DocSave (LPOLESERVERDOC);
OLESTATUS  APIENTRY DocSetColorScheme (LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
OLESTATUS  APIENTRY DocSetDocDimensions (LPOLESERVERDOC, OLE_CONST RECT FAR *);
OLESTATUS  APIENTRY DocSetHostNames (LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);

// Object methods

OLESTATUS  APIENTRY ObjDoVerb (LPOLEOBJECT, UINT, BOOL, BOOL);
OLESTATUS  APIENTRY ObjGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
LPVOID     APIENTRY ObjQueryProtocol (LPOLEOBJECT, OLE_LPCSTR);
OLESTATUS  APIENTRY ObjRelease (LPOLEOBJECT);
OLESTATUS  APIENTRY ObjSetBounds (LPOLEOBJECT, OLE_CONST RECT FAR*);
OLESTATUS  APIENTRY ObjSetColorScheme (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
OLESTATUS  APIENTRY ObjSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS  APIENTRY ObjSetTargetDevice (LPOLEOBJECT, HANDLE);
OLESTATUS  APIENTRY ObjShow (LPOLEOBJECT, BOOL);
OLECLIPFORMAT  APIENTRY ObjEnumFormats (LPOLEOBJECT, OLECLIPFORMAT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oledll2\chicago\makefile.inc ===
obj\i386\oledll2.def: oledll2.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oledll2\oledll2.c ===
//+-------------------------------------------------------------------
//
//  File:       oledll2.c
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      FunctionInAnotherDLL
//
//              This DLL is used to to test loading of in
//              InProcServer that uses another statically linked DLL.  
//              The extra DLL (OleDll2.DLL) should not be on the path 
//              when the test is run.  The entry point FuntionInAnotherDLL
//              is exported by OleDll2.DLL
//
//
//  History:	30-Jun-94      AndyH        Created
//
//---------------------------------------------------------------------

#include    <windows.h>
#include    "oledll2.h"

//+-------------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------



//
//  Entry point to DLL is traditional LibMain
//


BOOL _cdecl LibMain ( HINSTANCE hinst,
                          HANDLE    segDS,
                          UINT      cbHeapSize,
			  LPTSTR    lpCmdLine)
{
    return TRUE;
}


//+-------------------------------------------------------------------
//
//  Function:   FunctionInAnotherDLL
//
//  Synopsis:   Does nothing. 
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    30-Jun-94  AndyH   Created
//
//--------------------------------------------------------------------



//
//  Entry point for testing statically linked DLL.
//


BOOL FunctionInAnotherDLL ( void )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\olebind\widewrap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       widewrap.h
//
//  Contents:   Wrapper functions for Win32c API used by 32-bit OLE 2
//
//  History:    12-27-93   ErikGav   Created
//              06-14-94   KentCe    Various Chicago build fixes.
//
//----------------------------------------------------------------------------

#ifndef _WIDEWRAP_H_
#define _WIDEWRAP_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING WIDEWRAP.H from " __FILE__)
#endif  /* RC_INVOKED */

#ifdef _CHICAGO_

#ifdef __cplusplus
extern "C" {
#endif

#undef  WNDCLASS
#define WNDCLASS WNDCLASSW
#define WNDCLASST WNDCLASSA

#undef  STARTUPINFO
#define STARTUPINFO STARTUPINFOW

#undef  WIN32_FIND_DATA
#define WIN32_FIND_DATA WIN32_FIND_DATAW

HANDLE
WINAPI
CreateFileX(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

#undef  CreateFile
#define CreateFile CreateFileX
#define CreateFileT CreateFileA

BOOL
WINAPI
DeleteFileX(
    LPCWSTR lpFileName
    );

#undef  DeleteFile
#define DeleteFile DeleteFileX
#define DeleteFileT DeleteFileA

UINT
WINAPI
RegisterClipboardFormatX(
    LPCWSTR lpszFormat);

#undef  RegisterClipboardFormat
#define RegisterClipboardFormat RegisterClipboardFormatX
#define RegisterClipboardFormatT RegisterClipboardFormatA

int
WINAPI
GetClipboardFormatNameX(
    UINT format,
    LPWSTR lpszFormatName,
    int cchMaxCount);

#undef  GetClipboardFormatName
#define GetClipboardFormatName GetClipboardFormatNameX
#define GetClipboardFormatNameT GetClipboardFormatNameA

LONG
APIENTRY
RegOpenKeyX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

#undef  RegOpenKey
#define RegOpenKey RegOpenKeyX
#define RegOpenKeyT RegOpenKeyA

LONG
APIENTRY
RegQueryValueX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpValue,
    PLONG   lpcbValue
    );

#undef  RegQueryValue
#define RegQueryValue RegQueryValueX
#define RegQueryValueT RegQueryValueA
LONG
APIENTRY
RegSetValueX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );

#undef  RegSetValue
#define RegSetValue RegSetValueX
#define RegSetValueT RegSetValueA

LONG
APIENTRY
RegSetValueExX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwReserved,
    DWORD dwType,
    LPBYTE lpData,
    DWORD cbData
    );

#undef  RegSetValueEx
#define RegSetValueEx RegSetValueExX
#define RegSetValueExT RegSetValueExA


UINT
WINAPI
RegisterWindowMessageX(
    LPCWSTR lpString);

#undef  RegisterWindowMessage
#define RegisterWindowMessage RegisterWindowMessageX
#define RegisterWindowMessageT RegisterWindowMessageA

LONG
APIENTRY
RegOpenKeyExX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

#undef  RegOpenKeyEx
#define RegOpenKeyEx RegOpenKeyExX
#define RegOpenKeyExT RegOpenKeyExA

LONG
APIENTRY
RegQueryValueExX (
    HKEY hKey,
    LPWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

#undef  RegQueryValueEx
#define RegQueryValueEx RegQueryValueExX
#define RegQueryValueExT RegQueryValueExA

HWND
WINAPI
CreateWindowExX(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);

#undef  CreateWindowEx
#define CreateWindowEx CreateWindowExX
#define CreateWindowExT CreateWindowExA

ATOM
WINAPI
RegisterClassX(
    CONST WNDCLASSW *lpWndClass);

#undef  RegisterClass
#define RegisterClass RegisterClassX
#define RegisterClassT RegisterClassA

BOOL
WINAPI
UnregisterClassX(
    LPCWSTR lpClassName,
    HINSTANCE hInstance);

#undef  UnregisterClass
#define UnregisterClass UnregisterClassX
#define UnregisterClassT UnregisterClassA

int WINAPIV wsprintfX(LPWSTR pwszOut, LPCWSTR pwszFormat, ...);

#undef  wsprintf
#define wsprintf wsprintfX
#define wsprintfT wsprintfA

HWND
WINAPI
CreateWindowX(
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);

#undef  CreateWindow
#define CreateWindow CreateWindowX
#define CreateWindowT CreateWindowA

HANDLE
WINAPI
GetPropX(
    HWND hWnd,
    LPCWSTR lpString);

#undef  GetProp
#define GetProp GetPropX
#define GetPropT GetPropA

BOOL
WINAPI
SetPropX(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData);

#undef  SetProp
#define SetProp SetPropX
#define SetPropT SetPropA

HANDLE
WINAPI
RemovePropX(
    HWND hWnd,
    LPCWSTR lpString);

#undef  RemoveProp
#define RemoveProp RemovePropX
#define RemovePropT RemovePropA

UINT
WINAPI
GetProfileIntX(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
    );

#undef  GetProfileInt
#define GetProfileInt GetProfileIntX
#define GetProfileIntT GetProfileIntA

ATOM
WINAPI
GlobalAddAtomX(
    LPCWSTR lpString
    );

#undef  GlobalAddAtom
#define GlobalAddAtom GlobalAddAtomX
#define GlobalAddAtomT GlobalAddAtomA

UINT
WINAPI
GlobalGetAtomNameX(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );

#undef  GlobalGetAtomName
#define GlobalGetAtomName GlobalGetAtomNameX
#define GlobalGetAtomNameT GlobalGetAtomNameA

DWORD
WINAPI
GetModuleFileNameX(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#undef  GetModuleFileName
#define GetModuleFileName GetModuleFileNameX
#define GetModuleFileNameT GetModuleFileNameA

LPWSTR
WINAPI
CharPrevX(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent);

#undef  CharPrev
#define CharPrev CharPrevX
#define CharPrevT CharPrevA

HFONT   WINAPI CreateFontX(int, int, int, int, int, DWORD,
                             DWORD, DWORD, DWORD, DWORD, DWORD,
                             DWORD, DWORD, LPCWSTR);
#undef  CreateFont
#define CreateFont CreateFontX
#define CreateFontT CreateFontA

HMODULE
WINAPI
LoadLibraryX(
    LPCWSTR lpLibFileName
    );

#undef  LoadLibrary
#define LoadLibrary LoadLibraryX
#define LoadLibraryT LoadLibraryA

HMODULE
WINAPI
LoadLibraryExX(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );

#undef  LoadLibraryEx
#define LoadLibraryEx LoadLibraryExX
#define LoadLibraryExT LoadLibraryExA

LONG
APIENTRY
RegDeleteKeyX (
    HKEY hKey,
    LPCWSTR lpSubKey
    );

#undef  RegDeleteKey
#define RegDeleteKey RegDeleteKeyX
#define RegDeleteKeyT RegDeleteKeyA

#undef  RpcStringBindingCompose
#define RpcStringBindingCompose RpcStringBindingComposeW

#undef  RpcBindingFromStringBinding
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW

#undef  RpcStringFree
#define RpcStringFree RpcStringFreeW

BOOL
WINAPI
CreateProcessX(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

#undef  CreateProcess
#define CreateProcess CreateProcessX
#define CreateProcessT CreateProcessA

LONG
APIENTRY
RegEnumKeyExX (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

#undef  RegEnumKeyEx
#define RegEnumKeyEx RegEnumKeyExX
#define RegEnumKeyExT RegEnumKeyExA

#undef  RpcServerUseProtseqEp
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW

BOOL
WINAPI
AppendMenuX(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDNewItem,
    LPCWSTR lpNewItem
    );

#undef  AppendMenu
#define AppendMenu AppendMenuX
#define AppendMenuT AppendMenuA

HANDLE
WINAPI
OpenEventX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

#undef  OpenEvent
#define OpenEvent OpenEventX
#define OpenEventT OpenEventA

HANDLE
WINAPI
CreateEventX(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );

#undef  CreateEvent
#define CreateEvent CreateEventX
#define CreateEventT CreateEventA

UINT
WINAPI
GetDriveTypeX(
    LPCWSTR lpRootPathName
    );

#undef  GetDriveType
#define GetDriveType GetDriveTypeX
#define GetDriveTypeT GetDriveTypeA

DWORD
WINAPI
GetFileAttributesX(
    LPCWSTR lpFileName
    );

#undef  GetFileAttributes
#define GetFileAttributes GetFileAttributesX
#define GetFileAttributesT GetFileAttributesA

LONG
APIENTRY
RegEnumKeyX (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );

#undef  RegEnumKey
#define RegEnumKey RegEnumKeyX
#define RegEnumKeyT RegEnumKeyA

HANDLE
WINAPI
FindFirstFileX(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );

#undef  FindFirstFile
#define FindFirstFile FindFirstFileX
#define FindFirstFileT FindFirstFileA

#undef  RegisterProtseq
#define RegisterProtseq RegisterProtseqW

#undef  RpcStringBindingParse
#define RpcStringBindingParse RpcStringBindingParseW

#undef  RpcNetworkIsProtseqValid
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW

#undef  RpcBindingToStringBinding
#define RpcBindingToStringBinding RpcBindingToStringBindingW

#undef  RpcServerUseProtseq
#define RpcServerUseProtseq RpcServerUseProtseqW

BOOL
WINAPI
GetComputerNameX (
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

#undef  GetComputerName
#define GetComputerName GetComputerNameX
#define GetComputerNameT GetComputerNameA

#undef  Foo
#define Foo FooW

#undef  Foo
#define Foo FooW

#undef  Foo
#define Foo FooW

//The following force Chicago to directly use the ANSI versions

#undef  DefWindowProc
#define DefWindowProc   DefWindowProcA

#undef  CopyMetaFile                       // Currently str ptr is always
#define CopyMetaFile    CopyMetaFileA      // null, write a wrapper if this
                                           // changes
#undef  CreateMetaFile
#define CreateMetaFile  CreateMetaFileA

#undef  PostMessage
#define PostMessage     PostMessageA

#undef  SendMessage
#define SendMessage     SendMessageA

#undef  PeekMessage
#define PeekMessage     PeekMessageA

#undef  DispatchMessage
#define DispatchMessage DispatchMessageA

#undef  GetWindowLong
#define GetWindowLong GetWindowLongA

#undef  SetWindowLong
#define SetWindowLong SetWindowLongA

DWORD
WINAPI
GetShortPathNameX(
    LPCWSTR lpszLongPath,
    LPWSTR lpszShortPath,
    DWORD cchBuffer
    );

#undef  GetShortPathName
#define GetShortPathName GetShortPathNameX
#define GetShortPathNameT GetShortPathNameA

DWORD
WINAPI
GetFullPathNameX(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

#undef  GetFullPathName
#define GetFullPathName GetFullPathNameX
#define GetFullPathNameT GetFullPathNameA

DWORD
WINAPI
SearchPathX(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

#undef SearchPath
#define SearchPath SearchPathX
#define SearchPathT SearchPathA

ATOM
WINAPI
GlobalFindAtomX(
    LPCWSTR lpString
    );

#undef GlobalFindAtom
#define GlobalFindAtom GlobalFindAtomX
#define GlobalFindAtomT GlobalFindAtomA

int
WINAPI
GetClassNameX(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount);

#undef GetClassName
#define GetClassName GetClassNameX
#define GetClassNameT GetClassNameA

int
WINAPI
lstrlenX(LPCWSTR lpString);

#undef lstrlen
#define lstrlen lstrlenX
#define lstrlenT lstrlenA

LPWSTR
WINAPI
lstrcatX(
    LPWSTR lpString1,
    LPCWSTR lpString2);

#undef lstrcat
#define lstrcat lstrcatX
#define lstrcatT lstrcatA



int
WINAPI
lstrcmpX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );

#undef lstrcmp
#define lstrcmp lstrcmpX
#define lstrcmpT lstrcmpA

int
WINAPI
lstrcmpiX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );

#undef lstrcmpi
#define lstrcmpi lstrcmpiX
#define lstrcmpiT lstrcmpiA

LPWSTR
WINAPI
lstrcpyX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );

#undef lstrcpy
#define lstrcpy lstrcpyX
#define lstrcpyT lstrcpyA

HANDLE
WINAPI
CreateFileMappingX(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );

#undef CreateFileMapping
#define CreateFileMapping CreateFileMappingX
#define CreateFileMappingT CreateFileMappingA

HANDLE
WINAPI
OpenFileMappingX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

#undef OpenFileMapping
#define OpenFileMapping OpenFileMappingX
#define OpenFileMappingT OpenFileMappingA

#ifdef __cplusplus
}
#endif

#else
//
// These are the definitions for NT
//
#define CreateFileT CreateFileW
#define DeleteFileT DeleteFileW
#define RegisterClipboardFormatT RegisterClipboardFormatW
#define GetClipboardFormatNameT GetClipboardFormatNameW
#define RegOpenKeyT RegOpenKeyW
#define RegQueryValueT RegQueryValueW
#define RegSetValueT RegSetValueW
#define RegSetValueExT RegSetValueExW
#define RegisterWindowMessageT RegisterWindowMessageW
#define RegOpenKeyExT RegOpenKeyExW
#define RegQueryValueExT RegQueryValueExW
#define CreateWindowExT CreateWindowExW
#define RegisterClassT RegisterClassW
#define UnregisterClassT UnregisterClassW
#define wsprintfT wsprintfW
#define CreateWindowT CreateWindowW
#define GetPropT GetPropW
#define SetPropT SetPropW
#define RemovePropT RemovePropW
#define GetProfileIntT GetProfileIntW
#define GlobalAddAtomT GlobalAddAtomW
#define GlobalGetAtomNameT GlobalGetAtomNameW
#define GetModuleFileNameT GetModuleFileNameW
#define CharPrevT CharPrevW
#define CreateFontT CreateFontW
#define LoadLibraryT LoadLibraryW
#define LoadLibraryExT LoadLibraryExW
#define RegDeleteKeyT RegDeleteKeyW
#define CreateProcessT CreateProcessW
#define RegEnumKeyExT RegEnumKeyExW
#define AppendMenuT AppendMenuW
#define OpenEventT OpenEventW
#define CreateEventT CreateEventW
#define GetDriveTypeT GetDriveTypeW
#define GetFileAttributesT GetFileAttributesW
#define RegEnumKeyT RegEnumKeyW
#define FindFirstFileT FindFirstFileW
#define GetComputerNameT GetComputerNameW
#define GetShortPathNameT GetShortPathNameW
#define GetFullPathNameT GetFullPathNameW
#define SearchPathT SearchPathW
#define GlobalFindAtomT GlobalFindAtomW
#define GetClassNameT GetClassNameW
#define lstrlenT lstrlenW
#define lstrcatT lstrcatW
#define lstrcmpT lstrcmpW
#define lstrcmpiT lstrcmpiW
#define lstrcpyT lstrcpyW
#define CreateFileMappingT CreateFileMappingW
#define OpenFileMappingT OpenFileMappingW
#define WNDCLASST WNDCLASSW

#endif  // _CHICAGO_

#endif  // _WIDEWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oleexts\oleexts.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       oleexts.h
//
//  Contents:   macros useful for OLE debugger extensions
//
//  Classes:    none
//
//  Functions:  macros for: dprintf
//                          GetExpression
//                          GetSymbol
//                          Disassm
//                          CheckControlC
//                          DECLARE_API(...)
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#ifndef _OLEEXTS_H_
#define _OLEEXTS_H_

//
//  NTSD_EXTENSION_APIS defined in ntsdexts.h
//
//  typedef struct _NTSD_EXTENSION_APIS {
//      DWORD                   nSize;
//      PNTSD_OUTPUT_ROUTINE    lpOutputRoutine;
//      PNTSD_GET_EXPRESSION    lpGetExpressionRoutine;
//      PNTSD_GET_SYMBOL        lpGetSymbolRoutine;
//      PNTSD_DISASM            lpDisasmRoutine
//      PNTSD_CHECK_CONTROL_C   lpCheckControlCRoutine;
//  }; NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS
//
//  the following macros assume global: NTSD_EXTENSION_APIS ExtensionApis

// formatted print like CRT printf
// void dprintf(char *format [, argument] ...);
#define dprintf         (ExtensionApis.lpOutputRoutine)

// returns value of expression
// DWORD GetExpression(char *expression);
#define GetExpression   (ExtensionApis.lpGetExpressionRoutine)

// locates the nearest symbol
// void GetSymbol(LPVOID address, PUCHAR buffer, LPDWORD lpdwDisplacement);
#define GetSymbol       (ExtensionApis.lpGetSymbolRoutine)

// Disassembles an instruction
// DWORD Disassm(LPDWORD lpdwOffset, LPSTR lpBuffer, BOOL fShowEffectiveAddress);
#define Disassm         (ExtensionApis.lpGetDisasmRoutine)

// did user press CTRL+C
// BOOL CheckControlC(void);
#define CheckControlC   (ExtensionApis.lpCheckControlCRoutine)

//+-------------------------------------------------------------------------
//
//  Function Macro: DECLARE_API(...)
//
//  Synopsis:   definition for an NTSD debugger extension function
//
//  Effects:
//
//  Arguments:  [hCurrentProcess]   - Handle to current process
//              [hCurrentThread]    - Handle to current thread
//              [dwCurrentPc]       - Copy of the program counter
//              [lpExtenisonApis]   - pointer to NTSD_EXTENSION_APIS
//                                    (structure function pointers for NTSD)
//              [args]              - a string of arguments from NTSD cmd line
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              we use a function macro for defining our debugger extensions
//              functions to allow for easy extensibility
//
//              !!!function names MUST be lower case!!!
//
//--------------------------------------------------------------------------

#define DECLARE_API(s)                              \
        VOID                                        \
        s(                                          \
            HANDLE               hCurrentProcess,   \
            HANDLE               hCurrentThread,    \
            DWORD                dwCurrentPc,       \
            PNTSD_EXTENSION_APIS lpExtensionApis,   \
            LPSTR                args               \
            )

#endif // _OLEEXTS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oleexts\oleexts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       oleexts.cpp
//
//  Contents:   ntsd and windbg debugger extension
//
//  Classes:    none
//
//  Functions:
//              operator new    (global)
//              operator delete (global)
//              sizeofstring
//              dprintfx
//              dump_saferefcount
//              dump_threadcheck
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <imagehlp.h>
#include <ntsdexts.h>

#include <le2int.h>
#include <oaholder.h>
#include <daholder.h>
#include <olerem.h>
#include <defhndlr.h>
#include <deflink.h>
#include <olecache.h>
#include <cachenod.h>
#include <clipdata.h>
#include <mf.h>
#include <emf.h>
#include <gen.h>
#include <defcf.h>
#include <dbgdump.h>

#include "oleexts.h"

// structure of function pointers
NTSD_EXTENSION_APIS ExtensionApis;

//+-------------------------------------------------------------------------
//
//  Function:   operator new (global), internal
//
//  Synopsis:   allocate memory
//
//  Effects:
//
//  Arguments:  [cb]    - number of bytes to allocate
//
//  Requires:   CoTaskMemAlloc
//
//  Returns:    pointer to allocated memory
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              we define our own operator new so that we do not need to link
//              with the CRT library
//
//              we must also define our own global operator delete
//
//--------------------------------------------------------------------------

void * __cdecl
::operator new(unsigned int cb)
{
    return CoTaskMemAlloc(cb);
}

//+-------------------------------------------------------------------------
//
//  Function:   operator delete (global), internal
//
//  Synopsis:   free memory
//
//  Effects:
//
//  Arguments:  [p] - pointer to the memory to free
//
//  Requires:   CoTaskMemFree
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  check to see if pointer is valid
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              we define our own operator delete so that we do not need
//              to link with the CRT library
//
//              we must also define our own global operator new
//
//--------------------------------------------------------------------------

void __cdecl
::operator delete (void *p)
{
    // CoTaskMemFree takes care if the pointer is NULL
    CoTaskMemFree(p);
    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dprintfx, internal
//
//  Synopsis:   prints a formatted string in MAX_STRING_SIZE chunks
//
//  Effects:
//
//  Arguments:  [pszString] - null terminated string
//
//  Requires:   sizeofstring to calculate length of given string
//              dprintf (NTSD Extension API)
//              MAX_STRING_SIZE
//
//              !!!This requires the NTSD_EXTENSION_APIS global variable
//                 ExtensionApis to be initialize with the function
//                 pointers
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              NTSD has a limit of a 4K buffer...some of the character
//              arrays from Dump methods can be > 4K. this will
//              print a formatted string in chunks that NTSD can handle
//
//--------------------------------------------------------------------------

#define MAX_STRING_SIZE 1000

void dprintfx(char *pszString)
{
    char *pszFront;
    int size;
    char x;

    for (   pszFront = pszString,
            size = strlen(pszString);
            size > 0;
            pszFront += (MAX_STRING_SIZE - 1),
            size -= (MAX_STRING_SIZE - 1 )  )
    {
        if ( size > (MAX_STRING_SIZE - 1) )
        {
            x = pszFront[MAX_STRING_SIZE - 1];
            pszFront[MAX_STRING_SIZE - 1] = '\0';
            dprintf("%s", pszFront);
            pszFront[MAX_STRING_SIZE - 1] = x;
        }
        else
        {
            dprintf("%s", pszFront);
        }
    }
    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   help, exported
//
//  Synopsis:   print help message
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

DECLARE_API( help )
{
    ExtensionApis = *lpExtensionApis;

    if (*args == '\0') {
        dprintf("OLE DEBUGGER EXTENSIONS HELP:\n\n");
        dprintf("!symbol    (<address>|<symbol name>)   - Returns either the symbol name or address\n");

        dprintf("!dump_atom                 <address>      - Dumps a ATOM structure\n");
        dprintf("!dump_clsid                <address>      - Dumps a CLSID structure\n");
        dprintf("!dump_clipformat           <address>      - Dumps a CLIPFORMAT structure\n");
        dprintf("!dump_mutexsem             <address>      - Dumps a CMutexSem class\n");
        dprintf("!dump_filetime             <address>      - Dumps a FILETIME structure\n");
        dprintf("!dump_cachelist_item       <address>      - Dumps a CACHELIST_ITEM struct\n");
        dprintf("!dump_cacheenum            <address>      - Dumps a CCacheEnum class\n");
        dprintf("!dump_cacheenumformatetc   <address>      - Dumps a CCacheEnumFormatEtc class\n");
        dprintf("!dump_cachenode            <address>      - Dumps a CCacheNode class\n");
        dprintf("!dump_clipdataobject       <address>      - Dumps a CClipDataObject class\n");
        dprintf("!dump_clipenumformatetc    <address>      - Dumps a CClipEnumFormatEtc class\n");
        dprintf("!dump_daholder             <address>      - Dumps a CDAHolder class\n");
        dprintf("!dump_dataadvisecache      <address>      - Dumps a CDataAdviseCache class\n");
        dprintf("!dump_defclassfactory      <address>      - Dumps a CDefClassFactory class\n");
        dprintf("!dump_deflink              <address>      - Dumps a CDefLink class\n");
        dprintf("!dump_defobject            <address>      - Dumps a CDefObject class\n");
        dprintf("!dump_emfobject            <address>      - Dumps a CEMfObject class\n");
        dprintf("!dump_enumfmt              <address>      - Dumps a CEnumFmt class\n");
        dprintf("!dump_enumfmt10            <address>      - Dumps a CEnumFmt10 class\n");
        dprintf("!dump_enumstatdata         <address>      - Dumps a CEnumSTATDATA class\n");
        dprintf("!dump_enumverb             <address>      - Dumps a CEnumVerb class\n");
        dprintf("!dump_membytes             <address>      - Dumps a CMemBytes class\n");
        dprintf("!dump_cmemstm              <address>      - Dumps a CMemStm class\n");
        dprintf("!dump_mfobject             <address>      - Dumps a CMfObject class\n");
        dprintf("!dump_oaholder             <address>      - Dumps a COAHolder class\n");
        dprintf("!dump_olecache             <address>      - Dumps a COleCache class\n");
        dprintf("!dump_saferefcount         <address>      - Dumps a CSafeRefCount class\n");
        dprintf("!dump_threadcheck          <address>      - Dumps a CThreadCheck class\n");
        dprintf("!dump_formatetc            <address>      - Dumps a FORMATETC structure\n");
        dprintf("!dump_memstm               <address>      - Dumps a MEMSTM structure\n");
        dprintf("!dump_statdata             <address>      - Dumps a STATDATA structure\n");
        dprintf("!dump_stgmedium            <address>      - Dumps a STGMEDIUM\n");
        dprintf("\n");
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   symbol, exported
//
//  Synopsis:   given an address to a symbol, dumps the symbol name and offset
//              (given a symbol name, dump address and offset)
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

DECLARE_API( symbol )
{
    DWORD dwAddr;
    CHAR Symbol[64];
    DWORD Displacement;

    ExtensionApis = *lpExtensionApis;

    dwAddr = GetExpression(args);
    if ( !dwAddr ) {
        return;
    }

    GetSymbol((LPVOID)dwAddr,(unsigned char *)Symbol,&Displacement);
    dprintf("%s+%lx at %lx\n", Symbol, Displacement, dwAddr);
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_atom, exported
//
//  Synopsis:   dumps ATOM object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_atom)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_atom not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_clsid, exported
//
//  Synopsis:   dumps CLSID object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_clsid)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_clsid not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_clipformat, exported
//
//  Synopsis:   dumps CLIPFORMAT object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_clipformat)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_clipformat not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_mutexsem, exported
//
//  Synopsis:   dumps CMutexSem object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_mutexsem)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_mutexsem not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_filetime, exported
//
//  Synopsis:   dumps FILETIME object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_filetime)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_filetime not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_cachelist_item, exported
//
//  Synopsis:   dumps CACHELIST_ITEM object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_cachelist_item)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszCacheListItem;
    char            *blockCacheListItem = NULL;
    char            *blockCacheNode     = NULL;
    char            *blockPresObj       = NULL;
    char            *blockPresObjAF     = NULL;
    CACHELIST_ITEM  *pCacheListItem     = NULL;
    DWORD           dwSizeOfPresObj;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CACEHLIST_ITEM\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockCacheListItem = new char[sizeof(CACHELIST_ITEM)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCacheListItem,
                sizeof(CACHELIST_ITEM),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CACHELIST_ITEM \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CACHELIST_ITEM))
    {
        dprintf("Size of process memory read != requested(CACHELIST_ITEM\n");

        goto errRtn;
    }

    pCacheListItem = (CACHELIST_ITEM *)blockCacheListItem;

    if (pCacheListItem->lpCacheNode != NULL)
    {
        blockCacheNode = new char[sizeof(CCacheNode)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pCacheListItem->lpCacheNode,
                    blockCacheNode,
                    sizeof(CCacheNode),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CCacheNode \n");
            dprintf("at address %x\n", pCacheListItem->lpCacheNode);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CCacheNode))
        {
            dprintf("Size of process memory read != requested (CCacheNode)\n");

            goto errRtn;
        }

        pCacheListItem->lpCacheNode = (CCacheNode*)blockCacheNode;

        // need to get the OlePresObjs for the CCacheNode
        if (pCacheListItem->lpCacheNode->m_pPresObj != NULL)
        {
            switch (pCacheListItem->lpCacheNode->m_dwPresFlag)
            {
            case CN_PRESOBJ_GEN:
                dwSizeOfPresObj = sizeof(CGenObject);
                break;
            case CN_PRESOBJ_MF:
                dwSizeOfPresObj = sizeof(CMfObject);
                break;
            case CN_PRESOBJ_EMF:
                dwSizeOfPresObj = sizeof(CEMfObject);
                break;
            default:
                dprintf("Error: can not determine size of IOlePresObj\n");
                return;
            }

            blockPresObj = new char[dwSizeOfPresObj];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pCacheListItem->lpCacheNode->m_pPresObj,
                        blockPresObj,
                        dwSizeOfPresObj,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                dprintf("at address %x\n", pCacheListItem->lpCacheNode->m_pPresObj);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != dwSizeOfPresObj)
            {
                dprintf("Size of process memory read != requested (IPresObj)\n");

                goto errRtn;
            }

            pCacheListItem->lpCacheNode->m_pPresObj = (IOlePresObj *)blockPresObj;
        }

        if (pCacheListItem->lpCacheNode->m_pPresObjAfterFreeze != NULL)
        {
            switch (pCacheListItem->lpCacheNode->m_dwPresFlag)
            {
            case CN_PRESOBJ_GEN:
                dwSizeOfPresObj = sizeof(CGenObject);
                break;
            case CN_PRESOBJ_MF:
                dwSizeOfPresObj = sizeof(CMfObject);
                break;
            case CN_PRESOBJ_EMF:
                dwSizeOfPresObj = sizeof(CEMfObject);
                break;
            default:
                dprintf("Error: can not determine size of IOlePresObj\n");
                return;
            }

            blockPresObjAF = new char[dwSizeOfPresObj];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pCacheListItem->lpCacheNode->m_pPresObjAfterFreeze,
                        blockPresObjAF,
                        dwSizeOfPresObj,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                dprintf("at address %x\n", pCacheListItem->lpCacheNode->m_pPresObjAfterFreeze);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != dwSizeOfPresObj)
            {
                dprintf("Size of process memory read != requested (IOlePresObj)\n");

                goto errRtn;
            }

            pCacheListItem->lpCacheNode->m_pPresObjAfterFreeze = (IOlePresObj *)blockPresObjAF;
        }
    }

    // dump the structure
    pszCacheListItem = DumpCACHELIST_ITEM(pCacheListItem, NO_PREFIX, 1);

    dprintf("CACHELIST_ITEM @ 0x%x\n", dwAddr);
    dprintfx(pszCacheListItem);

    CoTaskMemFree(pszCacheListItem);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockPresObj;
    delete[] blockPresObjAF;
    delete[] blockCacheNode;
    delete[] blockCacheListItem;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_cacheenum, exported
//
//  Synopsis:   dumps CCacheEnum object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_cacheenum)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszCE;
    char            *blockCE    = NULL;
    CCacheEnum      *pCE        = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CCacheEnum\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockCE = new char[sizeof(CCacheEnum)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCE,
                sizeof(CCacheEnum),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CCacheEnum \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CCacheEnum))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCE = (CCacheEnum *)blockCE;

    // dump the structure
    pszCE = DumpCCacheEnum(pCE, NO_PREFIX, 1);

    dprintf("CCacheEnum @ 0x%x\n", dwAddr);
    dprintfx(pszCE);

    CoTaskMemFree(pszCE);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockCE;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_cacheenumformatetc, exported
//
//  Synopsis:   dumps CCacheEnumFormatEtc object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_cacheenumformatetc)
{
    BOOL                fError;
    LPVOID              dwAddr;
    DWORD               dwReturnedCount;
    char                *pszCacheEnumFormatEtc;
    char                *blockCacheEnumFormatEtc   = NULL;
    CCacheEnumFormatEtc *pCacheEnumFormatEtc       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CCacheEnumFormatEtc\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockCacheEnumFormatEtc = new char[sizeof(CCacheEnumFormatEtc)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCacheEnumFormatEtc,
                sizeof(CCacheEnumFormatEtc),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory CacheEnumFormatEtc");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CCacheEnumFormatEtc))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCacheEnumFormatEtc = (CCacheEnumFormatEtc *)blockCacheEnumFormatEtc;

    // dump the structure
    pszCacheEnumFormatEtc = DumpCCacheEnumFormatEtc(pCacheEnumFormatEtc, NO_PREFIX, 1);

    dprintf("CCacheEnumFormatEtc @ 0x%x\n", dwAddr);
    dprintfx(pszCacheEnumFormatEtc);

    CoTaskMemFree(pszCacheEnumFormatEtc);

errRtn:

    delete[] blockCacheEnumFormatEtc;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_cachenode, exported
//
//  Synopsis:   dumps CCacheNode object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_cachenode)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount     = 0;
    char            *pszCacheNode       = NULL;
    char            *blockCacheNode     = NULL;
    char            *blockPresObj       = NULL;
    char            *blockPresObjAF     = NULL;
    CCacheNode      *pCacheNode         = NULL;
    DWORD            dwSizeOfPresObj;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CCacheNode\n");
        return;
    }

    // get the CCacheNode block of mem
    blockCacheNode = new char[sizeof(CCacheNode)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCacheNode,
                sizeof(CCacheNode),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CCacheNode \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CCacheNode))
    {
        dprintf("Size of process memory read != requested (CCacheNode)\n");

        goto errRtn;
    }

    pCacheNode = (CCacheNode*)blockCacheNode;

    // need to get the OlePresObjs for the CCacheNode
    if (pCacheNode->m_pPresObj != NULL)
    {
        switch (pCacheNode->m_dwPresFlag)
        {
        case CN_PRESOBJ_GEN:
            dwSizeOfPresObj = sizeof(CGenObject);
            break;
        case CN_PRESOBJ_MF:
            dwSizeOfPresObj = sizeof(CMfObject);
            break;
        case CN_PRESOBJ_EMF:
            dwSizeOfPresObj = sizeof(CEMfObject);
            break;
        default:
            dprintf("Error: can not determine size of IOlePresObj\n");
            return;
        }

        blockPresObj = new char[dwSizeOfPresObj];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pCacheNode->m_pPresObj,
                    blockPresObj,
                    dwSizeOfPresObj,
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: IOlePresObj \n");
            dprintf("at address %x\n", pCacheNode->m_pPresObj);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != dwSizeOfPresObj)
        {
            dprintf("Size of process memory read != requested (IOlePresObj)\n");

            goto errRtn;
        }

        // pass off pointer
        pCacheNode->m_pPresObj = (IOlePresObj *)blockPresObj;
    }

    if (pCacheNode->m_pPresObjAfterFreeze != NULL)
    {
        switch (pCacheNode->m_dwPresFlag)
        {
        case CN_PRESOBJ_GEN:
            dwSizeOfPresObj = sizeof(CGenObject);
            break;
        case CN_PRESOBJ_MF:
            dwSizeOfPresObj = sizeof(CMfObject);
            break;
        case CN_PRESOBJ_EMF:
            dwSizeOfPresObj = sizeof(CEMfObject);
            break;
        default:
            dprintf("Error: can not determine size of IOlePresObj\n");
            return;
        }

        blockPresObjAF = new char[dwSizeOfPresObj];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pCacheNode->m_pPresObjAfterFreeze,
                    blockPresObjAF,
                    dwSizeOfPresObj,
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: IOlePresObj \n");
            dprintf("at address %x\n", pCacheNode->m_pPresObjAfterFreeze);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != dwSizeOfPresObj)
        {
            dprintf("Size of process memory read != requested (IOlePresObj)\n");

            goto errRtn;
        }

        // pass off pointer
        pCacheNode->m_pPresObjAfterFreeze = (IOlePresObj *)blockPresObjAF;
    }

    // dump the structure
    pszCacheNode = DumpCCacheNode(pCacheNode, NO_PREFIX, 1);

    dprintf("CCacheNode @ 0x%x\n", dwAddr);
    dprintfx(pszCacheNode);

    CoTaskMemFree(pszCacheNode);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockPresObj;
    delete[] blockPresObjAF;
    delete[] blockCacheNode;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_clipdataobject, exported
//
//  Synopsis:   dumps CClipDataObject object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_clipdataobject)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszCDO;
    char            *blockCDO    = NULL;
    char            *blockFE     = NULL;
    CClipDataObject *pCDO        = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CClipDataObject\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockCDO = new char[sizeof(CClipDataObject)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCDO,
                sizeof(CClipDataObject),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CClipDataObject \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CClipDataObject))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCDO = (CClipDataObject *)blockCDO;

    // read the block of mem for the FORMATETC array
    blockFE = new char[sizeof(FORMATETC)*pCDO->m_cFormats];

    fError = ReadProcessMemory(
                hCurrentProcess,
                pCDO->m_rgFormats,
                blockFE,
                sizeof(FORMATETC)*pCDO->m_cFormats,
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: FORMATETC array \n");
        dprintf("at address %x\n", pCDO->m_rgFormats);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != (sizeof(FORMATETC)*pCDO->m_cFormats))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCDO->m_rgFormats = (FORMATETC *)blockFE;

    // dump the structure
    pszCDO = DumpCClipDataObject(pCDO, NO_PREFIX, 1);

    dprintf("CClipDataObject @ 0x%x\n", dwAddr);
    dprintfx(pszCDO);

    CoTaskMemFree(pszCDO);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockFE;
    delete[] blockCDO;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_clipenumformatetc, exported
//
//  Synopsis:   dumps CClipEnumFormatEtc object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_clipenumformatetc)
{
    BOOL                fError;
    LPVOID              dwAddr;
    DWORD               dwReturnedCount;
    char                *pszCEFE;
    char                *blockCEFE    = NULL;
    char                *blockFE      = NULL;
    CClipEnumFormatEtc  *pCEFE        = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CClipEnumFormatEtc\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockCEFE = new char[sizeof(CClipEnumFormatEtc)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCEFE,
                sizeof(CClipEnumFormatEtc),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CClipEnumFormatEtc \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CClipEnumFormatEtc))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCEFE = (CClipEnumFormatEtc *)blockCEFE;

    // read the block of mem for the FORMATETC array
    blockFE = new char[sizeof(FORMATETC)*pCEFE->m_cTotal];

    fError = ReadProcessMemory(
                hCurrentProcess,
                pCEFE->m_rgFormats,
                blockFE,
                sizeof(FORMATETC)*pCEFE->m_cTotal,
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: FORMATETC array \n");
        dprintf("at address %x\n", pCEFE->m_rgFormats);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != (sizeof(FORMATETC)*pCEFE->m_cTotal))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pCEFE->m_rgFormats = (FORMATETC *)blockFE;

    // dump the structure
    pszCEFE = DumpCClipEnumFormatEtc(pCEFE, NO_PREFIX, 1);

    dprintf("CClipEnumFormatEtc @ 0x%x\n", dwAddr);
    dprintfx(pszCEFE);

    CoTaskMemFree(pszCEFE);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockFE;
    delete[] blockCEFE;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_daholder, exported
//
//  Synopsis:   dumps CDAHolder object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_daholder)
{
    DWORD           dwReturnedCount;
    BOOL            fError;
    LPVOID          dwAddr;
    char            *pszDAH;
    char            *blockDAH           = NULL;
    char            *blockStatDataArray = NULL;
    CDAHolder       *pDAH               = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CDAHolder\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockDAH = new char[sizeof(CDAHolder)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockDAH,
                sizeof(CDAHolder),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CDAHolder \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CDAHolder))
    {
        dprintf("Size of process memory read != requested (CDAHolder)\n");

        goto errRtn;
    }

    pDAH = (CDAHolder *)blockDAH;

    // read the block of mem for the STATDATA array
    blockStatDataArray = new char[sizeof(STATDATA) * pDAH->m_iSize];

    fError = ReadProcessMemory(
                hCurrentProcess,
                pDAH->m_pSD,
                blockStatDataArray,
                sizeof(STATDATA) * pDAH->m_iSize,
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: STATDATA array \n");
        dprintf("at address %x\n", pDAH->m_pSD);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != (sizeof(STATDATA) * pDAH->m_iSize))
    {
        dprintf("Size of process memory read != requested (STATDATA array)\n");

        goto errRtn;
    }

    pDAH->m_pSD = (STATDATA *)blockStatDataArray;

    // dump the structure
    pszDAH = DumpCDAHolder(pDAH, NO_PREFIX, 1);

    dprintf("CDAHolder @ 0x%x\n", dwAddr);
    dprintfx(pszDAH);

    CoTaskMemFree(pszDAH);

errRtn:

    delete[] blockDAH;
    delete[] blockStatDataArray;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_dataadvisecache, exported
//
//  Synopsis:   dumps CDataAdviseCache object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_dataadvisecache)
{
    BOOL                fError;
    LPVOID              dwAddr;
    DWORD               dwReturnedCount;
    char                *pszDataAdviseCache;
    char                *blockDataAdviseCache   = NULL;
    char                *blockDAH               = NULL;
    CDataAdviseCache    *pDataAdviseCache       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CDataAdviseCache\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockDataAdviseCache = new char[sizeof(CDataAdviseCache)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockDataAdviseCache,
                sizeof(CDataAdviseCache),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory DataAdviseCache");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CDataAdviseCache))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pDataAdviseCache = (CDataAdviseCache *)blockDataAdviseCache;

    // get the mem for CDAHolder
    if (pDataAdviseCache->m_pDAH != NULL)
    {
        blockDAH = new char[sizeof(CDAHolder)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDataAdviseCache->m_pDAH,
                    blockDAH,
                    sizeof(CDAHolder),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory CDAHolder");
            dprintf("at address %x\n", pDataAdviseCache->m_pDAH);
            dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CDAHolder))
        {
            dprintf("Size of process memory read != requested (CDAHolder)\n");

            goto errRtn;
        }

        pDataAdviseCache->m_pDAH = (CDAHolder *)blockDAH;
    }

    // dump the structure
    pszDataAdviseCache = DumpCDataAdviseCache(pDataAdviseCache, NO_PREFIX, 1);

    dprintf("CDataAdviseCache @ 0x%x\n", dwAddr);
    dprintfx(pszDataAdviseCache);

    CoTaskMemFree(pszDataAdviseCache);

errRtn:

    delete[] blockDAH;
    delete[] blockDataAdviseCache;

    return;
}
//+-------------------------------------------------------------------------
//
//  Function:   dump_defclassfactory, exported
//
//  Synopsis:   dumps CDefClassFactory object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_defclassfactory)
{
    BOOL                fError;
    LPVOID              dwAddr;
    DWORD               dwReturnedCount;
    char                *pszDefClassFactory;
    char                *blockDefClassFactory   = NULL;
    CDefClassFactory    *pDefClassFactory       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CDefClassFactory\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockDefClassFactory = new char[sizeof(CDefClassFactory)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockDefClassFactory,
                sizeof(CDefClassFactory),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory DefClassFactory");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CDefClassFactory))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pDefClassFactory = (CDefClassFactory *)blockDefClassFactory;

    // dump the structure
    pszDefClassFactory = DumpCDefClassFactory(pDefClassFactory, NO_PREFIX, 1);

    dprintf("CDefClassFactory @ 0x%x\n", dwAddr);
    dprintfx(pszDefClassFactory);

    CoTaskMemFree(pszDefClassFactory);

errRtn:

    delete[] blockDefClassFactory;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_deflink, exported
//
//  Synopsis:   dumps CDefLink object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_deflink)
{
    unsigned int    ui;
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount     = 0;
    char            *pszDL              = NULL;
    char            *blockDefLink       = NULL;
    char            *blockCOleCache     = NULL;
    char            *blockDataAdvCache  = NULL;
    char            *blockOAHolder      = NULL;
    char            *blockpIAS          = NULL;
    char            *blockDAHolder      = NULL;
    char            *blockSTATDATA      = NULL;
    char            *blockCACHELIST     = NULL;
    char            *blockCacheNode     = NULL;
    char            *blockPresObj       = NULL;
    CDefLink        *pDL                = NULL;
    CDAHolder       *pDAH               = NULL;
    COAHolder       *pOAH               = NULL;
    DWORD            dwSizeOfPresObj;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CDefLink\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockDefLink = new char[sizeof(CDefLink)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockDefLink,
                sizeof(CDefLink),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CDefLink \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CDefLink))
    {
        dprintf("Size of process memory read != requested (CDefLink)\n");

        goto errRtn;
    }

    pDL = (CDefLink *)blockDefLink;

    // we need to NULL the monikers since we can't use GetDisplayName in this process
    pDL->m_pMonikerAbs = NULL;
    pDL->m_pMonikerRel = NULL;

    // get the block of mem for the COAHolder
    if (pDL->m_pCOAHolder != NULL)
    {
        blockOAHolder = new char[sizeof(COAHolder)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDL->m_pCOAHolder,
                    blockOAHolder,
                    sizeof(COAHolder),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: COAHolder \n");
            dprintf("at address %x\n", pDL->m_pCOAHolder);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(COAHolder))
        {
            dprintf("Size of process memory read != requested (COAHolder)\n");

            goto errRtn;
        }

        pDL->m_pCOAHolder = (COAHolder *)blockOAHolder;
        pOAH = (COAHolder *)blockOAHolder;

        // need to copy the array of IAdviseSink pointers
        if (pOAH->m_iSize > 0)
        {
            blockpIAS = new char[pOAH->m_iSize * sizeof(IAdviseSink *)];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pOAH->m_ppIAS,
                        blockpIAS,
                        sizeof(IAdviseSink *) * pOAH->m_iSize,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: IAdviseSink Array \n");
                dprintf("at address %x\n", pOAH->m_ppIAS);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != (sizeof(IAdviseSink *) * pOAH->m_iSize))
            {
                dprintf("Size of process memory read != requested(IAdviseSink Array)\n");

                goto errRtn;
            }

            pOAH->m_ppIAS = (IAdviseSink **)blockpIAS;
        }
    }

    // get block of mem for CDataAdviseCache (only if m_pDataAdvCache != NULL)
    if (pDL->m_pDataAdvCache != NULL)
    {
        blockDataAdvCache = new char[sizeof(CDataAdviseCache)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDL->m_pDataAdvCache,
                    blockDataAdvCache,
                    sizeof(CDataAdviseCache),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CDataAdviseCache \n");
            dprintf("at address %x\n", pDL->m_pDataAdvCache);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CDataAdviseCache))
        {
            dprintf("Size of process memory read != requested (CDataAdviseCache)\n");

            goto errRtn;
        }

        pDL->m_pDataAdvCache = (CDataAdviseCache *)blockDataAdvCache;

        if (pDL->m_pDataAdvCache->m_pDAH != NULL)
        {
            blockDAHolder = new char[sizeof(CDAHolder)];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pDL->m_pDataAdvCache->m_pDAH,
                        blockDAHolder,
                        sizeof(CDAHolder),
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: CDAHolder \n");
                dprintf("at address %x\n", pDL->m_pDataAdvCache->m_pDAH);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != sizeof(CDAHolder))
            {
                dprintf("Size of process memory read != requested (CDAHolder)\n");

                goto errRtn;
            }

            pDL->m_pDataAdvCache->m_pDAH = (IDataAdviseHolder *)blockDAHolder;
            pDAH = (CDAHolder *)blockDAHolder;

            if (pDAH->m_pSD != NULL)
            {
                blockSTATDATA = new char[sizeof(STATDATA)*pDAH->m_iSize];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pDAH->m_pSD,
                            blockSTATDATA,
                            sizeof(STATDATA)*pDAH->m_iSize,
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: STATDATA \n");
                    dprintf("at address %x\n", pDAH->m_pSD);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != (sizeof(STATDATA)*pDAH->m_iSize))
                {
                    dprintf("Size of process memory read != requested (STATDATA)\n");

                    goto errRtn;
                }

                pDAH->m_pSD = (STATDATA *)blockSTATDATA;
            }
        }
    }

    // get block of mem for COleCache (only if m_pCOleCache != NULL)
    if (pDL->m_pCOleCache != NULL)
    {
        blockCOleCache = new char[sizeof(COleCache)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDL->m_pCOleCache,
                    blockCOleCache,
                    sizeof(COleCache),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: COleCache \n");
            dprintf("at address %x\n", pDL->m_pCOleCache);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(COleCache))
        {
            dprintf("Size of process memory read != requested (COleCache)\n");

            goto errRtn;
        }

        pDL->m_pCOleCache = (COleCache *)blockCOleCache;

        // get block of mem for CACHELIST
        if (pDL->m_pCOleCache->m_pCacheList != NULL)
        {
            blockCACHELIST = new char[sizeof(CACHELIST_ITEM) * pDL->m_pCOleCache->m_uCacheNodeMax];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pDL->m_pCOleCache->m_pCacheList,
                        blockCACHELIST,
                        sizeof(CACHELIST_ITEM) * pDL->m_pCOleCache->m_uCacheNodeMax,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: CACHELIST \n");
                dprintf("at address %x\n", pDL->m_pCOleCache->m_pCacheList);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != (sizeof(CACHELIST_ITEM) * pDL->m_pCOleCache->m_uCacheNodeMax))
            {
                dprintf("Size of process memory read != requestedi (CACHELIST)\n");

                goto errRtn;
            }

            pDL->m_pCOleCache->m_pCacheList = (LPCACHELIST) blockCACHELIST;
        }

        // need to copy the memory of the CCacheNode's in the CACHELIST
        for (ui = 0; ui < pDL->m_pCOleCache->m_uCacheNodeMax; ui++)
        {
            if (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode != NULL)
            {
                blockCacheNode = new char[sizeof(CCacheNode)];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode,
                            blockCacheNode,
                            sizeof(CCacheNode),
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: CCacheNode \n");
                    dprintf("at address %x\n", pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != sizeof(CCacheNode))
                {
                    dprintf("Size of process memory read != requested (CCacheNode)\n");

                    goto errRtn;
                }

                // pass off pointer
                pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode = (CCacheNode*)blockCacheNode;
                blockCacheNode = NULL;

                // need to get the OlePresObjs for the CCacheNode
                if (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj != NULL)
                {
                    switch (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                    {
                    case CN_PRESOBJ_GEN:
                        dwSizeOfPresObj = sizeof(CGenObject);
                        break;
                    case CN_PRESOBJ_MF:
                        dwSizeOfPresObj = sizeof(CMfObject);
                        break;
                    case CN_PRESOBJ_EMF:
                        dwSizeOfPresObj = sizeof(CEMfObject);
                        break;
                    default:
                        dprintf("Error: can not determine size of IOlePresObj\n");
                        return;
                    }

                    blockPresObj = new char[dwSizeOfPresObj];

                    fError = ReadProcessMemory(
                                hCurrentProcess,
                                pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj,
                                blockPresObj,
                                dwSizeOfPresObj,
                                &dwReturnedCount
                                );

                    if (fError == FALSE)
                    {
                        dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                        dprintf("at address %x\n", pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                        goto errRtn;
                    }

                    if (dwReturnedCount != dwSizeOfPresObj)
                    {
                        dprintf("Size of process memory read != requested (IOlePresObj)\n");

                        goto errRtn;
                    }

                    // pass off pointer
                    pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj = (IOlePresObj *)blockPresObj;
                    blockPresObj = NULL;
                }

                if (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze != NULL)
                {
                    switch (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                    {
                    case CN_PRESOBJ_GEN:
                        dwSizeOfPresObj = sizeof(CGenObject);
                        break;
                    case CN_PRESOBJ_MF:
                        dwSizeOfPresObj = sizeof(CMfObject);
                        break;
                    case CN_PRESOBJ_EMF:
                        dwSizeOfPresObj = sizeof(CEMfObject);
                        break;
                    default:
                        dprintf("Error: can not determine size of IOlePresObj\n");
                        return;
                    }

                    blockPresObj = new char[dwSizeOfPresObj];

                    fError = ReadProcessMemory(
                                hCurrentProcess,
                                pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze,
                                blockPresObj,
                                dwSizeOfPresObj,
                                &dwReturnedCount
                                );

                    if (fError == FALSE)
                    {
                        dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                        dprintf("at address %x\n", pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                        goto errRtn;
                    }

                    if (dwReturnedCount != dwSizeOfPresObj)
                    {
                        dprintf("Size of process memory read != requested (IOlePresObj)\n");

                        goto errRtn;
                    }

                    // pass off pointer
                    pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze = (IOlePresObj *)blockPresObj;
                    blockPresObj = NULL;
                }
            }
        }
    }

    // dump the structure
    pszDL = DumpCDefLink(pDL, NO_PREFIX, 1);

    dprintf("CDefLink @ 0x%x\n", dwAddr);
    dprintfx(pszDL);

    CoTaskMemFree(pszDL);

errRtn:

    // delete the blocks and not the pointers
    if ( (pDL != NULL)&&(blockCACHELIST != NULL)&&(blockCOleCache != NULL) )
    {
        for (ui = 0; ui < pDL->m_pCOleCache->m_uCacheNodeMax; ui++)
        {
         if (pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode != NULL)
            {
                delete[] ((char *)pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                delete[] ((char *)pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                delete[] ((char *)pDL->m_pCOleCache->m_pCacheList[ui].lpCacheNode);
            }
        }
    }
    delete[] blockCACHELIST;
    delete[] blockCOleCache;
    delete[] blockDAHolder;
    delete[] blockSTATDATA;
    delete[] blockDataAdvCache;
    delete[] blockpIAS;
    delete[] blockOAHolder;
    delete[] blockDefLink;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_defobject, exported
//
//  Synopsis:   dumps CDefObject object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_defobject)
{
    unsigned int    ui;
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount     = 0;
    char            *pszDO              = NULL;
    char            *blockDefObject     = NULL;
    char            *blockCOleCache     = NULL;
    char            *blockDataAdvCache  = NULL;
    char            *blockOAHolder      = NULL;
    char            *blockpIAS          = NULL;
    char            *blockDAHolder      = NULL;
    char            *blockSTATDATA      = NULL;
    char            *blockCACHELIST     = NULL;
    char            *blockCacheNode     = NULL;
    char            *blockPresObj       = NULL;
    CDefObject      *pDO                = NULL;
    CDAHolder       *pDAH               = NULL;
    COAHolder       *pOAH               = NULL;
    DWORD            dwSizeOfPresObj;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CDefObject\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockDefObject = new char[sizeof(CDefObject)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockDefObject,
                sizeof(CDefObject),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CDefObject \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CDefObject))
    {
        dprintf("Size of process memory read != requested (CDefObject)\n");

        goto errRtn;
    }

    pDO = (CDefObject *)blockDefObject;

    // get the block of mem for the COAHolder
    if (pDO->m_pOAHolder != NULL)
    {
        blockOAHolder = new char[sizeof(COAHolder)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDO->m_pOAHolder,
                    blockOAHolder,
                    sizeof(COAHolder),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: COAHolder \n");
            dprintf("at address %x\n", pDO->m_pOAHolder);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(COAHolder))
        {
            dprintf("Size of process memory read != requested (COAHolder)\n");

            goto errRtn;
        }

        pDO->m_pOAHolder = (COAHolder *)blockOAHolder;
        pOAH = (COAHolder *)blockOAHolder;

        // need to copy the array of IAdviseSink pointers
        if (pOAH->m_iSize > 0)
        {
            blockpIAS = new char[pOAH->m_iSize * sizeof(IAdviseSink *)];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pOAH->m_ppIAS,
                        blockpIAS,
                        sizeof(IAdviseSink *) * pOAH->m_iSize,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: IAdviseSink Array \n");
                dprintf("at address %x\n", pOAH->m_ppIAS);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != (sizeof(IAdviseSink *) * pOAH->m_iSize))
            {
                dprintf("Size of process memory read != requested(IAdviseSink Array)\n");

                goto errRtn;
            }

            pOAH->m_ppIAS = (IAdviseSink **)blockpIAS;
        }
    }

    // get block of mem for CDataAdviseCache (only if m_pDataAdvCache != NULL)
    if (pDO->m_pDataAdvCache != NULL)
    {
        blockDataAdvCache = new char[sizeof(CDataAdviseCache)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDO->m_pDataAdvCache,
                    blockDataAdvCache,
                    sizeof(CDataAdviseCache),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CDataAdviseCache \n");
            dprintf("at address %x\n", pDO->m_pDataAdvCache);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CDataAdviseCache))
        {
            dprintf("Size of process memory read != requested (CDataAdviseCache)\n");

            goto errRtn;
        }

        pDO->m_pDataAdvCache = (CDataAdviseCache *)blockDataAdvCache;

        // get the mem for CDAHolder
        if (pDO->m_pDataAdvCache->m_pDAH != NULL)
        {
            blockDAHolder = new char[sizeof(CDAHolder)];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pDO->m_pDataAdvCache->m_pDAH,
                        blockDAHolder,
                        sizeof(CDAHolder),
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: CDAHolder \n");
                dprintf("at address %x\n", pDO->m_pDataAdvCache->m_pDAH);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != sizeof(CDAHolder))
            {
                dprintf("Size of process memory read != requested (CDAHolder)\n");

                goto errRtn;
            }

            pDO->m_pDataAdvCache->m_pDAH = (IDataAdviseHolder *)blockDAHolder;
            pDAH = (CDAHolder *)blockDAHolder;

            // get the STATDATA array
            if (pDAH->m_pSD != NULL)
            {
                blockSTATDATA = new char[sizeof(STATDATA)*pDAH->m_iSize];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pDAH->m_pSD,
                            blockSTATDATA,
                            sizeof(STATDATA)*pDAH->m_iSize,
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: STATDATA \n");
                    dprintf("at address %x\n", pDAH->m_pSD);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != (sizeof(STATDATA)*pDAH->m_iSize))
                {
                    dprintf("Size of process memory read != requested (STATDATA)\n");

                    goto errRtn;
                }

                pDAH->m_pSD = (STATDATA *)blockSTATDATA;
            }
        }
    }

    // get block of mem for COleCache (only if m_pCOleCache != NULL)
    if (pDO->m_pCOleCache != NULL)
    {
        blockCOleCache = new char[sizeof(COleCache)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pDO->m_pCOleCache,
                    blockCOleCache,
                    sizeof(COleCache),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: COleCache \n");
            dprintf("at address %x\n", pDO->m_pCOleCache);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(COleCache))
        {
            dprintf("Size of process memory read != requested (COleCache)\n");

            goto errRtn;
        }

        pDO->m_pCOleCache = (COleCache *)blockCOleCache;

        // get block of mem for CACHELIST
        if (pDO->m_pCOleCache->m_pCacheList != NULL)
        {
            blockCACHELIST = new char[sizeof(CACHELIST_ITEM) * pDO->m_pCOleCache->m_uCacheNodeMax];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pDO->m_pCOleCache->m_pCacheList,
                        blockCACHELIST,
                        sizeof(CACHELIST_ITEM) * pDO->m_pCOleCache->m_uCacheNodeMax,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: CACHELIST \n");
                dprintf("at address %x\n", pDO->m_pCOleCache->m_pCacheList);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != (sizeof(CACHELIST_ITEM) * pDO->m_pCOleCache->m_uCacheNodeMax))
            {
                dprintf("Size of process memory read != requested(CACHELIST_ITEM\n");

                goto errRtn;
            }

            pDO->m_pCOleCache->m_pCacheList = (LPCACHELIST) blockCACHELIST;
        }

        // need to copy the memory of the CCacheNode's in the CACHELIST
        for (ui = 0; ui < pDO->m_pCOleCache->m_uCacheNodeMax; ui++)
        {
            if (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode != NULL)
            {
                blockCacheNode = new char[sizeof(CCacheNode)];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode,
                            blockCacheNode,
                            sizeof(CCacheNode),
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: CCacheNode \n");
                    dprintf("at address %x\n", pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != sizeof(CCacheNode))
                {
                    dprintf("Size of process memory read != requested (CCacheNode)\n");

                    goto errRtn;
                }

                // pass off pointer
                pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode = (CCacheNode*)blockCacheNode;
                blockCacheNode = NULL;

                // need to get the OlePresObjs for the CCacheNode
                if (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj != NULL)
                {
                    switch (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                    {
                    case CN_PRESOBJ_GEN:
                        dwSizeOfPresObj = sizeof(CGenObject);
                        break;
                    case CN_PRESOBJ_MF:
                        dwSizeOfPresObj = sizeof(CMfObject);
                        break;
                    case CN_PRESOBJ_EMF:
                        dwSizeOfPresObj = sizeof(CEMfObject);
                        break;
                    default:
                        dprintf("Error: can not determine size of IOlePresObj\n");
                        return;
                    }

                    blockPresObj = new char[dwSizeOfPresObj];

                    fError = ReadProcessMemory(
                                hCurrentProcess,
                                pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj,
                                blockPresObj,
                                dwSizeOfPresObj,
                                &dwReturnedCount
                                );

                    if (fError == FALSE)
                    {
                        dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                        dprintf("at address %x\n", pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                        goto errRtn;
                    }

                    if (dwReturnedCount != dwSizeOfPresObj)
                    {
                        dprintf("Size of process memory read != requested (IOlePresObj)\n");

                        goto errRtn;
                    }

                    // pass off pointer
                    pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj = (IOlePresObj *)blockPresObj;
                    blockPresObj = NULL;
                }

                if (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze != NULL)
                {
                    switch (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                    {
                    case CN_PRESOBJ_GEN:
                        dwSizeOfPresObj = sizeof(CGenObject);
                        break;
                    case CN_PRESOBJ_MF:
                        dwSizeOfPresObj = sizeof(CMfObject);
                        break;
                    case CN_PRESOBJ_EMF:
                        dwSizeOfPresObj = sizeof(CEMfObject);
                        break;
                    default:
                        dprintf("Error: can not determine size of IOlePresObj\n");
                        return;
                    }

                    blockPresObj = new char[dwSizeOfPresObj];

                    fError = ReadProcessMemory(
                                hCurrentProcess,
                                pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze,
                                blockPresObj,
                                dwSizeOfPresObj,
                                &dwReturnedCount
                                );

                    if (fError == FALSE)
                    {
                        dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                        dprintf("at address %x\n", pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                        goto errRtn;
                    }

                    if (dwReturnedCount != dwSizeOfPresObj)
                    {
                        dprintf("Size of process memory read != requested (IOlePresObj)\n");

                        goto errRtn;
                    }

                    // pass off pointer
                    pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze = (IOlePresObj *)blockPresObj;
                    blockPresObj = NULL;
                }
            }
        }
    }

    // dump the structure
    pszDO = DumpCDefObject(pDO, NO_PREFIX, 1);

    dprintf("CDefObject @ 0x%x\n", dwAddr);
    dprintfx(pszDO);

    CoTaskMemFree(pszDO);

errRtn:

    // delete the blocks and not the pointers
    if ( (pDO != NULL)&&(blockCACHELIST != NULL)&&(blockCOleCache != NULL) )
    {
        for (ui = 0; ui < pDO->m_pCOleCache->m_uCacheNodeMax; ui++)
        {
         if (pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode != NULL)
            {
                delete[] ((char *)pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                delete[] ((char *)pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                delete[] ((char *)pDO->m_pCOleCache->m_pCacheList[ui].lpCacheNode);
            }
        }
    }
    delete[] blockCACHELIST;
    delete[] blockCOleCache;
    delete[] blockDAHolder;
    delete[] blockSTATDATA;
    delete[] blockDataAdvCache;
    delete[] blockpIAS;
    delete[] blockOAHolder;
    delete[] blockDefObject;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_emfobject, exported
//
//  Synopsis:   dumps CEMfObject object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_emfobject)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszEMfObject;
    char            *blockEMfObject   = NULL;
    CEMfObject      *pEMfObject       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CEMfObject\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockEMfObject = new char[sizeof(CEMfObject)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockEMfObject,
                sizeof(CEMfObject),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory EMfObject");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CEMfObject))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pEMfObject = (CEMfObject *)blockEMfObject;

    // dump the structure
    pszEMfObject = DumpCEMfObject(pEMfObject, NO_PREFIX, 1);

    dprintf("CEMfObject @ 0x%x\n", dwAddr);
    dprintfx(pszEMfObject);

    CoTaskMemFree(pszEMfObject);

errRtn:

    delete[] blockEMfObject;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_enumfmt, exported
//
//  Synopsis:   dumps CEnumFmt object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_enumfmt)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_enumfmt not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_enumfmt10, exported
//
//  Synopsis:   dumps CEnumFmt10 object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_enumfmt10)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_enumfmt10 not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_enumstatdata, exported
//
//  Synopsis:   dumps CEnumSTATDATA object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_enumstatdata)
{
    DWORD           dwReturnedCount;
    BOOL            fError;
    LPVOID          dwAddr;
    char            *pszESD;
    char            *blockEnumStatData  = NULL;
    char            *blockDAH           = NULL;
    char            *blockStatDataArray = NULL;
    CEnumSTATDATA   *pESD               = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CEnumSTATDATA\n");
        return;
    }

    // read the mem for the CEnumSTATDATA
    blockEnumStatData = new char[sizeof(CEnumSTATDATA)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockEnumStatData,
                sizeof(CEnumSTATDATA),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CEnumSTATDATA \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CEnumSTATDATA))
    {
        dprintf("Size of process memory read != requested (CEnumSTATDATA)\n");

        goto errRtn;
    }

    pESD = (CEnumSTATDATA *)blockEnumStatData;

    // read the block of memory for the CDAHolder
    if (pESD->m_pHolder != NULL)
    {
        blockDAH = new char[sizeof(CDAHolder)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pESD->m_pHolder,
                    blockDAH,
                    sizeof(CDAHolder),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CDAHolder \n");
            dprintf("at address %x\n", pESD->m_pHolder);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CDAHolder))
        {
            dprintf("Size of process memory read != requested (CDAHolder)\n");

            goto errRtn;
        }

        pESD->m_pHolder = (CDAHolder *)blockDAH;

        // read the block of mem for the STATDATA array
        if (pESD->m_pHolder->m_pSD != NULL)
        {
            blockStatDataArray = new char[sizeof(STATDATA) * pESD->m_pHolder->m_iSize];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pESD->m_pHolder->m_pSD,
                        blockStatDataArray,
                        sizeof(STATDATA) * pESD->m_pHolder->m_iSize,
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: STATDATA array \n");
                dprintf("at address %x\n", pESD->m_pHolder->m_pSD);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != (sizeof(STATDATA) * pESD->m_pHolder->m_iSize))
            {
                dprintf("Size of process memory read != requested (STATDATA array)\n");

                goto errRtn;
            }

            pESD->m_pHolder->m_pSD = (STATDATA *)blockStatDataArray;
        }
    }

    // dump the structure
    pszESD = DumpCEnumSTATDATA(pESD, NO_PREFIX, 1);

    dprintf("CEnumSTATDATA @ 0x%x\n", dwAddr);
    dprintfx(pszESD);

    CoTaskMemFree(pszESD);

errRtn:

    delete[] blockEnumStatData;
    delete[] blockDAH;
    delete[] blockStatDataArray;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_enumverb, exported
//
//  Synopsis:   dumps CEnumVerb object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_enumverb)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_enumverb not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_genobject, exported
//
//  Synopsis:   dumps CGenObject object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_genobject)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszGenObject;
    char            *blockGenObject   = NULL;
    CGenObject      *pGenObject       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CGenObject\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockGenObject = new char[sizeof(CGenObject)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockGenObject,
                sizeof(CGenObject),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory GenObject");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CGenObject))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pGenObject = (CGenObject *)blockGenObject;

    // dump the structure
    pszGenObject = DumpCGenObject(pGenObject, NO_PREFIX, 1);

    dprintf("CGenObject @ 0x%x\n", dwAddr);
    dprintfx(pszGenObject);

    CoTaskMemFree(pszGenObject);

errRtn:

    delete[] blockGenObject;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_membytes, exported
//
//  Synopsis:   dumps CMemBytes object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_membytes)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszMB;
    char            *blockMB        = NULL;
    CMemBytes       *pMB            = NULL;
    char            *blockMEMSTM    = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CMemBytes\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockMB = new char[sizeof(CMemBytes)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockMB,
                sizeof(CMemBytes),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CMemBytes \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CMemBytes))
    {
        dprintf("Size of process memory read != requested(CMemBytes)\n");

        goto errRtn;
    }

    pMB = (CMemBytes *)blockMB;

    // copy the MEMSTM structure
    if (pMB->m_pData != NULL)
    {
        blockMEMSTM = new char[sizeof(MEMSTM)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pMB->m_pData,
                    blockMEMSTM,
                    sizeof(MEMSTM),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: MEMSTM \n");
            dprintf("at address %x\n", pMB->m_pData);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(MEMSTM))
        {
            dprintf("Size of process memory read != requested(MEMSTM)\n");

            goto errRtn;
        }

        pMB->m_pData = (MEMSTM *)blockMEMSTM;
    }

    // dump the structure
    pszMB = DumpCMemBytes(pMB, NO_PREFIX, 1);

    dprintf("CMemBytes @ 0x%x\n", dwAddr);
    dprintfx(pszMB);

    CoTaskMemFree(pszMB);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockMB;
    delete[] blockMEMSTM;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_cmemstm, exported
//
//  Synopsis:   dumps CMemStm object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_cmemstm)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszMS;
    char            *blockMS        = NULL;
    CMemStm         *pMS            = NULL;
    char            *blockMEMSTM    = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CMemStm\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockMS = new char[sizeof(CMemStm)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockMS,
                sizeof(CMemStm),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CMemStm \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CMemStm))
    {
        dprintf("Size of process memory read != requested(CMemStm)\n");

        goto errRtn;
    }

    pMS = (CMemStm *)blockMS;

    // copy the MEMSTM structure
    if (pMS->m_pData != NULL)
    {
        blockMEMSTM = new char[sizeof(MEMSTM)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pMS->m_pData,
                    blockMEMSTM,
                    sizeof(MEMSTM),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: MEMSTM \n");
            dprintf("at address %x\n", pMS->m_pData);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(MEMSTM))
        {
            dprintf("Size of process memory read != requested(MEMSTM)\n");

            goto errRtn;
        }

        pMS->m_pData = (MEMSTM *)blockMEMSTM;
    }

    // dump the structure
    pszMS = DumpCMemStm(pMS, NO_PREFIX, 1);

    dprintf("CMemStm @ 0x%x\n", dwAddr);
    dprintfx(pszMS);

    CoTaskMemFree(pszMS);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockMS;
    delete[] blockMEMSTM;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_mfobject, exported
//
//  Synopsis:   dumps CMfObject object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_mfobject)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszMfObject;
    char            *blockMfObject   = NULL;
    CMfObject       *pMfObject       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CMfObject\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockMfObject = new char[sizeof(CMfObject)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockMfObject,
                sizeof(CMfObject),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory MfObject");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CMfObject))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pMfObject = (CMfObject *)blockMfObject;

    // dump the structure
    pszMfObject = DumpCMfObject(pMfObject, NO_PREFIX, 1);

    dprintf("CMfObject @ 0x%x\n", dwAddr);
    dprintfx(pszMfObject);

    CoTaskMemFree(pszMfObject);

errRtn:

    delete[] blockMfObject;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_oaholder, exported
//
//  Synopsis:   dumps COAHolder object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_oaholder)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszOAH;
    char            *blockOAH   = NULL;
    char            *blockpIAS  = NULL;
    COAHolder       *pOAH       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of COAHolder\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockOAH = new char[sizeof(COAHolder)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockOAH,
                sizeof(COAHolder),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: COAHolder \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(COAHolder))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pOAH = (COAHolder *)blockOAH;

    // need to copy the array of IAdviseSink pointers
    if (pOAH->m_iSize > 0)
    {
        blockpIAS = new char[pOAH->m_iSize * sizeof(IAdviseSink *)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pOAH->m_ppIAS,
                    blockpIAS,
                    sizeof(IAdviseSink *) * pOAH->m_iSize,
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: IAdviseSink Array \n");
            dprintf("at address %x\n", pOAH->m_ppIAS);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != (sizeof(IAdviseSink *) * pOAH->m_iSize))
        {
            dprintf("Size of process memory read != requested\n");

            goto errRtn;
        }

        pOAH->m_ppIAS = (IAdviseSink **)blockpIAS;
    }

    // dump the structure
    pszOAH = DumpCOAHolder(pOAH, NO_PREFIX, 1);

    dprintf("COAHolder @ 0x%x\n", dwAddr);
    dprintfx(pszOAH);

    CoTaskMemFree(pszOAH);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockOAH;
    delete[] blockpIAS;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_olecache, exported
//
//  Synopsis:   dumps COleCache object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_olecache)
{
    unsigned int    ui;
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszOC;
    char            *blockOC            = NULL;
    COleCache       *pOC                = NULL;
    char            *blockCCacheEnum    = NULL;
    char            *blockCACHELIST     = NULL;
    char            *blockCacheNode     = NULL;
    char            *blockPresObj       = NULL;
    DWORD            dwSizeOfPresObj;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of COleCache\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockOC = new char[sizeof(COleCache)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockOC,
                sizeof(COleCache),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: COleCache \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(COleCache))
    {
        dprintf("Size of process memory read != requested (COleCache)\n");

        goto errRtn;
    }

    pOC = (COleCache *)blockOC;

    // get block of mem for CCacheEnum (only if m_pCacheEnum != NULL)
    if (pOC->m_pCacheEnum != NULL)
    {
        blockCCacheEnum = new char[sizeof(CCacheEnum)];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pOC->m_pCacheEnum,
                    blockCCacheEnum,
                    sizeof(CCacheEnum),
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CCacheEnum \n");
            dprintf("at address %x\n", pOC->m_pCacheEnum);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != sizeof(CCacheEnum))
        {
            dprintf("Size of process memory read != requested (CCacheEnum)\n");

            goto errRtn;
        }

        pOC->m_pCacheEnum = (CCacheEnum *)blockCCacheEnum;
    }

    // get block of mem for CACHELIST
    if (pOC->m_pCacheList != NULL)
    {
        blockCACHELIST = new char[sizeof(CACHELIST_ITEM) * pOC->m_uCacheNodeMax];

        fError = ReadProcessMemory(
                    hCurrentProcess,
                    pOC->m_pCacheList,
                    blockCACHELIST,
                    sizeof(CACHELIST_ITEM) * pOC->m_uCacheNodeMax,
                    &dwReturnedCount
                    );

        if (fError == FALSE)
        {
            dprintf("Could not read debuggee's process memory: CACHELIST \n");
            dprintf("at address %x\n", pOC->m_pCacheList);
            dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

            goto errRtn;
        }

        if (dwReturnedCount != (sizeof(CACHELIST_ITEM) * pOC->m_uCacheNodeMax))
        {
            dprintf("Size of process memory read != requested\n");

            goto errRtn;
        }

        pOC->m_pCacheList = (LPCACHELIST) blockCACHELIST;
    }

    // need to copy the memory of the CCacheNode's in the CACHELIST
    for (ui = 0; ui < pOC->m_uCacheNodeMax; ui++)
    {
        if (pOC->m_pCacheList[ui].lpCacheNode != NULL)
        {
            blockCacheNode = new char[sizeof(CCacheNode)];

            fError = ReadProcessMemory(
                        hCurrentProcess,
                        pOC->m_pCacheList[ui].lpCacheNode,
                        blockCacheNode,
                        sizeof(CCacheNode),
                        &dwReturnedCount
                        );

            if (fError == FALSE)
            {
                dprintf("Could not read debuggee's process memory: CCacheNode \n");
                dprintf("at address %x\n", pOC->m_pCacheList[ui].lpCacheNode);
                dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                goto errRtn;
            }

            if (dwReturnedCount != sizeof(CCacheNode))
            {
                dprintf("Size of process memory read != requested (CCacheNode)\n");

                goto errRtn;
            }

            // pass off pointer
            pOC->m_pCacheList[ui].lpCacheNode = (CCacheNode*)blockCacheNode;
            blockCacheNode = NULL;

            // need to get the OlePresObjs for the CCacheNode
            if (pOC->m_pCacheList[ui].lpCacheNode->m_pPresObj != NULL)
            {
                switch (pOC->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                {
                case CN_PRESOBJ_GEN:
                    dwSizeOfPresObj = sizeof(CGenObject);
                    break;
                case CN_PRESOBJ_MF:
                    dwSizeOfPresObj = sizeof(CMfObject);
                    break;
                case CN_PRESOBJ_EMF:
                    dwSizeOfPresObj = sizeof(CEMfObject);
                    break;
                default:
                    dprintf("Error: can not determine size of IOlePresObj\n");
                    return;
                }

                blockPresObj = new char[dwSizeOfPresObj];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pOC->m_pCacheList[ui].lpCacheNode->m_pPresObj,
                            blockPresObj,
                            dwSizeOfPresObj,
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                    dprintf("at address %x\n", pOC->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != dwSizeOfPresObj)
                {
                    dprintf("Size of process memory read != requested (IOlePresObj)\n");

                    goto errRtn;
                }

                // pass off pointer
                pOC->m_pCacheList[ui].lpCacheNode->m_pPresObj = (IOlePresObj *)blockPresObj;
                blockPresObj = NULL;
            }

            if (pOC->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze != NULL)
            {
                switch (pOC->m_pCacheList[ui].lpCacheNode->m_dwPresFlag)
                {
                case CN_PRESOBJ_GEN:
                    dwSizeOfPresObj = sizeof(CGenObject);
                    break;
                case CN_PRESOBJ_MF:
                    dwSizeOfPresObj = sizeof(CMfObject);
                    break;
                case CN_PRESOBJ_EMF:
                    dwSizeOfPresObj = sizeof(CEMfObject);
                    break;
                default:
                    dprintf("Error: can not determine size of IOlePresObj\n");
                    return;
                }

                blockPresObj = new char[dwSizeOfPresObj];

                fError = ReadProcessMemory(
                            hCurrentProcess,
                            pOC->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze,
                            blockPresObj,
                            dwSizeOfPresObj,
                            &dwReturnedCount
                            );

                if (fError == FALSE)
                {
                    dprintf("Could not read debuggee's process memory: IOlePresObj \n");
                    dprintf("at address %x\n", pOC->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                    dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

                    goto errRtn;
                }

                if (dwReturnedCount != dwSizeOfPresObj)
                {
                    dprintf("Size of process memory read != requested (IOlePresObj)\n");

                    goto errRtn;
                }

                // pass off pointer
                pOC->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze = (IOlePresObj *)blockPresObj;
                blockPresObj = NULL;
            }
        }
    }

    // dump the structure
    pszOC = DumpCOleCache(pOC, NO_PREFIX, 1);

    dprintf("COleCache @ 0x%x\n", dwAddr);
    dprintfx(pszOC);

    CoTaskMemFree(pszOC);

errRtn:

    // delete the blocks and not the pointers
    if ( (pOC != NULL) && (blockCACHELIST != NULL))
    {
        for (ui = 0; ui < pOC->m_uCacheNodeMax; ui++)
        {
         if (pOC->m_pCacheList[ui].lpCacheNode != NULL)
            {
                delete[] ((char *)pOC->m_pCacheList[ui].lpCacheNode->m_pPresObj);
                delete[] ((char *)pOC->m_pCacheList[ui].lpCacheNode->m_pPresObjAfterFreeze);
                delete[] ((char *)pOC->m_pCacheList[ui].lpCacheNode);
            }
        }
    }
    delete[] blockCACHELIST;
    delete[] blockCCacheEnum;
    delete[] blockOC;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_saferefcount, exported
//
//  Synopsis:   dumps CSafeRefCount object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API( dump_saferefcount )
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszSRC;
    char            *blockSRC   = NULL;
    CSafeRefCount   *pSRC       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CSafeRefCount\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockSRC = new char[sizeof(CSafeRefCount)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockSRC,
                sizeof(CSafeRefCount),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CSafeRefCount))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pSRC = (CSafeRefCount *)blockSRC;

    // dump the structure
    pszSRC = DumpCSafeRefCount(pSRC, NO_PREFIX, 1);

    dprintf("CSafeRefCount @ 0x%x\n", dwAddr);
    dprintfx(pszSRC);

    CoTaskMemFree(pszSRC);

errRtn:

    delete[] blockSRC;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_threadcheck, exported
//
//  Synopsis:   dumps CThreadCheck object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_threadcheck)
{
    DWORD           dwReturnedCount;
    BOOL            fError;
    LPVOID          dwAddr;
    char            *pszTC;
    char            *blockTC    = NULL;
    CThreadCheck    *pTC        = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CThreadCheck\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockTC = new char[sizeof(CThreadCheck)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockTC,
                sizeof(CThreadCheck),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(CThreadCheck))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pTC = (CThreadCheck *)blockTC;

    // dump the structure
    pszTC = DumpCThreadCheck(pTC, NO_PREFIX, 1);

    dprintf("CThreadCheck @ 0x%x\n", dwAddr);
    dprintfx(pszTC);

    CoTaskMemFree(pszTC);

errRtn:

    delete[] blockTC;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_formatetc, exported
//
//  Synopsis:   dumps FORMATETC object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_formatetc)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszFE;
    char            *blockFE   = NULL;
    FORMATETC       *pFE       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of FORMATETC\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockFE = new char[sizeof(FORMATETC)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockFE,
                sizeof(FORMATETC),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: FORMATETC \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(FORMATETC))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pFE = (FORMATETC *)blockFE;

    // dump the structure
    pszFE = DumpFORMATETC(pFE, NO_PREFIX, 1);

    dprintf("FORMATETC @ 0x%x\n", dwAddr);
    dprintfx(pszFE);

    CoTaskMemFree(pszFE);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockFE;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_memstm, exported
//
//  Synopsis:   dumps MEMSTM object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_memstm)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszMS;
    char            *blockMS   = NULL;
    MEMSTM          *pMS       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of MEMSTM\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockMS = new char[sizeof(MEMSTM)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockMS,
                sizeof(MEMSTM),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: MEMSTM \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(MEMSTM))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pMS = (MEMSTM *)blockMS;

    // dump the structure
    pszMS = DumpMEMSTM(pMS, NO_PREFIX, 1);

    dprintf("MEMSTM @ 0x%x\n", dwAddr);
    dprintfx(pszMS);

    CoTaskMemFree(pszMS);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockMS;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_statdata, exported
//
//  Synopsis:   dumps STATDATA object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_statdata)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszSD;
    char            *blockSD   = NULL;
    STATDATA        *pSD       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of STATDATA\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockSD = new char[sizeof(STATDATA)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockSD,
                sizeof(STATDATA),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: STATDATA \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(STATDATA))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pSD = (STATDATA *)blockSD;

    // dump the structure
    pszSD = DumpSTATDATA(pSD, NO_PREFIX, 1);

    dprintf("STATDATA @ 0x%x\n", dwAddr);
    dprintfx(pszSD);

    CoTaskMemFree(pszSD);

errRtn:

    // delete the blocks and not the pointers
    delete[] blockSD;

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_stgmedium, exported
//
//  Synopsis:   dumps STGMEDIUM object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_stgmedium)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszSTGMEDIUM;
    char            *blockSTGMEDIUM   = NULL;
    STGMEDIUM       *pSTGMEDIUM       = NULL;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of STGMEDIUM\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockSTGMEDIUM = new char[sizeof(STGMEDIUM)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockSTGMEDIUM,
                sizeof(STGMEDIUM),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory STGMEDIUM");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (dwReturnedCount != sizeof(STGMEDIUM))
    {
        dprintf("Size of process memory read != requested\n");

        goto errRtn;
    }

    pSTGMEDIUM = (STGMEDIUM *)blockSTGMEDIUM;

    // dump the structure
    pszSTGMEDIUM = DumpSTGMEDIUM(pSTGMEDIUM, NO_PREFIX, 1);

    dprintf("STGMEDIUM @ 0x%x\n", dwAddr);
    dprintfx(pszSTGMEDIUM);

    CoTaskMemFree(pszSTGMEDIUM);

errRtn:

    delete[] blockSTGMEDIUM;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\olebind\widewrap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       widewrap.cxx
//
//  Contents:   Unicode wrapper API, used only on Chicago
//
//  Functions:  About fifty Win32 function wrappers
//
//  Notes:      'sz' is used instead of the "correct" hungarian 'psz'
//              throughout to enhance readability.
//
//              Not all of every Win32 function is wrapped here.  Some
//              obscurely-documented features may not be handled correctly
//              in these wrappers.  Caller beware.
//
//              These are privately exported for use by the Shell.
//
//  History:    28-Dec-93   ErikGav   Created
//              06-14-94    KentCe    Various Chicago build fixes.
//              21-Dec-94   BruceMa   Use olewcstombs + other fixes
//              21-Feb-95   BruceMa   Add support for AreFileApisANSI
//
//----------------------------------------------------------------------------

#include <windows.h>
#include "widewrap.h"

size_t olembstowcs(WCHAR *pwsz, const char *psz, size_t cCh);
size_t olewcstombs(char *psz, const WCHAR *pwsz , size_t cCh);

inline size_t olembstowcs(WCHAR *pwsz, const char *psz, size_t cCh)
{
    return MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, psz, -1, pwsz, cCh);
}

inline size_t olewcstombs(char *psz, const WCHAR *pwsz , size_t cCh)
{
    return WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, pwsz, -1, psz,
                               cCh, NULL, NULL);
}

#ifdef _CHICAGO_

#define HFINDFILE HANDLE
#define ERR ((char*) -1)


//
//  BUGBUG: 9869
//
//  The length of a Unicode string (in chars) and a DBCS string are not
//  always equal.  We need to review all WideChar to MultiByte conversions
//  logic to verify that the proper result buffer size is used.
//
//  Make the below Win95 only change to get the Win95 FE build out.
//

int UnicodeToAnsi(LPSTR sz, LPCWSTR pwsz, LONG cb)
{
    int ret;

    ret = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, pwsz, -1, sz, cb, NULL, NULL);

#if DBG==1
    if (ret == -1)
    {
        DebugBreak();
    }
#endif

    return ret;
}


int UnicodeToAnsiOem(LPSTR sz, LPCWSTR pwsz, LONG cb)
{
    int ret;

    if (AreFileApisANSI())
    {
        ret = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, pwsz, -1, sz,
                                  cb, NULL, NULL);
    }
    else
    {
        ret = WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, pwsz, -1, sz,
                                  cb, NULL, NULL);
    }

#if DBG==1
    if (ret == -1)
    {
        DebugBreak();
    }
#endif

    return ret;
}



#if DBG==1
int AnsiToUnicode(LPWSTR pwsz, LPCSTR sz, LONG cb)
{
    int ret;

    ret = olembstowcs(pwsz, sz, cb);

    if (ret == -1)
    {
        DebugBreak();
    }

    return ret;
}
#else
#define AnsiToUnicode olembstowcs
#endif



int AnsiToUnicodeOem(LPWSTR pwsz, LPCSTR sz, LONG cb)
{
    int ret;

    if (AreFileApisANSI())
    {
        ret = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cb, pwsz, cb);
    }
    else
    {
        ret = MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, sz, cb, pwsz, cb);
    }

#if DBG==1
    if (ret == -1)
    {
        DebugBreak();
    }
#endif

    return ret;
}




LPSTR Convert(LPCWSTR pwsz)
{
    LONG len;
    LPSTR sz = NULL;

    if (pwsz == NULL)
        goto Exit;

#if DBG==1
    // some Win32 API accept atoms in their string parameters
#endif

    len = (wcslen(pwsz) + 1) * 2;

    sz = new CHAR[len];
    if (sz==NULL)
    {
        sz = ERR;
        goto Exit;
    }

    __try
    {
        UnicodeToAnsi(sz, pwsz, len);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
#if DBG==1
        MessageBoxA(NULL, "GP fault in unicode conversion -- caught",
                   NULL, MB_OK);
#endif
        if (sz)
            delete sz;
        sz = ERR;
    }

Exit:
    return sz;
}









LPSTR ConvertOem(LPCWSTR pwsz)
{
    LONG len;
    LPSTR sz = NULL;

    if (pwsz == NULL)
        goto Exit;

#if DBG==1
    // some Win32 API accept atoms in their string parameters
#endif

    len = (wcslen(pwsz) + 1) * 2;

    sz = new CHAR[len];
    if (sz==NULL)
    {
        sz = ERR;
        goto Exit;
    }

    __try
    {
        UnicodeToAnsiOem(sz, pwsz, len);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
#if DBG==1
        MessageBoxA(NULL, "GP fault in unicode conversion -- caught",
                   NULL, MB_OK);
#endif
        if (sz)
            delete sz;
        sz = ERR;
    }

Exit:
    return sz;
}





HANDLE WINAPI CreateFileX(LPCWSTR pwsz, DWORD fdwAccess, DWORD fdwShareMask,
        LPSECURITY_ATTRIBUTES lpsa, DWORD fdwCreate, DWORD fdwAttrsAndFlags,
        HANDLE hTemplateFile)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFile\n");
    #endif

    CHAR  sz[MAX_PATH * 2];
    UnicodeToAnsiOem(sz, pwsz, sizeof(sz));

    return CreateFileA(sz, fdwAccess, fdwShareMask, lpsa, fdwCreate,
            fdwAttrsAndFlags, hTemplateFile);
}

BOOL WINAPI DeleteFileX(LPCWSTR pwsz)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("DeleteFile\n");
    #endif

    CHAR  sz[MAX_PATH * 2];
    UnicodeToAnsi(sz, pwsz, sizeof(sz));

    return DeleteFileA(sz);
}


LONG APIENTRY RegOpenKeyX(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegOpenKey\n");
    #endif

    LONG ret;
    LPSTR sz;

    sz = Convert(pwszSubKey);

    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegOpenKeyA(hKey, sz, phkResult);
    if (sz)
        delete sz;
    return ret;
}

LONG APIENTRY RegQueryValueX(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue,
    PLONG   lpcbValue)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegQueryValue\n");
    #endif

    LONG  cb, ret;
    LPSTR szValue = NULL;
    LPSTR sz;

    sz = Convert(pwszSubKey);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegQueryValueA(hKey, sz, NULL, &cb);

    // If the caller was just asking for the size of the value, jump out
    //  now, without actually retrieving and converting the value.

    if (pwszValue == NULL)
    {
        // Adjust size of buffer to report, to account for CHAR -> WCHAR
        *lpcbValue = cb * sizeof(WCHAR);
        goto Exit;
    }


    if (ret == ERROR_SUCCESS)
    {
        // If the caller was asking for the value, but allocated too small
        // of a buffer, set the buffer size and jump out.

        if (*lpcbValue < (LONG) (cb * sizeof(WCHAR)))
        {
            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbValue = cb * sizeof(WCHAR);
            ret = ERROR_MORE_DATA;
            goto Exit;
        }

        // Otherwise, retrieve and convert the value.

        szValue = new CHAR[cb];
        if (szValue == NULL)
        {
            ret = ERROR_OUTOFMEMORY;
            goto Exit;
        }

        ret = RegQueryValueA(hKey, sz, szValue, &cb);

        if (ret == ERROR_SUCCESS)
        {
            AnsiToUnicode(pwszValue, szValue, cb);

            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbValue = cb * sizeof(WCHAR);
        }
    }

Exit:
    if (szValue)
        delete szValue;
    if (sz)
        delete sz;

    return ret;
}

LONG APIENTRY RegSetValueX(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType,
    LPCWSTR lpData, DWORD cbData)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegSetValue\n");
    #endif

    LPSTR szKey = NULL;
    LPSTR szValue = NULL;
    LONG  ret = ERROR_OUTOFMEMORY;

    szKey = Convert(lpSubKey);
    if (szKey == ERR)
    {
        szKey = NULL;
        goto Exit;
    }

    szValue = Convert(lpData);
    if (szValue == ERR)
    {
        szValue = NULL;
        goto Exit;
    }

    ret = RegSetValueA(hKey, szKey, dwType, szValue, cbData);

Exit:
    if (szKey)
        delete szKey;
    if (szValue)
        delete szValue;
    return ret;
}

LONG APIENTRY RegSetValueExX(HKEY hKey,
			     LPCWSTR lpSubKey,
			     DWORD dwReserved,
			     DWORD dwType,
			     LPBYTE lpData,
			     DWORD cbData)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegSetValueEx\n");
    #endif

    LPSTR szKey = NULL;
    LPBYTE szValue = lpData;
    LONG  ret = ERROR_OUTOFMEMORY;

    szKey = Convert(lpSubKey);
    if (szKey == ERR)
    {
        szKey = NULL;
        goto Exit;
    }

    if (dwType == REG_SZ)
    {
	szValue = (LPBYTE) Convert((LPWSTR)lpData);
    }
    if (szValue == (LPBYTE) ERR)
    {
        szValue = NULL;
        goto Exit;
    }

    ret = RegSetValueExA(hKey, szKey, dwReserved, dwType, szValue, cbData);

Exit:
    if (szKey)
        delete szKey;
    if ((szValue != lpData) && (szValue != (LPBYTE)ERR))
        delete szValue;
    return ret;
}

UINT WINAPI RegisterWindowMessageX(LPCWSTR lpString)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegisterWindowMessage\n");
    #endif

    UINT ret;
#if 0
    LPSTR sz;

    sz = Convert(lpString);
    if (sz == ERR)
    {
        return 0;
    }
#else
    // BUGBUG: CairOLE calls this from libmain -- have to use static buffer

    CHAR sz[200];
    UnicodeToAnsi(sz, lpString, sizeof(sz));
#endif

    ret = RegisterWindowMessageA(sz);
#if 0
    delete sz;
#endif
    return ret;
}

LONG
APIENTRY
RegOpenKeyExX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegOpenKeyEx\n");
    #endif

    LONG ret;
    LPSTR sz;

    sz = Convert(lpSubKey);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegOpenKeyExA(hKey, sz, ulOptions, samDesired, phkResult);
    if (sz)
        delete sz;
    return ret;
}

LONG
APIENTRY
RegQueryValueExX(
    HKEY hKey,
    LPWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegQueryValueEx\n");
    #endif

    LPBYTE lpTempBuffer;
    DWORD dwTempType;
    DWORD cb, cbRequired;
    LONG  ret;
    LPSTR sz;
    LPWSTR pwszTempWide;
    LPSTR pszTempNarrow;
    ULONG ulStringLength;

    sz = Convert(lpValueName);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegQueryValueExA(hKey, sz, lpReserved, &dwTempType, NULL, &cb);

    // If the caller was just asking for the size of the value, jump out
    //  now, without actually retrieving and converting the value.

    if (lpData == NULL)
    {
        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            // Adjust size of buffer to report, to account for CHAR -> WCHAR

            if (lpcbData != NULL)
                *lpcbData = cb * sizeof(WCHAR);
            break;

        default:

            if (lpcbData != NULL)
                *lpcbData = cb;
            break;
        }

        // Set the type, if required.
        if (lpType != NULL)
        {
            *lpType = dwTempType;
        }

        goto Exit;
    }


    if (ret == ERROR_SUCCESS)
    {
        //
        // Determine the size of buffer needed
        //

        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            cbRequired = cb * sizeof(WCHAR);
            break;

        default:

            cbRequired = cb;
            break;
        }

        // If the caller was asking for the value, but allocated too small
        // of a buffer, set the buffer size and jump out.

        if (lpcbData != NULL && *lpcbData < cbRequired)
        {
            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbData = cbRequired;

            // Set the type, if required.
            if (lpType != NULL)
            {
                *lpType = dwTempType;
            }

            ret = ERROR_MORE_DATA;
            goto Exit;
        }

        // Otherwise, retrieve and convert the value.

        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            lpTempBuffer = new BYTE[cbRequired];
            if (lpTempBuffer == NULL)
            {
                return ERROR_OUTOFMEMORY;
            }

            ret = RegQueryValueExA(hKey,
                                  sz,
                                  lpReserved,
                                  &dwTempType,
                                  lpTempBuffer,
                                  &cb);

            if (ret == ERROR_SUCCESS)
            {
                switch (dwTempType)
                {
                case REG_EXPAND_SZ:
                case REG_SZ:

                    AnsiToUnicode((LPWSTR) lpData, (LPSTR) lpTempBuffer, cb);

                    // Adjust size of buffer to report, to account for CHAR -> WCHAR
                    *lpcbData = cbRequired;

                    // Set the type, if required.
                    if (lpType != NULL)
                    {
                        *lpType = dwTempType;
                    }
                    break;

                case REG_MULTI_SZ:

                    pszTempNarrow = (LPSTR) lpTempBuffer;
                    pwszTempWide = (LPWSTR) lpData;

                    while (pszTempNarrow != NULL)
                    {
                        ulStringLength = strlen(pszTempNarrow) + 1;
                        AnsiToUnicode(pwszTempWide,
                                      pszTempNarrow,
                                      ulStringLength);

                        // Compiler will scale appropriately here
                        pszTempNarrow += ulStringLength;
                        pwszTempWide += ulStringLength;
                    }
                    break;
                }
            }

            if (lpTempBuffer)
                delete lpTempBuffer;

            break;

        default:

            //
            // No conversion of out parameters needed.  Just call narrow
            // version with args passed in, and return directly.
            //

            ret = RegQueryValueExA(hKey,
                                   sz,
                                   lpReserved,
                                   lpType,
                                   lpData,
                                   lpcbData);

        }
    }

Exit:
    if (sz)
       delete sz;
    return ret;
}



ATOM
WINAPI
RegisterClassX(
    CONST WNDCLASSW *lpWndClass)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegisterClass\n");
    #endif

    WNDCLASSA wc;
    ATOM      ret;
    BOOL      fAtom = FALSE;


    memcpy(&wc, lpWndClass, sizeof(WNDCLASS));

    wc.lpszMenuName = Convert(lpWndClass->lpszMenuName);
    if (wc.lpszMenuName==ERR)
    {
        return NULL;
    }

    if (HIWORD(lpWndClass->lpszClassName) == 0)
    {
        wc.lpszClassName = (LPSTR) lpWndClass->lpszClassName;
        fAtom = TRUE;
    }
    else
    {
        wc.lpszClassName = Convert(lpWndClass->lpszClassName);
        if (wc.lpszClassName==ERR)
        {
            if ((LPSTR) wc.lpszMenuName)
                delete (LPSTR) wc.lpszMenuName;
            return NULL;
        }
    }

    ret = RegisterClassA(&wc);
    if ((LPSTR) wc.lpszMenuName)
        delete (LPSTR) wc.lpszMenuName;
    if (!fAtom) delete (LPSTR) wc.lpszClassName;
    return ret;
}

BOOL
WINAPI
UnregisterClassX(
    LPCWSTR lpClassName,
    HINSTANCE hInstance)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("UnregisterClass\n");
    #endif

    LPSTR sz;
    BOOL  ret;
    BOOL  fAtom = FALSE;

    if (HIWORD(lpClassName) == 0)
    {
        sz = (LPSTR) lpClassName;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpClassName);
        if (sz == ERR)
            return FALSE;
    }

    ret = UnregisterClassA(sz, hInstance);
    if (!fAtom) delete sz;
    return ret;
}

HANDLE
WINAPI
GetPropX(
    HWND hWnd,
    LPCWSTR lpString)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetProp\n");
    #endif

    HANDLE ret;
    LPSTR  sz;
    BOOL   fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        fAtom = TRUE;
        sz = (LPSTR) lpString;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = GetPropA(hWnd, sz);
    if (!fAtom) delete sz;
    return ret;
}


BOOL
WINAPI
SetPropX(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("SetProp\n");
    #endif

    BOOL  ret;
    LPSTR sz;
    BOOL  fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        sz = (LPSTR) lpString;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = SetPropA(hWnd, sz, hData);
    if (!fAtom) delete sz;
    return ret;
}


HANDLE
WINAPI
RemovePropX(
    HWND hWnd,
    LPCWSTR lpString)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RemoveProp\n");
    #endif

    HANDLE ret;
    LPSTR  sz;
    BOOL   fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        sz = (LPSTR) lpString;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = RemovePropA(hWnd, sz);
    if (!fAtom) delete sz;
    return ret;
}


UINT
WINAPI
GetProfileIntX(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT     nDefault
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetProfileInt\n");
    #endif

    LPSTR szApp;
    LPSTR szKey;
    UINT  ret;

    szApp = Convert(lpAppName);
    if (szApp==ERR)
    {
        return nDefault;
    }

    szKey = Convert(lpKeyName);
    if (szApp==ERR)
    {
        if (szApp)
            delete szApp;
        return nDefault;
    }

    ret = GetProfileIntA(szApp, szKey, nDefault);
    if (szApp)
        delete szApp;
    if (szKey)
        delete szKey;
    return ret;
}

ATOM
WINAPI
GlobalAddAtomX(
    LPCWSTR lpString
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalAddAtom\n");
    #endif

    ATOM ret;
    LPSTR sz;

    sz = Convert(lpString);
    if (sz==ERR)
    {
        return NULL;
    }

    ret = GlobalAddAtomA(sz);
    if (sz)
        delete sz;
    return ret;
}

UINT
WINAPI
GlobalGetAtomNameX(
    ATOM nAtom,
    LPWSTR pwszBuffer,
    int nSize
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalGetAtomName\n");
    #endif

    LPSTR sz;
    UINT ret;

    sz = new CHAR[nSize];
    if (sz == NULL)
    {
        return 0;
    }

    ret = GlobalGetAtomNameA(nAtom, sz, nSize);
    if (ret)
    {
        AnsiToUnicode(pwszBuffer, sz, lstrlenA(sz) + 1);
    }
    if (sz)
        delete sz;
    return ret;
}


DWORD
WINAPI
GetModuleFileNameX(
    HINSTANCE hModule,
    LPWSTR pwszFilename,
    DWORD nSize
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetModuleFileName\n");
    #endif

    LPSTR sz;
    DWORD ret;

    sz = new CHAR[nSize];
    if (sz == NULL)
    {
        return 0;
    }

    ret = GetModuleFileNameA(hModule, sz, nSize);
    if (ret)
    {
        AnsiToUnicode(pwszFilename, sz, lstrlenA(sz) + 1);
    }

    if (sz)
        delete sz;
    return ret;
}


LPWSTR
WINAPI
CharPrevX(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CharPrev\n");
    #endif

    if (lpszCurrent == lpszStart)
    {
        return (LPWSTR) lpszStart;
    }
    else
    {
        return (LPWSTR) lpszCurrent - 1;
    }
}

HFONT WINAPI CreateFontX(int a, int b, int c, int d, int e, DWORD f,
                         DWORD g, DWORD h, DWORD i, DWORD j, DWORD k,
                         DWORD l, DWORD m, LPCWSTR pwsz)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFont\n");
    #endif

    LPSTR sz;
    HFONT ret;

    sz = Convert(pwsz);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = CreateFontA(a,b,c,d,e,f,g,h,i,j,k,l,m,sz);
    if (sz)
        delete sz;
    return ret;
}


HINSTANCE
WINAPI
LoadLibraryX(
    LPCWSTR pwszFileName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("LoadLibrary\n");
    #endif

    HINSTANCE ret;
    LPSTR sz;

    sz = Convert(pwszFileName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = LoadLibraryA(sz);
    if (sz)
        delete sz;
    return ret;
}


HMODULE
WINAPI
LoadLibraryExX(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("LoadLibrary\n");
    #endif

    HINSTANCE ret;
    LPSTR sz;

    sz = ConvertOem(lpLibFileName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = LoadLibraryExA(sz, hFile, dwFlags);
    if (sz)
        delete sz;
    return ret;
}



LONG
APIENTRY
RegDeleteKeyX(
    HKEY hKey,
    LPCWSTR pwszSubKey
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegDeleteKey\n");
    #endif

    LONG ret;
    LPSTR sz;

    sz = Convert(pwszSubKey);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegDeleteKeyA(hKey, sz);
    if (sz)
        delete sz;
    return ret;
}

BOOL
APIENTRY
CreateProcessX(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateProcess\n");
    #endif

    STARTUPINFOA si;
    BOOL         ret = FALSE;
    LPSTR        szApp = NULL;
    LPSTR        szCommand = NULL;
    LPSTR        szDir = NULL;

    memcpy(&si, lpStartupInfo, sizeof(STARTUPINFO));

    si.lpTitle = NULL;

    si.lpDesktop = Convert(lpStartupInfo->lpDesktop);
    if (si.lpDesktop == ERR)
    {
        si.lpDesktop = NULL;
        goto Error;
    }
    si.lpTitle = Convert(lpStartupInfo->lpTitle);
    if (si.lpTitle == ERR)
    {
        si.lpTitle = NULL;
        goto Error;
    }

    szApp = Convert(lpApplicationName);
    if (szApp == ERR)
    {
        szApp = NULL;
        goto Error;
    }
    szCommand = ConvertOem(lpCommandLine);
    if (szCommand == ERR)
    {
        szCommand = NULL;
        goto Error;
    }
    szDir = Convert(lpCurrentDirectory);
    if (szDir == ERR)
    {
        szDir = NULL;
        goto Error;
    }

    ret = CreateProcessA(szApp, szCommand, lpProcessAttributes,
                lpThreadAttributes, bInheritHandles, dwCreationFlags,
                lpEnvironment, szDir, &si, lpProcessInformation);

Error:
    if (si.lpDesktop)
        delete si.lpDesktop;
    if (si.lpTitle)
        delete si.lpTitle;

    if (szApp)
        delete szApp;
    if (szCommand)
        delete szCommand;
    if (szDir)
        delete szDir;

    return ret;
}

LONG
APIENTRY
RegEnumKeyExX(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegEnumKeyEx\n");
    #endif

    LPSTR szName;
    LPSTR szClass = NULL;
    LONG  ret = ERROR_OUTOFMEMORY;

    szName = new CHAR[*lpcbName];
    if (szName == NULL)
        goto Exit;

    if (lpClass != NULL)
    {
        szClass = new CHAR[*lpcbClass + 1];
        if (szName == NULL)
            goto Exit;
    }

    //
    //  Return lengths do not include zero char.
    //
    ret = RegEnumKeyExA(hKey, dwIndex, szName, lpcbName, lpReserved,
                       szClass, lpcbClass, lpftLastWriteTime);

    if (ret == ERROR_SUCCESS)
    {
        AnsiToUnicode(lpName, szName, *lpcbName + 1);

        if (szClass)
        {
            AnsiToUnicode(lpClass, szClass, *lpcbClass + 1);
        }
    }

Exit:
    return ret;
}

BOOL
WINAPI
AppendMenuX(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDnewItem,
    LPCWSTR lpnewItem
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("AppendMenu\n");
    #endif

    BOOL  ret;
    LPSTR sz;

    if (uFlags == MF_STRING)
    {
        sz = Convert(lpnewItem);
        if (sz==ERR)
        {
            return FALSE;
        }
    }
    else
    {
        sz = (LPSTR) lpnewItem;
    }

    ret = AppendMenuA(hMenu, uFlags, uIDnewItem, sz);

    if (uFlags == MF_STRING)
    {
        if (sz)
            delete sz;
    }

    return ret;
}

HANDLE
WINAPI
OpenEventX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("OpenEvent\n");
    #endif

    LPSTR sz;
    HANDLE ret;

    sz = Convert(lpName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = OpenEventA(dwDesiredAccess, bInheritHandle, sz);
    if (sz)
        delete sz;
    return ret;
}

HANDLE
WINAPI
CreateEventX(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateEvent\n");
    #endif

    LPSTR sz;
    HANDLE ret;

    sz = Convert(lpName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = CreateEventA(lpEventAttributes, bManualReset, bInitialState, sz);
    if (sz)
        delete sz;
    return ret;
}

UINT
WINAPI
GetDriveTypeX(
    LPCWSTR lpRootPathName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetDriveType\n");
    #endif

    LPSTR sz;
    UINT ret;

    sz = Convert(lpRootPathName);
    if (sz == ERR)
    {
        return 0;
    }

    ret = GetDriveTypeA(sz);
    if (sz)
        delete sz;
    return ret;
}

DWORD
WINAPI
GetFileAttributesX(
    LPCWSTR lpFileName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetFileAttributes\n");
    #endif

    LPSTR sz;
    DWORD ret;

    sz = ConvertOem(lpFileName);
    if (sz == ERR)
        return 0xFFFFFFFF;

    ret = GetFileAttributesA(sz);
    if (sz)
        delete sz;
    return ret;
}

LONG
APIENTRY
RegEnumKeyX(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegEnumKey\n");
    #endif

    CHAR sz[MAX_PATH+1];
    LONG ret;

    //
    //  Return lengths do not include zero char.
    //
    ret = RegEnumKeyA(hKey, dwIndex, sz, cbName);
    if (ret == ERROR_SUCCESS)
    {
        AnsiToUnicode(lpName, sz, lstrlenA(sz) + 1);
    }
    return ret;
}

HFINDFILE
WINAPI
FindFirstFileX(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW pwszFd
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("FindFirstFile\n");
    #endif

    WIN32_FIND_DATAA fd;
    CHAR             sz[MAX_PATH * 2];
    HFINDFILE        ret;
    int              len = wcslen(lpFileName) + 1;

    UnicodeToAnsiOem(sz, lpFileName, sizeof(sz));
    ret = FindFirstFileA(sz, &fd);
    if (ret != INVALID_HANDLE_VALUE)
    {
        memcpy(pwszFd, &fd, sizeof(FILETIME)*3 + sizeof(DWORD)*5);
        AnsiToUnicodeOem(pwszFd->cFileName, fd.cFileName,
                         lstrlenA(fd.cFileName) + 1);
        AnsiToUnicodeOem(pwszFd->cAlternateFileName, fd.cAlternateFileName,
                         14);
    }

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   wsprintfX
//
//  Synopsis:   Nightmare string function
//
//  Arguments:  [pwszOut]    --
//              [pwszFormat] --
//              [...]        --
//
//  Returns:
//
//  History:    1-06-94   ErikGav   Created
//
//  Notes:      If you're reading this, you're probably having a problem with
//              this function.  Make sure that your "%s" in the format string
//              says "%ws" if you are passing wide strings.
//
//              %s on NT means "wide string"
//              %s on Chicago means "ANSI string"
//
//----------------------------------------------------------------------------

int WINAPIV wsprintfX(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("wsprintf\n");
    #endif

    LPSTR szFormat;
    LPWSTR pwszTemp = NULL;
    int i = 0;

    // Convert the format string over

    szFormat = Convert(pwszFormat);
    if (szFormat == ERR)
    {
        szFormat = NULL;
        goto Exit;
    }

    // magic voodoo follows:
    //
    // 1. Call wvsprintf passing the varargs
    // 2. Use the pwszOut as a temp buffer to hold the ANSI output
    // 3. Save the returned characters

    i = wvsprintfA((LPSTR) pwszOut, szFormat,
                  (LPSTR) ((BYTE*)&pwszFormat) + sizeof(pwszFormat));

    // allocate a buffer for the Ansi to Unicode conversion

    pwszTemp = new WCHAR[i+1];

    // convert the string

    AnsiToUnicode(pwszTemp, (LPSTR) pwszOut, i+1);

    // copy it to the out buffer

    wcsncpy(pwszOut, pwszTemp, i+1);

Exit:
    if (pwszTemp)
        delete pwszTemp;
    if (szFormat)
        delete szFormat;
    return i;
}

BOOL
WINAPI
GetComputerNameX(
    LPWSTR pwszName,
    LPDWORD lpcchBuffer
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetComputerName\n");
    #endif

    BOOL ret;
    LPSTR sz;

    sz  = new CHAR[*lpcchBuffer];
    ret = GetComputerNameA(sz, lpcchBuffer);

    if (ret)
    {
        AnsiToUnicode(pwszName, sz, *lpcchBuffer);
    }

    if (sz)
        delete sz;
    return ret;
}

DWORD
WINAPI
GetFullPathNameX(
    LPCWSTR lpFileName,
    DWORD   cchBuffer,
    LPWSTR  lpPathBuffer,
    LPWSTR *lppFilePart
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetFullPathName\n");
    #endif

    LPSTR szFileName;
    CHAR  szPathBuffer[MAX_PATH];
    LPSTR szFilePart;
    DWORD ret;


    szFileName = ConvertOem(lpFileName);
    if (szFileName == ERR)
        return 0;

    ret = GetFullPathNameA(szFileName, cchBuffer, szPathBuffer, &szFilePart);

    AnsiToUnicode(lpPathBuffer, szPathBuffer, cchBuffer);

    *lppFilePart = lpPathBuffer + (szFilePart - szPathBuffer);

    if (szFileName)
        delete szFileName;

    return ret;
}


DWORD
WINAPI
GetShortPathNameX(
    LPCWSTR lpszFullPath,
    LPWSTR  lpszShortPath,
    DWORD   cchBuffer
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetShortPathName\n");
    #endif

    LPSTR szFullPath;
    CHAR  szShortBuffer[MAX_PATH];
    DWORD ret;


    szFullPath = Convert(lpszFullPath);
    if (szFullPath == ERR)
        return 0;

    if (lpszShortPath == NULL)
    {
        ret = GetShortPathNameA(szFullPath, NULL, cchBuffer);
    }
    else
    {
        ret = GetShortPathNameA(szFullPath, szShortBuffer, sizeof(szShortBuffer));

        //
        //  Only convert the actual data, not the whole buffer.
        //
        if (cchBuffer > ret + 1)
            cchBuffer = ret + 1;

        AnsiToUnicode(lpszShortPath, szShortBuffer, cchBuffer);
    }

    delete szFullPath;

    return ret;
}


DWORD
WINAPI
SearchPathX(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    )
{
    LPSTR lpszFileName;
    CHAR  szBuffer[MAX_PATH];
    DWORD ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("SearchPath\n");
    #endif

    lpszFileName = Convert(lpFileName);
    if (lpszFileName == ERR)
        return 0;

    ret = SearchPathA(NULL, lpszFileName, NULL, sizeof(szBuffer), szBuffer, NULL);

    AnsiToUnicode(lpBuffer, szBuffer, lstrlenA(szBuffer) + 1);

    delete lpszFileName;

    return ret;
}


ATOM
WINAPI
GlobalFindAtomX(
    LPCWSTR lpString
    )
{
    LPSTR lpszString;
    ATOM  retAtom;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalFindAtom\n");
    #endif

    lpszString = Convert(lpString);
    if (lpszString == ERR)
        return 0;

    retAtom = GlobalFindAtomA(lpszString);

    delete lpszString;

    return retAtom;
}


int
WINAPI
GetClassNameX(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount)
{
    LPSTR lpszClassName;
    int  ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetClassName\n");
    #endif

    lpszClassName = Convert(lpClassName);
    if (lpszClassName == ERR)
        return 0;

    ret = GetClassNameA(hWnd, lpszClassName, nMaxCount);

    delete lpszClassName;

    return ret;
}


int
WINAPI
lstrlenX(LPCWSTR lpString)
{
    return wcslen(lpString);
}

LPWSTR
WINAPI
lstrcatX(
    LPWSTR lpString1,
    LPCWSTR lpString2)
{
    return wcscat(lpString1, lpString2);
}

int
WINAPI
lstrcmpX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return wcscmp(lpString1, lpString2);
}

int
WINAPI
lstrcmpiX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return _wcsicmp(lpString1, lpString2);
}

LPWSTR
WINAPI
lstrcpyX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return wcscpy(lpString1, lpString2);
}



HANDLE
WINAPI
CreateFileMappingX(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    )
{
    LPSTR lpszAName;
    HANDLE ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFileMapping\n");
    #endif

    lpszAName = Convert(lpName);

    if (lpszAName == ERR)
    {
        return 0;
    }

    ret = CreateFileMappingA(
        hFile,
        lpFileMappingAttributes,
        flProtect,
        dwMaximumSizeHigh,
        dwMaximumSizeLow,
        lpszAName);

    delete lpszAName;

    return ret;
}


HANDLE
WINAPI
OpenFileMappingX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    LPSTR lpszAName;
    HANDLE ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFileMapping\n");
    #endif

    lpszAName = Convert(lpName);

    if (lpszAName == ERR)
    {
        return 0;
    }

    ret = OpenFileMappingA(
        dwDesiredAccess,
        bInheritHandle,
        lpszAName);

    delete lpszAName;

    return ret;
}

#endif   //  CHICAGO

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oledll2\oledll2.h ===
//+-------------------------------------------------------------------
//
//  File:       oledll2.h
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      FunctionInAnotherDLL
//
//              This DLL is used to to test loading of in
//              InProcServer that uses another statically linked DLL.  
//              The extra DLL (OleDll2.DLL) should not be on the path 
//              when the test is run.  The entry point FuntionInAnotherDLL
//              is exported by OleDll2.DLL
//
//
//  History:	30-Jun-94      AndyH        Created
//
//---------------------------------------------------------------------

//
//  Entry point for testing statically linked DLL.
//


BOOL FunctionInAnotherDLL ( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oleexts\daytona\makefile.inc ===
obj\i386\oledbg.def: oledbg.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\app.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:  	app.cpp
//
//  Contents:	implementation of OleTestApp class methods
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//    		06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"

//+-------------------------------------------------------------------------
//
//  Member: 	OleTestApp::Reset
//
//  Synopsis:	clears internal variables in the OleTestApp instance
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void OleTestApp::Reset(void)
{
	int i;

	m_message 	= NULL;
	m_wparam 	= NULL;
	m_lparam	= NULL;

	for( i = 0; i < (sizeof(m_rgTesthwnd)/sizeof(m_rgTesthwnd[0])); i++ )
	{
		m_rgTesthwnd[i] = NULL;
	}

	m_Temp = NULL;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\appwin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       appwin.h
//
//  Contents:   constants for the menu items and so forth
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//
//--------------------------------------------------------------------------

#ifndef _APPWIN_H
#define _APPWIN_H

#define IDM_EXIT        100
#define IDM_COPY        103
#define IDM_SAVE        104
#define IDM_RUN_BASE    200

#define IDD_ASSERTIONFAILURE            101

#define IDC_EDIT                        1003
#define IDB_BREAK                       1004

#endif //!_APPWIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\app.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	app.h
//
//  Contents:	The class declaration of OleTestApp class..
//
//  Classes: 	OleTestApp
//
//  History:    dd-mmm-yy Author    Comment
//		06-Feb-93 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _APP_H
#define _APP_H

//+-------------------------------------------------------------------------
//
//  Class:	OleTestApp
//
//  Purpose: 	Stores all global app data for the oletest driver app
//		(such as the to-do stack).
//
//  History:    dd-mmm-yy Author    Comment
// 		06-Feb-93 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

class OleTestApp
{
public:
	// driver information
	HINSTANCE	m_hinst;
	HWND		m_hwndMain;
	HWND		m_hwndEdit;
	TaskStack	m_TaskStack;
	BOOL		m_fInteractive;	//if TRUE, then we should not
					//shut down when tests are
					//completed.

	LPSTR		m_pszDebuggerOption;
	FILE *		m_fpLog;

    // set to TRUE when a test fails, reset after WM_TESTSCOMPLETED
    BOOL        m_fGotErrors;

	// information on running test apps
	void Reset(void);		//zeros all the data below.

	UINT		m_message;
	WPARAM		m_wparam;
	LPARAM		m_lparam;

	// variables that test routines may modify.
	HWND		m_rgTesthwnd[10];
	void *		m_Temp;		//temporary dumping ground for
					//data that spans callback functions.
};

// declaration for the global instance of OleTestApp

extern OleTestApp vApp;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\assert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	assert.h
//
//  Contents:	Declaraions of assert
//
//  Classes: 	
//
//  History:    dd-mmm-yy Author    Comment
//              09-Dec-94 MikeW     author
//
//--------------------------------------------------------------------------

#ifndef _ASSERT_H_
#define _ASSERT_H_

//
// Misc prototypes
//
INT_PTR CALLBACK DlgAssertProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void OleTestAssert(char *, char *, UINT);

//
// Assertion macros
//
#define Assert(x)           assert(x)
#define assert(x)			{if (!(x)) OleTestAssert(#x, __FILE__, __LINE__);}
#define AssertSz(x, exp)	{if (!(x)) OleTestAssert(exp, __FILE__, __LINE__);}

#endif //_ASSERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\assert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   assert.cpp
//
//  Contents:   Assertion handling code for OleTest
//
//  Classes:
//
//  Functions:  OleTestAssert
//              DlgAssertProc
//
//  History:    dd-mmm-yy Author    Comment
//              09-Dec-94 MikeW     author              
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "appwin.h"

//+-------------------------------------------------------------------------
//
//  Function:   OleTestAssert
//
//  Synopsis:   Reports assertion failures to the user
//
//  Effects:
//
//  Arguments:  [pszMessage]    -- the assertion message
//              [pszFile]       -- the file it occured in
//              [uLine]         -- the line it occured at
//
//  Requires:   
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Format the message and then put up a dialog box for the user.
//              They can then choose to abort the test, break to the debugger,
//              or ignore the assertion.
//
//  History:    dd-mmm-yy Author    Comment
//              09-Dec-94 MikeW     author
//
//  Notes:
//
//--------------------------------------------------------------------------

void OleTestAssert(char *pszMessage, char *pszFile, UINT uLine)
{
    char        szErrorMessage[3 * 80];         // room for 3 lines of info
    int         cch;
    int         nAction;

    OutputDebugString("OleTest -- Assertion Failure\r\n");

    //
    // format the message
    //
        
    cch = _snprintf(szErrorMessage,
            sizeof(szErrorMessage),
            "%s\r\nIn file: %s\r\nAt line: %u",
            pszMessage,
            pszFile,
            uLine);

    if (cch < 0)
    {
        //
        // the whole assertion message doesn't fit in the buffer so
        // just worry about the file name and line number
        //

        OutputDebugString(pszMessage);  // send original text to the debugger
        OutputDebugString("\r\n");
                
        _snprintf(szErrorMessage,
                sizeof(szErrorMessage),
                "In file: %s\r\nAt line: %d",
                pszFile, 
                uLine);

        szErrorMessage[sizeof(szErrorMessage) - 1] = '\0';  // just in case
    }

    OutputDebugString(szErrorMessage);
    OutputDebugString("\r\n");

    nAction = DialogBoxParam(vApp.m_hinst,          // get the users choice
            MAKEINTRESOURCE(IDD_ASSERTIONFAILURE), 
            vApp.m_hwndMain, 
            DlgAssertProc,
            (LPARAM) szErrorMessage);
          
    switch (nAction)
    {
    case IDABORT:                                   // abort the test
        RaiseException(E_ABORT, 0, 0, NULL);

    case IDB_BREAK:                                 // break into the debugger
        DebugBreak();
        break;

    case IDIGNORE:                                  // ignore the assertion
        break;

    default:                                        // whoops
        RaiseException(E_UNEXPECTED, 0, 0, NULL);
    }
}   


//+-------------------------------------------------------------------------
//
//  Function:   DlgAssertProc
//
//  Synopsis:   Window procedure for the assertion dialog box
//
//  Effects:
//
//  Arguments:  [hWnd]      -- dialog window
//              [uMsg]      -- message
//              [wParam]    -- wParam
//              [lParam]    -- lParam (for INITDIALOG it points to assert text)
//
//  Requires:   
//
//  Returns:    BOOL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Just wait for a button to be pressed
//
//  History:    dd-mmm-yy Author    Comment
//              09-Dec-94 MikeW     author
//
//  Notes:
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK DlgAssertProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        DeleteMenu(GetSystemMenu(hWnd, FALSE), SC_CLOSE, MF_BYCOMMAND);
        DrawMenuBar(hWnd);

        SetDlgItemText(hWnd, IDC_EDIT, (LPCSTR) lParam);

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
            case IDABORT:
            case IDB_BREAK:
            case IDIGNORE:
                EndDialog(hWnd, LOWORD(wParam));
                return TRUE;
                            
            default:
                return FALSE;
        }

    default:
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\attest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       attest.cpp
//
//  Contents:   upper layer tests to test the apartment thread model
//
//  Classes:    CBareFactory
//              CATTestIPtrs
//
//  Functions:
//              ATTest
//              CreateEHelperQuery
//              LinkObjectQuery
//              GetClipboardQuery
//              CreateEHTest
//              LinkObjectTest
//              GetClipboardTest
//              OleLinkMethods
//              OleObjectMethods
//              PersistStorageMethods
//              DataObjectMethods
//              RunnableObjectMethods
//              ViewObject2Methods
//              OleCache2Methods
//              ExternalConnectionsMethods
//              CHECK_FOR_THREAD_ERROR (macro)
//
//  History:    dd-mmm-yy Author    Comment
//              04-Jan-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "attest.h"

#include "initguid.h"
DEFINE_GUID(CLSID_SimpSvr,
            0xBCF6D4A0,
            0xBE8C,
            0x1068,
            0xB6,
            0xD4,
            0x00,
            0xDD,
            0x01,
            0x0C,
            0x05,
            0x09);

DEFINE_GUID(CLSID_StdOleLink,
            0x00000300,
            0,
            0,
            0xC0,
            0,
            0,
            0,
            0,
            0,
            0,
            0x46);

//+-------------------------------------------------------------------------
//
//  Member:     CATTestIPtrs::CATTestIPtrs(), public
//
//  Synopsis:   constructor
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
CATTestIPtrs::CATTestIPtrs()
{
    _pOleObject         = NULL;
    _pOleCache2         = NULL;
    _pDataObject        = NULL;
    _pPersistStorage    = NULL;
    _pRunnableObject    = NULL;
    _pViewObject2       = NULL;
    _pExternalConnection= NULL;
    _pOleLink           = NULL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CATTestIPtrs::Reset(), public
//
//  Synopsis:   resets all pointers to NULL
//
//  Effects:    releases all objects
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   releases all objects and NULLs pointer
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP CATTestIPtrs::Reset()
{
    if (_pOleObject != NULL)
    {
        _pOleObject->Release();
        _pOleObject = NULL;
    }

    if (_pOleCache2 != NULL)
    {
        _pOleCache2->Release();
        _pOleCache2 = NULL;
    }

    if (_pDataObject != NULL)
    {
        _pDataObject->Release();
        _pDataObject = NULL;
    }

    if (_pPersistStorage != NULL)
    {
        _pPersistStorage->Release();
        _pPersistStorage = NULL;
    }

    if (_pRunnableObject != NULL)
    {
        _pRunnableObject->Release();
        _pRunnableObject = NULL;
    }

    if (_pViewObject2 != NULL)
    {
        _pViewObject2->Release();
        _pViewObject2 = NULL;
    }

    if (_pExternalConnection != NULL)
    {
        _pExternalConnection->Release();
        _pExternalConnection = NULL;
    }

    if (_pOleLink != NULL)
    {
        _pOleLink->Release();
        _pOleLink = NULL;
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::CBareFactory, public
//
//  Synopsis:   constructor for the class factory
//
//  Effects:
//
//  Arguments:  none
//
//  Returns:    void
//
//  Modifies:   initializes _cRefs
//
//  Derivation: IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
CBareFactory::CBareFactory()
{
    _cRefs = 1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::QueryInterface, public
//
//  Synopsis:   only IUnknown and IClassFactory are supported
//
//  Effects:
//
//  Arguments:  [iid]   -- the requested interface
//              [ppvObj]-- where to put the interface pointer
//
//  Returns:    HRESULT
//
//  Modifies:   ppvObj
//
//  Derivation: IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CBareFactory::QueryInterface (REFIID iid, LPVOID FAR* ppvObj)
{
    if( IsEqualIID(iid, IID_IClassFactory) ||
	IsEqualIID(iid, IID_IUnknown) )
    {
	*ppvObj = this;
	AddRef();
	return NOERROR;
    }
    else
    {
	*ppvObj = NULL;
	return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::AddRef, public
//
//  Synopsis:   increments the reference count
//
//  Effects:
//
//  Arguments:  none
//
//  Returns:    ULONG -- the new reference count
//
//  Modifies:
//
//  Derivation: IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBareFactory::AddRef (void)
{
    _cRefs++;
    return _cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::Release, public
//
//  Synopsis:   decrements the reference count
//
//  Effects:    deletes object when reference count is zero
//
//  Arguments:  none
//
//  Returns:    ULONG -- the new reference count
//
//  Modifies:
//
//  Derivation: IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBareFactory::Release (void)
{
    _cRefs--;

    if( _cRefs == 0 )
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::CreateInstance, public
//
//  Synopsis:   does nothing
//
//  Effects:
//
//  Arguments:  [pUnkOuter] --  the controlling unknown for aggregation
//              [iid]       -- the requested interface
//              [ppvObj]    -- where to put the interface pointer
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  Derivation: IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP CBareFactory::CreateInstance (
            LPUNKNOWN pUnkOuter,
            REFIID iid,
	    LPVOID FAR* ppv)
{
    return E_NOTIMPL;;
}

//+-------------------------------------------------------------------------
//
//  Member:     CBareFactory::LockServer, public
//
//  Synopsis:   does nothing
//
//  Effects:
//
//  Arguments:  [flock] --  specifies the lock count
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP CBareFactory::LockServer ( BOOL fLock )
{
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function:   CHECK_FOR_THREAD_ERROR (macro)
//
//  Synopsis:   make sure that the hresult is RPC_E_WRONG_THREAD
//
//  Effects:    exits thread if hresult != RPC_E_WRONG
//
//  Arguments:  [hresult]   --  error code
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              09-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
#define CHECK_FOR_THREAD_ERROR(hresult) \
    if (hresult != RPC_E_WRONG_THREAD) \
    { \
       OutputString("Expected RPC_E_WRONG_THREAD but received %x.\r\n", hresult); \
       assert(hresult == RPC_E_WRONG_THREAD); \
       ExitThread((DWORD)E_UNEXPECTED); \
    }

// globals
CATTestIPtrs g_IPtrs;

//+-------------------------------------------------------------------------
//
//  Function:   ATTest
//
//  Synopsis:   calls the query functions to get pointers to the
//              supported interfaces
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   globals g_IPtrs._pOleObject
//                      g_IPtrs._pPersistStorage
//                      g_IPtrs._pDataObject
//                      g_IPtrs._pRunnableObject
//                      g_IPtrs._pViewObject2
//                      g_IPtrs._pOleCache2
//                      g_IPtrs._pExternalConnection
//                      g_IPtrs._pOleLink
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

void ATTest(void)
{
    HRESULT hresult;

    hresult = OleInitialize(NULL);
    assert(hresult == S_OK);

    // the functions CreateEHelperQuery, LinkObjectQuery and
    // GetClipboardQuery return either NOERROR or E_UNEXPECTED.
    // NOERROR is defined as 0
    hresult  = CreateEHelperQuery();

    g_IPtrs.Reset();
    hresult |= LinkObjectQuery();

    g_IPtrs.Reset();
    hresult |= GetClipboardQuery();

    vApp.Reset();
    vApp.m_wparam = (hresult == NOERROR) ? TEST_SUCCESS : TEST_FAILURE;
    vApp.m_lparam = (LPARAM)hresult;
    vApp.m_message = WM_TESTEND;

    HandleTestEnd();

    OleUninitialize();

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetClipboardQuery
//
//  Synopsis:   get a pointer to IDataObject interface, create a new thread
//              to test proper exit/error codes, wait for the thread to
//              complete and return the thread's exit code
//
//  Effects:    creates new thread
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   g_IPtrs._pDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT GetClipboardQuery(void)
{
    HRESULT hresult;
    HANDLE  hTestInterfaceThread;
    DWORD   dwThreadId = 0;
    DWORD   dwThreadExitCode;

    hresult = OleGetClipboard( &g_IPtrs._pDataObject );
    assert(hresult == S_OK );

    hTestInterfaceThread = CreateThread(
                NULL,                                       // security attributes
                0,                                          // stack size (default)
                (LPTHREAD_START_ROUTINE)&GetClipboardTest,  // address of thread function
                NULL,                                       // arguments of thread function
                0,                                          // creation flags
                &dwThreadId );                              // address of new thread ID

    assert(hTestInterfaceThread != NULL); //ensure that we have a valid thread handle

    // wait for the thread object so we can examine the error code
    WaitForSingleObject(hTestInterfaceThread, INFINITE);

    GetExitCodeThread(hTestInterfaceThread, &dwThreadExitCode);

    hresult = (HRESULT)dwThreadExitCode;

    CloseHandle(hTestInterfaceThread);

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   LinkObjectQuery
//
//  Synopsis:   get a pointer to available interfaces, create a new thread
//              to test proper exit/error codes, wait for the thread to
//              complete and return the thread's exit code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   g_IPtrs._pOleObject
//              g_IPtrs._pPersistStorage
//              g_IPtrs._pDataObject
//              g_IPtrs._pRunnableObject
//              g_IPtrs._pViewObject2
//              g_IPtrs._pOleCache2
//              g_IPtrs._pOleLink
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT LinkObjectQuery(void)
{
    HRESULT hresult;
    HANDLE  hTestInterfaceThread;
    DWORD   dwThreadId = 0;
    DWORD   dwThreadExitCode;

    hresult = CoCreateInstance(
                CLSID_StdOleLink,               // class ID of the object class
                NULL,                           // controlling unknown fro aggregation
                CLSCTX_INPROC,                  // context to run executables
                IID_IOleObject,                 // the requested interface
                (void **)&g_IPtrs._pOleObject); // where to store pointer to interface
    assert(hresult == S_OK);


    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IPersistStorage, (void **)&g_IPtrs._pPersistStorage);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IDataObject, (void **)&g_IPtrs._pDataObject);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IRunnableObject, (void **)&g_IPtrs._pRunnableObject);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IViewObject2, (void **)&g_IPtrs._pViewObject2);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IOleCache2, (void **)&g_IPtrs._pOleCache2);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IOleLink, (void **)&g_IPtrs._pOleLink);
    assert(hresult == S_OK);

    hTestInterfaceThread = CreateThread(
                NULL,                                   // security attributes
                0,                                      // stack size (default)
                (LPTHREAD_START_ROUTINE)&LinkObjectTest,// address of thread function
                NULL,                                   // arguments of thread function
                0,                                      // creation flags
                &dwThreadId );                          // address of new thread ID

    assert(hTestInterfaceThread != NULL); //ensure that we have a valid thread handle

    // wait for the thread object so we can examine the error code
    WaitForSingleObject(hTestInterfaceThread, INFINITE);

    GetExitCodeThread(hTestInterfaceThread, &dwThreadExitCode);

    hresult = (HRESULT)dwThreadExitCode;

    CloseHandle(hTestInterfaceThread);

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateEHelperQuery
//
//  Synopsis:   get a pointer to available interfaces, create a new thread
//              to test proper exit/error codes, wait for the thread to
//              complete and return the thread's exit code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   g_IPtrs._pOleObject
//              g_IPtrs._pPersistStorage
//              g_IPtrs._pDataObject
//              g_IPtrs._pRunnableObject
//              g_IPtrs._pViewObject2
//              g_IPtrs._pOleCache2
//              g_IPtrs._pExternalConnection
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT CreateEHelperQuery(void)
{
    HRESULT         hresult;
    HANDLE          hTestInterfaceThread;
    DWORD           dwThreadId = 0;
    DWORD           dwThreadExitCode;
    CBareFactory   *pCF = new CBareFactory;

    // must use EMBDHLP_DELAYCREATE flag otherwise API will try pCF->CreateInstance
    // and verify pointer. CBareFactory::CreateInstance is not implemented!
    hresult = OleCreateEmbeddingHelper(
                CLSID_SimpSvr,                              // class ID of the server
                NULL,                                       // controlling unknown for aggregation
                EMBDHLP_INPROC_SERVER | EMBDHLP_DELAYCREATE,// flags
                pCF,                                        // pointer to server's class factory
                IID_IOleObject,                             // the requested interface
                (void **)&g_IPtrs._pOleObject );            // where to store pointer to interface
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IPersistStorage, (void **)&g_IPtrs._pPersistStorage);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IDataObject, (void **)&g_IPtrs._pDataObject);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IRunnableObject, (void **)&g_IPtrs._pRunnableObject);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IViewObject2, (void **)&g_IPtrs._pViewObject2);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IOleCache2, (void **)&g_IPtrs._pOleCache2);
    assert(hresult == S_OK);

    hresult = g_IPtrs._pOleObject->QueryInterface(IID_IExternalConnection, (void **)&g_IPtrs._pExternalConnection);
    assert(hresult == S_OK);

    hTestInterfaceThread = CreateThread(
                NULL,                                   // security attributes
                0,                                      // stack size (default)
                (LPTHREAD_START_ROUTINE)&CreateEHTest,  // address of thread function
                NULL,                                   // arguments of thread function
                0,                                      // creation flags
                &dwThreadId );                          // address of new thread ID

    assert(hTestInterfaceThread != NULL); //ensure that we have a valid thread handle

    // wait for the thread object so we can examine the exit/error code
    WaitForSingleObject(hTestInterfaceThread, INFINITE);

    GetExitCodeThread(hTestInterfaceThread, &dwThreadExitCode);

    hresult = (HRESULT)dwThreadExitCode;

    CloseHandle(hTestInterfaceThread);

    pCF->Release();

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetClipBoardTest
//
//  Synopsis:   calls interface method functions and exits thread
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      all the interface methods are being called from a thread
//              which is not the owner. The methods should return
//              RPC_E_WRONG_THREAD error. If an interface method does not
//              return such error message, it is asserted and the
//              thread is exited with an E_UNEXPECTED exit code.
//
//--------------------------------------------------------------------------
void GetClipboardTest(void)
{
    DataObjectMethods();

    ExitThread((DWORD)NOERROR);
}

//+-------------------------------------------------------------------------
//
//  Function:   LinkObjectTest
//
//  Synopsis:   calls interface method functions and exits thread
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      all the interface methods are being called from a thread
//              which is not the owner. The methods should return
//              RPC_E_WRONG_THREAD error. If an interface method does not
//              return such error message, it is asserted and the
//              thread is exited with an E_UNEXPECTED exit code.
//
//--------------------------------------------------------------------------
void LinkObjectTest(void)
{
    OleObjectMethods();

    PersistStorageMethods();

    DataObjectMethods();

    RunnableObjectMethods();

    OleCache2Methods();

    ViewObject2Methods();

    OleLinkMethods();

    ExitThread((DWORD)NOERROR);
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateEHTest
//
//  Synopsis:   calls interface method functions and exits thread
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      all the interface methods are being called from a thread
//              which is not the owner. The methods should return
//              RPC_E_WRONG_THREAD error. If an interface method does not
//              return such error message, it is asserted and the
//              thread is exited with an E_UNEXPECTED exit code.
//
//--------------------------------------------------------------------------
void CreateEHTest(void)
{
    ExternalConnectionsMethods();

    OleObjectMethods();

    PersistStorageMethods();

    DataObjectMethods();

    RunnableObjectMethods();

    ViewObject2Methods();

    OleCache2Methods();

    ExitThread((DWORD)NOERROR);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleLinkMethods
//
//  Synopsis:   Calls all public IOleLink interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void OleLinkMethods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pOleLink->SetUpdateOptions(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->GetUpdateOptions(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->SetSourceMoniker(NULL, CLSID_NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->GetSourceMoniker(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->SetSourceDisplayName(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->GetSourceDisplayName(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->BindToSource(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->BindIfRunning();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->GetBoundSource(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->UnbindSource();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleLink->Update(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   ExternalConnectionsMethods
//
//  Synopsis:   Calls all public IExternalConnection interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void ExternalConnectionsMethods(void)
{
    HRESULT hresult;

    hresult = (HRESULT)g_IPtrs._pExternalConnection->AddConnection(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = (HRESULT)g_IPtrs._pExternalConnection->ReleaseConnection(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleObjectMethods
//
//  Synopsis:   Calls all public IOleObject interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void OleObjectMethods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pOleObject->SetClientSite(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetClientSite(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->SetHostNames(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->Close(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->SetMoniker(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetMoniker(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->InitFromData(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetClipboardData(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->DoVerb(NULL, NULL, NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->EnumVerbs(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->Update();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->IsUpToDate();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetUserClassID(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetUserType(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->SetExtent(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetExtent(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->Advise(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->Unadvise(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->EnumAdvise(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->GetMiscStatus(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleObject->SetColorScheme(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   PersistStorageMethods
//
//  Synopsis:   Calls all public IPersistStorage interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void PersistStorageMethods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pPersistStorage->GetClassID(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->IsDirty();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->InitNew(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->Load(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->Save(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->SaveCompleted(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pPersistStorage->HandsOffStorage();
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   DataObjectMethods
//
//  Synopsis:   Calls all public IDataObject interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void DataObjectMethods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pDataObject->GetData(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->GetDataHere(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->QueryGetData(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->GetCanonicalFormatEtc(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->SetData(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->EnumFormatEtc(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->DAdvise(NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->DUnadvise(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pDataObject->EnumDAdvise(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   RunnableObjectMethods
//
//  Synopsis:   Calls all public IRunnableObject interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void RunnableObjectMethods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pRunnableObject->GetRunningClass(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pRunnableObject->Run(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pRunnableObject->IsRunning();
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pRunnableObject->LockRunning(NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pRunnableObject->SetContainedObject(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   ViewObject2Methods
//
//  Synopsis:   Calls all public IViewObject2 interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void ViewObject2Methods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pViewObject2->Draw(NULL, NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->GetColorSet(NULL, NULL, NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->Freeze(NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->Unfreeze(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->SetAdvise(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->GetAdvise(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pViewObject2->GetExtent(NULL, NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleCache2Methods
//
//  Synopsis:   Calls all public IOleCache2 interface methods with NULL
//              parameters.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//  Notes:      The interface methods are called on the wrong thread, thus
//              an RPC_E_WRONG_THREAD error should be returned from each
//              method. If not, we assert and then exit the thread.
//
//--------------------------------------------------------------------------
void OleCache2Methods(void)
{
    HRESULT hresult;

    hresult = g_IPtrs._pOleCache2->Cache(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->Uncache(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->EnumCache(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->InitCache(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->SetData(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->UpdateCache(NULL, NULL, NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    hresult = g_IPtrs._pOleCache2->DiscardCache(NULL);
    CHECK_FOR_THREAD_ERROR(hresult);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\cotest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       cotest.h
//
//  Contents:   declarations for all compobj test routines
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-94 ricksa    author
//
//--------------------------------------------------------------------------

#ifndef _COTEST_H
#define _COTEST_H

HRESULT ThreadUnitTest(void);


#endif // _COTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\attest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       attest.h
//
//  Contents:   declarations for upper layer apartment thread test
//
//  Classes:    CBareFactory
//              CATTestIPtrs
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Jan-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#ifndef _ATTEST_H
#define _ATTEST_H

//+-------------------------------------------------------------------------
//
//  Class:
//
//  Purpose:
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:
//
//--------------------------------------------------------------------------

class CATTestIPtrs
{

public:
    CATTestIPtrs();

    STDMETHOD(Reset)();

    IOleObject          *_pOleObject;
    IOleCache2          *_pOleCache2;
    IDataObject         *_pDataObject;
    IPersistStorage     *_pPersistStorage;
    IRunnableObject     *_pRunnableObject;
    IViewObject2        *_pViewObject2;
    IExternalConnection *_pExternalConnection;
    IOleLink            *_pOleLink;
};

//+-------------------------------------------------------------------------
//
//  Class:      CBareFactory
//
//  Purpose:    use as a class factory which doesn't do anything in
//              OleCreateEmbeddingHelper API
//
//  Interface:  IClassFactory
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

class CBareFactory : public IClassFactory
{

public:
    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);
    STDMETHOD(CreateInstance) (LPUNKNOWN pUnkOuter, REFIID iid,
				    LPVOID FAR* ppv);
    STDMETHOD(LockServer) ( BOOL fLock );

    CBareFactory();

private:
    ULONG		_cRefs;
};

// runs 3 test routines and returns results
void    ATTest(void);

// get pointers to interfaces and creates thread to ensure
// interface methods return RPC_E_WRONG_ERROR
HRESULT CreateEHelperQuery(void);

HRESULT LinkObjectQuery(void);

HRESULT GetClipboardQuery(void);

// new thread functions to try interface methods
void    LinkObjectTest(void);

void    CreateEHTest(void);

void    GetClipboardTest(void);

// interface methods with NULL parameters
void    OleLinkMethods(void);

void    OleObjectMethods(void);

void    PersistStorageMethods(void);

void    DataObjectMethods(void);

void    RunnableObjectMethods(void);

void    ViewObject2Methods(void);

void    OleCache2Methods(void);

void    ExternalConnectionsMethods(void);

#endif  //!ATTEST_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\gendata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	gendata.cpp
//
//  Contents: 	implementation of CGenDataObject
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//		06-Jun-94 alexgo    added support for OLE1 tests
//    		24-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "gendata.h"

static const CLSID CLSID_TestCLSID = {0xaabbccee, 0x1122, 0x3344, { 0x55, 0x66,
    0x77, 0x88, 0x99, 0x00, 0xaa, 0xbb }};

static const char szTestString[] = "A carefully chosen test string";
static const OLECHAR wszTestStream[] = OLESTR("TestStream");
static const char szNativeData[] = "Ole1Test NATIVE data";
static const char szOwnerLinkData[] = "PBrush\0foo.bmp\00 0 200 160\0\0";


//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::CGenDataObject
//
//  Synopsis:	constructor
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		06-Jun-94 alexgo    added OLE1 support
//		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CGenDataObject::CGenDataObject( )
{
	m_refs = 0;
	m_fQICalled = FALSE;

	// now set up the formats that we support

	m_cfTestStorage = RegisterClipboardFormat("OleTest Storage Format");
        m_cfEmbeddedObject = RegisterClipboardFormat("Embedded Object");
	m_cfEmbedSource = RegisterClipboardFormat("Embed Source");
	m_cfLinkSource = RegisterClipboardFormat("Link Source");
	m_cfObjectDescriptor = RegisterClipboardFormat("Object Descriptor");
	m_cfLinkSrcDescriptor = RegisterClipboardFormat("Link Source "
					"Descriptor");
	m_cfOwnerLink = RegisterClipboardFormat("OwnerLink");
	m_cfNative = RegisterClipboardFormat("Native");
	m_cfObjectLink = RegisterClipboardFormat("ObjectLink");

	// now set up the array of formatetc's.  SetupOle1Mode must be
	// called if you want OLE1 formats

	m_rgFormats = new FORMATETC[2];

	assert(m_rgFormats);

	m_rgFormats[0].cfFormat = m_cfTestStorage;
	m_rgFormats[0].ptd = NULL;
	m_rgFormats[0].dwAspect = DVASPECT_CONTENT;
	m_rgFormats[0].lindex = -1;
	m_rgFormats[0].tymed = TYMED_ISTORAGE;

	m_rgFormats[1].cfFormat = m_cfEmbeddedObject;
	m_rgFormats[1].ptd = NULL;
	m_rgFormats[1].dwAspect = DVASPECT_CONTENT;
	m_rgFormats[1].lindex = -1;
	m_rgFormats[1].tymed = TYMED_ISTORAGE;

	m_cFormats = 2;

}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::QueryInterface
//
//  Synopsis: 	returns requested interfaces
//
//  Effects:
//
//  Arguments: 	[riid]		-- the requested interface
//		[ppvObj]	-- where to put the interface pointer
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::QueryInterface( REFIID riid, LPVOID *ppvObj )
{
	HRESULT		hresult = NOERROR;

	m_fQICalled = TRUE;

	if( IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IDataObject) )
	{
		*ppvObj = this;
		AddRef();
	}
	else
	{
		*ppvObj = NULL;
		hresult = ResultFromScode(E_NOINTERFACE);
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::AddRef
//
//  Synopsis:	increments the reference count
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	ULONG-- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//    		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenDataObject::AddRef( )
{
	return ++m_refs;
}

//+-------------------------------------------------------------------------
//
//  Member:   	CGenDataObject::Release
//
//  Synopsis:	decrements the reference count on the object
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenDataObject::Release( )
{
	ULONG cRefs;

	if( (cRefs = --m_refs ) == 0 )
	{
		delete this;
	}
	return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::GetData
//
//  Synopsis:	retrieves data of the specified format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[pmedium]	-- where to put the data
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		06-Jun-94 alexgo    added OLE1 support
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::GetData( LPFORMATETC pformatetc, LPSTGMEDIUM
		pmedium)
{
	HRESULT		hresult = NOERROR;

	if( (pformatetc->cfFormat == m_cfTestStorage ||
                pformatetc->cfFormat == m_cfEmbeddedObject ) &&
		(pformatetc->tymed & TYMED_ISTORAGE) )
	{
		pmedium->tymed = TYMED_ISTORAGE;
		pmedium->pstg = GetTestStorage();
		assert(pmedium->pstg);
	}

	// test for OLE1 formats

	else if( pformatetc->cfFormat == m_cfOwnerLink &&
		(m_fOle1 & OLE1_OFFER_OWNERLINK ) &&
		(pformatetc->tymed & TYMED_HGLOBAL) )
	{
		pmedium->tymed = TYMED_HGLOBAL;
		pmedium->hGlobal = GetOwnerOrObjectLink();
		assert(pmedium->hGlobal);
	}
	else if( pformatetc->cfFormat == m_cfObjectLink &&
		(m_fOle1 & OLE1_OFFER_OBJECTLINK ) &&
		(pformatetc->tymed & TYMED_HGLOBAL) )
	{
		pmedium->tymed = TYMED_HGLOBAL;
		pmedium->hGlobal = GetOwnerOrObjectLink();
		assert(pmedium->hGlobal);
	}
	else if( pformatetc->cfFormat == m_cfNative &&
		(m_fOle1 & OLE1_OFFER_NATIVE ) &&
		(pformatetc->tymed &TYMED_HGLOBAL ) )
	{
		pmedium->tymed = TYMED_HGLOBAL;
		pmedium->hGlobal = GetNativeData();
	}
	else
	{
		hresult = ResultFromScode(E_FAIL);
	}
		
	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::GetDataHere
//
//  Synopsis:	retrieves data of the specified format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[pmedium]	-- where to put the data
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::GetDataHere( LPFORMATETC pformatetc, LPSTGMEDIUM
		pmedium)
{
	(void)pformatetc;
	(void)pmedium;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::QueryGetData
//
//  Synopsis:	queries whether a GetData call would succeed
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::QueryGetData( LPFORMATETC pformatetc )
{			
	(void)pformatetc;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::GetCanonicalFormatEtc
//
//  Synopsis:	retrieve the canonical format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[pformatetcOut]	-- the canonical format
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::GetCanonicalFormatEtc( LPFORMATETC pformatetc,
	LPFORMATETC pformatetcOut)
{
	(void)pformatetc;
	(void)pformatetcOut;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::SetData
//
//  Synopsis:	sets data of the specified format
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the format of the data
//		[pmedium]	-- the data
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::SetData( LPFORMATETC pformatetc, LPSTGMEDIUM
		pmedium, BOOL fRelease)
{
	(void)pformatetc;
	(void)pmedium;
	(void)fRelease;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::EnumFormatEtc
//
//  Synopsis:	return an enumerator for the available data formats
//
//  Effects:
//
//  Arguments:	[dwDirection]	-- the direction (GET or SET)
//		[ppenum]	-- where to put the enumerator
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::EnumFormatEtc( DWORD dwDirection,
	LPENUMFORMATETC * ppenum )
{
	HRESULT		hresult;

	if( dwDirection == DATADIR_GET )
	{
		hresult = CGenEnumFormatEtc::Create( ppenum, m_rgFormats,
				m_cFormats);
		assert(hresult == NOERROR);

		return hresult;
	}
	else
	{
		return ResultFromScode(E_NOTIMPL);
	}
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::DAdvise
//
//  Synopsis:	register a data advise
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- the requested format
//		[dwAdvf]	-- advise flags
//		[pAdvSink]	-- the advise sink
//		[pdwConnection]	-- where to put the connection ID
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::DAdvise( LPFORMATETC pformatetc, DWORD dwAdvf,
	IAdviseSink * pAdvSink, DWORD *pdwConnection )
{
	(void)pformatetc;
	(void)dwAdvf;
	(void)pAdvSink;
	(void)pdwConnection;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::DUnadvise
//
//  Synopsis:	unadvises an advise connection
//
//  Effects:
//
//  Arguments:	[dwConnection]	-- the connection to remove
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::DUnadvise(DWORD dwConnection)
{
	(void)dwConnection;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::EnumDAdvise
//
//  Synopsis:  	enumerates data advises
//
//  Effects:
//
//  Arguments:	[ppenum]	-- where to put the enumerator
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IDataObject	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenDataObject::EnumDAdvise( LPENUMSTATDATA *ppenum)
{
	(void)ppenum;

	return ResultFromScode(E_NOTIMPL);
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::VerifyMedium
//
//  Synopsis:	verifies the contents of the given medium
//
//  Effects:
//
//  Arguments: 	[pmedium]	-- the medium to verify
//
//  Requires:
//
//  Returns:  	BOOL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	For OLE1 formats, the following must be true:
//		cfEmbeddedObject:
//			must have OWNERLINK and !NATIVE
//			or OWNERLINK precedes NATIVE
//		cfEmbedSource:
//			must have NATIVE && OWNERLINK and
//			OWNERLINK must not precede NATIVE
//		cfObjectDescriptor:
//			same as EmbedSource
//		cfLinkSource:
//			must have either OBJECTLINK or
//			OWNERLINK must precede NATIVE
//		cfLinkSrcDescriptor:
//			same as LinkSource
//
//  History:    dd-mmm-yy Author    Comment
//		06-Jun-94 alexgo    added OLE1 support
//	 	15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGenDataObject::VerifyFormatAndMedium( FORMATETC *pformatetc,
			STGMEDIUM *pmedium )
{
	// if any of these flags are set, then we were offering OLE1
	// data.  Do relevant tests.

	if( (m_fOle1 & (OLE1_OFFER_OWNERLINK | OLE1_OFFER_OBJECTLINK |
		OLE1_OFFER_NATIVE) ) )
	{
		// now do individual tests for formats
		if( pformatetc->cfFormat == m_cfEmbedSource ||
			pformatetc->cfFormat == m_cfObjectDescriptor)
		{
			if( (m_fOle1 & OLE1_OFFER_NATIVE) &&
				(m_fOle1 & OLE1_OFFER_OWNERLINK) &&
				!(m_fOle1 & OLE1_OWNERLINK_PRECEDES_NATIVE) )
			{
				return TRUE;
			}
		}
		else if( pformatetc->cfFormat == m_cfLinkSource ||
			pformatetc->cfFormat == m_cfLinkSrcDescriptor)
		{
			if( (m_fOle1 & OLE1_OFFER_OBJECTLINK) ||
				((m_fOle1 & OLE1_OFFER_OWNERLINK) &&
				(m_fOle1 & OLE1_OFFER_NATIVE) &&
				(m_fOle1 & OLE1_OWNERLINK_PRECEDES_NATIVE)))
			{
				return TRUE;
			}
		}

		// no 'else' so we check for cfObjectDescriptor again
		if( pformatetc->cfFormat == m_cfEmbeddedObject ||
			pformatetc->cfFormat == m_cfObjectDescriptor )
		{
			if( ((m_fOle1 & OLE1_OFFER_NATIVE) &&
				(m_fOle1 & OLE1_OFFER_OWNERLINK) &&
				(m_fOle1 & OLE1_OWNERLINK_PRECEDES_NATIVE)) ||
				((m_fOle1 & OLE1_OFFER_OWNERLINK) &&
				!(m_fOle1 & OLE1_OFFER_NATIVE)) )
			{
				return TRUE;
			}

		}

		// fall through and do rest of testing, in case we didn't
		// hit one of the synthesized formats.
	}

	if( pformatetc->cfFormat == m_cfTestStorage ||
               pformatetc->cfFormat == m_cfEmbeddedObject )
	{
		return VerifyTestStorage( pformatetc, pmedium );
	}
	else if( pformatetc->cfFormat == m_cfOwnerLink ||
		pformatetc->cfFormat == m_cfObjectLink )
	{
		return VerifyOwnerOrObjectLink(pformatetc, pmedium);
	}
	else if( pformatetc->cfFormat == m_cfNative )
	{
		return VerifyNativeData(pformatetc, pmedium);
	}

	return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::VerifyTestStorage
//
//  Synopsis: 	verifies the test storage format
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//	     	
//  Returns: 	BOOL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//   		15-Apr-94 alexgo    author; tax day :-(
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGenDataObject::VerifyTestStorage( FORMATETC *pformatetc,
		STGMEDIUM *pmedium)
{
	IStream *	pstm;
	STATSTG		statstg;
	char 		szBuf[sizeof(szTestString)];
	HRESULT		hresult;

	if( pmedium->tymed != TYMED_ISTORAGE )
	{
		//REVIEW: we may want to convert and test different
		//mediums at a later date

		return FALSE;
	}

	
	// check the class ID

	pmedium->pstg->Stat(&statstg, STATFLAG_NONAME);

	if( !IsEqualCLSID(statstg.clsid, CLSID_TestCLSID) )
	{
		OutputString("Failed CLSID check on storage in "
			"VerifyTestStorage!!\r\n");
		return FALSE;
	}

	// now open the test stream

	hresult = pmedium->pstg->OpenStream(wszTestStream, NULL, (STGM_READ |
		STGM_SHARE_EXCLUSIVE), 0, &pstm);

	if( hresult != NOERROR )
	{
		OutputString("OpenStream in VerifyTestStorage failed! (%lx)"
			"\r\n", hresult);
		return FALSE;
	}

	hresult = pstm->Read((void *)szBuf, sizeof(szTestString), NULL);

	if( hresult != NOERROR )
	{
		OutputString("Stream->Read failed in VerifyTestStorage (%lx)"
			"\r\n", hresult);
		pstm->Release();
		return FALSE;
	}

	if( strcmp(szBuf, szTestString) != 0 )
	{
		OutputString("'%s' != '%s'\r\n", szBuf, szTestString);
		return FALSE;
	}

	pstm->Release();

	return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenDataObject::GetTestStorage (private)
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns: 	a new storage
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

IStorage * CGenDataObject::GetTestStorage( void )
{
	IStorage *	pstg;
	IStream *	pstm;
	HRESULT		hresult;


	// create the docfile

	hresult = StgCreateDocfile(NULL, (STGM_READWRITE | STGM_DIRECT |
                        STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE), NULL,
                        &pstg);

	if( hresult != NOERROR )
	{
		OutputString("GetTestStorage: CreateDocfile failed!! (%lx)"
			"\r\n", hresult);
		return NULL;
	}

        // set the class ID

        hresult = pstg->SetClass(CLSID_TestCLSID);

	// now create the stream

	hresult = pstg->CreateStream(wszTestStream, (STGM_READWRITE |
			STGM_SHARE_EXCLUSIVE ), 0, 0, &pstm);

	if( hresult != NOERROR )
	{
		OutputString("GetTestStorage: CreateStream failed! (%lx)\r\n",
			hresult);
		pstg->Release();
		return NULL;
	}

	hresult = pstm->Write((void *)szTestString, sizeof(szTestString),
			NULL);

	if( hresult != NOERROR )
	{
		OutputString("GetTestStorage: Stream->Write failed! (%lx)\r\n",
			hresult);
		pstm->Release();
		pstg->Release();
		return NULL;
	}

	pstm->Release();

	return pstg;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenDataObject::GetOwnerOrObjectLink (private)
//
//  Synopsis:  	Creates either cfOwnerLink or cfObjectLink for a dummy
//		Paintbrush (ole1) object
//
//  Effects: 	allocates an HGLOBAL
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	HGLOBAL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HGLOBAL CGenDataObject::GetOwnerOrObjectLink( void )
{
	HGLOBAL hglobal;
	char *pdata;

	hglobal = GlobalAlloc(GMEM_MOVEABLE, sizeof(szOwnerLinkData));

	assert(hglobal);

	pdata = (char *)GlobalLock(hglobal);

	assert(pdata);

	memcpy(pdata, szOwnerLinkData, sizeof(szOwnerLinkData));

	GlobalUnlock(hglobal);

	return hglobal;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::GetNativeData (private)
//
//  Synopsis: 	Creates OLE1 Native data
//
//  Effects:  	allocates an hglobal
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	HGLOBAL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HGLOBAL CGenDataObject::GetNativeData( void )
{
	HGLOBAL	hglobal;
	char *pdata;

	hglobal = GlobalAlloc(GMEM_MOVEABLE, sizeof(szNativeData) + 1);

	assert(hglobal);

	pdata = (char *)GlobalLock(hglobal);

	assert(pdata);

	memcpy(pdata, szNativeData, sizeof(szNativeData)+1);

	GlobalUnlock(hglobal);

	return hglobal;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::VerifyOwnerOrObjectLink
//
//  Synopsis: 	verifies that the owner or object link data is correct
//
//  Effects:
//
//  Arguments: 	[pformatetc]	-- the formatetc describing the data
//		[pmedium]	-- the data
//
//  Requires:	pformatetc must be for OwnerLink or ObjectLink
//
//  Returns:	BOOL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-94 alexgo    author
//
//  Notes:
//		NB!!: must be expanded to cover container-side cases
//
//--------------------------------------------------------------------------

BOOL CGenDataObject::VerifyOwnerOrObjectLink( FORMATETC *pformatetc,
	STGMEDIUM *pmedium )
{
	char *	pdata;
	BOOL	fRet = FALSE;
	

	assert(pformatetc->cfFormat == m_cfOwnerLink ||
		pformatetc->cfFormat == m_cfObjectLink );

	// check standard stuff
	if( !(pformatetc->tymed & TYMED_HGLOBAL ) ||
		pformatetc->dwAspect != DVASPECT_CONTENT ||
		pformatetc->ptd != NULL ||
		pformatetc->lindex != -1 ||
		pmedium->tymed != TYMED_HGLOBAL )
	{
		return FALSE;
	}

	// if we offered the data natively from OLE1, then
	// check the contents.

	// this conditional tests to see if the format in question
	// was originally offered by us

	if( ((m_fOle1 & OLE1_OFFER_OWNERLINK) &&
		pformatetc->cfFormat == m_cfOwnerLink) ||
		((m_fOle1 & OLE1_OFFER_OBJECTLINK) &&
		pformatetc->cfFormat == m_cfObjectLink) )
	{
			
		pdata = (char *)GlobalLock(pmedium->hGlobal);
	
		if( memcmp(pdata, szOwnerLinkData,
			sizeof(szOwnerLinkData)) == 0 )
		{
			fRet = TRUE;
		}

		GlobalUnlock(pmedium->hGlobal);
	}
	// else CHECK SYNTHESIZED OLE1 FORMATS WHEN IMPLEMENTED


	return fRet;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::VerifyNativeData (private)
//
//  Synopsis:	verifies OLE1 Native data
//
//  Effects:
//
//  Arguments:	[pformatetc]	-- formatetc for the data
//		[pmedium]	-- location of the native data
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-95 alexgo    author
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGenDataObject::VerifyNativeData( FORMATETC *pformatetc,
		STGMEDIUM *pmedium )
{
	char *	pdata;
	BOOL	fRet = FALSE;
	

	assert(pformatetc->cfFormat == m_cfNative );

	// check standard stuff
	if( !(pformatetc->tymed & TYMED_HGLOBAL) ||
		pformatetc->dwAspect != DVASPECT_CONTENT ||
		pformatetc->ptd != NULL ||
		pformatetc->lindex != -1 ||
		pmedium->tymed != TYMED_HGLOBAL )
	{
		return FALSE;
	}

	// if we offered the data natively from OLE1, then
	// check the contents.

	// this conditional tests to see if the format in question
	// was originally offered by us

	if( (m_fOle1 & OLE1_OFFER_NATIVE) )
	{
			
		pdata = (char *)GlobalLock(pmedium->hGlobal);
	
		if( memcmp(pdata, szNativeData,
			sizeof(szNativeData)) == 0 )
		{
			fRet = TRUE;
		}

		GlobalUnlock(pmedium->hGlobal);
	}
	// else CHECK SYNTHESIZED OLE1 FORMATS WHEN IMPLEMENTED


	return fRet;
}
	
//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::SetupOle1Mode (public)
//
//  Synopsis:	Sets the data object up for OLE1 compatibility mode
//
//  Effects:
//
//  Arguments:	[fFlags]	-- specifies various OLE1 options
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-94 alexgo    author
//
//  Notes:
//		The default test information in the data object will be
//		lost by this call.  Simply create a new data object if
//		it is needed again.
//
//--------------------------------------------------------------------------

void CGenDataObject::SetupOle1Mode( Ole1TestFlags fFlags )
{
	DWORD	count = 0, i = 0;
	UINT	cfFormats[3];		// OLE1 formats offered

	if( fFlags == 0 )
	{
		// don't need to do anything
		return;
	}

	// the formats we had previously

	delete m_rgFormats;


	// first figure out how many formats we need

	if( (fFlags & OLE1_OFFER_NATIVE) )
	{
		if( !((fFlags & OLE1_OWNERLINK_PRECEDES_NATIVE) &&
			(fFlags & OLE1_OFFER_OWNERLINK)) )
		{
			cfFormats[i] = m_cfNative;
			i++;
		}
		count++;
	}

	if( (fFlags & OLE1_OFFER_OWNERLINK) )
	{
		cfFormats[i] = m_cfOwnerLink;
		i++;

		if( (fFlags & OLE1_OWNERLINK_PRECEDES_NATIVE) &&
			(fFlags & OLE1_OFFER_NATIVE) )
		{
			cfFormats[i] = m_cfNative;
			i++;
		}
		
		count++;
	}

	if( (fFlags & OLE1_OFFER_OBJECTLINK) )
	{

		cfFormats[i] = m_cfObjectLink;
		
		count++;
	}

	m_rgFormats = new FORMATETC[count];

	assert(m_rgFormats);

	for(i = 0; i < count; i++ )
	{
		m_rgFormats[i].cfFormat = cfFormats[i];
		m_rgFormats[i].ptd = NULL;
		m_rgFormats[i].dwAspect = DVASPECT_CONTENT;
		m_rgFormats[i].lindex = -1;
		m_rgFormats[i].tymed = TYMED_HGLOBAL;
	}

	m_cFormats = count;

	m_fOle1 = fFlags;

	return;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenDataObject::SetOle1ToClipboard
//
//  Synopsis:	stuffs available OLE1 formats to the clipboard
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires: 	SetOle1Mode *must* have been called
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//   		06-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CGenDataObject::SetOle1ToClipboard( void )
{
	HRESULT	hresult = NOERROR;
	DWORD	i;
	HGLOBAL	hglobal;

	assert((m_fOle1 & (OLE1_OFFER_OWNERLINK | OLE1_OFFER_OBJECTLINK |
		OLE1_OFFER_NATIVE)));

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	if( !EmptyClipboard() )
	{
		CloseClipboard();
		return ResultFromScode(CLIPBRD_E_CANT_EMPTY);
	}

	for( i = 0 ; i < m_cFormats; i++ )
	{
		if( m_rgFormats[i].cfFormat == m_cfNative )
		{
			hglobal = GetNativeData();
			SetClipboardData(m_cfNative, hglobal);
		}
		else if( m_rgFormats[i].cfFormat == m_cfOwnerLink )
		{
			hglobal = GetOwnerOrObjectLink();
			SetClipboardData(m_cfOwnerLink, hglobal);
		}
		else if( m_rgFormats[i].cfFormat == m_cfObjectLink )
		{
			hglobal = GetOwnerOrObjectLink();
			SetClipboardData(m_cfObjectLink, hglobal);
		}
		else
		{
			hresult = ResultFromScode(E_UNEXPECTED);
		}
	}

	CloseClipboard();

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenDataObject::HasQIBeenCalled (public)
//
//  Synopsis:	returns wether or not QueryInterface has been called on
//		this data object.  Used in testing OleQueryCreateFromData
//
//  Effects:
//
//  Arguments:	none
//
//  Requires:
//
//  Returns: 	TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		23-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CGenDataObject::HasQIBeenCalled()
{
	return m_fQICalled;	
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenDataObject::SetDatFormats
//
//  Synopsis:  	sets the formats that the data object will offer
//
//  Effects:
//
//  Arguments: 	[fFlags]	-- formats to offer
//
//  Requires:
//
//  Returns: 	void
//	     	
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		23-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void CGenDataObject::SetDataFormats( DataFlags fFlags )
{
	DWORD 		cFormats = 0;
	DWORD	 	flags = (DWORD)fFlags;
	DWORD 		i =0;

	if( m_rgFormats )
	{
		delete m_rgFormats;
		m_rgFormats = NULL;
	}

	if( flags == 0 )
	{
		return;
	}

	// count the number of formats to offer

	cFormats++;

	while( flags &= (flags -1) )
	{
		cFormats++;
	}

   	m_rgFormats = new FORMATETC[cFormats];

	assert(m_rgFormats);

	memset(m_rgFormats, 0, sizeof(FORMATETC)*cFormats);

	if( fFlags & OFFER_TESTSTORAGE )
	{
		m_rgFormats[i].cfFormat = m_cfTestStorage;
		m_rgFormats[i].ptd = NULL;
		m_rgFormats[i].dwAspect = DVASPECT_CONTENT;
		m_rgFormats[i].lindex = -1;
		m_rgFormats[i].tymed = TYMED_ISTORAGE;

		i++;
	}

	if( fFlags & OFFER_EMBEDDEDOBJECT )
	{
		m_rgFormats[i].cfFormat = m_cfEmbeddedObject;
		m_rgFormats[i].ptd = NULL;
		m_rgFormats[i].dwAspect = DVASPECT_CONTENT;
		m_rgFormats[i].lindex = -1;
		m_rgFormats[i].tymed = TYMED_ISTORAGE;
		i++;
	}

	m_cFormats = i;
}

//
// Generic Data Object formatetc enumerator
//

//+-------------------------------------------------------------------------
//
//  Member: 	CGenEnumFormatEtc::QueryInterface
//
//  Synopsis: 	returns requested interfaces
//
//  Effects:
//
//  Arguments: 	[riid]		-- the requested interface
//		[ppvObj]	-- where to put the interface pointer
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenEnumFormatEtc::QueryInterface( REFIID riid, LPVOID *ppvObj )
{
	HRESULT		hresult = NOERROR;

	if( IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IEnumFORMATETC) )
	{
		*ppvObj = this;
		AddRef();
	}
	else
	{
		*ppvObj = NULL;
		hresult = ResultFromScode(E_NOINTERFACE);
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CGenEnumFormatEtc::AddRef
//
//  Synopsis:	increments the reference count
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	ULONG-- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//    		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenEnumFormatEtc::AddRef( )
{
	return ++m_refs;
}

//+-------------------------------------------------------------------------
//
//  Member:   	CGenEnumFormatEtc::Release
//
//  Synopsis:	decrements the reference count on the object
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenEnumFormatEtc::Release( )
{
	ULONG cRefs;

	if( (cRefs = --m_refs ) == 0 )
	{
		delete this;
	}
	return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenEnumFormatEtc::Next
//
//  Synopsis:	gets the next [celt] formats
//
//  Effects:
//
//  Arguments:	[celt]		-- the number of elements to fetch
//		[rgelt]		-- where to put them
//		[pceltFetched]	-- the number of formats actually fetched
//
//  Requires:
//
//  Returns:	NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenEnumFormatEtc::Next( ULONG celt, FORMATETC *rgelt,
		ULONG *pceltFetched)
{
	HRESULT		hresult = NOERROR;
	ULONG		cFetched;

	if( celt > m_cTotal - m_iCurrent )
	{
		cFetched = m_cTotal - m_iCurrent;
		hresult = ResultFromScode(S_FALSE);
	}
	else
	{
		cFetched = celt;
	}

	memcpy( rgelt, m_rgFormats + m_iCurrent,
			cFetched * sizeof(FORMATETC) );

	m_iCurrent += cFetched;

	if( pceltFetched )
	{
		*pceltFetched = cFetched;
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenEnumFormatEtc::Skip
//
//  Synopsis:	skips the next [celt] formats
//
//  Effects:
//
//  Arguments:	[celt]		-- the number of elements to skip
//
//  Requires:
//
//  Returns:	NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenEnumFormatEtc::Skip( ULONG celt )
{
	HRESULT		hresult = NOERROR;

	m_iCurrent += celt;

	if( m_iCurrent > m_cTotal )
	{
		// whoops, skipped to far ahead.  Set us to the max limit.
		m_iCurrent = m_cTotal;
		hresult = ResultFromScode(S_FALSE);
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenEnumFormatEtc::Reset
//
//  Synopsis:	resets the seek pointer to zero
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenEnumFormatEtc::Reset( void )
{
	m_iCurrent = 0;

	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:	CGenEnumFormatEtc::Clone
//
//  Synopsis:	clones the enumerator
//
//  Effects:
//
//  Arguments:	[ppIEnum]	-- where to put the cloned enumerator
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:	IEnumFORMATETC
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP CGenEnumFormatEtc::Clone( IEnumFORMATETC **ppIEnum )
{
	HRESULT			hresult = ResultFromScode(E_OUTOFMEMORY);
	CGenEnumFormatEtc *	pClipEnum;	

	*ppIEnum = NULL;

	pClipEnum = new CGenEnumFormatEtc();

	// ref count will be 1 and m_iCurrent will be zero.

	if( pClipEnum )
	{
		pClipEnum->m_cTotal = m_cTotal;
		pClipEnum->m_rgFormats = new FORMATETC[m_cTotal];
		pClipEnum->m_iCurrent = m_iCurrent;

		assert(pClipEnum->m_rgFormats);

		if( pClipEnum->m_rgFormats )
		{
			// copy our formatetc's into the cloned enumerator's
			// array
			memcpy(pClipEnum->m_rgFormats, m_rgFormats,
				m_cTotal * sizeof(FORMATETC) );

			*ppIEnum = pClipEnum;
	
			hresult = NOERROR;
		}
		else
		{
			
			delete pClipEnum;
		}
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenEnumFormatEtc::CGenEnumFormatEtc, private
//
//  Synopsis:	constructor
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	 	15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CGenEnumFormatEtc::CGenEnumFormatEtc( void )
{
	m_refs 		= 1;	// give the intial reference
	m_rgFormats 	= NULL;
	m_iCurrent	= 0;
	m_cTotal	= 0;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenEnumFormatEtc::~CGenEnumFormatEtc, private
//
//  Synopsis:	destructor
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	 	15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CGenEnumFormatEtc::~CGenEnumFormatEtc( void )
{
	if( m_rgFormats )
	{
		delete m_rgFormats;
	}
}

//+-------------------------------------------------------------------------
//
//  Member:  	CGenEnumFormatEtc::Create, static, public
//
//  Synopsis:	Creates a clipboard formatetc enumerator
//	      	
//  Effects:
//
//  Arguments: 	[ppIEnum]	-- where to put the enumerator
//
//  Requires:	the clipboard must be open
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CGenEnumFormatEtc::Create( IEnumFORMATETC **ppIEnum,
		FORMATETC *prgFormats, DWORD cFormats )
{
	HRESULT			hresult = ResultFromScode(E_OUTOFMEMORY);
	CGenEnumFormatEtc *	pClipEnum;


	*ppIEnum = NULL;

	pClipEnum = new CGenEnumFormatEtc();

	assert(pClipEnum);

	// now allocate memory for the array

	pClipEnum->m_rgFormats = new FORMATETC[cFormats];

	assert(pClipEnum->m_rgFormats);

	pClipEnum->m_cTotal = cFormats;

	memcpy(pClipEnum->m_rgFormats, prgFormats,
		cFormats * sizeof(FORMATETC));

	*ppIEnum = pClipEnum;

	return NOERROR;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\gendata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	gendata.h
//
//  Contents: 	Declaration of a generic data object.
//
//  Classes:	CGenDataObject
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
// 		24-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _GENDATA_H
#define _GENDATA_H

// flags used by OLE1 compatibilty mode

typedef enum
{
	OLE1_OFFER_OWNERLINK	= 1,
	OLE1_OFFER_OBJECTLINK	= 2,
	OLE1_OFFER_NATIVE	= 4,
	OLE1_OWNERLINK_PRECEDES_NATIVE = 8
} Ole1TestFlags;

// more flags used to control what formats are offered

typedef enum
{
	OFFER_TESTSTORAGE	= 1,
	OFFER_EMBEDDEDOBJECT	= 2
} DataFlags;


//+-------------------------------------------------------------------------
//
//  Class:	CGenDataObject
//
//  Purpose: 	generic data object (for clipboard data transfers, etc)
//
//  Interface: 	IDataObject
//
//  History:    dd-mmm-yy Author    Comment
// 		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

class CGenDataObject : public IDataObject
{
public:
	// IUnknown methods
	STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
	STDMETHOD_(ULONG,AddRef)(void);
	STDMETHOD_(ULONG,Release)(void);
	
	// IDataObject methods
	STDMETHOD(GetData)(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium);
	STDMETHOD(GetDataHere)(THIS_ LPFORMATETC pformatetc,
	    LPSTGMEDIUM pmedium);
	STDMETHOD(QueryGetData)(THIS_ LPFORMATETC pformatetc);
	STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC pformatetc,
	    LPFORMATETC pformatetcOut);
	STDMETHOD(SetData)(LPFORMATETC pformatetc,
			STGMEDIUM FAR* pmedium, BOOL fRelease);
	STDMETHOD(EnumFormatEtc)(DWORD dwDirection,
	    LPENUMFORMATETC FAR* ppenumFormatEtc);
	STDMETHOD(DAdvise)(FORMATETC FAR* pFormatetc, DWORD advf,
	    IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection);
	STDMETHOD(DUnadvise)(DWORD dwConnection);
	STDMETHOD(EnumDAdvise)(LPENUMSTATDATA FAR* ppenumAdvise);

	// constructor
	CGenDataObject();

	// test functions

	BOOL VerifyFormatAndMedium(FORMATETC *pformatetc, STGMEDIUM *pmedium);

	// OLE1 compatibility test functions

	void SetupOle1Mode( Ole1TestFlags fFlags );
	HRESULT SetOle1ToClipboard( void );

       	// Used by various tests, controls what formats are offered by
	// the data object

	void SetDataFormats( DataFlags fFlags );

	// Indicates whether or not QueryInterface was called.  Used by
	// OleQueryXXX tests.

	BOOL HasQIBeenCalled();

	// test clipboard formats

	UINT		m_cfTestStorage;
	UINT		m_cfEmbeddedObject;
	UINT		m_cfEmbedSource;
	UINT		m_cfObjectDescriptor;
	UINT		m_cfLinkSource;
	UINT		m_cfLinkSrcDescriptor;
	UINT		m_cfOwnerLink;
	UINT		m_cfObjectLink;
	UINT		m_cfNative;

private:
	IStorage * 	GetTestStorage(void);

	BOOL		VerifyTestStorage(FORMATETC *pformatetc,
				STGMEDIUM *pmedium);

	ULONG 		m_refs; 	// reference count
	DWORD 		m_cFormats;	// number of formats supported
	FORMATETC *	m_rgFormats;	// the formats

	// OLE1 support functions and data
	HGLOBAL		GetOwnerOrObjectLink(void);
	HGLOBAL		GetNativeData(void);

	BOOL		VerifyOwnerOrObjectLink( FORMATETC *pformatec,
				STGMEDIUM *pmedium);
	BOOL		VerifyNativeData( FORMATETC *pformatetc,
				STGMEDIUM *pmedium);

	Ole1TestFlags	m_fOle1;	// OLE1 configuration flags
	BOOL		m_fQICalled;

};

//+-------------------------------------------------------------------------
//
//  Class: 	CGenEnumFormatEtc
//
//  Purpose:	Enumerator for the formats available on the generic data
//		object
//
//  Interface: 	IEnumFORMATETC
//
//  History:    dd-mmm-yy Author    Comment
// 		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

class CGenEnumFormatEtc :public IEnumFORMATETC
{
public:
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
	STDMETHOD_(ULONG,AddRef)(void);
	STDMETHOD_(ULONG,Release)(void);

	STDMETHOD(Next) (ULONG celt, FORMATETC *rgelt,
			ULONG *pceltFetched);
	STDMETHOD(Skip) (ULONG celt);
	STDMETHOD(Reset) (void);
	STDMETHOD(Clone) (IEnumFORMATETC **ppenum);

	static HRESULT Create(IEnumFORMATETC **ppIEnum, FORMATETC *prgFormats,
			DWORD cFormats);

private:
	CGenEnumFormatEtc();	// constructor
	~CGenEnumFormatEtc();	// destructor

	ULONG		m_refs;		// reference count
	ULONG		m_iCurrent;	// current clipboard format
	ULONG		m_cTotal;	// total number of formats
	FORMATETC *	m_rgFormats;	// array of available formats
};


#endif // !_GENDATA_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\genenum.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	genenum.cpp
//
//  Contents: 	implementation of CGenDataObject
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "genenum.h"

//+-------------------------------------------------------------------------
//
//  Member:     CEnumeratorTest::CEnumeratorTest
//
//  Synopsis:   Constructor
//
//  Effects:
//
//  Arguments:  [penum]		-- Enumerator Interface cast to void*
//		[ElementSize]	-- Size of elements return from next
//		[ElementCount]	-- Numer of elements that should be in the enumeration,
//				   -1 if unknown.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

CEnumeratorTest::CEnumeratorTest(
		void *penum,
		size_t ElementSize,
		LONG ElementCount,
                HRESULT& rhr)
{
	assert(penum);

	m_pEnumTest = (IGenEnum*)penum;

	m_ElementSize = ElementSize;
	m_ElementCount = ElementCount;

	rhr = m_pEnumTest->Reset();

	if (rhr != S_OK)
	{
		OutputStr(("IEnumnX: Reset failed (%lx)\r\n", rhr));
	}
}



//+-------------------------------------------------------------------------
//
//  Function: 	CEnumeratorTest::GetNext
//
//  Synopsis:	Internal Next Implementation. Does some basic checks on the	
//		return values.
//
//  Effects:
//
//  Arguments:	[celt]		-- the number of items to fetch
//		[pceltFetched]	-- the number of items fetched
//		[phresult]	-- the return from next
//
//  Requires:
//
//  Returns:	True if the basic tests passed, false if they didn't
//		The result of the next call itself is passed in param 3.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	Checks:
//		That if s_ok is returned celt and pceltFetched are ==
//		If a verify is provided it is called
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CEnumeratorTest::GetNext(	ULONG   celt,
		ULONG*  pceltFetched,
		HRESULT* phresult
		)
{
	void* 	prgelt;
	ULONG  	ul;
	BOOL	fRet = TRUE;

	// Allocate memory for the return elements

	prgelt = new char[m_ElementSize * celt];

	assert(prgelt);

	// Call next

	*phresult = m_pEnumTest->Next(celt, prgelt, pceltFetched);

	// If the return result is S_OK make sure the numbers match

	if (*phresult == S_OK)
	{
		if ((pceltFetched) && (celt != *pceltFetched))
		{
			OutputStr(("IEnumX::Next return S_OK but celt"
					" and pceltFetch mismatch.\r\n"));
			return(FALSE);
		}
	}

	// Call verify to make sure the elements are ok.

	if ((*phresult == NOERROR) || (*phresult == ResultFromScode(S_FALSE)))
	{
		// loop through every returned element

		for (ul=0; ul < *pceltFetched ; ul++)
		{
			if (!Verify(prgelt))
			{
				OutputStr(("Data elment %d returned by IEnumX::Next is bad.\r\n",
						ul));

				fRet = FALSE;
				// we keep looping anyway just to
				// free up resources.
			}

			// If the user supplied a cleanup function there is additional
			// memory that needs to be freed

			CleanUp(prgelt);
		}

	}

	free (prgelt);

	return fRet;
}

//+-------------------------------------------------------------------------
//
//  Method: 	CEnumeratorTest::TestNext
//
//  Synopsis:	Test the next enumerator methods
//
//  Effects:
//
//  Arguments:	None.
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CEnumeratorTest::TestNext(void)
{
	ULONG	celtFetched;
	LONG	InternalCount = 0;
	HRESULT	hresult;

	// First we want to count the element by doing a next on each one.

	do {
		if (!GetNext(1, &celtFetched, &hresult))
		{
			return ResultFromScode(E_FAIL);
		}
		if (hresult == S_OK)
		{
			InternalCount++;
		}

	} while ( hresult == S_OK );

	// If the user passed in an ammount make sure it matches what we got

	if ((m_ElementCount != -1) && (InternalCount != m_ElementCount))
	{
		OutputStr(("IEnumX: enumerated count and passed count do not match!\r\n"));
		return ResultFromScode(E_FAIL);
	}

	m_pEnumTest->Reset();

	// Make sure we fail on ...Next(celt>1, ...,NULL)

	/* BUGBUG: clipboard enumerator fails on this test

	if (GetNext(2, NULL, &hresult))
	{
		if ((hresult == S_OK ) || (hresult == S_FALSE))
		{
			(("IEnumX: celt>1 pceltFetched==NULL returned S_OK\r\n"));
			return(E_FAIL);
		}
	}
	else
	{
		return(E_FAIL);
	}

	*/

	return(S_OK);

}

//+-------------------------------------------------------------------------
//
//  Method: 	CEnumeratorTest::TestAll
//
//  Synopsis:	This function calls all the tests
//
//  Effects:
//
//  Arguments:	None
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CEnumeratorTest::TestAll(void)
{
	return(TestNext());


}




//+-------------------------------------------------------------------------
//
//  Method: 	CEnumeratorTest::VerifyAll
//
//  Synopsis:   Verify entire array of returned results.
//
//  Arguments:	None
//
//  Returns:	HRESULT
//
//  Algorithm:  Just default to saying everything is ok
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 ricksa    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CEnumeratorTest::VerifyAll(void *pv, LONG cl)
{
	return TRUE;
}




//+-------------------------------------------------------------------------
//
//  Method: 	CEnumeratorTest::CleanUp
//
//  Synopsis:   Default implementation of cleanup
//
//  Arguments:  [pv] - pointer to entry enumerated
//
//  Algorithm:  If there is nothing special to free this implementation
//              can be used.
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 ricksa    author
//
//--------------------------------------------------------------------------

void  CEnumeratorTest::CleanUp(void *pv)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\dataadv.cpp ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	cliptest.cpp
//
//  Contents:   Data Advise Holder tests
//
//  Classes:    CDataAdviseTestFormatEtc
//              CTestAdviseSink
//              CTestDaHolder
//
//  Functions:  TestPrimeFirstOnlyOnceNoData
//              TestPrimeFirstOnlyOnceData
//              DoRegisterNotifyDeregister
//              TestRegisterNotifyDegister
//              TestRegisterNotifyDegisterNoData
//              TestNotifyOnStop
//              TestNotifyOnce
//              CreateMassRegistration
//              DoMassUnadvise
//              TestEnumerator
//              LEDataAdviseHolderTest
//
//  History:    dd-mmm-yy Author    Comment
//		25-May-94 ricksa    author
//
//--------------------------------------------------------------------------

#include    "oletest.h"
#include    "gendata.h"
#include    "genenum.h"



//+-------------------------------------------------------------------------
//
//  Class:      CDataAdviseTestFormatEtc
//
//  Purpose:    Hold FORMATETC used by the data advise holder unit tests
//
//  Interface:  GetFormatEtc - get a pointer to the FORMATETC
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
class CDataAdviseTestFormatEtc
{
public:
                        CDataAdviseTestFormatEtc(void);

    FORMATETC *         GetFormatEtc(void);

private:

    FORMATETC           _formatetc;
};




//+-------------------------------------------------------------------------
//
//  Member:     CDataAdviseTestFormatEtc::CDataAdviseTestFormatEtc
//
//  Synopsis:   Initialize object
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
CDataAdviseTestFormatEtc::CDataAdviseTestFormatEtc(void)
{
    _formatetc.cfFormat = RegisterClipboardFormat("OleTest Storage Format");
    _formatetc.ptd = NULL;
    _formatetc.dwAspect = DVASPECT_CONTENT;
    _formatetc.lindex = -1;
    _formatetc.tymed = TYMED_ISTORAGE;
}




//+-------------------------------------------------------------------------
//
//  Member:     CDataAdviseTestFormatEtc::GetFormatEtc
//
//  Synopsis:   Get pointer to standard format etc
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
FORMATETC *CDataAdviseTestFormatEtc::GetFormatEtc(void)
{
    return &_formatetc;
}




// Global Formatec for all the data advise tests
CDataAdviseTestFormatEtc g_datfeDaTest;




//+-------------------------------------------------------------------------
//
//  Class:      CTestAdviseSink
//
//  Purpose:    Advise sink used to verify data advise holder
//
//  Interface:  QueryInterface - get new interface pointer
//              AddRef - bump reference count
//              Release - decrement reference count
//              OnDataChange - data change notification
//              OnViewChange - not implemented
//              OnRename - not implemented
//              OnSave - not implemented
//              OnClose - not implemented
//              ValidOnDataChange - verify all expected data change notification
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      We only implement interface methods required for
//              test of data advise holder.
//
//--------------------------------------------------------------------------
class CTestAdviseSink : public IAdviseSink
{
public:
                        CTestAdviseSink(CGenDataObject *pgdo);

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);

    STDMETHOD_(ULONG, AddRef)(void);

    STDMETHOD_(ULONG, Release)(void);

    // IAdviseSink methods
    STDMETHOD_(void, OnDataChange)(FORMATETC *pFormatetc, STGMEDIUM *pStgmed);

    STDMETHOD_(void, OnViewChange)(
                            DWORD dwAspect,
                            LONG lindex);

    STDMETHOD_(void, OnRename)(IMoniker *pmk);

    STDMETHOD_(void, OnSave)(void);

    STDMETHOD_(void, OnClose)(void);

    // Test methods used for verification
    BOOL                ValidOnDataChange(void);

private:

    LONG                _lRefs;

    CGenDataObject *    _pgdo;

    BOOL                _fValidOnDataChange;

};



//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::CTestAdviseSink
//
//  Synopsis:   Initialize object
//
//  Arguments:  [pgdo] - generic data object
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      pgdo being NULL means we don't expect a STGMEDIUM when
//              the OnDataChange notification occurs.
//
//--------------------------------------------------------------------------
CTestAdviseSink::CTestAdviseSink(CGenDataObject *pgdo)
    : _lRefs(1), _fValidOnDataChange(FALSE)
{
    _pgdo = pgdo;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::QueryInterface
//
//  Synopsis:   Return a new interface
//
//  Arguments:  [riid] - interface id requested
//              [ppvObj] - where to put the interface
//
//  Returns:    S_OK - we are returning an interface
//              E_NOINTERFACE - we do not support the requested interface
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CTestAdviseSink::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj)
{
    if (IsEqualGUID(IID_IUnknown, riid) || IsEqualGUID(IID_IAdviseSink, riid))
    {
        AddRef();
        *ppvObj = this;
        return NOERROR;
    }

    *ppvObj = NULL;

    return E_NOINTERFACE;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::AddRef
//
//  Synopsis:   Bump reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTestAdviseSink::AddRef(void)
{
    return _lRefs++;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::Release
//
//  Synopsis:   Decrement reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTestAdviseSink::Release(void)
{
    assert(_lRefs >= 1);

    return --_lRefs;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::OnDataChange
//
//  Synopsis:   Notify of change in data
//
//  Arguments:  [pFormatetc] - FORMATETC of data
//              [pStgmed] - storage medium for data
//
//  Algorithm:  Verify that the we recieved the expected FORMATEC. Then
//              verify that we recieved the expected STGMEDIUM.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(void) CTestAdviseSink::OnDataChange(
    FORMATETC *pFormatetc,
    STGMEDIUM *pStgmed)
{
    // Verify the format
    if (memcmp(g_datfeDaTest.GetFormatEtc(), pFormatetc, sizeof(FORMATETC))
        == 0)
    {
        if (_pgdo != NULL)
        {
            // We have a data object that we can use to verify the format
            // so we do.
            _fValidOnDataChange =
                _pgdo->VerifyFormatAndMedium(pFormatetc, pStgmed);
        }
        // We are expecting an empty STGMEDIUM so verify that it is
        else if ((pStgmed->tymed == TYMED_NULL)
            && (pStgmed->pUnkForRelease == NULL))
        {
            _fValidOnDataChange = TRUE;
        }
    }
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::OnViewChange
//
//  Synopsis:   Notify that view should change
//
//  Arguments:  [dwAspect] - specifies view of the object
//              [lindex] -  which piece of view changed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
STDMETHODIMP_(void) CTestAdviseSink::OnViewChange(
    DWORD dwAspect,
    LONG lindex)
{
    OutputString("CTestAdviseSink::OnViewChange Unexpectedly Called!\r\n");
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::OnRename
//
//  Synopsis:   Notifies of rename operation
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
STDMETHODIMP_(void) CTestAdviseSink::OnRename(IMoniker *pmk)
{
    OutputString("CTestAdviseSink::OnRename Unexpectedly Called!\r\n");
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::OnSave
//
//  Synopsis:   Notify that object was saved
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
STDMETHODIMP_(void) CTestAdviseSink::OnSave(void)
{
    OutputString("CTestAdviseSink::OnSave Unexpectedly Called!\r\n");
}



//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::OnClose
//
//  Synopsis:   Notify object closed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
STDMETHODIMP_(void) CTestAdviseSink::OnClose(void)
{
    OutputString("CTestAdviseSink::OnClose Unexpectedly Called!\r\n");
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestAdviseSink::ValidOnDataChange
//
//  Synopsis:   Verify that we recieved the expected OnDataChange notification
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CTestAdviseSink::ValidOnDataChange(void)
{
    BOOL fResult = _fValidOnDataChange;
    _fValidOnDataChange = FALSE;
    return fResult;
}


// Preallocated structure used to mass advise registration testing
#define MAX_REGISTER 100
struct
{
    CTestAdviseSink *   ptas;
    DWORD               dwConnection;
} aMassAdvise[MAX_REGISTER];




//+-------------------------------------------------------------------------
//
//  Class:      CTestDaHolder
//
//  Purpose:    Test enumerator for data advise holder
//
//  Interface:  Verify - verify particular entry being enumerated
//              VerifyAllEnmerated - verify all entries were enumerated once
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
class CTestDaHolder : public CEnumeratorTest
{
public:

                        CTestDaHolder(IEnumSTATDATA *penumAdvise, HRESULT& rhr);

    BOOL                Verify(void *);

    BOOL                VerifyAllEnmerated(void);

    BOOL                VerifyAll(void *, LONG);

private:

    DWORD               _cdwFound[MAX_REGISTER];
};




//+-------------------------------------------------------------------------
//
//  Member:     CTestDaHolder::CTestDaHolder
//
//  Synopsis:   Initialize object
//
//  Arguments:  [penumAdvise] - data advise holder enumerator
//              [rhr] - HRESULT reference thorugh which to return an error
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
CTestDaHolder::CTestDaHolder(IEnumSTATDATA *penumAdvise, HRESULT& rhr)
    : CEnumeratorTest(penumAdvise, sizeof(STATDATA), MAX_REGISTER, rhr)
{
    // Zero out our table of counts
    memset(&_cdwFound[0], 0, sizeof(_cdwFound));
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestDaHolder::VerifyAllEnmerated
//
//  Synopsis:   Verify all objects got enumerated
//
//  Returns:    TRUE - all objects enumerated
//              FALSE - error in enumeration
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CTestDaHolder::VerifyAllEnmerated(void)
{
    for (int i = 0; i < MAX_REGISTER; i++)
    {
        if (_cdwFound[i] != 1)
        {
            OutputString("Entry %d enumerated %d times\r\n", i, _cdwFound[i]);
            return FALSE;
        }

        // Reset for another test
        _cdwFound[i] = 0;
    }

    return TRUE;
}



//+-------------------------------------------------------------------------
//
//  Member:     CTestDaHolder::Verify
//
//  Synopsis:   Verify an enumeration entry
//
//  Arguments:  [pvEntry] - entry enumerated
//
//  Returns:    TRUE - enumerated entry is valid
//              FALSE - obvious error in enumeration
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CTestDaHolder::Verify(void *pvEntry)
{
    STATDATA *pstatdata = (STATDATA *) pvEntry;

    // Verify the advf field
    if ((pstatdata->advf == 0)
        && (memcmp(g_datfeDaTest.GetFormatEtc(), &pstatdata->formatetc,
            sizeof(FORMATETC)) == 0))
    {
        // Can we find the connection?
        for (int i = 0; i < MAX_REGISTER; i++)
        {
            if (pstatdata->dwConnection == aMassAdvise[i].dwConnection)
            {
                // Bump found count
                _cdwFound[i]++;

                // Everything is OK so tell the caller
                return TRUE;
            }
        }
    }

    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Member:     CTestDaHolder::VerifyAll
//
//  Synopsis:   Verify that an array of all entries is valid
//
//  Arguments:  [pvEntries] - array of enumerated data
//              [clEntries] - number of enumerated entries
//
//  Returns:    TRUE - enumerated entry is valid
//              FALSE - obvious error in enumeration
//
//  History:    dd-mmm-yy Author    Comment
//              02-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CTestDaHolder::VerifyAll(void *pvEntries, LONG clEntries)
{
    // Verify that the count is as expected.
    if (clEntries != MAX_REGISTER)
    {
        return FALSE;
    }

    // Verify each entry in the array is reasonable
    STATDATA *pstatdata = (STATDATA *) pvEntries;

    for (int i = 0; i < MAX_REGISTER; i++, pstatdata++)
    {
        if (!Verify(pstatdata))
        {
            return FALSE;
        }
    }

    // Verify that each entry was only referred to once
    return VerifyAllEnmerated();
}





//+-------------------------------------------------------------------------
//
//  Function:   TestPrimeFirstOnlyOnceNoData
//
//  Synopsis:   Test one notification of
//              ADVF_NODATA | ADVF_PRIMEFIRST | ADVF_ONLYONCE
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create an test advise sink object. Register it with the
//              advise holder which should cause the notification. Verify
//              that the advise was notified and that no connection was
//              returned.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestPrimeFirstOnlyOnceNoData(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    // Create an advise sink - the NULL means we don't want to validate
    // the STGMEDIUM.
    CTestAdviseSink tas(NULL);

    DWORD dwConnection = 0;

    // Register the advise
    HRESULT hr = pdahTest->Advise(pgdo, g_datfeDaTest.GetFormatEtc(),
        ADVF_NODATA | ADVF_PRIMEFIRST | ADVF_ONLYONCE, &tas, &dwConnection);

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("TestPrimeFirstOnlyOnceNoData OnDataChange invalid!\r\n");
        return E_FAIL;
    }

    // Make sure the advise was not registered
    if (dwConnection != 0)
    {
        OutputString("TestPrimeFirstOnlyOnceNoData got Connection!\r\n");
        return E_FAIL;
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   TestPrimeFirstOnlyOnceData
//
//  Synopsis:   Test one notification of
//              ADVF_PRIMEFIRST | ADVF_ONLYONCE
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create an test advise sink object. Register it with the
//              advise holder which should cause the notification. Verify
//              that the advise was notified and that no connection was
//              returned.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestPrimeFirstOnlyOnceData(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    // Create an advise sink that we can verify the STGMEDIUM
    CTestAdviseSink tas(pgdo);

    // Where to store the connection
    DWORD dwConnection = 0;

    // Register the advise
    HRESULT hr = pdahTest->Advise(pgdo, g_datfeDaTest.GetFormatEtc(),
        ADVF_PRIMEFIRST | ADVF_ONLYONCE, &tas, &dwConnection);

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("TestPrimeFirstOnlyOnceData OnDataChange invalid!\r\n");
        return E_FAIL;
    }

    // Make sure the advise was not registered
    if (dwConnection != 0)
    {
        OutputString("TestPrimeFirstOnlyOnceData got Connection!\r\n");
        return E_FAIL;
    }

    return NOERROR;
}



//+-------------------------------------------------------------------------
//
//  Function:   DoRegisterNotifyDeregister
//
//  Synopsis:
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pdo] - IDataObject interface
//              [pgdo] - generic data object
//              [advf] - advise flags to use
//              [pszCaller] - name of test
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create a test advise sink object. Register for an notification
//              with the data advise holder. Confirm that the prime first
//              notification worked. Confirm that the object did get
//              registered. Tell the advise holder to notify all registered
//              advises that the data changed. Confirm that the appropriate
//              notification was sent. Then deregister the advise. Do it
//              again to make sure the connection is no longer valid.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT DoRegisterNotifyDeregister(
    IDataAdviseHolder *pdahTest,
    IDataObject *pdo,
    CGenDataObject *pgdo,
    DWORD advf,
    char *pszCaller)
{
    // Create an advise sink that we can verify the STGMEDIUM
    CTestAdviseSink tas(pgdo);

    // Where to store the connection
    DWORD dwConnection;

    // Register the advise
    HRESULT hr = pdahTest->Advise(pdo, g_datfeDaTest.GetFormatEtc(),
        ADVF_PRIMEFIRST | advf, &tas, &dwConnection);

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("%s First OnDataChange invalid!\r\n", pszCaller);
        return E_FAIL;
    }

    // Make sure the advise is registered
    if (dwConnection == 0)
    {
        OutputString("%s did not get Connection!\r\n", pszCaller);
        return E_FAIL;
    }

    // Test regular data change
    hr = pdahTest->SendOnDataChange(pdo, 0, 0);

    if (hr != NOERROR)
    {
        OutputString("%s SendOnDataChange unexpected HRESULT = %lx!\r\n",
            pszCaller, hr);
        return E_FAIL;
    }

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("%s Second OnDataChange invalid!\r\n", pszCaller);
        return E_FAIL;
    }

    // Test unadvise
    hr = pdahTest->Unadvise(dwConnection);

    if (hr != NOERROR)
    {
        OutputString("%s Unadvise unexpected HRESULT = %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    // Test second unadvise on the same connection
    hr = pdahTest->Unadvise(dwConnection);

    if (hr != OLE_E_NOCONNECTION)
    {
        OutputString("%s Second Unadvise Bad Hresult = %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   TestRegisterNotifyDegister
//
//  Synopsis:   Test a simple register/notify/deregister sequence
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestRegisterNotifyDegister(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    return DoRegisterNotifyDeregister(pdahTest, pgdo, pgdo, 0,
        "TestRegisterNotifyDegister");
}



//+-------------------------------------------------------------------------
//
//  Function:   TestRegisterNotifyDegisterNoData
//
//  Synopsis:   Test a simple register/notify/deregister sequence with
//              no data being returned.
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestRegisterNotifyDegisterNoData(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    return DoRegisterNotifyDeregister(pdahTest, pgdo, NULL, ADVF_NODATA,
        "TestRegisterNotifyDegisterNoData");
}




//+-------------------------------------------------------------------------
//
//  Function:   TestNotifyOnStop
//
//  Synopsis:   Test a registration with a call of notify on stop
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create a test object. Register it with the advise holder.
//              Confirm that the connection was returned and that no
//              notification occurred. Then tell the data advise holder
//              to notify its registrations of a data change. Make sure
//              that the advise was correctly notified. Finally, verify
//              that we can deregister the advise and that its connection
//              becomes invalid.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT  TestNotifyOnStop(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    // Routine name for messages
    char *pszCaller = "TestNotifyOnStop";

    // Create an advise sink that we can verify the STGMEDIUM
    CTestAdviseSink tas(pgdo);

    // Where to store the connection
    DWORD dwConnection;

    // Register the advise
    HRESULT hr = pdahTest->Advise(pgdo, g_datfeDaTest.GetFormatEtc(),
        ADVF_DATAONSTOP, &tas, &dwConnection);

    // Make sure the advise is registered
    if (dwConnection == 0)
    {
        OutputString("%s did not get Connection!\r\n", pszCaller);
        return E_FAIL;
    }

    // Confirm that the data object was not notified
    if (tas.ValidOnDataChange())
    {
        OutputString("%s Registration caused notification!\r\n", pszCaller);
        return E_FAIL;
    }

    // Test regular data change
    hr = pdahTest->SendOnDataChange(pgdo, 0, ADVF_DATAONSTOP);

    if (hr != NOERROR)
    {
        OutputString("%s SendOnDataChange unexpected HRESULT = %lx!\r\n",
            pszCaller, hr);
        return E_FAIL;
    }

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("%s Second OnDataChange invalid!\r\n", pszCaller);
        return E_FAIL;
    }

    // Test unadvise
    hr = pdahTest->Unadvise(dwConnection);

    if (hr != NOERROR)
    {
        OutputString("%s Unadvise unexpected HRESULT = %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    // Test second unadvise on the same connection
    hr = pdahTest->Unadvise(dwConnection);

    if (hr != OLE_E_NOCONNECTION)
    {
        OutputString("%s Second Unadvise Bad Hresult = %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Function:   TestNotifyOnce
//
//  Synopsis:   Test a notify once advise
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create a test advise object. Register it to be advised only
//              once of a change. Confirm that we got a registration. Then
//              tell the advise holder to notify its advises of a data
//              change. Confirm that the correct notification occurred. Finally,
//              confirm that we are no longer registered with the advise
//              holder.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT  TestNotifyOnce(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    // Routine name for messages
    char *pszCaller = "TestNotifyOnce";

    // Create an advise sink that we can verify the STGMEDIUM
    CTestAdviseSink tas(pgdo);

    // Where to store the connection
    DWORD dwConnection;

    // Register the advise
    HRESULT hr = pdahTest->Advise(pgdo, g_datfeDaTest.GetFormatEtc(),
        ADVF_ONLYONCE, &tas, &dwConnection);

    // Make sure the advise is registered
    if (dwConnection == 0)
    {
        OutputString("%s did not get Connection!\r\n", pszCaller);
        return E_FAIL;
    }

    // Test regular data change
    hr = pdahTest->SendOnDataChange(pgdo, 0, 0);

    if (hr != NOERROR)
    {
        OutputString("%s SendOnDataChange unexpected HRESULT = %lx!\r\n",
            pszCaller, hr);
        return E_FAIL;
    }

    // Confirm that the advise is notified and in the correct state
    if (!tas.ValidOnDataChange())
    {
        OutputString("%s Send OnDataChange invalid!\r\n", pszCaller);
        return E_FAIL;
    }

    // Try a second notify
    hr = pdahTest->SendOnDataChange(pgdo, 0, 0);


    // Confirm that the advise is *not* notified
    if (tas.ValidOnDataChange())
    {
        OutputString("%s Second OnDataChange unexpectedly succeeded!\r\n",
            pszCaller);
        return E_FAIL;
    }

    // Test unadvise - should fail since we requested to be notified
    // only once.
    hr = pdahTest->Unadvise(dwConnection);

    if (hr != OLE_E_NOCONNECTION)
    {
        OutputString("%s Second Unadvise Bad Hresult = %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Function:   CreateMassRegistration
//
//  Synopsis:   Register a large number of advise objects with a holder
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//              [pszCaller] - name of test
//
//  Returns:    NOERROR - all advises were registered
//              E_FAIL - error in registration
//
//  Algorithm:  Create a MAX_REGISTER number of test advise objects and
//              store them in the aMassAdvise array. Then register them
//              all with the input advise holder.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CreateMassRegistration(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo,
    char *pszCaller)
{
    // Create the advise sinks for the test for the test
    for (int i = 0; i < MAX_REGISTER; i++)
    {
        aMassAdvise[i].ptas = new CTestAdviseSink(pgdo);

        if (aMassAdvise[i].ptas == NULL)
        {
            OutputString(
                "%s Advise create of test advise failed on %d!\r\n", pszCaller,
                    i);
            return E_FAIL;
        }

        aMassAdvise[i].dwConnection = 0;
    }

    HRESULT hr;

    // Register the advise sinks
    for (i = 0; i < MAX_REGISTER; i++)
    {
        // Register the advise
        hr = pdahTest->Advise(pgdo, g_datfeDaTest.GetFormatEtc(),
            0, aMassAdvise[i].ptas, &aMassAdvise[i].dwConnection);

        if (hr != NOERROR)
        {
            OutputString(
                "%s Advise unexpected HRESULT = %lx on %d!\r\n", pszCaller,
                    hr, i);
            return E_FAIL;
        }
    }

    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   DoMassUnadvise
//
//  Synopsis:   Deregister all entries in the aMassAdvise array
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pszCaller] - name of test
//
//  Returns:    NOERROR - deregistration worked
//              E_FAIL - error in deregistration
//
//  Algorithm:  For each entry in the aMassAdvise array, deregister it
//              from the holder. Then confirm that its connection is
//              no longer valid.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT DoMassUnadvise(
    IDataAdviseHolder *pdahTest,
    char *pszCaller)
{
    HRESULT hr;

    // Unadvise them
    for (int i = 0; i < MAX_REGISTER; i++)
    {
        // Test unadvise
        hr = pdahTest->Unadvise(aMassAdvise[i].dwConnection);

        if (hr != NOERROR)
        {
            OutputString(
                "%s Unadvise unexpected HRESULT = %lx on %d!\r\n", pszCaller,
                    hr, i);
            return E_FAIL;
        }

        // Test second unadvise on the same connection
        hr = pdahTest->Unadvise(aMassAdvise[i].dwConnection);

        if (hr != OLE_E_NOCONNECTION)
        {
            OutputString(
                "%s Second Unadvise Bad Hresult = %lx on %d!\r\n", pszCaller,
                    hr, i);
            return E_FAIL;
        }
    }

    // Delete the advise sinks for the test
    for (i = 0; i < MAX_REGISTER; i++)
    {
        delete aMassAdvise[i].ptas ;
    }

    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Function:   TestMassRegister
//
//  Synopsis:   Test registering a large number of advises with a holder
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Register a large number of test advises with the data advise
//              holder. Then tell the advise holder to notify them of
//              a change. Confirm that all registered entries were notified.
//              Finally, deregister all the test advises.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestMassRegister(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    char *pszCaller = "TestMassRegister";

    HRESULT hr = CreateMassRegistration(pdahTest, pgdo, "TestMassRegister");

    if (hr != NOERROR)
    {
        return hr;
    }

    // Notify them of a change
    hr = pdahTest->SendOnDataChange(pgdo, 0, 0);

    // Verify that each was notified
    for (int i = 0; i < MAX_REGISTER; i++)
    {
        if (!aMassAdvise[i].ptas->ValidOnDataChange())
        {
            OutputString(
                "%s OnDataChange invalid for entry %d!\r\n", pszCaller, i);
            return E_FAIL;
        }
    }

    // Unadvise them and free the memory
    return DoMassUnadvise(pdahTest, "TestMassRegister");
}




//+-------------------------------------------------------------------------
//
//  Function:   TestEnumerator
//
//  Synopsis:   Test the data advise holder enumerator
//
//  Arguments:  [pdahTest] - data advise holder we are testing
//              [pgdo] - generic data object
//
//  Returns:    NOERROR - notification was correct
//              E_FAIL - error in notification
//
//  Algorithm:  Create a large number of test advises and register them
//              with the advise holder. Get an advise enumerator. Create
//              a test enumerator object. Tell the test enumerator object
//              to enumerate all the object in the holder. Verify that
//              all objects were correctly enumerated. Then release the
//              advise holder enumerator. Finally, deregister all the
//              test advises from the advise holder.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT  TestEnumerator(
    IDataAdviseHolder *pdahTest,
    CGenDataObject *pgdo)
{
    char *pszCaller = "TestEnumerator";

    // Do a mass register
    HRESULT hr = CreateMassRegistration(pdahTest, pgdo, pszCaller);

    if (hr != NOERROR)
    {
        return hr;
    }

    // Get an enumerator for this registration
    IEnumSTATDATA *penumAdvise;

    hr = pdahTest->EnumAdvise(&penumAdvise);

    if (hr != NOERROR)
    {
        OutputString("%s EnumAdvise failed %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    // Create a test enumerator object
    CTestDaHolder tdh(penumAdvise, hr);

    if (hr != NOERROR)
    {
        OutputString(
            "%s Failed creating  CTestDaHolder %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    // Enmerate all 1 by 1
    if (tdh.TestNext() != NOERROR)
    {
        OutputString(
            "%s tdh.TestNext failed during enumeration\r\n", pszCaller);
        return E_FAIL;
    }

    // Verify that all entries were enumerated
    if (!tdh.VerifyAllEnmerated())
    {
        OutputString(
            "%s tdh.VerifyAllEnmerated failed verification pass\r\n", pszCaller);
        return E_FAIL;
    }

    // Do a test all
    if (tdh.TestAll() != NOERROR)
    {
        OutputString(
            "%s tdh.TestAll failed during enumeration\r\n", pszCaller);
        return E_FAIL;
    }

    // Release the advise enumerator
    if (penumAdvise->Release() != 0)
    {
        OutputString(
            "%s Failed freeing advise enumerator %lx!\r\n", pszCaller, hr);
        return E_FAIL;
    }

    // Release the registrations
    return DoMassUnadvise(pdahTest, pszCaller);
}




//+-------------------------------------------------------------------------
//
//  Function:   LEDataAdviseHolderTest
//
//  Synopsis:   Unit test for the data advise holder.
//
//  Returns:    NOERROR - test passed
//              E_FAIL - test failed.
//
//  Algorithm:  Create an advise holder object. Run through all the test
//              cases. Return NOERROR if they succeed or stop with the first
//              that fails.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT LEDataAdviseHolderTest(void)
{
    // Create a data object for use in the test
    CGenDataObject *pgdo = new CGenDataObject;

    assert(pgdo);

    // Create a data advise holder
    IDataAdviseHolder *pdahTest;

    HRESULT hr = CreateDataAdviseHolder(&pdahTest);

    if (hr != NOERROR)
    {
        OutputString(
            "LEDataAdviseHolderTest CreateDataAdviseHolder Faild hr = %lx", hr);
        return hr;
    }

    // Case 1: ADVF_PRIMEFIRST & ADVF_ONLYONCE & ADVF_NODATA
    if ((hr = TestPrimeFirstOnlyOnceNoData(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 2: ADVF_PRIMEFIRST
    if ((hr = TestPrimeFirstOnlyOnceNoData(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 3: Register/Notify/Deregister
    if ((hr = TestRegisterNotifyDegister(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 4: Register/Notify/Deregister with no data returned
    if ((hr = TestRegisterNotifyDegisterNoData(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 5: Test notify on stop
    if ((hr = TestNotifyOnStop(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 6: Test notify only once
    if ((hr = TestNotifyOnce(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 7: Test mass Register/Notify/Deregister
    if ((hr = TestMassRegister(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // Case 8: Test Enumerator
    if ((hr = TestEnumerator(pdahTest, pgdo)) != NOERROR)
    {
        return hr;
    }

    // We are done
    DWORD dwFinalRefs = pdahTest->Release();

    if (dwFinalRefs != 0)
    {
        OutputString(
            "LEDataAdviseHolderTest Final Release is = %d", dwFinalRefs);
        return E_FAIL;
    }

    pgdo->Release();

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\cliptest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	cliptest.cpp
//
//  Contents: 	Clipboard Unit tests
//
//  Classes:
//
//  Functions:	LEClipTest1
//
//  History:    dd-mmm-yy Author    Comment
//		23-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "gendata.h"
#include "genenum.h"
#include "letest.h"

SLETestInfo letiClipTest = { "cntroutl", WM_TEST1 };

//
// functions local to this file
//

void	DumpClipboardFormats(FILE *fp);
HRESULT LEOle1ClipTest2Callback( void );
HRESULT	StressOleFlushClipboard(void);
HRESULT	StressOleGetClipboard(void);
HRESULT	StressOleIsCurrentClipboard(void);
HRESULT	StressOleSetClipboard(void);


class CClipEnumeratorTest : public CEnumeratorTest
{
public:

        CClipEnumeratorTest(
            IEnumFORMATETC *penum,
            LONG clEntries,
            HRESULT& rhr);

        BOOL Verify(void *);
};



CClipEnumeratorTest::CClipEnumeratorTest(
    IEnumFORMATETC *penum,
    LONG clEntries,
    HRESULT& rhr)
        : CEnumeratorTest(penum, sizeof(FORMATETC), clEntries, rhr)
{
    // Header does all the work
}


BOOL CClipEnumeratorTest::Verify(void *)
{
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function: 	DumpClipboardFormats
//
//  Synopsis:	dumps the formats currently on the clipboard to a file
//
//  Effects:
//
//  Arguments:	[fp]	-- the file to print the current formats
//
//  Requires:	
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//   		11-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void DumpClipboardFormats( FILE *fp )
{
	char	szBuf[256];
	UINT	cf = 0;

	fprintf(fp, "==================================================\n\n");

	OpenClipboard(NULL);

	while( (cf = EnumClipboardFormats(cf)) != 0)
	{
		GetClipboardFormatName(cf, szBuf, sizeof(szBuf));

		fprintf(fp, "%s\n", szBuf);
	}

	fprintf(fp, "\n==================================================\n");

	CloseClipboard();

	return;
}

//+-------------------------------------------------------------------------
//
//  Function: 	LEClipTest1
//
//  Synopsis: 	runs the clipboard through a series of tests
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	Tests basic OLE32 functionality of the apis:
//			OleSetClipboard
//			OleGetClipboard
//			OleIsCurrentClipboard
//			OleFlushClipboard
//		downlevel format and clipboard data object testing is *not*
//		done by this routine
//
//  History:    dd-mmm-yy Author    Comment
//	 	23-Mar-94 alexgo    author
//              22-Jul-94 AlexT     Add OleInit/OleUninit call
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT LEClipTest1( void )
{
	HRESULT		hresult = NOERROR;
	CGenDataObject *pDO;
	ULONG		cRefs;
	IDataObject *	pIDO;

	pDO = new CGenDataObject;

	assert(pDO);

	cRefs = pDO->AddRef();

	// if cRefs != 1, then somebody modified this test code; the tests
	// below will be invalid.

	assert(cRefs==1);

	//
	//	Basic Tests
	//

	hresult = OleSetClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// the data object should have been AddRef'ed

	cRefs = pDO->AddRef();

	if( cRefs != 3 )
	{
		OutputString("Wrong reference count!! Should be 3, "
			"was %lu\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();

        //  Calling OleInitialize & OleUninitialize should not disturb the
        //  clipboard

        hresult = OleInitialize(NULL);
        if (FAILED(hresult))
        {
	    OutputString("LEClipTest1: OleInitialize failed - hr = %lx\n",
			 hresult);
	    return ResultFromScode(E_FAIL);
        }

        OleUninitialize();

	hresult = OleGetClipboard(&pIDO);

	if( hresult != NOERROR )
	{
		OutputString("OleGetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	if( pIDO == NULL )
	{
		OutputString("OleGetClipboard returned NULL IDO\r\n");
		return ResultFromScode(E_FAIL);
	}

	// the reference count on the clipboard data object should have gone up
	// by one (to be 2). Remember this is not our data object but
        // the clipboard's.

	cRefs = pIDO->AddRef();

	if( cRefs != 2 )
	{
		OutputString("Wrong ref count!! Should be 2, was %lu\r\n",
			cRefs);
		return ResultFromScode(E_FAIL);
	}

        // Release the clipboard data object's extra add ref.

	pIDO->Release();

        // Release the clipboard's data object entirely.

	pIDO->Release();

        // the reference count on our data object should be 2 still

	cRefs = pDO->AddRef();

	if( cRefs != 3 )
	{
		OutputString("Wrong ref count!! Should be 3, was %lu\r\n",
			cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();

	// now check to see if the we are the current clipboard

	hresult = OleIsCurrentClipboard( pDO );

	if( hresult != NOERROR )
	{
		OutputString("OleIsCurrentClipboard failed! (%lx)\r\n",
			hresult);
		return hresult;
	}

	// now flush the clipboard, removing the data object

	hresult = OleFlushClipboard();

	if( hresult != NOERROR )
	{
		OutputString("OleFlushClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// Flush should have released the data object (ref count should
	// be 1)

	cRefs = pDO->AddRef();

	if( cRefs != 2 )
	{
		OutputString("Wrong ref count!! Should be 2, was %lu\r\n",
			cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();		// take it down to 1
	cRefs = pDO->Release();	// should be zero now

	if(cRefs != 0 )
	{
		OutputString("Wrong ref count on data transfer object! "
			"Unable to delete\r\n");
		return ResultFromScode(E_FAIL);
	}

	// if we got this far, basic clipboard tests passed

	OutputString("Basic Clipboard tests passed\r\n");

	// now stress individual API's

	OutputString("Now stressing clipboard API's\r\n");

	if( (hresult = StressOleFlushClipboard()) != NOERROR )
	{
		return hresult;
	}

	if( (hresult = StressOleGetClipboard()) != NOERROR )
	{
		return hresult;
	}

	if( (hresult = StressOleIsCurrentClipboard()) != NOERROR )
	{
		return hresult;
	}

	if( (hresult = StressOleSetClipboard()) != NOERROR )
	{
		return hresult;
	}

	OutputString("Clipoard API stress passed!\r\n");

	return NOERROR;
	
}

//+-------------------------------------------------------------------------
//
//  Function:	LEClipTest2
//
//  Synopsis:	Tests the clipboard data object
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//   		15-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT LEClipTest2( void )
{
	CGenDataObject *	pGenData;
	IDataObject *		pDataObj;
	HRESULT			hresult;
	IEnumFORMATETC * 	penum;
	FORMATETC		formatetc;
	STGMEDIUM		medium;
	ULONG			cRefs;

	pGenData = new CGenDataObject();

	assert(pGenData);

	cRefs = pGenData->AddRef();

	// ref count should be 1

	assert(cRefs == 1);

	hresult = OleSetClipboard(pGenData);

	if( hresult != NOERROR )
	{
		OutputString("Clip2: OleSetClipboard failed! (%lx)\r\n",
			hresult);
		goto errRtn2;
	}

	hresult = OleFlushClipboard();

	if( hresult != NOERROR )
	{
		OutputString("Clip2: OleFlushClipboard failed! (%lx)\r\n",
			hresult);
		goto errRtn2;
	}

	// get the fake clipboard data object

	hresult = OleGetClipboard(&pDataObj);

	if( hresult != NOERROR )
	{
		OutputString("Clip2: OleGetClipboard failed! (%lx)\r\n",
			hresult);
		goto errRtn2;
	}

	hresult = pDataObj->EnumFormatEtc(DATADIR_GET, &penum);

	if( hresult != NOERROR )
	{
		OutputString("Clip2: EnumFormatEtc failed! (%lx)\r\n",
			hresult);
		goto errRtn;
	}

	while( penum->Next( 1, &formatetc, NULL ) == NOERROR )
	{
		if( formatetc.cfFormat == pGenData->m_cfTestStorage ||
			formatetc.cfFormat == pGenData->m_cfEmbeddedObject )
		{
			// we should be told IStorage

			if( !(formatetc.tymed & TYMED_ISTORAGE) )
			{
				hresult = ResultFromScode(E_FAIL);
				OutputString("medium mismatch, ISTORAGE");
				break;
			}
		}

		hresult = pDataObj->GetData(&formatetc, &medium);

		if( hresult != NOERROR )
		{
			break;
  		}

		// verify the data

		if( !pGenData->VerifyFormatAndMedium(&formatetc, &medium) )
		{
      			hresult = ResultFromScode(E_FAIL);
			OutputString("Clip2: retrieved data doesn't match! "
				"cf == %d\r\n", formatetc.cfFormat);
			break;
		}

		ReleaseStgMedium(&medium);

		memset(&medium, 0, sizeof(STGMEDIUM));

	}

        {
                CClipEnumeratorTest cet(penum, -1, hresult);

	        if (hresult == S_OK)
	        {
		        hresult = cet.TestAll();
	        }
        }

	penum->Release();
		

errRtn:
	pDataObj->Release();

errRtn2:
	pGenData->Release();

	if( hresult == NOERROR )
	{
		OutputString("Clipboard data object tests Passed!\r\n");
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function: 	LEOle1ClipTest1
//
//  Synopsis: 	Simple tests of OLE1 clipboard compatibility (copy from
//		and OLE1 server)
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	Run through 15 combinations of OLE1 support and verify
//		everything came out OK
//
//  History:    dd-mmm-yy Author    Comment
//  		06-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT LEOle1ClipTest1( void )
{
	HRESULT			hresult;
	DWORD			flags;
	CGenDataObject *	pGenData = NULL;
	IDataObject *		pDataObj = NULL;
	IEnumFORMATETC *	penum = NULL;
	FORMATETC		formatetc;
	STGMEDIUM		medium;

	// we are going to take advantage of the fact that the interesting
	// OLE1 bit flags for this test are the bottom 4 bits.

	pGenData = new CGenDataObject();

	assert(pGenData);

	for( flags = 1; flags < 16; flags++ )
	{
		// test #8 is not interesting (because no ole1
		// formats are offered on the clipboard

		if( (Ole1TestFlags)flags == OLE1_OWNERLINK_PRECEDES_NATIVE )
		{
			continue;
		}

		// setup the OLE1 mode desired

		pGenData->SetupOle1Mode((Ole1TestFlags)flags);

	
		hresult = pGenData->SetOle1ToClipboard();

		if( hresult != NOERROR )
		{
			goto errRtn;
		}

		// log the formats that are currently on the clipboard
		DumpClipboardFormats(vApp.m_fpLog);

		// get the fake clipboard data object
	
		hresult = OleGetClipboard(&pDataObj);
	
		if( hresult != NOERROR )
		{
			OutputString("Ole1Clip1: OleGetClipboard failed! "
				"(%lx)\r\n", hresult);
			goto errRtn;
		}
	
		hresult = pDataObj->EnumFormatEtc(DATADIR_GET, &penum);
	
		if( hresult != NOERROR )
		{
			OutputString("Ole1Clip1: EnumFormatEtc failed! "
				"(%lx)\r\n", hresult);
			goto errRtn;
		}
	
		while( penum->Next( 1, &formatetc, NULL ) == NOERROR )
		{
			DumpFormatetc(&formatetc, vApp.m_fpLog);

#ifdef WIN32
			hresult = pDataObj->GetData(&formatetc, &medium);
	
			if( hresult != NOERROR )
			{
				goto errRtn;
			}
	
			// verify the data
	
			if( !pGenData->VerifyFormatAndMedium(&formatetc,
				&medium) )
			{
				hresult = ResultFromScode(E_FAIL);
				OutputString("Ole1Clip1: retrieved data "
					"doesn't match! cf == %d\r\n",
					formatetc.cfFormat);
				goto errRtn;
			}
	
			ReleaseStgMedium(&medium);
	
			memset(&medium, 0, sizeof(STGMEDIUM));

#endif // WIN32
		}

		// now release everything

		penum->Release();
		penum = NULL;
		pDataObj->Release();
		pDataObj = NULL;
	}

errRtn:

	if( penum )
	{
		penum->Release();
	}

	if( pDataObj )
	{
		pDataObj->Release();
	}

	if( pGenData )
	{
		pGenData->Release();
	}

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function: 	LEOle1ClipTest2
//
//  Synopsis: 	Tests OLE1 container support via the clipboard
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	Start cntroutl, tell it to copy a simpsvr object to the
//		clipboard.  Check the clipboard to make sure OLE1 formats
//		are available.
//
//		We do this by sheduling a function to check the clipboard
//		after we've launched the standard copy-to-clipboard
//		routines.
//
//  History:    dd-mmm-yy Author    Comment
//  		16-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void LEOle1ClipTest2( void *pv )
{
	// this will get triggered by the return of WM_TEST1 from
	// container outline

	vApp.m_TaskStack.Push(RunApi, (void *)LEOle1ClipTest2Callback);

	vApp.m_TaskStack.Push(LETest1, (void *)&letiClipTest);

	// now post a message to ourselves to get things rollling

	PostMessage(vApp.m_hwndMain, WM_TEST1, 0, 0);

	return;
}

//+-------------------------------------------------------------------------
//
//  Function:	LEOle1ClipTest2Callback
//
//  Synopsis: 	checks the clipboard for OLE1 formats
//
//  Effects:
//
//  Arguments:	[pv]	-- unused
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		20-Aug-94 alexgo    updated to cfObjectLink test
//		16-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT LEOle1ClipTest2Callback( void )
{
	HRESULT		hresult;
	IDataObject *	pDO;
	IEnumFORMATETC *penum;
	FORMATETC	formatetc;
	BOOL		fGotNative = FALSE,
			fGotOwnerLink = FALSE,
			fGotObjectLink = FALSE;
	UINT		cfNative,
			cfOwnerLink,
			cfObjectLink;

	cfNative = RegisterClipboardFormat("Native");
	cfOwnerLink = RegisterClipboardFormat("OwnerLink");
	cfObjectLink = RegisterClipboardFormat("ObjectLink");

	assert(vApp.m_message == WM_TEST1);

	hresult = (HRESULT)vApp.m_wparam;

	if( hresult != NOERROR )
	{
		return hresult;
	}

	// we need to wait for cntroutl to shut down before
	// fetching the clipboard

	while( (hresult = OleGetClipboard(&pDO)) != NOERROR )
	{
		if( hresult != ResultFromScode(CLIPBRD_E_CANT_OPEN) )
		{
			return hresult;
		}
	}

	hresult = pDO->EnumFormatEtc(DATADIR_GET, &penum);

	if( hresult != NOERROR )
	{
		return hresult;
	}

	while( penum->Next(1, &formatetc, NULL) == NOERROR )
	{
		if( formatetc.cfFormat == cfNative )
		{
			fGotNative = TRUE;
		}
		else if( formatetc.cfFormat == cfOwnerLink )
		{
			fGotOwnerLink = TRUE;
		}
		else if( formatetc.cfFormat == cfObjectLink )
		{
			fGotObjectLink = TRUE;
		}
	}

	penum->Release();
	pDO->Release();

	// the OLE1 container compatibility code should put
	// OLE1 formats on the clipboard.  However, they should NOT
	// be in the enumerator since the stuff was copied from
	// an OLE2 container.

	if( (fGotNative || fGotOwnerLink || fGotObjectLink) )
	{
		hresult = ResultFromScode(E_FAIL);
		return hresult;
	}

	if( IsClipboardFormatAvailable(cfNative) )
	{
		fGotNative = TRUE;
	}

	if( IsClipboardFormatAvailable(cfOwnerLink) )
	{
		fGotOwnerLink = TRUE;
	}

	if( IsClipboardFormatAvailable(cfObjectLink) )
	{
		fGotObjectLink = TRUE;
	}

	// NB!!  only Native and OwnerLink should be on the clipboard
	// this test puts an OLE2 *embedding* on the clipbaord, which
	// an OLE1 container cannot link to.  So ObjectLink should not
	// be available

	if( !(fGotNative && fGotOwnerLink && !fGotObjectLink) )
	{
		hresult = ResultFromScode(E_FAIL);

	}

	return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:	StressOleFlushClipboard
//
//  Synopsis: 	
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	stresses the following cases:
//		1.  Caller is not the clipboard owner (somebody else put
//			data on the clipboard)
//		2.  somebody else has the clipboard open
//		3.  OleFlushClipboard is called twice (second attempt should
//			not fail).
//
//  History:    dd-mmm-yy Author    Comment
//		28-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT StressOleFlushClipboard(void)
{
	HRESULT		hresult;
	CGenDataObject *pDO;
	ULONG		cRefs;

	OutputString("Now stressing OleFlushClipboard() \r\n");

	pDO = new CGenDataObject();

	assert(pDO);

	pDO->AddRef();		//initial count of 1

	//take ownership of the clipboard

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	if( !EmptyClipboard() )
	{
		OutputString("Can't EmptyClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_EMPTY);
	}

	if( !CloseClipboard() )
	{
		OutputString("Can't CloseClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_CLOSE);
	}

	// now to flush the clipboard; we should get E_FAIL

	hresult = OleFlushClipboard();

	if( hresult != ResultFromScode(E_FAIL) )
	{
		OutputString("Unexpected hresult:(%lx)\r\n", hresult);
		return (hresult) ? hresult : ResultFromScode(E_UNEXPECTED);
	}

	// now put something on the clipboard so we can flush it

	hresult = OleSetClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// open the clipboard with us

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard!\r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	// OleFlushClipboard should return with CLIPBRD_E_CANT_OPEN
	// since another window has the clipboard open

	hresult = OleFlushClipboard();

	if( hresult != ResultFromScode(CLIPBRD_E_CANT_OPEN) )
	{
		OutputString("Unexpected hresult:(%lx)\r\n", hresult);
		return (hresult)? hresult :ResultFromScode(E_UNEXPECTED);
	}

	cRefs = pDO->AddRef();

	// cRefs should be 3 (one from beginning, one from OleSetClipboard
	// and 1 from above.  OleFlushClipboard should *not* remove the
	// count for the above failure case)

	if( cRefs != 3 )
	{
		OutputString("Bad ref count, was %lu, should be 3\r\n",
			cRefs);
		return ResultFromScode(E_FAIL);
	}

	// undo the most recent addref above
	pDO->Release();

	// close the clipboard

	if( !CloseClipboard() )
	{
		OutputString("Can't CloseClipboard!\r\n");
		return ResultFromScode(CLIPBRD_E_CANT_CLOSE);
	}

	// now call OleFlushClipboard for real

	hresult = OleFlushClipboard();

	if( hresult != NOERROR )
	{
		OutputString("OleFlushClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// now call it once more

	hresult = OleFlushClipboard();

	if( hresult != NOERROR )
	{
		OutputString("Second call to OleFlushClipboard should not"
			"have failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// there should have only been 1 release from the first
	// OleFlushClipboard call.  This next release should nuke the object

	cRefs = pDO->Release();

	if( cRefs != 0 )
	{
		OutputString("Bad ref count, was %lu, should be 0\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function: 	StressOleGetClipboard
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	tests the following cases:
//		1. somebody else has the clipboard open
//
//  History:    dd-mmm-yy Author    Comment
// 		28-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT StressOleGetClipboard(void)
{
	HRESULT		hresult;
	IDataObject *	pIDO;
	CGenDataObject *pDO;
	ULONG		cRefs;

	OutputString("Stressing OleGetClipboard()\r\n");

	pDO = new CGenDataObject();

	assert(pDO);

	pDO->AddRef();

	hresult = OleSetClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard!\r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	hresult = OleGetClipboard(&pIDO);

	if( hresult != ResultFromScode(CLIPBRD_E_CANT_OPEN) )
	{
		OutputString("Unexpected hresult (%lx)\r\n", hresult);
		return (hresult) ? hresult : ResultFromScode(E_UNEXPECTED);
	}

	// the ref count should not have gone up

	cRefs = pDO->AddRef();

	if( cRefs != 3 )
	{
		OutputString("Bad ref count, was %lu, should be 3\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();

	// now clear stuff out and go home

	if( !CloseClipboard() )
	{
		OutputString("CloseClipboard failed!\r\n");
		return ResultFromScode(E_FAIL);
	}

	// this should clear the clipboard

	hresult = OleSetClipboard(NULL);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// this should be the final release on the object

	cRefs = pDO->Release();

	if( cRefs != 0 )
	{
		OutputString("Bad ref count, was %lu, should be 0\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function: 	StressOleIsCurrentClipboard
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm: 	tests the following cases
//		1. the caller is not the clipboard owner
//		2. somebody else has the clipboard open
//		2. the data object is NULL
//		3. the data object is not the data object put on the clipboard
//
//  History:    dd-mmm-yy Author    Comment
//		28-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT StressOleIsCurrentClipboard(void)
{
	HRESULT         hresult;
	CGenDataObject *pDO, *pDO2;
	ULONG		cRefs;

	OutputString("Stressing OleIsCurrentClipboard()\r\n");

	pDO = new CGenDataObject();
	pDO2 = new CGenDataObject();

	assert(pDO);
	assert(pDO2);

	pDO->AddRef();
	pDO2->AddRef();

	//take ownership of the clipboard

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	if( !EmptyClipboard() )
	{
		OutputString("Can't EmptyClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_EMPTY);
	}

	if( !CloseClipboard() )
	{
		OutputString("Can't CloseClipboard! \r\n");
		return ResultFromScode(CLIPBRD_E_CANT_CLOSE);
	}

	// now to flush the clipboard; we should get S_FALSE

	hresult = OleIsCurrentClipboard(pDO);

	if( hresult != ResultFromScode(S_FALSE) )
	{
		OutputString("Unexpected hresult:(%lx)\r\n", hresult);
		return (hresult) ? hresult : ResultFromScode(E_UNEXPECTED);
	}


	// now set the clipboard and test w/ the clipboard open
	// we should not fail in this case

	hresult = OleSetClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard!\r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	hresult = OleIsCurrentClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("Unexpected hresult (%lx)\r\n", hresult);
		return (hresult) ? hresult : ResultFromScode(E_UNEXPECTED);
	}

	// the ref count should not have gone up

	cRefs = pDO->AddRef();

	if( cRefs != 3 )
	{
		OutputString("Bad ref count, was %lu, should be 3\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();

	// now close the clipboard

	if( !CloseClipboard() )
	{
		OutputString("CloseClipboard failed!\r\n");
		return ResultFromScode(E_FAIL);
	}

	// now test for passing NULL

	hresult = OleIsCurrentClipboard(NULL);

	if( hresult != ResultFromScode(S_FALSE) )
	{
		OutputString("Unexpected hresult (%lx)\r\n", hresult);
		return (hresult)? hresult : ResultFromScode(E_FAIL);
	}

	// now test for passign other pointer

         hresult = OleIsCurrentClipboard(pDO2);

	if( hresult != ResultFromScode(S_FALSE) )
	{
		OutputString("Unexpected hresult (%lx)\r\n", hresult);
		return (hresult)? hresult : ResultFromScode(E_FAIL);
	}

	// now clean stuff up and go home

	hresult = OleSetClipboard(NULL);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard(NULL) failed!! (%lx)\r\n",
			hresult);
		return hresult;
	}

	cRefs = pDO->Release();

	// cRefs should be 0 now

	if( cRefs != 0 )
	{
		OutputString("Bad ref count, was %lu, should be 0\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}


	pDO2->Release();

	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function: 	StressOleSetClipboard
//
//  Synopsis: 	
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//	     	
//  Returns:  	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	tests the following cases:
//		1. somebody else has the clipboard open
//		2. Do OleSetClipboard with data and then
//			OleSetClipboard(NULL) to clear it out
//
//  History:    dd-mmm-yy Author    Comment
//		28-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT StressOleSetClipboard(void)
{
	HRESULT		hresult;
	CGenDataObject *pDO;
	ULONG		cRefs;

	OutputString("Stressing OleGetClipboard()\r\n");

	pDO = new CGenDataObject();

	assert(pDO);

	pDO->AddRef();


	if( !OpenClipboard(vApp.m_hwndMain) )
	{
		OutputString("Can't OpenClipboard!\r\n");
		return ResultFromScode(CLIPBRD_E_CANT_OPEN);
	}

	hresult = OleSetClipboard(pDO);

	if( hresult != ResultFromScode(CLIPBRD_E_CANT_OPEN) )
	{
		OutputString("Unexpected hresult (%lx)\r\n", hresult);
		return (hresult) ? hresult : ResultFromScode(E_UNEXPECTED);
	}

	// the ref count should not have gone up

	cRefs = pDO->AddRef();

	if( cRefs != 2 )
	{
		OutputString("Bad ref count, was %lu, should be 2\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	pDO->Release();

	if( !CloseClipboard() )
	{
		OutputString("CloseClipboard failed!\r\n");
		return ResultFromScode(E_FAIL);
	}

	// now really set the clipboard so we can try to clear it

	hresult = OleSetClipboard(pDO);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// this should clear the clipboard

	hresult = OleSetClipboard(NULL);

	if( hresult != NOERROR )
	{
		OutputString("OleSetClipboard failed! (%lx)\r\n", hresult);
		return hresult;
	}

	// this should be the final release on the object

	cRefs = pDO->Release();

	if( cRefs != 0 )
	{
		OutputString("Bad ref count, was %lu, should be 0\r\n", cRefs);
		return ResultFromScode(E_FAIL);
	}

	return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Function: 	TestOleQueryCreateFromDataMFCHack
//
//  Synopsis: 	tests the MFC hack put into OleQueryCreateFromData
//
//  Effects:
//
//  Arguments:	void
//
//  Requires: 	
//
//  Returns:  	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	create a data object that offers private data
//		put on the clipboard and then retrieve the clipboard data
//		object.
//		Call OleQueryCreateFromData on clipboard data object--
//			QI for IPS should not be called
//		Call OleQueryCreateFromData on generic data object
//			QI for IPS should be called
//		set EmbeddedObject on the generic data object
//		Call OleQueryCreateFromData; should return S_OK
//
//  History:    dd-mmm-yy Author    Comment
//		23-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT TestOleQueryCreateFromDataMFCHack( void )
{
	CGenDataObject *	pgendata;
	IDataObject *		pdataobj;
	HRESULT			hresult;


	pgendata = new CGenDataObject();

	assert(pgendata);

	pgendata->AddRef();

	pgendata->SetDataFormats(OFFER_TESTSTORAGE);

	hresult = OleSetClipboard(pgendata);

	if( hresult != NOERROR )
	{
		return hresult;
	}

	hresult = OleGetClipboard(&pdataobj);

	if( hresult != NOERROR )
	{
		return hresult;
	}

	hresult = OleQueryCreateFromData(pdataobj);

	// for a clipboard data object, we should not call QueryInterface
	// for IPersistStorage.


	if( hresult != S_FALSE || pgendata->HasQIBeenCalled() == TRUE )
	{
		return ResultFromScode(E_FAIL);
	}

	// for other data objects, if there are no OLE2 formats, then
	// we should call QI for IPersistStorage

	hresult = OleQueryCreateFromData(pgendata);

	if( hresult != S_FALSE || pgendata->HasQIBeenCalled() == FALSE )
	{
		return ResultFromScode(E_FAIL);
	}

	// now clear the clipboard and continue testing
	
	pdataobj->Release();
	hresult = OleSetClipboard(NULL);

	if( hresult != NOERROR )
	{
		return hresult;
	}

	pgendata->SetDataFormats(OFFER_EMBEDDEDOBJECT);

	hresult = OleQueryCreateFromData(pgendata);

	// we just set OLE2 data on the data object.  OQCFD should return
	// S_OK

	if( hresult != NOERROR )
	{
		return ResultFromScode(E_FAIL);
	}

	if( pgendata->Release() == 0 )
	{
		return NOERROR;
	}
	else
	{
		return ResultFromScode(E_FAIL);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\genenum.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	genenum.h
//
//  Contents: 	Declaration of a generic enum object and test object.
//
//  Classes:	CGenEnumObject
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              23-May-94 kennethm  author! author!
//
//--------------------------------------------------------------------------

#ifndef _GENENUM_H
#define _GENENUM_H

//
// This macro allows the code to use a different outputstring function.
//

#define OutputStr(a) OutputString a

//+-------------------------------------------------------------------------
//
//  Class:	IGenEnum
//
//  Purpose: 	generic enumerator
//
//  Interface: 	Abstract class
//
//  History:    dd-mmm-yy Author    Comment
//              23-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

class IGenEnum
{
public:
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) = 0;
	STDMETHOD_(ULONG,AddRef)(void) = 0;
	STDMETHOD_(ULONG,Release)(void) = 0;

	STDMETHOD(Next) (ULONG celt, void *rgelt,
			ULONG *pceltFetched) = 0;
	STDMETHOD(Skip) (ULONG celt) = 0;
	STDMETHOD(Reset) (void) = 0;
	STDMETHOD(Clone) (void **ppenum) = 0;
};

//+-------------------------------------------------------------------------
//
//  Class:	CEnumeratorTest
//
//  Purpose: 	enumerator test class
//
//  Interface: 	
//
//  History:    dd-mmm-yy Author    Comment
//              23-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

class CEnumeratorTest
{
public:	
	// Constructor

	CEnumeratorTest(
			void *penum,
			size_t ElementSize,
			LONG ElementCount,
                        HRESULT& rhr);

	// Test for each enumerator object

	HRESULT TestAll(void);
	HRESULT TestNext(void);
// NYI!	HRESULT TestSkip(void);
//	HRESULT TestClone(void);
//	HRESULT TestRelease(void);

        // For derived classes which know what we are enumerating
        virtual BOOL Verify(void *) = 0;
        virtual BOOL VerifyAll(void *, LONG);
        virtual void CleanUp(void *);

private:	

	BOOL GetNext(ULONG celt, ULONG* pceltFetched, HRESULT* phresult);

	IGenEnum *	m_pEnumTest;
	size_t		m_ElementSize;
	LONG		m_ElementCount;
};

#endif // !_GENENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\output.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	output.h
//
//  Contents:	Declarations for String output functions.
//
//  Classes:
//
//  Functions:	OutputInitialize()
//		OutputString()
//
//  History:    dd-mmm-yy Author    Comment
// 		22-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _OUTPUT_H
#define _OUTPUT_H

int OutputString( char *szFormat, ... );
void SaveToFile( void );

#endif // !_OUTPUT_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\letest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       letest.h
//
//  Contents:   declarations for all upper-layer test routines
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _LETEST_H
#define _LETEST_H

struct SLETestInfo
{
    char *pszPgm;
    UINT dwMsgId;
};

extern SLETestInfo letiInsertObjectTest1;
extern SLETestInfo letiInsertObjectTest2;

extern SLETestInfo letiInplaceTest1;

extern SLETestInfo letiOle1Test1;
extern SLETestInfo letiOle1Test2;
extern SLETestInfo letiClipTest;

void LETest1( void * );
HRESULT LEClipTest1( void );
HRESULT LEClipTest2( void );
HRESULT LEOle1ClipTest1( void );
void LEOle1ClipTest2( void *);

HRESULT LEDataAdviseHolderTest( void );
HRESULT LEOleAdviseHolderTest( void );

HRESULT TestOleQueryCreateFromDataMFCHack( void );


#endif  //!_LETEST_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\oletest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	oletest.h
//
//  Contents:	include all other headers needed for oletest
//
//  History:    dd-mmm-yy Author    Comment
//		06-Feb-93 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _OLETEST_H
#define _OLETEST_H

//system includes
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <ole2.h>

// define the OLECHAR stuff
#ifndef WIN32

#define OLECHAR char
#define LPOLESTR LPSTR
#define OLESTR(x) x

#include <toolhelp.h>

#endif // !WIN32

//app includes
#include "assert.h"
#include "task.h"
#include "stack.h"
#include "app.h"
#include "output.h"
#include "utils.h"

#include <testmess.h>

#else
	Error!  Oletest.h included multiple times.
#endif //!_OLETEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\oleadv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	oleadv.cpp
//
//  Contents: 	implementation of unit test for Ole Advise Holder
//
//  Classes:    CTestPretendMoniker
//              COaTestAdviseSink
//              COaTestObj
//
//  Functions:  NotifyOfChanges
//              TestSingleOleAdvise
//              TestMassOleAdvise
//              TestOleAdviseHolderEnumerator
//              LEOleAdviseHolderTest
//
//  History:    dd-mmm-yy Author    Comment
//              27-May-94 ricksa    author
//
//--------------------------------------------------------------------------
#include    "oletest.h"


#define MAX_OA_TO_REGISTER 100




//+-------------------------------------------------------------------------
//
//  Class:      CTestPretendMoniker
//
//  Purpose:    Use where we need a moniker to confirm reciept of OnRename
//
//  Interface:  QueryInterface - get a new interface
//              AddRef - add a reference
//              Release - remove a reference
//              VerifySig - verify signiture is correct
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      This only supports IUnknown
//
//--------------------------------------------------------------------------
class CTestPretendMoniker : public IUnknown
{
public:
                        CTestPretendMoniker(void);

    // IUnknown methods
    HRESULT __stdcall  QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    ULONG __stdcall     AddRef(void);

    ULONG __stdcall     Release(void);

    BOOL                VerifySig(void);

private:

    enum Sigs { SIG1 = 0x01020304, SIG2 = 0x04030201 };

    LONG                _lRefs;

    Sigs                _sig1;

    Sigs                _sig2;

};



//+-------------------------------------------------------------------------
//
//  Member:     CTestPretendMoniker::CTestPretendMoniker
//
//  Synopsis:   Initialize object
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
CTestPretendMoniker::CTestPretendMoniker(void)
    : _lRefs(0), _sig1(SIG1), _sig2(SIG2)
{
    // Header does all the work
}



//+-------------------------------------------------------------------------
//
//  Member:     CTestPretendMoniker::VerifySig
//
//  Synopsis:   Verify signiture is as expected
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CTestPretendMoniker::VerifySig(void)
{
    return (_sig1 == SIG1 && _sig2 == SIG2);
}



//+-------------------------------------------------------------------------
//
//  Member:     CTestPretendMoniker::QueryInterface
//
//  Synopsis:   Return a supported interface
//
//  Arguments:  [riid] - interface id requested
//              [ppvObj] - where to put the interface
//
//  Returns:    S_OK - we are returning an interface
//              E_NOINTERFACE - we do not support the requested interface
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT __stdcall CTestPretendMoniker::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj)
{
    if (IsEqualGUID(IID_IUnknown, riid) || IsEqualGUID(IID_IMoniker, riid))
    {
        AddRef();
        *ppvObj = this;
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestPretendMoniker::AddRef
//
//  Synopsis:   Bump reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
ULONG __stdcall CTestPretendMoniker::AddRef(void)
{
    return _lRefs++;
}




//+-------------------------------------------------------------------------
//
//  Member:     CTestPretendMoniker::Release
//
//  Synopsis:   Decrement the reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
ULONG __stdcall CTestPretendMoniker::Release(void)
{
    assert(_lRefs >= 1);

    return --_lRefs;
}




//+-------------------------------------------------------------------------
//
//  Class:      COaTestAdviseSink
//
//  Purpose:    Advise sink for use in testing the Ole Advise Holder
//
//  Interface:  QueryInterface - get supported interface pointer
//              AddRef - bump reference count
//              Release - decrement reference count
//              OnDataChange - not implemented
//              OnViewChange - not implemented
//              OnRename - rename notification
//              OnSave - save notification
//              OnClose - close notification
//              VerifyNotifications - verify all expected notifications arrived
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      We only support parts of advise sink we need to test the
//              advise holder.
//
//--------------------------------------------------------------------------
class COaTestAdviseSink : public IAdviseSink
{
public:
                        COaTestAdviseSink(void);

    // IUnknown methods
    HRESULT __stdcall  QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    ULONG __stdcall     AddRef(void);

    ULONG __stdcall     Release(void);

    // IAdviseSink methods
    void __stdcall      OnDataChange(FORMATETC *pFormatetc, STGMEDIUM *pStgmed);

    void __stdcall      OnViewChange(
                            DWORD dwAspect,
                            LONG lindex);

    void __stdcall      OnRename(IMoniker *pmk);

    void __stdcall      OnSave(void);

    void __stdcall      OnClose(void);

    // Test methods used for verification
    BOOL                VerifyNotifications(void);

private:

    LONG                _lRefs;

    BOOL                _fOnCloseNotify;

    BOOL                _fOnSaveNotify;

    BOOL                _fOnRenameNotify;
};



//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::COaTestAdviseSink
//
//  Synopsis:   Initialize advise sink
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
COaTestAdviseSink::COaTestAdviseSink(void)
    : _lRefs(1), _fOnCloseNotify(FALSE), _fOnSaveNotify(FALSE),
        _fOnRenameNotify(FALSE)
{
    // Header does all the work
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::QueryInterface
//
//  Synopsis:   Return requested interface pointer
//
//  Arguments:  [riid] - interface id requested
//              [ppvObj] - where to put the interface
//
//  Returns:    S_OK - we are returning an interface
//              E_NOINTERFACE - we do not support the requested interface
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT __stdcall COaTestAdviseSink::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj)
{
    if (IsEqualGUID(IID_IUnknown, riid) || IsEqualGUID(IID_IAdviseSink, riid))
    {
        AddRef();
        *ppvObj = this;
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::AddRef
//
//  Synopsis:   Bump reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
ULONG __stdcall COaTestAdviseSink::AddRef(void)
{
    return _lRefs++;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::Release
//
//  Synopsis:   Decrement reference count
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
ULONG __stdcall COaTestAdviseSink::Release(void)
{
    assert(_lRefs >= 1);

    return --_lRefs;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::OnDataChange
//
//  Synopsis:   Notify of change in data
//
//  Arguments:  [pFormatetc] - FORMATETC of data
//              [pStgmed] - storage medium for data
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
void __stdcall COaTestAdviseSink::OnDataChange(
    FORMATETC *pFormatetc,
    STGMEDIUM *pStgmed)
{
    OutputString("COaTestAdviseSink::OnDataChange Unexpectedly Called!\r\n");
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::OnViewChange
//
//  Synopsis:   Notify that view should change
//
//  Arguments:  [dwAspect] - specifies view of the object
//              [lindex] -  which piece of view changed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      Not supported for this object
//
//--------------------------------------------------------------------------
void __stdcall COaTestAdviseSink::OnViewChange(
    DWORD dwAspect,
    LONG lindex)
{
    OutputString("COaTestAdviseSink::OnViewChange Unexpectedly Called!\r\n");
}



//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::OnRename
//
//  Synopsis:   Notifies of rename operation
//
//  Arguments:  [pmk] - new full name of the object
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
void __stdcall COaTestAdviseSink::OnRename(IMoniker *pmk)
{
    // Verify that we get the pretend moniker
    CTestPretendMoniker *ptpm = (CTestPretendMoniker *) pmk;

    if (ptpm->VerifySig())
    {
        _fOnCloseNotify = TRUE;
    }
    else
    {
        OutputString("OnRename got a bad moniker\r\n");
    }
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::OnSave
//
//  Synopsis:   Notifies that object has been saved
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
void __stdcall COaTestAdviseSink::OnSave(void)
{
    _fOnSaveNotify = TRUE;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::OnClose
//
//  Synopsis:   Notifies that object has been closed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
void __stdcall COaTestAdviseSink::OnClose(void)
{
    _fOnRenameNotify = TRUE;
}



//+-------------------------------------------------------------------------
//
//  Member:     COaTestAdviseSink::VerifyNotifications
//
//  Synopsis:   Verify that we recieved expected notifications
//
//  Returns:    TRUE - we recieved expected notification
//              FALSE - we didn't receive expected notifications
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      This resets the values after returning the result
//
//--------------------------------------------------------------------------
BOOL COaTestAdviseSink::VerifyNotifications(void)
{
    // Save the result of all the notifications
    BOOL fResult = _fOnCloseNotify && _fOnSaveNotify && _fOnRenameNotify;

    // Reset the notifications
    _fOnCloseNotify = FALSE;
    _fOnSaveNotify = FALSE;
    _fOnRenameNotify = FALSE;

    // Let caller know the result of the notifications
    return fResult;
}




//+-------------------------------------------------------------------------
//
//  Class:      COaTestObj
//
//  Purpose:    Provides place to keep information related to an advise
//
//  Interface:  Register - register advise with holder
//              VerifyNotified - verify that object was notified by holder
//              Revoke - revoke registration with holder
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
class COaTestObj
{
public:
                        COaTestObj(void);

    HRESULT             Register(IOleAdviseHolder *poah, char *pszCaller);

    HRESULT             VerifyNotified(void);

    HRESULT             Revoke(void);

private:

    COaTestAdviseSink   _otas;

    DWORD               _dwConnection;

    IOleAdviseHolder *  _poah;

    char *              _pszTest;
};



//+-------------------------------------------------------------------------
//
//  Member:     COaTestObj::COaTestObj
//
//  Synopsis:   Initialize object
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
COaTestObj::COaTestObj(void) : _dwConnection(0)
{
    // Header does all the work
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestObj::Register
//
//  Synopsis:   Register advise with the holder
//
//  Arguments:  [poah] - pointer to the advise holder
//              [pszTest] - name of the test
//
//  Returns:    S_OK - registration was successful
//              E_FAIL - registration failed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT COaTestObj::Register(IOleAdviseHolder *poah, char *pszTest)
{
    // Register the advise
    HRESULT hr = poah->Advise(&_otas, &_dwConnection);

    // Make sure results are sensible
    if (hr != NOERROR)
    {
        OutputString("%s Registration failed hr = %lx\r\n", pszTest, hr);
        return E_FAIL;
    }

    if (_dwConnection == 0)
    {
        OutputString("%s Connection not updated\r\n", pszTest);
        return E_FAIL;
    }

    // Save these for the revoke
    _pszTest = pszTest;
    _poah = poah;

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestObj::VerifyNotified
//
//  Synopsis:   Verify that our advise was notified of changes
//
//  Returns:    S_OK - advise was notified of changes
//              E_FAIL - object was not notified.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT COaTestObj::VerifyNotified(void)
{
    if (!_otas.VerifyNotifications())
    {
        OutputString("%s Object not correctly notified\r\n", _pszTest);
        return E_FAIL;
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Member:     COaTestObj::Revoke
//
//  Synopsis:   Revoke our advise registration with advise holder
//
//  Returns:    S_OK - advise was successfully deregistered
//              E_FAIL - revokation experience unexpected result
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT COaTestObj::Revoke(void)
{
    // Remove the advise registration
    HRESULT hr = _poah->Unadvise(_dwConnection);

    if (hr != NOERROR)
    {
        OutputString("%s Revoke failed hr = %lx\r\n", _pszTest, hr);
        return E_FAIL;
    }

    // Try the unadvise one more time to make sure it took
    hr = _poah->Unadvise(_dwConnection);

    if (hr != OLE_E_NOCONNECTION)
    {
        OutputString("%s Second revoke bad hr = %lx\r\n", _pszTest, hr);
        return E_FAIL;
    }

    return NOERROR;
}



//+-------------------------------------------------------------------------
//
//  Function:   NotifyOfChanges
//
//  Synopsis:   Run through list of possible notifications for advise
//
//  Arguments:  [poahForTest] - advise holder we are testing
//              [pszTest] - test description
//
//  Returns:    NOERROR - all notifications reported success
//              Any Other - error occurred during notification
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      We currently only do the public notifications
//
//--------------------------------------------------------------------------
HRESULT NotifyOfChanges(IOleAdviseHolder *poahForTest, char *pszTest)
{
    // Notify Renamed
    CTestPretendMoniker tpm;

    HRESULT hr = poahForTest->SendOnRename((IMoniker *) &tpm);

    if (hr != NOERROR)
    {
        OutputString("%s SendOnRename failed hr = %lx\r\n", pszTest);
        return hr;
    }

    // Notify of save
    hr =  poahForTest->SendOnSave();

    if (hr != NOERROR)
    {
        OutputString("%s SendOnSave failed hr = %lx\r\n", pszTest);
        return hr;
    }

    // Notify of close
    hr =  poahForTest->SendOnClose();

    if (hr != NOERROR)
    {
        OutputString("%s SendOnClose failed hr = %lx\r\n", pszTest);
        return hr;
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Function:   TestSingleOleAdvise
//
//  Synopsis:   Test advise holder with only a single advise
//
//  Arguments:  [poahForTest] - advise holder we are testing
//
//  Returns:    NOERROR - test was successfully passed
//              Any Other - test failed
//
//  Algorithm:  Create a test object. Register that test object with the
//              advise holder. Tell adviser holder to notify all its objects
//              of changes. Verify that test object was notified. Revoke
//              the registration of the test object with the advise holder.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestSingleOleAdvise(IOleAdviseHolder *poahForTest)
{
    char *pszTest = "TestSingleOleAdvise";
    COaTestObj oto;

    // Register a single advise
    HRESULT hr = oto.Register(poahForTest, pszTest);

    if (hr != NOERROR)
    {
        return hr;
    }

    // Notifiy it of changes
    hr = NotifyOfChanges(poahForTest, pszTest);

    if (hr != NOERROR)
    {
        return hr;
    }

    // Verify that notifications occurred
    hr = oto.VerifyNotified();

    if (hr != NOERROR)
    {
        return hr;
    }

    // Revoke all advises
    return oto.Revoke();
}




//+-------------------------------------------------------------------------
//
//  Function:   TestMassOleAdvise
//
//  Synopsis:   Test registering a very large number of advises
//
//  Arguments:  [poahForTest] - advise holder we are testing
//
//  Returns:    NOERROR - test was successfully passed
//              Any Other - test failed
//
//  Algorithm:  Create a large number of test objects. Then register all
//              those with the advise holder for changes. Tell advise holder
//              to notify all its registered objects of changes. Verify that
//              each of the test objects recieved a notification. Finally,
//              revoke all the test object registrations.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT TestMassOleAdvise(IOleAdviseHolder *poahForTest)
{
    char *pszTest = "TestMassOleAdviseHolder";

    // Create a large number of advises
    COaTestObj aoto[MAX_OA_TO_REGISTER];

    HRESULT hr;

    // Register all the advises
    for (int i = 0; i < MAX_OA_TO_REGISTER; i++)
    {
        hr = aoto[i].Register(poahForTest, pszTest);

        if (hr != NOERROR)
        {
            OutputString("%s Failed on Loop %d\r\n", pszTest, i);
            return hr;
        }
    }

    // Notify all the advises of changes
    hr = NotifyOfChanges(poahForTest, pszTest);

    if (hr != NOERROR)
    {
        return hr;
    }

    // Verify all objects were notified
    for (i = 0; i < MAX_OA_TO_REGISTER; i++)
    {
        hr = aoto[i].VerifyNotified();

        if (hr != NOERROR)
        {
            OutputString("%s Failed on Loop %d\r\n", pszTest, i);
            return hr;
        }
    }

    // Revoke all registrations
    for (i = 0; i < MAX_OA_TO_REGISTER; i++)
    {
        hr = aoto[i].Revoke();

        if (hr != NOERROR)
        {
            OutputString("%s Failed on Loop %d\r\n", pszTest, i);
            return hr;
        }
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Function:   TestOleAdviseHolderEnumerator
//
//  Synopsis:   Test the OLE Advise Holder enumerator
//
//  Arguments:  [poahForTest] - OLE advise holder we are testing
//
//  Returns:    NOERROR - test passed
//              Any Other - test failed
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//  Notes:      We currently just verify that the enumerator is not implemented
//
//--------------------------------------------------------------------------
HRESULT TestOleAdviseHolderEnumerator(IOleAdviseHolder *poahForTest)
{
    char *pszCaller = "TestOleAdviseHolderEnumerator";

    // Confirm no enumerator
    IEnumSTATDATA *penumAdvise;

    HRESULT hr = poahForTest->EnumAdvise(&penumAdvise);

    if (hr != E_NOTIMPL)
    {
        OutputString("%s EnumAdvise Hresult = %lx\r\n", pszCaller, hr);
        return E_FAIL;
    }

    if (penumAdvise != NULL)
    {
        OutputString("%s EnumAdvise returned advise not NULL\r\n", pszCaller);
        return E_FAIL;
    }

    return NOERROR;
}




//+-------------------------------------------------------------------------
//
//  Function:   LEOleAdviseHolderTest
//
//  Synopsis:   Unit test for advise holders
//
//  Returns:    NOERROR - test passed
//              Any Other - test failed
//
//  Algorithm:  First we verify that a large number of verification work. Then
//              we verify that a large number of registrations work. Finally,
//              we verify that the enumerator for the OLE advise holder
//              behaves as expected.
//
//  History:    dd-mmm-yy Author    Comment
//              01-Jun-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT LEOleAdviseHolderTest(void)
{
    IOleAdviseHolder *poahForTest;

    HRESULT hr = CreateOleAdviseHolder(&poahForTest);

    // Test a single registration
    if ((hr = TestSingleOleAdvise(poahForTest)) != NOERROR)
    {
        return hr;
    }


    // Test a large number of registrations
    if ((hr = TestMassOleAdvise(poahForTest)) != NOERROR)
    {
        return hr;
    }


    // Test Enumerator
    if ((hr = TestOleAdviseHolderEnumerator(poahForTest)) != NOERROR)
    {
        return hr;
    }

    // Release the advise holder
    DWORD dwFinalRefs = poahForTest->Release();

    if (dwFinalRefs != 0)
    {
        OutputString(
            "LEOleAdviseHolderTest Final Release is = %d", dwFinalRefs);
        return E_FAIL;
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\output.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	output.cpp
//
//  Contents:	String output functions for displaying text on the main
//		edit window
//
//  Classes:
//
//  Functions: 	OutputString
//		SaveToFile
//
//  History:    dd-mmm-yy Author    Comment
//		22-Mar-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include <commdlg.h>

#ifndef WIN32
#include <stdarg.h>
#endif

//
// handle to memory where the text is stored
//
// Please note this is really burfy (having all these globals).  But for
// the purposes of a simple driver app, it is the easiest.
//
static HGLOBAL	hText;		// handle to the Text
static ULONG	cbText;
static ULONG	iText;

//+-------------------------------------------------------------------------
//
//  Function:	OutputString
//
//  Synopsis:	Dumps the string in printf format to the screen
//
//  Effects:
//
//  Arguments:	[szFormat]	-- the format string
//		[...]		-- variable arguments
//
//  Requires:
//
//  Returns:	int, the number of characters written (returned by sprintf)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:
//
//--------------------------------------------------------------------------

int OutputString( char *szFormat, ... )
{
	LPSTR	psz;
	va_list	ap;
	int	cbWritten;

	va_start(ap, szFormat);

	if( !hText )
	{
		hText = GlobalAlloc( GMEM_MOVEABLE , 2048 );
		assert(hText);
		cbText = 2048;
	}

	// double the size of the array if we need to

	if( iText > cbText / 2 )
	{
		hText = GlobalReAlloc(hText, cbText * 2, GMEM_MOVEABLE );
		assert(hText);
		cbText *= 2;
	}

	psz = (LPSTR)GlobalLock(hText);

	assert(psz);

	cbWritten = wvsprintf( psz + iText, szFormat, ap);

	iText += cbWritten;

	va_end(ap);

	SetWindowText(vApp.m_hwndEdit, psz);

	GlobalUnlock(hText);


	return cbWritten;

}

//+-------------------------------------------------------------------------
//
//  Function: 	SaveToFile
//
//  Synopsis: 	Gets a filename from the user and save the text buffer into it
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//		24-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void SaveToFile( void )
{
	char 		szFileName[MAX_PATH];
	OPENFILENAME	ofn;
	static char *	szFilter[] = { "Log Files (*.log)", "*.log",
				"All Files (*.*)", "*.*", ""};
	FILE *		fp;
	LPSTR		psz;


	memset(&ofn, 0, sizeof(OPENFILENAME));
	
	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = vApp.m_hwndMain;
	ofn.lpstrFilter = szFilter[0];
	ofn.nFilterIndex = 0;
	
	szFileName[0] = '\0';
	
	ofn.lpstrFile = szFileName;
	ofn.nMaxFile = MAX_PATH;
	
	ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
	
	//
	// Get the file
	//
	
	if (GetSaveFileName(&ofn) == FALSE)
	{
		// user hit cancel
	       return;
	}

	// the 'b' specifies binary mode, so \n --> \r\n translations are
	// not done.
	if( !(fp = fopen( szFileName, "wb")) )
	{
		MessageBox( NULL, "Can't open file!", "OleTest Driver",
			MB_ICONEXCLAMATION );
		return;
	}

	psz = (LPSTR)GlobalLock(hText);

	assert(psz);

	fwrite(psz, iText, sizeof(char), fp);

	fclose(fp);

	GlobalUnlock(hText);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\letests.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       letests.cpp
//
//  Contents:   upper layer tests
//
//  Classes:
//
//  Functions:  LETest1
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "letest.h"

// Test1 information
SLETestInfo letiInsertObjectTest1 = { "simpdnd", WM_TEST1 };

SLETestInfo letiInplaceTest1 = { "simpcntr", WM_TEST1 };
SLETestInfo letiOle1Test1 = { "simpdnd", WM_TEST2 };

// Test2 information
SLETestInfo letiInsertObjectTest2 = { "spdnd16", WM_TEST1 };

SLETestInfo letiOle1Test2 = { "spdnd16", WM_TEST2 };



//+-------------------------------------------------------------------------
//
//  Function:   LETestCallback
//
//  Synopsis:   generic callback function for running L&E tests.
//
//  Effects:
//
//  Arguments:  pvArg           -- the test message to send to the app
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Create the process and wait for it to finish.  The exit
//              status is then returned.
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//  Notes:
//
//--------------------------------------------------------------------------

void LETestCallback( void *pvArg )
{
        //the test app (simpdnd) should have just sent us a WM_TESTREG message.

        assert(vApp.m_message == WM_TESTREG);

        vApp.m_rgTesthwnd[0] = (HWND)vApp.m_wparam;

        //now tell the app to start the requested test
        OutputString( "Tell LETest to Start\r\n");

        PostMessage(vApp.m_rgTesthwnd[0], (UINT)pvArg, 0, 0);

        return;
}

//+-------------------------------------------------------------------------
//
//  Function:   LETest1
//
//  Synopsis:   Runs the app specified in the argument
//
//  Effects:
//
//  Arguments:  pvArg           -- unused
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Create the process and wait for it to finish.  The exit
//              status is then returned.
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//  Notes:
//
//--------------------------------------------------------------------------

void LETest1( void *pvArg )
{
        SLETestInfo *pleti = (SLETestInfo *) pvArg;

#ifdef WIN32

        PROCESS_INFORMATION     procinfo;
        static STARTUPINFO      startinfo;      //to make it all zero
        char szBuf[128];

        //initialize the command line

        sprintf(szBuf, "%s%s -driver %lu",
                       vApp.m_pszDebuggerOption,
                       pleti->pszPgm,
                       vApp.m_hwndMain);

        startinfo.cb = sizeof(startinfo);

        if( CreateProcess(NULL, szBuf, NULL, NULL, NULL, NULL, NULL,
                NULL, &startinfo, &procinfo) )
        {
                //simpdnd launched, stuff a callback function in the stack
                vApp.m_TaskStack.Push(LETestCallback,
                        (void *)((ULONG)pleti->dwMsgId));
        }
        else
        {
                vApp.m_wparam = TEST_FAILURE;
                vApp.m_lparam = (LPARAM)GetLastError();
                vApp.m_message = WM_TESTEND;

                HandleTestEnd();
        }

        return;
        
#else
	// 16bit Version!!
	
	vApp.m_wparam = TEST_SUCCESS;
	vApp.m_lparam = 0;
	vApp.m_message = WM_TESTEND;
	
	HandleTestEnd();
	
	return;
	
#endif // WIN32

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\oletest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       oletest.cpp
//
//  Contents:   WinMain and the main message filter for oletest
//
//  Classes:
//
//  Functions:  WinMain
//              InitApplication
//              InitInstance
//              MainWndProc
//
//
//  History:    dd-mmm-yy Author    Comment
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "appwin.h"

#define MAX_WM_USER 0x7FFF

// Global instance of the app class.  All interesting app-wide
// data is contained within this instance.

OleTestApp vApp;


// Constant used to identify the edit window

static const int EDITID=1;

//
// Misc internal prototypes
//

void ListAllTests();
void PrintHelp();


//+-------------------------------------------------------------------------
//
//  Function:   MainWndProc
//
//  Synopsis:   main window message filter
//
//  Effects:
//
//  Arguments:  hWnd
//              message
//              wParam
//              lParam
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              09-Dec-94 MikeW     Allow running of single tests from menu
//              22-Mar-94 alexgo    added an edit window for displaying text
//                                  output.
//              07-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef WIN32
LONG APIENTRY MainWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam)
#else
LONG FAR PASCAL _export MainWndProc(HWND hWnd, UINT message, WPARAM wParam,
                LPARAM lParam)
#endif

{
        //set global variables

        if( (message > WM_USER) && (message <= MAX_WM_USER) )
        {
                vApp.m_message  = message;
                vApp.m_wparam   = wParam;
                vApp.m_lparam   = lParam;
        }

        switch (message)
        {
        case WM_CREATE:
                //create the edit window

                vApp.m_hwndEdit = CreateWindow( "edit", NULL,
                        WS_CHILD | WS_VISIBLE | WS_HSCROLL |
                        WS_VSCROLL | WS_BORDER | ES_LEFT |
                        ES_MULTILINE | ES_NOHIDESEL | ES_AUTOHSCROLL |
                        ES_AUTOVSCROLL | ES_READONLY | ES_WANTRETURN,
                        0,0,0,0,
                        hWnd,(HMENU) EDITID, vApp.m_hinst, NULL );

                // Reset the error status

                vApp.m_fGotErrors = FALSE;

                // start the task stack running
                // note that if we are running interactive, and no
                // tasks were specified on the command line, nothing
                // will happen.

                PostMessage(hWnd, WM_TESTSTART, 0,0);
                break;

        case WM_SETFOCUS:
                SetFocus(vApp.m_hwndEdit);
                break;

        case WM_SIZE:
                MoveWindow( vApp.m_hwndEdit, 0, 0, LOWORD(lParam),
                        HIWORD(lParam), TRUE);
                break;

        case WM_DESTROY:
                PostQuitMessage(0);
                break;
        case WM_TESTEND:
                HandleTestEnd();
                break;
        case WM_TESTSCOMPLETED:
                HandleTestsCompleted();
                //if we are not in interactive mode, then
                //quit the app.
                if (!vApp.m_fInteractive)
                {
                        PostQuitMessage(0);
                }
                else
                {
                        //cleanup
                        vApp.Reset();
                }
                break;

        case WM_COMMAND:
                switch( wParam )
                {
                case IDM_EXIT:
                        SendMessage(hWnd, WM_CLOSE, 0, 0L);
                        break;
                case IDM_COPY:
                        SendMessage(vApp.m_hwndEdit, WM_COPY, 0, 0L);
                        break;
                case IDM_SAVE:
                        SaveToFile();
                        break;
                }

                //
                // if the user picked a test, run it
                // > 100 tests wouldn't fit on the menu anyway
                //

                if (wParam >= IDM_RUN_BASE && wParam < IDM_RUN_BASE + 100)
                {
                    vApp.m_TaskStack.Push(&vrgTaskList[wParam - IDM_RUN_BASE]);
                    vApp.m_TaskStack.PopAndExecute(NULL);
                }

                break;

        default:
                //test to see if it's a message the driver
                //may understand

                if( (message > WM_USER) && (message <= MAX_WM_USER)
                        && (!vApp.m_TaskStack.IsEmpty()) )
                {
                        vApp.m_TaskStack.PopAndExecute(NULL);
                }
                else
                {
                        return DefWindowProc(hWnd, message, wParam,
                                lParam);
                }
                break;
        }
        return (0);
}

//+-------------------------------------------------------------------------
//
//  Function:   InitApplication
//
//  Synopsis:   initializes and registers the application class
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-93 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS  wc;

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(hInstance, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  "OleTestMenu";
    wc.lpszClassName = "OleTestWClass";

    return (RegisterClass(&wc));
}

//+-------------------------------------------------------------------------
//
//  Function:   InitInstance
//
//  Synopsis:   creates the app window
//
//  Effects:
//
//  Arguments:  hInstance
//              nCmdShow
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//              09-Dec-94 MikeW     add tests to the run menu
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL InitInstance(
    HINSTANCE          hInstance,
    UINT             nCmdShow)
{
    int         nTask;
    HMENU       hMenu;

    vApp.m_hinst = hInstance;

    vApp.m_hwndMain = CreateWindow(
        "OleTestWClass",
        "OleTest Driver",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (!vApp.m_hwndMain)
        return (FALSE);

    hMenu = GetSubMenu(GetMenu(vApp.m_hwndMain), 2);
    if (!hMenu)
        return (FALSE);

    //
    // Add all of the tests to the "Run" menu
    //

    for (nTask = 0; vrgTaskList[nTask].szName != (LPSTR) 0; nTask++)
    {
        AppendMenu(hMenu,
                MF_STRING,
                IDM_RUN_BASE + nTask,
                vrgTaskList[nTask].szName);
    }

    ShowWindow(vApp.m_hwndMain, nCmdShow);
    UpdateWindow(vApp.m_hwndMain);
    return (TRUE);
}


//+-------------------------------------------------------------------------
//
//  Table:      regConfig
//
//  Synopsis:   Table of registry settings required to run OleTest.
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-94 KentCe    Created.
//
//  Notes:      The registry template contains embedded "%s" to permit
//              the insertion of the full path of test binaries when the
//              registry is updated.
//
//              The registry template is passed to wsprintf as an argument
//              so verify that changes are wsprintf safe (ie, use %% when
//              you want a single %, etc).
//
//--------------------------------------------------------------------------

char * regConfig[] =
{
    ".ut1", "ProgID49",
    ".ut2", "ProgID48",
    ".ut3", "ProgID47",
    ".ut4", "ProgID50",
    "ProgID49", "test app 1",
    "ProgID49\\CLSID", "{99999999-0000-0008-C000-000000000049}",
    "ProgID48", "test app 2",
    "ProgID48\\CLSID", "{99999999-0000-0008-C000-000000000048}",
    "ProgID47", "test app 3",
    "ProgID47\\CLSID", "{99999999-0000-0008-C000-000000000047}",
    "ProgID50", "test app 4",
    "ProgID50\\CLSID", "{99999999-0000-0008-C000-000000000050}",
    "CLSID\\{00000009-0000-0008-C000-000000000047}", "BasicSrv",
    "CLSID\\{00000009-0000-0008-C000-000000000047}\\LocalServer32", "%s\\testsrv.exe",
    "CLSID\\{00000009-0000-0008-C000-000000000048}", "BasicBnd2",
    "CLSID\\{00000009-0000-0008-C000-000000000048}\\LocalServer32", "%s\\olesrv.exe",
    "CLSID\\{00000009-0000-0008-C000-000000000049}", "BasicBnd",
    "CLSID\\{00000009-0000-0008-C000-000000000049}\\InprocServer32", "%s\\oleimpl.dll",
    "CLSID\\{99999999-0000-0008-C000-000000000048}", "BasicBnd2",
    "CLSID\\{99999999-0000-0008-C000-000000000048}\\LocalServer32", "%s\\olesrv.exe",
    "CLSID\\{99999999-0000-0008-C000-000000000049}", "BasicBnd",
    "CLSID\\{99999999-0000-0008-C000-000000000049}\\InprocServer32", "%s\\oleimpl.dll",
    "CLSID\\{99999999-0000-0008-C000-000000000047}", "TestEmbed",
    "CLSID\\{99999999-0000-0008-C000-000000000047}\\InprocHandler32", "ole32.dll",
    "CLSID\\{99999999-0000-0008-C000-000000000047}\\InprocServer32", "ole32.dll",
    "CLSID\\{99999999-0000-0008-C000-000000000047}\\LocalServer32", "%s\\testsrv.exe",
    "CLSID\\{99999999-0000-0008-C000-000000000047}\\protocol\\StdFileEditing", "",
    "CLSID\\{99999999-0000-0008-C000-000000000047}\\protocol\\StdFileEditing\\server", "testsrv.exe",
    "CLSID\\{99999999-0000-0008-C000-000000000050}", "TestFail",
    "CLSID\\{99999999-0000-0008-C000-000000000050}\\LocalServer32", "%s\\fail.exe",
    "SIMPSVR", "Simple OLE 2.0 Server",
    "SIMPSVR\\protocol\\StdFileEditing\\server", "simpsvr.exe",
    "SIMPSVR\\protocol\\StdFileEditing\\verb\\0", "&Edit",
    "SIMPSVR\\protocol\\StdFileEditing\\verb\\1", "&Open",
    "SIMPSVR\\Insertable", "",
    "SIMPSVR\\CLSID", "{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}", "Simple OLE 2.0 Server",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\Insertable", "",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\MiscStatus", "0",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\DefaultIcon", "simpsvr.exe,0",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\AuxUserType\\2", "Simple Server",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\AuxUserType\\3", "Simple OLE 2.0 Server",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\Verb\\0", "&Play,0,2",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\Verb\\1", "&Open,0,2",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\LocalServer32", "%s\\simpsvr.exe",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\InprocHandler32", "ole32.dll",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\ProgID", "SIMPSVR",
    "CLSID\\{BCF6D4A0-BE8C-1068-B6D4-00DD010C0509}\\DataFormats\\GetSet\\0", "3,1,32,1",
    ".svr", "SIMPSVR",
    "SPSVR16", "Simple 16 Bit OLE 2.0 Server",
    "SPSVR16\\protocol\\StdFileEditing\\server", "spsvr16.exe",
    "SPSVR16\\protocol\\StdFileEditing\\verb\\0", "&Edit",
    "SPSVR16\\protocol\\StdFileEditing\\verb\\1", "&Open",
    "SPSVR16\\Insertable", "",
    "SPSVR16\\CLSID", "{9fb878d0-6f88-101b-bc65-00000b65c7a6}",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}", "Simple 16 Bit OLE 2.0 Server",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\Insertable", "",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\MiscStatus", "0",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\DefaultIcon", "spsvr16.exe,0",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\AuxUserType\\2", "Simple Server",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\AuxUserType\\3", "Simple 16 Bit OLE 2.0 Server",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\Verb\\0", "&Play,0,2",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\Verb\\1", "&Open,0,2",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\LocalServer", "%s\\spsvr16.exe",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\InprocHandler", "ole2.dll",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\ProgID", "SPSVR16",
    "CLSID\\{9fb878d0-6f88-101b-bc65-00000b65c7a6}\\DataFormats\\GetSet\\0", "3,1,32,1",
    ".svr", "SPSVR16",
    "OLEOutline", "Ole 2.0 In-Place Server Outline",
    "OLEOutline\\CLSID", "{00000402-0000-0000-C000-000000000046}",
    "OLEOutline\\CurVer", "OLE2ISvrOtl",
    "OLEOutline\\CurVer\\Insertable", "",
    "OLE2SvrOutl", "Ole 2.0 Server Sample Outline",
    "OLE2SvrOutl\\CLSID", "{00000400-0000-0000-C000-000000000046}",
    "OLE2SvrOutl\\Insertable", "",
    "OLE2SvrOutl\\protocol\\StdFileEditing\\verb\\0", "&Edit",
    "OLE2SvrOutl\\protocol\\StdFileEditing\\server", "svroutl.exe",
    "OLE2SvrOutl\\Shell\\Print\\Command", "svroutl.exe %%1",
    "OLE2SvrOutl\\Shell\\Open\\Command", "svroutl.exe %%1",
    "CLSID\\{00000400-0000-0000-C000-000000000046}", "Ole 2.0 Server Sample Outline",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\ProgID", "OLE2SvrOutl",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\InprocHandler32", "ole32.dll",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\LocalServer32", "%s\\svroutl.exe",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\Verb\\0", "&Edit,0,2",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\Insertable", "",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\AuxUserType\\2", "Outline",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\AuxUserType\\3", "Ole 2.0 Outline Server",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\DefaultIcon", "svroutl.exe,0",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\DataFormats\\DefaultFile", "Outline",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\0", "Outline,1,1,3",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\1", "1,1,1,3",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\2", "3,1,32,1",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\3", "3,4,32,1",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\MiscStatus", "512",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\Conversion\\Readable\\Main", "Outline",
    "CLSID\\{00000400-0000-0000-C000-000000000046}\\Conversion\\Readwritable\\Main", "Outline",
    "OLE2CntrOutl", "Ole 2.0 Container Sample Outline",
    "OLE2CntrOutl\\Clsid", "{00000401-0000-0000-C000-000000000046}",
    "OLE2CntrOutl\\Shell\\Print\\Command", "cntroutl.exe %%1",
    "OLE2CntrOutl\\Shell\\Open\\Command", "cntroutl.exe %%1",
    "CLSID\\{00000401-0000-0000-C000-000000000046}", "Ole 2.0 Container Sample Outline",
    "CLSID\\{00000401-0000-0000-C000-000000000046}\\ProgID", "OLE2CntrOutl",
    "CLSID\\{00000401-0000-0000-C000-000000000046}\\InprocHandler32", "ole32.dll",
    "CLSID\\{00000401-0000-0000-C000-000000000046}\\LocalServer32", "%s\\cntroutl.exe",
    "OLE2ISvrOtl", "Ole 2.0 In-Place Server Outline",
    "OLE2ISvrOtl\\CLSID", "{00000402-0000-0000-C000-000000000046}",
    "OLE2ISvrOtl\\Insertable", "",
    "OLE2ISvrOtl\\protocol\\StdFileEditing\\verb\\1", "&Open",
    "OLE2ISvrOtl\\protocol\\StdFileEditing\\verb\\0", "&Edit",
    "OLE2ISvrOtl\\protocol\\StdFileEditing\\server", "isvrotl.exe",
    "OLE2ISvrOtl\\Shell\\Print\\Command", "isvrotl.exe %%1",
    "OLE2ISvrOtl\\Shell\\Open\\Command", "isvrotl.exe %%1",
    "CLSID\\{00000402-0000-0000-C000-000000000046}", "Ole 2.0 In-Place Server Outline",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\ProgID", "OLE2ISvrOtl",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\ProgID", "OLE2ISvrOtl",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\InprocHandler32", "ole32.dll",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\LocalServer32", "%s\\isvrotl.exe",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\Verb\\1", "&Open,0,2",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\Verb\\0", "&Edit,0,2",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\Insertable", "",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\AuxUserType\\2", "Outline",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\AuxUserType\\3", "Ole 2.0 In-Place Outline Server",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DefaultIcon", "isvrotl.exe,0",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\DefaultFile", "Outline",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\0", "Outline,1,1,3",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\1", "1,1,1,3",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\2", "3,1,32,1",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\DataFormats\\GetSet\\3", "3,4,32,1",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\MiscStatus", "512",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\MiscStatus\\1", "896",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\Conversion\\Readable\\Main", "Outline",
    "CLSID\\{00000402-0000-0000-C000-000000000046}\\Conversion\\Readwritable\\Main", "Outline",
    "OLE2ICtrOtl", "Ole 2.0 In-Place Container Outline",
    "OLE2ICtrOtl\\Clsid", "{00000403-0000-0000-C000-000000000046}",
    "OLE2ICtrOtl\\Shell\\Print\\Command", "icntrotl.exe %%1",
    "OLE2ICtrOtl\\Shell\\Open\\Command", "icntrotl.exe %%1",
    ".olc", "OLE2ICtrOtl",
    "CLSID\\{00000403-0000-0000-C000-000000000046}", "Ole 2.0 In-Place Container Outline",
    "CLSID\\{00000403-0000-0000-C000-000000000046}\\ProgID", "OLE2ICtrOtl",
    "CLSID\\{00000403-0000-0000-C000-000000000046}\\InprocHandler32", "ole32.dll",
    "CLSID\\{00000403-0000-0000-C000-000000000046}\\LocalServer32", "%s\\icntrotl.exe",
    NULL
};


//+-------------------------------------------------------------------------
//
//  Function:   InitializeRegistry
//
//  Synopsis:   Initialize the registry for oletest.
//
//  Effects:
//
//  Arguments:  None.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              08-Nov-94 KentCe    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void InitializeRegistry( void )
{
    char szBuf[MAX_PATH * 2];
    char szPath[MAX_PATH];
    int  i;


    //
    //  Assume all the oletest components are in the current directory.
    //
    if (!GetCurrentDirectory(sizeof(szPath), szPath))
    {
        assert(0);
    }

    //
    //  Loop thru string key/value pairs and update the registry.
    //
    for (i = 0; regConfig[i] != NULL; i += 2)
    {
        //
        //  The registry template contains embedded "%s" to permit
        //  the insertion of the full path of test binaries.
        //
        wsprintf(szBuf, regConfig[i+1], szPath);

        if (RegSetValue(HKEY_CLASSES_ROOT, regConfig[i+0], REG_SZ,
                szBuf, strlen(szBuf)) != ERROR_SUCCESS)
        {
            assert(0);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   TestSetup
//
//  Synopsis:   process the command line and setup the tests that need to
//              be run.
//
//  Effects:
//
//  Arguments:  lpszCmdLine
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  We scan the command line for the following information
//
//              NULL or empty cmdline, assume running task 0
//                      (usually run all tasks)
//              otherwise scan for n numbers, adding each to the end of
//                      the stack (so the tasks are run in order).
//
//  History:    dd-mmm-yy Author    Comment
//              12-Dec-94 MikeW     restructured parse algorithm, added -? & l
//              07-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TestSetup( LPSTR lpszCmdLine )
{
    LPSTR   pszArg;
    int     nTest, cTests;

    // initialize debugger options to nothing.

    vApp.m_pszDebuggerOption = "";

    //
    // count up the number of tests available
    //

    for (cTests = 0; vrgTaskList[cTests].szName != (LPSTR) 0; cTests++)
    {
        ;
    }

    //
    // make sure the registery is set up correctly.
    //

    InitializeRegistry();

    //
    // if the command line is empty, run all tests
    // (assumed to be task 0)
    //

    pszArg = strtok(lpszCmdLine, " ");

    if (NULL == pszArg)
    {
        vApp.m_TaskStack.Push(&vrgTaskList[0]);
        vApp.m_fInteractive = FALSE;
    }

    //
    // otherwise, look for options & test numbers
    //

    while (NULL != pszArg)
    {
        if ('-' == *pszArg)
        {
            while ('\0' != *(++pszArg))     // it's an option
            {
                switch (*pszArg)
                {
                case 'r':       // 'r' flag is obsolete
                    break;

		case 'R':
                    OutputString("Warning: 'R' flag to oletest is obsolete.\n");
                    vApp.m_fInteractive = FALSE;
                    vApp.m_TaskStack.Push(&vrgTaskList[0]);
                    break;

                case 'i':                           // run in interactive mode
                    vApp.m_fInteractive = TRUE;
                    break;

                case 'n':                           // start apps in debugger
                    vApp.m_fInteractive = TRUE;
                    vApp.m_pszDebuggerOption = "ntsd ";
                    break;

                case 'l':                           // list tests & test nums
                    ListAllTests();
                    vApp.m_fInteractive = TRUE;
                    break;

                case '?':                           // output the option list
                    PrintHelp();
                    vApp.m_fInteractive = TRUE;
                    break;
                }
            }
        }
        else    // it's not a option, maybe it's a test number
        {
            if (isdigit(*pszArg))
            {
                nTest = atoi(pszArg);

                if (nTest < 0 || nTest > cTests - 1)
                {
                    OutputString("Ignoring invalid test #%d", nTest);
                }
                else
                {
                    vApp.m_TaskStack.AddToEnd(&vrgTaskList[nTest]);
                }
            }
        }

        pszArg = strtok(NULL, " ");     // fetch the next argument
    }

    vApp.m_fpLog = fopen("clip.log", "w+");
    assert(vApp.m_fpLog);
}


//+-------------------------------------------------------------------------
//
//  Function:   ListAllTests
//
//  Synopsis:   List all available tests and the corresponding test number
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Iterate through vrgTaskList
//
//  History:    dd-mmm-yy Author    Comment
//              12-Dec-94 MikeW     author
//
//  Notes:
//
//--------------------------------------------------------------------------

void ListAllTests()
{
    int     nTask;

    for (nTask = 0; vrgTaskList[nTask].szName != (LPSTR) 0; nTask++)
    {
        OutputString("%2d -- %s\r\n", nTask, vrgTaskList[nTask].szName);
    }

    OutputString("\r\n");
}


//+-------------------------------------------------------------------------
//
//  Function:   PrintHelp
//
//  Synopsis:   Print the program options & tests
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Dec-94 MikeW     author
//
//  Notes:
//
//--------------------------------------------------------------------------

void PrintHelp()
{
    OutputString("OleTest [options] [test numbers] -\r\n");
    OutputString("\r\n");
    OutputString("    -r  -  Autoregister test apps\r\n");
    OutputString("    -R  -  Autoregister and Run All Tests\r\n");
    OutputString("    -i  -  Run in interactive mode\r\n");
    OutputString("    -n  -  Run test apps using ntsd and run interactive\r\n");
    OutputString("    -l  -  List tests & test numbers and run interactive\r\n");
    OutputString("    -?  -  Print this help\r\n");
    OutputString("\r\n");

    ListAllTests();
}


//+-------------------------------------------------------------------------
//
//  Function:   WinMain
//
//  Synopsis:   main window procedure
//
//  Effects:
//
//  Arguments:  hInstance
//              hPrevInstance
//              lpCmdLine
//              nCmdShow
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
#ifdef WIN32
int APIENTRY WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow)
#else
int PASCAL WinMain(
        HANDLE hInstance,
        HANDLE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow)
#endif

{
        MSG             msg;

        if (!hPrevInstance)
        {
                if (!InitApplication(hInstance))
                {
                        return FALSE;
                }
        }

        if (!InitInstance(hInstance, nCmdShow))
        {
                return FALSE;
        }

        TestSetup(lpCmdLine);

        OleInitialize(NULL);

        while (GetMessage(&msg, NULL, 0, 0))
        {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
        }

        OleUninitialize();

        fclose(vApp.m_fpLog);
        return (msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\stack.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	stack.cpp	
//
//  Contents: 	Implementation of the TaskStack
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//    		06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::TaskStack
//
//  Synopsis: 	Constructor
//
//  Arguments: 	
//
//  Returns:	void
//
//  History:    dd-mmm-yy Author    Comment
// 		06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

TaskStack::TaskStack( void )
{
	m_pNodes	= NULL;
}

//+-------------------------------------------------------------------------
//
//  Member:	TaskStack::AddToEnd
//
//  Synopsis: 	adds a function and it's argument to the bottom of the stack
//
//  Effects:
//
//  Arguments:	ti	-- the task item to add to the end of the stack
//
//  Requires:
//
//  Returns:	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//    		06-Feb-94 alexgo    author
//
//  Notes:	The task item is copied into the stack.
//
//--------------------------------------------------------------------------

void TaskStack::AddToEnd( const TaskItem *pti )
{
	TaskNode **ppNode;
	TaskNode *pNode = new TaskNode;

	assert(pNode);

	pNode->ti = *pti;
	pNode->pNext = NULL;

	for( ppNode = &m_pNodes; *ppNode != NULL;
		ppNode = &(*ppNode)->pNext)
	{
		;
	}
	
	*ppNode = pNode;

	return;
}

//+-------------------------------------------------------------------------
//
//  Member:	TaskStack::AddToEnd
//
//  Synopsis: 	adds a function and it's argument to the bottom of the stack
//
//  Effects:
//
//  Arguments:	fnCall		-- the function to call
//		pvArg		-- the closure argument for the function
//
//  Requires:
//
//  Returns:	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//    		06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::AddToEnd( void (*fnCall)(void *), void *pvArg)
{
	TaskItem ti	= vzTaskItem; 	//clear it to zero

	ti.fnCall 	= fnCall;
	ti.pvArg 	= pvArg;

	AddToEnd(&ti);
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::Empty
//
//  Synopsis:	Empties the stack, ignoring the function call
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	NULL
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::Empty( void )
{
	while( m_pNodes )
	{
		Pop(NULL);
	}
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::IsEmpty
//
//  Synopsis:	returns TRUE if the stack is empty, false otherwise
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	TRUE/FALSE
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL TaskStack::IsEmpty(void)
{
	if( m_pNodes )
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::Pop
//
//  Synopsis:	Pops the stack, ignoring the function call
//
//  Effects:
//
//  Arguments: 	void
//
//  Requires:
//
//  Returns: 	the task item that was popped.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::Pop( TaskItem *pti )
{
	TaskNode *pTemp;

	if( m_pNodes )
	{
		if( pti )
		{
			*pti = m_pNodes->ti;
		}
		pTemp = m_pNodes;
		m_pNodes = m_pNodes->pNext;

		//now free the memory
		delete pTemp;
	}

	return;
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::PopAndExecute
//
//  Synopsis: 	pops the stack and executes the function call
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	the task item that was popped.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  Pop the stack and then execute the function call
//		in the just removed stack node.
//
//  History:    dd-mmm-yy Author    Comment
//	 	06-Feb-94 alexgo    author
//              09-Dec-94 MikeW     Added exception handling
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::PopAndExecute( TaskItem *pti )
{
	TaskItem ti;

	if( pti == NULL )
	{
		pti = &ti;
	}

	Pop(pti);

 	//if there's a function to execute, do it.
	//if the stack is empty, Pop will return a zero-filled TaskItem

	if( pti->fnCall )
	{
		if( pti->szName )
		{
			OutputString("Starting: %s\r\n", pti->szName);
		}
		//call the function

        __try
        {            
		    (*pti->fnCall)(pti->pvArg);
        }
        __except ((GetExceptionCode() == E_ABORT) 
                ? EXCEPTION_EXECUTE_HANDLER 
                : EXCEPTION_CONTINUE_SEARCH)
        {
            //
            // there was an assertion and the user hit abort
            //

            PostMessage(vApp.m_hwndMain, WM_TESTEND, TEST_FAILURE, 0);
        }
	}

	return;
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::Push
//
//  Synopsis:	pushes a function onto the stack
//
//  Effects:
//
//  Arguments:	ti	-- the task item to push onto the stack
//
//  Requires:
//
//  Returns:  	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::Push( const TaskItem *pti )
{
	TaskNode *pNode = new TaskNode;

	assert(pNode);

	pNode->ti = *pti;
	pNode->pNext = m_pNodes;
	m_pNodes = pNode;

	return;
}

//+-------------------------------------------------------------------------
//
//  Member: 	TaskStack::Push
//
//  Synopsis:	pushes a function onto the stack
//
//  Effects:
//
//  Arguments:	fnCall		-- the function to call
//		pvArg		-- the closure argument for the function
//
//  Requires:
//
//  Returns:  	void
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	    	06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void TaskStack::Push( void (*fnCall)(void *), void * pvArg)
{
	TaskItem ti = vzTaskItem;

	ti.fnCall = fnCall;
	ti.pvArg = pvArg;

	Push(&ti);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\stack.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	stack.h
//
//  Contents:	The class declaration of the task stack.
//
//  Classes: 	TaskStack
//
//  History:    dd-mmm-yy Author    Comment
//		06-Feb-93 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _STACK_H
#define _STACK_H

typedef struct TaskNode
{
	TaskItem ti;
	struct TaskNode *pNext;
} TaskNode;

//+-------------------------------------------------------------------------
//
//  Class:	TaskStack
//
//  Purpose: 	Stores the task list of tests to be run.
//
//  History:    dd-mmm-yy Author    Comment
// 		06-Feb-93 alexgo    author
//
//  Notes:	TaskItems are passed in and returned from methods
//		as structure copies.  This is done to simply memory
//		management (since the overriding design goal of the
//		driver app is simplicity over efficiency).
//
//--------------------------------------------------------------------------

class TaskStack
{
public:
	TaskStack( void );	//constructor

 	void AddToEnd( void (*)(void *), void *);
	void AddToEnd( const TaskItem *);
	void Empty(void);
	BOOL IsEmpty(void);
	void Pop( TaskItem * );
	void PopAndExecute( TaskItem * );
	void Push( void (*)(void *), void *);
	void Push( const TaskItem *);


private:
	TaskNode	*m_pNodes;
};

#endif	//!_STACK_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf\idl\makefile.inc ===
CPP_CMD=cl

!if $(386)
CPP_CMD=cl386
!endif

!if $(ALPHA)
CPP_CMD=$(ALPHA_CC)
!endif

iperf.h: iperf.idl
      midl iperf.idl               \
          -Zp8                     \
          -I$(INCLUDES)            \
          -ms_ext		   \
          -c_ext		   \
          -out ..\proxy		   \
          -header ..\idl\iperf.h   \
          -iid ..\perfuuid\iperf_i.c   \
          $(C_DEFINES)             \
	  -cpp_cmd $(CPP_CMD)	   \
          -cpp_opt "-nologo -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES) -E -Tc"

#
# This target compiles all .idl files into their corresponding _?.c?? and
# .h components
#
allidl:   iperf.h


clean:
          erase iperf.h  >NUL 2>NUL

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\utils.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	utils.h
//
//  Contents:	declarations for utility functions
//
//  Classes:
//
//  Functions:	DumpFormatetc
//
//  History:    dd-mmm-yy Author    Comment
// 		11-Aug-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _UTILS_H

void DumpFormatetc(FORMATETC *pformatetc, FILE *fp);

#endif // _UTILS_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\utils.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	utils.cpp
//
//  Contents: 	various utility functions for oletest
//
//  Classes:
//
//  Functions:	DumpFormatetc
//
//  History:    dd-mmm-yy Author    Comment
//		11-Aug-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "oletest.h"


//+-------------------------------------------------------------------------
//
//  Function: 	DumpFormatetc
//
//  Synopsis: 	prints the contents of the formatetc to the given file
//
//  Effects:
//
//  Arguments: 	[pformatetc]	-- the formatetc
//		[fp]		-- the file pointer
//
//  Requires:
//
//  Returns:	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		11-Aug-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void DumpFormatetc( FORMATETC *pformatetc, FILE *fp)
{
	char szBuf[256];

	fprintf(fp, "\n\n");

	// clipboard format
	GetClipboardFormatName(pformatetc->cfFormat, szBuf, sizeof(szBuf));
	fprintf(fp, "cfFormat:  %s\n", szBuf);

	// target device
	fprintf(fp, "ptd:       %p\n", pformatetc->ptd);

	// aspect
	if( pformatetc->dwAspect == DVASPECT_CONTENT )
	{
		sprintf(szBuf, "DVASPECT_CONTENT");
	}
	else if( pformatetc->dwAspect == DVASPECT_ICON )
	{
		sprintf(szBuf, "DVASPECT_ICON");
	}
	else if( pformatetc->dwAspect == DVASPECT_THUMBNAIL )
	{
		sprintf(szBuf, "DVASPECT_THUMBNAIL");
	}
	else if( pformatetc->dwAspect == DVASPECT_DOCPRINT )
	{
		sprintf(szBuf, "DVASPECT_DOCPRINT");
	}
	else
	{
		sprintf(szBuf, "UNKNOWN ASPECT");
	}

	fprintf(fp, "dwAspect:  %s\n", szBuf);

	// lindex

	fprintf(fp, "lindex:    %lx\n", pformatetc->lindex);

	// medium

	szBuf[0] = '\0';

	if( pformatetc->tymed & TYMED_HGLOBAL )	
	{
		strcat(szBuf, "TYMED_HGLOBAL ");
	}

	if( pformatetc->tymed & TYMED_FILE )
	{
		strcat(szBuf, "TYMED_FILE");
	}

	if( pformatetc->tymed & TYMED_ISTREAM )
	{
		strcat(szBuf, "TYMED_ISTREAM");
	}

	if( pformatetc->tymed & TYMED_ISTORAGE )
	{
		strcat(szBuf, "TYMED_ISTORAGE");
	}

	if( pformatetc->tymed & TYMED_GDI )
	{
		strcat(szBuf, "TYMED_GDI");
	}

	if( pformatetc->tymed & TYMED_MFPICT )
	{
		strcat(szBuf, "TYMED_MFPICT");
	}

	// TYMED_EMFPICT (not in 16bit)
	if( (ULONG)pformatetc->tymed & (ULONG)64L )
	{
		strcat(szBuf, "TYMED_ENHMF");
	}

	fprintf(fp, "tymed:     %s\n\n", szBuf);
}
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\task.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       task.cpp
//
//  Contents:   The global task list and helper function implementations
//
//  Classes:
//
//  Functions:  HandleTestEnd
//              RunAllTests
//              RunApp
//              RunTestOnThread
//
//  History:    dd-mmm-yy Author    Comment
//              06-Jan-95 t-scotth  added apartment thread test and RunTestOnThread
//              06-Feb-94 alexgo    author
//
//  Notes:
//              Folks adding new tests will need to insert their test
//              into the global array.
//
//--------------------------------------------------------------------------

#include "oletest.h"
#include "cotest.h"
#include "letest.h"
#include "attest.h"

// global, zero'ed task item
TaskItem vzTaskItem;

// the global task list array.
// Multi-test entries go first, followed by individual tests.

#ifdef WIN32

const TaskItem vrgTaskList[] =
{
        // the constant should be the index at which individual tests
        // begin.  RunAllTests will run every test in this list after
        // that index.
        { "Run All Tests", RunAllTests, (void *)2},
        // the constant below should be the index at which individual
        // upper layer unit tests exist.  All tests at that index and
        // beyond will be run
        { "Run All Upper Layer Tests", RunAllTests, (void *)5 },
        { "OleBind", RunApp, (void *)"olebind.exe"},
        { "Threads", RunApi, (void *) ThreadUnitTest },
        { "Storage DRT", RunApp, (void *)"stgdrt.exe"},
        { "LE: Insert Object Test 1", LETest1, &letiInsertObjectTest1 },
        { "LE: Clipboard Test 1", RunApi, (void *)LEClipTest1},
        { "LE: Clipboard Test 2 (clipboard data object)", RunApi,
                (void *)LEClipTest2 },
        { "LE: Inplace Test 1", LETest1, &letiInplaceTest1 },
        { "LE: Data Advise Holder Test", RunApi,
                (void *) LEDataAdviseHolderTest},
        { "LE: OLE Advise Holder Test", RunApi, (void *) LEOleAdviseHolderTest},
	{ "LE: OLE1 Clipboard Test 1", RunApi, (void *)LEOle1ClipTest1},
        { "LE: Insert Object Test 2", LETest1, &letiInsertObjectTest2 },
	{ "LE: OLE1 Clipboard Test 2", LEOle1ClipTest2, NULL },
	{ "LE: OleQueryCreateFromData Test 1", RunApi,
		(void *)TestOleQueryCreateFromDataMFCHack },
        { "LE: Apartment Thread Test", RunTestOnThread, (void *)ATTest },
	{ 0, 0, 0 }
};

#else

// Win16 tests

const TaskItem vrgTaskList[] =
{
        // the constant should be the index at which individual tests
        // begin.  RunAllTests will run every test in this list after
        // that index.
        { "Run All Tests", RunAllTests, (void *)1},	
        { "LE: Clipboard Test 1", RunApi, (void *)LEClipTest1},
        { "LE: Clipboard Test 2 (clipboard data object)", RunApi,
                (void *)LEClipTest2 },
	{ "LE: OLE1 Clipboard Test 1", RunApi, (void *)LEOle1ClipTest1},
	{ 0, 0, 0 }
};

#endif
	


//+-------------------------------------------------------------------------
//
//  Function:   HandleTestEnd
//
//  Synopsis:   Handles processing for the WM_TESTEND message.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  execute the next task in the task stack or sends
//              a TESTSCOMPLETED message back the message queue
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//              13-Dec-94 MikeW     Allow testing to continue after failures
//
//  Notes:      vApp must be initialized correctly for this function to
//              work properly.
//
//              BUGBUG::Need to add output routines in here.
//
//--------------------------------------------------------------------------
void HandleTestEnd( void )
{
        assert(vApp.m_message == WM_TESTEND);

        switch( vApp.m_wparam )
        {
                case TEST_UNKNOWN:
                        //we usually get this message from a test run
                        //by RunApp (i.e. one that does not communicate
                        //with us via windows messages).  We'll check
                        //the exit code and decide what to do.

                        if( vApp.m_lparam != 0 )
                        {
                                //presumably an error
                                OutputString("Test End, Status Unknown "
                                        "( %lx )\r\n\r\n", vApp.m_lparam);

                                vApp.m_fGotErrors = TRUE;
                                break;
                        }
                        // otherwise we fall through to the success case.
                case TEST_SUCCESS:
                        OutputString("Test Success ( %lx )!\r\n\r\n",
                                vApp.m_lparam);
                        break;

                case TEST_FAILURE:
                        OutputString("Test FAILED! ( %lx )\r\n\r\n", vApp.m_lparam);
                        vApp.m_fGotErrors = TRUE;
                        break;

                default:
                        assert(0);      //we should never get here
                        break;
        }

        vApp.Reset();

        //
        // Now check to see if there are any more tests
        //

        while (!vApp.m_TaskStack.IsEmpty())
        {
            TaskItem    ti;

            vApp.m_TaskStack.Pop(&ti);

            if (ti.szName != (LPSTR) 0)
            {
                vApp.m_TaskStack.Push(&ti);
                break;
            }
        }


        if (vApp.m_TaskStack.IsEmpty())
        {
                PostMessage(vApp.m_hwndMain,
                        WM_TESTSCOMPLETED,
                        vApp.m_wparam, vApp.m_lparam);
        }
        else
        {
                //if the stack is not empty, run
                //the next task
                PostMessage(vApp.m_hwndMain,
                        WM_TESTSTART,
                        0, 0);
        }

        return;
}

//+-------------------------------------------------------------------------
//
//  Function:   HandleTestsCompleted
//
//  Synopsis:   Handles processing for the WM_TESTSCOMPLETED message.
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//  Notes:      vApp must be initialized correctly for this function to
//              work properly.
//
//              BUGBUG::Need to add more output routines in here.
//
//--------------------------------------------------------------------------
void HandleTestsCompleted( void )
{
        char szBuf[128];

        assert(vApp.m_message == WM_TESTSCOMPLETED);

        //temporary output

        switch(vApp.m_fGotErrors)
        {
                case FALSE:
                        OutputString("Tests PASSED!!\n");
                        break;
                case TRUE:
                        sprintf(szBuf, "Tests FAILED, code %lx",
                                vApp.m_lparam);
                        MessageBox(vApp.m_hwndMain, szBuf, "Ole Test Driver",
                                MB_ICONEXCLAMATION | MB_OK);
                        break;
                default:
                        assert(0);
        }

        //
        // Reset the got error status
        //

        vApp.m_fGotErrors = FALSE;

        return;
}

//+-------------------------------------------------------------------------
//
//  Function:   RunAllTests
//
//  Synopsis:   Runs all the individual tests in the global list
//
//  Effects:
//
//  Arguments:  pvArg           -- the index at which individual tests
//                                 start in the global list.
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//  Notes:
//              Tests will be run in the order they appear in the global
//              list.
//
//--------------------------------------------------------------------------

void RunAllTests( void *pvArg )
{
        ULONG index = (ULONG)pvArg;
        ULONG i;

        //find the number of tasks in the list (so we can push
        //them in reverse order).

        for (i = 0; vrgTaskList[i].szName != 0; i++ )
        {
                ;
        }

        assert( i > 1 );

        //now push the tasks onto the stack in reverse order.

        for (i--; i >= index; i-- )
        {
                vApp.m_TaskStack.Push(vrgTaskList + i);
        }

        //start the first one.

        vApp.m_TaskStack.PopAndExecute(NULL);

        return;
}

//+-------------------------------------------------------------------------
//
//  Function:   RunApi
//
//  Synopsis:   Runs the specified Api
//
//  Effects:
//
//  Arguments:  [pvArg] -- the api to run
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              23-Mar-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void RunApi( void *pvArg )
{
        HRESULT         hresult;


        hresult = (*((HRESULT (*)(void))pvArg))();

        vApp.Reset();
        vApp.m_wparam = (hresult == NOERROR) ? TEST_SUCCESS : TEST_FAILURE;
        vApp.m_lparam = (LPARAM)hresult;
        vApp.m_message = WM_TESTEND;

        HandleTestEnd();
}

//+-------------------------------------------------------------------------
//
//  Function:   RunApp
//
//  Synopsis:   Runs the app specified in the argument
//
//  Effects:
//
//  Arguments:  pvArg           -- a string with the app to execute
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Create the process and wait for it to finish.  The exit
//              status is then returned.
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void RunApp( void *pvArg )
{
        WPARAM                  wparam = 0;
        DWORD                   error = 0;

#ifdef WIN32

       	PROCESS_INFORMATION     procinfo;
        static STARTUPINFO      startinfo;      //to make it all zero

        assert(pvArg);  //should be a valid ANSI string.

        startinfo.cb = sizeof(startinfo);

        if( CreateProcess(NULL, (LPTSTR)pvArg, NULL, NULL, NULL, NULL, NULL,
                NULL, &startinfo, &procinfo) )
        {
                //the process started, now wait for it to finish.
                WaitForSingleObject(procinfo.hProcess, INFINITE);

                //now get the return code of the process.

                GetExitCodeProcess(procinfo.hProcess, &error);
                wparam = TEST_UNKNOWN;
        }
        else
        {
                wparam = TEST_FAILURE;
                error = GetLastError();
        }

#endif // WIN32

        // since there will be no WM_TESTEND message, we must do the
        // test end processing ourselves.
        vApp.Reset();
        vApp.m_wparam = wparam;
        vApp.m_lparam = error;
        vApp.m_message = WM_TESTEND;

        HandleTestEnd();


        return;
}

//+-------------------------------------------------------------------------
//
//  Function:   RunTestOnThread
//
//  Synopsis:   creates a thread to run a test function
//
//  Effects:    creates a new thread
//
//  Arguments:  [pvArg] -- a function pointer to the test function
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------
void RunTestOnThread(void *pvArg)
{
    HANDLE      hMainTestThread;
    DWORD       dwThreadId = 0;

    hMainTestThread = CreateThread(
                NULL,                                   // security attributes
                0,                                      // stack size (default)
                (LPTHREAD_START_ROUTINE)pvArg,          // address of thread function
                NULL,                                   // arguments of thread function
                0,                                      // creation flags
                &dwThreadId );                          // address of new thread ID

    assert(hMainTestThread);

    CloseHandle(hMainTestThread);

    return;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf\perfcli\perfcli.cxx ===
//+-------------------------------------------------------------
//
// File:        perfcli.cxx
//
// Contents:    First attempt at getting perfcliing to work
//
// This is the client side
//
//
//---------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>

#include <ole2.h>
#include "iperf.h"
#include "..\perfsrv\perfsrv.hxx"
#include <memalloc.h>

#pragma hdrstop

#define TEST_FILE L"\\tmp\\test"

void QueryMsg( void );

// These are Cairo symbols.  Just define them here so I don't have to rip
// out or conditionally compile all references to them.
#define COINIT_MULTITHREADED  0
#define COINIT_SINGLETHREADED 1

DWORD thread_mode    = COINIT_SINGLETHREADED;
int   num_objects    = 1;
int   num_iterations = 1000;
HANDLE helper_wait;
HANDLE main_wait;

/*************************************************************************/
int DoTest()
{
    IPerf   **perf;
    HRESULT  result;
    DWORD    time_first;
    DWORD    waste;
    int      i;
    int      j;
    BOOL     success;
    LARGE_INTEGER frequency;
    LARGE_INTEGER count_first;
    LARGE_INTEGER count_last;
    LARGE_INTEGER dummy;

    // Allocate memory to hold the object and interface pointers.
    perf = (IPerf **) malloc( sizeof(void *) * num_objects );
    if (perf == NULL)
    {
      printf( "Could not get memory.\n" );
      return 1;
    }

    // Get a test object.
    result = CoCreateInstance( CLSID_IPerf, NULL, CLSCTX_LOCAL_SERVER, IID_IPerf,
                               (void **) &perf[0] );
    if (!SUCCEEDED(result))
    {
      printf( "Could not create instance of performance server: %x\n", result );
      return 1;
    }

    // Create the required number of objects.
    for (i = 1; i < num_objects; i++)
    {
      result = perf[0]->GetAnotherObject( &perf[i] );
      if (!SUCCEEDED(result))
      {
        printf( "Could not get enough objects: 0x%x\n", result );
        return 1;
      }
      perf[i]->NullCall();
    }

    // Prompt to start when the user is ready.
    // printf( "Ready? " );
    // gets( s );

    // Compute the time spent just looping.
    waste = GetTickCount();
    for (i = 0; i < num_iterations; i++)
      ;
    waste = GetTickCount() - waste;

    // Repeatedly call the first object to time it.
    time_first = GetTickCount();
    for (i = 0; i < num_iterations; i++)
      perf[0]->NullCall();
    time_first = GetTickCount() - time_first - waste;

    // Print the results.
    printf( "%d uS/Call\n", time_first*1000/num_iterations );

/*
    // Measure the same thing using the performance counter.
    success = QueryPerformanceFrequency( &frequency );
    if (!success)
    {
      printf( "Could not query performance frequency.\n" );
      goto free;
    }
    success = QueryPerformanceCounter( &count_first );
    if (!success)
    {
      printf( "Could not query performance counter.\n" );
      goto free;
    }
    perf[0]->NullCall();
    success = QueryPerformanceCounter( &count_last );
    if (!success)
    {
      printf( "Could not query performance counter.\n" );
      goto free;
    }
    if (count_last.HighPart != count_first.HighPart ||
        frequency.HighPart != 0)
      printf( "\n\n***** Overflow *****\n\n\n" );
    count_last.LowPart = (count_last.LowPart - count_first.LowPart) * 1000000 /
                         frequency.LowPart;
    printf( "\nFrequency %d\n", frequency.LowPart );
    printf( "%d uS/Call\n", count_last.LowPart );

    // How long does it take to query the performance counter?
    success = QueryPerformanceCounter( &count_first );
    if (!success)
    {
      printf( "Could not query performance counter.\n" );
      goto free;
    }
    for (i = 0; i < num_iterations; i++)
      QueryPerformanceCounter( &dummy );
    success = QueryPerformanceCounter( &count_last );
    if (!success)
    {
      printf( "Could not query performance counter.\n" );
      goto free;
    }
    if (count_last.HighPart != count_first.HighPart ||
        frequency.HighPart != 0)
      printf( "\n\n***** Overflow *****\n\n\n" );
    count_last.LowPart = (count_last.LowPart - count_first.LowPart) /
                         num_iterations * 1000000 / frequency.LowPart;
    printf( "%d uS/Query\n", count_last.LowPart );
*/

    // Prompt to let the user peruse the results.
    // printf( "Done? " );
    // gets( s );

    // Free the objects.
free:
    for (i = 0; i < num_objects; i++)
      perf[i]->Release();
    return 0;
}

/*************************************************************************/
void EventTest()
{
  DWORD    time_first;
  DWORD    waste;
  int      i;
  HANDLE   helper;

  // Measure how long it takes to loop.
  waste = GetTickCount();
  for (i = 0; i < num_iterations; i++)
    ;
  waste = GetTickCount() - waste;

  // Measure how long it takes to get an event
  time_first = GetTickCount();
  for (i = 0; i < num_iterations; i++)
  {
    helper = CreateEvent( NULL, FALSE, FALSE, NULL );
    if (helper == NULL)
    {
      printf( "Could not create event %d.\n", i );
      return;
    }
    CloseHandle( helper );
  }
  time_first = GetTickCount() - time_first - waste;
  printf( "%d uS/CreateEvent\n", time_first*1000/num_iterations );

  // Don't bother cleaning up.
}

/*************************************************************************/
/* Parse the arguments. */
BOOL parse( int argc, char *argv[] )
{
  int i;
  int len;
  TCHAR buffer[80];

#if 0
  // Look up the thread mode from the win.ini file.
  len = GetProfileString( L"My Section", L"ThreadMode", L"MultiThreaded", buffer,
                          sizeof(buffer) );
  if (lstrcmp(buffer, L"SingleThreaded") == 0)
    thread_mode = COINIT_SINGLETHREADED;
  else if (lstrcmp(buffer, L"MultiThreaded") == 0)
    thread_mode = COINIT_MULTITHREADED;
#endif

  // Parse each item, skip the command name
  for (i = 1; i < argc; i++)
  {
    if (strcmp( argv[i], "Single" ) == 0)
      thread_mode = COINIT_SINGLETHREADED;
    else if (strcmp( argv[i], "Multi" ) == 0)
      thread_mode = COINIT_MULTITHREADED;
    else if (strcmp( argv[i], "-o" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include an object count after the -o option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &num_objects );
    }
    else if (strcmp( argv[i], "-i" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include an object count after the -i option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &num_iterations );
    }
    else
    {
      printf( "You don't know what you are doing!\n" );
    }
  }

  return TRUE;
}

/*************************************************************************/
void MarshalTest()
{
  HANDLE    file;
  HRESULT   result;
  IMoniker *moniker;
  IBindCtx *bindctx;
  WCHAR    *wide_name;
  unsigned char *name;
  int            i;
  IPerf         *perf;

  // Initialize OLE.
  result = OleInitialize(NULL);
  if (FAILED(result))
  {
    printf( "Could not initialize OLE: 0x%x\n", result );
    return;
  }

  // Create file.
  file = CreateFile( TEST_FILE, 0, 0, NULL, CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL, NULL );
  if (file == INVALID_HANDLE_VALUE)
  {
    printf( "Could not create file." );
    return;
  }

  // Create file moniker.
  result = CreateFileMoniker( TEST_FILE, &moniker );
  if (FAILED(result))
  {
    printf( "Could not create file moniker: 0x%x\n", result );
    return;
  }

  // Get a bind context.
  result = CreateBindCtx( NULL, &bindctx );
  if (FAILED(result))
  {
    printf( "Could not create bind context: 0x%x\n", result );
    return;
  }

  // Display name.
  result = moniker->GetDisplayName( bindctx, NULL, &wide_name );
  if (FAILED(result))
  {
    printf( "Could not get display name: 0x%x\n", result );
    return;
  }

  // Convert the string to ascii and print it.
  name = (unsigned char *) wide_name;
  i = 0;
  while (wide_name[i] != 0)
    name[i] = wide_name[i++];
  name[i] = 0;
  printf( "The moniker is called <%s>\n", name );

  // Free string.
  CoTaskMemFree( wide_name );

  // Get a test object.
  result = CoCreateInstance( CLSID_IPerf, NULL, CLSCTX_LOCAL_SERVER, IID_IPerf,
                               (void **) &perf );
  if (!SUCCEEDED(result))
  {
    printf( "Could not create instance of performance server: %x\n", result );
    return;
  }

  // Pass moniker to server.
  result = perf->PassMoniker( moniker );
  if (FAILED(result))
  {
    printf( "Could not give moniker to server: 0x%x\n", result );
    return;
  }

  // Release everything.
  CloseHandle( file );
  moniker->Release();
  bindctx->Release();
  perf->Release();
  OleUninitialize();
}


//+--------------------------------------------------------------
// Function:    Main
//
// Synopsis:    Executes the BasicBnd test
//
// Effects:     None
//
//
// Returns:     Exits with exit code 0 if success, 1 otherwise
//
// History:     05-Mar-92   Sarahj   Created
//
//---------------------------------------------------------------

int _cdecl main(int argc, char *argv[])
{
  BOOL    initialized = FALSE;
  HRESULT hresult = S_OK;
  BOOL    fFailed = FALSE;

  // Parse the command line arguments.
  if (!parse( argc, argv ))
    return 0;

  // Print the process id.
  printf( "Hi, I am %x.\n", GetCurrentProcessId() );

  // Time event creation.
//  EventTest();
//  return 1;

  // Pass around monikers.
//  MarshalTest();

  // Measure message queue APIs.
//  QueryMsg();


  // Print the thread mode.
  if (thread_mode == COINIT_SINGLETHREADED)
  {
    printf( "Measuring performance for the single threaded mode.\n" );
  }
  else
  {
    printf( "Measuring performance for the multithreaded mode.\n" );
  }

  // must be called before any other OLE API
  hresult = OleInitialize(NULL);

  if (FAILED(hresult))
  {
      printf("OleInitialize Failed with %lx\n", hresult);
      goto exit_main;
  }
  initialized = TRUE;

  if (fFailed = DoTest())
    goto exit_main;

/*
  // Uninitialize and rerun in the other thread mode.
  OleUninitialize();
  if (thread_mode == COINIT_SINGLETHREADED)
    thread_mode = COINIT_MULTITHREADED;
  else
    thread_mode = COINIT_SINGLETHREADED;

  // Print the thread mode.
  if (thread_mode == COINIT_SINGLETHREADED)
    printf( "Measuring performance for the single threaded mode.\n" );
  else
    printf( "Measuring performance for the multithreaded mode.\n" );

  // must be called before any other OLE API
  hresult = OleInitialize(NULL);

  if (FAILED(hresult))
  {
      printf("OleInitialize Failed with %lx\n", hresult);
      goto exit_main;
  }

  if (fFailed = DoTest())
    goto exit_main;
*/

exit_main:

  if (initialized)
    OleUninitialize();

  if (!fFailed)
  {
      printf("\nCairole: PASSED\n");
  }
  else
  {
      printf("\nCairole: FAILED\n");
  }

  return fFailed;
}

/*************************************************************************/
DWORD _stdcall MsgHelper( void *param )
{
  int    i;

  // Alternately signal and wait on an event.  Do it one time too many
  // because the main thread calls once to let us get set up.
  for (i = 0; i < num_iterations+1; i++)
  {
    WaitForSingleObject( helper_wait, INFINITE );
    SetEvent( main_wait );
  }

#define must_return_a_value return 0
  must_return_a_value;
}

/*************************************************************************/
void QueryMsg()
{
  DWORD    time_first;
  DWORD    waste;
  int      i;
  HANDLE   helper;
  DWORD    thread_id;

  // Create an event.
  helper_wait = CreateEvent( NULL, FALSE, FALSE, NULL );
  if (helper_wait == NULL)
  {
    printf( "Could not create event.\n" );
    return;
  }
  main_wait = CreateEvent( NULL, FALSE, FALSE, NULL );
  if (main_wait == NULL)
  {
    printf( "Could not create event.\n" );
    return;
  }

  // Measure how long it takes to loop.
  waste = GetTickCount();
  for (i = 0; i < num_iterations; i++)
    ;
  waste = GetTickCount() - waste;

  // Measure how long it takes to query the message queue.
  time_first = GetTickCount();
  for (i = 0; i < num_iterations; i++)
    GetQueueStatus( QS_ALLINPUT );
  time_first = GetTickCount() - time_first - waste;
  printf( "%d uS/GetQueueStatus\n", time_first*1000/num_iterations );

  // Start a thread to wake up this one.
  helper = CreateThread( NULL, 0, MsgHelper, 0, 0,
                           &thread_id );
  if (helper == NULL)
  {
    printf( "Could not create helper thread.\n" );
    return;
  }

  // Call MsgWaitForMultipleObjects once to let the thread get started.
  SetEvent( helper_wait );
  MsgWaitForMultipleObjects( 1, &main_wait, FALSE,
                             INFINITE, QS_ALLINPUT );

  // Measure how long it takes to call MsgWaitForMultipleObjects.
  time_first = GetTickCount();
  for (i = 0; i < num_iterations; i++)
  {
    SetEvent( helper_wait );
    MsgWaitForMultipleObjects( 1, &main_wait, FALSE,
                               INFINITE, QS_ALLINPUT );
  }
  time_first = GetTickCount() - time_first - waste;
  printf( "%d uS/MsgWaitForMultipleObjects\n", time_first*1000/num_iterations );

  // Start a thread to wake up this one.
  helper = CreateThread( NULL, 0, MsgHelper, 0, 0,
                           &thread_id );
  if (helper == NULL)
  {
    printf( "Could not create helper thread.\n" );
    return;
  }

  // Let the thread get started.
  SetEvent( helper_wait );
  WaitForSingleObject( main_wait, INFINITE );

  // Measure how long it takes to switch threads just using events.
  time_first = GetTickCount();
  for (i = 0; i < num_iterations; i++)
  {
    SetEvent( helper_wait );
    WaitForSingleObject( main_wait, INFINITE );
  }
  time_first = GetTickCount() - time_first - waste;
  printf( "%d uS/MsgWaitForMultipleObjects\n", time_first*1000/num_iterations );

  // Don't bother cleaning up.
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\task.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	task.h
//
//  Contents:	declarations for task-related functions and data structures
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              12-Jan-95 t-ScottH  added RunTestOnThread
//		06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef _TASK_H
#define _TASK_H

typedef struct TaskItem
{
	LPSTR	szName;
	void (*fnCall)(void *);
	void *pvArg;
} TaskItem;

// global list of all available tests
extern const TaskItem vrgTaskList[];
// global zero'ed task list
extern TaskItem vzTaskItem;

// generic callback function for test apps that register a window handle
void GenericRegCallback(void *);

// run the given api (which must be HRESULT api ( void ))
void RunApi(void *);

// runs the given app
void RunApp(void *);

// runs the app and inserts a callback function so the app can register
// its window handle for communication
void RunAppWithCallback(void *);

// runs the given test by sending a message to the currently running test
// app.
void RunTest(void *);

// runs all the tests currently built into the driver program
void RunAllTests(void *);

// run the given test function as a new thread
void    RunTestOnThread(void *pvArg);

// handles the test completion message
void HandleTestEnd(void);

// handles the tests completed message
void HandleTestsCompleted(void);

#endif //!_TASK_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\oletest\uthread.cpp ===
//+-------------------------------------------------------------------
//
//  File:       uthread.cpp
//
//  Contents:   Unit test for various OLE threading model features
//
//  Classes:    SSTParamBlock
//              SSTParamBlock
//              SBTParamBlock
//
//  Functions:  CreateTestThread
//              VerifyTestObject
//              CheckForDllExistence
//              GetDllDirectory
//              SetRegForDll
//              SetSingleThreadRegEntry
//              SetAptThreadRegEntry
//              SetBothThreadRegEntry
//              SingleThreadTestThread
//              AptTestThread
//              BothTestThread
//              SetUpRegistry
//              TestSingleThread
//              TestAptThread
//              TestBothDll
//              TestFreeAllLibraries
//              ThreadUnitTest
//
//  History:    31-Oct-94   Ricksa
//
//--------------------------------------------------------------------
#include    <windows.h>
#include    <ole2.h>
#include    <uthread.h>
#include    <cotest.h>

// Test single threaded DLL - all operations s/b executed on the main thread.
// Pointers between threads s/b different. Test loading class object from
// different than the main thread.

// Test apartment model - all operations should occur on the thread the
// object was created on. This should also test the helper APIs. Pointers
// between threads s/b different. This tests helper APIs.

// Both model DLL. We want to make sure that the marshaling works between
// threads so that you get the same pointer. This tests new marshal context.

// Test Free Unused Libraries from non-main thread. Test FreeUnused libraries
// from main thread.



//+-------------------------------------------------------------------------
//
//  Class:      SSTParamBlock
//
//  Purpose:    Parameter block for single threaded dll test.
//
//  Interface:
//
//  History:    01-Nov-92 Ricksa    Created
//
//--------------------------------------------------------------------------
struct SSTParamBlock
{
    HANDLE              hEvent;
    BOOL                fResult;
    IClassFactory *     pcf;
};




//+-------------------------------------------------------------------------
//
//  Class:      SSTParamBlock
//
//  Purpose:    Parameter block for apt model threaded dll test.
//
//  Interface:
//
//  History:    01-Nov-92 Ricksa    Created
//
//--------------------------------------------------------------------------
struct SATParamBlock
{
    HANDLE              hEvent;
    BOOL                fResult;
    IClassFactory *     pcf;
    IStream *           pstrm;
};




//+-------------------------------------------------------------------------
//
//  Class:      SBTParamBlock
//
//  Purpose:    Parameter block for both model dll test.
//
//  Interface:
//
//  History:    02-Nov-92 Ricksa    Created
//
//--------------------------------------------------------------------------
struct SBTParamBlock
{
    HANDLE              hEvent;
    BOOL                fResult;
    IClassFactory *     pcf;
    IStream *           pstrm;
};




const TCHAR *pszRegValThreadModel = TEXT("ThreadingModel");
const TCHAR *pszApartmentModel = TEXT("Apartment");
const TCHAR *pszBoth = TEXT("Both");

//+-------------------------------------------------------------------
//
//  Function:   ThreadWaitForEvent, private
//
//  Synopsis:   Process messages until event becomes signaled
//
//  Arguments:  [lphObject] - handle to become signaled
//
//  History:    02-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
void ThreadWaitForEvent(HANDLE hObject)
{
    // message loop lasts until we get a WM_QUIT message
    // upon which we shall return from the function
    while (TRUE)
    {
        // wait for any message sent or posted to this queue
        // or for one of the passed handles to become signaled
        DWORD result = MsgWaitForMultipleObjects(1, &hObject,
            FALSE, INFINITE, QS_ALLINPUT);

        // result tells us the type of event we have:
        // a message or a signaled handle

        // if there are one or more messages in the queue ...
        if (result == (WAIT_OBJECT_0 + 1))
        {
            // block-local variable
            MSG msg;

            // read all of the messages in this next loop
            // removing each message as we read it
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {

                // if it's a quit message we're out of here
                if (msg.message == WM_QUIT)
                {
                    return;
                }

                // otherwise dispatch it
                DispatchMessage(&msg);

            }

            continue;
        }

        // Event got signaled so we are done.
        break;
    }

}



//+-------------------------------------------------------------------
//
//  Function:   CreateTestThread, private
//
//  Synopsis:   Create a test thread in standard way
//
//  Arguments:  [lpStartAddr] - start routine address
//              [pvThreadArg] - argument to pass to the thread
//
//  Returns:    TRUE - Thread created successfully
//              FALSE - Thread could not be created.
//
//  History:    02-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL CreateTestThread(
    LPTHREAD_START_ROUTINE lpStartAddr,
    void *pvThreadArg)
{
    // Where to put the thread ID that we don't care about
    DWORD dwThreadId;

    // Create thread to load single threaded object
    HANDLE hThread = CreateThread(
        NULL,                       // Default security descriptor
        0,                          // Default stack
        lpStartAddr,                // Start routine
        pvThreadArg,                // Parameters to pass to the thread
        0,                          // Thread runs immediately after creation
        &dwThreadId);               // Where to return thread id (unused).

    CloseHandle(hThread);

    return hThread != NULL;
}



//+-------------------------------------------------------------------
//
//  Function:   VerifyTestObject, private
//
//  Synopsis:   Create a test DLL object in standard way
//
//  Arguments:  [pcf] - start routine address
//              [rclsid] - clsid to check
//
//  Returns:    TRUE - Object behaved as expected
//              FALSE - Object did not behave
//
//  History:    02-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL VerifyTestObject(
    IClassFactory *pcf,
    REFCLSID rclsid)
{
    // Result from test
    BOOL fResult = FALSE;

    // Pointer to unknown for the object
    IUnknown *punk = NULL;

    // Pointer to IPersist interface
    IPersist *pIPersist = NULL;

    // Create an instance of an object
    if (pcf->CreateInstance(NULL, IID_IUnknown, (void **) &punk) == NOERROR)
    {
        // Do a QI to confirm object behaves correctly
        if (punk->QueryInterface(IID_IPersist, (void **) &pIPersist) == NOERROR)
        {
            CLSID clsidTest;

            // Make sure we can actually call through to the proxy object.
            if ((pIPersist->GetClassID(&clsidTest) == NOERROR)
                && IsEqualCLSID(clsidTest, rclsid))
            {
                fResult = TRUE;
            }
        }
    }

    if (punk != NULL)
    {
        punk->Release();
    }

    if (pIPersist != NULL)
    {
        pIPersist->Release();
    }

    return fResult;
}





//+-------------------------------------------------------------------
//
//  Function:   GetFullDllName, private
//
//  Synopsis:   Get the directory for the registration for the test.
//
//  Arguments:  [pszDllName] - DLL name
//              [pszFullDllName] - output buffer for DLL path
//
//  Returns:    TRUE - we could get the path for the DLL
//              FALSE - we couldn't figure out what to use.
//
//  History:    31-Oct-94   Ricksa       Created
//
//  Notes:
//
//--------------------------------------------------------------------
BOOL GetFullDllName(const TCHAR *pszDllName, TCHAR *pszFullDllName)
{
    // Use windows to tell us what DLL we would load.
    HINSTANCE hinstDll = LoadLibraryEx(pszDllName, NULL,
        DONT_RESOLVE_DLL_REFERENCES | LOAD_WITH_ALTERED_SEARCH_PATH);

    if (hinstDll == NULL)
    {
        // We could not find the DLL so there isn't much purpose in
        // continuing the test.
        MessageBox(NULL, TEXT("LoadLibraryEx Failed!"),
            TEXT("FATAL ERROR"), MB_OK);
        return FALSE;
    }

    // Get the DLLs path name
    if (!GetModuleFileName(hinstDll, pszFullDllName, MAX_PATH))
    {
        // How can this fail?? -- anyway we better tell someone.
        MessageBox(NULL, TEXT("Threading Test GetModuleFileName Failed!"),
            TEXT("FATAL ERROR"), MB_OK);
        return FALSE;
    }

    FreeLibrary(hinstDll);

    return TRUE;
}



//+-------------------------------------------------------------------
//
//  Function:   SetRegForDll, private
//
//  Synopsis:   Set registry entry for a DLL
//
//  Arguments:  [rclsid] - clsid for reg entry
//              [pszDir] - directory for DLL path
//              [pszDllName] - name to use for DLL
//              [pszThreadModel] - threading model can be NULL.
//
//  Returns:    TRUE - Registry entry set successfully.
//              FALSE - Registry entry set successfully.
//
//  History:    01-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL SetRegForDll(
    REFCLSID rclsid,
    const TCHAR *pszDllName,
    const TCHAR *pszThreadModel)
{
    // Result returned by function
    BOOL fResult = FALSE;

    // String buffer used for various purposes
    TCHAR aszWkBuf[MAX_PATH];

    // Key to class
    HKEY hKeyClass = NULL;

    // Key to DLL entry
    HKEY hKeyDll = NULL;

    // Build clsid registry key
    wsprintf(aszWkBuf,
        TEXT("CLSID\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
        rclsid.Data1, rclsid.Data2, rclsid.Data3,
        rclsid.Data4[0], rclsid.Data4[1],
        rclsid.Data4[2], rclsid.Data4[3],
        rclsid.Data4[4], rclsid.Data4[5],
        rclsid.Data4[6], rclsid.Data4[7]);

    // Create the key for the class
    if (ERROR_SUCCESS != RegCreateKey(HKEY_CLASSES_ROOT, aszWkBuf, &hKeyClass))
    {
        goto SetSingleThreadRegEntryExit;
    }

    // Create the key for the DLL

    if (ERROR_SUCCESS != RegCreateKey(hKeyClass, TEXT("InprocServer32"),
        &hKeyDll))
    {
        goto SetSingleThreadRegEntryExit;
    }

    // Build the DLL name
    if (!GetFullDllName(pszDllName, &aszWkBuf[0]))
    {
        goto SetSingleThreadRegEntryExit;
    }

    OutputDebugString(&aszWkBuf[0]);

    // Set the value for the DLL name
    if (ERROR_SUCCESS != RegSetValue(hKeyDll, NULL, REG_SZ, aszWkBuf,
        lstrlen(aszWkBuf)))
    {
        goto SetSingleThreadRegEntryExit;
    }

    // Set the threading model if there is one
    if (pszThreadModel != NULL)
    {
        // Set the value for the DLL name
        if (ERROR_SUCCESS != RegSetValueEx(hKeyDll, pszRegValThreadModel, 0,
            REG_SZ, (const unsigned char*) pszThreadModel,
                lstrlen(pszThreadModel) + 1))
        {
            goto SetSingleThreadRegEntryExit;
        }
    }

    fResult = TRUE;

SetSingleThreadRegEntryExit:

    if (hKeyClass != NULL)
    {
        RegCloseKey(hKeyClass);
    }

    if (hKeyDll != NULL)
    {
        RegCloseKey(hKeyDll);
    }

    if (!fResult)
    {
        wsprintf(aszWkBuf, TEXT("Registry Setup For %s Failed"), pszDllName);

        MessageBox(NULL, aszWkBuf, TEXT("FATAL ERROR"), MB_OK);
    }

    return fResult;
}



//+-------------------------------------------------------------------
//
//  Function:   SingleThreadTestThread, private
//
//  Synopsis:   Verify single threaded object call correctly from non
//              main thread.
//
//  Arguments:  [pvCtrlData] - control data for the thread
//
//  Returns:    0 - interesting values returned through pvCtrlData.
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
DWORD SingleThreadTestThread(void *pvCtrlData)
{
    // Data shared with main thread
    SSTParamBlock *psstp = (SSTParamBlock *) pvCtrlData;

    psstp->fResult = FALSE;

    // Local class factory object.
    IClassFactory *pcf = NULL;

    // IUnknown ptrs used for multiple purposes
    IUnknown *punk = NULL;

    // Initialize thread
    if (CoInitialize(NULL) != NOERROR)
    {
        goto SingleThreadTestThreadExit;
    }

    // Get the class object
    if (CoGetClassObject(clsidSingleThreadedDll, CLSCTX_INPROC, NULL,
        IID_IClassFactory, (void **) &pcf) != NOERROR)
    {
        goto SingleThreadTestThreadExit;
    }

    // Make sure main thread's ptr is not the same as this thread's ptr.
    if (pcf == psstp->pcf)
    {
        goto SingleThreadTestThreadExit;
    }

    // Confirm that class object is a proxy
    if (pcf->QueryInterface(IID_IProxyManager, (void **) &punk) == NOERROR)
    {
        // Verify that we can play with an object.
        psstp->fResult = VerifyTestObject(pcf, clsidSingleThreadedDll);
    }

SingleThreadTestThreadExit:

    if (pcf != NULL)
    {
        pcf->Release();
    }

    if (punk != NULL)
    {
        punk->Release();
    }

    // Exit the thread.
    SetEvent(psstp->hEvent);

    return 0;
}




//+-------------------------------------------------------------------
//
//  Function:   AptTestThread, private
//
//  Synopsis:   Verify apt threaded object call correctly from thread
//              if was not created on.
//
//  Arguments:  [pvCtrlData] - control data for the thread
//
//  Returns:    0 - interesting values returned through pvCtrlData.
//
//  History:    02-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
DWORD AptTestThread(void *pvCtrlData)
{
    // Data shared with main thread
    SATParamBlock *psatpb = (SATParamBlock *) pvCtrlData;

    psatpb->fResult = FALSE;

    // Class factory object unmarshaled from other thread.
    IClassFactory *pcfUnmarshal = NULL;

    // Class factory gotten from this thread
    IClassFactory *pcfThisThread = NULL;

    // IUnknown ptrs used for multiple purposes
    IUnknown *punk = NULL;

    // Initialize thread
    if (CoInitialize(NULL) != NOERROR)
    {
        goto AptTestThreadExit;
    }

    // Get the class object from the marshaled stream
    if (CoGetInterfaceAndReleaseStream(psatpb->pstrm, IID_IClassFactory,
        (void **) &pcfUnmarshal) != NOERROR)
    {
        goto AptTestThreadExit;
    }

    // Caller doesn't have to release this now.
    psatpb->pstrm = NULL;

    // Make sure main thread's ptr is not the same as this thread's ptr.
    if (pcfUnmarshal == psatpb->pcf)
    {
        goto AptTestThreadExit;
    }

    // Confirm that class object is a proxy
    if (pcfUnmarshal->QueryInterface(IID_IProxyManager, (void **) &punk)
        != NOERROR)
    {
        goto AptTestThreadExit;
    }

    // Release the interface we got back and NULL it let the exit routine
    // known that it does not have to clean this object up.
    punk->Release();
    punk = NULL;

    if (!VerifyTestObject(pcfUnmarshal, clsidAptThreadedDll))
    {
        goto AptTestThreadExit;
    }

    // Get the class factory for this thread
    if (CoGetClassObject(clsidAptThreadedDll, CLSCTX_INPROC, NULL,
        IID_IClassFactory, (void **) &pcfThisThread) != NOERROR)
    {
        goto AptTestThreadExit;
    }

    // Make sure that it isn't the same as the one we unmarshaled
    if (pcfUnmarshal == pcfThisThread)
    {
        goto AptTestThreadExit;
    }

    // Make sure the one we got for this not a proxy.
    if (pcfThisThread->QueryInterface(IID_IProxyManager, (void **) &punk)
        != NOERROR)
    {
        psatpb->fResult = VerifyTestObject(pcfThisThread, clsidAptThreadedDll);
    }

AptTestThreadExit:

    if (pcfUnmarshal != NULL)
    {
        pcfUnmarshal->Release();
    }

    if (pcfThisThread != NULL)
    {
        pcfThisThread->Release();
    }

    if (punk != NULL)
    {
        punk->Release();
    }

    // Exit the thread.
    SetEvent(psatpb->hEvent);

    return 0;
}




//+-------------------------------------------------------------------
//
//  Function:   BothTestThread, private
//
//  Synopsis:   Verify a DLL that supports both models is marshaled
//              correctly.
//
//  Arguments:  [pvCtrlData] - control data for the thread
//
//  Returns:    0 - interesting values returned through pvCtrlData.
//
//  History:    02-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
DWORD BothTestThread(void *pvCtrlData)
{
    // Data shared with main thread
    SBTParamBlock *psbtpb = (SBTParamBlock *) pvCtrlData;

    psbtpb->fResult = FALSE;

    // Class factory object unmarshaled from other thread.
    IClassFactory *pcfUnmarshal = NULL;

    // IUnknown ptrs used for multiple purposes
    IUnknown *punk = NULL;
    IUnknown *pIPersist = NULL;

    // Initialize thread
    if (CoInitialize(NULL) != NOERROR)
    {
        goto BothTestThreadExit;
    }

    // Get the class object from the marshaled stream
    if (CoGetInterfaceAndReleaseStream(psbtpb->pstrm, IID_IClassFactory,
        (void **) &pcfUnmarshal) != NOERROR)
    {
        goto BothTestThreadExit;
    }

    // Caller doesn't have to release this now.
    psbtpb->pstrm = NULL;

    // Make sure main thread's ptr is not the same as this thread's ptr.
    if (pcfUnmarshal != psbtpb->pcf)
    {
        goto BothTestThreadExit;
    }

    // Confirm that class object is a proxy
    if (pcfUnmarshal->QueryInterface(IID_IProxyManager, (void **) &punk)
        != NOERROR)
    {
        // Make sure object created by the class works as expected
        psbtpb->fResult = VerifyTestObject(pcfUnmarshal, clsidBothThreadedDll);
    }

BothTestThreadExit:

    if (pcfUnmarshal != NULL)
    {
        pcfUnmarshal->Release();
    }

    if (punk != NULL)
    {
        punk->Release();
    }

    // Exit the thread.
    SetEvent(psbtpb->hEvent);

    return 0;
}




//+-------------------------------------------------------------------
//
//  Function:   SetUpRegistry, private
//
//  Synopsis:   Make sure registry is set up appropriately for the test
//
//  Returns:    TRUE - Registry set up successfully
//              FALSE - Registry could not be set up
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL SetUpRegistry(void)
{
    BOOL fRet = FALSE;

    // Update the registry with the correct information
    fRet = SetRegForDll(clsidSingleThreadedDll, pszSingleThreadedDll, NULL)
        && SetRegForDll(clsidAptThreadedDll, pszAptThreadedDll,
                pszApartmentModel)
        && SetRegForDll(clsidBothThreadedDll, pszBothThreadedDll, pszBoth);

    // Give Registry a chance to get updated
    Sleep(1000);

    return fRet;
}



//+-------------------------------------------------------------------
//
//  Function:   TestSingleThread, private
//
//  Synopsis:   Driver to verify testing of single threaded behavior
//
//  Returns:    TRUE - Test Passed
//              FALSE - Test Failed
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL TestSingleThread(void)
{
    // Result of test - default to FALSE.
    BOOL fResult = FALSE;

    // Create an event for test to wait for completion of test.
    SSTParamBlock sstp;

    sstp.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    sstp.pcf = NULL;

    if (sstp.hEvent == NULL)
    {
        goto TestSingleThreadExit;
    }

    // Create a class object and put in a parameter block
    if (CoGetClassObject(clsidSingleThreadedDll, CLSCTX_INPROC, NULL,
        IID_IClassFactory, (void **) &sstp.pcf) != NOERROR)
    {
        goto TestSingleThreadExit;
    }

    // Create the thread.
    if (CreateTestThread(SingleThreadTestThread, &sstp))
    {
        // Wait for test to complete - ignore deadlock for now at least. The
        // test thread is simple enough that it should not be a problem.
        ThreadWaitForEvent(sstp.hEvent);

        // Get result from thread
        fResult = sstp.fResult;
    }

TestSingleThreadExit:

    if (sstp.hEvent != NULL)
    {
        CloseHandle(sstp.hEvent);
    }

    if (sstp.pcf != NULL)
    {
        sstp.pcf->Release();
    }

    // Let user know this didn't work
    if (!fResult)
    {
        MessageBox(NULL, TEXT("Single Threaded Test Failed"),
            TEXT("FATAL ERROR"), MB_OK);
    }

    // Return results of test
    return fResult;
}





//+-------------------------------------------------------------------
//
//  Function:   TestAptThread, private
//
//  Synopsis:   Test an apartment model object. The most important
//              aspect of this is that it tests the helper APIs.
//
//  Returns:    TRUE - Test Passed
//              FALSE - Test Failed
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL TestAptThread(void)
{
    // Return result for test
    BOOL fResult = FALSE;

    // Block for passing parameters to the test thread
    SATParamBlock satpb;

    satpb.pstrm = NULL;
    satpb.pcf = NULL;

    // Create an event for test to wait for completion of test.
    satpb.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (satpb.hEvent == NULL)
    {
        goto TestAptThreadExit;
    }
    satpb.pcf = NULL;
    // Create a class object and put in parameter block
    if (CoGetClassObject(clsidAptThreadedDll, CLSCTX_INPROC, NULL,
        IID_IClassFactory, (void **) &satpb.pcf) != NOERROR)
    {
        goto TestAptThreadExit;
    }

    // Create stream using helper API
    if (CoMarshalInterThreadInterfaceInStream(IID_IClassFactory,
        satpb.pcf, &satpb.pstrm) != NOERROR)
    {
        goto TestAptThreadExit;
    }

    // Create thread to do apartment model test
    if (CreateTestThread(AptTestThread, &satpb))
    {
        // Wait for test to complete - ignore deadlock for now at least. The
        // test thread is simple enough that it should not be a problem.
        ThreadWaitForEvent(satpb.hEvent);

        // Get result from thread
        fResult = satpb.fResult;
    }

TestAptThreadExit:

    // Clean up any resources
    if (satpb.hEvent != NULL)
    {
        CloseHandle(satpb.hEvent);
    }

    if (satpb.pcf != NULL)
    {
        satpb.pcf->Release();
    }

    if (satpb.pstrm != NULL)
    {
        satpb.pstrm->Release();
    }

    // Let user know this didn't work
    if (!fResult)
    {
        MessageBox(NULL, TEXT("Apartment Threaded Test Failed"),
            TEXT("FATAL ERROR"), MB_OK);
    }

    // Return results of test
    return fResult;
}





//+-------------------------------------------------------------------
//
//  Function:   TestBothDll, private
//
//  Synopsis:   Test using DLL that purports to support both free
//              threading and apt model. The most important aspect
//              of this test is that it tests the marshal context.
//
//  Returns:    TRUE - Test Passed
//              FALSE - Test Failed
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL TestBothDll(void)
{
    // Return result for test
    BOOL fResult = FALSE;

    // Block for passing parameters to the test thread
    SBTParamBlock sbtpb;

    sbtpb.pstrm = NULL;
    sbtpb.pcf = NULL;

    IClassFactory *pcfFromMarshal = NULL;
    IStream *pstmForMarshal = NULL;
    HGLOBAL hglobForStream = NULL;

    // Create an event for test to wait for completion of test.
    sbtpb.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (sbtpb.hEvent == NULL)
    {
        goto TestBothDllExit;
    }

    // Create a class object and put in parameter block
    if (CoGetClassObject(clsidBothThreadedDll, CLSCTX_INPROC, NULL,
        IID_IClassFactory, (void **) &sbtpb.pcf) != NOERROR)
    {
        goto TestBothDllExit;
    }

    // Marshal this for the local context and unmarshal it and
    // see if we get the same result.

    if ((hglobForStream = GlobalAlloc(GMEM_MOVEABLE, 100)) == NULL)
    {
        GetLastError();
        goto TestBothDllExit;
    }

    if (CreateStreamOnHGlobal(hglobForStream, TRUE, &pstmForMarshal) != NOERROR)
    {
        goto TestBothDllExit;
    }

    if (CoMarshalInterface(pstmForMarshal, IID_IClassFactory, sbtpb.pcf,
        MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL) != NOERROR)
    {
        goto TestBothDllExit;
    }

    // Reset the stream to the begining
    {
        LARGE_INTEGER li;
        LISet32(li, 0);
        pstmForMarshal->Seek(li, STREAM_SEEK_SET, NULL);
    }

    if (CoUnmarshalInterface(pstmForMarshal, IID_IClassFactory,
        (void **) &pcfFromMarshal) != NOERROR)
    {
        goto TestBothDllExit;
    }

    if (sbtpb.pcf != pcfFromMarshal)
    {
        goto TestBothDllExit;
    }

    // Create stream using helper API
    if (CoMarshalInterThreadInterfaceInStream(IID_IClassFactory,
        sbtpb.pcf, &sbtpb.pstrm) != NOERROR)
    {
        goto TestBothDllExit;
    }

    // Create thread to do apartment model test
    if (CreateTestThread(BothTestThread, &sbtpb))
    {
        // Wait for test to complete - ignore deadlock for now at least. The
        // test thread is simple enough that it should not be a problem.
        WaitForSingleObject(sbtpb.hEvent, INFINITE);

        // Get result from thread
        fResult = sbtpb.fResult;
    }

TestBothDllExit:

    // Clean up any resources
    if (sbtpb.hEvent != NULL)
    {
        CloseHandle(sbtpb.hEvent);
    }

    if (sbtpb.pcf != NULL)
    {
        sbtpb.pcf->Release();
    }

    if (sbtpb.pstrm != NULL)
    {
        sbtpb.pstrm->Release();
    }

    if (pcfFromMarshal != NULL)
    {
        pcfFromMarshal->Release();
    }

    if (pstmForMarshal != NULL)
    {
        pstmForMarshal->Release();
    }
    else if (hglobForStream != NULL)
    {
        GlobalFree(hglobForStream);
    }

    // Let user know this didn't work
    if (!fResult)
    {
        MessageBox(NULL, TEXT("Both Threaded Test Failed"),
            TEXT("FATAL ERROR"), MB_OK);
    }

    // Return results of test
    return fResult;
}




//+-------------------------------------------------------------------
//
//  Function:   TestFreeAllLibraries, private
//
//  Synopsis:   Test free from non-main thread. This is really to
//              just make sure that nothing really bad happens when
//              we do this.
//
//  Returns:    TRUE - Test Passed
//              FALSE - Test Failed
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL TestFreeAllLibraries(void)
{
    CoFreeUnusedLibraries();

    return TRUE;
}




//+-------------------------------------------------------------------
//
//  Function:   ThreadUnitTest, public
//
//  Synopsis:   Test various messaging enhancements to OLE
//
//  Returns:    TRUE - Test Passed
//              FALSE - Test Failed
//
//  History:    31-Oct-94   Ricksa       Created
//
//--------------------------------------------------------------------
HRESULT ThreadUnitTest(void)
{
    HRESULT hr = E_FAIL;

    // Make sure OLE is initialized
    HRESULT hrInit = OleInitialize(NULL);

    if (FAILED(hrInit))
    {
        MessageBox(NULL, TEXT("ThreadUnitTest: OleInitialize FAILED"),
            TEXT("FATAL ERROR"), MB_OK);
        goto ThreadUnitTestExit;
    }

    // Set up the registry
    if (!SetUpRegistry())
    {
        goto ThreadUnitTestExit;
    }

    // Test Single Threaded DLL
    if (!TestSingleThread())
    {
        goto ThreadUnitTestExit;
    }

    // Test an aparment model DLL
    if (!TestAptThread())
    {
        goto ThreadUnitTestExit;
    }

    // Test a both DLL
    if (!TestBothDll())
    {
        goto ThreadUnitTestExit;
    }

    // Test CoFreeAllLibraries
    if (TestFreeAllLibraries())
    {
        hr = NOERROR;
    }

ThreadUnitTestExit:

    OleUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf\perfsrv\wterm.h ===
#ifndef __WTERM__
#define __WTERM__

// Message to print a line on the window
#define WM_PRINT_LINE (WM_USER + 1)

// Message to print a character on the window
#define WM_PUTC (WM_USER + 2)

// Message used to terminate this window
#define WM_TERM_WND (WM_USER + 3)

//
//  Typedefs for call back functions for the window
//
typedef long (*MFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);
typedef long (*CFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);
typedef long (*TFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);

// Register the terminal window class
BOOL TermRegisterClass(
    HANDLE hInstance,
    LPTSTR MenuName,
    LPTSTR ClassName,
    LPTSTR ICON);

// Create a window for the terminal
BOOL
TermCreateWindow(
    LPTSTR lpClassName,
    LPTSTR lpWindowName,
    HMENU hMenu,
    MFUNCP MenuProc,
    CFUNCP CharProc,
    TFUNCP CloseProc,
    int nCmdShow,
    HWND *phNewWindow,
    void *pvCallBackData);

#endif // __WTERM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\my3216.h ===
#ifndef MY3216_H
#define MY3216_H

#ifndef WIN32
    #define lstrcmpiA   lstrcmpi
    #define TEXT(a) (a)
    typedef TCHAR FAR * LPTSTR;
#endif

#endif // MY3216_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\syshead.h ===
#ifndef __SYSHEAD_H
#define __SYSHEAD_H

#define INC_OLE2
#include <windows.h>
#include <ole2.h>
#include <ole2ver.h>

#endif // __SYSHEAD_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf\proxy\dllentry.c ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       dllentry.c
//
//  Contents:   Dll Entry point code.  Calls the appropriate run-time
//              init/term code and then defers to LibMain for further
//              processing.
//
//  Classes:    <none>
//
//  Functions:  DllEntryPoint - Called by loader
//
//  History:    10-May-92  BryanT    Created
//              22-Jul-92  BryanT    Switch to calling _cexit/_mtdeletelocks
//                                    on cleanup.
//              06-Oct-92  BryanT    Call RegisterWithCommnot on entry
//                                   and DeRegisterWithCommnot on exit.
//                                   This should fix the heap dump code.
//              12-23-93   TerryRu   Replace LockExit, and UnLockExit
//                                   with critial sections for Daytona.
//              12-28-93   TerryRu   Place Regiter/DeRegister WinCommnot apis
//                                   Inside WIN32 endifs for Daytona builds.
//
//--------------------------------------------------------------------
#include <windows.h>
//#include <win4p.h>
#include <process.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>


BOOL WINAPI _CRT_INIT (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

BOOL __stdcall DllEntryPoint (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

BOOL __cdecl LibMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

void __cdecl _mtdeletelocks(void);

DWORD WINAPI
GetModuleFileNameCtC(
        HMODULE hModule,
        LPWSTR  pwszFilename,
        DWORD   nSize);

#ifdef USE_CRTDLL

#define _RT_ONEXIT      24

/*
 * routine in DLL to do initialization (in this case, C++ constructors)
 */

typedef void (__cdecl *PF)(void);

/*
 * pointers to initialization sections
 */

PF *__onexitbegin;
PF *__onexitend;

/*
 * Define increment (in entries) for growing the _onexit/atexit table
 */
#define ONEXITTBLINCR   4

static void __cdecl _onexitinit ( void );
extern void __cdecl _initterm(PF *, PF *);
extern void __cdecl _amsg_exit(int);
extern void __cdecl _lockexit(void);
extern void __cdecl _unlockexit(void);

#endif

// BUGBUG: defined in $(COMMON)\src\except\memory.cxx

void RegisterWithCommnot(void);
void DeRegisterWithCommnot(void);

CRITICAL_SECTION __gCriticalSection;

BOOL __stdcall DllEntryPoint (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fRc = FALSE;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:

#ifdef USE_CRTDLL
            //
            // Assumption: The run-time is sufficiantly up and running to
            //             support malloc that _onexitinit will perform.
            //
            _onexitinit();
            InitializeCriticalSection(&__gCriticalSection );
#endif

            _CRT_INIT(hDll, dwReason, lpReserved);
#if WIN32==300
            RegisterWithCommnot();
#endif

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            fRc = LibMain (hDll, dwReason, lpReserved);
            break;

        case DLL_PROCESS_DETACH:
            fRc = LibMain (hDll, dwReason, lpReserved);

            //
            // BUGBUG: What a hack.  In order to make sure we don't kill
            //         commnot's objects while still in use (_cexit will do
            //         the atexit list processing where the compiler stores
            //         pointers to all the static destructors), test the
            //         module name.  If not commnot, call _cexit().
            //         DeRegisterWithCommnot will call it for commnot...
            //

#ifdef USE_CRTDLL

            {
                wchar_t pwszModName[512];
                GetModuleFileName(hDll, pwszModName, 512);

                if (!wcswcs(wcsupr(pwszModName), L"COMMNOT"))
                    if (__onexitbegin)
                        _initterm(__onexitbegin, __onexitend);
            }

            DeleteCriticalSection( & __gCriticalSection );
#else

            {
                wchar_t pwszModName[512];
                GetModuleFileName(hDll, pwszModName, 512);

                if (!wcswcs(wcsupr(pwszModName), L"COMMNOT"))
                    _cexit();
            }

            _mtdeletelocks();
#endif
#if WIN32==300
            DeRegisterWithCommnot();
#endif
            break;
    }

    return(fRc);
}

#ifdef USE_CRTDLL

_onexit_t __cdecl _onexit ( _onexit_t func )
{
        PF      *p;

        EnterCriticalSection( &__gCriticalSection );                    /* lock the exit code */

        /*
         * First, make sure the table has room for a new entry
         */
        if ( _msize(__onexitbegin) <= (unsigned)((char *)__onexitend -
            (char *)__onexitbegin) ) {
                /*
                 * not enough room, try to grow the table
                 */
                if ( (p = (PF *) realloc(__onexitbegin, _msize(__onexitbegin) +
                    ONEXITTBLINCR * sizeof(PF))) == NULL ) {
                        /*
                         * didn't work. don't do anything rash, just fail
                         */
                        LeaveCriticalSection(&__gCriticalSection );

                        return NULL;
                }

                /*
                 * update __onexitend and __onexitbegin
                 */

                __onexitend = p + (__onexitend - __onexitbegin);
                __onexitbegin = p;
        }

        /*
         * Put the new entry into the table and update the end-of-table
         * pointer.
         */

         *(__onexitend++) = (PF)func;

        LeaveCriticalSection( &__gCriticalSection );

        return func;

}

int __cdecl atexit ( PF func )
{
        return (_onexit((_onexit_t)func) == NULL) ? -1 : 0;
}

static void __cdecl _onexitinit ( void )
{
        if ( (__onexitbegin = (PF *)malloc(32 * sizeof(PF))) == NULL )
                /*
                 * cannot allocate minimal required size. generate
                 * fatal runtime error.
                 */
                _amsg_exit(_RT_ONEXIT);

        *(__onexitbegin) = (PF) NULL;
        __onexitend = __onexitbegin;
}

#endif  // USE_CRTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\bookpart.h ===
#define SETDefFormatEtc(fe, cf, med)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=DVASPECT_CONTENT;\
    (fe).ptd=NULL;\
    (fe).tymed=med;\
    (fe).lindex=-1;\
    };

#define DATASIZE_FROM_INDEX(i)  ((i) * 1024)


//Types that OLE2.H et. al. leave out
#ifndef LPLPVOID
typedef LPVOID FAR * LPLPVOID;
#endif  //LPLPVOID

#ifndef PPVOID  //Large model version
typedef LPVOID * PPVOID;
#endif  //PPVOID


EXTERN_C const GUID CDECL FAR CLSID_DataObjectTest32;
EXTERN_C const GUID CDECL FAR CLSID_DataObjectTest16;

#ifdef INIT_MY_GUIDS

    EXTERN_C const GUID CDECL
    CLSID_DataObjectTest32 = { /* ad562fd0-ac40-11ce-9d69-00aa0060f944 */
        0xad562fd0,
        0xac40,
        0x11ce,
        {0x9d, 0x69, 0x00, 0xaa, 0x00, 0x60, 0xf9, 0x44}
      };

    EXTERN_C const GUID CDECL
    CLSID_DataObjectTest16 = { /* ad562fd1-ac40-11ce-9d69-00aa0060f944 */
        0xad562fd1,
        0xac40,
        0x11ce,
        {0x9d, 0x69, 0x00, 0xaa, 0x00, 0x60, 0xf9, 0x44}
    };

#endif /* INITGUID */



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf\perfuuid\perfsrvi.c ===
#pragma warning(disable:4101)    // Ignore variable not use warning

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: iperf_i.c
//
//  Contents: IID_IPerf
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.83
//
//--------------------------------------------------------------------------
typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;


const IID CLSID_IPerf = {0x1AFDBB80, 0xAA32, 0x101A, {0xB4, 0xAD, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf\perfsrv\wterm.c ===
/****************************************************************************

    PROGRAM: wterm.c

    PURPOSE: Implementation of TermWClass Windows

    FUNCTIONS:


    COMMENTS:


****************************************************************************/

#include "windows.h"
#include "stdlib.h"
#include "memory.h"
#include "wterm.h"

#define MAX_ROWS 24
#define MAX_COLS 80

typedef struct WData
{
    // Function to execute for processing a menu
    MFUNCP pMenuProc;

    // Function to execute for processing a single character
    CFUNCP pCharProc;

    // Function to execute when window is closed (terminated)
    TFUNCP pCloseProc;

    // Pass on callback
    void *pvCallBackData;

    BOOL fGotFocus;

    BOOL fCaretHidden;

    // Rows on the screen
    int cRows;

    // Columns on the screen
    int cCols;

    // Row at top of screen
    int iTopRow;

    // Row at bottom of the screen
    int iBottomRow;

    // First Column on screen
    int iFirstCol;

    // Column at bottom of the screen
    int iBottomCol;

    // Row for next character
    int iNextRow;

    // Row for next column
    int iNextCol;

    // Width of character
    int cxChar;

    // Height of character
    int cyChar;

    // Memory image of screen this is treated as a circular buffer
    TCHAR aImage[MAX_ROWS] [MAX_COLS];

    // First row in circular screen buffer
    int iBufferTop;
} WData;

static HANDLE hInst = 0;
TCHAR BlankLine[80];

static int
row_diff(
    int row1,
    int row2)
{
    return (row2 > row1)
        ? MAX_ROWS - (row2 - row1)
        : row1 - row2;
}

static void
set_vscroll_pos(
    HWND hwnd,
    WData *pwdata)
{
    if (pwdata->cRows != 0)
    {
        // Save a few indirections by caching cRows
        register int cRows = pwdata->cRows;

        // calculate distance bottom of screen from top of data buffer
        register int top_from_row = row_diff(pwdata->iBottomRow,
            pwdata->iBufferTop);

        // Output position of scroll bar
        int new_pos = 0;

        if (top_from_row >= cRows)
        {
            // Calculate number of screens to display entire buffer
            int screens_for_data = MAX_ROWS / cRows
               + ((MAX_ROWS % cRows != 0) ? 1 : 0);

            // Figure out which screen the row falls in
            int screen_loc = top_from_row / cRows
                + ((top_from_row % cRows != 0) ? 1 : 0);

            // If the screen is in the last one set box to max
            new_pos = (screen_loc == screens_for_data)
                ? MAX_ROWS : screen_loc * cRows;
        }

        SetScrollPos(hwnd, SB_VERT, new_pos, TRUE);
    }
}

static int
calc_row(
    register int row,
    WData *pwdata)
{
    register int top = pwdata->iTopRow;
    static int boopa = 0;

    if (top > row)
        boopa++;

    return (row >= top) ? row - top : (MAX_ROWS - (top - row));
}

static void
display_text(
    HWND hwnd,
    int row,
    int col,
    LPTSTR text,
    int text_len,
    WData *pWData)
{
    // Get the DC to display the text
    HDC hdc = GetDC(hwnd);

    // Select Font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    // Hide caret while we are printing
    HideCaret(hwnd);

    // Update the screen
    TextOut(hdc, (col - pWData->iFirstCol) * pWData->cxChar,
        calc_row(row, pWData) * pWData->cyChar, text, text_len);

    // Done with DC
    ReleaseDC(hwnd, hdc);

    // Put the caret back now that we are done
    ShowCaret(hwnd);
}

static void
display_char(
    HWND hwnd,
    TCHAR char_to_display,
    WData *pWData)
{
    // Update image buffer
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = char_to_display;

    display_text(hwnd, pWData->iNextRow, pWData->iNextCol,
      &char_to_display, 1, pWData);
}

static void
do_backspace(
    HWND hwnd,
    WData *pWData)
{
    // Point to the previous character in the line
    if (--pWData->iNextCol < 0)
    {
        // Can't backspace beyond the current line
        pWData->iNextCol = 0;
        return;
    }

    display_char(hwnd, ' ', pWData);

    // Null character for repaint
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = '\0';
}

static int
inc_row(
    int row,
    int increment)
{
    row += increment;

    if (row >= MAX_ROWS)
    {
        row -= MAX_ROWS;
    }
    else if (row < 0)
    {
        row += MAX_ROWS;
    }

    return row;
}

void
inc_next_row(
    HWND hwnd,
    WData *pWData)
{
    if (pWData->iNextRow == pWData->iBottomRow)
    {
        // Line is at bottom -- scroll the client area one row
        ScrollWindow(hwnd, 0, -pWData->cyChar, NULL, NULL);

        // Increment the top & bottom of the screen
        pWData->iTopRow = inc_row(pWData->iTopRow, 1);
        pWData->iBottomRow = inc_row(pWData->iBottomRow, 1);
    }

    // Increment the row
    pWData->iNextRow = inc_row(pWData->iNextRow, 1);

    if (pWData->iNextRow == pWData->iBufferTop)
    {
        // Have to reset circular buffer to next
        pWData->iBufferTop = inc_row(pWData->iBufferTop, 1);

        // Reset line to nulls for repaint
        memset(&pWData->aImage[pWData->iNextRow][0], '\0', MAX_COLS);
    }

    pWData->iNextCol = 0;
}

static void
do_cr(
    HWND hwnd,
    WData *pWData)
{
    // Set position to next row
    inc_next_row(hwnd, pWData);
    pWData->iNextCol = 0;

    // Make sure next character is null for repaint of line
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = '\0';

    // Update the vertical scroll bar's position
    set_vscroll_pos(hwnd, pWData);
}

static void
do_char(
    HWND hwnd,
    WPARAM wParam,
    WData *pWData)
{
    display_char(hwnd, (TCHAR) wParam, pWData);

    // Point to the next character in the line
    if (++pWData->iNextCol > MAX_COLS)
    {
        // Handle switch to next line
        inc_next_row(hwnd, pWData);
    }
}

static void
do_tab(
    HWND hwnd,
    WData *pWData)
{
    int c = pWData->iNextCol % 8;

    if ((pWData->iNextCol + c) <= MAX_COLS)
    {
        for ( ; c; c--)
        {
            do_char(hwnd, ' ', pWData);
        }
    }
    else
    {
        do_cr(hwnd, pWData);
    }
}

static void
EchoChar(
    HWND hwnd,
    WORD cRepeats,
    WPARAM wParam,
    WData *pWData)
{
    for ( ; cRepeats; cRepeats--)
    {
        switch (wParam)
        {
        // Backspace
        case '\b':
            do_backspace(hwnd, pWData);
            break;

        // Carriage return
        case '\n':
        case '\r':
            do_cr(hwnd, pWData);
            break;

        // Tab
        case '\t':
            do_tab(hwnd, pWData);
            break;

        // Regular characters
        default:
            do_char(hwnd, wParam, pWData);
        }
    }

    // The row is guaranteed to be on the screen because we will
    // scroll on a CR. However, the next column for input may be
    // beyond the window we are working in.
    if (pWData->iNextCol > pWData->iBottomCol)
    {
        // We are out of the window so scroll the window one
        // column to the right.
        SendMessage(hwnd, WM_HSCROLL, SB_LINEDOWN, 0L);
    }
    else if (pWData->iNextCol < pWData->iFirstCol)
    {
        // We are out of the window so repaint the window using
        // iNextCol as the first column for the screen.
        pWData->iFirstCol = pWData->iNextCol;
        pWData->iBottomCol = pWData->iFirstCol + pWData->cCols - 1;

        // Reset scroll bar
        SetScrollPos(hwnd, SB_HORZ, pWData->iFirstCol, TRUE);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
    else
    {
        // Reset Caret's position
        SetCaretPos((pWData->iNextCol - pWData->iFirstCol) * pWData->cxChar,
            calc_row(pWData->iNextRow, pWData) * pWData->cyChar);
    }
}

/****************************************************************************

    FUNCTION: WmCreate(HWND)

    PURPOSE:  Initializes control structures for a TermWClass Window

    MESSAGES:
              WM_CREATE

    COMMENTS:

            This prepares a window for processing character based
            I/O. In particular it does stuff like calculate the
            size of the window needed.

****************************************************************************/
static void
WmCreate(
    HWND hwnd,
    CREATESTRUCT *pInit)
{
    WData *pData = (WData *) (pInit->lpCreateParams);
    HDC hdc = GetDC(hwnd);
    TEXTMETRIC tm;

    // Store pointer to window data
    SetWindowLong(hwnd, 0, (LONG) pData);

    // Set font to system fixed font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    // Calculate size of a character
    GetTextMetrics(hdc, &tm);
    pData->cxChar = tm.tmAveCharWidth;
    pData->cyChar = tm.tmHeight;
    ReleaseDC(hwnd, hdc);

    // Set up vertical scroll bars
    SetScrollRange(hwnd, SB_VERT, 0, MAX_ROWS, TRUE);
    SetScrollPos(hwnd, SB_VERT, 0, TRUE);

    // Set up horizontal scroll bars
    SetScrollRange(hwnd, SB_HORZ, 0, MAX_COLS, TRUE);
    SetScrollPos(hwnd, SB_HORZ, 0, TRUE);
}

/****************************************************************************

    FUNCTION: WmSize(HWND, WORD, LONG)

    PURPOSE:  Processes a size message

    MESSAGES:

    COMMENTS:

****************************************************************************/
static void
WmSize(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    // Get the new size of the window
    int cxClient;
    int cyClient;
    int cRowChange = pwdata->cRows;
    RECT rect;

    // Get size of client area
    GetClientRect(hwnd, &rect);

    // Calculate size of client area
    cxClient = rect.right - rect.left;
    cyClient = rect.bottom - rect.top;

    // Calculate size of area in rows
    pwdata->cCols = cxClient / pwdata->cxChar;
    pwdata->cRows = min(MAX_ROWS, cyClient / pwdata->cyChar);
    pwdata->iBottomCol = min(pwdata->iFirstCol + pwdata->cCols, MAX_COLS);
    cRowChange = pwdata->cRows - cRowChange;

    // Keep input line toward bottom of screen
    if (cRowChange < 0)
    {
        // Screen has shrunk in size.
        if (pwdata->iNextRow != pwdata->iTopRow)
        {
            // Has input row moved out of screen?
            if (row_diff(pwdata->iNextRow, pwdata->iTopRow) >= pwdata->cRows)
            {
                // Yes -- Calculate top new top that puts input line on
                // the bottom.
                pwdata->iTopRow =
                    inc_row(pwdata->iNextRow, 1 - pwdata->cRows);
            }
        }
    }
    else
    {
        // Screen has gotten bigger -- Display more text if possible
        if (pwdata->iTopRow != pwdata->iBufferTop)
        {
            pwdata->iTopRow = inc_row(pwdata->iTopRow,
                -(min(row_diff(pwdata->iTopRow, pwdata->iBufferTop),
                    cRowChange)));
        }
    }

    // Calculate new bottom
    pwdata->iBottomRow = inc_row(pwdata->iTopRow, pwdata->cRows - 1);

    InvalidateRect(hwnd, NULL, TRUE);
    UpdateWindow(hwnd);
}

static void
WmSetFocus(
    HWND hwnd,
    WData *pwdata)
{
    // save indirections
    register int cxchar = pwdata->cxChar;
    register int cychar = pwdata->cyChar;
    pwdata->fGotFocus = TRUE;
    CreateCaret(hwnd, NULL, cxchar, cychar);

    if (!pwdata->fCaretHidden)
    {
        SetCaretPos(pwdata->iNextCol * cxchar,
            calc_row(pwdata->iNextRow, pwdata) * cychar);
    }

    ShowCaret(hwnd);
}

static void
WmKillFocus(
    HWND hwnd,
    WData *pwdata)
{
    pwdata->fGotFocus = FALSE;

    if (!pwdata->fCaretHidden)
    {
        HideCaret(hwnd);
    }

    DestroyCaret();
}

static void
WmVscroll(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    int cVscrollInc = 0;
    register int top_diff = row_diff(pwdata->iTopRow, pwdata->iBufferTop);
    register int bottom_diff = MAX_ROWS - (top_diff + pwdata->cRows);

    switch(wParam)
    {
    case SB_TOP:

        if (top_diff != 0)
        {
            cVscrollInc = -top_diff;
        }

        break;

    case SB_BOTTOM:

        if (bottom_diff != 0)
        {
            cVscrollInc = bottom_diff;
        }

        break;

    case SB_LINEUP:

        if (top_diff != 0)
        {
            cVscrollInc = -1;
        }

        break;

    case SB_LINEDOWN:

        if (bottom_diff != 0)
        {
            cVscrollInc = 1;
        }

        break;

    case SB_PAGEUP:

        if (top_diff != 0)
        {
            cVscrollInc = - ((top_diff > pwdata->cRows)
                ? pwdata->cRows : top_diff);
        }

        break;

    case SB_PAGEDOWN:

        if (bottom_diff != 0)
        {
            cVscrollInc = (bottom_diff > pwdata->cRows)
                ? pwdata->cRows : bottom_diff;
        }

        break;

    case SB_THUMBTRACK:

        if (LOWORD(lParam) != 0)
        {
            cVscrollInc = LOWORD(lParam)
                - row_diff(pwdata->iTopRow, pwdata->iBufferTop);
        }
    }

    // Cacluate new top row
    if (cVscrollInc != 0)
    {
        // Calculate new top and bottom
        pwdata->iTopRow = inc_row(pwdata->iTopRow, cVscrollInc);
        pwdata->iBottomRow = inc_row(pwdata->iTopRow, pwdata->cRows);

        // Scroll window
        ScrollWindow(hwnd, 0, pwdata->cyChar * cVscrollInc, NULL, NULL);

        // Reset scroll bar
        set_vscroll_pos(hwnd, pwdata);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
}

static void
WmHscroll(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    register int cHscrollInc = 0;

    switch(wParam)
    {
    case SB_LINEUP:

        cHscrollInc = -1;
        break;

    case SB_LINEDOWN:

        cHscrollInc = 1;
        break;

    case SB_PAGEUP:

        cHscrollInc = -8;
        break;

    case SB_PAGEDOWN:

        cHscrollInc = 8;
        break;

    case SB_THUMBTRACK:

        if (LOWORD(lParam) != 0)
        {
            cHscrollInc = LOWORD(lParam) - pwdata->iFirstCol;
        }
    }

    if (cHscrollInc != 0)
    {
        // Cacluate new first column
        register int NormalizedScrollInc = cHscrollInc + pwdata->iFirstCol;

        if (NormalizedScrollInc < 0)
        {
            cHscrollInc = -pwdata->iFirstCol;
        }
        else if (NormalizedScrollInc > MAX_COLS - pwdata->cCols)
        {
            cHscrollInc = (MAX_COLS - pwdata->cCols) - pwdata->iFirstCol;
        }

        pwdata->iFirstCol += cHscrollInc;
        pwdata->iBottomCol = pwdata->iFirstCol + pwdata->cCols - 1;

        // Scroll window
        ScrollWindow(hwnd, -(pwdata->cxChar * cHscrollInc), 0, NULL, NULL);

        // Reset scroll bar
        SetScrollPos(hwnd, SB_HORZ, pwdata->iFirstCol, TRUE);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
}

static void
WmPaint(
    HWND hwnd,
    WData *pwdata)
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hwnd, &ps);
    register int row = pwdata->iTopRow;
    register int col = pwdata->iFirstCol;
    int bottom_row = pwdata->iBottomRow;
    int cxChar = pwdata->cxChar;
    int cyChar = pwdata->cyChar;
    int y;

    // Select System Font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    while (TRUE)
    {
	int len = lstrlen(&pwdata->aImage[row][col]);

        if (len != 0)
        {
            y = calc_row(row, pwdata) * cyChar;
	    TextOut(hdc, 0, y, &pwdata->aImage[row][col], len);
        }

        if (row == bottom_row)
        {
            break;
        }

        row = inc_row(row, 1);
    }

    if (pwdata->fGotFocus)
    {
        if ((pwdata->iNextCol >= pwdata->iFirstCol)
            && (row_diff(pwdata->iNextRow, pwdata->iTopRow) < pwdata->cRows))
        {
            if (pwdata->fCaretHidden)
            {
                pwdata->fCaretHidden = FALSE;
                ShowCaret(hwnd);
            }

            SetCaretPos(
                (pwdata->iNextCol - pwdata->iFirstCol) * pwdata->cxChar,
                calc_row(pwdata->iNextRow, pwdata) * pwdata->cyChar);
        }
        else
        {
            if (!pwdata->fCaretHidden)
            {
                pwdata->fCaretHidden = TRUE;
                HideCaret(hwnd);
            }
        }
    }

    EndPaint(hwnd, &ps);
}





//
//  FUNCTION:   WmPrintLine
//
//  PURPOSE:    Print a line on the screen.
//
//  Note: this is a user message not an intrinsic Window's message.
//
void
WmPrintLine(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pTermData)
{
    TCHAR *pBuf = (TCHAR *) lParam;

    // MessageBox(hwnd, L"WmPrintLine", L"Debug", MB_OK);

    // DebugBreak();

    while (wParam--)
    {
        // Is character a lf?
        if (*pBuf == '\n')
        {
            // Convert to cr since that is what this window uses
            *pBuf = '\r';
        }

        // Write the character to the window
        EchoChar(hwnd, 1, *pBuf++, pTermData);
    }

}

//
//  FUNCTION:   WmPutc
//
//  PURPOSE:    Print a single character on the screen
//
//  Note: this is a user message not an intrinsic Window's message.
//
void
WmPutc(
    HWND hwnd,
    WPARAM wParam,
    WData *pTermData)
{
    // Is character a lf?
    if (wParam == '\n')
    {
        // Convert to cr since that is what this window uses
        wParam = '\r';
    }

    // Write the character to the window
    EchoChar(hwnd, 1, wParam, pTermData);
}


/****************************************************************************

    FUNCTION: TermWndProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

    MESSAGES:

    COMMENTS:

****************************************************************************/

long TermWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    WData *pTerm = (WData *) GetWindowLong(hWnd, 0);

    switch (message)
    {
        case WM_CREATE:
            WmCreate(hWnd, (CREATESTRUCT *) lParam);
            break;

        case WM_COMMAND:
        case WM_SYSCOMMAND:
            // Call procedure that processes the menus
            return (*(pTerm->pMenuProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_SIZE:
            WmSize(hWnd, wParam, lParam, pTerm);
            break;

        case WM_SETFOCUS:
            WmSetFocus(hWnd, pTerm);
            break;

        case WM_KILLFOCUS:
            WmKillFocus(hWnd, pTerm);
            break;

        case WM_VSCROLL:
            WmVscroll(hWnd, wParam, lParam, pTerm);
            break;

        case WM_HSCROLL:
            WmHscroll(hWnd, wParam, lParam, pTerm);
            break;

        case WM_CHAR:
            // Character message echo and put in buffer
            return (*(pTerm->pCharProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_PAINT:
            WmPaint(hWnd, pTerm);
            break;

        case WM_CLOSE:
	    DestroyWindow(hWnd);
            break;

        case WM_NCDESTROY:
            // Call close notification procedure
            return (*(pTerm->pCloseProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_PRINT_LINE:
            WmPrintLine(hWnd, wParam, lParam, pTerm);
            break;

        case WM_PUTC:
            WmPutc(hWnd, wParam, pTerm);
	    break;

	case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

	case WM_TERM_WND:
	    DestroyWindow(hWnd);
	    break;

        default:                          /* Passes it on if unproccessed    */
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }

    return 0;
}


/****************************************************************************

    FUNCTION: TermRegisterClass(HANDLE)

    PURPOSE:  Register a class for a terminal window

    COMMENTS:


****************************************************************************/

BOOL TermRegisterClass(
    HANDLE hInstance,
    LPTSTR MenuName,
    LPTSTR ClassName,
    LPTSTR Icon)
{
    WNDCLASS  wc;
    BOOL retVal;

    // Make sure blank line is blank
    memset(BlankLine, ' ', 80);

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = 0;
    wc.lpfnWndProc = TermWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(WData *);
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, Icon);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  MenuName;
    wc.lpszClassName = ClassName;

    /* Register the window class and return success/failure code. */
    if (retVal = RegisterClass(&wc))
    {
        // Class got registered -- so finish set up
        hInst = hInstance;
    }

    return retVal;
}


/****************************************************************************

    FUNCTION:  TermCreateWindow(LPWSTR, LPWSTR, HMENU, void *, void *, int)

    PURPOSE:   Create a window of a previously registered window class

    COMMENTS:


****************************************************************************/

BOOL
TermCreateWindow(
    LPTSTR lpClassName,
    LPTSTR lpWindowName,
    HMENU hMenu,
    MFUNCP MenuProc,
    CFUNCP CharProc,
    TFUNCP CloseProc,
    int nCmdShow,
    HWND *phNewWindow,
    void *pvCallBackData)
{
    HWND            hWnd;               // Main window handle.
    WData           *pTermData;

    // Allocate control structure for the window
    if ((pTermData = malloc(sizeof(WData))) == NULL)
    {
        return FALSE;
    }

    // Set entire structure to nulls
    memset((TCHAR *) pTermData, '\0', sizeof(WData));

    // Initialize function pointers
    pTermData->pMenuProc = MenuProc;
    pTermData->pCharProc = CharProc;
    pTermData->pCloseProc = CloseProc;

    // Initialize callback data
    pTermData->pvCallBackData = pvCallBackData;

    // Create a main window for this application instance.
    hWnd = CreateWindow(
        lpClassName,
        lpWindowName,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        hMenu,
        hInst,
	(LPTSTR) pTermData
    );

    // If window could not be created, return "failure"

    if (!hWnd)
    {
        free(pTermData);
        return FALSE;
    }

    SetFocus(hWnd);

    // Make the window visible; update its client area; and return "success"

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);
    *phNewWindow = hWnd;
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf\perfsrv\perfsrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:       perfsrv.cxx
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      DllGetClassObject (Bindings key func)
//			CPerfCF (class factory)
//			CPerf   (actual class implementation)
//
//  Classes:	CPerfCF, CPerf
//
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------

// Turn off ole Cairol IUnknown
#define __IUNKNOWN_TMP__


#include    <windows.h>
#include    <ole2.h>
#include    "perfsrv.hxx"
extern "C" {
#include    <stdio.h>
#include    <stdarg.h>
#include    "wterm.h"
}

// These are Cairo symbols.  Just define them here so I don't have to rip
// out or conditionally compile all references to them.
#define COINIT_MULTITHREADED  0
#define COINIT_SINGLETHREADED 1

#define IDM_DEBUG 0x100

// Count of objects we have instantiated. When we detect 0, we quit.
ULONG g_cUsage = 0;

const TCHAR *szAppName = L"Performance Server";

HWND g_hMain;
DWORD thread_mode = COINIT_SINGLETHREADED;
DWORD MainThread;
DWORD junk;


void Display(TCHAR *pszFmt, ...)
{
    va_list marker;
    TCHAR szBuffer[256];

    va_start(marker, pszFmt);

    int iLen = vswprintf(szBuffer, pszFmt, marker);

    va_end(marker);

    // Display the message on terminal window
    SendMessage(g_hMain, WM_PRINT_LINE, iLen, (LONG) szBuffer);
}




//+-------------------------------------------------------------------------
//
//  Function:	ProcessMenu
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessMenu(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
    void *)
{
    if ((uiMessage == WM_SYSCOMMAND) && (wParam == IDM_DEBUG))
    {
	// Request for a debug breakpoint!
	DebugBreak();
    }


    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}


//+-------------------------------------------------------------------------
//
//  Function:	ProcessChar
//
//  Synopsis:	Gets called when a WM_CHAR message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessChar(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
    void *)
{
    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}


//+-------------------------------------------------------------------------
//
//  Function:	ProcessClose
//
//  Synopsis:	Gets called when a NC_DESTROY message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessClose(
    HWND hWindow,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam,
    void *pvCallBackData)
{
    // Take default action with message
    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    char *lpCmdLine,
    int nCmdShow)
{
    // For windows message
    MSG   msg;
    DWORD dwRegistration;
    int   len;
    TCHAR buffer[80];
    MainThread = GetCurrentThreadId();

    // Look up the thread mode from the win.ini file.
#if 0
    len = GetProfileString( L"My Section", L"ThreadMode", L"MultiThreaded", buffer,
                            sizeof(buffer) );
    if (lstrcmp(buffer, L"SingleThreaded") == 0)
      thread_mode = COINIT_SINGLETHREADED;
    else if (lstrcmp(buffer, L"MultiThreaded") == 0)
      thread_mode = COINIT_MULTITHREADED;
#endif

    // Initialize the OLE libraries
    OleInitialize(NULL);

    // Create our class factory
    CPerfCF *perf_cf = new CPerfCF();

    // Register our class with OLE
    CoRegisterClassObject(CLSID_IPerf, perf_cf, CLSCTX_LOCAL_SERVER,
	REGCLS_MULTIPLEUSE, &dwRegistration);

    // CoRegister bumps reference count so we don't have to!
    perf_cf->Release();

    // Register the window class
    TermRegisterClass(hInstance, (LPTSTR) szAppName,
	 (LPTSTR) szAppName, (LPTSTR) (1));

    // Create the server window
    TermCreateWindow(
	(LPTSTR) szAppName,
	(LPTSTR) szAppName,
	NULL,
	ProcessMenu,
	ProcessChar,
	ProcessClose,
	SW_SHOWNORMAL,
	&g_hMain,
	NULL);

    // Add debug option to system menu
    HMENU hmenu = GetSystemMenu(g_hMain, FALSE);

    AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hmenu, MF_STRING | MF_ENABLED, IDM_DEBUG, L"Debug");

    // Print the process id.
    Display( L"Hi, I am %x.\n", GetCurrentProcessId() );

    // Echo the mode.
    if (thread_mode == COINIT_SINGLETHREADED)
      Display(L"Server running in single threaded mode.\n");
    else
      Display(L"Server running in multithreaded mode.\n");

    // Message processing loop
    while (GetMessage (&msg, NULL, 0, 0))
    {
	TranslateMessage (&msg);
	DispatchMessage (&msg);
    }

    // Deregister out class - should release object as well
    CoRevokeClassObject(dwRegistration);

    // Tell OLE we are going away.
    OleUninitialize();

    return (msg.wParam);	   /* Returns the value from PostQuitMessage */
}



/***************************************************************************/
void CheckThread( TCHAR *name )
{
  if (thread_mode == COINIT_SINGLETHREADED)
  {
    if (GetCurrentThreadId() != MainThread)
      goto complain;
  }
  else
  {
    if (GetCurrentThreadId() == MainThread)
      goto complain;
  }
  return;

complain:
  Display( L"*********************************************************\n" );
  Display( L"*                                                       *\n" );
  Display( L"*                      Error                            *\n" );
  Display( L"*                                                       *\n" );
  Display( L"* Method called on wrong thread.                        *\n" );
  Display( name );
  Display( L"*                                                       *\n" );
  Display( L"*********************************************************\n" );
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CPerf::AddRef( THIS )
{
  CheckThread(L"STDMETHODIMP_(ULONG) CPerf::AddRef( THIS )");
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
CPerf::CPerf()
{
  ref_count = 1;
  g_cUsage++;
}

/***************************************************************************/
CPerf::~CPerf()
{
    if (--g_cUsage == 0)
    {
	SendMessage(g_hMain, WM_TERM_WND, 0, 0);
    }
}

/***************************************************************************/
STDMETHODIMP CPerf::GetAnotherObject( IPerf **another )
{
  CheckThread(L"STDMETHODIMP CPerf::GetAnotherObject( IPerf **another )");
  *another = NULL;
  CPerf *perf = new FAR CPerf();

  if (perf == NULL)
  {
    return E_OUTOFMEMORY;
  }

  *another = perf;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CPerf::HResultCall()
{
  CheckThread(L"STDMETHODIMP CPerf::HResultCall()");
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CPerf::NullCall()
{
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CPerf::PassMoniker( IMoniker *moniker )
{
  HRESULT        result;
  IBindCtx      *bindctx;
  WCHAR         *wide_name;

  // Get a bind context.
  result = CreateBindCtx( NULL, &bindctx );
  if (FAILED(result))
  {
    Display( L"Could not create bind context: 0x%x\n", result );
    return E_FAIL;
  }

  // Display name.
  result = moniker->GetDisplayName( bindctx, NULL, &wide_name );
  if (FAILED(result))
  {
    Display( L"Could not get display name: 0x%x\n", result );
    return E_FAIL;
  }

  // Display the name.
  Display( L"The moniker is called <%s>\n", wide_name );

  // Free string.
  CoTaskMemFree( wide_name );

  // Release everything.
  moniker->Release();
  bindctx->Release();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CPerf::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  CheckThread(L"STDMETHODIMP CPerf::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)" );
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_IPerf))
  {
    *ppvObj = (IUnknown *) this;
    AddRef();
    return S_OK;
  }
  else
  {
    *ppvObj = NULL;
    return E_NOINTERFACE;
  }
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CPerf::Release( THIS )
{
  CheckThread(L"STDMETHODIMP_(ULONG) CPerf::Release( THIS )");
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CPerfCF::AddRef( THIS )
{
  CheckThread(L"STDMETHODIMP_(ULONG) CPerfCF::AddRef( THIS )");
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
CPerfCF::CPerfCF()
{
  ref_count = 1;
}

/***************************************************************************/
CPerfCF::~CPerfCF()
{
}

/***************************************************************************/
STDMETHODIMP CPerfCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
  CheckThread(L"STDMETHODIMP CPerfCF::CreateInstance(" );
    Display(L"CPerfCF::CreateInstance called\n");

    *ppv = NULL;
    if (pUnkOuter != NULL)
    {
	return E_FAIL;
    }

    if (!IsEqualIID( iidInterface, IID_IPerf ))
      return E_NOINTERFACE;

    CPerf *perf = new FAR CPerf();

    if (perf == NULL)
    {
	return E_OUTOFMEMORY;
    }

    *ppv = perf;
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CPerfCF::LockServer(BOOL fLock)
{
  CheckThread( L"STDMETHODIMP CPerfCF::LockServer(BOOL fLock)" );
    return E_FAIL;
}


/***************************************************************************/
STDMETHODIMP CPerfCF::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  CheckThread(L"STDMETHODIMP CPerfCF::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)");
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_IClassFactory))
  {
    *ppvObj = (IUnknown *) this;
    AddRef();
    return S_OK;
  }

  *ppvObj = NULL;
  return E_NOINTERFACE;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CPerfCF::Release( THIS )
{
  CheckThread(L"STDMETHODIMP_(ULONG) CPerfCF::Release( THIS )");
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\client\perror.cpp ===
// This is functions used by both the
// the client and the server programs

#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdarg.h>
#include "perror.h"

LPTSTR
winErrorString(
    HRESULT hrErrorCode,
    LPTSTR sBuf,
    int cBufSize)
{
#ifdef WIN32
    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL,
                  hrErrorCode,
                  GetSystemDefaultLangID(),
                  sBuf,
                  cBufSize,
                  NULL);
#else
    wsprintf(sBuf, "\"0x%08x\"\n", hrErrorCode);
#endif // WIN32
    return sBuf;
}

#define PBUF_LEN    200

#if 0 // I'm not linking with "printf" currently.
void
print_error(
    LPTSTR sMessage,
    HRESULT hrErrorCode)
{
    TCHAR sBuf[PBUF_LEN];

    winErrorString(hrErrorCode, sMessage, PBUF_LEN);
#ifdef WIN32
    printf("%s(0x%x)%s", sMessage, hrErrorCode, sBuf);
#else
    printf("%s%s", sMessage, sBuf);
#endif
}
#endif

void
perror_OKBox(
    HWND hwnd,
    LPTSTR sTitle,
    HRESULT hrErrorCode)
{
    TCHAR sBuf[PBUF_LEN];
    TCHAR sBuf2[PBUF_LEN];

    winErrorString(hrErrorCode, sBuf, PBUF_LEN);
    wsprintf(sBuf2, TEXT("%s(%08x)"), sBuf, hrErrorCode);
    MessageBox(hwnd, sBuf2, sTitle, MB_OK);
}

void
wprintf_OKBox(
    HWND hwnd,
    LPTSTR sTitle,
    LPTSTR sFormat,
    ...)
{
    TCHAR sBuf[PBUF_LEN];
    va_list vaMarker;

    va_start( vaMarker, sFormat );
    wvsprintf(sBuf, sFormat, vaMarker);
    MessageBox(hwnd, sBuf, sTitle, MB_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\client\datausr.cpp ===
/*
 * DATAUSER.CPP
 * Data Object User Chapter 6
 *
 * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#define INIT_MY_GUIDS
#include "datausr.h"
#include "perror.h"
#include <stdio.h>

#ifdef WIN32
#define APP_TITLE TEXT("32 Bit IDataObject User")
#else
#define APP_TITLE TEXT("16 Bit IDataObject User")
#endif

//These are for displaying clipboard formats textually.
static TCHAR * rgszCF[13]={TEXT("Unknown"), TEXT("CF_TEXT")
                 , TEXT("CF_BITMAP"), TEXT("CF_METAFILEPICT")
                 , TEXT("CF_SYLK"), TEXT("CF_DIF"), TEXT("CF_TIFF")
                 , TEXT("CF_OEMTEXT"), TEXT("CF_DIB")
                 , TEXT("CF_PALETTE"), TEXT("CF_PENDATA")
                 , TEXT("CF_RIFF"), TEXT("CF_WAVE")};


static TCHAR szSuccess[]    =TEXT("succeeded");
static TCHAR szFailed[]     =TEXT("failed");
static TCHAR szExpected[]   =TEXT("expected");
static TCHAR szUnexpected[] =TEXT("unexpected!");

TCHAR tcMessageBuf[4096]; // Misc use buffer for messages.
int cKSizes[NUM_POINTS] = { 1,  2,  4,  6,  8,
                           10, 12, 16, 20, 24,
                           28, 32, 40, 48, 56 };

/*
 * WinMain
 *
 * Purpose:
 *  Main entry point of application.
 */

int PASCAL WinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR pszCmdLine,
    int nCmdShow)
{
    MSG         msg;
    PAPPVARS    pAV;

#ifndef WIN32
    int         cMsg=96;

    while (!SetMessageQueue(cMsg) && (cMsg-=8));
#endif

    pAV=new CAppVars(hInst, hInstPrev, nCmdShow);

    if (NULL==pAV)
        return -1;

    if (pAV->FInit())
    {
        while (GetMessage(&msg, NULL, 0,0 ))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    delete pAV;
    return msg.wParam;
}




/*
 * DataUserWndProc
 *
 * Purpose:
 *  Window class procedure.  Standard callback.
 */

LRESULT API_ENTRY DataUserWndProc(HWND hWnd, UINT iMsg
    , WPARAM wParam, LPARAM lParam)
    {
    HRESULT         hr;
    PAPPVARS        pAV;
    HMENU           hMenu;
    FORMATETC       fe;
    WORD            wID;
    int             i;

    pAV=(PAPPVARS)GetWindowLong(hWnd, DATAUSERWL_STRUCTURE);

    switch (iMsg)
        {
        case WM_NCCREATE:
            pAV=(PAPPVARS)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLong(hWnd, DATAUSERWL_STRUCTURE, (LONG)pAV);
            return (DefWindowProc(hWnd, iMsg, wParam, lParam));

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case WM_PAINT:
            pAV->Paint();
            break;

        case WM_COMMAND:
            SETDefFormatEtc(fe, 0, TYMED_HGLOBAL | TYMED_GDI| TYMED_MFPICT);

            hMenu=GetMenu(hWnd);
            wID=LOWORD(wParam);

            if(wID >= IDM_OBJECTSETDATA && wID <= IDM_OBJECTSETDATA+64)
            {
                // Blast all possible SetData menu items. Some don't exist.
                for(i=IDM_OBJECTSETDATA; i<=IDM_OBJECTSETDATA+64; i++)
                    CheckMenuItem(hMenu,i, MF_UNCHECKED);
                CheckMenuItem(hMenu, wID, MF_CHECKED);

                pAV->m_SetData_SetSize(wID-IDM_OBJECTSETDATA);
                break;
            }

            switch (wID)
            {
            case IDM_USE16BITSERVER:
                if (pAV->m_f16Bit)
                    break;
                pAV->m_f16Bit = TRUE;
                pAV->FReloadDataObjects(TRUE);
                break;

            case IDM_USE32BITSERVER:
                if (!pAV->m_f16Bit)
                    break;
                pAV->m_f16Bit = FALSE;
                pAV->FReloadDataObjects(TRUE);
                break;

            case IDM_OBJECTQUERYGETDATA:
                if (NULL==pAV->m_pIDataObject)
                    break;

                fe.tymed=TYMED_HGLOBAL | TYMED_GDI
                     | TYMED_MFPICT;

                pAV->TryQueryGetData(&fe, CF_TEXT, TRUE, 0);
                pAV->TryQueryGetData(&fe, CF_BITMAP, TRUE, 1);
#ifdef NOT_SIMPLE
                pAV->TryQueryGetData(&fe, CF_DIB, FALSE, 2);
                pAV->TryQueryGetData(&fe, CF_METAFILEPICT, TRUE, 3);
                pAV->TryQueryGetData(&fe, CF_WAVE, FALSE, 4);
#endif /* NOT_SIMPLE */
                break;


            case IDM_OBJECTGETDATA_TEXT:
            case IDM_OBJECTGETDATA_BITMAP:
#ifdef NOT_SIMPLE
            case IDM_OBJECTGETDATA_METAFILEPICT:
#endif /* NOT_SIMPLE */
                if (pAV->m_GetData(wID) )
                {
                    InvalidateRect(hWnd, NULL, TRUE);
                    UpdateWindow(hWnd);
                }

                if(pAV->m_fDisplayTime)
                    pAV->m_DisplayTimerResults();
                break;

            case IDM_OBJECTGETDATAHERE_TEXT:
            case IDM_OBJECTGETDATAHERE_NULLTEXT:
            case IDM_OBJECTGETDATAHERE_BITMAP:
            case IDM_OBJECTGETDATAHERE_NULLBITMAP:
                if (pAV->m_GetDataHere(wID) )
                {
                    InvalidateRect(hWnd, NULL, TRUE);
                    UpdateWindow(hWnd);
                }

                if(pAV->m_fDisplayTime)
                    pAV->m_DisplayTimerResults();
                break;

            case IDM_OBJECTSETDATAPUNK_TEXT:
            case IDM_OBJECTSETDATAPUNK_BITMAP:
                pAV->m_SetData_WithPUnk(wID);
                break;

            case IDM_MEASUREMENT_1:
            case IDM_MEASUREMENT_50:
            case IDM_MEASUREMENT_300:
            case IDM_MEASUREMENT_OFF:
            case IDM_MEASUREMENT_ON:
            case IDM_MEASUREMENT_TEST:
                pAV->m_SetMeasurement(wID);
                break;

            case IDM_BATCH_GETDATA:
                pAV->m_MeasureAllSizes(IDM_OBJECTGETDATA_TEXT,
                                    TEXT("GetData w/HGLOBAL"),
                                    NULL);
                break;

            case IDM_BATCH_GETDATAHERE:
                pAV->m_MeasureAllSizes(IDM_OBJECTGETDATAHERE_TEXT,
                                    TEXT("GetDataHere w/HGLOBAL"),
                                    NULL);
                break;

            case IDM_BATCHTOFILE:
                pAV->m_BatchToFile();
                break;

            case IDM_OBJECTEXIT:
                PostMessage(hWnd, WM_CLOSE, 0, 0L);
                break;

#ifdef NOT_SIMPLE
            case IDM_ADVISETEXT:
            case IDM_ADVISEBITMAP:
            case IDM_ADVISEMETAFILEPICT:
                if (NULL==pAV->m_pIDataObject)
                    break;

                //Terminate the old connection
                if (0!=pAV->m_dwConn)
                    {
                    pAV->m_pIDataObject->DUnadvise(pAV
                        ->m_dwConn);
                    }

                CheckMenuItem(hMenu, pAV->m_cfAdvise
                    +IDM_ADVISEMIN, MF_UNCHECKED);
                CheckMenuItem(hMenu, wID, MF_CHECKED);

                //New format is wID-IDM_ADVISEMIN
                pAV->m_cfAdvise=(UINT)(wID-IDM_ADVISEMIN);
                fe.cfFormat=pAV->m_cfAdvise;
                pAV->m_pIDataObject->DAdvise(&fe, ADVF_NODATA
                    , pAV->m_pIAdviseSink, &pAV->m_dwConn);

                break;

            case IDM_ADVISEGETDATA:
                pAV->m_fGetData=!pAV->m_fGetData;
                CheckMenuItem(hMenu, wID, pAV->m_fGetData
                    ? MF_CHECKED : MF_UNCHECKED);
                break;

            case IDM_ADVISEREPAINT:
                pAV->m_fRepaint=!pAV->m_fRepaint;
                CheckMenuItem(hMenu, wID, pAV->m_fRepaint
                    ? MF_CHECKED : MF_UNCHECKED);
                break;
#endif /* NOT_SIMPLE*/
            default:
                break;
            }
            break;

        default:
            return (DefWindowProc(hWnd, iMsg, wParam, lParam));
        }

    return 0L;
    }


/*
 * CAppVars::CAppVars
 * CAppVars::~CAppVars
 *
 * Constructor Parameters: (from WinMain)
 *  hInst           HINSTANCE of the application.
 *  hInstPrev       HINSTANCE of a previous instance.
 *  nCmdShow        UINT specifying how to show the app window.
 */

CAppVars::CAppVars(HINSTANCE hInst, HINSTANCE hInstPrev
    , UINT nCmdShow)
    {
    m_hInst       =hInst;
    m_hInstPrev   =hInstPrev;
    m_nCmdShow    =nCmdShow;

    m_hWnd        =NULL;
#ifdef NOT_SIMPLE
    m_fEXE        =FALSE;

    m_pIAdviseSink =NULL;
    m_dwConn       =0;
    m_cfAdvise     =0;
    m_fGetData     =FALSE;
    m_fRepaint     =FALSE;

    m_pIDataSmall =NULL;
    m_pIDataMedium=NULL;
    m_pIDataLarge =NULL;
#endif /* NOT_SIMPLE */
    m_pIDataObject=NULL;
    m_f16Bit=FALSE;
    m_cfFormat=0;
    m_stm.tymed=TYMED_NULL;
    m_stm.lpszFileName=NULL;      //Initializes union to NULL
    m_stm.pUnkForRelease=NULL;

    m_HereAllocCount=0; // For debugging

    m_fInitialized=FALSE;
    return;
    }



CAppVars::~CAppVars(void)
    {
    //This releases the data object interfaces and advises
    FReloadDataObjects(FALSE);

    ReleaseStgMedium(&m_stm);

#ifdef NOT_SIMPLE
    if (NULL!=m_pIAdviseSink)
        m_pIAdviseSink->Release();
#endif /* NOT_SIMPLE */

    if (IsWindow(m_hWnd))
        DestroyWindow(m_hWnd);

    if (m_fInitialized)
        CoUninitialize();

    return;
    }



/*
 * CAppVars::FInit
 *
 * Purpose:
 *  Initializes an CAppVars object by registering window classes,
 *  creating the main window, and doing anything else prone to
 *  failure such as calling CoInitialize.  If this function fails
 *  the caller should insure that the destructor is called.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 */

BOOL CAppVars::FInit(void)
    {
    WNDCLASS    wc;
    DWORD       dwVer;
    BOOL        fRet;

    dwVer=CoBuildVersion();

    if (rmm!=HIWORD(dwVer))
        return FALSE;

    if (FAILED(CoInitialize(NULL)))
        return FALSE;

    m_fInitialized=TRUE;

    //Register our window classes.
    if (!m_hInstPrev)
        {
        wc.style          = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc    = DataUserWndProc;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = CBWNDEXTRA;
        wc.hInstance      = m_hInst;
        wc.hIcon          = LoadIcon(m_hInst, TEXT("Icon"));
        wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName   = MAKEINTRESOURCE(IDR_MENU);
        wc.lpszClassName  = TEXT("DATAUSER");

        if (!RegisterClass(&wc))
            return FALSE;
        }

    //Create the main window.
    m_hWnd=CreateWindow(TEXT("DATAUSER"),
                        APP_TITLE,
                        WS_OVERLAPPEDWINDOW,
                        35, 35, 350, 250,
                        NULL, NULL,
                        m_hInst, this);

    if (NULL==m_hWnd)
        return FALSE;

    ShowWindow(m_hWnd, m_nCmdShow);
    UpdateWindow(m_hWnd);

    m_iDataSizeIndex=1;
    CheckMenuItem(GetMenu(m_hWnd), IDM_OBJECTSETDATA+1, MF_CHECKED);
    for(int i=0; i<64; i++)
        m_hgHereBuffers[i] = NULL;

    m_cIterations = 1;
    CheckMenuItem(GetMenu(m_hWnd), IDM_MEASUREMENT_1,   MF_CHECKED);

    m_fDisplayTime = FALSE;
    CheckMenuItem(GetMenu(m_hWnd), IDM_MEASUREMENT_OFF, MF_CHECKED);

#ifdef NOT_SIMPLE
    m_pIAdviseSink=new CImpIAdviseSink(this);

    if (NULL==m_pIAdviseSink)
        return FALSE;

    m_pIAdviseSink->AddRef();

    CheckMenuItem(GetMenu(m_hWnd), IDM_OBJECTUSEDLL, MF_CHECKED);
    CheckMenuItem(GetMenu(m_hWnd), IDM_OBJECTDATASIZESMALL
        , MF_CHECKED);
#endif /* NOT_SIMPLE */

    //Load the initial objects
    fRet=FReloadDataObjects(TRUE);
#ifdef NOT_SIMPLE
    m_pIDataObject=m_pIDataSmall;
#endif /* NOT_SIMPLE */

    m_swTimer.m_ClassInit();

    return fRet;
    }


/*
 * CAppVars::FReloadDataObjects
 *
 * Purpose:
 *  Releases the old data objects we're holding on to and reloads
 *  the new ones from either EXE or DLL depending on m_fEXE.
 *
 * Parameters:
 *  fReload         BOOL indicating if we are to recreate everything
 *                  or just release the old ones (so we can use this
 *                  from the destructor).
 *
 * Return Value:
 *  BOOL            TRUE if there are usable objects in us now.
 */

BOOL CAppVars::FReloadDataObjects(BOOL fReload)
    {
    HCURSOR     hCur, hCurT;

    //Clean out any data we're holding
    m_cfFormat=0;
    ReleaseStgMedium(&m_stm);

    //Turn off whatever data connection we have
#ifdef NOT_SIMPLE
    if (NULL!=m_pIDataObject && 0!=m_dwConn)
        m_pIDataObject->DUnadvise(m_dwConn);

    if (NULL!=m_pIDataLarge)
        m_pIDataLarge->Release();

    if (NULL!=m_pIDataMedium)
        m_pIDataMedium->Release();

    if (NULL!=m_pIDataSmall)
        m_pIDataSmall->Release();
#else /* IS SIMPLE */
    if (NULL != m_pIDataObject)
        m_pIDataObject->Release();
#endif /* NOT_SIMPLE */

    m_pIDataObject=NULL;
    CoFreeUnusedLibraries();

    //Exit if we just wanted to free.
    if (!fReload)
        return FALSE;


    hCur=LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
    hCurT=SetCursor(hCur);
    ShowCursor(TRUE);

#ifdef NOT_SIMPLE
    HRESULT     hr1, hr2, hr3;
    DWORD       dwClsCtx;

    dwClsCtx=(m_fEXE) ? CLSCTX_LOCAL_SERVER : CLSCTX_INPROC_SERVER;

    hr1=CoCreateInstance(CLSID_DataObjectSmall, NULL, dwClsCtx
        , IID_IDataObject, (PPVOID)&m_pIDataSmall);

    hr2=CoCreateInstance(CLSID_DataObjectMedium, NULL, dwClsCtx
        , IID_IDataObject, (PPVOID)&m_pIDataMedium);

    hr3=CoCreateInstance(CLSID_DataObjectLarge, NULL, dwClsCtx
        , IID_IDataObject, (PPVOID)&m_pIDataLarge);
#else /* IS SIMPLE */
    HRESULT     hr;

    if(m_f16Bit)
    {
        hr = CoCreateInstance(CLSID_DataObjectTest16,
                                NULL,
                                CLSCTX_LOCAL_SERVER,
                                IID_IDataObject,
                                (PPVOID)&m_pIDataObject);
    }else
    {
        hr = CoCreateInstance(CLSID_DataObjectTest32,
                                NULL,
                                CLSCTX_LOCAL_SERVER,
                                IID_IDataObject,
                                (PPVOID)&m_pIDataObject);
    }

#endif /* NOT_SIMPLE */

    ShowCursor(FALSE);
    SetCursor(hCurT);

    //If anything fails, recurse to clean up...
#ifdef NOT_SIMPLE
    if (FAILED(hr1) || FAILED(hr2) || FAILED(hr3))
#else /* IS SIMPLE */
    if (FAILED(hr))
#endif /* NOT_SIMPLE */
    {
        perror_OKBox(0, TEXT("CoCreateInstance Failed: "), hr);
        return FReloadDataObjects(FALSE);
    }

    HMENU hMenu = GetMenu(m_hWnd);
    UINT        uTempD, uTempE;

    if(m_f16Bit)
    {
        CheckMenuItem(hMenu, IDM_USE16BITSERVER, MF_CHECKED);
        CheckMenuItem(hMenu, IDM_USE32BITSERVER, MF_UNCHECKED);
    }
    else
    {
        CheckMenuItem(hMenu, IDM_USE16BITSERVER, MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_USE32BITSERVER, MF_CHECKED);
    }


    hMenu=GetMenu(m_hWnd);
    for(int i=IDM_OBJECTSETDATA; i<=IDM_OBJECTSETDATA+64; i++)
    {
        CheckMenuItem(hMenu, i, MF_UNCHECKED);
    }
    m_iDataSizeIndex = 1;
    CheckMenuItem(hMenu,
                  IDM_OBJECTSETDATA + m_iDataSizeIndex,
                  MF_CHECKED);

    //Reset the state of the menus for Small, no advise, no options.
#ifdef NOT_SIMPLE
    CheckMenuItem(hMenu, IDM_OBJECTDATASIZESMALL,  MF_CHECKED);
    CheckMenuItem(hMenu, IDM_OBJECTDATASIZEMEDIUM, MF_UNCHECKED);
    CheckMenuItem(hMenu, IDM_OBJECTDATASIZELARGE,  MF_UNCHECKED);

    m_pIDataObject=m_pIDataSmall;
    CheckMenuItem(hMenu, m_cfAdvise+IDM_ADVISEMIN, MF_UNCHECKED);

    uTempE=m_fEXE  ? MF_CHECKED : MF_UNCHECKED;
    uTempD=!m_fEXE ? MF_CHECKED : MF_UNCHECKED;

    CheckMenuItem(hMenu, IDM_OBJECTUSEDLL, uTempD);
    CheckMenuItem(hMenu, IDM_OBJECTUSEEXE, uTempE);

    CheckMenuItem(hMenu, IDM_ADVISEGETDATA, MF_UNCHECKED);
    CheckMenuItem(hMenu, IDM_ADVISEREPAINT, MF_UNCHECKED);

    m_fGetData=FALSE;
    m_fRepaint=FALSE;

    //Cannot request data using async advises, so disable these.
    uTempE=m_fEXE  ? MF_DISABLED | MF_GRAYED : MF_ENABLED;
    EnableMenuItem(hMenu,  IDM_ADVISEGETDATA, uTempE);
    EnableMenuItem(hMenu, IDM_ADVISEREPAINT, uTempE);
#endif /* NOT_SIMPLE */
    return TRUE;
    }



/*
 * CAppVars::TryQueryGetData
 *
 * Purpose:
 *  Centralized function call and output code for displaying results
 *  of various IDataObject::QueryGetData calls.
 *
 * Parameters:
 *  pFE             LPFORMATETC to test.
 *  cf              UINT specific clipboard format to stuff in pFE
 *                  before calling.  If zero, use whatever is
 *                  already in pFE.
 *  fExpect         BOOL indicating expected results
 *  y               UINT line on which to print results.
 *
 * Return Value:
 *  None
 */

void CAppVars::TryQueryGetData(LPFORMATETC pFE, UINT cf
    , BOOL fExpect, UINT y)
    {
    TCHAR       szTemp[80];
    LPTSTR      psz1;
    LPTSTR      psz2;
    UINT        cch;
    HRESULT     hr;
    HDC         hDC;

    if (0!=cf)
        pFE->cfFormat=cf;

    hr=m_pIDataObject->QueryGetData(pFE);
    psz1=(NOERROR==hr) ? szSuccess : szFailed;
    psz2=((NOERROR==hr)==fExpect) ? szExpected : szUnexpected;

    hDC=GetDC(m_hWnd);
    SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hDC, GetSysColor(COLOR_WINDOW));

    if (CF_WAVE < cf || 0==cf)
        {
        cch=wsprintf(szTemp, TEXT("QueryGetData on %d %s (%s).")
            , cf, psz1, psz2);
        }
    else
        {
        cch=wsprintf(szTemp, TEXT("QueryGetData on %s %s (%s).")
            , (LPTSTR)rgszCF[cf], psz1, psz2);
        }

    //Don't overwrite other painted display.
    SetBkMode(hDC, TRANSPARENT);
    TextOut(hDC, 0, 16*y, szTemp, cch);

    ReleaseDC(m_hWnd, hDC);

    return;
    }


int
CAppVars::m_GetData(WORD wID)
{
    FORMATETC   fe;
    HRESULT     hr;

    if (NULL == m_pIDataObject)
        return(0);  // Don't redraw.

    //Clean up whatever we currently have.
    m_cfFormat = 0;
    ReleaseStgMedium(&m_stm);

    switch (wID)
    {
    case IDM_OBJECTGETDATA_TEXT:
        SETDefFormatEtc(fe, CF_TEXT, TYMED_HGLOBAL);
        break;

#ifdef NOT_SIMPLE
    case IDM_OBJECTGETDATA_BITMAP:
        SETDefFormatEtc(fe, CF_BITMAP, TYMED_GDI);
        break;

    case IDM_OBJECTGETDATA_METAFILEPICT:
        SETDefFormatEtc(fe, CF_METAFILEPICT, TYMED_MFPICT);
        break;
#endif /* NOT_SIMPLE */

    default:
        MessageBox(0,
                   TEXT("Type is Unsupported in the Client"),
                   TEXT("GetData"),
                   MB_OK);
        return(0);
    }

    m_swTimer.m_Start();
    HRESULT didfail = NOERROR;

    for(int i=0; i<m_cIterations; i++)
    {
        hr = m_pIDataObject->GetData(&fe, &m_stm);
        if (SUCCEEDED(hr))
        {
            // If we are just whacking off for the benchmark.
            // Then release all but the last one we recieve.
            if(i < m_cIterations-1)
                ReleaseStgMedium(&m_stm);
        }
        else
            didfail = hr;
    }
    m_swTimer.m_Stop();

    if (SUCCEEDED(didfail))
        m_cfFormat=fe.cfFormat;
    else
    {
        perror_OKBox(0,
                     TEXT("GetData Failed"),
                     didfail);
    }

    return(1);  // Do redraw even if it failed (draw blank).
}


int
CAppVars::m_GetDataHere(WORD wID)
{
    FORMATETC   fe;
    HRESULT     hr;

    if(NULL == m_pIDataObject)
        return(0);      // Don't redraw

    m_cfFormat = 0;

    // Don't Release the STGMedium.  We recycle them!

    switch(wID)
    {
    case IDM_OBJECTGETDATAHERE_TEXT:
        SETDefFormatEtc(fe, CF_TEXT, TYMED_HGLOBAL);
        break;

    case IDM_OBJECTGETDATAHERE_NULLTEXT:
        SETDefFormatEtc(fe, CF_TEXT, TYMED_NULL);
        break;

        /* Other cases go here....  */

    default:
        MessageBox(0,
                   TEXT("Type is Unsupported in the Client"),
                   TEXT("GetDataHere"),
                   MB_OK);
        return(0);
    }

    HGLOBAL* phg = &m_hgHereBuffers[m_iDataSizeIndex];
    if(NULL == *phg)
    {
        ++m_HereAllocCount;
        *phg = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE,
                           DATASIZE_FROM_INDEX(m_iDataSizeIndex) );
        if(NULL == *phg)
        {
            MessageBox(0,
                       TEXT("GlobalAlloc Return NULL"),
                       TEXT("Failure"),
                       MB_OK);
            PostQuitMessage(0);
            return(0);      // Don't redraw
        }
    }

    m_stm.hGlobal=*phg;
    m_stm.tymed=TYMED_HGLOBAL;
    m_stm.pUnkForRelease=NULL;

    // The TYMED_NULL case tests code in olethk where it is written:
    // "If tymed == TYMED_NULL then GetDataHere should behave like GetData."
    // I can't find this in any manual (OLE2 or Ole).  I wanted to see what
    // good that code was.  (there is also bug #15974) Aug 8th 1995 BChapman.

    if (IDM_OBJECTGETDATAHERE_NULLTEXT == wID)
    {
        m_stm.hGlobal=NULL;
        m_stm.tymed=TYMED_NULL;
    }

    // The other side "knows" the size of the data.
    // (It is told via. SetData)

    HRESULT didfail = NOERROR;
    m_swTimer.m_Start();
    for(int i=0; i<m_cIterations; i++)
    {
        hr = m_pIDataObject->GetDataHere(&fe, &m_stm);
        if (FAILED(hr))
            didfail = hr;
        // We don't ReleaseSTGMedium because this
        // is GetDataHere !
    }
    m_swTimer.m_Stop();

    if (SUCCEEDED(didfail))
        m_cfFormat=fe.cfFormat;
    else
    {
        perror_OKBox(0,
                     TEXT("GetDataHere Failed"),
                     didfail);
    }
    return(1);  // redraw (if FAILED(hr) then draw blank)
}


int
CAppVars::m_SetData_SetSize(long iSizeIndex)
{
    FORMATETC   fe;
    HRESULT     hr;

    if (NULL == m_pIDataObject)
        return 0;

    SETDefFormatEtc(fe, CF_TEXT, TYMED_HGLOBAL);

    m_iDataSizeIndex = iSizeIndex;

    HGLOBAL hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(ULONG) );
    if(NULL == hMem)
    {
        MessageBox(0,
                   TEXT("GlobalAlloc Return NULL"),
                   TEXT("Failure"),
                   MB_OK);
        PostQuitMessage(0);
        return 0;
    }

    long* pl=(long*)GlobalLock(hMem);       // Lock
    *((long*)pl) = DATASIZE_FROM_INDEX(m_iDataSizeIndex);
    GlobalUnlock(hMem);                     // Unlock

    m_stm.hGlobal=hMem;
    m_stm.tymed=TYMED_HGLOBAL;
    m_stm.pUnkForRelease=NULL;

    hr = m_pIDataObject->SetData(&fe, &m_stm, FALSE);   // Keep Ownership.
    if (FAILED(hr))
    {
        perror_OKBox(0,
                     TEXT("SetData Failed"),
                     hr);
        return 0;
    }
    return 1;;
    // release the hMem HGLOBAL perhaps ???
}


int
CAppVars::m_SetData_WithPUnk(WORD wID)
{
    FORMATETC   fe;
    HRESULT     hr;

    if(NULL == m_pIDataObject)
        return 0;

    switch(wID)
    {
    case IDM_OBJECTSETDATAPUNK_TEXT:
        SETDefFormatEtc(fe, CF_TEXT, TYMED_HGLOBAL);
        break;

        /* Other cases go here....  */

    default:
        MessageBox(0,
                   TEXT("Type is Unsupported in the Client"),
                   TEXT("SetData"),
                   MB_OK);
        return(0);
    }

    HGLOBAL hMem=GlobalAlloc( GMEM_SHARE | GMEM_MOVEABLE, sizeof(ULONG) );
    if(NULL == hMem)
    {
        MessageBox(0,
                   TEXT("GlobalAlloc Return NULL"),
                   TEXT("Failure"),
                   MB_OK);
        PostQuitMessage(0);
        return 0;
    }

    long* pl=(long*)GlobalLock(hMem);   // Lock
    *((long*)pl) = 0xffffffff;          // Use
    GlobalUnlock(hMem);                 // Unlock


    m_stm.hGlobal=hMem;
    m_stm.tymed=TYMED_HGLOBAL;
    hr = GetStgMedpUnkForRelease(&m_stm.pUnkForRelease);
    if(NOERROR != hr)
    {
        perror_OKBox(0, TEXT("Can't get pUnk For Release"), hr);
    }

    hr = m_pIDataObject->SetData(&fe, &m_stm, TRUE);   // Pass Ownership.
    // We passed ownership so SetData took the HGLOBAL from us.
    if (FAILED(hr))
    {
        perror_OKBox(0,
                     TEXT("SetData Failed"),
                     hr);
        return 0;
    }
    return 1;
}

#define NUM_RUNS 5


void
CAppVars::m_BatchToFile()
{
    dataset_t dsGetDataText;
    dataset_t dsGetDataHereText;

    pm_ClearDataset(&dsGetDataText);
    pm_ClearDataset(&dsGetDataHereText);

    int iRun;
    for(iRun=0; iRun < NUM_RUNS; iRun++)
    {
        m_MeasureAllSizes(IDM_OBJECTGETDATA_TEXT,
                          NULL,
                          &dsGetDataText);
        m_MeasureAllSizes(IDM_OBJECTGETDATAHERE_TEXT,
                          NULL,
                          &dsGetDataHereText);
    }

    FILE *fp;
    int i;
    if(NULL == (fp = fopen(FILENAME, "w")))
    {
        MessageBox(0, TEXT("Cannot Open Output File"),
                      TEXT(FILENAME),
                      MB_OK | MB_ICONSTOP);
        return;
    }

    fprintf(fp, "           GetData w/ HGLOBAL    GetDataHere w/ HGLOBAL\n");
    fprintf(fp, " Size      Best   Worst Average   Best    Worst Average\n");
    for (i=0; i<NUM_POINTS; i++)
    {
        fprintf(fp, "%5d\t", cKSizes[i]);
#define PR_TIME(fp, v)    (fprintf(fp, "%3lu.%03lu\t", (v)/1000, (v)%1000))

        PR_TIME(fp, dsGetDataText.cBest[i]);
        PR_TIME(fp, dsGetDataText.cWorst[i]);
        PR_TIME(fp, dsGetDataText.cTotal[i]/NUM_RUNS);
        PR_TIME(fp, dsGetDataHereText.cBest[i]);
        PR_TIME(fp, dsGetDataHereText.cWorst[i]);
        PR_TIME(fp, dsGetDataHereText.cTotal[i]/NUM_RUNS);
        fprintf(fp, "\n");
    }
    fclose(fp);

    MessageBox(0, TEXT("Output Written to file.dat!"),
                  TEXT("Done"), MB_OK);
}

void
CAppVars::pm_ClearDataset(dataset_t *ds)
{
    int i;
    for(i=0; i<NUM_POINTS; i++)
    {
        ds->cTotal[i] = 0;
        ds->cBest[i] = 0xFFFFFFFF;
        ds->cWorst[i] = 0;
    }
}


void
CAppVars::m_MeasureAllSizes(
    WORD wID,
    LPTSTR tstrTitle,
    dataset_t *ds)
{
    int i;
    ULONG cUSecs[NUM_POINTS];

    // Save some state.
    ULONG iOldDataSizeIndex = m_iDataSizeIndex;

    for (i=0; i<NUM_POINTS; i++)
    {
        m_SetData_SetSize(cKSizes[i]);

        switch(wID)
        {
            case IDM_OBJECTGETDATA_TEXT:
            case IDM_OBJECTGETDATA_BITMAP:
                m_GetData(wID);
                break;

            case IDM_OBJECTGETDATAHERE_TEXT:
            case IDM_OBJECTGETDATAHERE_BITMAP:
                m_GetDataHere(wID);
                break;
        }
        m_swTimer.m_Read(&cUSecs[i]);
        cUSecs[i] /= m_cIterations;
    }

    // Restore save state.
    m_iDataSizeIndex = iOldDataSizeIndex;
    m_SetData_SetSize(m_iDataSizeIndex);


    // If the caller provided memory then return the data in it.
    if(NULL != ds)
    {
        for (i=0; i<NUM_POINTS; i++)
        {
            ds->cData[i] = cUSecs[i];
            ds->cTotal[i] += cUSecs[i];

            if(ds->cBest[i] > cUSecs[i])
                ds->cBest[i] = cUSecs[i];
            if( ds->cWorst[i] < cUSecs[i])
                ds->cWorst[i] = cUSecs[i];
        }
    }

    // If the caller passed a NULL Title then no message box.
    if(NULL == tstrTitle)
        return;

    // Render Results.
    LPTSTR tstr = &tcMessageBuf[0];
    for (i=0; i<NUM_POINTS; i++)
    {
        wsprintf(tstr, TEXT("%dK: %lu.%03lu%c"),
                        cKSizes[i], cUSecs[i]/1000, cUSecs[i]%1000,
                        (i%4==3)? TEXT('\n'):TEXT('\t') );
        tstr += lstrlen(tstr);
    }
    MessageBox(0, tcMessageBuf, tstrTitle, MB_OK);
}



void
CAppVars::m_SetMeasurement(WORD wID)
{
    HMENU hMenu=GetMenu(m_hWnd);
    switch (wID)
    {
    case IDM_MEASUREMENT_ON:
        m_fDisplayTime = TRUE;
        CheckMenuItem(hMenu, IDM_MEASUREMENT_ON,  MF_CHECKED);
        CheckMenuItem(hMenu, IDM_MEASUREMENT_OFF, MF_UNCHECKED);
        break;

    case IDM_MEASUREMENT_OFF:
        m_fDisplayTime = FALSE;
        CheckMenuItem(hMenu, IDM_MEASUREMENT_ON,  MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_MEASUREMENT_OFF, MF_CHECKED);
        break;


    case IDM_MEASUREMENT_1:
        m_cIterations = 1;
        goto set_menu;
    case IDM_MEASUREMENT_50:
        m_cIterations = 50;
        goto set_menu;
    case IDM_MEASUREMENT_300:
        m_cIterations = 300;
        goto set_menu;
set_menu:
        CheckMenuItem(hMenu, IDM_MEASUREMENT_1,   MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_MEASUREMENT_50,  MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_MEASUREMENT_300, MF_UNCHECKED);
        CheckMenuItem(hMenu, wID, MF_CHECKED);
        break;


    case IDM_MEASUREMENT_TEST:
        m_swTimer.m_Start();
        m_swTimer.m_Sleep(777);
        m_swTimer.m_Stop();
        m_DisplayTimerResults();
        break;
    }
}

void
CAppVars::m_DisplayTimerResults()
{
    ULONG usecs;
    m_swTimer.m_Read(&usecs);
    usecs /= m_cIterations;
    wprintf_OKBox(0, TEXT("MilliSeconds"),
                     TEXT("%lu.%03lu"),
                     usecs/1000, usecs%1000);
}


/*
 * CAppVars::Paint
 *
 * Purpose:
 *  Handles WM_PAINT for the main window by drawing whatever
 *  data we have sitting in the STGMEDIUM at this time.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void CAppVars::Paint(void)
    {
    PAINTSTRUCT     ps;
    HDC             hDC;
#ifdef NOT_SIMPLE
    HDC             hMemDC;
    LPMETAFILEPICT  pMF;
#endif /* NOT_SIMPLE */
    LPTSTR          psz;
    RECT            rc;
    FORMATETC       fe;

    GetClientRect(m_hWnd, &rc);

    hDC=BeginPaint(m_hWnd, &ps);

    //May need to retrieve the data with EXE objects
#ifdef NOT_SIMPLE
    if (m_fEXE)
        {
        if (TYMED_NULL==m_stm.tymed && 0!=m_cfFormat)
            {
            SETDefFormatEtc(fe, m_cfFormat, TYMED_HGLOBAL
                | TYMED_MFPICT | TYMED_GDI);

            if (NULL!=m_pIDataObject)
                m_pIDataObject->GetData(&fe, &m_stm);
            }
        }
#endif /* NOT_SIMPLE */

    switch (m_cfFormat)
        {
        case CF_TEXT:
            psz=(LPTSTR)GlobalLock(m_stm.hGlobal);

            if (NULL==psz)
                break;

            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
            SetBkColor(hDC, GetSysColor(COLOR_WINDOW));

            pm_DrawText(hDC, psz, &rc, DT_LEFT | DT_WORDBREAK);

            GlobalUnlock(m_stm.hGlobal);
            break;

#ifdef NOT_SIMPLE
        case CF_BITMAP:
            hMemDC=CreateCompatibleDC(hDC);

            if (NULL!=SelectObject(hMemDC, (HGDIOBJ)m_stm.hGlobal))
                {
                BitBlt(hDC, 0, 0, rc.right-rc.left, rc.bottom-rc.top
                    , hMemDC, 0, 0, SRCCOPY);
                }

            DeleteDC(hMemDC);
            break;

        case CF_METAFILEPICT:
            pMF=(LPMETAFILEPICT)GlobalLock(m_stm.hGlobal);

            if (NULL==pMF)
                break;

            SetMapMode(hDC, pMF->mm);
            SetWindowOrgEx(hDC, 0, 0, NULL);
            SetWindowExtEx(hDC, pMF->xExt, pMF->yExt, NULL);

            SetViewportExtEx(hDC, rc.right-rc.left
                , rc.bottom-rc.top, NULL);

            PlayMetaFile(hDC, pMF->hMF);
            GlobalUnlock(m_stm.hGlobal);
            break;

#else /* IS SIMPLE */
        case CF_BITMAP:
        case CF_METAFILEPICT:
            DebugBreak();
            break;

#endif /* NOT_SIMPLE */

        default:
            break;
        }

    EndPaint(m_hWnd, &ps);
    return;
    }


void
CAppVars::pm_DrawText(
    HDC hDC,
    LPTSTR psz,
    RECT* prc,
    UINT flags)
{
    SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hDC, GetSysColor(COLOR_WINDOW));

// If we are WIN32 and the server is 16 bits this must be ASCII.
#ifdef WIN32
    if(m_f16Bit)
        DrawTextA(hDC, (char*)psz, -1, prc, flags);
    else
#endif
        DrawText(hDC, psz, -1, prc, flags);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\client\make16.inc ===
# 16-bit makefile
#
# Copyright (c) 1991, Microsoft Corporation
#
# History:
#
#   18-Feb-1994 KevinRo
#   24-Feb-1994 DrewB, added OBJDIR and some other niceties from win40.mk
#

.SUFFIXES:
.SUFFIXES: .c  .cxx  .cpp .asm .h   .inc .obj .lst
.SUFFIXES: .sys .exe .com .map .sym .def .lib .rc .res

!if "$(TARGET)" == ""
!error TARGET must be defined
!endif

OUTNUL= 1>nul 2>nul

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"
OBJDIR = obj16d
!else
OBJDIR = obj16r
!endif

# Build up lists of files to produce from sources

!if "$(CFILES)" != ""
OBJFILES = $(OBJFILES) $(CFILES:.c=.obj)
!endif
!if "$(CXXFILES)" != ""
OBJFILES = $(OBJFILES) $(CXXFILES:.cxx=.obj)
!endif
!if "$(CPPFILES)" != ""
OBJFILES = $(OBJFILES) $(CPPFILES:.cpp=.obj)
!endif

!if "$(ASMFILES)" != ""
OBJFILES = $(OBJFILES) $(ASMFILES:.asm=.obj)
!endif

!if "$(RCFILES)" != ""
RESFILES = $(RCFILES:.rc=.res)
!endif

# Replace .\ with $(OBJDIR)
# Unfortunately we can't do this directly so we have to explicitly check
# the value of OBJDIR

!if "$(OBJDIR)" == "obj16d"
OBJFILES = $(OBJFILES:.\=obj16d\)
RESFILES = $(RESFILES:.\=obj16d\)

!elseif "$(OBJDIR)" == "obj16r"
OBJFILES = $(OBJFILES:.\=obj16r\)
RESFILES = $(RESFILES:.\=obj16r\)

!else
!error Unknown OBJDIR: $(OBJDIR)
!endif

# Default target

all: $(OBJDIR)\$(TARGET)

# Determine target type and base name

# Is it a DLL?
TARGETBASE=$(TARGET:.dll=)
!if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=dll
!else

# Is it an EXE?
TARGETBASE=$(TARGET:.exe=)
! if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=exe
! else

# Is it a LIB?
TARGETBASE=$(TARGET:.lib=)
!  if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=lib
!  endif
! endif
!endif

!if "$(TARGETTYPE)" == ""
!error Unknown target type for "$(TARGET)"
!endif

!if "$(BUILDDETAILS)" != ""
BLDKEEP=        KEEP
!endif

OLETHUNK= $(_NTDRIVE)$(_NTROOT)\private\ole32\olethunk
OLE16= $(OLETHUNK)\ole16

RCINC = $(RCINC) -i$(OLE16)\inc
INCS = -I$(OLE16)\inc -I$(OLETHUNK)\h -I$(_NTDRIVE)$(_NTROOT)\private\cinc


PATH     = $(OLE16)\tools;$(PATH)
LINK    = link16
RC      = rc16
CL      = cl16
IMPLIB  = implib
LIBUTIL = lib16
MAPSYM  = mapsym
MASM    = masm

DEFINES = -DWOW

AOBJ    = -Mx -t $(DEFINES) $(INCS)

!if "$(TARGETTYPE)" == "exe"
CW16    = -GA
!else
CW16    = -GD
DEFINES = $(DEFINES) -D_WINDLL
!endif

CW16    = $(CW16) -G2 -AL $(DEFINES) $(INCS) /NMSEG_CODE

LFLAGS  = $(LFLAGS) /nod /noe /map:0 /align:16

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"

DEFINES = $(DEFINES) -DDBG=1 -DDEVL=1

!if "$(NTDEBUGTYPE)" == "windbg"
AOBJ    = $(AOBJ) -Zi
CW16    = $(CW16) /Odi /Zip /FA
LFLAGS  = $(LFLAGS) /CO
!else
AOBJ    = $(AOBJ) -Zd
CW16    = $(CW16) /Odi /Zd
LFLAGS  = $(LFLAGS) /LI
!endif

!else
CW16    = $(CW16) /Os /Zp /Gs
DEFINES = $(DEFINES) -DDBG=0 -DDEVL=1
!endif

!if "$(TARGETTYPE)" == "dll"
W16LIBS = $(OLE16)\lib\ldllcew.lib
!else
!if "$(QUICKWINDOWS)" != ""
W16LIBS = $(OLE16)\lib\llibcewq.lib
!else
W16LIBS = $(OLE16)\lib\llibcew.lib
!endif
!endif

W16LIBS = $(W16LIBS) $(OLE16)\lib\libw.lib

!if "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "exe"
LIBS = $(LIBS) $(W16LIBS)
!endif

.asm{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) $*,$*;

.asm.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) -l $*,nul,$*.lst;


.c{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
$<
<<$(BLDKEEP)

.c.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fonul
-Fc$*.lst
$<
<<$(BLDKEEP)

.cxx{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cxx.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cxx.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.cpp{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cpp.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cpp.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.def{$(OBJDIR)}.lib:
        @-md $(OBJDIR) $(OUTNUL)
        $(IMPLIB) $*.lib $<

{$(OBJDIR)}.map{$(OBJDIR)}.sym:
        @-md $(OBJDIR) $(OUTNUL)
        $(MAPSYM) $<

.rc{$(OBJDIR)}.res:
                @-md $(OBJDIR) $(OUTNUL)
        $(RC) -r  $(RCINC) -fo $*.res $<


cleanup:
    if exist $(OBJDIR)\*.lrf del $(OBJDIR)\*.lrf
    if exist $(OBJDIR)\*.obj del $(OBJDIR)\*.obj
    if exist $(OBJDIR)\*.exe del $(OBJDIR)\*.exe
    if exist $(OBJDIR)\*.map del $(OBJDIR)\*.map
    if exist $(OBJDIR)\*.sym del $(OBJDIR)\*.sym
    if exist $(OBJDIR)\*.res del $(OBJDIR)\*.res

clean: cleanup

!if "$(TARGETTYPE)" == "dll"

$(OBJDIR)\$(TARGETBASE).lib: $(TARGETBASE).def

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(OBJDIR)\$(TARGETBASE).lib $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map
!if "$(RCFILES)" != ""
        $(RC)  -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif

!elseif "$(TARGETTYPE)" == "lib"

$(OBJDIR)\$(TARGET): $(OBJFILES) $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        -del $@ $(OUTNUL)
        $(LIBUTIL) @<<$*.lnb
$(OBJDIR)\$(TARGET)
y
$(OBJFILES: = &^
)&
$(LIBS: = &^
)&

$*.lls
<<$(BLDKEEP)

!elseif "$(TARGETTYPE)" == "exe"

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
!if "$(RCFILES)" != ""
       $(RC) -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map

!endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\client\datausr.h ===
/*
 * DATAUSER.H
 * Data Object User Chapter 6
 *
 * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#ifndef _DATAUSER_H_
#define _DATAUSER_H_

#include "../syshead.h"
#include "../my3216.h"
#include "../bookpart.h"
#include "stpwatch.h"


//Menu Resource ID and Commands
#define IDR_MENU                    1


// #define IDM_OBJECTUSEDLL                100
// #define IDM_OBJECTUSEEXE                101
// #define IDM_OBJECTDATASIZESMALL         102
// #define IDM_OBJECTDATASIZEMEDIUM        103
// #define IDM_OBJECTDATASIZELARGE         104
#define IDM_OBJECTQUERYGETDATA          105
#define IDM_OBJECTGETDATA_TEXT           106
#define IDM_OBJECTGETDATA_BITMAP         107
// #define IDM_OBJECTGETDATA_METAFILEPICT   108
#define IDM_OBJECTEXIT                  109

#define IDM_OBJECTGETDATAHERE_TEXT         110
#define IDM_OBJECTGETDATAHERE_BITMAP       111
#define IDM_OBJECTGETDATAHERE_NULLTEXT         112
#define IDM_OBJECTGETDATAHERE_NULLBITMAP       113

#define IDM_USE16BITSERVER              120
#define IDM_USE32BITSERVER              121

#define IDM_OBJECTGETCANON              122

// Reserve Range..
#define IDM_OBJECTSETDATA             400
//      ....
// reserved through 464

#define IDM_OBJECTSETDATAPUNK_TEXT       500
#define IDM_OBJECTSETDATAPUNK_BITMAP     501


#define IDM_MEASUREMENT_1               140
#define IDM_MEASUREMENT_50              141
#define IDM_MEASUREMENT_300             142

#define IDM_MEASUREMENT_OFF             145
#define IDM_MEASUREMENT_ON              146
#define IDM_MEASUREMENT_TEST            147

#define IDM_BATCHTOFILE                 150
#define IDM_BATCH_GETDATA               151
#define IDM_BATCH_GETDATAHERE           152

// #define IDM_ADVISEMIN                   200
// #define IDM_ADVISETEXT                  (IDM_ADVISEMIN+CF_TEXT)
// #define IDM_ADVISEBITMAP                (IDM_ADVISEMIN+CF_BITMAP)
// #define IDM_ADVISEMETAFILEPICT          (IDM_ADVISEMIN+CF_METAFILEPICT)
// #define IDM_ADVISEGETDATA               300
// #define IDM_ADVISEREPAINT               301


#ifdef WIN32
 #define API_ENTRY  APIENTRY
#else
 #define API_ENTRY  FAR PASCAL _export
#endif

//DATAUSER.CPP
LRESULT API_ENTRY DataUserWndProc(HWND, UINT, WPARAM, LPARAM);


class CImpIAdviseSink;
typedef class CImpIAdviseSink *PIMPIADVISESINK;



#define FILENAME "time.dat"
#define NUM_POINTS  15

typedef struct {
    ULONG cData[NUM_POINTS];
    ULONG cBest[NUM_POINTS];
    ULONG cWorst[NUM_POINTS];
    ULONG cTotal[NUM_POINTS];
} dataset_t;




/*
 * Application-defined classes and types.
 */

class CAppVars
    {
    friend LRESULT API_ENTRY DataUserWndProc(HWND, UINT, WPARAM, LPARAM);

    friend class CImpIAdviseSink;

    protected:
        HINSTANCE       m_hInst;            //WinMain parameters
        HINSTANCE       m_hInstPrev;
        UINT            m_nCmdShow;

        HWND            m_hWnd;             //Main window handle
//        BOOL            m_fEXE;             //For tracking menu

//        PIMPIADVISESINK m_pIAdviseSink;     //Our CImpIAdviseSink
//        DWORD           m_dwConn;           //Advise connection
//        UINT            m_cfAdvise;         //Advise format
//        BOOL            m_fGetData;         //GetData on data change?
//        BOOL            m_fRepaint;         //Repaint on data change?

//        LPDATAOBJECT    m_pIDataSmall;
//        LPDATAOBJECT    m_pIDataMedium;
//        LPDATAOBJECT    m_pIDataLarge;

        LPDATAOBJECT    m_pIDataObject;     //Current selection
        UINT            m_f16Bit;
        UINT            m_cfFormat;
        STGMEDIUM       m_stm;              //Current rendering

        BOOL            m_fInitialized;     //Did CoInitialize work?

        ULONG           m_iDataSizeIndex;
        HGLOBAL         m_hgHereBuffers[64];
        BOOL            m_fDisplayTime;
        LONG            m_cIterations;
        StopWatch_cl    m_swTimer;

        int             m_HereAllocCount; // For debugging.

    public:
        CAppVars(HINSTANCE, HINSTANCE, UINT);
        ~CAppVars(void);
        BOOL FInit(void);
        BOOL FReloadDataObjects(BOOL);
        void TryQueryGetData(LPFORMATETC, UINT, BOOL, UINT);
        void Paint(void);

        int  m_GetDataHere(WORD wID);
        int  m_GetData(WORD wID);
        int  m_SetData_SetSize(long iSizeIndex);
        int  m_SetData_WithPUnk(WORD wID);
        void m_SetMeasurement(WORD wID);
        void m_MeasureAllSizes(WORD wID, LPTSTR title, dataset_t *);

        void m_BatchToFile();
        void m_DisplayTimerResults();

    private:
        void pm_DrawText(HDC hDc, LPTSTR psz, RECT* prc, UINT flags);
        void pm_ClearDataset(dataset_t *);

    };


typedef CAppVars *PAPPVARS;

#define CBWNDEXTRA               sizeof(PAPPVARS)
#define DATAUSERWL_STRUCTURE     0


//This lives with the app to get OnDataChange notifications.

class CImpIAdviseSink : public IAdviseSink
    {
    protected:
        ULONG               m_cRef;
        PAPPVARS            m_pAV;

    public:
        CImpIAdviseSink(PAPPVARS);
        ~CImpIAdviseSink(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //We only implement OnDataChange for now.
        STDMETHODIMP_(void)  OnDataChange(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP_(void)  OnViewChange(DWORD, LONG);
        STDMETHODIMP_(void)  OnRename(LPMONIKER);
        STDMETHODIMP_(void)  OnSave(void);
        STDMETHODIMP_(void)  OnClose(void);
    };



//////////////////////////////////////////////////////////////////////////////
// Storage Medium IUnknown interface for pUnkForRelease.
//

class CStgMedIf: public IUnknown {
private:
    ULONG m_cRef;
public:
    CStgMedIf();
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
};

//////////////////////////
// API for getting a pUnkForRelease.
//

HRESULT GetStgMedpUnkForRelease(IUnknown **pp_unk);

#endif //_DATAUSER_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\client\perror.h ===
#include "../my3216.h"

/*
 * winErrorString: Write the text of an HRESULT into a supplied buffer.
 */
LPTSTR
winErrorString(
    HRESULT hrErrorCode,
    LPTSTR  sBuf,
    int     cBufSize);

/*
 * print_error:  Print a mesage and the text of an HRESULT .
 */
void
print_error(
    LPTSTR  sMessage,
    HRESULT hrErrorCode);

/*
 * perror_OKBox: Write the text of an HRESULT in a MessageBox.
 */
void
perror_OKBox(
    HWND    hwnd,
    LPTSTR  sTitle,
    HRESULT hrErrorCode);
/*
 * wprintf_OKBox: printf into a MessageBox.
 */
void
wprintf_OKBox(
    HWND   hwnd,
    LPTSTR sTitle,
    LPTSTR sFormat,
    ...);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\client\stpwatch.h ===
#ifndef __STOPWATCH_H
#define __STOPWATCH_H

#include "../syshead.h"
#include "../my3216.h"

class StopWatch_cl {
    private:
        static ULONG sm_TicksPerSecond;
        LARGE_INTEGER m_liStart;
        LARGE_INTEGER m_liStop;

        enum em_STATES { ZEROED, RUNNING, STOPPED };
        em_STATES  m_State;

    public:
        StopWatch_cl();
        void m_Zero();
        BOOL m_ClassInit();
        BOOL m_Start();
        BOOL m_Stop();
        BOOL m_Read(ULONG *);
        BOOL m_ShowWindow(HWND);
        BOOL m_Sleep(UINT);
};

#endif // __STOPWATCH_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\client\stgmedif.cpp ===
#include "datausr.h"

HRESULT
GetStgMedpUnkForRelease(IUnknown **pp_unk)
{
    CStgMedIf *p_smi = new CStgMedIf();
    HRESULT hr = p_smi->QueryInterface(IID_IUnknown, (PPVOID)pp_unk);
    return hr;
}

CStgMedIf::CStgMedIf()
{
    m_cRef = 0;
}


STDMETHODIMP
CStgMedIf::QueryInterface(
    REFIID riid,
    LPLPVOID ppv
)
{
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPVOID)this;
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG)
CStgMedIf::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CStgMedIf::Release(void)
{
    ULONG   cRefT;

    cRefT = --m_cRef;

    if (0==cRefT)
    {
        TCHAR chBuf[80];

        wsprintf(chBuf, TEXT("Reference Count is %d"), cRefT);
        MessageBox(0,
                   chBuf,
                   TEXT("STGMED pUnkForRelease"),
                   MB_OK);
        delete this;
    }
    return cRefT;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\client\stpwatch.cpp ===
#include "stpwatch.h"

StopWatch_cl::StopWatch_cl()
{
    m_Zero();
}

ULONG StopWatch_cl::sm_TicksPerSecond;

//
// Init global/static state of the StopWatch class.
//
BOOL
StopWatch_cl::m_ClassInit()
{
    LARGE_INTEGER liTPS;
#ifdef WIN32
    if(!QueryPerformanceFrequency(&liTPS) )
    {
        MessageBox(0,
                    TEXT("Can't read frequency"),
                    TEXT("QueryPerformanceFrequency"),
                    MB_OK);
        return FALSE;
    }
    if (liTPS.HighPart != 0)
    {
        MessageBox(0,
                    TEXT("Ticks Per Second is to great"),
                    TEXT("QueryPerformanceFrequency"),
                    MB_OK);
        return FALSE;
    }
    sm_TicksPerSecond = liTPS.LowPart;
#else
    sm_TicksPerSecond = 1000;
#endif
    return TRUE;
}

void
StopWatch_cl::m_Zero()
{
    LISet32(m_liStart, 0);
    LISet32(m_liStop, 0);
    m_State = ZEROED;
}


BOOL
StopWatch_cl::m_Start()
{
#ifdef WIN32
    if(!QueryPerformanceCounter(&m_liStart))
    {
        MessageBox(0,
                    TEXT("Get Start Time Failure"),
                    TEXT("QueryPerformancecounter Failed"),
                    MB_OK);
        return FALSE;
    }
#else
    m_liStart.LowPart = GetTickCount();
    m_liStart.HighPart = 0;
#endif
    m_State = RUNNING;
    return TRUE;
}

// m_MeasureStop()
// Returns microseconds per single iteration.
//
BOOL
StopWatch_cl::m_Stop()
{
#ifdef WIN32
    if(!QueryPerformanceCounter(&m_liStop))
    {
        MessageBox(0,
                    TEXT("Get Stop Time Failure"),
                    TEXT("QueryPerformancecounter Failed"),
                    MB_OK);
        return FALSE;
    }
#else
    m_liStop.LowPart = GetTickCount();
    m_liStop.HighPart = 0;
#endif
    m_State = STOPPED;
    return TRUE;
}

BOOL
StopWatch_cl::m_Sleep(UINT msecs)
{
#ifdef WIN32
    Sleep(msecs);
#else
    UINT start, elapsed;
    start = GetTickCount();
    do
    {
        elapsed = GetTickCount() - start;
    } while ( msecs > elapsed );
#endif
    return TRUE;
}


//
//  Return a ULONG count of the number of Microseconds on the timer.
// I would return LARGE_INTEGER but there doesn't seem to be facilities
// to user them easily under 16 bit.
//
BOOL
StopWatch_cl::m_Read(ULONG *p_cMicroSeconds)
{
    LARGE_INTEGER liTicks;

    int borrow = 0;
    if(m_liStart.LowPart > m_liStop.LowPart)
        borrow = 1;
    liTicks.LowPart  = m_liStop.LowPart  - m_liStart.LowPart;
    liTicks.HighPart = m_liStop.HighPart - m_liStart.HighPart - borrow;

    if(0 != liTicks.HighPart)
    {
        MessageBox(0,
                    TEXT("Time interval was too great"),
                    TEXT("Failure"),
                    MB_OK);
        return(FALSE);
    }

    // result has units of (ticks/ loop of iterations).  Where the ticks
    // are timer specific.  This will convert result into:
    // (Milli_ticks) / (single iteration)

#ifdef WIN32
    *p_cMicroSeconds = MulDiv(liTicks.LowPart, 1000000, sm_TicksPerSecond);
#else
    *p_cMicroSeconds = liTicks.LowPart * 1000;
#endif
    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\server\make16.inc ===
# 16-bit makefile
#
# Copyright (c) 1991, Microsoft Corporation
#
# History:
#
#   18-Feb-1994 KevinRo
#   24-Feb-1994 DrewB, added OBJDIR and some other niceties from win40.mk
#

.SUFFIXES:
.SUFFIXES: .c  .cxx  .cpp .asm .h   .inc .obj .lst
.SUFFIXES: .sys .exe .com .map .sym .def .lib .rc .res

!if "$(TARGET)" == ""
!error TARGET must be defined
!endif

OUTNUL= 1>nul 2>nul

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"
OBJDIR = obj16d
!else
OBJDIR = obj16r
!endif

# Build up lists of files to produce from sources

!if "$(CFILES)" != ""
OBJFILES = $(OBJFILES) $(CFILES:.c=.obj)
!endif
!if "$(CXXFILES)" != ""
OBJFILES = $(OBJFILES) $(CXXFILES:.cxx=.obj)
!endif
!if "$(CPPFILES)" != ""
OBJFILES = $(OBJFILES) $(CPPFILES:.cpp=.obj)
!endif

!if "$(ASMFILES)" != ""
OBJFILES = $(OBJFILES) $(ASMFILES:.asm=.obj)
!endif

!if "$(RCFILES)" != ""
RESFILES = $(RCFILES:.rc=.res)
!endif

# Replace .\ with $(OBJDIR)
# Unfortunately we can't do this directly so we have to explicitly check
# the value of OBJDIR

!if "$(OBJDIR)" == "obj16d"
OBJFILES = $(OBJFILES:.\=obj16d\)
RESFILES = $(RESFILES:.\=obj16d\)

!elseif "$(OBJDIR)" == "obj16r"
OBJFILES = $(OBJFILES:.\=obj16r\)
RESFILES = $(RESFILES:.\=obj16r\)

!else
!error Unknown OBJDIR: $(OBJDIR)
!endif

# Default target

all: $(OBJDIR)\$(TARGET)

# Determine target type and base name

# Is it a DLL?
TARGETBASE=$(TARGET:.dll=)
!if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=dll
!else

# Is it an EXE?
TARGETBASE=$(TARGET:.exe=)
! if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=exe
! else

# Is it a LIB?
TARGETBASE=$(TARGET:.lib=)
!  if "$(TARGETBASE)" != "$(TARGET)"
TARGETTYPE=lib
!  endif
! endif
!endif

!if "$(TARGETTYPE)" == ""
!error Unknown target type for "$(TARGET)"
!endif

!if "$(BUILDDETAILS)" != ""
BLDKEEP=        KEEP
!endif

OLETHUNK= $(_NTDRIVE)$(_NTROOT)\private\ole32\olethunk
OLE16= $(OLETHUNK)\ole16

RCINC = $(RCINC) -i$(OLE16)\inc
INCS = -I$(OLE16)\inc -I$(OLETHUNK)\h -I$(_NTDRIVE)$(_NTROOT)\private\cinc


PATH     = $(OLE16)\tools;$(PATH)
LINK    = link16
RC      = rc16
CL      = cl16
IMPLIB  = implib
LIBUTIL = lib16
MAPSYM  = mapsym
MASM    = masm

DEFINES = -DWOW

AOBJ    = -Mx -t $(DEFINES) $(INCS)

!if "$(TARGETTYPE)" == "exe"
CW16    = -GA
!else
CW16    = -GD
DEFINES = $(DEFINES) -D_WINDLL
!endif

CW16    = $(CW16) -G2 -AL $(DEFINES) $(INCS) /NMSEG_CODE

LFLAGS  = $(LFLAGS) /nod /noe /map:0 /align:16

!if "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail"

DEFINES = $(DEFINES) -DDBG=1 -DDEVL=1

!if "$(NTDEBUGTYPE)" == "windbg"
AOBJ    = $(AOBJ) -Zi
CW16    = $(CW16) /Odi /Zip /FA
LFLAGS  = $(LFLAGS) /CO
!else
AOBJ    = $(AOBJ) -Zd
CW16    = $(CW16) /Odi /Zd
LFLAGS  = $(LFLAGS) /LI
!endif

!else
CW16    = $(CW16) /Os /Zp /Gs
DEFINES = $(DEFINES) -DDBG=0 -DDEVL=1
!endif

!if "$(TARGETTYPE)" == "dll"
W16LIBS = $(OLE16)\lib\ldllcew.lib
!else
!if "$(QUICKWINDOWS)" != ""
W16LIBS = $(OLE16)\lib\llibcewq.lib
!else
W16LIBS = $(OLE16)\lib\llibcew.lib
!endif
!endif

W16LIBS = $(W16LIBS) $(OLE16)\lib\libw.lib

!if "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "exe"
LIBS = $(LIBS) $(W16LIBS)
!endif

.asm{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) $*,$*;

.asm.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(MASM) $(AOBJ) -l $*,nul,$*.lst;


.c{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
$<
<<$(BLDKEEP)

.c.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fonul
-Fc$*.lst
$<
<<$(BLDKEEP)

.cxx{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cxx.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cxx.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.cpp{$(OBJDIR)}.obj:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$*.rsp
$(CW16: =
)
-Fo$*.obj
-Tp$<
<<$(BLDKEEP)

.cpp.lst:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp
$(CW16: =
)
-Fc$*.lst
-Fonul
-Tp$<
<<$(BLDKEEP)

.cpp.pp:
        @-md $(OBJDIR) $(OUTNUL)
        $(CL) -c -nologo  @<<$(OBJDIR)\$*.rsp > $*.pp
$(CW16: =
)
-E
-Fonul
-Tp$<
<<$(BLDKEEP)


.def{$(OBJDIR)}.lib:
        @-md $(OBJDIR) $(OUTNUL)
        $(IMPLIB) $*.lib $<

{$(OBJDIR)}.map{$(OBJDIR)}.sym:
        @-md $(OBJDIR) $(OUTNUL)
        $(MAPSYM) $<

.rc{$(OBJDIR)}.res:
                @-md $(OBJDIR) $(OUTNUL)
        $(RC) -r  $(RCINC) -fo $*.res $<


cleanup:
    if exist $(OBJDIR)\*.lrf del $(OBJDIR)\*.lrf
    if exist $(OBJDIR)\*.obj del $(OBJDIR)\*.obj
    if exist $(OBJDIR)\*.exe del $(OBJDIR)\*.exe
    if exist $(OBJDIR)\*.map del $(OBJDIR)\*.map
    if exist $(OBJDIR)\*.sym del $(OBJDIR)\*.sym
    if exist $(OBJDIR)\*.res del $(OBJDIR)\*.res

clean: cleanup

!if "$(TARGETTYPE)" == "dll"

$(OBJDIR)\$(TARGETBASE).lib: $(TARGETBASE).def

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(OBJDIR)\$(TARGETBASE).lib $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map
!if "$(RCFILES)" != ""
        $(RC)  -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif

!elseif "$(TARGETTYPE)" == "lib"

$(OBJDIR)\$(TARGET): $(OBJFILES) $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        -del $@ $(OUTNUL)
        $(LIBUTIL) @<<$*.lnb
$(OBJDIR)\$(TARGET)
y
$(OBJFILES: = &^
)&
$(LIBS: = &^
)&

$*.lls
<<$(BLDKEEP)

!elseif "$(TARGETTYPE)" == "exe"

$(OBJDIR)\$(TARGET) $(OBJDIR)\$(TARGETBASE).map: $(OBJFILES) $(RESFILES) \
        $(TARGETBASE).def $(LIBS)
        @-md $(OBJDIR) $(OUTNUL)
        $(LINK) $(LFLAGS) @<<$(OBJDIR)\$(TARGETBASE).rsp
$(OBJFILES: =+^
)
$(OBJDIR)\$(TARGET)
$(OBJDIR)\$(TARGETBASE).map
$(LIBS: =+^
)
$(TARGETBASE).def
<<$(BLDKEEP)
!if "$(RCFILES)" != ""
       $(RC) -t $(OBJDIR)\$(TARGETBASE).res $(OBJDIR)\$(TARGET)
!endif
        $(MAPSYM) -o $(OBJDIR)\$(TARGETBASE).sym $(OBJDIR)\$(TARGETBASE).map

!endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\server\dataobj.cpp ===
#include "dataobj.h"

extern HINSTANCE g_hInstance;

DWORD   g_dwID=0;
DWORD   g_foobar;

CDataObject::CDataObject(
    LPUNKNOWN  pUnkOuter,
    PFNDESTROYED  pfnDestroy
)
{
    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
    m_pfnDestroy = pfnDestroy;

    m_hWndAdvise = NULL;
    m_dwAdvFlags = ADVF_NODATA;

    m_pIDataObject = NULL;
    m_pIDataAdviseHolder = NULL;

    m_cfeGet = CFORMATETCGET;
    SETDefFormatEtc(m_rgfeGet[0], CF_TEXT, TYMED_HGLOBAL);

    m_dataText = NULL;
    m_cDataSize = DATASIZE_FROM_INDEX(1);

    return;
}

CDataObject::~CDataObject(void)
{
    if (NULL != m_dataText)
        delete m_dataText;

    if (NULL != m_pIDataAdviseHolder)
        m_pIDataAdviseHolder->Release();

    if (NULL != m_pIDataObject)
        delete m_pIDataObject;

    if (NULL != m_hWndAdvise)
        DestroyWindow(m_hWndAdvise);
}

BOOL
CDataObject::FInit(void)
{
    LPUNKNOWN   pIUnknown = (LPUNKNOWN)this;

    // Create the contained "IDataObject" interface and
    // pass it the correct containing IUnknown.
    if (NULL != m_pUnkOuter)
        pIUnknown = m_pUnkOuter;

    m_pIDataObject = new CImpIDataObject(this, pIUnknown);

    if (NULL == m_pIDataObject)
        return FALSE;

    // [ Code for "Advise Window" goes here. ]

    return TRUE;
}

STDMETHODIMP
CDataObject::QueryInterface(
    REFIID riid,
    LPLPVOID ppv
)
{
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (LPVOID)this;

    if (IsEqualIID(riid, IID_IDataObject))
        *ppv = (LPVOID) m_pIDataObject;

    if(NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG)
CDataObject::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CDataObject::Release(void)
{
    ULONG   cRefT;

    cRefT = --m_cRef;

    if (0==m_cRef)
    {
        if (NULL != m_pfnDestroy)
            (*m_pfnDestroy)();
        delete this;
    }
    return cRefT;
}

#ifdef NOT_SIMPLE
LRESULT APIENTRY
AdvisorWndProc(
    HWND hWnd,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    PCDataObject   pDO;

    pDO = (PCDataObject)(GetWindowLong)(hWnd, 0);

    switch (iMsg)
    {
    case WM_NCCREATE:
        pDO = (PCDataObject) ((LONG)((LPCREATESTRUCT)lParam)
                                                ->lpCreateParams);
        SetWindowLong(hWnd, 0, (LONG)pDO);
        return (DefWindowProc(hWnd, iMsg, wParam, lParam));

#ifdef FINISHED
    case WM_CLOSE:
        // Forbid the Task Manager from closing us.
        return 0L;
#endif /* Finished */

    case WM_COMMAND:
        // [ Code for "Advise Window" goes here. ]
        break;

    default:
        return (DefWindowProc(hWnd, iMsg, wParam, lParam));
    }
    return 0L;
}
#endif  /* NOT_SIMPLE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\server\edataobj.h ===
#ifndef _EDATAOBJ_H_
#define _EDATAOBJ_H_

#include "dataobj.h"


//EDATAOBJ.CPP
LRESULT WINAPI DataObjectWndProc(HWND, UINT, WPARAM, LPARAM);


class CAppVars
{
    friend LRESULT WINAPI DataObjectWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    HINSTANCE       m_hInst;            //WinMain parameters
    HINSTANCE       m_hInstPrev;
    LPSTR           m_pszCmdLine;
    UINT            m_nCmdShow;

    HWND            m_hWnd;             //Main window handle
    BOOL            m_fInitialized;     //Did CoInitialize work?

    //We have multiple classes, one for each data size.
    // DWORD           m_rgdwRegCO[DOSIZE_CSIZES];
    // LPCLASSFACTORY  m_rgpIClassFactory[DOSIZE_CSIZES];
    DWORD           m_dwRegCO;
    LPCLASSFACTORY  m_pIClassFactory;

public:
    CAppVars(HINSTANCE, HINSTANCE, LPSTR, UINT);
    ~CAppVars(void);
    BOOL FInit(void);
};

typedef CAppVars *PAPPVARS;

void PASCAL ObjectDestroyed(void);

//This class factory object creates Data Objects.

class CDataObjectClassFactory : public IClassFactory
{
protected:
    ULONG           m_cRef;

public:
    CDataObjectClassFactory();
    ~CDataObjectClassFactory(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, PPVOID);
    STDMETHODIMP         LockServer(BOOL);
};

typedef CDataObjectClassFactory *PCDataObjectClassFactory;

#endif //_EDATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\server\ienumfe.cpp ===
#include "dataobj.h"

CEnumFormatEtc::CEnumFormatEtc(
    LPUNKNOWN pUnkRef,
    ULONG cFE,
    LPFORMATETC prgFE
)
{
    UINT    i;

    m_cRef = 0;
    m_pUnkRef = pUnkRef;

    m_iCur = 0;
    m_cfe = cFE;
    m_prgfe = new FORMATETC[ (UINT) cFE ];

    if (NULL != m_prgfe)
    {
        for(i=0; i<cFE; i++)
            m_prgfe[i] = prgFE[i];
    }
    return;
}

CEnumFormatEtc::~CEnumFormatEtc(void)
{
    if (NULL != m_prgfe)
        delete [] m_prgfe;
    return;
}

STDMETHODIMP
CEnumFormatEtc::QueryInterface(
    REFIID riid,
    LPLPVOID ppv
)
{
    *ppv = NULL;
    if(IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IEnumFORMATETC))
    {
        *ppv = (LPVOID) this;
    }
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG)
CEnumFormatEtc::AddRef(void)
{
    ++m_cRef;
    m_pUnkRef->AddRef();
    return m_cRef;
}

STDMETHODIMP_(ULONG)
CEnumFormatEtc::Release(void)
{
    ULONG   cRefT;

    cRefT = --m_cRef;

    if (0 == m_cRef)
        delete this;

    return cRefT;
}

STDMETHODIMP
CEnumFormatEtc::Next(
    ULONG   cFE,
    LPFORMATETC pFE,
    ULONG FAR   *pulFE
)
{
    ULONG   cReturn = 0L;

    if (NULL == m_prgfe)
        return ResultFromScode(S_FALSE);

    if (NULL == pulFE)
    {
        if (1L != cFE)
            return ResultFromScode(E_POINTER);
    }
    else
        *pulFE = 0L;

    if (NULL == pFE || m_iCur >= m_cfe)
        return ResultFromScode(S_FALSE);

    while ( (m_iCur < m_cfe) && (cFE > 0) )
    {
        *pFE++ = m_prgfe[m_iCur++];
        ++cReturn;
        --cFE;
    }

    if (NULL != pulFE)
        *pulFE = cReturn;

    return NOERROR;
}

STDMETHODIMP
CEnumFormatEtc::Skip(
    ULONG   cSkip
)
{
    if ( ( (m_iCur+cSkip) > m_cfe) || (NULL == m_prgfe) )
        return ResultFromScode(S_FALSE);

    m_iCur += cSkip;
    return NOERROR;
}

STDMETHODIMP
CEnumFormatEtc::Reset(void)
{
    m_iCur = 0;
    return NOERROR;
}

STDMETHODIMP
CEnumFormatEtc::Clone(
    LPENUMFORMATETC FAR *ppEnum
)
{
    PCEnumFormatEtc    pNew;

    *ppEnum = NULL;

    pNew = new CEnumFormatEtc(m_pUnkRef, m_cfe, m_prgfe);
    if (NULL == pNew)
        return ResultFromScode(E_OUTOFMEMORY);
    pNew->AddRef();
    pNew->m_iCur = m_iCur;

    *ppEnum = pNew;
    return NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\server\idataobj.cpp ===
#include "dataobj.h"
#include <stdlib.h>

CImpIDataObject::CImpIDataObject(
    PCDataObject pObj,
    LPUNKNOWN pUnkOuter
)
{
    m_cRef = 0;
    m_pObj = pObj;
    m_pUnkOuter = pUnkOuter;
    return;
}


CImpIDataObject::~CImpIDataObject(void)
{
    return;
}

STDMETHODIMP
CImpIDataObject::QueryInterface(
    REFIID riid,
    LPLPVOID ppv
)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
CImpIDataObject::AddRef(void)
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG)
CImpIDataObject::Release(void)
{
    --m_cRef;
    return m_pUnkOuter->Release();
}

STDMETHODIMP
CImpIDataObject::GetData(
    LPFORMATETC pFE,
    LPSTGMEDIUM pSTM
)
{
    UINT    cf = pFE->cfFormat;

    if (!(DVASPECT_CONTENT & pFE->dwAspect))
        return ResultFromScode(DATA_E_FORMATETC);

    switch (cf)
    {
    case CF_TEXT:
        if (!(TYMED_HGLOBAL & pFE->tymed))
            break;
        return m_pObj->RenderText(pSTM, TEXT("Getdata"),
                                                FL_MAKE_ITEM | FL_PASS_PUNK);

    default:
        break;
    }
    return ResultFromScode(DATA_E_FORMATETC);
}



STDMETHODIMP
CImpIDataObject::GetDataHere(
    LPFORMATETC pFE,
    LPSTGMEDIUM pSTM
)
{
    UINT    cf = pFE->cfFormat;

    if (!(DVASPECT_CONTENT & pFE->dwAspect))
        return ResultFromScode(DATA_E_FORMATETC);

    switch (cf)
    {
    case CF_TEXT:
        if (!(TYMED_HGLOBAL & pFE->tymed))
            break;

        if(TYMED_NULL == pSTM->tymed)
            return ResultFromScode(S_OK);

        if(TYMED_HGLOBAL != pSTM->tymed)
            return ResultFromScode(E_INVALIDARG);

        return m_pObj->RenderText(pSTM, TEXT("GetDataHere"), FL_USE_ITEM);

    default:
        return ResultFromScode( DATA_E_FORMATETC );

    }
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP
CImpIDataObject::QueryGetData(
    LPFORMATETC pFE
)
{
    UINT    cf = pFE->cfFormat;
    BOOL    fRet = FALSE;

    if (!(DVASPECT_CONTENT & pFE->dwAspect))
        return ResultFromScode(DATA_E_FORMATETC);

    switch (cf)
    {
    case CF_TEXT:
        fRet = (BOOL) (pFE->tymed & TYMED_HGLOBAL);
        break;

    default:
        fRet = FALSE;
        break;
    }
    return fRet ? NOERROR : ResultFromScode(S_FALSE);
}

STDMETHODIMP
CImpIDataObject::GetCanonicalFormatEtc(
    LPFORMATETC pFEIn,
    LPFORMATETC pFEOut
)
{
    if (NULL==pFEOut)
        return ResultFromScode(E_INVALIDARG);

    pFEOut->ptd = NULL;
    return ResultFromScode(DATA_S_SAMEFORMATETC);
}

STDMETHODIMP
CImpIDataObject::SetData(
    LPFORMATETC pFE,
    STGMEDIUM FAR *pST,
    BOOL fRelease
)
{
    UINT    cf = pFE->cfFormat;
    int iArg;

    if (!(DVASPECT_CONTENT & pFE->dwAspect))
        return ResultFromScode(DATA_E_FORMATETC);

    switch (cf)
    {
    case CF_TEXT:
        if (!(TYMED_HGLOBAL & pFE->tymed))
            break;

        if(TYMED_HGLOBAL != pST->tymed)
            return ResultFromScode(E_INVALIDARG);

        LPTSTR psz=(LPTSTR)GlobalLock(pST->hGlobal);        // Lock
        iArg = *((long*)psz);                               // Use
        GlobalUnlock(pST->hGlobal);                         // Unlock

        if(iArg > 0)
        {
            m_pObj->m_cDataSize = iArg;
            return NOERROR;
        }
    }
    if(-1 == iArg && fRelease)
    {
        ReleaseStgMedium(pST);
        return NOERROR;
    }
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP
CImpIDataObject::EnumFormatEtc(
    DWORD dwDir,
    LPENUMFORMATETC FAR *ppEnum
)
{
    switch (dwDir)
    {
    case DATADIR_GET:
        *ppEnum = (LPENUMFORMATETC) new CEnumFormatEtc(
                                        m_pUnkOuter,
                                        m_pObj->m_cfeGet,
                                        m_pObj->m_rgfeGet );
        break;

    case DATADIR_SET:
        *ppEnum = NULL;
        break;

    default:
        *ppEnum = NULL;
        break;
    }
    if (NULL == *ppEnum)
        return ResultFromScode(E_FAIL);
    else
        (*ppEnum)->AddRef();

    return NOERROR;
}

STDMETHODIMP
CImpIDataObject::DAdvise(
    LPFORMATETC pFE,
    DWORD   dwFlags,
    LPADVISESINK    pIAdviseSink,
    LPDWORD pdwConn
)
{
    HRESULT hr;

    if (NULL == m_pObj->m_pIDataAdviseHolder)
    {
        hr = CreateDataAdviseHolder(&m_pObj->m_pIDataAdviseHolder);
        if(FAILED(hr))
            return ResultFromScode(E_OUTOFMEMORY);
    }
    hr = m_pObj->m_pIDataAdviseHolder->Advise(
                    (LPDATAOBJECT)this,
                    pFE,
                    dwFlags,
                    pIAdviseSink,
                    pdwConn );
    return hr;
}

STDMETHODIMP
CImpIDataObject::DUnadvise(
    DWORD dwConn
)
{
    HRESULT hr;

    if (NULL==m_pObj->m_pIDataAdviseHolder)
        return ResultFromScode(E_FAIL);
    hr = m_pObj->m_pIDataAdviseHolder->Unadvise(dwConn);
    return hr;
}

STDMETHODIMP
CImpIDataObject::EnumDAdvise(
    LPENUMSTATDATA FAR *ppEnum
)
{
    HRESULT hr;

    if (NULL==m_pObj->m_pIDataAdviseHolder)
        return ResultFromScode(E_FAIL);

    hr = m_pObj->m_pIDataAdviseHolder->EnumAdvise(ppEnum);
    return hr;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\server\edataobj.cpp ===
#define INIT_MY_GUIDS
#include <ole2ver.h>
#include "edataobj.h"


// Count of the number of objects and number of locks.
ULONG       g_cObj=0;
ULONG       g_cLock=0;

//Make window handle global so other code can cause a shutdown
HWND        g_hWnd=NULL;
HINSTANCE   g_hInst=NULL;


/*
 * WinMain
 *
 * Purpose:
 *  Main entry point of application.
 */

int PASCAL
WinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR pszCmdLine,
    int nCmdShow)
{
    MSG         msg;
    PAPPVARS    pAV;

#ifndef WIN32
    int cMsg = 96;
    while (!SetMessageQueue(cMsg) && (cMsg -= 9))
        ;
#endif
    g_hInst=hInst;

    pAV=new CAppVars(hInst, hInstPrev, pszCmdLine, nCmdShow);

    if (NULL==pAV)
        return -1;

    if (pAV->FInit())
    {
        while (GetMessage(&msg, NULL, 0,0 ))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    delete pAV;
    return msg.wParam;
}


LRESULT WINAPI
DataObjectWndProc(
    HWND hWnd,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (iMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return (DefWindowProc(hWnd, iMsg, wParam, lParam));
    }

    return 0L;
}


void PASCAL
ObjectDestroyed(void)
{
    g_cObj--;

    //No more objects and no locks, shut the app down.
    if (0L==g_cObj && 0L==g_cLock && IsWindow(g_hWnd))
        PostMessage(g_hWnd, WM_CLOSE, 0, 0L);

    return;
}


CAppVars::CAppVars(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR pszCmdLine,
    UINT nCmdShow)
{
    m_hInst     =hInst;
    m_hInstPrev =hInstPrev;
    m_pszCmdLine=pszCmdLine;

    m_nCmdShow  = nCmdShow;

    m_hWnd=NULL;

#if 0
    for (i=0; i < DOSIZE_CSIZES; i++)
    {
        m_rgdwRegCO[i]=0;
        m_rgpIClassFactory[i]=NULL;
    }
#else
    m_dwRegCO = 0;
    m_pIClassFactory = NULL;
#endif

    m_fInitialized=FALSE;
    return;
}


CAppVars::~CAppVars(void)
{
#if 0
    UINT        i;

    //Revoke and destroy the class factories of all sizes
    for (i=0; i < DOSIZE_CSIZES; i++)
    {
        if (0L!=m_rgdwRegCO[i])
            CoRevokeClassObject(m_rgdwRegCO[i]);

        if (NULL!=m_rgpIClassFactory[i])
            m_rgpIClassFactory[i]->Release();
    }
#else
    if (0L != m_dwRegCO)
        CoRevokeClassObject(m_dwRegCO);

    if (NULL != m_pIClassFactory)
        m_pIClassFactory->Release();
#endif

    if (m_fInitialized)
        CoUninitialize();

    return;
}

/*
 * CAppVars::FInit
 *
 * Purpose:
 *  Initializes an CAppVars object by registering window classes,
 *  etc...  If this function fails the caller should guarantee
 *  that the destructor is called.
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 */

BOOL
CAppVars::FInit(void)
{
    WNDCLASS        wc;
    HRESULT         hr;
    DWORD           dwVer;
#ifdef WIN32
    static TCHAR    szClass[] = TEXT("IdataSvr32");
#else
    static TCHAR    szClass[] = TEXT("IdataSvr16");
#endif

    //Check command line for -Embedding
    if (lstrcmpiA(m_pszCmdLine, "-Embedding"))
        return FALSE;

    dwVer=CoBuildVersion();

    if (rmm!=HIWORD(dwVer))
        return FALSE;

    if (FAILED(CoInitialize(NULL)))
        return FALSE;

    m_fInitialized=TRUE;

    if (!m_hInstPrev)
    {
        wc.style          = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc    = DataObjectWndProc;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = 0;
        wc.hInstance      = m_hInst;
        wc.hIcon          = NULL;
        wc.hCursor        = NULL;
        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName   = NULL;
        wc.lpszClassName  = szClass;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    m_hWnd=CreateWindow(szClass,
                        szClass,
                        WS_OVERLAPPEDWINDOW,
                        135, 135, 350, 250,
                        NULL, NULL, m_hInst, NULL);

    if (NULL==m_hWnd)
        return FALSE;

    g_hWnd=m_hWnd;

    //ShowWindow(m_hWnd, m_nCmdShow);
    //UpdateWindow(m_hWnd);


#if 0
    /*
     * This code supplies three different classes, one for each type
     * of data object that handles a different size of data. All the
     * class factories share the same implementation, but their
     * instantiations differ by the type passed in the constructor.
     * When the class factories create objects, they pass that size
     * to the CDataObject contstructor as well.
     */

    UINT            i;
    HRESULT         hr2, hr3;

    for (i=0; i < DOSIZE_CSIZES; i++)
        {
        m_rgpIClassFactory[i]=new CDataObjectClassFactory(i);

        if (NULL==m_rgpIClassFactory[i])
            return FALSE;

        m_rgpIClassFactory[i]->AddRef();
        }

    hr=CoRegisterClassObject(CLSID_DataObjectSmall
        , m_rgpIClassFactory[0], CLSCTX_LOCAL_SERVER
        , REGCLS_MULTIPLEUSE, &m_rgdwRegCO[0]);

    hr2=CoRegisterClassObject(CLSID_DataObjectMedium
        , m_rgpIClassFactory[1], CLSCTX_LOCAL_SERVER
        , REGCLS_MULTIPLEUSE, &m_rgdwRegCO[1]);

    hr3=CoRegisterClassObject(CLSID_DataObjectLarge
        , m_rgpIClassFactory[2], CLSCTX_LOCAL_SERVER
        , REGCLS_MULTIPLEUSE, &m_rgdwRegCO[2]);

    if (FAILED(hr) || FAILED(hr2) || FAILED(hr3))
        return FALSE;
#else
    m_pIClassFactory = new CDataObjectClassFactory();
    if (NULL == m_pIClassFactory)
        return FALSE;
    m_pIClassFactory->AddRef();
#ifdef WIN32
    hr = CoRegisterClassObject( CLSID_DataObjectTest32,
                                m_pIClassFactory,
                                CLSCTX_LOCAL_SERVER,
                                REGCLS_MULTIPLEUSE,
                                &m_dwRegCO );
#else
    hr = CoRegisterClassObject( CLSID_DataObjectTest16,
                                m_pIClassFactory,
                                CLSCTX_LOCAL_SERVER,
                                REGCLS_MULTIPLEUSE,
                                &m_dwRegCO );
#endif // WIN32
    if (FAILED(hr))
        return FALSE;
#endif

    return TRUE;
}


/*
 * CDataObjectClassFactory::CDataObjectClassFactory
 * CDataObjectClassFactory::~CDataObjectClassFactory
 *
 * Constructor Parameters:
 *  iSize           UINT specifying the data size for this class.
 */

CDataObjectClassFactory::CDataObjectClassFactory()
{
    m_cRef=0L;
    return;
}


CDataObjectClassFactory::~CDataObjectClassFactory(void)
{
    return;
}


STDMETHODIMP
CDataObjectClassFactory::QueryInterface(
    REFIID riid,
    PPVOID ppv)
{
    *ppv=NULL;

    //Any interface on this object is the object pointer.
#ifdef ORIGINAL_CODE_LOOKS_WRONG
    if (IID_IUnknown==riid || IID_IClassFactory==riid)
#else
    if (IsEqualIID(IID_IUnknown, riid)|| IsEqualIID(IID_IClassFactory, riid))
#endif
        *ppv = this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG)
CDataObjectClassFactory::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CDataObjectClassFactory::Release(void)
{
    ULONG           cRefT;

    cRefT=--m_cRef;

    if (0L==m_cRef)
        delete this;

    return cRefT;
}


/*
 * CDataObjectClassFactory::CreateInstance
 *
 * Purpose:
 *  Instantiates a CDataObject object that supports the IDataObject
 *  and IUnknown interfaces.  If the caller asks for a different
 *  interface than these two then we fail.
 *
 * Parameters:
 *  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
 *                  being used in an aggregation.
 *  riid            REFIID identifying the interface the caller
 *                  desires to have for the new object.
 *  ppvObj          PPVOID in which to store the desired interface
 *                  pointer for the new object.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise contains
 *                  E_NOINTERFACE if we cannot support the
 *                  requested interface.
 */

STDMETHODIMP
CDataObjectClassFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    PPVOID ppvObj)
{
    PCDataObject        pObj;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=ResultFromScode(E_OUTOFMEMORY);

#ifdef ORIGINAL_CODE_LOOKS_WRONG
    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
#else
    if (NULL!=pUnkOuter && (! IsEqualIID(IID_IUnknown, riid) ) )
#endif
        return ResultFromScode(E_NOINTERFACE);

    //Create the object telling it the data size to work with
    pObj=new CDataObject(pUnkOuter, ObjectDestroyed);

    if (NULL==pObj)
        return hr;

    if (pObj->FInit())
        hr=pObj->QueryInterface(riid, ppvObj);

    g_cObj++;

    if (FAILED(hr))
    {
        delete pObj;
        ObjectDestroyed();  //Decrements g_cObj
    }

    return hr;
}


/*
 * CDataObjectClassFactory::LockServer
 *
 * Purpose:
 *  Increments or decrements the lock count of the serving
 *  IClassFactory object.  When the number of locks goes to
 *  zero and the number of objects is zero, we shut down the
 *  application.
 *
 * Parameters:
 *  fLock           BOOL specifying whether to increment or
 *                  decrement the lock count.
 *
 * Return Value:
 *  HRESULT         NOERROR always.
 */

STDMETHODIMP
CDataObjectClassFactory::LockServer(
    BOOL fLock)
{
    if (fLock)
        g_cLock++;
    else
    {
        g_cLock--;

        //No more objects and no locks, shut the app down.
        if (0L==g_cObj && 0L==g_cLock && IsWindow(g_hWnd))
            PostMessage(g_hWnd, WM_CLOSE, 0, 0L);
    }

    return NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\server\render.cpp ===
#include "dataobj.h"
#include <string.h>



HRESULT
CDataObject::RenderText(
    LPSTGMEDIUM pSTM,
    LPTSTR      lptstr,
    DWORD       flags)
{
    DWORD       cch;
    HGLOBAL     hMem;
    LPTSTR      psz;
    UINT        i;

    if(!(FL_MAKE_ITEM & flags))
        hMem = pSTM->hGlobal;
    else
        hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, m_cDataSize);

    if (NULL==hMem)
        return ResultFromScode(STG_E_MEDIUMFULL);

    cch = 64 / sizeof(TCHAR);
    psz=(LPTSTR)GlobalLock(hMem);

    wsprintf(psz, TEXT("%ld:"), m_cDataSize);

    for (i=lstrlen(psz); i<cch-1, '\0'!=*lptstr; i++, lptstr++)
        *(psz+i) = *lptstr;

    for ( ; i < cch-1; i++)
        *(psz+i)=TEXT(' ') + (i % 32);

    *(psz+i)=0;

    GlobalUnlock(hMem);

    if(FL_MAKE_ITEM & flags)
    {
        pSTM->hGlobal=hMem;
        pSTM->tymed=TYMED_HGLOBAL;
        pSTM->pUnkForRelease=NULL;
    }
    if(FL_PASS_PUNK & flags)
        GetStgMedpUnkForRelease(pSTM, &pSTM->pUnkForRelease);

    return NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\server\dataobj.h ===
/*
 * DATAOBJ.H
 * Data Object Chapter 6
 *
 * Classes that implement the Data Object independent of whether
 * we live in a DLL or EXE.
 *
 * Copyright (c)1993-1995 Microsoft Corporation, All Right Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

#define INC_OLE2
#include <windows.h>
#include <ole2.h>

#include "../my3216.h"
#include "../bookpart.h"

//Type for an object-destroyed callback
typedef void (PASCAL *PFNDESTROYED)(void);


/*
 * The DataObject object is implemented in its own class with its
 * own IUnknown to support aggregation.  It contains one
 * CImpIDataObject object that we use to implement the externally
 * exposed interfaces.
 */


//DATAOBJ.CPP
#ifdef NOT_SIMPLE
LRESULT APIENTRY
AdvisorWndProc(HWND, UINT, WPARAM, LPARAM);
#endif /* NOT_SIMPLE */

class CImpIDataObject;
typedef class CImpIDataObject *PIMPIDATAOBJECT;


class CDataObject : public IUnknown
{
    friend class CImpIDataObject;
#ifdef NOT_SIMPLE
    friend LRESULT APIENTRY AdvisorWndProc(HWND, UINT
                                            , WPARAM, LPARAM);
#endif /* NOT_SIMPLE */

    protected:
        ULONG               m_cRef;
        LPUNKNOWN           m_pUnkOuter;
        PFNDESTROYED        m_pfnDestroy;

        HWND                m_hWndAdvise;   //Popup with Advise menu
        DWORD               m_dwAdvFlags;   //Notification flags

        //Contained interface implemetation
        PIMPIDATAOBJECT     m_pIDataObject;

        //Other interfaces used, implemented elsewhere
        LPDATAADVISEHOLDER  m_pIDataAdviseHolder;

        //Arrays for IDataObject::EnumFormatEtc
#define CFORMATETCGET 1
        ULONG               m_cfeGet;
        FORMATETC           m_rgfeGet[CFORMATETCGET];

        LPSTR               m_dataText;
        ULONG               m_cDataSize;

    protected:
        //Functions for use from IDataObject::GetData
#define FL_MAKE_ITEM   0x01    // StgMedium item must be created.
#define FL_USE_ITEM    0x00    // StgMedium item is allocated, use that.
#define FL_PASS_PUNK   0x02    // put a pUnk in the StgMedium.
        HRESULT     RenderText(LPSTGMEDIUM, LPTSTR, DWORD flags);
        HRESULT     RenderBitmap(LPSTGMEDIUM);
        HRESULT     RenderMetafilePict(LPSTGMEDIUM);

    public:
        CDataObject(LPUNKNOWN, PFNDESTROYED);
        ~CDataObject(void);

        BOOL FInit(void);

        //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
};

typedef CDataObject *PCDataObject;



/*
 * Interface implementations for the CDataObject object.
 */

class CImpIDataObject : public IDataObject
    {
    private:
        ULONG           m_cRef;
        PCDataObject    m_pObj;
        LPUNKNOWN       m_pUnkOuter;

    public:
        CImpIDataObject(PCDataObject, LPUNKNOWN);
        ~CImpIDataObject(void);

        //IUnknown members that delegate to m_pUnkOuter.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IDataObject members
        STDMETHODIMP GetData(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP GetDataHere(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP QueryGetData(LPFORMATETC);
        STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC,LPFORMATETC);
        STDMETHODIMP SetData(LPFORMATETC, LPSTGMEDIUM, BOOL);
        STDMETHODIMP EnumFormatEtc(DWORD, LPENUMFORMATETC *);
        STDMETHODIMP DAdvise(LPFORMATETC, DWORD,  LPADVISESINK
            , DWORD *);
        STDMETHODIMP DUnadvise(DWORD);
        STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *);
    };

/*
 * IEnumFORMATETC object that is created from
 * IDataObject::EnumFormatEtc.  This object lives on its own.
 */


class CEnumFormatEtc : public IEnumFORMATETC
    {
    private:
        ULONG           m_cRef;         //Object reference count
        LPUNKNOWN       m_pUnkRef;      //For reference counting
        ULONG           m_iCur;         //Current element.
        ULONG           m_cfe;          //Number of FORMATETCs in us
        LPFORMATETC     m_prgfe;        //Source of FORMATETCs

    public:
        CEnumFormatEtc(LPUNKNOWN, ULONG, LPFORMATETC);
        ~CEnumFormatEtc(void);

        //IUnknown members that delegate to m_pUnkRef.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IEnumFORMATETC members
        STDMETHODIMP Next(ULONG, LPFORMATETC, ULONG *);
        STDMETHODIMP Skip(ULONG);
        STDMETHODIMP Reset(void);
        STDMETHODIMP Clone(IEnumFORMATETC **);
    };


typedef CEnumFormatEtc *PCEnumFormatEtc;

//////////////////////////////////////////////////////////////////////////////
// Storage Medium IUnknown interface for pUnkForRelease.
//

class CStgMedIf: public IUnknown {
private:
    ULONG m_cRef;
    LPSTGMEDIUM m_pSTM;

public:
    CStgMedIf(LPSTGMEDIUM);

    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
};

//////////////////////////
// API for getting a pUnkForRelease.
//

HRESULT
GetStgMedpUnkForRelease(LPSTGMEDIUM pSTM, IUnknown **pp_unk);

#endif //_DATAOBJ_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perf16\idata\server\stgmedif.cpp ===
#include "dataobj.h"

HRESULT
GetStgMedpUnkForRelease(LPSTGMEDIUM pSTM, IUnknown **pp_unk)
{
    CStgMedIf *p_smi = new CStgMedIf(pSTM);
    HRESULT hr = p_smi->QueryInterface(IID_IUnknown, (PPVOID)pp_unk);
    return hr;
}

CStgMedIf::CStgMedIf(LPSTGMEDIUM pSTM)
{
    m_pSTM = pSTM;
    m_cRef = 0;
}


STDMETHODIMP
CStgMedIf::QueryInterface(
    REFIID riid,
    LPLPVOID ppv
)
{
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPVOID)this;
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG)
CStgMedIf::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CStgMedIf::Release(void)
{
    ULONG   cRefT;

    cRefT = --m_cRef;

    if (0==m_cRef)
    {
        m_pSTM->pUnkForRelease = 0;
        ReleaseStgMedium(m_pSTM);
        delete this;
    }
    return cRefT;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairo.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cairo.inc

Abstract:

    common root include file for daytona version of performance
    project build.  This gets included by all sources files under
    this directory.

!ENDIF

MAJORCOMP   = cairole
MINORCOMP   = perform

OLEDIR=       $(BASEDIR)\private\ole32
OLEUTESTDIR=  $(BASEDIR)\private\oleutest
OLEPERFDIR=   $(OLEUTESTDIR)\perform

INCLUDES=     ;..;$(OLEPERFDIR)\common;$(OLEPERFDIR)\cairole\tests
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\oleprx32\cairo
INCLUDES=     $(INCLUDES);$(OLEDIR)\ih;$(OLEDIR)\common\cairo

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
	      -DWIN32=300	    \
	      -D_CAIRO_=300	    \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE            \
	      -DNOEXCEPTIONS	    \
	      -D_DCOM_		    \
	      -DCOM_THREADING_SUPPORT \
	      -DOLE_THREADING_SUPPORT

CAIRO_PRODUCT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\dll\cairo\makefile.inc ===
obj\i386\oletest.def: oletest.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\daytona.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    daytona.inc

Abstract:

    common root include file for daytona version of performance
    project build.  This gets included by all sources files under
    this directory.

!ENDIF

MAJORCOMP   = cairole
MINORCOMP   = perform

OLEDIR=       $(BASEDIR)\private\ole32
OLEUTESTDIR=  $(BASEDIR)\private\oleutest
OLEPERFDIR=   $(OLEUTESTDIR)\perform

INCLUDES=     ;..;$(OLEPERFDIR)\common;$(OLEPERFDIR)\cairole\tests
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\oleprx32\daytona
INCLUDES=     $(INCLUDES);$(OLEDIR)\ih;$(OLEDIR)\common\daytona

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=100           \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE            \
              -DNOEXCEPTIONS        \
              -DCAIROLE_DOWNLEVEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\dll\testdllx.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	    testdllx.cxx
//
//  Contents:	DLL extensions
//
//  Classes:	
//
//  Functions:	DllGetClassObject
//				DllCanUnloadNow
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------


#include "oletest.hxx"


extern ULONG objCount, lockCount;
extern COleTestClassFactory theFactory;


STDAPI DllGetClassObject (REFCLSID classId, REFIID riid, VOID **ppv)
{
	if (IsEqualGUID (classId, CLSID_COleTestClass))
		return theFactory.QueryInterface (riid, ppv);
	return E_UNEXPECTED;
}



STDAPI DllCanUnloadNow ()
{
	return (objCount==0 && lockCount==0) ? S_OK : E_UNEXPECTED;
}


extern "C"
BOOL _cdecl LibMain (HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\dll\chicago\makefile.inc ===
obj\i386\oletest.def: oletest.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\dll\daytona\makefile.inc ===
obj\i386\oletest.def: oletest.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\svr\bmtstsvr.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	    bmtstsvr.cxx
//
//  Contents:	Test server for benchmark test
//
//  Classes:	
//
//  Functions:	WinMain
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------


#include <oletest.hxx>


extern COleTestClassFactory theFactory;
extern ULONG objCount, lockCount;


int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
	DWORD reg;
	objCount = lockCount = 0;

	OleInitialize (NULL);
	CoRegisterClassObject (CLSID_COleTestClass, (IClassFactory *)&theFactory, 
		CLSCTX_LOCAL_SERVER,0, &reg);

	while (objCount==0 && lockCount==0)
	    Sleep (1000);
	while (objCount || lockCount)
	{
	    Sleep (3000);
	}

	CoRevokeClassObject (reg);

	OleUninitialize ();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\dll\oletest.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	    oletest.cxx
//
//  Contents:	Simple OLE test object
//
//  Classes:	COleTestClass
//
//  Functions:	
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------


#include <oletest.hxx>



ULONG objCount = 0, lockCount = 0;
COleTestClassFactory theFactory;


COleTestClass::COleTestClass ()
{
	refCount = 1;
	objCount++;
}



COleTestClass::~COleTestClass ()
{                        
	objCount--;
}		



SCODE COleTestClass::QueryInterface (THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
	if (IsEqualIID (riid, IID_IUnknown))
		*ppvObj = (LPVOID FAR)(IUnknown*)this;
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}



ULONG COleTestClass::AddRef (THIS)
{
	return (refCount++);
}
    
    
ULONG COleTestClass::Release (THIS)
{
	refCount--;
	if (refCount == 0)
	{
		delete this;
		return 0;
	}
	return refCount;
}


	

SCODE COleTestClassFactory::QueryInterface (THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
	if (IsEqualIID (riid, IID_IUnknown))
		*ppvObj = (LPVOID FAR)(IUnknown*)this;
	else
	{
		if (IsEqualIID (riid, IID_IClassFactory))
			*ppvObj = (LPVOID FAR)(IClassFactory*)this;
		else
		{
			*ppvObj = NULL;
			return E_NOINTERFACE;
		}
	}
	return S_OK;
}



ULONG COleTestClassFactory::AddRef (THIS)
{
	return 1;
}
    
    
ULONG COleTestClassFactory::Release (THIS)
{
	return 1;
}

    
SCODE COleTestClassFactory::CreateInstance (THIS_ LPUNKNOWN pUnkOuter,
	REFIID riid, LPVOID FAR* ppvObject)
{
	*ppvObject = (LPVOID FAR*)(IStream*)new COleTestClass;
	return S_OK;
}

    
    
SCODE COleTestClassFactory::LockServer (THIS_ BOOL fLock)
{
	if (fLock)
		lockCount++;
	else
		lockCount--;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_activ.cxx ===
//+- -----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_activ.cxx
//
//  Contents:	Ole object activation test
//
//  Classes:	COleActivationTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_activ.hxx>
#include <oletest.hxx>


TCHAR *COleActivationTest::Name ()
{
    return TEXT("ObjActivation");
}


SCODE COleActivationTest::Setup (CTestInput *pInput)
{
    SCODE sc;

    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize state
    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apszClsIDName[iCtx]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	INIT_RESULTS(m_ulGetClassObjectTime[iCtx]);
	INIT_RESULTS(m_ulCreateInstanceTime[iCtx]);
	INIT_RESULTS(m_ulLoadTime[iCtx]);
	INIT_RESULTS(m_ulPunkReleaseTime[iCtx]);
	INIT_RESULTS(m_ulCFReleaseTime[iCtx]);
    }

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - InitCOM failed."), sc);
        return	sc;
    }

    return S_OK;
}


SCODE COleActivationTest::Cleanup ()
{	
    UninitCOM();
    return S_OK;
}


SCODE COleActivationTest::Run ()
{
    CStopWatch	  sw;
    IPersistFile  *pIPF = NULL;
    IClassFactory *pICF = NULL;

    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset ();
	    SCODE sc = CoGetClassObject(m_ClsID[iCtx], dwaClsCtx[iCtx], NULL,
				    IID_IClassFactory, (void **)&pICF);
	    m_ulGetClassObjectTime[iCtx][iIter] = sw.Read ();
	    Log (TEXT("CoGetClassObject"), sc);

	    if (SUCCEEDED(sc))
	    {
		sw.Reset();
		sc = pICF->CreateInstance(NULL, IID_IPersistFile, (void **)&pIPF);
		m_ulCreateInstanceTime[iCtx][iIter] = sw.Read ();
		Log (TEXT("CreateInstance"), sc);

		sw.Reset();
		pICF->Release();
		m_ulCFReleaseTime[iCtx][iIter] = sw.Read();

		if (SUCCEEDED(sc))
		{
		    //	load the data
		    sw.Reset();
		    pIPF->Load(apszPerstName[iCtx], 0);
		    m_ulLoadTime[iCtx][iIter] = sw.Read();

		    sw.Reset();
		    pIPF->Release ();
		    m_ulPunkReleaseTime[iCtx][iIter] = sw.Read();
		}
		else
		{
		    m_ulCreateInstanceTime[iCtx][iIter] = NOTAVAIL;
		}
	    }
	    else
	    {
		m_ulGetClassObjectTime[iCtx][iIter] = NOTAVAIL;
	    }
	}
    }

    return S_OK;
}					  



SCODE COleActivationTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("CoGetClassObject"), *m_pInput);

    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	output.WriteString(TEXT("\n"));
	output.WriteClassID (&m_ClsID[iCtx]);
	output.WriteString(apszClsCtx[iCtx]);
	output.WriteString(TEXT("\n"));

	output.WriteResults (TEXT("CoGetClassObject"), m_ulIterations,
			     m_ulGetClassObjectTime[iCtx]);

	output.WriteResults (TEXT("CreateInstance  "), m_ulIterations,
			     m_ulCreateInstanceTime[iCtx]);

	output.WriteResults (TEXT("pICF->Release   "), m_ulIterations,
			     m_ulCFReleaseTime[iCtx]);

	output.WriteResults (TEXT("pIPF->Load      "), m_ulIterations,
			     m_ulLoadTime[iCtx]);

	output.WriteResults (TEXT("pIPF->Release   "), m_ulIterations,
			     m_ulPunkReleaseTime[iCtx]);

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bmp_stg2.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//					
//  File:	bmp_stg2.cxx
//
//  Contents:	Generic Storage parser based test file 2
//
//  Classes:	CStorageParser
//
//  Functions:	Parse and Execute functions for each instruction.
//
//  History:    20-June-94 t-vadims    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <bmp_stg.hxx>
#include <tchar.h>

#define STGTY_ANY	0		// any storage element, stream or storage

//
// Static array of info for each instruction
//
SInstrInfo CStorageParser::m_aInstructions[] =
   { { TEXT("StgIsStorageFile"),
       TEXT("StgIsStorageFile     "),
       Parse_StgIsStorageFile,
       Execute_StgIsStorageFile,
       NULL },

     { TEXT("StgCreateDocFile"), 			
       TEXT("StgCreateDocFile     "),
       Parse_StgCreateDocFile,
       Execute_StgCreateDocFile,
       NULL },

     { TEXT("OpenStorage"),
       TEXT("StgOpenStorage       "),
       Parse_StgOpenStorage,
       Execute_StgOpenStorage ,
       NULL },

     { TEXT("CExposedDocFile::AddRef"),
       TEXT("IStorage::AddRef     "),
       Parse_IStorageAddRef,
       Execute_IStorageAddRef ,
       NULL },

     { TEXT("CExposedDocFile::Release"),
       TEXT("IStorage::Release    "),
       Parse_IStorageRelease,
       Execute_IStorageRelease ,
       NULL },

     { TEXT("CExposedDocFile::Commit"),
       TEXT("IStorage::Commit     "),
       Parse_IStorageCommit,
       Execute_IStorageCommit ,
       NULL },

     { TEXT("CExposedDocFile::Revert"),
       TEXT("IStorage::Revert     "),
       Parse_IStorageRelease,
       Execute_IStorageRelease ,
       NULL },

     { TEXT("CExposedDocFile::CreateStream"),
       TEXT("IStorage::CreateStream"),
       Parse_IStorageCreateStream,
       Execute_IStorageCreateStream ,
       NULL },

     { TEXT("CExposedDocFile::OpenStream"),	
       TEXT("IStorage::OpenStream "),
       Parse_IStorageOpenStream,
       Execute_IStorageOpenStream ,
       NULL },

     { TEXT("CExposedDocFile::CreateStorage"),	
       TEXT("IStorage::CreateStorage"),
       Parse_IStorageCreateStorage,
       Execute_IStorageCreateStorage ,
       NULL },

     { TEXT("CExposedDocFile::OpenStorage"),	
       TEXT("IStorage::OpenStorage"),
       Parse_IStorageOpenStorage,
       Execute_IStorageOpenStorage ,
       NULL },

     { TEXT("CExposedDocFile::DestroyElement"),	
       TEXT("IStorage::DestroyElement"),
       Parse_IStorageDestroyElement,
       Execute_IStorageDestroyElement ,
       NULL },

     { TEXT("CExposedDocFile::RenameElement"),	
       TEXT("IStorage::RenameElement"),
       Parse_IStorageRenameElement,
       Execute_IStorageRenameElement ,
       NULL },

     { TEXT("CExposedDocFile::SetStateBits"),	
       TEXT("IStorage::SetStateBits"),
       Parse_IStorageSetStateBits,
       Execute_IStorageSetStateBits ,
       NULL },

     { TEXT("CExposedDocFile::SetElementTimes"),	
       TEXT("IStorage::SetElementTimes"),
       Parse_IStorageSetElementTimes,
       Execute_IStorageSetElementTimes ,
       NULL },

     { TEXT("CExposedDocFile::SetClass"),	
       TEXT("IStorage::SetClass   "),
       Parse_IStorageSetClass,
       Execute_IStorageSetClass ,
       NULL },

     { TEXT("CExposedDocFile::Stat"),	
       TEXT("IStorage::Stat       "),
       Parse_IStorageStat,
       Execute_IStorageStat ,
       NULL },

     { TEXT("CExposedStream::AddRef"),	
       TEXT("IStream::AddRef      "),
       Parse_IStreamAddRef,
       Execute_IStreamAddRef ,
       NULL },

     { TEXT("CExposedStream::Release"),	
       TEXT("IStream::Release     "),
       Parse_IStreamRelease,
       Execute_IStreamRelease ,
       NULL },

     { TEXT("CExposedStream::Commit"),	
       TEXT("IStream::Commit      "),
       Parse_IStreamCommit,
       Execute_IStreamCommit ,
       NULL },

     { TEXT("CExposedStream::Clone"),	
       TEXT("IStream::Clone       "),
       Parse_IStreamClone,
       Execute_IStreamClone ,
       NULL },

    { TEXT("CExposedStream::Revert"),	
       TEXT("IStream::Revert      "),
       Parse_IStreamRevert,
       Execute_IStreamRevert ,
       NULL },

     { TEXT("CExposedStream::SetSize"),	
       TEXT("IStream::SetSize    "),
       Parse_IStreamSetSize,
       Execute_IStreamSetSize ,
       NULL },

     { TEXT("CExposedStream::Write"),	
       TEXT("IStream::Write        "),
       Parse_IStreamWrite,
       Execute_IStreamWrite ,
       GetName_IStreamWrite },

     { TEXT("CExposedStream::Read"),	
       TEXT("IStream::Read        "),
       Parse_IStreamRead,
       Execute_IStreamRead ,
       GetName_IStreamRead },

     { TEXT("CExposedStream::Seek"),	
       TEXT("IStream::Seek        "),
       Parse_IStreamSeek,
       Execute_IStreamSeek ,
       GetName_IStreamSeek },

     { TEXT("CExposedStream::Stat"),	
       TEXT("IStream::Stat       "),
       Parse_IStreamStat,
       Execute_IStreamStat ,
       NULL }
  };


//
//  Number of instructions in the above array
//
ULONG CStorageParser::m_iMaxInstruction =
	sizeof(CStorageParser::m_aInstructions) /
	sizeof(CStorageParser::m_aInstructions[0]);


//
// Tries to find an "almost" matching name in the storage.
// Used to get around bug of loging functions, that print a '.' instead of unprintable
// characters.
SCODE CStorageParser::CheckForElementName(LPINSTRDATA pInstrData, DWORD dwType)
{
    HRESULT 		hr;
    LPENUMSTATSTG 	pEnum;
    STATSTG		StatStg;
    BOOL		bFound = FALSE;


    hr = m_apStorages[pInstrData->ThisID]->EnumElements(0, NULL, 0, &pEnum);

    while (!bFound && pEnum->Next(1, &StatStg, NULL) == S_OK)
    {
        if (StatStg.type == dwType || dwType == STGTY_ANY)
	{
	    // if the names are the same except for the first letter, copy that letter.
	    if (wcscmp(StatStg.pwcsName + 1, pInstrData->wszParam + 1) == 0)
	    {
	    	pInstrData->wszParam[0] = StatStg.pwcsName[0];
		bFound = TRUE;
	    }

	}
	m_piMalloc->Free(StatStg.pwcsName);
    }

    pEnum->Release();
    return bFound ? S_OK : E_FAIL;
}


/*
--------::In  StgIsStorageFile(stgtest.bm)
--------::Out StgIsStorageFile().  ret == 1
*/
SCODE CStorageParser::Parse_StgIsStorageFile(LPINSTRDATA pInstrData,
						LPTSTR pszPart1,
						LPTSTR pszPart2)
{
#ifdef UNICODE
    swscanf(pszPart1 + 31, L"%[^)]",pInstrData->wszParam);
#else
    TCHAR szName[MAX_PATH];
    sscanf(pszPart1 + 31, "%[^)]", szName);
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    return S_OK;
}


ULONG CStorageParser::Execute_StgIsStorageFile(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;

    sw.Reset();
    hr = StgIsStorageFile(pInstrData->wszParam);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}


/*
--------::In  OpenStorage(stgtest.bm, 00000000, 10, 00000000, 0, 0012F540, 0012F4F8)
--------::Out OpenStorage().  *ppstgOpen == 00000000, ret == 80030050
*/
SCODE CStorageParser::Parse_StgOpenStorage(LPINSTRDATA pInstrData,
					      LPTSTR pszPart1,
					      LPTSTR pszPart2)
{
    ULONG ulStorageID;
    TCHAR szName[MAX_PATH];

   _stscanf(pszPart1 + 26, TEXT("%[^,], %*x, %lx"), szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 + 44, TEXT("%lx"), &ulStorageID);

    pInstrData->OutID = FindStorageID(ulStorageID);
    return S_OK;
}


ULONG CStorageParser::Execute_StgOpenStorage(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;

    sw.Reset();
    hr = StgOpenStorage(pInstrData->wszParam, NULL, pInstrData->dwParam1,
    			NULL, 0, &m_apStorages[pInstrData->OutID]);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}


/*
--------::In  StgCreateDocFile(stgtest.bm, 1011, 0, 0012F53C)
--------::Out StgCreateDocFile().  *ppstgOpen == 50000A5C, ret == 0
*/
SCODE CStorageParser::Parse_StgCreateDocFile(LPINSTRDATA pInstrData,
						LPTSTR pszPart1,
						LPTSTR pszPart2)
{
    ULONG ulStorageID;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1 + 31, TEXT("%[^,], %lx"),
    	    szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 + 49, TEXT("%lx"), &ulStorageID);

    pInstrData->OutID = FindStorageID(ulStorageID);

    return S_OK;
}


ULONG CStorageParser::Execute_StgCreateDocFile(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    OLECHAR	*pwszName;

    pwszName = pInstrData->wszParam;

    if (wcscmp(pwszName, L"(null)") == 0)
    	pwszName = NULL;

    sw.Reset();
    hr = StgCreateDocfile(pwszName, pInstrData->dwParam1,
    			  0, &m_apStorages[pInstrData->OutID]);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::AddRef()
50000A5C::Out CExposedDocFile::AddRef().  ret == 0
*/
SCODE CStorageParser::Parse_IStorageAddRef(LPINSTRDATA pInstrData,
					      LPTSTR pszPart1,
					      LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStorageAddRef(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    m_apStorages[pInstrData->ThisID]->AddRef();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, S_OK);

    return ulTime;
}


/*
50000A5C::In  CExposedDocFile::Release()
50000A5C::Out CExposedDocFile::Release().  ret == 0
*/
SCODE CStorageParser::Parse_IStorageRelease(LPINSTRDATA pInstrData,
					       LPTSTR pszPart1,
					       LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStorageRelease(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    m_apStorages[pInstrData->ThisID]->Release();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, S_OK);

    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::Revert()
50000A5C::Out CExposedDocFile::Revert().  ret == 0
*/
SCODE CStorageParser::Parse_IStorageRevert(LPINSTRDATA pInstrData,
					      LPTSTR pszPart1,
					      LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStorageRevert(LPINSTRDATA pInstrData)
{					
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT 	hr;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->Revert();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::Commit(0)
50000A5C::Out CExposedDocFile::Commit().  ret == 0
*/
SCODE CStorageParser::Parse_IStorageCommit(LPINSTRDATA pInstrData,
					      LPTSTR pszPart1,
					      LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    _stscanf(pszPart1 + 38, TEXT("%lx"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStorageCommit(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->Commit(pInstrData->dwParam1);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::CreateStream(CONTENTS, 1011, 0, 0, 0012F54C)
50000A5C::Out CExposedDocFile::CreateStream().  *ppstm == 500008F4, ret == 0
*/
SCODE CStorageParser::Parse_IStorageCreateStream(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStreamID;
    ULONG ulStorageID;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    _stscanf(pszPart1 + 44, TEXT("%[^,], %lx"),
    	    szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 +	58, TEXT("%lx"), &ulStreamID);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    pInstrData->OutID = FindStreamID(ulStreamID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageCreateStream(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->CreateStream(pInstrData->wszParam,
    						   pInstrData->dwParam1,
						   0, 0,
						   &m_apStreams[pInstrData->OutID]);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;
}


/*
50000A5C::In  CExposedDocFile::OpenStream(CONTENTS, 0 12, 0, 0012F54C)
50000A5C::Out CExposedDocFile::OpenStream().  *ppstm == 500008F4, ret == 0
*/
SCODE CStorageParser::Parse_IStorageOpenStream(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStreamID;
    ULONG ulStorageID;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    _stscanf(pszPart1 + 42, TEXT("%[^,], %*x %lx"),
    	    szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 +	56, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart2 + 73, TEXT("%lx"), &pInstrData->dwParam2);

    pInstrData->ThisID = FindStorageID(ulStorageID);
    pInstrData->OutID = FindStreamID(ulStreamID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageOpenStream(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    SCODE	sc;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->OpenStream(pInstrData->wszParam, 0,
    						   pInstrData->dwParam1, 0,
						   &m_apStreams[pInstrData->OutID]);
    ulTime = sw.Read();

    // check if we failed but script indicated succes, which means that a name could be wrong
    if (FAILED(hr) && SUCCEEDED(pInstrData->dwParam2))
    {
    	sc = CheckForElementName(pInstrData, STGTY_STREAM);
	if (SUCCEEDED(sc))
	{
	    sw.Reset();
    	    hr = m_apStorages[pInstrData->ThisID]->OpenStream(pInstrData->wszParam, 0,
    						   pInstrData->dwParam1, 0,
						   &m_apStreams[pInstrData->OutID]);
	    ulTime = sw.Read();
	}
    }

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;			
}

/*
50000A5C::In  CExposedDocFile::CreateStorage(STORAGE1, 1011, 0, 0, 0012F54C)
50000A5C::Out CExposedDocFile::CreateStorage().  *ppstm == 500008F4, ret == 0
*/
SCODE CStorageParser::Parse_IStorageCreateStorage(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID1;
    ULONG ulStorageID2;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID1);
    _stscanf(pszPart1 + 45, TEXT("%[^,], %lx"),
    	    szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 +	59, TEXT("%lx"), &ulStorageID2);

    pInstrData->ThisID = FindStorageID(ulStorageID1);
    pInstrData->OutID = FindStorageID(ulStorageID2);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageCreateStorage(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->CreateStorage(pInstrData->wszParam,
    						   pInstrData->dwParam1,
						   0, 0,
						   &m_apStorages[pInstrData->OutID]);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::OpenStorage(CONTENTS, 00000000, 1011, 00000000, 0, 0012F54C)
50000A5C::Out CExposedDocFile::OpenStorage().  *ppstm == 500008F4, ret == 0
*/					
SCODE CStorageParser::Parse_IStorageOpenStorage(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID1;
    ULONG ulStorageID2;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID1);
    _stscanf(pszPart1 + 43, TEXT("%[^,], %*lx, %lx"),
    	    szName, &pInstrData->dwParam1);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 +	57, TEXT("%lx"), &ulStorageID2);
    _stscanf(pszPart2 + 74, TEXT("%lx"), &pInstrData->dwParam2);

    pInstrData->ThisID = FindStorageID(ulStorageID1);
    pInstrData->OutID = FindStorageID(ulStorageID2);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageOpenStorage(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    SCODE	sc;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->OpenStorage(pInstrData->wszParam,
    		   				   NULL,
    						   pInstrData->dwParam1,
						   NULL, 0,
						   &m_apStorages[pInstrData->OutID]);
    ulTime = sw.Read();

    // check if we failed but script indicated succes, which means that a name could be wrong
    if (FAILED(hr) && SUCCEEDED(pInstrData->dwParam2))
    {
    	sc = CheckForElementName(pInstrData, STGTY_STORAGE);
	if (SUCCEEDED(sc))
	{
	    sw.Reset();
    	    hr = m_apStorages[pInstrData->ThisID]->OpenStorage(pInstrData->wszParam, NULL,
    						   pInstrData->dwParam1, NULL, 0,
						   &m_apStorages[pInstrData->OutID]);
	    ulTime = sw.Read();
	}
    }
    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;
}


/*
50000A5C::In  CExposedDocFile::DestroyElement(CONTENTS)
50000A5C::Out CExposedDocFile::DestroyElement().  ret == 0
*/					
SCODE CStorageParser::Parse_IStorageDestroyElement(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
#ifdef UNICODE
    swscanf(pszPart1 + 46, L"%[^,]", pInstrData->wszParam);
#else
    TCHAR szName[MAX_PATH];
    sscanf(pszPart1 + 46, "%[^,]", szName);
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif
    _stscanf(pszPart2 + 57, TEXT("%lx"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageDestroyElement(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    SCODE	sc;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->DestroyElement(pInstrData->wszParam);
    ulTime = sw.Read();

        // check if we failed but script indicated succes, which means that a name could be wrong
    if (FAILED(hr) && SUCCEEDED(pInstrData->dwParam1))
    {
    	sc = CheckForElementName(pInstrData, STGTY_ANY);
	if (SUCCEEDED(sc))
	{
	    sw.Reset();
    	    hr = m_apStorages[pInstrData->ThisID]->DestroyElement(pInstrData->wszParam);
	    ulTime = sw.Read();
	}
    }
    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}


/*
50000A5C::In  CExposedDocFile::SetStateBits(%lu, %lu)
50000A5C::Out CExposedDocFile::SetStateBits().  ret == ??
*/					
SCODE CStorageParser::Parse_IStorageSetStateBits(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    _stscanf(pszPart1 + 44, TEXT("%lu, %lu"),
    	    &pInstrData->dwParam1, &pInstrData->dwParam2);

    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageSetStateBits(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->SetStateBits(pInstrData->dwParam1, pInstrData->dwParam2);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}


/*
50000A5C::In  CExposedDocFile::SetClass(?)
50000A5C::Out CExposedDocFile::SetClass().  ret == ??
*/					
SCODE CStorageParser::Parse_IStorageSetClass(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);

    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageSetClass(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
static const CLSID  ClsID =
    {0x0000013a,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->SetClass(ClsID);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}


/*
5000A0FC::In  CExposedDocFile::SetElementTimes(contents, 0012F518, 0012F518, 00000000)
5000A0FC::Out CExposedDocFile::SetElementTimes().  ret == 80030005
*/					
SCODE CStorageParser::Parse_IStorageSetElementTimes(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;
    TCHAR szName[MAX_PATH];

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    _stscanf(pszPart1 + 47, TEXT("%[^,], %lx, %lx, %lx"),
    	    szName, &pInstrData->dwParam1,
    	    &pInstrData->dwParam2, &pInstrData->dwParam3);
#ifdef UNICODE
    wcscpy(pInstrData->wszParam, szName);
#else
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
#endif

    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageSetElementTimes(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    FILETIME	ft;
    SYSTEMTIME	st;
    LPFILETIME  pft1, pft2, pft3;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    // get current time
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    pft1 =  pInstrData->dwParam1 ? &ft : NULL;
    pft2 =  pInstrData->dwParam2 ? &ft : NULL;
    pft3 =  pInstrData->dwParam3 ? &ft : NULL;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->SetElementTimes(pInstrData->wszParam,
    							   pft1, pft2, pft3);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}



/*
50000A5C::In  CExposedDocFile::RenameElement(Name1, Name2)
50000A5C::Out CExposedDocFile::RenameElement().  ret == ??
*/					
SCODE CStorageParser::Parse_IStorageRenameElement(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;

    pInstrData->wszParam2 = (OLECHAR *)m_piMalloc->Alloc(MAX_PATH * sizeof(OLECHAR));
    if (pInstrData->wszParam2 == NULL)
    {
    	Log(TEXT("Can't allocate memory in for RenameElement"), E_OUTOFMEMORY);
	return E_FAIL;
    }
    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
#ifdef UNICODE
    swscanf(pszPart1 + 45, L"%[^,], %[^)]",
            pInstrData->wszParam, pInstrData->wszParam2);
#else
    TCHAR szName[MAX_PATH], szName2[MAX_PATH];
    _stscanf(pszPart1 + 45, "%[^,], %[^)]",
            szName, szName2);
    mbstowcs(pInstrData->wszParam, szName, strlen(szName)+1);
    mbstowcs(pInstrData->wszParam2, szName2, strlen(szName2)+1);
#endif
    _stscanf(pszPart2 + 56, TEXT("%lx"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageRenameElement(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    SCODE	sc;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->RenameElement(pInstrData->wszParam,
    							 pInstrData->wszParam2);
    ulTime = sw.Read();

    // check if we failed but script indicated succes,
    // which means that a name could be wrong
    if (FAILED(hr) && SUCCEEDED(pInstrData->dwParam1))
    {
    	sc = CheckForElementName(pInstrData, STGTY_ANY);
	if (SUCCEEDED(sc))
	{
	    sw.Reset();
    	    hr = m_apStorages[pInstrData->ThisID]->RenameElement(pInstrData->wszParam,
    							 	 pInstrData->wszParam2);
	    ulTime = sw.Read();
	}
    }

    m_piMalloc->Free(pInstrData->wszParam2);
    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;
}

/*
50000A5C::In  CExposedDocFile::Stat(xxxxxxxx)
50000A5C::Out CExposedDocFile::Stat().  ret == ??
*/					
SCODE CStorageParser::Parse_IStorageStat(LPINSTRDATA pInstrData,
						    LPTSTR pszPart1,
						    LPTSTR pszPart2)
{
    ULONG ulStorageID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStorageID);
    pInstrData->ThisID = FindStorageID(ulStorageID);

    return S_OK;
}

ULONG CStorageParser::Execute_IStorageStat(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;
    STATSTG	StatStg;

    if (FAILED(CheckThisStorageID(pInstrData->ThisID)))
       	return TEST_FAILED;

    sw.Reset();
    hr = m_apStorages[pInstrData->ThisID]->Stat(&StatStg, STATFLAG_NONAME);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedStream::AddRef()
50000A5C::Out CExposedStream::AddRef().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamAddRef(LPINSTRDATA pInstrData,
					     LPTSTR pszPart1,
					     LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamAddRef(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    ULONG	ulRes;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;
    sw.Reset();
    ulRes = m_apStreams[pInstrData->ThisID]->AddRef();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, S_OK);

    return ulTime;
}


/*
50000A5C::In  CExposedStream::Release()
50000A5C::Out CExposedStream::Release().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamRelease(LPINSTRDATA pInstrData,
					      LPTSTR pszPart1,
					      LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamRelease(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    m_apStreams[pInstrData->ThisID]->Release();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, S_OK);

    return ulTime;
}

/*
50000A5C::In  CExposedStream::Revert()
50000A5C::Out CExposedStream::Revert().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamRevert(LPINSTRDATA pInstrData,
					     LPTSTR pszPart1,
					     LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamRevert(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Revert();
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedStream::Commit(0)
50000A5C::Out CExposedStream::Commit().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamCommit(LPINSTRDATA pInstrData,
					     LPTSTR pszPart1,
					     LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart1 + 37, TEXT("%lx"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamCommit(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Commit(pInstrData->dwParam1);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedStream::SetSize(10)
50000A5C::Out CExposedStream::SetSize().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamSetSize(LPINSTRDATA pInstrData,
					     LPTSTR pszPart1,
					     LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart1 + 38, TEXT("%lu"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamSetSize(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    ULARGE_INTEGER liSize;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    LISet32(liSize, pInstrData->dwParam1);

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->SetSize(liSize);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

/*
50000A5C::In  CExposedStream::Write(xxxxxxxx, 1234, xxxxxxxx)
50000A5C::Out CExposedStream::Write().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamWrite(LPINSTRDATA pInstrData,
					    LPTSTR pszPart1,
					    LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart1 + 46, TEXT("%lu"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamWrite(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    BYTE	*pData;

    pData = (BYTE *) m_piMalloc->Alloc(pInstrData->dwParam1);
    if (pData == NULL)
    {
    	Log(TEXT("Can't allocate memory for write"), E_OUTOFMEMORY);
	return TEST_FAILED;
    }

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Write(pData, pInstrData->dwParam1, NULL);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    m_piMalloc->Free(pData);

    return ulTime;
}


TCHAR *CStorageParser::GetName_IStreamWrite(LPINSTRDATA pInstrData)
{
    _stscanf(m_szBuffer, TEXT("IStream::Write %-8lu"), pInstrData->dwParam1);
    return m_szBuffer;
}


/*
50000A5C::In  CExposedStream::Read(xxxxxxxx, 1234, xxxxxxxx)
50000A5C::Out CExposedStream::Read().  ret == 0
*/
SCODE CStorageParser::Parse_IStreamRead(LPINSTRDATA pInstrData,
					   LPTSTR pszPart1,
					   LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart1 + 45, TEXT("%lu"), &pInstrData->dwParam1);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamRead(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    BYTE	*pData;

    pData = (BYTE *) m_piMalloc->Alloc(pInstrData->dwParam1);
    if (pData == NULL)
    {
    	Log(TEXT("Can't allocate memory for read"), E_OUTOFMEMORY);
	return TEST_FAILED;
    }

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Read(pData, pInstrData->dwParam1, NULL);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    m_piMalloc->Free(pData);

    return ulTime;
}

TCHAR *CStorageParser::GetName_IStreamRead(LPINSTRDATA pInstrData)
{
    _stscanf(m_szBuffer, TEXT("IStream::Read %-8lu"), pInstrData->dwParam1);
    return m_szBuffer;
}

/*
50000A5C::In  CExposedStream::Seek(0, 1234, xxxxxxxx)
50000A5C::Out CExposedStream::Seek().  ulPos == %lu,  ret == 0
*/
SCODE CStorageParser::Parse_IStreamSeek(LPINSTRDATA pInstrData,
					   LPTSTR pszPart1,
					   LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);
    _stscanf(pszPart1 + 35, TEXT("%ld, %lu"),
    	    &pInstrData->dwParam1, &pInstrData->dwParam2);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamSeek(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    LARGE_INTEGER liSize;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    LISet32(liSize, pInstrData->dwParam1);

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Seek(liSize,
    					       pInstrData->dwParam2,
    					       NULL);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}

TCHAR *CStorageParser::GetName_IStreamSeek(LPINSTRDATA pInstrData)
{
    _stscanf(m_szBuffer, TEXT("IStream::Seek %lu %lu"),
        pInstrData->dwParam1, pInstrData->dwParam2);

    return m_szBuffer;
}


/*
500074A4::In  CExposedStream::Clone(0012DCE8)
500074A4::Out CExposedStream::Clone().  *ppstm == 50007324, ret == 0
*/
SCODE CStorageParser::Parse_IStreamClone(LPINSTRDATA pInstrData,
					 LPTSTR pszPart1,
					 LPTSTR pszPart2)
{
    ULONG ulStreamID1;
    ULONG ulStreamID2;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID1);
    _stscanf(pszPart2 +	50, TEXT("%lx"), &ulStreamID2);

    pInstrData->ThisID = FindStreamID(ulStreamID1);
    pInstrData->OutID = FindStreamID(ulStreamID2);

    return S_OK;
}

ULONG CStorageParser::Execute_IStreamClone(LPINSTRDATA pInstrData)
{
    CStopWatch  sw;
    ULONG	ulTime;
    HRESULT	hr;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;

    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Clone(&m_apStreams[pInstrData->OutID]);
    ulTime = sw.Read();

    Log(m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);
    return ulTime;
}

/*
50000A5C::In  CExposedStream::Stat(xxxxxxxx)
50000A5C::Out CExposedStream::Stat).  ret == 0
*/
SCODE CStorageParser::Parse_IStreamStat(LPINSTRDATA pInstrData,
					     LPTSTR pszPart1,
					     LPTSTR pszPart2)
{
    ULONG ulStreamID;

    _stscanf(pszPart1, TEXT("%lx"), &ulStreamID);

    pInstrData->ThisID = FindStreamID(ulStreamID);
    return S_OK;
}


ULONG CStorageParser::Execute_IStreamStat(LPINSTRDATA pInstrData)
{
    CStopWatch 	sw;
    ULONG 	ulTime;
    HRESULT	hr;
    STATSTG	StatStg;

    if (FAILED(CheckThisStreamID(pInstrData->ThisID)))
    	return TEST_FAILED;


    sw.Reset();
    hr = m_apStreams[pInstrData->ThisID]->Stat(&StatStg, STATFLAG_NONAME);
    ulTime = sw.Read();

    Log (m_aInstructions[pInstrData->ulInstrID].szPrintName, hr);

    return ulTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_alloc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_alloc.cxx
//
//  Contents:	IMalloc test
//
//  Classes:	COleAllocTest
//
//  History:    29-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_alloc.hxx>


TCHAR *COleAllocTest::Name ()
{
    return TEXT("IMalloc");
}


SCODE COleAllocTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    SCODE sc;

    // Get number of iterations
    m_ulIterations = pInput->GetIterations(Name());
    m_ulSize = 32;

    INIT_RESULTS (m_ulAllocTime);
    INIT_RESULTS (m_ulFreeTime);
    INIT_RESULTS (m_ulReallocTime);
    INIT_RESULTS (m_ulGetSizeTime);
    INIT_RESULTS (m_ulDidAllocTime);
    INIT_RESULTS (m_ulHeapMinimizeTime);

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    //	create an instance of the object to marshal
    m_pMalloc = NULL;

    sc = CoGetMalloc(MEMCTX_TASK, &m_pMalloc);

    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoGetMalloc failed"), sc);
	return sc;
    }

    return sc;
}


SCODE COleAllocTest::Cleanup ()
{
    //	release objects
    if (m_pMalloc)
	m_pMalloc->Release();

    UninitCOM();
    return S_OK;
}


SCODE COleAllocTest::Run ()
{
	CStopWatch sw;
	LPVOID FAR pv;

	//  make the various IMalloc calls
	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    pv = m_pMalloc->Alloc(m_ulSize);
	    m_ulAllocTime[iIter] = sw.Read();
	    Log(TEXT("IMalloc::Alloc"), (pv) ? S_OK : E_OUTOFMEMORY);

	    sw.Reset();
	    pv = m_pMalloc->Realloc(pv, m_ulSize*2);
	    m_ulReallocTime[iIter] = sw.Read();
	    Log(TEXT("IMalloc::Realloc"), (pv) ? S_OK : E_OUTOFMEMORY);

	    sw.Reset();
	    ULONG ulSize = m_pMalloc->GetSize(pv);
	    m_ulGetSizeTime[iIter] = sw.Read();
	    Log(TEXT("IMalloc::GetSize"), (ulSize > 0) ? S_OK : E_OUTOFMEMORY);

	    sw.Reset();
	    INT fRes = m_pMalloc->DidAlloc(pv);
	    m_ulDidAllocTime[iIter] = sw.Read();
	    Log(TEXT("IMalloc::DidAlloc"), (fRes) ? S_OK : E_OUTOFMEMORY);

	    sw.Reset();
	    m_pMalloc->Free(pv);
	    m_ulFreeTime[iIter] = sw.Read();
	}

	//  loop through all the sizes.  starting with a size of 8,
	//  we double it each time for MAX_SIZE_CNT times.

	ULONG ulSize = 8;
	for (ULONG iSize = 0; iSize <MAX_SIZE_CNT; iSize++)
	{
	    //	loop through all the number of iterations
	    for (iIter=0; iIter<m_ulIterations; iIter++)
	    {
		VOID *pv[TEST_MAX_ITERATIONS];

		sw.Reset();
		for (ULONG iCnt=0; iCnt<iIter+1; iCnt++)
		{
		    pv[iCnt] = m_pMalloc->Alloc(ulSize);
		}
		m_ulAllocSizeTime[iSize][iIter] = sw.Read();

		sw.Reset();
		for (iCnt=0; iCnt<iIter+1; iCnt++)
		{
		    m_pMalloc->Free(pv[iCnt]);
		}
		m_ulFreeSizeTime[iSize][iIter] = sw.Read();

		for (iCnt=0; iCnt<iIter+1; iCnt++)
		{
		    if (pv[iCnt] == NULL)
		    {
			Log(TEXT("IMalloc::Alloc failed."), E_OUTOFMEMORY);

			//  an allocation failed, correct the times
			m_ulAllocSizeTime[iSize][iIter] = NOTAVAIL;
			m_ulFreeSizeTime[iSize][iIter] = NOTAVAIL;
		    }
		}


	    }

	    //	double the allocation size
	    ulSize *= 2;
	}

	return S_OK;
}


SCODE COleAllocTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(),
			   TEXT("OLE20 IMalloc MEMCTX_TASK"),
			   *m_pInput);

    output.WriteString	(TEXT("\n"));
    output.WriteResults (TEXT("IMalloc->Alloc     32:"), m_ulIterations, m_ulAllocTime);
    output.WriteResults (TEXT("IMalloc->Realloc   64:"), m_ulIterations, m_ulReallocTime);
    output.WriteResults (TEXT("IMalloc->GetSize      "), m_ulIterations, m_ulGetSizeTime);
    output.WriteResults (TEXT("IMalloc->DidAlloc     "), m_ulIterations, m_ulDidAllocTime);
    output.WriteResults (TEXT("IMalloc->Free         "), m_ulIterations, m_ulFreeTime);
    output.WriteString	(TEXT("\n"));

    output.WriteString	(TEXT("N consecutive allocations of the same size:\n"));
    ULONG ulSize = 8;
    for (ULONG iSize = 0; iSize<MAX_SIZE_CNT; iSize++)
    {
	//  format output string containing allocation size
	TCHAR	szBuf[80];
	wsprintf(szBuf, TEXT("IMalloc->Alloc %6d:"), ulSize);

	output.WriteResults (szBuf, m_ulIterations, m_ulAllocSizeTime[iSize]);
	output.WriteResults (TEXT("IMalloc->Free       "), m_ulIterations, m_ulFreeSizeTime[iSize]);

	//  double the size
	ulSize *= 2;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bmguid.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmguid.cxx
//
//  Contents:	OLE test guids
//
//  Classes:	
//
//  Functions:	
//
//  History:    12-August-93 t-martig    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <oletest.hxx>

const GUID CLSID_COleTestClass =
       {0x20730701,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass1 =
       {0x20730711,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass2 =
       {0x20730712,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass3 =
       {0x20730713,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass4 =
       {0x20730714,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass5 =
       {0x20730715,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass6 =
       {0x20730716,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass7 =
       {0x20730717,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID CLSID_COleTestClass8 =
       {0x20730718,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


const GUID CLSID_TestProp =
       {0x20730722,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bmp_test.cxx ===
//
// A very simple test based on parser base classes
// It understands only two commands 1 and 2 in first column.
// 2's are simply ignored.
// on execution of 1's I just loop for the id of current command
// which is increased by 1 with every command encounterd, starting with 0.
//
//
//   t-vadims
//

#include <headers.cxx>
#pragma hdrstop

#include <bmp_test.hxx>	


SCODE CSimpleTest::SetParserObject ()
{
    m_pParser = new CParserTest;
    return S_OK;
}

SCODE CSimpleTest::DeleteParserObject ()
{
    delete m_pParser;
    return S_OK;
}


WCHAR* CSimpleTest::Name ()
{
    return L"ParserTest";
}

WCHAR* CSimpleTest::SectionHeader()
{
    return L"Simple test of interpreting files";
}


SCODE CParserTest::Setup (CTestInput *pInput)
{
   /* do any neccessary setup staff */
   m_iInstrID = 0;
   return S_OK;
}

SCODE CParserTest::Cleanup ()
{
   /* do any neccessary clean up */
   return S_OK;
}

ULONG CParserTest::ParseNewInstruction(LPWSTR pwszInstr)
{
    ULONG ulID;

    if (pwszInstr[0] == L'1')
    {
   	m_iInstrID ++;
   	ulID = m_iInstrID;
    }
    else if (pwszInstr[0] == L'2')
   	ulID = NOT_INSTRUCTION;
    else
    	ulID = INVALID_INSTRUCTION;

    return ulID;   		
}

ULONG CParserTest::ExecuteInstruction(ULONG ulID)
{
    CStopWatch sw;

    sw.Reset();
    for (ULONG i =0; i <=ulID; i++)
       /* empty loop */;
    return sw.Read();
}


WCHAR* CParserTest::InstructionName(ULONG ulID)
{
    wsprintf(m_wszBuf, L"Instruction %ld", ulID);
    return m_wszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bmp_stg.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//					 
//  File:	bmp_stg.cxx
//
//  Contents:	Generic Storage parser based test
//
//  Classes:	CStorageParserTest, CStorageParser
//
//  Functions:	
//
//  History:    15-June-94 t-vadims    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <valid.h>
#include <tchar.h>
#include <bmp_stg.hxx>	

//+------------------------------------------------------------------------
//
//  Class:	CStorageParserTest
//
//  Functions:	
//
//  History:    15-June-94 t-vadims    Created
//      
//--------------------------------------------------------------------------

SCODE CStorageParserTest::SetParserObject ()
{
    m_pParser = new CStorageParser;
    return S_OK;
}


SCODE CStorageParserTest::DeleteParserObject ()
{
    delete m_pParser;
    return S_OK;
}


TCHAR* CStorageParserTest::Name ()
{
    return TEXT("StorageParserTest");
}


TCHAR *CStorageParserTest::SectionHeader()
{
    return TEXT("Storage test from log");
}



//+------------------------------------------------------------------------
//
//  Class:	CStorageParser
//
//  Functions:	
//
//  History:    15-June-94 t-vadims    Created
//
//--------------------------------------------------------------------------

#define  STATE_OFFSET	      10	  // location of "In"/"Out" in log string
#define  NAME_OFFSET	      14	  // location of command name in log string

#define  MAX_NAME 	      50	  

#define DEF_ARRAYSIZE	      10


//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::Setup, public
//
//  Synopsis:	Makes all neccessary initializations.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CStorageParser::Setup (CTestInput *pInput)
{
    SCODE sc;


    sc = CoGetMalloc(MEMCTX_TASK, &m_piMalloc);
    if (FAILED(sc))
   	return sc;

    m_iStreamCount = 0;
    m_iStreamArraySize = DEF_ARRAYSIZE;
    m_aulStreamID = (ULONG *)m_piMalloc->Alloc(m_iStreamArraySize * 
   					      sizeof(ULONG));
    m_apStreams = (LPSTREAM *)m_piMalloc->Alloc(m_iStreamArraySize * 
   					      sizeof(LPSTREAM));

    m_iStorageCount = 0;
    m_iStorageArraySize = DEF_ARRAYSIZE;
    m_aulStorageID = (ULONG *)m_piMalloc->Alloc(m_iStorageArraySize * 
   					      sizeof(ULONG));
    m_apStorages = (LPSTORAGE *)m_piMalloc->Alloc(m_iStorageArraySize * 
   					      sizeof(LPSTORAGE));

    m_iInstrCount = 0;
    m_iInstrArraySize = DEF_ARRAYSIZE;
    m_apInstrData = (LPINSTRDATA *)m_piMalloc->Alloc(m_iInstrArraySize * 
   					      sizeof(LPINSTRDATA));


    m_bGotFirstPart = FALSE;

    if (m_apInstrData == NULL || m_aulStorageID == NULL ||
       	m_apStorages == NULL || m_aulStreamID == NULL ||
	m_apStreams == NULL )
    {
    	Cleanup();
	Log(TEXT("Setup can't allocate memory"), E_OUTOFMEMORY);
	return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::Cleanup, public
//
//  Synopsis:	Makes all neccessary cleanup
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CStorageParser::Cleanup ()
{
    /* do any neccessary clean up */
    if(m_piMalloc)
    {
    	if (m_aulStreamID)
   	    m_piMalloc->Free(m_aulStreamID);
	if (m_apStreams)
   	    m_piMalloc->Free(m_apStreams);
	if (m_aulStorageID)
   	    m_piMalloc->Free(m_aulStorageID);
	if (m_apStorages)
   	    m_piMalloc->Free(m_apStorages); 


	for (ULONG i = 0; i < m_iInstrCount; i++)
	   delete m_apInstrData[i];

	if (m_apInstrData)
   	    m_piMalloc->Free(m_apInstrData);

	m_piMalloc->Release();
	m_piMalloc = NULL;
    }
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::AddInstruction, public
//
//  Synopsis:	Parse new instruction and add it to array if it is valid
//
//  Return:	ID of instruction
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::AddInstruction(LPTSTR pszFirstPart, LPTSTR pszSecondPart)
{
    ULONG  ulInstrID;
    SCODE  sc;

    TCHAR  szInstrName[MAX_NAME];
    TCHAR  szSecondName[MAX_NAME];

    if (_tcsncmp(pszFirstPart + STATE_OFFSET, TEXT("In"), 2) != 0)
   	return INVALID_INSTRUCTION;

    if (_tcsncmp(pszSecondPart + STATE_OFFSET, TEXT("Out"), 3) != 0)
   	return INVALID_INSTRUCTION;

   
    // check if the same instruction name;
    GetInstructionName(szInstrName, pszFirstPart);
    GetInstructionName(szSecondName, pszSecondPart);

    if(_tcscmp(szInstrName, szSecondName) != 0)
   	return INVALID_INSTRUCTION;


    // determine the instruction 
    ulInstrID = INVALID_INSTRUCTION;
    for (ULONG i = 0; i < m_iMaxInstruction; i++)
       	if (_tcscmp(szInstrName, m_aInstructions[i].szLogName) == 0)
	{
	    ulInstrID = i;
	    break;
	}

   if(ulInstrID == INVALID_INSTRUCTION)
   	return INVALID_INSTRUCTION;

    // fill appropriate structure fields
    SInstrData *pInstrData = new SInstrData;
    pInstrData->ulInstrID = ulInstrID;

    sc = (this->*m_aInstructions[ulInstrID].Parse)(pInstrData, 
    						      pszFirstPart, 
    						      pszSecondPart);

    if (FAILED(sc))
    {
    	delete pInstrData;
    	return INVALID_INSTRUCTION;
    }

    return AddNewInstrData(pInstrData);
}			   

//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::IgnoreInstruction, private
//
//  Synopsis:	Check if this instruction should be ignored.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
BOOL CStorageParser::IgnoreInstruction(LPTSTR pszInstr)
{
    TCHAR szName[MAX_NAME];

    // We Ignore those instructions that are completely implemented
    // in terms of other instructions that are also logged.

    GetInstructionName(szName, pszInstr);

    if (_tcscmp (szName, TEXT("CExposedStream::QueryInterface")) == 0 ||
   	_tcscmp (szName, TEXT("CExposedDocFile::QueryInterface")) == 0 ||
   	_tcscmp (szName, TEXT("CExposedStream::CopyTo")) == 0  ||
   	_tcscmp (szName, TEXT("CExposedDocFile::MoveElementTo")) == 0 ||
   	_tcscmp (szName, TEXT("CExposedDocFile::CopyTo")) == 0 ||
   	_tcscmp (szName, TEXT("ExposedDocFile::CopyTo")) == 0 
	)
    {
 	return TRUE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::ParseNewInstruction, public
//
//  Synopsis:	Parse new line of file, and return its id.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::ParseNewInstruction(LPTSTR pszInstr)
{
    ULONG ulID;

    if (IgnoreInstruction(pszInstr))
    	return  NOT_INSTRUCTION;

    if (m_bGotFirstPart)     
    {
    	// out part of instruction. We can now add it.
   	ulID = AddInstruction(m_szBuffer, pszInstr);
	m_bGotFirstPart = FALSE;
    }
    else
    {
    	// save In part of instruction, and fake CTimerBase into
	// thinking that this wasn't an instruction.	   
   	_tcscpy(m_szBuffer, pszInstr);
	ulID = NOT_INSTRUCTION;
	m_bGotFirstPart = TRUE;
    }

    return ulID;   		
}

//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::ExecuteInstruction, public
//
//  Synopsis:	Execute instruction with given id.
//
//  Return:	time taken to execute it.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::ExecuteInstruction(ULONG ulID)
{
    SInstrData  *pInstrData = m_apInstrData[ulID];

    return (this->*m_aInstructions[pInstrData->ulInstrID].Execute)(pInstrData);
}


//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::InstructionName, public
//
//  Synopsis:	Return name of instruction.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
TCHAR * CStorageParser::InstructionName(ULONG ulID)
{
    SInstrData  *pInstrData = m_apInstrData[ulID];

    if (m_aInstructions[pInstrData->ulInstrID].GetName != NULL)
    	return (this->*m_aInstructions[pInstrData->ulInstrID].GetName)(pInstrData);
    else
    	return m_aInstructions[pInstrData->ulInstrID].szPrintName;
}


//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::GetInstructionName, public
//
//  Synopsis:	Extract instruction name from the instruction.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CStorageParser::GetInstructionName (LPTSTR pszName, LPTSTR pszInstruction)
{
    _stscanf(pszInstruction + NAME_OFFSET, TEXT("%[^(]"), pszName);
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::AddNewInstrData, public
//
//  Synopsis:	Adds new instruction to instrData array.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::AddNewInstrData (LPINSTRDATA pInstrData)
{
    if (m_iInstrCount >= m_iInstrArraySize)
    {
    	m_iInstrArraySize *= 2;
	m_apInstrData = (LPINSTRDATA *)m_piMalloc->Realloc(m_apInstrData,
				  m_iInstrArraySize * sizeof(LPINSTRDATA));
    }

    m_apInstrData[m_iInstrCount] = pInstrData;

    return m_iInstrCount++;
}
					           
//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::FindStorageID, public
//
//  Synopsis:	finds or creates new storage, based on ID.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::FindStorageID (ULONG ulStgID)
{
    for (ULONG i = 0; i < m_iStorageCount; i++)
    	if (m_aulStorageID[i] == ulStgID)
	    return i;

    if (m_iStorageCount >= m_iStorageArraySize)
    {
    	m_iStorageArraySize *= 2;
	m_aulStorageID = (ULONG *)m_piMalloc->Realloc(m_aulStorageID, 
				  m_iStorageArraySize * sizeof(ULONG));

	m_apStorages = (LPSTORAGE *)m_piMalloc->Realloc(m_apStorages,
				  m_iStorageArraySize * sizeof(LPSTORAGE));
				
    }
    m_aulStorageID[m_iStorageCount] = ulStgID;
    m_apStorages[m_iStorageCount] = NULL;

    return m_iStorageCount++;
}


//+-------------------------------------------------------------------
//
//  Member:	CStorageParser::FindStreamID, public
//
//  Synopsis:	finds or creates new stream, based on ID.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
ULONG CStorageParser::FindStreamID (ULONG ulStreamID)
{
    for (ULONG i = 0; i < m_iStreamCount; i++)
    	if (m_aulStreamID[i] == ulStreamID)
	    return i;

    if (m_iStreamCount >= m_iStreamArraySize)
    {
    	m_iStreamArraySize *=2;
	m_aulStreamID = (ULONG *)m_piMalloc->Realloc(m_aulStreamID, 
				  m_iStreamArraySize * sizeof(ULONG));

	m_apStreams = (LPSTREAM *)m_piMalloc->Realloc(m_apStreams,
				  m_iStreamArraySize * sizeof(LPSTREAM));
				
    }
    m_aulStreamID[m_iStreamCount] = ulStreamID;
    m_apStreams[m_iStreamCount] = NULL;

    return m_iStreamCount++;
}

//+-------------------------------------------------------------------
//
//  Members:	CStorageParser::CheckThisStorageID, public
//		CStorageParser::CheckThisStreamID, public
//
//  Synopsis:	Check if storage/stream with given id can be dereferenced.
//		(must be non null).
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------

SCODE CStorageParser::CheckThisStorageID(ULONG ulStorageID)
{
    if(m_apStorages[ulStorageID] == NULL || 
       ! IsValidInterface(m_apStorages[ulStorageID]))
    {					       
    	Log(TEXT("Trying to dereference an unassigned Storage"), E_FAIL);
	return E_FAIL;
    }
    return S_OK;
}


SCODE CStorageParser::CheckThisStreamID(ULONG ulStreamID)
{
    if(m_apStreams[ulStreamID] == NULL ||
       ! IsValidInterface(m_apStreams[ulStreamID]))
    {
    	Log(TEXT("Trying to dereference an unassigned Stream"), E_FAIL);
	return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_cgps.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_cgps.cxx
//
//  Contents:	test CoGetPSClsid
//
//  Classes:	CCGPSTest
//
//  History:	07-Oct-95   Rickhi	Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop
#include <bm_cgps.hxx>


extern const IID *iid[];



TCHAR *CCGPSTest::Name ()
{
    return TEXT("CoGetPSClsidTest");
}


SCODE CCGPSTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize timing arrays
    INIT_RESULTS(m_ulCoGetPSClsid);


    SCODE sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
    }

    return sc;
}


SCODE CCGPSTest::Cleanup ()
{
    UninitCOM();
    return S_OK;
}


SCODE CCGPSTest::Run ()
{
    CStopWatch	sw;
    CLSID	clsid;

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
	SCODE sc = CoGetPSClsid(*iid[iIter], &clsid);
	m_ulCoGetPSClsid[iIter] = sw.Read();

	if (FAILED(sc))
	{
	    Log (TEXT("CoGetPSClsid failed."), sc);
	}
    }

    return S_OK;
}					


SCODE CCGPSTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("CoGetPSClsid"), *m_pInput);

    output.WriteString	(TEXT("\n"));
    output.WriteResults (TEXT("CoGetPSClsid "), m_ulIterations, m_ulCoGetPSClsid);

    return S_OK;
}
	
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_filio.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//					
//  File:	bm_filio.cxx
//
//  Contents:	Basic File IO test
//
//  Classes:	CFileIOTest
//
//  History:    04-Aug-94 t-vadims    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_filio.hxx>
#include <memory.h>

#define DEF_DATASIZE    16384

TCHAR *CFileIOTest::Name ()
{
    return TEXT("FileIOTest");
}

SCODE CFileIOTest::Setup (CTestInput *pInput)
{
    SCODE sc;
    TCHAR pszValue[16];
    ULONG i;

    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    // get malloc interface for this task
    m_piMalloc = NULL;
    sc = CoGetMalloc(MEMCTX_TASK, &m_piMalloc);
    if (FAILED(sc))
    {
    	Log (TEXT("Setup - CoGetMalloc"), sc);
	Cleanup();
    	return sc;
    }

    // get values of various paremeters from ini file

    m_iStartSize = pInput->GetConfigInt(Name(), TEXT("StartSize"), 16);
    if(m_iStartSize <= 0)
    	m_iStartSize = 16;

    m_iEndSize = pInput->GetConfigInt(Name(), TEXT("EndSize"), DEF_DATASIZE);

    // initialize array to be written to the file.
    m_pbData = (BYTE *)m_piMalloc->Alloc(m_iEndSize);
    if(m_pbData == NULL)
    {
    	Log (TEXT("Setup - Cannot allocate memory"), E_OUTOFMEMORY);
	Cleanup();
	return E_OUTOFMEMORY;
    }

    for (i=0; i < m_iEndSize; i++)
        m_pbData[i] = (BYTE)i;


    m_iRepeatFactor = pInput->GetConfigInt(Name(), TEXT("RepeatFactor"), 1);

    if (m_iRepeatFactor > MAX_REPS)
    	m_iRepeatFactor = MAX_REPS;

    // Figure out how many different sizes we're going to write.
    // and the size of the final file.
    m_ulTotalSize = 0;
    for(m_ulNumSizes = 0, i = m_iStartSize; i <= m_iEndSize; i *=2, m_ulNumSizes++)
	m_ulTotalSize += i * m_iRepeatFactor;


    if (m_iRepeatFactor * m_ulNumSizes > MAX_READS)
    {
    	Log(TEXT("Too many different sizes and/or repeat factor is too big"), E_FAIL);
	Cleanup();
	return E_FAIL;
    }

    m_flStandardCreateFlags = 0;
    // get file name to be used and values of other parameters
    pInput->GetConfigString(Name(), TEXT("FileName"), TEXT("stgtest.bm"),
    			    m_pszFile, MAX_PATH);

    pInput->GetConfigString(Name(), TEXT("WriteThrough"), TEXT("OFF"), pszValue, 15);

    if (lstrcmpi(pszValue, TEXT("ON")) == 0)
    	m_flStandardCreateFlags |= FILE_FLAG_WRITE_THROUGH;

    pInput->GetConfigString(Name(), TEXT("AccessMode"), TEXT("NORMAL"), m_pszAccessMode, 15);

    if (lstrcmpi(m_pszAccessMode, TEXT("ASYNC")) == 0)
    {
    	m_flAccessMode = AM_ASYNC;
	m_flStandardCreateFlags |= FILE_FLAG_OVERLAPPED;
    }
    else if (lstrcmpi(m_pszAccessMode, TEXT("MAPPED")) == 0)
    {
    	m_flAccessMode = AM_MAPPED;
    }
    else
    	m_flAccessMode = AM_NORMAL;

    pInput->GetConfigString(Name(), TEXT("Flush"), TEXT("OFF"), pszValue, 15);

    if (lstrcmpi(pszValue, TEXT("ON")) == 0)
    	m_bFlush = TRUE;
    else
    	m_bFlush = FALSE;

    pInput->GetConfigString(Name(), TEXT("ReadMode"), TEXT("SEQUENTIAL"),
    			    m_pszReadMode, 15);

    if(lstrcmpi(m_pszReadMode, TEXT("SEQUENTIAL")) == 0)
    	m_bSequentialRead = TRUE;
    else
    	m_bSequentialRead = FALSE;


    InitTimings();

    return S_OK;
}


void CFileIOTest::InitTimings()
{
    ULONG i;

    //	initialize timing arrays

    INIT_RESULTS(m_ulOpenFileW);
    INIT_RESULTS(m_ulClose1);
    INIT_RESULTS(m_ulOpenFileR);
    INIT_RESULTS(m_ulClose2);

    ZERO_RESULTS(m_ulWriteTotal);
    ZERO_RESULTS(m_ulReadTotal);
    ZERO_RESULTS(m_ulSeekTotal);

    INIT_RESULTS(m_ulCreateFileMappingW);
    INIT_RESULTS(m_ulMapViewW);
    INIT_RESULTS(m_ulCloseMap1);
    INIT_RESULTS(m_ulUnmapView1);
    ZERO_RESULTS(m_ulFlush1);

    INIT_RESULTS(m_ulCreateFileMappingR);
    INIT_RESULTS(m_ulMapViewR);
    INIT_RESULTS(m_ulCloseMap2);
    INIT_RESULTS(m_ulUnmapView2);
    ZERO_RESULTS(m_ulFlush2);



    for (i = 0; i < MAX_READS; i++)
    {
    	INIT_RESULTS(m_ulWrite[i]);
    	INIT_RESULTS(m_ulRead[i]);
	INIT_RESULTS(m_ulSeek[i]);
    }

    for (i = 0; i < 2; i++ )
    	ZERO_RESULTS(m_ulTotal[i]);

}


SCODE CFileIOTest::Cleanup ()
{
    //	delete the file
    DeleteFile (m_pszFile);
    if(m_piMalloc)
    {
    	if (m_pbData)
    	    m_piMalloc->Free(m_pbData);

	m_pbData = NULL;

	m_piMalloc->Release();
	m_piMalloc = NULL;

    }

    UninitCOM();

    return S_OK;
}

SCODE CFileIOTest::Run ()
{
	CStopWatch  sw;
	ULONG       iIter;
	HANDLE      hFile;
	ULONG       cb;
	ULONG       iSize;
	ULONG	    i, iCount;
	ULONG	    cbCurOffset;

        // Async mode variables
	OVERLAPPED  ov;
	LPOVERLAPPED lpov;
	BOOL        fRes;

	// file-mapped mode variables
        LPBYTE	    lpbFileData;
	HANDLE	    hMap;


	ov.Offset = 0;
	ov.OffsetHigh = 0;
	ov.hEvent = NULL;

	if (IsAsyncMode())
	    lpov = &ov;
	else
	    lpov = NULL;


	// create normal file and write some data to it
	for (iIter = 0; iIter < m_ulIterations; iIter++)
	{
	    sw.Reset();
	    hFile = CreateFile(m_pszFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
	    		       m_flStandardCreateFlags | FILE_ATTRIBUTE_NORMAL, NULL);
	    m_ulOpenFileW[iIter] = sw.Read();
	    Log(TEXT("CreateFile for writing"),
	    	(hFile != INVALID_HANDLE_VALUE) ? S_OK : E_FAIL);
	    if(hFile == INVALID_HANDLE_VALUE)
	        return E_FAIL;

	    if (IsMappedMode())  // create file mapping
	    {

	        sw.Reset();
	        hMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, m_ulTotalSize, NULL);
		m_ulCreateFileMappingW[iIter] = sw.Read();

		Log(TEXT("CreateFileMapping"), (hMap != NULL) ? S_OK : E_FAIL);
		if(hMap == NULL)
		{
		    TCHAR szBuf[80];
		    wsprintf(szBuf, TEXT("GetLastError = %ld , FileSize = %ld"), GetLastError(), m_ulTotalSize);
		    Log(szBuf, E_FAIL);
		    CloseHandle(hFile);
		    return E_FAIL;
		}

		sw.Reset();
		lpbFileData = (LPBYTE)MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0);
		m_ulMapViewW[iIter] = sw.Read();

		Log(TEXT("MapViewOfFile"), (lpbFileData != NULL) ? S_OK : E_FAIL);
		if(lpbFileData == NULL)
		{
		    TCHAR szBuf[80];
		    wsprintf(szBuf, TEXT("GetLastError = %ld"), GetLastError());
		    Log(szBuf, E_FAIL);
		    CloseHandle(hMap);
		    CloseHandle(hFile);
		    return E_FAIL;
		}

	    }

	    cbCurOffset = 0;
	    iCount = 0;
	    for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    {

	      for (i = 0; i < m_iRepeatFactor; i++)
	      {
	
	 	if (IsMappedMode())
		{
		    sw.Reset();
		    memcpy(lpbFileData + cbCurOffset, m_pbData, iSize);
	     	    m_ulWrite[iCount][iIter] = sw.Read();
		    cb = iSize; // force correct cb for error check
		}
		else
		{
		    ov.Offset = cbCurOffset;
		    sw.Reset();
	    	    fRes = WriteFile(hFile, (LPSTR)m_pbData, iSize, &cb, lpov);
	     	    m_ulWrite[iCount][iIter] = sw.Read();
		}
		m_ulWriteTotal[iIter] += m_ulWrite[iCount][iIter];

		if (IsAsyncMode())	// if in async mode wait for result
		{
		     if(!fRes)
		     {
		     	Log(TEXT("Doing Actual Async call"), S_OK);
			GetOverlappedResult(hFile, lpov, &cb, TRUE);
		     }

		}

		Log(TEXT("Writing data"), cb == iSize ? S_OK : E_FAIL);

		cbCurOffset += iSize;
		iCount++;
	      }
	    }
	    Log(TEXT("WriteFile X bytes"), S_OK );

            if (IsMappedMode())
	    {
	    	if (m_bFlush)
		{
		    sw.Reset();
		    fRes = FlushViewOfFile((LPVOID) lpbFileData, 0);
		    m_ulFlush1[iIter] = sw.Read();
		    Log(TEXT("FlushViewOfFile"), fRes ? S_OK : E_FAIL);
		}	

	    	sw.Reset();
		fRes = UnmapViewOfFile((LPVOID) lpbFileData);
		m_ulUnmapView1[iIter] = sw.Read();
		Log(TEXT("UnmapViewOfFile"), fRes ? S_OK : E_FAIL);
	
	    	sw.Reset();
		CloseHandle(hMap);
		m_ulCloseMap1[iIter] = sw.Read();
		Log(TEXT("CloseHandle of file-mapping"), S_OK);
	    }
            else if (m_bFlush)
	    {
	    	sw.Reset();
		fRes = FlushFileBuffers(hFile);
		m_ulFlush1[iIter] = sw.Read();
	        Log(TEXT("FlushFileBuffers"), fRes ? S_OK : E_FAIL);
	    }

	    sw.Reset();
	    CloseHandle(hFile);
	    m_ulClose1[iIter] = sw.Read();

	    m_ulTotal[0][iIter] = m_ulOpenFileW[iIter] +
	                    	  m_ulWriteTotal[iIter] +
				  m_ulFlush1[iIter] +
	                    	  m_ulClose1[iIter];

	    if (IsMappedMode())
	    {
	    	m_ulTotal[0][iIter] +=  m_ulCreateFileMappingW[iIter] +
					m_ulMapViewW[iIter] +
					m_ulUnmapView1[iIter] +
					m_ulCloseMap1[iIter];
	    }

	}

	// try to read from that file
	for (iIter = 0; iIter < m_ulIterations; iIter++)
	{
	    sw.Reset();
	    hFile = CreateFile(m_pszFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
	    		       m_flStandardCreateFlags | FILE_ATTRIBUTE_NORMAL, NULL);
	    m_ulOpenFileR[iIter] = sw.Read();
	    Log(TEXT("CreateFile for reading"),
	    	(hFile != INVALID_HANDLE_VALUE) ? S_OK : E_FAIL);
	    if(hFile == INVALID_HANDLE_VALUE)
	        return E_FAIL;

	    if (IsMappedMode())  // create file mapping
	    {
	        sw.Reset();
	        hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
		m_ulCreateFileMappingR[iIter] = sw.Read();

		Log(TEXT("CreateFileMapping"), (hMap != NULL) ? S_OK : E_FAIL);
		if(hMap == NULL)
		{
		    CloseHandle(hFile);
		    return E_FAIL;
		}

		sw.Reset();
		lpbFileData = (LPBYTE)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
		m_ulMapViewR[iIter] = sw.Read();

		Log(TEXT("MapViewOfFile"), (lpbFileData != NULL) ? S_OK : E_FAIL);
		if(lpbFileData == NULL)
		{
		    CloseHandle(hMap);
		    CloseHandle(hFile);
		    return E_FAIL;
		}

	    }

	    cbCurOffset = 0;
	    iCount = 0;

	    if (m_bSequentialRead)
	    {
	    	for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    	{
		  for (i =0; i < m_iRepeatFactor; i++)
		  {
	
	            if (IsMappedMode())
		    {
		    	sw.Reset();
		    	memcpy(m_pbData, lpbFileData + cbCurOffset, iSize);
	     	    	m_ulRead[iCount][iIter] = sw.Read();
			cb = iSize;	 // force correct cb for error check
	    	    }
		    else
		    {
		    	ov.Offset = cbCurOffset;
	 	    	sw.Reset();
	   	    	fRes = ReadFile(hFile, (LPSTR)m_pbData, iSize, &cb, lpov);
	     	    	m_ulRead[iCount][iIter] = sw.Read();
		    }
	    	    m_ulReadTotal[iIter] += m_ulRead[iCount][iIter];

		    if (IsAsyncMode())   // in async mode wait for result
		    {
		     	if(!fRes)
		     	{
		     	    Log(TEXT("Doing Actual Async call"), S_OK);
			    GetOverlappedResult(hFile, lpov, &cb, TRUE);
		        }

		    }

		    Log(TEXT("Reading data"),  cb == iSize ? S_OK : E_FAIL);

		    cbCurOffset += iSize;
		    iCount++;
		  }
	    	}

	    	Log(TEXT("ReadFile Sequential"), S_OK);
	    }
	    else
	    {
	        cbCurOffset = m_ulTotalSize;
	    	for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    	{
	    	  for ( i =0; i< m_iRepeatFactor; i++)
		  {
		    cbCurOffset -= iSize;
		    ov.Offset = cbCurOffset;

		    if (IsNormalMode())
		    {
	    	    	sw.Reset();
	    	    	SetFilePointer(hFile, cbCurOffset, NULL, FILE_BEGIN);
	     	    	m_ulSeek[iCount][iIter] = sw.Read();
	     	    	m_ulSeekTotal[iIter] += m_ulSeek[iCount][iIter];
		    }
	    	
	 	    if (IsMappedMode())
		    {
		    	sw.Reset();
		    	memcpy(m_pbData, lpbFileData + cbCurOffset, iSize);
	     	    	m_ulRead[iCount][iIter] = sw.Read();
			cb = iSize;  // force correct cb for error check.
		    }
		    else
		    {
		    	sw.Reset();
  	    		fRes = ReadFile(hFile, (LPSTR)m_pbData, iSize, &cb, lpov);
	     	    	m_ulRead[iCount][iIter] = sw.Read();
		    }
	     	    m_ulReadTotal[iIter] = m_ulRead[iCount][iIter];

		    if (IsAsyncMode())
		    {
		     	if(!fRes)
		     	{
		     	    Log(TEXT("Doing Actual Async call"), S_OK);
			    GetOverlappedResult(hFile, lpov, &cb, TRUE);
		        }
		    }
		    Log(TEXT("Reading data"),  cb == iSize ? S_OK : E_FAIL);
		    iCount++;
	    	  }
		}
	    	Log(TEXT("ReadFile Random"), S_OK);
	    }


            if (IsMappedMode())
	    {
	    	if (m_bFlush)
		{
		    sw.Reset();
		    fRes = FlushViewOfFile((LPVOID) lpbFileData, 0);
		    m_ulFlush2[iIter] = sw.Read();
		    Log(TEXT("FlushViewOfFile"), fRes ? S_OK : E_FAIL);
		}	

	    	sw.Reset();
		fRes = UnmapViewOfFile((LPVOID) lpbFileData);
		m_ulUnmapView2[iIter] = sw.Read();
		Log(TEXT("UnmapViewOfFile"), fRes ? S_OK : E_FAIL);
	
	    	sw.Reset();
		CloseHandle(hMap);
		m_ulCloseMap2[iIter] = sw.Read();
		Log(TEXT("CloseHandle of file-mapping"), S_OK);
	    }
	    else if ( m_bFlush)
	    {
	    	sw.Reset();
		fRes = FlushFileBuffers(hFile);
		m_ulFlush2[iIter] = sw.Read();
	        Log(TEXT("FlushFileBuffers"), fRes ? S_OK : E_FAIL);
	    }

	    sw.Reset();
	    CloseHandle(hFile);
	    m_ulClose2[iIter] = sw.Read();
	    Log(TEXT("CloseHandle of File"), S_OK);

	    m_ulTotal[1][iIter] = m_ulOpenFileR[iIter] +
	    			  m_ulSeekTotal[iIter] +
	    	                  m_ulReadTotal[iIter] +
				  m_ulFlush2[iIter] +
	        	          m_ulClose2[iIter];
	    if (IsMappedMode())
	    {
	    	m_ulTotal[1][iIter] +=  m_ulCreateFileMappingR[iIter] +
					m_ulMapViewR[iIter] +
					m_ulUnmapView2[iIter] +
					m_ulCloseMap2[iIter];
	    }
    	}


    	return S_OK;
}


SCODE CFileIOTest::Report (CTestOutput &output)
{
    TCHAR pszBuf[80];
    ULONG i, iSize, iCount;

    wsprintf(pszBuf, TEXT("File IO in %s Mode with %s Read/Writes"),
    	      m_pszAccessMode, m_pszReadMode);
    output.WriteSectionHeader (Name(), pszBuf, *m_pInput);

    wsprintf(pszBuf, TEXT("WriteThrough is %s\n"),
    		(m_flStandardCreateFlags & FILE_FLAG_WRITE_THROUGH) ? TEXT("ON") : TEXT("OFF"));
    output.WriteString (pszBuf);

    wsprintf(pszBuf, TEXT("Flush is %s\n\n"), m_bFlush ? TEXT("ON") : TEXT("OFF"));
    output.WriteString (pszBuf);


    output.WriteResults (TEXT("CreateFile   WRITE "), m_ulIterations,
    			 m_ulOpenFileW);

    if (IsMappedMode())
    {
    	output.WriteResults(TEXT("CreateFileMapping"), m_ulIterations,
    			    m_ulCreateFileMappingW);

	output.WriteResults(TEXT("MapViewOfFile    "), m_ulIterations,
			    m_ulMapViewW);
    }

    output.WriteString (TEXT("\n"));

    iCount = 0;
    for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
    {
        for (i = 0; i < m_iRepeatFactor; i++)
	{

    	     wsprintf(pszBuf, TEXT("WriteFile %-9d"), iSize);

    	     output.WriteResults (pszBuf, m_ulIterations, m_ulWrite[iCount]);
	     iCount++;
	}
    }

    output.WriteResults (TEXT("Write     Total    "), m_ulIterations, m_ulWriteTotal);

    output.WriteString (TEXT("\n"));

    if (IsMappedMode())
    {
    	if (m_bFlush)
	    output.WriteResults(TEXT("FlushViewOfFile  "), m_ulIterations,
			    m_ulFlush1);
		
	output.WriteResults(TEXT("UnmapViewOfFile  "), m_ulIterations,
			    m_ulUnmapView1);

    	output.WriteResults(TEXT("CloseMapping     "), m_ulIterations,
    			    m_ulCloseMap1);
    }

    else if (m_bFlush)
	    output.WriteResults(TEXT("FlushFileBuffers "), m_ulIterations,
			    m_ulFlush1);

    output.WriteResults (TEXT("CloseHandle         "), m_ulIterations,
    			 m_ulClose1);

    output.WriteResults (TEXT("Total               "), m_ulIterations,
    			 m_ulTotal[0]);
    output.WriteString (TEXT("\n\n"));

    output.WriteResults (TEXT("CreateFile    READ  "), m_ulIterations,
    			 m_ulOpenFileR);

    if (IsMappedMode())
    {
    	output.WriteResults(TEXT("CreateFileMapping"), m_ulIterations,
    			    m_ulCreateFileMappingR);

	output.WriteResults(TEXT("MapViewOfFile    "), m_ulIterations,
			    m_ulMapViewR);
    }

    output.WriteString (TEXT("\n"));

    iCount =0;
    for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
    {
        for (i=0; i < m_iRepeatFactor; i++)
	{
    	    if (!m_bSequentialRead && IsNormalMode())
	    {
    	    	wsprintf(pszBuf, TEXT("SetFilePosition %-9d"), m_iEndSize - iSize);
    	    	output.WriteResults (pszBuf, m_ulIterations, m_ulSeek[iCount]);
	    }
    	    wsprintf(pszBuf, TEXT("ReadFile  %-9d"), iSize);
    	    output.WriteResults (pszBuf, m_ulIterations, m_ulRead[iCount]);
	    iCount++;
	}
    }

    if (!m_bSequentialRead && IsNormalMode())
        output.WriteResults (TEXT("Seek      Total  "), m_ulIterations, m_ulSeekTotal);

    output.WriteResults (TEXT("Read      Total  "), m_ulIterations, m_ulReadTotal);

    output.WriteString (TEXT("\n"));

    if (IsMappedMode())
    {
    	if (m_bFlush)
	    output.WriteResults(TEXT("FlushViewOfFile  "), m_ulIterations,
			    m_ulFlush2);

	output.WriteResults(TEXT("UnmapViewOfFile  "), m_ulIterations,
			    m_ulUnmapView2);

    	output.WriteResults(TEXT("CloseMapping     "), m_ulIterations,
    			    m_ulCloseMap2);

    }
    else if ( m_bFlush)
	    output.WriteResults(TEXT("FlushFileBuffers "), m_ulIterations,
			    m_ulFlush2);

    output.WriteResults (TEXT("CloseHandle         "), m_ulIterations,
    			 m_ulClose2);

    output.WriteResults (TEXT("Total               "), m_ulIterations,
    			 m_ulTotal[1]);

    output.WriteString (TEXT("\n"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_init.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_init.cxx
//
//  Contents:	OleInitialize/OleUninitialize tests
//
//  Classes:	COleInitializeTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_init.hxx>
#include <oletest.hxx>


DWORD dwInitFlag = 0;

TCHAR *COleInitializeTest::Name ()
{
    return TEXT("OleInitialize");
}


SCODE COleInitializeTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize state
    INIT_RESULTS(m_ulOleInitializeTime);
    INIT_RESULTS(m_ulOleUninitializeTime);
    INIT_RESULTS(m_ulRepOleInitializeTime);
    INIT_RESULTS(m_ulRepOleUninitializeTime);

    INIT_RESULTS(m_ulCoInitializeTime);
    INIT_RESULTS(m_ulCoUninitializeTime);
    INIT_RESULTS(m_ulRepCoInitializeTime);
    INIT_RESULTS(m_ulRepCoUninitializeTime);

    return S_OK;
}


SCODE COleInitializeTest::Cleanup ()
{	
    return S_OK;
}


SCODE COleInitializeTest::Run ()
{
    CStopWatch	sw;
    SCODE	sc;

    //	compute times for OleInit, OleUninit.
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
#ifdef OLE_THREADING_SUPPORT
	sc = OleInitializeEx(NULL, dwInitFlag);
#else
	sc = OleInitialize(NULL);
#endif
	m_ulOleInitializeTime[iIter] = sw.Read();
	Log (TEXT("OleInitialize"), sc);

	if (SUCCEEDED(sc))
	{
	    sw.Reset();
	    OleUninitialize();
	    m_ulOleUninitializeTime[iIter] = sw.Read();
	    Log (TEXT("OleUninitialize"), sc);
	}
	else
	{
	    m_ulOleInitializeTime[iIter] = NOTAVAIL;
	}

	sw.Reset();
#ifdef COM_THREADING_SUPPORT
	sc = CoInitializeEx(NULL, dwInitFlag);
#else
	sc = CoInitialize(NULL);
#endif
	m_ulCoInitializeTime[iIter] = sw.Read();
	Log (TEXT("CoInitialize"), sc);

	if (SUCCEEDED(sc))
	{
	    sw.Reset();
	    CoUninitialize();
	    m_ulCoUninitializeTime[iIter] = sw.Read();
	    Log (TEXT("CoUninitialize"), sc);
	}
	else
	{
	    m_ulCoInitializeTime[iIter] = NOTAVAIL;
	}

    }

    //	first, compute times for repetitive OleInit
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
#ifdef OLE_THREADING_SUPPORT
	sc = OleInitializeEx(NULL, dwInitFlag);
#else
	sc = OleInitialize(NULL);
#endif
	m_ulRepOleInitializeTime[iIter] = sw.Read();
	Log (TEXT("OleInitialize"), sc);

	if (FAILED(sc))
	{
	    m_ulRepOleInitializeTime[iIter] = NOTAVAIL;
	}
    }

    //	second, compute times for repetitive OleUninit
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
	OleUninitialize();
	m_ulRepOleUninitializeTime[iIter] = sw.Read();
	Log (TEXT("OleUninitialize"), sc);
    }


    //	first, compute times for repetitive CoInit
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
#ifdef COM_THREADING_SUPPORT
	sc = CoInitializeEx(NULL, dwInitFlag);
#else
	sc = CoInitialize(NULL);
#endif
	m_ulRepCoInitializeTime[iIter] = sw.Read();
	Log (TEXT("CoInitialize"), sc);

	if (FAILED(sc))
	{
	    m_ulRepCoInitializeTime[iIter] = NOTAVAIL;
	}
    }

    //	second, compute times for repetitive CoUninit
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
	CoUninitialize();
	m_ulRepCoUninitializeTime[iIter] = sw.Read();
	Log (TEXT("CoUninitialize"), sc);
    }

    return S_OK;
}					  



SCODE COleInitializeTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("OleInitialize / OleUninitialize"), *m_pInput);

    output.WriteResults (TEXT("\nOleInitialize     "), m_ulIterations,
			 m_ulOleInitializeTime);

    output.WriteResults (TEXT("OleUninitialize   "), m_ulIterations,
			 m_ulOleUninitializeTime);

    output.WriteResults (TEXT("\nRepOleInitialize  "), m_ulIterations,
			 m_ulRepOleInitializeTime);

    output.WriteResults (TEXT("RepOleUninitialize"), m_ulIterations,
			 m_ulRepOleUninitializeTime);

    output.WriteResults (TEXT("\nCoInitialize     "), m_ulIterations,
			 m_ulCoInitializeTime);

    output.WriteResults (TEXT("CoUninitialize   "), m_ulIterations,
			 m_ulCoUninitializeTime);

    output.WriteResults (TEXT("\nRepCoInitialize  "), m_ulIterations,
			 m_ulRepCoInitializeTime);

    output.WriteResults (TEXT("RepCoUninitialize"), m_ulIterations,
			 m_ulRepCoUninitializeTime);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_api.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_api.cxx
//
//  Contents:	Miscellaneous OLE API tests
//
//  Classes:	CApiTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_api.hxx>


const GUID CLSID_Balls =
    {0x0000013a,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_Dummy =
    {0x00000142,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};



TCHAR *CApiTest::Name ()
{
    return TEXT("ApiTest");
}


SCODE CApiTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize timing arrays
    INIT_RESULTS(m_ulCoBuildVersion);
    INIT_RESULTS(m_ulOleBuildVersion);

    INIT_RESULTS(m_ulCoGetCurrentProcess);
    INIT_RESULTS(m_ulCoGetMalloc);


    //	time APIs

    INIT_RESULTS(m_ulCoFileTimeNow);
    INIT_RESULTS(m_ulCoFileTimeToDosDateTime);
    INIT_RESULTS(m_ulCoDosDateTimeToFileTime);


    //	registry & class APIs

    INIT_RESULTS(m_ulCoCreateGuid);
    INIT_RESULTS(m_ulCoTreatAsClass);
    INIT_RESULTS(m_ulCoGetTreatAsClass);
    INIT_RESULTS(m_ulCoIsOle1Class);
    INIT_RESULTS(m_ulGetClassFile);

    INIT_RESULTS(m_ulStringFromCLSID);
    INIT_RESULTS(m_ulCLSIDFromString);
    INIT_RESULTS(m_ulProgIDFromCLSID);
    INIT_RESULTS(m_ulStringFromIID);
    INIT_RESULTS(m_ulIIDFromString);

    INIT_RESULTS(m_ulCLSIDFromProgID);
    INIT_RESULTS(m_ulStringFromGUID2);


    // Get ClsID for this Ctx from the .ini file
    CLSID ClsID;

    HRESULT sc = pInput->GetGUID(&ClsID, Name(), apszClsIDName[1]);
    if (FAILED(sc))
    {
	Log (TEXT("Setup - GetClassID failed."), sc);
	return sc;
    }

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
	return	sc;
    }


    // Create an instance
    IClassFactory *pICF = NULL;

    sc = CoGetClassObject(ClsID, dwaClsCtx[1], NULL,
			  IID_IClassFactory, (void **)&pICF);
    if (SUCCEEDED(sc))
    {
	IPersistFile *pIPF = NULL;

	sc = pICF->CreateInstance(NULL, IID_IPersistFile,
				  (void **)&pIPF);
	pICF->Release();
	if (SUCCEEDED(sc))
	{
	    //	save the class instance in the storage
	    sc = pIPF->Save(apszPerstName[1], FALSE);
	    pIPF->Release();

	    if (FAILED(sc))
	    {
		Log (TEXT("Setup - pIPF->Save failed."), sc);
	    }
	}
	else
	{
	    Log (TEXT("Setup - CreateInstance failed"), sc);
	}
    }
    else
    {
	Log (TEXT("Setup - CoGetClassObject failed"), sc);
    }

    return sc;
}


SCODE CApiTest::Cleanup ()
{
    UninitCOM();

    //	delete the file
    CHAR    szPerstName[MAX_PATH];
    wcstombs(szPerstName, apszPerstName[1], wcslen(apszPerstName[1])+1);
    _unlink (szPerstName);

    return S_OK;
}


SCODE CApiTest::Run ()
{
	CStopWatch  sw;
	SCODE	    sc;

	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    DWORD bldver = CoBuildVersion();
	    m_ulCoBuildVersion[iIter] = sw.Read();
	}

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    DWORD bldver = OleBuildVersion();
	    m_ulOleBuildVersion[iIter] = sw.Read();
	}

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    DWORD pid = CoGetCurrentProcess();
	    m_ulCoGetCurrentProcess[iIter] = sw.Read();
	}

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    IMalloc *pMalloc = NULL;
	    sw.Reset();
	    sc = CoGetMalloc(MEMCTX_TASK, &pMalloc);
	    if (SUCCEEDED(sc))
	    {
		pMalloc->Release();
	    }
	    m_ulCoGetMalloc[iIter] = sw.Read();
	    Log (TEXT("CoGetMalloc"), sc);
	}

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    FILETIME ft;
	    WORD wDosDate, wDosTime;

	    sw.Reset();
	    sc = CoFileTimeNow(&ft);
	    m_ulCoFileTimeNow[iIter] = sw.Read();
	    Log (TEXT("CoFileTimeNow"), sc);

	    sw.Reset();
	    sc = CoFileTimeToDosDateTime(&ft, &wDosDate, &wDosTime);
	    m_ulCoFileTimeToDosDateTime[iIter] = sw.Read();
	    Log (TEXT("CoFileTimeToDosDateTime"), sc);

	    sw.Reset();
	    sc = CoDosDateTimeToFileTime(wDosDate, wDosTime, &ft);
	    m_ulCoDosDateTimeToFileTime[iIter] = sw.Read();
	    Log (TEXT("CoDosDateTimeToFileTime"), sc);
	}


	IMalloc	*pMalloc = NULL;
	sc = CoGetMalloc(MEMCTX_TASK, &pMalloc);
	if (FAILED(sc))
	{
	    return sc;
	}

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    GUID	Guid, GuidNew;
	    LPOLESTR	pwsz = NULL;
	    OLECHAR	awsz[50];

	    sw.Reset();
	    sc = CoCreateGuid(&Guid);
	    m_ulCoCreateGuid[iIter] = sw.Read();
	    if (FAILED(sc))
		m_ulCoCreateGuid[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = CoTreatAsClass(CLSID_Dummy, Guid);
	    m_ulCoTreatAsClass[iIter] = sw.Read();
	    Log (TEXT("CoTreatAsClass"), sc);
	    if (FAILED(sc))
		m_ulCoTreatAsClass[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = CoGetTreatAsClass(CLSID_Dummy, &GuidNew);
	    m_ulCoGetTreatAsClass[iIter] = sw.Read();
	    Log (TEXT("CoGetTreatAsClass"), sc);
	    if (FAILED(sc))
		m_ulCoGetTreatAsClass[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = GetClassFile(apszPerstName[1], &Guid);
	    m_ulGetClassFile[iIter] = sw.Read();
	    Log (TEXT("GetClassFile"), sc);
	    if (FAILED(sc))
		m_ulGetClassFile[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = StringFromCLSID(Guid, &pwsz);
	    m_ulStringFromCLSID[iIter] = sw.Read();
	    Log (TEXT("StringFromCLSID"), sc);
	    if (FAILED(sc))
		m_ulStringFromCLSID[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = CLSIDFromString(pwsz, &GuidNew);
	    m_ulCLSIDFromString[iIter] = sw.Read();
	    Log (TEXT("CLSIDFromString"), sc);
	    if (FAILED(sc))
		m_ulCLSIDFromString[iIter] = NOTAVAIL;

	    pMalloc->Free((void *)pwsz);


	    sw.Reset();
	    sc = StringFromIID(Guid, &pwsz);
	    m_ulStringFromIID[iIter] = sw.Read();
	    Log (TEXT("StringFromIID"), sc);
	    if (FAILED(sc))
		m_ulStringFromIID[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = IIDFromString(pwsz, &GuidNew);
	    m_ulIIDFromString[iIter] = sw.Read();
	    Log (TEXT("IIDFromString"), sc);
	    if (FAILED(sc))
		m_ulIIDFromString[iIter] = NOTAVAIL;

	    pMalloc->Free((void *)pwsz);

	    sw.Reset();
	    sc = StringFromGUID2(Guid, awsz, 50);
	    m_ulStringFromGUID2[iIter] = sw.Read();
	    Log (TEXT("StringFromGUID2"), sc);
	    if (FAILED(sc))
		m_ulStringFromGUID2[iIter] = NOTAVAIL;
	}


	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    GUID     Guid;
	    LPOLESTR pwsz = NULL;

	    sw.Reset();
	    sc = ProgIDFromCLSID(CLSID_Balls, &pwsz);
	    m_ulProgIDFromCLSID[iIter] = sw.Read();
	    Log (TEXT("ProgIDFromCLSID"), sc);
	    if (FAILED(sc))
		m_ulProgIDFromCLSID[iIter] = NOTAVAIL;

	    sw.Reset();
	    sc = CLSIDFromProgID(pwsz, &Guid);
	    m_ulCLSIDFromProgID[iIter] = sw.Read();
	    Log (TEXT("CLSIDFromProgID"), sc);
	    if (FAILED(sc))
		m_ulCLSIDFromProgID[iIter] = NOTAVAIL;

	    pMalloc->Free((void *)pwsz);
	}

	if (pMalloc)
	    pMalloc->Release();

	// INIT_RESULTS(m_ulCoIsOle1Class);

	return S_OK;
}					



SCODE CApiTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("Misc COM Apis"), *m_pInput);

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("CoBuildVersion     "), m_ulIterations, m_ulCoBuildVersion);
    output.WriteResults (TEXT("OleBuildVersion    "), m_ulIterations, m_ulOleBuildVersion);
    output.WriteResults (TEXT("CoGetCurrentProcess"), m_ulIterations, m_ulCoGetCurrentProcess);
    output.WriteResults (TEXT("CoGetMalloc        "), m_ulIterations, m_ulCoGetMalloc);
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("CoFileTimeNow          "), m_ulIterations, m_ulCoFileTimeNow);
    output.WriteResults (TEXT("CoFileTimeToDosDateTime"), m_ulIterations, m_ulCoFileTimeToDosDateTime);
    output.WriteResults (TEXT("CoDosDateTimeToFileTime"), m_ulIterations, m_ulCoDosDateTimeToFileTime);
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("CoCreateGuid       "), m_ulIterations, m_ulCoCreateGuid);
    output.WriteResults (TEXT("CoTreatAsClass     "), m_ulIterations, m_ulCoTreatAsClass);
    output.WriteResults (TEXT("CoGetTreatAsClass  "), m_ulIterations, m_ulCoGetTreatAsClass);
    output.WriteResults (TEXT("CoIsOle1Class      "), m_ulIterations, m_ulCoIsOle1Class);
    output.WriteResults (TEXT("GetClassFile       "), m_ulIterations, m_ulGetClassFile);
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("StringFromCLSID    "), m_ulIterations, m_ulStringFromCLSID);
    output.WriteResults (TEXT("CLSIDFromString    "), m_ulIterations, m_ulCLSIDFromString);
    output.WriteResults (TEXT("ProgIDFromCLSID    "), m_ulIterations, m_ulProgIDFromCLSID);
    output.WriteResults (TEXT("StringFromIID      "), m_ulIterations, m_ulStringFromIID);
    output.WriteResults (TEXT("IIDFromString      "), m_ulIterations, m_ulIIDFromString);
    output.WriteResults (TEXT("StringFromGUID2    "), m_ulIterations, m_ulStringFromGUID2);

    return S_OK;
}
	
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_mrsh2.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_marsh.cxx
//
//  Contents:	Mashalling test
//
//  Classes:	COleMarshalTest
//
//  History:    29-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_mrsh2.hxx>
#include <oletest.hxx>
#include <rpc.h>
#include <rpcdce.h>

// funciton prototype
DWORD _stdcall FnThread2(void *param);


ULARGE_INTEGER	ulSeekStart[REPS];	// stream starts
LARGE_INTEGER	libMove[REPS];


const IID *iid2[] = {&IID_IUnknown,	 &IID_IUnknown,
		 &IID_IAdviseSink,	 &IID_IAdviseSink,
		 &IID_IDataObject,	 &IID_IDataObject,
		 &IID_IOleObject,	 &IID_IOleObject,
		 &IID_IOleClientSite,	 &IID_IOleClientSite,
		 &IID_IParseDisplayName, &IID_IParseDisplayName,
		 &IID_IPersistStorage,	 &IID_IPersistStorage,
		 &IID_IPersistFile,	 &IID_IPersistFile,
		 &IID_IStorage, 	 &IID_IStorage,
		 &IID_IOleContainer,	 &IID_IOleContainer,
		 &IID_IOleItemContainer, &IID_IOleItemContainer,
		 &IID_IOleInPlaceSite,	 &IID_IOleInPlaceActiveObject,
		 &IID_IOleInPlaceObject, &IID_IOleInPlaceUIWindow,
		 &IID_IOleInPlaceFrame,	 &IID_IOleWindow};


TCHAR *COleMarshalTest2::Name ()
{
    return TEXT("Marshalling2");
}

SCODE COleMarshalTest2::Setup (CTestInput *pInput)
{
    SCODE sc;

    m_hThrd = NULL;
    m_dwTID1 = GetCurrentThreadId();

    for (ULONG i=0; i<REPS; i++)
	m_pStm[i] = NULL;

    CTestBase::Setup(pInput);

    // Get number of iterations
    m_ulIterations = pInput->GetIterations(Name());

    // set NULL in case of error
    for (i=0; i<m_ulIterations; i++)
	m_punk[i] = NULL;


    // Get custom ClsID from .ini file
    pInput->GetClassID(&m_ClsID, Name());

    // Get class activation context from .ini file
    m_dwClsCtx = pInput->GetClassCtx(Name());

    for (i=0; i<REPS; i++)
    {
	INIT_RESULTS (m_ulMarshalTime[i]);
	INIT_RESULTS (m_ulUnmarshalTime[i]);
	INIT_RESULTS (m_ulReleaseTime[i]);

	INIT_RESULTS (m_ulMarshalTime2[i]);
	INIT_RESULTS (m_ulUnmarshalTime2[i]);
	INIT_RESULTS (m_ulReleaseTime2[i]);
    }

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    for (i=0; i<m_ulIterations; i++)
    {
	//	create an instance of the object to marshal
	sc = CoCreateInstance(m_ClsID, NULL, m_dwClsCtx,
				  IID_IUnknown, (void **)&m_punk[i]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance failed"), sc);
	    return sc;
	}
    }


    for (i=0; i<REPS; i++)
    {
	//	create a stream to marshal the interface into
	SCODE sc = CreateStreamOnHGlobal(NULL, 0, &m_pStm[i]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CreateStreamOnHGlobal failed"), sc);
	}
	else
	{
	    // write some data to init the stream
	    DWORD	dwTemp;
	    m_pStm[i]->Write(&dwTemp, sizeof(DWORD), NULL);
	}
    }

    m_hThrd = CreateThread(NULL, 0, FnThread2, (void *)this, 0, &m_dwTID2);
    if (m_hThrd == NULL)
    {
	Log (TEXT("Setup - CreateThread failed"), sc);
    }

    Sleep(50);	// let the other thread initialize
    return S_OK;
}


SCODE COleMarshalTest2::Cleanup ()
{
    //	release objects
    for (ULONG i=0; i<m_ulIterations; i++)
    {
	if (m_punk[i])
	    m_punk[i]->Release();
    }

    for (i=0; i<REPS; i++)
    {
	if (m_pStm[i])
	    m_pStm[i]->Release();
    }

    UninitCOM();

    // close all the handles
    CloseHandle(m_hThrd);

    return S_OK;
}

DWORD _stdcall FnThread2(void *param)
{
    COleMarshalTest2 *pMrshlTst = (COleMarshalTest2 *)param;
    return pMrshlTst->Run2();
}

SCODE COleMarshalTest2::Run ()
{
    CStopWatch sw;
    LPVOID FAR pv[REPS];

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
	SCODE		sc[REPS];

	// settle down before running
	Sleep(100);

	// first, marshal the interface REPS times.
	for (ULONG i=0; i<REPS; i++)
	{
	    //	save current stream seek pointer
	    LISet32(libMove[i], 0x00000000);
	    m_pStm[i]->Seek(libMove[i], STREAM_SEEK_CUR, &ulSeekStart[i]);

	    //	marshal the interface into the stream
	    sw.Reset();
	    sc[i] = CoMarshalInterface(m_pStm[i], *iid2[i], m_punk[iIter],
				   0, 0, MSHLFLAGS_NORMAL);
	    m_ulMarshalTime[i][iIter] = sw.Read ();
	    Log (TEXT("CoMarshalInterface"), sc[i]);

	    if (FAILED(sc[i]))
	    {
		m_ulMarshalTime[i][iIter] = NOTAVAIL;
	    }
	}

	// reset the stream ptrs
	for (i=0; i<REPS; i++)
	{
	    // set stream ptr back to the starting position
	    LISet32(libMove[i], ulSeekStart[i].LowPart);
	    m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);
	}



	// kick the other thread alive
	PostThreadMessage(m_dwTID2, WM_QUIT, NULL, NULL);

	// enter modal loop to dispatch ORPC messages
	MSG msg;
	while (GetMessage(&msg, NULL, WM_NULL, WM_NULL))
	{
	    DispatchMessage(&msg);
	}



	// reset the stream ptrs
	for (i=0; i<REPS; i++)
	{
	    // set stream ptr back to the starting position
	    LISet32(libMove[i], ulSeekStart[i].LowPart);
	    m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);
	}

	Sleep(100);

	// unmarshal the interface ptrs
	for (i=0; i<REPS; i++)
	{
	    //	unmarshal the interface from the stream
	    sw.Reset ();
	    sc[i] = CoUnmarshalInterface(m_pStm[i], *iid2[i], &pv[i]);
	    m_ulUnmarshalTime2[i][iIter] = sw.Read ();
	    Log (TEXT("CoUnmarshalInterface"), sc[i]);
	}

	Sleep(100);

	// release all the interface ptrs we got
	for (i=0; i<REPS; i++)
	{
	    if (SUCCEEDED(sc[i]))
	    {
		sw.Reset ();
		((IUnknown *)pv[i])->Release ();
		m_ulReleaseTime2[i][iIter] = sw.Read ();
		Log (TEXT("Release"), sc[i]);
	    }
	    else
	    {
		m_ulReleaseTime2[i][iIter] = NOTAVAIL;
		m_ulUnmarshalTime2[i][iIter] = NOTAVAIL;
	    }
	}

	// reset the stream ptrs
	for (i=0; i<REPS; i++)
	{
	    // set stream ptr back to the starting position
	    LISet32(libMove[i], ulSeekStart[i].LowPart);
	    m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);
	}
    }

    return S_OK;
}


SCODE COleMarshalTest2::Run2 ()
{
    SCODE sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Thread2 - CoInitialize failed."), sc);
        return	sc;
    }

    CStopWatch sw;
    LPVOID FAR pv[REPS];

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
	SCODE		sc[REPS];

	// enter modal loop to dispatch ORPC messages
	MSG msg;
	while (GetMessage(&msg, NULL, WM_NULL, WM_NULL))
	{
	    DispatchMessage(&msg);
	}

	Sleep(100);

	// UnmarshalInterface the interfaces from the stream
	for (ULONG i=0; i<REPS; i++)
	{
	    //	unmarshal the interface from the stream
	    sw.Reset ();
	    sc[i] = CoUnmarshalInterface(m_pStm[i], *iid2[i], &pv[i]);
	    m_ulUnmarshalTime[i][iIter] = sw.Read ();
	    Log (TEXT("CoUnmarshalInterface"), sc[i]);
	}

	// now reset the stream ptrs
	for (i=0; i<REPS; i++)
	{
	    // set stream ptr back to the starting position
	    LISet32(libMove[i], ulSeekStart[i].LowPart);
	    m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);
	}

	Sleep(100);

	// remarshal the interface proxies
	for (i=0; i<REPS; i++)
	{
	    sw.Reset();
	    sc[i] = CoMarshalInterface(m_pStm[i], *iid2[i], (IUnknown *)pv[i],
					   0, 0, MSHLFLAGS_NORMAL);
	    m_ulMarshalTime2[i][iIter] = sw.Read ();
	    Log (TEXT("CoMarshalInterface"), sc[i]);

	    if (FAILED(sc[i]))
	    {
		m_ulMarshalTime2[i][iIter] = NOTAVAIL;
	    }
	}

	Sleep(100);

	// release all the interface ptrs we got
	for (i=0; i<REPS; i++)
	{
	    if (SUCCEEDED(sc[i]))
	    {
		sw.Reset ();
		((IUnknown *)pv[i])->Release ();
		m_ulReleaseTime[i][iIter] = sw.Read ();
		Log (TEXT("Release"), sc[i]);
	    }
	    else
	    {
		m_ulReleaseTime[i][iIter] = NOTAVAIL;
		m_ulUnmarshalTime[i][iIter] = NOTAVAIL;
	    }
	}

	// signal the other thread it is OK to go.
	PostThreadMessage(m_dwTID1, WM_QUIT, NULL, NULL);
    }

    UninitCOM();
    return S_OK;
}


SCODE COleMarshalTest2::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(),
			   TEXT("Interface Marshalling2"),
			   *m_pInput);

    for (ULONG iCtx=0; iCtx<1; iCtx++)
    {
	output.WriteString  (TEXT("\n"));
	output.WriteClassID (&m_ClsID);
	output.WriteString  (apszClsCtx[0]);
	output.WriteString  (TEXT("\n"));

	for (ULONG i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("CoMarshalInterface  "), m_ulIterations, m_ulMarshalTime[i]);
	}
	output.WriteString	(TEXT("\n"));


	for (i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("CoUnmarshalInterface"), m_ulIterations, m_ulUnmarshalTime[i]);
	}
	output.WriteString	(TEXT("\n"));


	for (i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("Release Interface   "), m_ulIterations, m_ulReleaseTime[i]);
	}
	output.WriteString	(TEXT("\n"));



	for (i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("CoMarshalInterface2  "), m_ulIterations, m_ulMarshalTime2[i]);
	}
	output.WriteString	(TEXT("\n"));


	for (i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("CoUnmarshalInterface2"), m_ulIterations, m_ulUnmarshalTime2[i]);
	}
	output.WriteString	(TEXT("\n"));


	for (i=0; i<REPS; i++)
	{
	    output.WriteResults(TEXT("Release Interface2   "), m_ulIterations, m_ulReleaseTime2[i]);
	}
	output.WriteString	(TEXT("\n"));

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_nest.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_nest.cxx
//
//  Contents:	Nested Object Rpc Method Invocation tests
//
//  Classes:	CNestTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_nest.hxx>
#include <oletest.hxx>
#include <tracelog.hxx>


TCHAR *CNestTest::Name ()
{
	return TEXT("Nested");
}


SCODE CNestTest::Setup (CTestInput *pInput)
{
	CTestBase::Setup(pInput);

	//  get iteration count
	m_ulIterations = pInput->GetIterations(Name());

	//  get CLSID of server
	SCODE sc = pInput->GetGUID(&m_ClsID, Name(), TEXT("Clsid_Local"));
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	//  initialize timing arrays
	INIT_RESULTS(m_ulNest2Time);
	INIT_RESULTS(m_ulNest3Time);
	INIT_RESULTS(m_ulNest4Time);
	INIT_RESULTS(m_ulNest5Time);


	sc = InitCOM();
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoInitialize failed."), sc);
	    return  sc;
	}

	m_pILoop1=NULL;
	sc = CoCreateInstance(m_ClsID, NULL, CLSCTX_LOCAL_SERVER,
			      IID_ILoop, (void **)&m_pILoop1);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance of first Server failed."), sc);
	    return sc;
	}

	m_pILoop2=NULL;
	sc = CoCreateInstance(m_ClsID, NULL, CLSCTX_LOCAL_SERVER,
			      IID_ILoop, (void **)&m_pILoop2);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance of second Server failed."), sc);
	    return sc;
	}

	//  pass the pointers to each other
	sc = m_pILoop1->Init(m_pILoop2);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - Initialization of first Server failed."), sc);
	    return sc;
	}

	sc = m_pILoop2->Init(m_pILoop1);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - Initialization of second Server failed."), sc);
	    return sc;
	}


	return S_OK;
}


SCODE CNestTest::Cleanup ()
{
	if (m_pILoop1)
	{
	    m_pILoop1->Uninit();
	    m_pILoop1->Release();
	}

	if (m_pILoop2)
	{
	    m_pILoop2->Uninit();
	    m_pILoop2->Release();
	}

	UninitCOM();
	return S_OK;
}


SCODE CNestTest::Run ()
{
	CStopWatch  sw;
	SCODE sc;

	//
	//  nesting 2 levels. Note we pass in 3 not 2, since the server
	//  subtracts 1 from the passed in value and then stops the nesting
	//  if the count is zero.
	//
	//  a value of 3 represents a single nested call.
	//

	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    sc = m_pILoop1->Loop(3);
	    m_ulNest2Time[iIter] = sw.Read();
	    Log (TEXT("Loop (2)"), sc);
	}

	//
	//  nesting 3 levels
	//

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    sc= m_pILoop1->Loop(4);
	    m_ulNest3Time[iIter] = sw.Read();
	    Log (TEXT("Loop (3)"), sc);
	}

	//
	//  nesting 4 levels
	//

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    sc = m_pILoop1->Loop(5);
	    m_ulNest4Time[iIter] = sw.Read();
	    Log (TEXT("Loop (4)"), sc);
	}

	//
	//  nesting 5 levels
	//

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    sc = m_pILoop1->Loop(6);
	    m_ulNest5Time[iIter] = sw.Read();
	    Log (TEXT("Loop (5)"), sc);
	}

	return S_OK;
}					  



SCODE CNestTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("Nested ORpc Calls"), *m_pInput);

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("Nesting 2    "), m_ulIterations, m_ulNest2Time);
    output.WriteResults (TEXT("Nesting 3    "), m_ulIterations, m_ulNest3Time);
    output.WriteResults (TEXT("Nesting 4    "), m_ulIterations, m_ulNest4Time);
    output.WriteResults (TEXT("Nesting 5    "), m_ulIterations, m_ulNest5Time);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_marsh.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_marsh.cxx
//
//  Contents:	Mashalling test
//
//  Classes:	COleMarshalTest
//
//  History:    29-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_marsh.hxx>
#include <oletest.hxx>

#include <rpc.h>
#include <rpcdce.h>
// extern "C" RPC_STATUS UuidCreate(GUID *pguid);


TCHAR *COleMarshalTest::Name ()
{
    return TEXT("Marshalling");
}


SCODE COleMarshalTest::Setup (CTestInput *pInput)
{
    SCODE sc;

    for (ULONG i=0; i<REPS; i++)
	m_pStm[i] = NULL;

    CTestBase::Setup(pInput);

    // Get number of iterations
    m_ulIterations = pInput->GetIterations(Name());

    // set NULL in case of error
    for (i=0; i<m_ulIterations; i++)
	m_punk[i] = NULL;


    // Get custom ClsID from .ini file
    pInput->GetClassID(&m_ClsID, Name());

    // Get class activation context from .ini file
    m_dwClsCtx = pInput->GetClassCtx(Name());

    INIT_RESULTS (m_ulUuidCreateTime);

    for (i=0; i<REPS; i++)
    {
	INIT_RESULTS (m_ulMarshalTime[i]);
	INIT_RESULTS (m_ulUnmarshalTime[i]);
	INIT_RESULTS (m_ulLockObjectTime[i]);
	INIT_RESULTS (m_ulGetStdMarshalTime[i]);
	INIT_RESULTS (m_ulGetMarshalSizeTime[i]);
	INIT_RESULTS (m_ulDisconnectTime[i]);
    }

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    for (i=0; i<m_ulIterations; i++)
    {
	//	create an instance of the object to marshal
	sc = CoCreateInstance(m_ClsID, NULL, m_dwClsCtx,
			  IID_IUnknown, (void **)&m_punk[i]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance failed"), sc);
	    return sc;
	}
    }


    for (i=0; i<REPS; i++)
    {
	// create a stream to marshal the interface into
	SCODE sc = CreateStreamOnHGlobal(NULL, 0, &m_pStm[i]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CreateStreamOnHGlobal failed"), sc);
	}
	else
	{
	    //	write some data to init the stream
	    DWORD dwTemp;
	    m_pStm[i]->Write(&dwTemp, sizeof(DWORD), NULL);
	}
    }

    return S_OK;
}


SCODE COleMarshalTest::Cleanup ()
{
    //	release objects
    for (ULONG i=0; i<m_ulIterations; i++)
    {
	if (m_punk[i])
	    m_punk[i]->Release();
    }

    for (i=0; i<REPS; i++)
    {
	if (m_pStm[i])
	    m_pStm[i]->Release();
    }

    UninitCOM();
    return S_OK;
}


SCODE COleMarshalTest::Run ()
{
	CStopWatch sw;
	LPVOID FAR pv;

	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    SCODE		sc[REPS];
	    ULARGE_INTEGER	ulSeekStart[REPS];
	    LARGE_INTEGER	libMove[REPS];

	    //	create Uuid's
	    GUID    guid;
	    sw.Reset();
	    sc[0] = UuidCreate(&guid);
	    m_ulUuidCreateTime[iIter] = sw.Read();
	    Log (TEXT("UuidCreate"), sc[0]);


	    //	first, marshal the interface REPS times.
	    for (ULONG i=0; i<REPS; i++)
	    {
		//  save current stream seek pointer
		LISet32(libMove[i], 0x00000000);
		m_pStm[i]->Seek(libMove[i], STREAM_SEEK_CUR, &ulSeekStart[i]);

		//  marshal the interface into the stream
		sw.Reset();
		sc[i] = CoMarshalInterface(m_pStm[i], IID_IUnknown, m_punk[iIter],
					   0, 0, MSHLFLAGS_NORMAL);
		m_ulMarshalTime[i][iIter] = sw.Read ();
		Log (TEXT("CoMarshalInterface"), sc[i]);

		if (FAILED(sc[i]))
		{
		    m_ulMarshalTime[i][iIter] = NOTAVAIL;
		}
	    }


	    //	now ReleaseMarshalData once
	    i = 0;
	    {
		// set stream ptr back to the starting position
		LISet32(libMove[i], ulSeekStart[i].LowPart);
		m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);

		// unmarshal the interface from the stream
		sw.Reset ();
		sc[i] = CoReleaseMarshalData(m_pStm[i]);
		m_ulUnmarshalTime[i][iIter] = sw.Read ();
		Log (TEXT("CoReleaseMarshalData"), sc[i]);
	    }


	    //	now UnmarshalInterface the remaining times
	    for (i=1; i<REPS; i++)
	    {
		if (FAILED(sc[i]))
		    continue;

		//  set stream ptr back to the starting position
		LISet32(libMove[i], ulSeekStart[i].LowPart);
		m_pStm[i]->Seek(libMove[i], STREAM_SEEK_SET, &ulSeekStart[i]);

		//  unmarshal the interface from the stream
		sw.Reset ();
		sc[i] = CoUnmarshalInterface(m_pStm[i], IID_IUnknown, &pv);
		m_ulUnmarshalTime[i][iIter] = sw.Read ();
		Log (TEXT("CoUnmarshalInterface"), sc[i]);

		if (SUCCEEDED(sc[i]))
		{
		    ((IUnknown *)pv)->Release ();  // Unmarshal called AddRef
		}
		else
		{
		    m_ulUnmarshalTime[i][iIter] = NOTAVAIL;
		}
	    }


	    //	call CoLockObjectExternal
	    sw.Reset();
	    sc[0] = CoLockObjectExternal(m_punk[iIter], TRUE, FALSE);
	    m_ulLockObjectTime[0][iIter] = sw.Read();
	    Log (TEXT("CoLockObjectExternal"), sc[0]);

	    sw.Reset();
	    sc[1] = CoLockObjectExternal(m_punk[iIter], FALSE, FALSE);
	    m_ulLockObjectTime[1][iIter] = sw.Read();
	    Log (TEXT("CoLockObjectExternal"), sc[1]);


	    //	call CoGetStdMarshal
	    IMarshal *pIM = NULL;
	    sw.Reset();
	    sc[0] = CoGetStandardMarshal(IID_IUnknown, m_punk[iIter], 0, NULL,
					 MSHLFLAGS_NORMAL, &pIM);
	    m_ulGetStdMarshalTime[0][iIter] = sw.Read();
	    Log (TEXT("CoGetStandardMarshal"), sc[0]);

	    sw.Reset();
	    pIM->Release();
	    m_ulGetStdMarshalTime[1][iIter] = sw.Read();
	    Log (TEXT("Release StdMarshal"), sc[1]);


	    //	call CoGetMarshalSizeMax
	    ULONG ulSize = 0;
	    sw.Reset();
	    sc[0] = CoGetMarshalSizeMax(&ulSize, IID_IUnknown, m_punk[iIter],
					 0, NULL,MSHLFLAGS_NORMAL);
	    m_ulGetMarshalSizeTime[0][iIter] = sw.Read();
	    Log (TEXT("CoGetMarshalSizeMax"), sc[0]);


	    //	call CoDisconnectObject
	    sc[0] = CoLockObjectExternal(m_punk[iIter], TRUE, FALSE);

	    sw.Reset();
	    sc[0] = CoDisconnectObject(m_punk[iIter], 0);
	    m_ulDisconnectTime[0][iIter] = sw.Read();
	    Log (TEXT("CoDisconnectObject"), sc[0]);
	    sc[0] = CoLockObjectExternal(m_punk[iIter], FALSE, FALSE);
	}

	return S_OK;
}


SCODE COleMarshalTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(),
				   TEXT("Interface Marshalling"),
				   *m_pInput);

	for (ULONG iCtx=0; iCtx<1; iCtx++)
	{
	    output.WriteString	(TEXT("\n"));
	    output.WriteClassID (&m_ClsID);
	    output.WriteString	(apszClsCtx[0]);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("UuidCreate            "), m_ulIterations, m_ulUuidCreateTime);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("CoMarshalInterface   1"), m_ulIterations, m_ulMarshalTime[0]);
	    output.WriteResults (TEXT("CoMarshalInterface   2"), m_ulIterations, m_ulMarshalTime[1]);
	    output.WriteResults (TEXT("CoMarshalInterface   3"), m_ulIterations, m_ulMarshalTime[2]);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("CoReleaseMarshalData 3"), m_ulIterations, m_ulUnmarshalTime[0]);
	    output.WriteResults (TEXT("CoUnmarshalInterface 2"), m_ulIterations, m_ulUnmarshalTime[1]);
	    output.WriteResults (TEXT("CoUnmarshalInterface 1"), m_ulIterations, m_ulUnmarshalTime[2]);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("CoLockObjectExternal L"), m_ulIterations, m_ulLockObjectTime[0]);
	    output.WriteResults (TEXT("CoLockObjectExternal U"), m_ulIterations, m_ulLockObjectTime[1]);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("CoGetStandardMarshal  "), m_ulIterations, m_ulGetStdMarshalTime[0]);
	    output.WriteResults (TEXT("pIMarshal->Release    "), m_ulIterations, m_ulGetStdMarshalTime[1]);
	    output.WriteString	(TEXT("\n"));

	    output.WriteResults (TEXT("CoDisconnectObject    "), m_ulIterations, m_ulDisconnectTime[0]);
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_iid.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_iid.cxx
//
//  Contents:	compare inline vs function call for guid compares
//
//  Classes:	CGuidCompareTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_iid.hxx>
#include <oletest.hxx>


TCHAR *CGuidCompareTest::Name ()
{
    return TEXT("GuidCompare");
}


SCODE CGuidCompareTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize state
    INIT_RESULTS(m_ulRepFunctionNEQTime);
    INIT_RESULTS(m_ulRepFunctionEQTime);
    INIT_RESULTS(m_ulRepInlineNEQTime);
    INIT_RESULTS(m_ulRepInlineEQTime);

    return S_OK;
}


SCODE CGuidCompareTest::Cleanup ()
{	
    return S_OK;
}


SCODE CGuidCompareTest::Run ()
{
	CStopWatch  sw;
	BOOL	    fRslt;

	//  compute times for the function version
	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    for (ULONG j=0; j<1000; j++)
		fRslt = IsEqualIID(IID_IUnknown, IID_IClassFactory);
	    m_ulRepFunctionNEQTime[iIter] = sw.Read();
	}
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    for (ULONG j=0; j<1000; j++)
		fRslt = IsEqualIID(IID_IUnknown, IID_IUnknown);
	    m_ulRepFunctionEQTime[iIter] = sw.Read();
	}

	//  compute the time for the inline
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    for (ULONG j=0; j<1000; j++)
		fRslt = !memcmp((void *)&IID_IUnknown,
				(void *)&IID_IClassFactory, sizeof(GUID));
	    m_ulRepInlineNEQTime[iIter] = sw.Read();
	}
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    for (ULONG j=0; j<1000; j++)
		fRslt = !memcmp((void *)&IID_IUnknown,
				(void *)&IID_IUnknown, sizeof(GUID));
	    m_ulRepInlineEQTime[iIter] = sw.Read();
	}

	return S_OK;
}					  



SCODE CGuidCompareTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("GUID Compare"), *m_pInput);

    output.WriteResults (TEXT("\nIsEqualGUID Not Equal x 1000 "),
		m_ulIterations, m_ulRepFunctionNEQTime);
    output.WriteResults (TEXT("\nIsEqualGUID Equal x 1000 "),
                m_ulIterations, m_ulRepFunctionEQTime);

    output.WriteResults (TEXT("memcmp Not Equal x 1000        "),
		m_ulIterations, m_ulRepInlineNEQTime);
    output.WriteResults (TEXT("memcmp Equal x 1000        "),
                m_ulIterations, m_ulRepInlineEQTime);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_obind.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_obind.cxx
//
//  Contents:	Ole moniker binding test (BindToObject)
//
//  Classes:	CFileMonikerObjBindTest
//
//  History:    9-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_obind.hxx>


TCHAR *CFileMonikerObjBindTest::Name ()
{
    return TEXT("BindToObject");
}


SCODE CFileMonikerObjBindTest::Setup (CTestInput *pInput)
{
    IClassFactory	*pICF = NULL;
    IPersistFile	*pIPF = NULL;
    SCODE		 sc = S_OK, scRet = S_OK;


    CTestBase::Setup(pInput);

    // get the iteration count from the ini file
    m_ulIterations = pInput->GetIterations(Name());

    //	for each class ctx, get the classid, and init internal state
    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	// Get ClsID for this Ctx from the .ini file
	sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apszClsIDName[iCtx]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	INIT_RESULTS(m_ulCreateMkrTime[iCtx]);
	INIT_RESULTS(m_ulCreateBndCtxTime[iCtx]);
	INIT_RESULTS(m_ulBindTime[iCtx]);
    }


    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }


    //	for each class ctx, create a persistent instance on disk
    for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	// Create an instance
	sc = CoGetClassObject(m_ClsID[iCtx], dwaClsCtx[iCtx], NULL,
				  IID_IClassFactory, (void **)&pICF);
	if (SUCCEEDED(sc))
	{
	    sc = pICF->CreateInstance(NULL, IID_IPersistFile,
					  (void **)&pIPF);
	    pICF->Release();
	    if (SUCCEEDED(sc))
	    {
		// save the class instance in the storage
		sc = pIPF->Save(apszPerstName[iCtx], FALSE);
		pIPF->Release();

		if (FAILED(sc))
		{
		    Log (TEXT("Setup - pIPF->Save failed."), sc);
		    scRet = sc;
		}
	    }
	    else
	    {
		Log (TEXT("Setup - CreateInstance failed"), sc);
		scRet = sc;
	    }
	}
	else
	{
	    Log (TEXT("Setup - CoGetClassObject failed"), sc);
	    scRet = sc;
	}
    }

    return scRet;
}


SCODE CFileMonikerObjBindTest::Cleanup ()
{	
	UninitCOM();

	CHAR	szPerstName[80];

	//  delete the persistent instances
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	delete original
	    wcstombs(szPerstName, apszPerstName[iCtx],
		     wcslen(apszPerstName[iCtx])+1);
	    _unlink (szPerstName);
	}

	return S_OK;
}


SCODE CFileMonikerObjBindTest::Run ()
{
	CStopWatch   sw;
	IMoniker     *pmk = NULL;
	IBindCtx     *pbc = NULL;
	IPersistFile *pIPF = NULL;
	SCODE	     sc;

	//  for each class context
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	for each iteration
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset();
		sc = CreateFileMoniker (apszPerstName[iCtx], &pmk);
		m_ulCreateMkrTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("CreateFileMoniker"), sc))
		{
		    m_ulCreateMkrTime[iCtx][iIter] = NOTAVAIL;
		}

		sw.Reset();
		sc = CreateBindCtx(0, &pbc);
		m_ulCreateBndCtxTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("CreateBindCtx"), sc))
		{
		    m_ulCreateBndCtxTime[iCtx][iIter] = NOTAVAIL;
		}

		sw.Reset();
		sc = pmk->BindToObject(pbc, NULL, IID_IPersistFile, (void**)&pIPF);
		m_ulBindTime[iCtx][iIter]=sw.Read ();

		pmk->Release();
		pbc->Release();

		if (Log (TEXT("BindToObject"), sc))
		{
		    m_ulBindTime[iCtx][iIter] = NOTAVAIL;
		}
		else
		{
		    sw.Reset();
		    pIPF->Release();
		    m_ulReleaseTime[iCtx][iIter]=sw.Read ();
		}
	    }
	}

	return S_OK;
}		



SCODE CFileMonikerObjBindTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(), TEXT("BindToObject via FileMoniker"), *m_pInput);

	//  for each clsctx, write the results
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    output.WriteString(TEXT("\n"));
	    output.WriteClassID(&m_ClsID[iCtx]);
	    output.WriteString(apszClsCtx[iCtx]);
	    output.WriteString(TEXT("\n"));

	    output.WriteResults(TEXT("CreateMoniker"), m_ulIterations, m_ulCreateMkrTime[iCtx]);
	    output.WriteResults(TEXT("CreateBindCtx"), m_ulIterations, m_ulCreateBndCtxTime[iCtx]);
	    output.WriteResults(TEXT("Bind         "), m_ulIterations, m_ulBindTime[iCtx]);
	    output.WriteResults(TEXT("Release      "), m_ulIterations, m_ulReleaseTime[iCtx]);
	}

	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_noise.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	    bm_noise.cxx
//
//  Contents:	output class for benchmark results
//
//  Classes:	CNoiseTest
//
//  History:    30-June-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_noise.hxx>



TCHAR *CNoiseTest::Name ()
{
    return TEXT("Noise Test");
}


SCODE CNoiseTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name(), TEST_MAX_ITERATIONS);
    INIT_RESULTS(m_ulNoiseTime);
    return S_OK;
}


SCODE CNoiseTest::Run ()
{
	CStopWatch sw;
	int n;
	FILE *pfDump;
	char buffer[100];
	int i;

	m_ulResolution = sw.Resolution();

	sw.Reset();
	Sleep (1000);
	m_ulSleep = sw.Read();

	sw.Reset();
	for (n=0; n<10000; n++);
	m_ulIdle = sw.Read();

	for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	{
        sw.Reset();
        m_ulNoiseTime[iIter] = sw.Read();
	}

	pfDump = fopen ("C:\\DUMP.BM", "wb");
	if (pfDump)
	{
		sw.Reset();
		for (i=0; i<1000; i++)
			fwrite (&buffer, 1, 100, pfDump);
		m_ulDumpWrite = sw.Read();
		fclose (pfDump);

		pfDump = fopen ("C:\\DUMP.BM", "rb");
		if (pfDump)
		{
			sw.Reset();
			for (i=0; i<1000; i++)
				fread (&buffer, 1, 100, pfDump);
			m_ulDumpRead = sw.Read();
			fclose (pfDump);
		}
		else
			m_ulDumpRead = 0xffffffff;
		
		_unlink ("C:\\DUMP.BM");
	}
	else
		m_ulDumpWrite = 0xffffffff;

	return S_OK;
}					



SCODE CNoiseTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), NULL, *m_pInput);

    output.WriteResult (TEXT("Resolution"), m_ulResolution);
    output.WriteResult (TEXT("Sleep 1000ms"), m_ulSleep);
    output.WriteResult (TEXT("Idle 10000 loops"), m_ulIdle);
    output.WriteResults (TEXT("Noise"), m_ulIterations, m_ulNoiseTime);
    output.WriteResult (TEXT("Write 100k to disk"), m_ulDumpWrite);
    output.WriteResult (TEXT("Read 100k from disk"), m_ulDumpRead);

    return S_OK;
}
	
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_props.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_props.cxx
//
//  Contents:	Ole properties test
//
//  Classes:	COlePropertyTest
//
//  History:    22-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_props.hxx>
#include <oletest.hxx>


DEFINE_OLEGUID(CLSID_TestProp,  0x20730722, 1, 8);	    // CT Test GUID


TCHAR *COlePropertyTest::Name ()
{
    return TEXT("Properties");
}


SCODE COlePropertyTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    SCODE sc = InitOLE();
    if (FAILED(sc))
    {
        Log (TEXT("Setup - OleInitialize failed."), sc);
        return	sc;
    }
	
    m_ulIterations = 0;
    return S_OK;
}


SCODE COlePropertyTest::Cleanup ()
{	
    UninitOLE();
    return S_OK;
}



SCODE COlePropertyTest::Run ()
{
/****	BUGBUG: these tests currently do nothing

	CStopWatch sw;
	IStorage *pIS;
	IDispatch *pID;
	COleTestClass unk;
	VARIANTARG avararg[2];
	DISPPARAMS dispparams = {avararg, NULL, 2, 0};
	VARIANT	varResult;
	EXCEPINFO excepinfo;
	UINT ierr;

	// Create storage

	if (FAILED(StgCreateDocfile (TEXT("C:\\DUMP.BM"), STGM_CREATE |
		STGM_DELETEONRELEASE, 0, &pIS)))
		return E_FAIL;

	sw.Reset ();

	if (FAILED(CoCreatePropSetStg (pIS, CLSID_TestProp, &unk, STGM_READWRITE |
		STGM_SHARE_EXCLUSIVE, NULL, (IUnknown**)&pID)))
	{
		pIS->Release ();
		return E_FAIL;
	}
	ulCreate = sw.Read ();

	pID->QueryInterface (IID_IDispatch, (void**)&pID);

	VariantInit(avararg + 1);
	avararg[1].vt = VT_LPWSTR;
	avararg[1].pwszVal = L"CairOLE";

	VariantInit(avararg + 0);
	avararg[0].vt = VT_LPWSTR;
	avararg[0].pwszVal = L"TooSlow";

	sw.Reset ();
	if (FAILED(pID->Invoke(DISPID_ADDPROP, CLSID_TestProp, 0,
	    DISPATCH_METHOD, &dispparams, &varResult, &excepinfo, &ierr)))
	{
		pIS->Release ();
		return E_FAIL;
	}

	ulAdd = sw.Read ();
	pIS->Release ();
****/
	return S_OK;
}



SCODE COlePropertyTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(), TEXT("Properties"), *m_pInput);
/****	BUGBUG: disable
	output.WriteResult (TEXT("Create property set"), ulCreate);
	output.WriteResult (TEXT("Add property"), ulAdd);
	output.WriteResult (TEXT("Set property"), ulSet);
	output.WriteResult (TEXT("Get property"), ulGet);
	output.WriteResult (TEXT("Delete property"), ulDelete);
****/
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_nstg.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_nstg.cxx
//
//  Contents:	Nested Storage test
//
//  Classes:	CNestedStorageTest
//
//  History:    09-June-94 t-vadims    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_nstg.hxx>

#define  DEF_DATASIZE    4096
#define  INFINITY	 0xffffffff	// max value of 32-bit ulong
			        
TCHAR *CNestedStorageTest::Name ()
{
    return TEXT("NestedStorageTest");
}


SCODE CNestedStorageTest::Setup (CTestInput *pInput)
{
    SCODE sc;
    ULONG iIndex;
    TCHAR pszBuf[15];
    
    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize timing arrays   
    INIT_RESULTS(m_ulStgCreateDocfile);
    INIT_RESULTS(m_ulFinalStorageCommit);
    INIT_RESULTS(m_ulFinalStorageRelease);

    for(iIndex = 0; iIndex <TEST_MAX_ITERATIONS; iIndex++)
    {
	m_ulCreateStorageTotal[iIndex] = 0;
	m_ulCreateStreamTotal[iIndex] = 0;
	m_ulStreamWriteTotal[iIndex] = 0;
	m_ulStreamReleaseTotal[iIndex] = 0;
	m_ulDestroyElementTotal[iIndex] = 0;
	m_ulStorageCommitTotal[iIndex] = 0;
	m_ulStorageReleaseTotal[iIndex] = 0;
	m_ulTotal[iIndex] = 0;

	m_ulCreateStreamMin[iIndex] = INFINITY;
	m_ulStreamWriteMin[iIndex] = INFINITY;
	m_ulStreamReleaseMin[iIndex] = INFINITY;
	m_ulDestroyElementMin[iIndex] = INFINITY;

	m_ulCreateStreamMax[iIndex] = 0;
	m_ulStreamWriteMax[iIndex] = 0;
	m_ulStreamReleaseMax[iIndex] = 0;
	m_ulDestroyElementMax[iIndex] = 0;

	for (ULONG iLevel =0; iLevel < MAX_NESTING; iLevel++)
	{
	    m_ulStorageCommitMin[iLevel][iIndex] = INFINITY;
	    m_ulStorageReleaseMin[iLevel][iIndex] = INFINITY;
	    m_ulCreateStorageMin[iLevel][iIndex] = INFINITY;

	    m_ulCreateStorageMax[iLevel][iIndex] = 0;
	    m_ulStorageCommitMax[iLevel][iIndex] = 0;
	    m_ulStorageReleaseMax[iLevel][iIndex] = 0;
    	}
    }



    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    // get malloc interface for this task
    m_piMalloc = NULL;
    sc = CoGetMalloc(MEMCTX_TASK, &m_piMalloc);
    if (FAILED(sc))
    {
    	Log (TEXT("Setup - CoGetMalloc"), sc);
    	return sc;
    }

    m_cbSize = pInput->GetConfigInt(Name(), TEXT("DataSize"), DEF_DATASIZE);
 
    // initialize array to be written to the file.  
    m_pbData = (BYTE *)m_piMalloc->Alloc(m_cbSize);
    if(m_pbData == NULL)
    {
    	Log (TEXT("Setup - Cannot allocate memory"), E_OUTOFMEMORY);
	return E_OUTOFMEMORY;
    }

    for (iIndex=0; iIndex < m_cbSize; iIndex++)
        m_pbData[iIndex] = (BYTE)iIndex;


    // get file name to be used and values of other parameters
    pInput->GetConfigString(Name(), TEXT("FileName"), TEXT("stgtest.bm"),
    			    m_pszFile, MAX_PATH);
#ifdef UNICODE
    wcscpy(m_pwszFile, m_pszFile);
#else
    mbstowcs(m_pwszFile, m_pszFile, strlen(m_pszFile)+1);
#endif

    pInput->GetConfigString(Name(), TEXT("FileMode"), TEXT("DIRECT"), m_pszFileMode, 15);

    if(lstrcmpi(m_pszFileMode, TEXT("DIRECT")) == 0)
       	m_flCreateFlags = STGM_DIRECT;
    else 
       	m_flCreateFlags = STGM_TRANSACTED; 	

    // get the nesting factor
    m_cNesting = pInput->GetConfigInt(Name(), TEXT("Nesting"), 3);

    if(m_cNesting > MAX_NESTING)
    	m_cNesting = MAX_NESTING;
    
    if(m_cNesting == 0)
    	m_cNesting = 1;
    	 
    // get the branching factor
    m_cBranching = pInput->GetConfigInt(Name(), TEXT("Branching"), 3);

    if(m_cBranching > MAX_BRANCHING)
    	m_cBranching = MAX_BRANCHING;
    
    if(m_cBranching == 0)
    	m_cBranching = 1;

    // get the value of Delete element option
    pInput->GetConfigString(Name(), TEXT("Delete"), TEXT("OFF"), pszBuf, 15);
    
    if( lstrcmpi(pszBuf, TEXT("OFF")) == 0 ||
        lstrcmpi(pszBuf, TEXT("FALSE")) == 0)
    	m_bDelete = FALSE;
    else
    	m_bDelete = TRUE; 

    // now compute number of streams and storages, depeding on 
    // the nesting and branching factors.  Formulas are as follows:
    // Nesting = n;
    // Branching = b;
    //    	       n
    // Streams    =   b
    //
    //		       n
    //		      b	  - 1 
    // Storages   =  ---------
    //		      b   - 1
    //
    //		        n-1
    //		       b   - 1
    // ParentFactor = ---------
    //                 b   - 1
    //
    // Parent factor is used to determine the parent storage of the stream
    //
    m_cStreams = 1;
    ULONG n = m_cNesting;
    while(n-- > 0)                   // compute b^n
        m_cStreams *= m_cBranching;

    m_cStorages = (m_cStreams - 1) / (m_cBranching - 1);

    m_cParentFactor = (m_cStreams / m_cBranching - 1) / 
    		      (m_cBranching - 1);


    // allocate arrays for storages
    m_piStorages = (LPSTORAGE *)m_piMalloc->Alloc(m_cStorages * 
    						sizeof(LPSTORAGE));
    if (m_piStorages == NULL)
    {
    	Log(TEXT("Cannot allocate memory"), E_OUTOFMEMORY);
	return E_OUTOFMEMORY;
    }

    return S_OK;
}


SCODE CNestedStorageTest::Cleanup ()
{
    //	delete the file
    DeleteFile (m_pszFile);

    // free all memory
    if(m_piMalloc)
    {
    	if (m_pbData)
    	    m_piMalloc->Free(m_pbData);

	if (m_piStorages)
    	    m_piMalloc->Free(m_piStorages);

	m_piMalloc->Release();
	m_piMalloc = NULL;
    }

    UninitCOM();

    return S_OK;
}


// Some macros that are used only in Run() function.

#define  STG_PARENT(iIndex)    ((iIndex - 1) / m_cBranching )
#define  STREAM_PARENT(iIndex) (iIndex / m_cBranching + m_cParentFactor )

// STG_NAME and STREAM_NAME macros are very ugly, but they save
// doing a bunch of allocations and name generation in the beginning.

#define  STG_NAME(iIndex)      (swprintf(pwszBuf, L"Storage%d", iIndex), pwszBuf)
#define  STREAM_NAME(iIndex)   (swprintf(pwszBuf, L"Stream%d", iIndex), pwszBuf)


SCODE CNestedStorageTest::Run ()
{
    CStopWatch   sw;
    HRESULT	 hr;
    ULONG	 cb;
    ULONG        iCurStream;
    LONG	 iCurStg;    // has to be long, not ulong, for looping down to zero.
    LPSTREAM	 piStream;
    ULONG	 iIter;
    OLECHAR	 pwszBuf[20];
    ULONG	 ulTime;
    ULONG	 iLevel;
    ULONG	 iParent;
 

    for (iIter =0; iIter < m_ulIterations; iIter++)
    {

        sw.Reset();
    	hr = StgCreateDocfile(m_pwszFile,  m_flCreateFlags  | STGM_WRITE
           	| STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &m_piStorages[0]);
	m_ulStgCreateDocfile[iIter] = sw.Read();
  	Log(TEXT("StgCreateDocfile"), hr);
	if (FAILED(hr))
	    return hr;

	// Create a complete tree of storages 
    	for (iCurStg = 1; iCurStg < (LONG)m_cStorages; iCurStg++)
    	{
	    // determine level of curent storage.
	    iLevel = 0;
	    iParent = STG_PARENT(iCurStg);
	    while(iParent > 0)
	    {
	    	iParent = STG_PARENT(iParent);
		iLevel++;
	    }

	    sw.Reset();
 	    hr = m_piStorages[STG_PARENT(iCurStg)]->
 		      CreateStorage(STG_NAME(iCurStg), 
 			      m_flCreateFlags | STGM_WRITE | 
 			      STGM_CREATE | STGM_SHARE_EXCLUSIVE,
 			      0, 0, &m_piStorages[iCurStg]);
	    ulTime = sw.Read();
	    m_ulCreateStorageTotal[iIter] += ulTime;

	    if(ulTime < m_ulCreateStorageMin[iLevel][iIter])
	    	m_ulCreateStorageMin[iLevel][iIter] = ulTime;

	    if(ulTime > m_ulCreateStorageMax[iLevel][iIter])
	    	m_ulCreateStorageMax[iLevel][iIter] = ulTime;

	    if (FAILED(hr))
	    {
	        Log(TEXT("CreateStorage"), hr);
	    	return hr;
	    }
    	}
        Log(TEXT("CreateStorage"), S_OK);
  	// For each storage in final level, open several streams,
	// write some data to them, and release them
	for (iCurStream = 0; iCurStream < m_cStreams; iCurStream++)
    	{
	    sw.Reset();
 	    hr = m_piStorages[STREAM_PARENT(iCurStream)]->
 	               CreateStream(STREAM_NAME(iCurStream), 
 	         	     STGM_DIRECT | STGM_WRITE | 
 	         	     STGM_CREATE | STGM_SHARE_EXCLUSIVE,
 			     0, 0, &piStream);
	    ulTime = sw.Read();
	    m_ulCreateStreamTotal[iIter] += ulTime;

	    if(ulTime < m_ulCreateStreamMin[iIter])
	    	m_ulCreateStreamMin[iIter] = ulTime;

	    if(ulTime > m_ulCreateStreamMax[iIter])
	    	m_ulCreateStreamMax[iIter] = ulTime;

	    if (FAILED(hr))
	    {
	    	Log(TEXT("CreateStream"), hr);
	    	return hr;
	    }

	    sw.Reset();
	    piStream->Write((LPVOID)m_pbData, m_cbSize, &cb);
	    ulTime = sw.Read();
	    m_ulStreamWriteTotal[iIter] += ulTime;

	    if(ulTime < m_ulStreamWriteMin[iIter])
	    	m_ulStreamWriteMin[iIter] = ulTime;

	    if(ulTime > m_ulStreamWriteMax[iIter])
	    	m_ulStreamWriteMax[iIter] = ulTime;

	    sw.Reset();
	    piStream->Release();
	    ulTime = sw.Read();
	    m_ulStreamReleaseTotal[iIter] += ulTime;

	    if(ulTime < m_ulStreamReleaseMin[iIter])
	    	m_ulStreamReleaseMin[iIter] = ulTime;

	    if(ulTime > m_ulStreamReleaseMax[iIter])
	    	m_ulStreamReleaseMax[iIter] = ulTime;
  	}
	Log(TEXT("CreateStream"), S_OK);
	Log(TEXT("StreamWrite"), S_OK);	    
	Log(TEXT("StreamRelease"), S_OK);	    

        if (m_bDelete)
	{
	    // delete 1 stream from every branch.
	    for (iCurStream = 1; iCurStream < m_cStreams; iCurStream += m_cBranching)
    	    {
	    	sw.Reset();
 	    	hr = m_piStorages[STREAM_PARENT(iCurStream)]->
 	               		DestroyElement(STREAM_NAME(iCurStream));
	    	ulTime = sw.Read();
	    	m_ulDestroyElementTotal[iIter] += ulTime;

	    	if (ulTime < m_ulDestroyElementMin[iIter])
	    	    m_ulDestroyElementMin[iIter] = ulTime;

	    	if (ulTime > m_ulDestroyElementMax[iIter])
	    	    m_ulDestroyElementMax[iIter] = ulTime;

	    	if (FAILED(hr))
		{
	    	    Log(TEXT("DestroyElement"), hr);
	    	    return hr;
		}
             }
	     Log( TEXT("DestroyElement"), S_OK);

	     m_ulDestroyElementAverage[iIter] = m_ulDestroyElementTotal[iIter] / 
	     					 (m_cStreams / m_cBranching);
	}
        // for each storage, do commit if in transacted mode
	// and release the storage.
    	for (iCurStg = m_cStorages-1 ; iCurStg >= 0 ; iCurStg--)
    	{
	    // determine level of curent storage.
	    iLevel = 0;
	    iParent = STG_PARENT(iCurStg);
	    while(iParent > 0)
	    {
	    	iParent = STG_PARENT(iParent);
		iLevel++;
	    }

    	    if (m_flCreateFlags == STGM_TRANSACTED)
	    {
	     	sw.Reset();
    	    	m_piStorages[iCurStg]->Commit(STGC_DEFAULT);
	    	ulTime = sw.Read();
	    	m_ulStorageCommitTotal[iIter] += ulTime;

		if (iCurStg != 0)
		{
	    	    if (ulTime < m_ulStorageCommitMin[iLevel][iIter])
	    	    	m_ulStorageCommitMin[iLevel][iIter] = ulTime;

	    	    if (ulTime > m_ulStorageCommitMax[iLevel][iIter])
	    	    	m_ulStorageCommitMax[iLevel][iIter] = ulTime;
		}
		else
		{
		    m_ulFinalStorageCommit[iIter] = ulTime; 
		}
	    }

	    sw.Reset();
    	    m_piStorages[iCurStg]->Release();
	    ulTime = sw.Read();
	    m_ulStorageReleaseTotal[iIter] += ulTime;

	    if (iCurStg != 0)
	    {
	    	if (ulTime < m_ulStorageReleaseMin[iLevel][iIter])
	            m_ulStorageReleaseMin[iLevel][iIter] = ulTime;

	    	if (ulTime > m_ulStorageReleaseMax[iLevel][iIter])
	            m_ulStorageReleaseMax[iLevel][iIter] = ulTime;
	    }
	    else
	    {
		m_ulFinalStorageRelease[iIter] = ulTime; 
	    }
	}

	Log(TEXT("StorageCommit"), S_OK);
	Log(TEXT("StorageRelease"), S_OK);


	m_ulCreateStorageAverage[iIter] = m_ulCreateStorageTotal[iIter] / m_cStorages;
	m_ulCreateStreamAverage[iIter]  = m_ulCreateStreamTotal[iIter]  / m_cStreams;
	m_ulStreamWriteAverage[iIter]   = m_ulStreamWriteTotal[iIter]   / m_cStreams;
	m_ulStreamReleaseAverage[iIter] = m_ulStreamReleaseTotal[iIter] / m_cStreams;
	m_ulStorageCommitAverage[iIter] = m_ulStorageCommitTotal[iIter] / m_cStorages;
	m_ulStorageReleaseAverage[iIter] = m_ulStorageReleaseTotal[iIter] / m_cStorages;

	m_ulTotal[iIter] = m_ulStgCreateDocfile[iIter] +
			   m_ulCreateStorageTotal[iIter] + 
			   m_ulCreateStreamTotal[iIter] +
			   m_ulStreamWriteTotal[iIter] +
			   m_ulStreamReleaseTotal[iIter] +
			   m_ulDestroyElementTotal[iIter] +
			   m_ulStorageCommitTotal[iIter] +
			   m_ulStorageReleaseTotal[iIter];
			      	
    }

    return S_OK;
}


SCODE CNestedStorageTest::Report (CTestOutput &output)
{	       
    TCHAR pszBuf[80];

    wsprintf(pszBuf, TEXT("Nested Storage Test in %s Mode writing %d bytes"),
    	      m_pszFileMode, m_cbSize);

    output.WriteSectionHeader (Name(), pszBuf, *m_pInput);
    output.WriteString (TEXT("\n"));

    for ( ULONG iLevel = 0; iLevel < m_cNesting - 1; iLevel++)
    {
    	wsprintf(pszBuf, TEXT("\nLevel %d\n"), iLevel + 1);
    	output.WriteString (pszBuf);   
    	output.WriteResults (TEXT("CreateStorage    Min"), m_ulIterations, 
    			     m_ulCreateStorageMin[iLevel]);
    	output.WriteResults (TEXT("CreateStorage    Max"), m_ulIterations, 
    			     m_ulCreateStorageMax[iLevel]);

    	if (m_flCreateFlags == STGM_TRANSACTED)
	{
            output.WriteResults (TEXT("StorageCommit    Min"), m_ulIterations, 
            			 m_ulStorageCommitMin[iLevel] );
            output.WriteResults (TEXT("StorageCommit    Max"), m_ulIterations, 
            			 m_ulStorageCommitMax[iLevel] );
	}

    	output.WriteResults (TEXT("StorageRelease   Min"), m_ulIterations, 
    			     m_ulStorageReleaseMin[iLevel]);
    	output.WriteResults (TEXT("StorageRelease   Max"), m_ulIterations, 
    			     m_ulStorageReleaseMax[iLevel]);
    }

    output.WriteString (TEXT("\nOverall\n"));

    output.WriteResults (TEXT("StgCreateDocfile    "), m_ulIterations, 
    			 m_ulStgCreateDocfile);

    if (m_flCreateFlags == STGM_TRANSACTED)
    	output.WriteResults (TEXT("Final Storage Commit"), m_ulIterations, 
    			     m_ulFinalStorageCommit);

    output.WriteResults (TEXT("Final Storage Release"), m_ulIterations, 
    			 m_ulFinalStorageRelease);
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("CreateStorage Average"), m_ulIterations, 
    			 m_ulCreateStorageAverage );
    output.WriteResults (TEXT("CreateStorage  Total"), m_ulIterations, 
    			 m_ulCreateStorageTotal );
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("CreateStream     Min"), m_ulIterations, 
    			 m_ulCreateStreamMin);
    output.WriteResults (TEXT("CreateStream     Max"), m_ulIterations, 
    			 m_ulCreateStreamMax);
    output.WriteResults (TEXT("CreateStream Average"), m_ulIterations, 
    			 m_ulCreateStreamAverage);
    output.WriteResults (TEXT("CreateStream   Total"), m_ulIterations, 
    			 m_ulCreateStreamTotal );
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("StreamWrite      Min"), m_ulIterations, 
    			 m_ulStreamWriteMin );
    output.WriteResults (TEXT("StreamWrite      Max"), m_ulIterations,
    			 m_ulStreamWriteMax );
    output.WriteResults (TEXT("StreamWrite  Average"), m_ulIterations,
    			 m_ulStreamWriteAverage );
    output.WriteResults (TEXT("StreamWrite    Total"), m_ulIterations,
    			 m_ulStreamWriteTotal );
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("StreamRelease    Min"), m_ulIterations,
    			 m_ulStreamReleaseMin );
    output.WriteResults (TEXT("StreamRelease    Max"), m_ulIterations,
    			 m_ulStreamReleaseMax );
    output.WriteResults (TEXT("StreamRelease Average"), m_ulIterations, 
    			 m_ulStreamReleaseAverage );
    output.WriteResults (TEXT("StreamRelease  Total"), m_ulIterations,
    			 m_ulStreamReleaseTotal );
    output.WriteString (TEXT("\n"));

    if(m_bDelete)		       
    {
    	output.WriteResults (TEXT("DestroyElement   Min"), m_ulIterations,
    			     m_ulDestroyElementMin );
    	output.WriteResults (TEXT("DestroyElement   Max"), m_ulIterations, 
    			     m_ulDestroyElementMax );
    	output.WriteResults (TEXT("DestroyElement Average"), m_ulIterations, 
    			     m_ulDestroyElementAverage );
    	output.WriteResults (TEXT("DestroyElement Total"), m_ulIterations, 
    			     m_ulDestroyElementTotal );
    	output.WriteString (TEXT("\n"));
    }

    if (m_flCreateFlags == STGM_TRANSACTED)
    {
        output.WriteResults (TEXT("StorageCommit Average"), m_ulIterations, 
        		     m_ulStorageCommitAverage );
        output.WriteResults (TEXT("StorageCommit   Total"), m_ulIterations, 
        		     m_ulStorageCommitTotal );
    	output.WriteString (TEXT("\n"));
    }

    output.WriteResults (TEXT("StorageRelease Average"), m_ulIterations, 
    			 m_ulStorageReleaseAverage );
    output.WriteResults (TEXT("StorageRelease  Total"), m_ulIterations, 
    			 m_ulStorageReleaseTotal );
    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("Overall Total       "), m_ulIterations, m_ulTotal );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_piact.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_piact.cxx
//
//  Contents:	Persistant instance activation test
//
//  Classes:	COlePersistActivationTest
//
//  History:    29-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_piact.hxx>


WCHAR *COlePersistActivationTest::Name ()
{
	return L"PersistActivation";
}


SCODE COlePersistActivationTest::Setup (CTestInput *pInput)
{
	IPersistFile   *pIPF = NULL;
	IClassFactory  *pICF = NULL;
	SCODE		sc = S_OK, scRet = S_OK;

	CTestBase::Setup (pInput);

	// Get number of iterations
	m_ulIterations = pInput->GetIterations(Name());

	//  for each class ctx, get the classid, and init internal state
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    // Get ClsID for this Ctx from the .ini file
	    sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apwszClsIDName[iCtx]);
	    if (FAILED(sc))
	    {
		Log (L"Setup - GetGUID failed", sc);
		return sc;
	    }

	    INIT_RESULTS (m_ulNewTime[iCtx]);
	    INIT_RESULTS (m_ulGetTime[iCtx]);
	}


    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }


	//  for each class ctx, create a persistent instance on disk
	for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    // Create an instance
	    sc = CoGetClassObject(m_ClsID[iCtx], dwaClsCtx[iCtx], NULL,
				  IID_IClassFactory, (void **)&pICF);
	    if (SUCCEEDED(sc))
	    {
		sc = pICF->CreateInstance(NULL, IID_IPersistFile, (void **)&pIPF);
		pICF->Release();
		if (SUCCEEDED(sc))
		{
		    //	save the instance in a file
		    sc = pIPF->Save (apwszPerstName[iCtx], TRUE);
		    pIPF->Release();

		    if (FAILED(sc))
		    {
			Log (L"Setup - IPersistFile::Save failed", sc);
			scRet = sc;
		    }
		}
		else
		{
		    Log (L"Setup - CreateInstance failed", sc);
		    scRet = sc;
		}

	    }
	    else
	    {
		Log (L"Setup - CoGetClassObject failed", sc);
		scRet = sc;
	    }
	}

	// _pInput = pInput;
	return scRet;
}


SCODE COlePersistActivationTest::Cleanup ()
{
	UninitCOM();

	CHAR	szPerstName[80];

	//  delete the persistent instances
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	delete original
	    wcstombs(szPerstName, apwszPerstName[iCtx],
		     wcslen(apwszPerstName[iCtx])+1);
	    _unlink (szPerstName);

	    //	delete new instance
	    wcstombs(szPerstName, apwszPerstNameNew[iCtx],
		     wcslen(apwszPerstNameNew[iCtx])+1);
	    _unlink (szPerstName);
	}

	return S_OK;
}


SCODE COlePersistActivationTest::Run ()
{
	CStopWatch  sw;
	IUnknown   *punk = NULL;
	SCODE	    sc;

	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset();
		sc = CoGetPersistentInstance(IID_IUnknown,
					dwaClsCtx[iCtx],
					STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
					apwszPerstName[iCtx],
					NULL,
					CLSID_NULL,
					NULL,
					(void**)&punk);

		m_ulGetTime[iCtx][iIter] = sw.Read();
		Log (L"CoGetPersistentInstance", sc);

		if (SUCCEEDED(sc))
		{
		    sw.Reset();
		    punk->Release();
		    m_ulGetReleaseTime[iCtx][iIter] = sw.Read();
		}
		else
		{
		    m_ulGetTime[iCtx][iIter] = NOTAVAIL;
		}

		// _pInput->Pause(IP_ITERPAUSE);

		sw.Reset();
		sc = CoNewPersistentInstance(m_ClsID[iCtx],
					IID_IUnknown,
					dwaClsCtx[iCtx],
					STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
					apwszPerstName[iCtx],
					NULL,
					apwszPerstNameNew[iCtx],
					(void**)&punk);
		m_ulNewTime[iCtx][iIter] = sw.Read();
		Log (L"CoNewPersistentInstance", sc);

		if (SUCCEEDED(sc))
		{
		    sw.Reset();
		    punk->Release();
		    m_ulNewReleaseTime[iCtx][iIter] = sw.Read();
		}
		else
		{
		    m_ulNewTime[iCtx][iIter] = NOTAVAIL;
		}

		CHAR	szPerstName[80];
		wcstombs(szPerstName, apwszPerstNameNew[iCtx],
			  wcslen(apwszPerstNameNew[iCtx])+1);
		_unlink(szPerstName);

		// _pInput->Pause(IP_ITERPAUSE);
	    }
	}

	return S_OK;
}



SCODE COlePersistActivationTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(),
			   L"CoGetPersistentInstance / CoNewPersistentInstance",
			   *m_pInput);

	//  for each clsctx, write the results
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    output.WriteString(L"\n");
	    output.WriteClassID (&m_ClsID[iCtx]);
	    output.WriteString (apwszClsCtx[iCtx]);
	    output.WriteString(L"\n");

	    output.WriteResults (L"CoGetPI", m_ulIterations, m_ulGetTime[iCtx]);
	    output.WriteResults (L"Release", m_ulIterations, m_ulGetReleaseTime[iCtx]);
	    output.WriteResults (L"CoNewPI", m_ulIterations, m_ulNewTime[iCtx]);
	    output.WriteResults (L"Release", m_ulIterations, m_ulNewReleaseTime[iCtx]);
	}

	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_regis.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_regis.cxx
//
//  Contents:	Ole object registration test
//
//  Classes:	COleRegistrationTest
//
//  History:    12-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_regis.hxx>
#include <oletest.hxx>

extern COleTestClassFactory theFactory;


const CLSID *apClsid[] = {&CLSID_COleTestClass1,
			  &CLSID_COleTestClass2,
			  &CLSID_COleTestClass3,
			  &CLSID_COleTestClass4,
			  &CLSID_COleTestClass5,
			  &CLSID_COleTestClass6,
			  &CLSID_COleTestClass7,
			  &CLSID_COleTestClass8};


TCHAR *COleRegistrationTest::Name ()
{
	return	TEXT("ObjRegistration");
}


SCODE COleRegistrationTest::Setup (CTestInput *pInput)
{
	HRESULT sc;

	CTestBase::Setup(pInput);

	//  get the iteration count
	m_ulIterations = pInput->GetIterations(Name());

	//  for the inproc case. load a class factory object to register.
	//  this is temporary to fix a problem (ambiguity) in inproc
	//  registration.

	sc = pInput->GetGUID(&m_Clsid[0], Name(), apszClsIDName[0]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	sc = pInput->GetGUID(&m_Clsid[1], Name(), apszClsIDName[1]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	sc = InitCOM();
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoInitialize failed."), sc);
	    return sc;
	}

	//  get the class factory
	sc = CoGetClassObject(m_Clsid[0], dwaClsCtx[0], NULL,
			  IID_IClassFactory, (void **)&m_apICF[0]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoGetClassObject failed."), sc);
	    return sc;
	}


	//  for local server, register an internal class.
	m_apICF[1] = (IClassFactory *)&theFactory;

	//  init internal state
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    INIT_RESULTS(m_ulRegisterCtx[iCtx]);
	    INIT_RESULTS(m_ulRevokeCtx[iCtx]);
	}

	// _pInput = pInput;
	return S_OK;
}


SCODE COleRegistrationTest::Cleanup ()
{
	m_apICF[0]->Release();

	UninitCOM();
	
	return S_OK;
}

SCODE COleRegistrationTest::Run ()
{
	CStopWatch sw;
	DWORD dwReg;

	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset ();
		SCODE sc = CoRegisterClassObject(m_Clsid[iCtx],
						 m_apICF[iCtx],
						 dwaClsCtx[iCtx],
						 REGCLS_MULTIPLEUSE, &dwReg);
		m_ulRegisterCtx[iCtx][iIter] = sw.Read ();
		Log (TEXT("CoRegisterClassObject"),sc);

		//  NOTE: Revoke has different behaviour depending on
		//  whether single use or multiuse is specified in the
		//  registration.

		if (SUCCEEDED(sc))
		{
		    // Revoke
		    sw.Reset ();
		    sc = CoRevokeClassObject(dwReg);
		    m_ulRevokeCtx[iCtx][iIter] = sw.Read();
		    if (Log (TEXT("CoRevokeClassObject"), sc))
			m_ulRevokeCtx[iCtx][iIter] = NOTAVAIL;
		}
		else
		{
		    m_ulRegisterCtx[iCtx][iIter] = NOTAVAIL;
		}

		// _pInput->Pause(IP_ITERPAUSE);
	    }
	}

	return S_OK;
}



SCODE COleRegistrationTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(),
		    TEXT("CoRegisterClassObject / CoRevokeClassObject"), *m_pInput);

	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    output.WriteString (TEXT("\n"));
	    output.WriteClassID(&m_Clsid[iCtx]);
	    output.WriteString (apszClsCtx[iCtx]);
	    output.WriteString (TEXT("\n"));

	    output.WriteResults (TEXT("Register"), m_ulIterations,
				 m_ulRegisterCtx[iCtx]);

	    output.WriteResults (TEXT("Revoke  "), m_ulIterations,
				 m_ulRevokeCtx[iCtx]);
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_rot.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_rot.cxx
//
//  Contents:	Ole running object table test (ROT)
//
//  Classes:	CROTTest
//
//  History:    9-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_rot.hxx>
#include <cact.hxx>		//  CTestAct


//  function used by CTestAct. need not do anything for our usage.
void GlobalRefs(BOOL fAdd)
{
}


TCHAR *CROTTest::Name ()
{
	return TEXT("ROT");
}


SCODE CROTTest::Setup (CTestInput *pInput)
{
	IClassFactory	*pICF = NULL;
	IPersistFile	*pIPF = NULL;
	SCODE		 sc = S_OK, scRet = S_OK;


	CTestBase::Setup(pInput);

	// get the iteration count from the ini file
	m_ulIterations = pInput->GetIterations(Name());
	m_ulEntries = 1;

	//  for each class ctx, get the classid, and init internal state
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    // Get ClsID for this Ctx from the .ini file
	    sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apszClsIDName[iCtx]);
	    if (FAILED(sc))
	    {
		Log (TEXT("Setup - GetClassID failed."), sc);
		return sc;
	    }

	    INIT_RESULTS(m_ulGetROTTime[iCtx]);
	    INIT_RESULTS(m_ulReleaseTime[iCtx]);
	    INIT_RESULTS(m_ulRegisterTime[iCtx]);
	    INIT_RESULTS(m_ulRevokeTime[iCtx]);
	    INIT_RESULTS(m_ulNoteChangeTime[iCtx]);
	    INIT_RESULTS(m_ulGetChangeTime[iCtx]);
	    INIT_RESULTS(m_ulIsRunningTime[iCtx]);
	    INIT_RESULTS(m_ulGetObjectTime[iCtx]);
	    INIT_RESULTS(m_ulEnumRunningTime[iCtx]);
	}


	sc = InitCOM();
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoInitialize failed."), sc);
	    return sc;
	}


	//  for each class ctx, create a persistent instance on disk
	for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    m_punkObj[iCtx] = NULL;
	    m_pmkObj[iCtx]  = NULL;

	    if (dwaClsCtx[iCtx] == CLSCTX_INPROC_SERVER)
	    {
		// create an inprocess instance
		m_punkObj[iCtx] = (IPersistFile *) new CTestAct(m_ClsID[iCtx]);
		sc = (m_punkObj[iCtx] != NULL) ? S_OK : E_OUTOFMEMORY;
	    }
	    else
	    {
		// Create an instance
		sc = CoCreateInstance(m_ClsID[iCtx], NULL, dwaClsCtx[iCtx],
				      IID_IUnknown, (void **)&m_punkObj[iCtx]);
	    }

	    if (SUCCEEDED(sc))
	    {
		//  Create a moniker
		sc = CreateFileMoniker(apszPerstName[iCtx], &m_pmkObj[iCtx]);

		if (SUCCEEDED(sc))
		{
		    //	get the IPersistFile interface
		    IPersistFile *pIPF = NULL;

		    sc = m_punkObj[iCtx]->QueryInterface(IID_IPersistFile,
							 (void **)&pIPF);

		    if (SUCCEEDED(sc))
		    {
			//  save the class instance in the file.
			//  NOTE: we assume the server's implementation of
			//  this method does not do any ROT operations. We
			//  know this to be true of CTestAct.

			sc = pIPF->Save(apszPerstName[iCtx], FALSE);
			pIPF->Release();

			if (FAILED(sc))
			{
			    Log (TEXT("Setup - pIPF->Save failed."), sc);
			    scRet = sc;
			}
		    }
		    else
		    {
			Log (TEXT("Setup - QueryInterface failed"), sc);
			scRet = sc;
		    }
		}
		else
		{
		    Log (TEXT("Setup - CreateFileMoniker failed"), sc);
		    scRet = sc;
		}
	    }
	    else
	    {
		Log (TEXT("Setup - CreateInstance failed"), sc);
		scRet = sc;
	    }
	}

	if (FAILED(scRet))
	{
	    Cleanup();
	}

	return scRet;
}


SCODE CROTTest::Cleanup ()
{	
	CHAR	szPerstName[80];

	//  delete the persistent instances
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	delete files
	    wcstombs(szPerstName, apszPerstName[iCtx],
		     wcslen(apszPerstName[iCtx])+1);
	    _unlink (szPerstName);

	    if (m_punkObj[iCtx])
		m_punkObj[iCtx]->Release();

	    if (m_pmkObj[iCtx])
		m_pmkObj[iCtx]->Release();
	}


	UninitCOM();
	return S_OK;
}


SCODE CROTTest::Run ()
{
	IRunningObjectTable *pROT = NULL;
	CStopWatch   sw;
	SCODE	     sc;


	//  do the server side ROT operations.
	//  this makes sense only for inprocess objects.

	ULONG iCtx=0;
	{
	    //	for each iteration
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset();
		sc = GetRunningObjectTable(NULL, &pROT);
		m_ulGetROTTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("GetRunningObjectTable"), sc))
		{
		    m_ulGetROTTime[iCtx][iIter] = NOTAVAIL;
		}

		DWORD	dwRegister = 0;

		sw.Reset();
		sc = pROT->Register(0, m_punkObj[iCtx], m_pmkObj[iCtx], &dwRegister);
		m_ulRegisterTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("pROT->Register"), sc))
		{
		    m_ulRegisterTime[iCtx][iIter] = NOTAVAIL;
		}


		FILETIME    ft;
		SYSTEMTIME  st;

		GetSystemTime(&st);
		SystemTimeToFileTime(&st, &ft);

		sw.Reset();
		sc = pROT->NoteChangeTime(dwRegister, &ft);
		m_ulNoteChangeTime[iCtx][iIter]=sw.Read ();
		if (Log (TEXT("pROT->NoteChangeTime"), sc))
		{
		    m_ulNoteChangeTime[iCtx][iIter] = NOTAVAIL;
		}


		sw.Reset();
		sc = pROT->Revoke(dwRegister);
		m_ulRevokeTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("pROT->Revoke"), sc))
		{
		    m_ulRevokeTime[iCtx][iIter] = NOTAVAIL;
		}


		sw.Reset();
		pROT->Release();
		m_ulReleaseTime[iCtx][iIter]=sw.Read ();
		pROT = NULL;
		if (Log (TEXT("pROT->Release"), sc))
		{
		    m_ulReleaseTime[iCtx][iIter] = NOTAVAIL;
		}
	    }
	}


	//  do the client side ROT operations
	//  this makes sense for both class contexts

	pROT = NULL;
	sc = GetRunningObjectTable(NULL, &pROT);
	if (Log (TEXT("GetRunningObjectTable"), sc))
	{
	    return sc;
	}


	for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	put the object into the loaded state. this will cause it to
	    //	register itself in the ROT.
	    IPersistFile *pIPF = NULL;

	    sc = m_punkObj[iCtx]->QueryInterface(IID_IPersistFile, (void **)&pIPF);
	    if (SUCCEEDED(sc))
	    {
		pIPF->Load(apszPerstName[iCtx], STGM_READ | STGM_SHARE_DENY_NONE);
		pIPF->Release();
	    }

	    //	for each iteration
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		IEnumMoniker	*pEnumMk = NULL;

		sw.Reset();
		sc = pROT->EnumRunning(&pEnumMk);
		m_ulEnumRunningTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("pROT->EnumRunning"), sc))
		{
		    m_ulEnumRunningTime[iCtx][iIter] = NOTAVAIL;
		}

		if (pEnumMk)
		{
		    pEnumMk->Release();
		}


		sw.Reset();
		sc = pROT->IsRunning(m_pmkObj[iCtx]);
		m_ulIsRunningTime[iCtx][iIter] = sw.Read();
		if (Log (TEXT("pROT->IsRunning"), sc))
		{
		    m_ulIsRunningTime[iCtx][iIter] = NOTAVAIL;
		}


		FILETIME    ft;

		sw.Reset();
		sc = pROT->GetTimeOfLastChange(m_pmkObj[iCtx], &ft);
		m_ulGetChangeTime[iCtx][iIter]=sw.Read ();
		if (Log (TEXT("pROT->GetTimeOfLastChange"), sc))
		{
		    m_ulGetChangeTime[iCtx][iIter] = NOTAVAIL;
		}


		IUnknown *pUnk = NULL;

		sw.Reset();
		sc = pROT->GetObject(m_pmkObj[iCtx], &pUnk);
		m_ulGetObjectTime[iCtx][iIter]=sw.Read ();
		if (Log (TEXT("pROT->GetObject"), sc))
		{
		    m_ulGetObjectTime[iCtx][iIter] = NOTAVAIL;
		}

		if (pUnk)
		{
		    pUnk->Release();
		}
	    }
	}

	return S_OK;
}		



SCODE CROTTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(), TEXT("RunningObjectTable"), *m_pInput);

	//  write out the server side results
	ULONG iCtx=0;
	output.WriteString(TEXT("\nServer Side\n\n"));
	output.WriteResults(TEXT("GetRunningObjTbl"), m_ulIterations, m_ulGetROTTime[iCtx]);
	output.WriteResults(TEXT("Register        "), m_ulIterations, m_ulRegisterTime[iCtx]);
	output.WriteResults(TEXT("NoteChangeTime  "), m_ulIterations, m_ulNoteChangeTime[iCtx]);
	output.WriteResults(TEXT("Revoke          "), m_ulIterations, m_ulRevokeTime[iCtx]);
	output.WriteResults(TEXT("pROT->Release   "), m_ulIterations, m_ulReleaseTime[iCtx]);


	//  write out the client side results
	output.WriteString(TEXT("\nClient Side\n"));

	//  for each clsctx, write the results
	for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    output.WriteString(TEXT("\n"));
	    output.WriteClassID(&m_ClsID[iCtx]);
	    output.WriteString(apszClsCtx[iCtx]);
	    output.WriteString(TEXT("\n"));

	    output.WriteResults(TEXT("EnumRunning     "), m_ulIterations, m_ulEnumRunningTime[iCtx]);
	    output.WriteResults(TEXT("IsRunning       "), m_ulIterations, m_ulIsRunningTime[iCtx]);
	    output.WriteResults(TEXT("GetChangeTime   "), m_ulIterations, m_ulGetChangeTime[iCtx]);
	    output.WriteResults(TEXT("GetObject       "), m_ulIterations, m_ulGetObjectTime[iCtx]);
	}

	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_qi.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_qi.cxx
//
//  Contents:	Ole QueryInterface test
//
//  Classes:	CQueryInterfaceTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_qi.hxx>


//  this is just an array of random interface iids. The qi server object
//  answers YES to any QI, although the only valid methods on each interface
//  are the methods of IUnknown.
//
//  the code will answer NO to the following IIDs in order to prevent
//  custom marshalling problems...
//
//	IID_IMarshal, IID_IStdMarshalInfo, IID_IStdIdentity,
//	IID_IPersist, IID_IProxyManager

const IID *iid[] = {&IID_IAdviseSink,	 &IID_IDataObject,
		 &IID_IOleObject,	 &IID_IOleClientSite,
		 &IID_IParseDisplayName, &IID_IPersistStorage,
		 &IID_IPersistFile,	 &IID_IStorage,
		 &IID_IOleContainer,	 &IID_IOleItemContainer,
		 &IID_IOleInPlaceSite,	 &IID_IOleInPlaceActiveObject,
		 &IID_IOleInPlaceObject, &IID_IOleInPlaceUIWindow,
		 &IID_IOleInPlaceFrame,	 &IID_IOleWindow};



TCHAR *CQueryInterfaceTest::Name ()
{
    return TEXT("QueryInterface");
}


SCODE CQueryInterfaceTest::Setup (CTestInput *pInput)
{
    SCODE sc;

    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize state
    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apszClsIDName[iCtx]);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	INIT_RESULTS(m_ulQueryInterfaceSameTime[iCtx]);
	INIT_RESULTS(m_ulPunkReleaseSameTime[iCtx]);
	INIT_RESULTS(m_ulQueryInterfaceNewTime[iCtx]);
	INIT_RESULTS(m_ulPunkReleaseNewTime[iCtx]);

	_pUnk[iCtx] = NULL;
    }

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    //	create an instance of each qi server object
    for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	sc = CoCreateInstance(m_ClsID[iCtx], NULL, dwaClsCtx[iCtx],
		      IID_IUnknown, (void **)&_pUnk[iCtx]);

	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance failed"), sc);
	}
    }

    return S_OK;
}


SCODE CQueryInterfaceTest::Cleanup ()
{
    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	if (_pUnk[iCtx])
	{
	    _pUnk[iCtx]->Release();
	}
    }

    UninitCOM();
    return S_OK;
}


SCODE CQueryInterfaceTest::Run ()
{
	CStopWatch    sw;
	IUnknown      *pUnk = NULL;


	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    if (!_pUnk[iCtx])
		continue;

	    //	same interface each time, releasing after each query
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset ();
		SCODE sc = _pUnk[iCtx]->QueryInterface(IID_IStorage, (void **)&pUnk);
		m_ulQueryInterfaceSameTime[iCtx][iIter] = sw.Read ();
		Log (TEXT("QueryInterface"), sc);

		if (SUCCEEDED(sc))
		{
		    sw.Reset();
		    pUnk->Release ();
		    m_ulPunkReleaseSameTime[iCtx][iIter] = sw.Read();
		}
		else
		{
		    m_ulPunkReleaseSameTime[iCtx][iIter] = NOTAVAIL;
		}
	    }

	    //	different interface each time, releasing after each query
	    for (iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset ();
		SCODE sc = _pUnk[iCtx]->QueryInterface(*(iid[iIter]), (void **)&pUnk);
		m_ulQueryInterfaceNewTime[iCtx][iIter] = sw.Read ();
		Log (TEXT("QueryInterface"), sc);

		if (SUCCEEDED(sc))
		{
		    sw.Reset();
		    pUnk->Release ();
		    m_ulPunkReleaseNewTime[iCtx][iIter] = sw.Read();
		}
		else
		{
		    m_ulPunkReleaseNewTime[iCtx][iIter] = NOTAVAIL;
		}
	    }

	}

	return S_OK;
}					  



SCODE CQueryInterfaceTest::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("QueryInterface"), *m_pInput);

    for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
    {
	output.WriteString(TEXT("\n"));
	output.WriteClassID (&m_ClsID[iCtx]);
	output.WriteString(apszClsCtx[iCtx]);
	output.WriteString(TEXT("\n"));

	output.WriteResults (TEXT("QuerySameInterface"), m_ulIterations,
			      m_ulQueryInterfaceSameTime[iCtx]);

	output.WriteResults (TEXT("Release           "), m_ulIterations,
			     m_ulPunkReleaseSameTime[iCtx]);

	output.WriteResults (TEXT("QueryNewInterface "), m_ulIterations,
			     m_ulQueryInterfaceNewTime[iCtx]);

	output.WriteResults (TEXT("Release           "), m_ulIterations,
			     m_ulPunkReleaseNewTime[iCtx]);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_rpc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_rpc.cxx
//
//  Contents:	Rpc Method Invocation tests
//
//  Classes:	CRpcTest
//
//  History:    1-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_rpc.hxx>
#include <oletest.hxx>
#include <tracelog.hxx>


TCHAR *CRpcTest::Name ()
{
	return TEXT("RpcTest");
}


SCODE CRpcTest::Setup (CTestInput *pInput)
{
	CTestBase::Setup(pInput);

	SCODE sc = pInput->GetGUID(&m_ClsID, Name(), TEXT("Clsid_Local"));
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID failed."), sc);
	    return sc;
	}

	// get flag indicating whether to keep all values or
	// only average values.
	TCHAR	szAverage[5];
	pInput->GetConfigString(Name(), TEXT("Average"), TEXT("Y"),
                            szAverage, sizeof(szAverage)/sizeof(TCHAR));
        if (szAverage[0] == 'n' || szAverage[0] == 'N')
	    m_fAverage = FALSE;
	else
	    m_fAverage = TRUE;

	//  get iteration count
	if (m_fAverage)
	    m_ulIterations = pInput->GetRealIterations(Name());
	else
	    m_ulIterations = pInput->GetIterations(Name());

	//  initialize timing arrays
	INIT_RESULTS(m_ulVoidTime);
	INIT_RESULTS(m_ulVoidRCTime);

	INIT_RESULTS(m_ulDwordInTime);
	INIT_RESULTS(m_ulDwordOutTime);
	INIT_RESULTS(m_ulDwordInOutTime);

	INIT_RESULTS(m_ulStringInTime);
	INIT_RESULTS(m_ulStringOutTime);
	INIT_RESULTS(m_ulStringInOutTime);

	INIT_RESULTS(m_ulGuidInTime);
	INIT_RESULTS(m_ulGuidOutTime);

	INIT_RESULTS(m_ulIUnknownInprocInTime);
	INIT_RESULTS(m_ulIUnknownInprocOutTime);
	INIT_RESULTS(m_ulIUnknownLocalInTime);
	INIT_RESULTS(m_ulIUnknownLocalOutTime);

	INIT_RESULTS(m_ulIUnknownKeepInTime);
	INIT_RESULTS(m_ulIUnknownKeepOutTime);

	INIT_RESULTS(m_ulInterfaceInprocInTime);
	INIT_RESULTS(m_ulInterfaceLocalInTime);


	sc = InitCOM();
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoInitialize failed."), sc);
	    return  sc;
	}

	m_pRPC=NULL;
	sc = CoCreateInstance(m_ClsID, NULL, CLSCTX_LOCAL_SERVER,
			      IID_IRpcTest, (void **)&m_pRPC);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance IRpcTest failed."), sc);
	    return sc;
	}


	//  get the inprocess object for the IUnknown marshalling test
	sc = pInput->GetGUID(&m_ClsID, Name(), TEXT("Clsid_Inproc"));
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - GetClassID Inproc failed."), sc);
	    return sc;
	}

	m_punkInproc = NULL;
	sc = CoCreateInstance(m_ClsID, NULL, CLSCTX_INPROC_SERVER,
			      IID_IUnknown, (void **)&m_punkInproc);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance IUnknown Inproc failed."), sc);
	    return sc;
	}


	//  get the out of process object for the IUnknown marshalling test

	m_punkLocal = NULL;
	sc = CoCreateInstance(m_ClsID, NULL, CLSCTX_LOCAL_SERVER,
			      IID_IUnknown, (void **)&m_punkLocal);
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoCreateInstance IUnknown LocalSrv failed."), sc);
	    return sc;
	}

	return S_OK;
}


SCODE CRpcTest::Cleanup ()
{
	if (m_pRPC)
	    m_pRPC->Release();

	if (m_punkInproc)
	    m_punkInproc->Release();

	if (m_punkLocal)
	    m_punkLocal->Release();

	UninitCOM();
	return S_OK;
}


SCODE CRpcTest::Run ()
{
    CStopWatch  sw;
    SCODE       sc;
    ULONG       iIter;

    //
    // void passing tests
    //

    // STARTTRACE("CRpcTest");

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
        // TRACECALL(TRACE_APP, "m_pRPC->Void()");

	ResetNotAverage( m_fAverage, sw );
        m_pRPC->Void();
	ReadNotAverage( m_fAverage, sw, m_ulVoidTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulVoidTime[0], m_ulIterations );

    // STOPTRACE("CRpcTest");


    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
        // TRACECALL(TRACE_APP, "m_pRPC->VoidRC()");

	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->VoidRC();
        ReadNotAverage( m_fAverage, sw, m_ulVoidRCTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulVoidRCTime[0], m_ulIterations );

    //
    //  dword passing tests
    //

    DWORD dwTmp = 1;
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->DwordIn(dwTmp);
        ReadNotAverage( m_fAverage, sw, m_ulDwordInTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulDwordInTime[0], m_ulIterations );

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->DwordOut(&dwTmp);
        ReadNotAverage( m_fAverage, sw, m_ulDwordOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulDwordOutTime[0], m_ulIterations );

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->DwordInOut(&dwTmp);
        ReadNotAverage( m_fAverage, sw, m_ulDwordInOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulDwordInOutTime[0], m_ulIterations );

    //
    //  string passing tests
    //

    OLECHAR wszHello[] = L"C:\\FOOFOO\\FOOBAR\\FOOBAK\\FOOBAZ\\FOOTYPICAL\\PATH\\HELLO";
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->StringIn(wszHello);
        ReadNotAverage( m_fAverage, sw, m_ulStringInTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulStringInTime[0], m_ulIterations );

    LPOLESTR pwszOut = NULL;
#ifdef STRINGOUT
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
        pwszOut = NULL;
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->StringOut(&pwszOut);
        ReadNotAverage( m_fAverage, sw, m_ulStringOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulStringOutTime[0], m_ulIterations );
#endif
    pwszOut = wszHello;
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->StringInOut(pwszOut);
        ReadNotAverage( m_fAverage, sw, m_ulStringInOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulStringInOutTime[0], m_ulIterations );

    //
    //  guid passing tests
    //

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->GuidIn(IID_IRpcTest);
        ReadNotAverage( m_fAverage, sw, m_ulGuidInTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulGuidInTime[0], m_ulIterations );

    GUID    guid;
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->GuidOut(&guid);
        ReadNotAverage( m_fAverage, sw, m_ulGuidOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulGuidOutTime[0], m_ulIterations );


    //
    //  IUnknown passing tests
    //

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->IUnknownIn(m_punkInproc);
        ReadNotAverage( m_fAverage, sw, m_ulIUnknownInprocInTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulIUnknownInprocInTime[0], m_ulIterations );

    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->IUnknownIn(m_punkLocal);
        ReadNotAverage( m_fAverage, sw, m_ulIUnknownLocalInTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulIUnknownLocalInTime[0], m_ulIterations );

    IUnknown *punk = NULL;
    ResetAverage( m_fAverage, sw );
    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	ResetNotAverage( m_fAverage, sw );
        sc = m_pRPC->IUnknownOut(&punk);
        punk->Release();
        punk = NULL;
        ReadNotAverage( m_fAverage, sw, m_ulIUnknownInprocOutTime[iIter] );
    }
    ReadAverage( m_fAverage, sw, m_ulIUnknownInprocOutTime[0], m_ulIterations );

    //
    //  interface passing tests
    //

#ifdef  NOTYET

    IStream *pIStm = NULL;
    sc = m_punkInproc->QueryInterface(IID_IStream, (void **)&pIStm);
    if (SUCCEEDED(sc) && pIStm)
    {
        ResetAverage( m_fAverage, sw );
        for (iIter=0; iIter<m_ulIterations; iIter++)
        {
	    ResetNotAverage( m_fAverage, sw );
            sc = m_pRPC->InterfaceIn(IID_IStream, pIStm);
            ReadNotAverage( m_fAverage, sw, m_ulInterfaceInprocInTime[iIter] );
        }
        ReadAverage( m_fAverage, sw, m_ulInterfaceInprocInTime[0], m_ulIterations );
        pIStm->Release();
    }

    pIStm = NULL;
    sc = m_punkLocal->QueryInterface(IID_IStream, (void **)&pIStm);
    if (SUCCEEDED(sc) && pIStm)
    {
        ResetAverage( m_fAverage, sw );
        for (iIter=0; iIter<m_ulIterations; iIter++)
        {
	    ResetNotAverage( m_fAverage, sw );
            sc = m_pRPC->InterfaceIn(IID_IStream, pIStm);
            ReadNotAverage( m_fAverage, sw, m_ulInterfaceLocalInTime[iIter] );
        }
        ReadAverage( m_fAverage, sw, m_ulInterfaceLocalInTime[0], m_ulIterations );
        pIStm->Release();
    }
#endif


    return S_OK;
}					



SCODE CRpcTest::Report (CTestOutput &output)
{
    if (m_fAverage)
    {
	output.WriteSectionHeader (Name(), TEXT("Object Rpc"), *m_pInput);

	output.WriteString (TEXT("\n"));
	output.WriteString (TEXT("Average times\n"));
	output.WriteString (TEXT("\n"));
	output.WriteResult (TEXT("Void         "), m_ulVoidTime[0]);
	output.WriteResult (TEXT("VoidRC       "), m_ulVoidRCTime[0]);

	output.WriteResult (TEXT("DwordIn      "), m_ulDwordInTime[0]);
	output.WriteResult (TEXT("DwordOut     "), m_ulDwordOutTime[0]);
	output.WriteResult (TEXT("DwordInOut   "), m_ulDwordInOutTime[0]);

	output.WriteResult (TEXT("StringIn     "), m_ulStringInTime[0]);
#ifdef STRINGOUT
	output.WriteResult (TEXT("StringOut    "), m_ulStringOutTime[0]);
#endif
	output.WriteResult (TEXT("StringInOut  "), m_ulStringInOutTime[0]);

	output.WriteResult (TEXT("GuidIn       "), m_ulGuidInTime[0]);
	output.WriteResult (TEXT("GuidOut      "), m_ulGuidOutTime[0]);

	output.WriteResult (TEXT("IUnknownIp   "), m_ulIUnknownInprocInTime[0]);
	output.WriteResult (TEXT("IUnknownLcl  "), m_ulIUnknownLocalInTime[0]);
	output.WriteResult (TEXT("IUnknownOut  "), m_ulIUnknownInprocOutTime[0]);
    //  output.WriteResult (TEXT("IUnknownKpIn "), m_ulIUnknownKeepInTime[0]);
    //  output.WriteResult (TEXT("IUnknownKpOut"), m_ulIUnknownKeepOutTime[0]);

#ifdef	NOTYET
	output.WriteResult (TEXT("InterfaceIn "), m_ulInterfaceInprocInTime[0]);
	output.WriteResult (TEXT("InterfaceLcl"), m_ulInterfaceLocalInTime[0]);
#endif
    }
    else
    {
	output.WriteSectionHeader (Name(), TEXT("Object Rpc"), *m_pInput);
	output.WriteString (TEXT("\n"));

	output.WriteResults (TEXT("Void         "), m_ulIterations, m_ulVoidTime);
	output.WriteResults (TEXT("VoidRC       "), m_ulIterations, m_ulVoidRCTime);

	output.WriteResults (TEXT("DwordIn      "), m_ulIterations, m_ulDwordInTime);
	output.WriteResults (TEXT("DwordOut     "), m_ulIterations, m_ulDwordOutTime);
	output.WriteResults (TEXT("DwordInOut   "), m_ulIterations, m_ulDwordInOutTime);

	output.WriteResults (TEXT("StringIn     "), m_ulIterations, m_ulStringInTime);
#ifdef STRINGOUT
	output.WriteResults (TEXT("StringOut    "), m_ulIterations, m_ulStringOutTime);
#endif
	output.WriteResults (TEXT("StringInOut  "), m_ulIterations, m_ulStringInOutTime);

	output.WriteResults (TEXT("GuidIn       "), m_ulIterations, m_ulGuidInTime);
	output.WriteResults (TEXT("GuidOut      "), m_ulIterations, m_ulGuidOutTime);

	output.WriteResults (TEXT("IUnknownIp   "), m_ulIterations, m_ulIUnknownInprocInTime);
	output.WriteResults (TEXT("IUnknownLcl  "), m_ulIterations, m_ulIUnknownLocalInTime);
	output.WriteResults (TEXT("IUnknownOut  "), m_ulIterations, m_ulIUnknownInprocOutTime);
    //  output.WriteResults (TEXT("IUnknownKpIn "), m_ulIterations, m_ulIUnknownKeepInTime);
    //  output.WriteResults (TEXT("IUnknownKpOut"), m_ulIterations, m_ulIUnknownKeepOutTime);

#ifdef	NOTYET
	output.WriteResults (TEXT("InterfaceIn "), m_ulIterations, m_ulInterfaceInprocInTime);
	output.WriteResults (TEXT("InterfaceLcl"), m_ulIterations, m_ulInterfaceLocalInTime);
#endif
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_rpc2.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_rpc2.cxx
//
//  Contents:	ORPC Method Invocation tests
//
//  Classes:	CRpcTest22
//
//  History:	08-08-95    Rickhi  Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_rpc2.hxx>
#include <stream.hxx>
#include <oletest.hxx>
#include <tracelog.hxx>
#include <cqi.hxx>


TCHAR *CRpcTest2::Name ()
{
    return TEXT("RpcTest2");
}


SCODE CRpcTest2::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);

    SCODE sc = pInput->GetGUID(&m_ClsID, Name(), TEXT("Clsid_Local"));
    if (FAILED(sc))
    {
	Log (TEXT("Setup - GetClassID failed."), sc);
	return sc;
    }

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    //	initialize timing arrays
    INIT_RESULTS(m_ulNULLTime);

    INIT_RESULTS(m_ulIUnknownBestInTime);
    INIT_RESULTS(m_ulIUnknownWorstInTime);

    INIT_RESULTS(m_ulIUnknownBestOutTime);
    INIT_RESULTS(m_ulIUnknownWorstOutTime);


    m_pRPC = NULL;
    m_pStm = NULL;

    // get the stream of data to unmarshal from the file.
    TCHAR	szFile[MAX_PATH];
    pInput->GetConfigString(Name(), TEXT("File"), TEXT(" "),
			    szFile, sizeof(szFile)/sizeof(TCHAR));

    if (!wcscmp(szFile,L" "))
    {
	sc = E_INVALIDARG;
	Log (TEXT("Setup - Get FileName failed."), sc);
	return sc;
    }

    // now make a stream on file
    m_pStm = (IStream *) new CStreamOnFile(szFile, sc, TRUE);

    if (FAILED(sc))
    {
	Log (TEXT("Setup - new CStreamOnFile failed."), sc);
	return sc;
    }

    m_punkInproc = (IUnknown *) new CQI(CLSID_QI);

    return S_OK;
}


SCODE CRpcTest2::Cleanup ()
{
    if (m_pRPC)
	m_pRPC->Release();

    if (m_punkInproc)
	m_punkInproc->Release();

    return S_OK;
}

SCODE CRpcTest2::PrepareForRun()
{
    SCODE sc = InitCOM();

    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
	return	sc;
    }

    // get the interface to call on

    // reset the stream to the beginning
    LARGE_INTEGER libMove;
    LISet32(libMove, 0x00000000);
    m_pStm->Seek(libMove, STREAM_SEEK_SET, NULL);

    // unmarshal the interface
    sc = CoUnmarshalInterface(m_pStm, IID_IRpcTest, (void **)&m_pRPC);

    if (FAILED(sc))
    {
	Log (TEXT("PrepareForRun - CoUnmarshalInteface failed."), sc);
	UninitCOM();
    }

    Sleep(500);
    return sc;
}

void CRpcTest2::CleanupFromRun()
{
    if (m_pRPC)
    {
	m_pRPC->Release();
	m_pRPC = NULL;
    }

    UninitCOM();

    Sleep(500);
}


SCODE CRpcTest2::Run ()
{
    CStopWatch  sw;
    SCODE       sc;
    ULONG       iIter;

    //
    // NULL call tests
    //

    if (FAILED(sc = PrepareForRun()))
    {
	return sc;
    }

    Sleep(2000);

    for (iIter=0; iIter<TEST_MAX_ITERATIONS_PRIVATE; iIter++)
    {
	sw.Reset();
        m_pRPC->Void();
	m_ulNULLTime[iIter] = sw.Read();
    }

    CleanupFromRun();




    //
    //	IUnknown [in] Best Case - The other side already has
    //	the interface we are passing in.
    //

    if (FAILED(sc = PrepareForRun()))
    {
	return sc;
    }

    // give the other side the interface to keep
    sc = m_pRPC->IUnknownInKeep(m_punkInproc);


    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	sw.Reset();
        sc = m_pRPC->IUnknownIn(m_punkInproc);
	m_ulIUnknownBestInTime[iIter] = sw.Read();
    }

    sc = m_pRPC->IUnknownInRelease();

    CleanupFromRun();





    //
    //	IUnknown [out] Best Case - We already have the interface being
    //	passed back to us.
    //

    if (FAILED(sc = PrepareForRun()))
    {
	return sc;
    }

    // get the interface from the other side, and hang onto it.
    IUnknown *punkOut = NULL;
    sc = m_pRPC->IUnknownOut(&punkOut);


    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	IUnknown *punkOut2 = NULL;

	sw.Reset();
	sc = m_pRPC->IUnknownOut(&punkOut2);
	m_ulIUnknownBestOutTime[iIter] = sw.Read();

	if (SUCCEEDED(sc))
	{
	    // release 1 reference
	    punkOut2->Release();
	}
    }

    // release the ptr we are holding, should be final release.
    punkOut->Release();

    CleanupFromRun();





    //
    //	IUnknown [in] Worst Case - the other side does not have
    //	the interface we are passing in, nor have we ever marshaled
    //	an interface before in this process. The other side does not
    //	keep the interface we hand it.	We loop several times, each time
    //	we do OleInit, OleUninit.
    //

    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	if (FAILED(sc = PrepareForRun()))
	{
	    return sc;
	}

	sw.Reset();
	sc = m_pRPC->IUnknownIn(m_punkInproc);
	m_ulIUnknownWorstInTime[iIter] = sw.Read();

	CleanupFromRun();
    }





    //
    //	IUnknown [out] Worst Case - the other side is giving us a brand
    //	new object, that it has never marshaled before. We do not hold onto
    //	the interface.	We loop several times, each time
    //	we do OleInit, OleUninit.
    //

    for (iIter=0; iIter<m_ulIterations; iIter++)
    {
	if (FAILED(sc = PrepareForRun()))
	{
	    return sc;
	}

	sw.Reset();

	// BUGBUG sc = m_pRPC->IUnknownNewOut(&punkOut);
	sc = m_pRPC->IUnknownOut(&punkOut);

	m_ulIUnknownWorstOutTime[iIter] = sw.Read();

	if (SUCCEEDED(sc))
	{
	    punkOut->Release();
	}

	CleanupFromRun();
    }

    return S_OK;
}					


SCODE CRpcTest2::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("Object Rpc2"), *m_pInput);

    output.WriteString(TEXT("\n"));

    output.WriteResults(TEXT("NULL              "), TEST_MAX_ITERATIONS_PRIVATE, m_ulNULLTime);
    output.WriteResults(TEXT("IUnknown In  Best "), m_ulIterations, m_ulIUnknownBestInTime);
    output.WriteResults(TEXT("IUnknown In  Worst"), m_ulIterations, m_ulIUnknownWorstInTime);
    output.WriteResults(TEXT("IUnknown Out Best "), m_ulIterations, m_ulIUnknownBestOutTime);
    output.WriteResults(TEXT("IUnknown Out Worst"), m_ulIterations, m_ulIUnknownWorstOutTime);

    return S_OK;
}
	
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	headers.cxx
//
//  Contents:	remote2/new precompiled headers
//
//  Classes:	
//
//  Functions:	
//
//  History:	24-Aug-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include <benchmrk.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\rawrpc_c.c ===
#include <string.h>
#include <limits.h>
#include <rpc.h>

#include "rawrpc.h"
static handle_t AutoBindHandle;
extern RPC_DISPATCH_TABLE IRawRpc_DispatchTable;

static RPC_CLIENT_INTERFACE ___RpcClientInterface =  {
  sizeof(RPC_CLIENT_INTERFACE),
  {{0x00000145,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}},
  {0,0}},
    {
    {0x8A885D04L,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},
    {2,0}
    }
  ,
  0,0,0,
  0
  }
;
RPC_IF_HANDLE IRawRpc_ClientIfHandle = (RPC_IF_HANDLE) &___RpcClientInterface;
SCODE Quit(
	handle_t hRpc)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 0 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
void Void(
	handle_t hRpc)
  {
  unsigned char * _packet;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 1 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _status = I_RpcFreeBuffer(&_message);
  if (_status) RpcRaiseException(_status);

  }
SCODE VoidRC(
	handle_t hRpc)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 2 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE VoidPtrIn(
	handle_t hRpc,
	ULONG cb,
	void *pv)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _length ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 8;
  if (pv ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
  _prpcmsg->BufferLength += 4;
  _prpcmsg->BufferLength += (unsigned int)(cb);
  _message.ProcNum = ( 3 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _length = _prpcmsg->BufferLength;
  _prpcmsg->BufferLength = 0;
  /* send data from cb */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)cb;
  // send total number of elements
  *(*(long **)&_prpcmsg->Buffer)++ = cb;
  /* send data from pv */
  NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) ((unsigned char *)pv+0), (unsigned int)(cb));
  *(unsigned long *)&_prpcmsg->Buffer += cb;
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE VoidPtrOut(
	handle_t hRpc,
	ULONG cb,
	ULONG *pcb,
	void *pv)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned long _valid_lower;
  unsigned long _valid_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _valid_total ));
  ((void)( _valid_lower ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 4;
  _message.ProcNum = ( 4 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  /* send data from cb */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)cb;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pcb ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    /* receive data into pcb */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)pcb);
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pv ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    // recv total number of elements
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
    // recv valid range
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_valid_lower);
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_valid_total);
    byte_array_from_ndr ((PRPC_MESSAGE)_prpcmsg, _valid_lower, _valid_lower + _valid_total, pv);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE DwordIn(
	handle_t hRpc,
	DWORD dw)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 4;
  _message.ProcNum = ( 5 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  /* send data from dw */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)dw;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE DwordOut(
	handle_t hRpc,
	DWORD *pdw)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 6 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pdw ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    /* receive data into pdw */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)pdw);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE DwordInOut(
	handle_t hRpc,
	DWORD *pdw)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _length ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 4;
  _message.ProcNum = ( 7 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _length = _prpcmsg->BufferLength;
  _prpcmsg->BufferLength = 0;
  /* send data from *pdw */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)*pdw;
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pdw ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    /* receive data into pdw */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)pdw);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE LiIn(
	handle_t hRpc,
	LARGE_INTEGER li)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 8;
  _message.ProcNum = ( 8 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  /* send data from &li */
  NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&li), (unsigned int)(8));
  *(unsigned long *)&_prpcmsg->Buffer += 8;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE LiOut(
	handle_t hRpc,
	LARGE_INTEGER *pli)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 9 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pli ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (pli), "4ll", 8);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE ULiIn(
	handle_t hRpc,
	ULARGE_INTEGER uli)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 8;
  _message.ProcNum = ( 10 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  /* send data from &uli */
  NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&uli), (unsigned int)(8));
  *(unsigned long *)&_prpcmsg->Buffer += 8;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE ULiOut(
	handle_t hRpc,
	ULARGE_INTEGER *puli)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 11 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (puli ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (puli), "4ll", 8);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE StringIn(
	handle_t hRpc,
	LPWSTR pwsz)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _length ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  if (pwsz ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
  tree_size_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
  _message.ProcNum = ( 12 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _length = _prpcmsg->BufferLength;
  _prpcmsg->BufferLength = 0;
  tree_into_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE StringOut(
	handle_t hRpc,
	LPWSTR *ppwsz)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned long _valid_lower;
  unsigned long _valid_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _valid_total ));
  ((void)( _valid_lower ));
  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 13 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    _treebuf = 0;
    if (ppwsz ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    *(unsigned long *)&_prpcmsg->Buffer += 3;
    *(unsigned long *)&_prpcmsg->Buffer &= 0xfffffffc;
    if (*(*(unsigned long **)&_prpcmsg->Buffer)++)
      {
      // recv total number of elements
      long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
      if ((*ppwsz) ==0)
        {
        (*ppwsz) = (WCHAR *)MIDL_user_allocate ((size_t)(_alloc_total * sizeof(WCHAR)));
        }
      data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) ((*ppwsz)), "s2", 1);
      }
    else
      {
      (*ppwsz) = 0;
      }
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE StringInOut(
	handle_t hRpc,
	LPWSTR pwsz)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned long _valid_lower;
  unsigned long _valid_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _valid_total ));
  ((void)( _valid_lower ));
  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  if (pwsz ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
  tree_size_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
  _message.ProcNum = ( 14 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _length = _prpcmsg->BufferLength;
  _prpcmsg->BufferLength = 0;
  tree_into_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    _treebuf = 0;
    if (pwsz ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    // recv total number of elements
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (pwsz), "s2", 1);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE GuidIn(
	handle_t hRpc,
	GUID guid)
  {
  SCODE _ret_value;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 16;
  _message.ProcNum = ( 15 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  /* send data from &guid */
  NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&guid), (unsigned int)(16));
  *(unsigned long *)&_prpcmsg->Buffer += 16;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
SCODE GuidOut(
	handle_t hRpc,
	GUID *pguid)
  {
  SCODE _ret_value;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  RPC_STATUS _status;
  RPC_MESSAGE _message;
  PRPC_MESSAGE _prpcmsg = & _message;

  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  _message.Handle = hRpc;
  _message.RpcInterfaceInformation = (void __RPC_FAR *) &___RpcClientInterface;
  _prpcmsg->BufferLength = 0;
  _message.ProcNum = ( 16 );
  _message.RpcFlags = ( 0 );
  _status = I_RpcGetBuffer(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcSendReceive(&_message);
  if (_status) RpcRaiseException(_status);
  _packet = _message.Buffer;
  RpcTryFinally
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    if (pguid ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    _gns__GUID ((GUID *)pguid, (PRPC_MESSAGE)_prpcmsg);
    /* receive data into &_ret_value */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_ret_value);
    }
  RpcFinally
    {
    _message.Buffer = _packet;
    _status = I_RpcFreeBuffer(&_message);
    if (_status) RpcRaiseException(_status);
    }
  RpcEndFinally

	return (_ret_value);
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_rrpc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_rrpc.cxx
//
//  Contents:	Raw Rpc function call tests
//
//  Classes:	CRawRpc
//
//  History:	1-Jul-93    t-martig	Created
//		2-Feb-94    rickhi	Modified from above for Raw Rpc
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <bm_rrpc.hxx>


HRESULT StartServer(BOOL _fDebug, LPTSTR _pszPath);


extern "C" const GUID IID_IRawRpc;


TCHAR *CRawRpc::Name ()
{
	return TEXT("RawRpc");
}


SCODE CRawRpc::Setup (CTestInput *pInput)
{
	CTestBase::Setup(pInput);

	// get flag indicating whether to keep all values or
	// only average values.
	TCHAR	szAverage[5];
	pInput->GetConfigString(Name(), TEXT("Average"), TEXT("Y"),
                            szAverage, sizeof(szAverage)/sizeof(TCHAR));
        if (szAverage[0] == 'n' || szAverage[0] == 'N')
	    m_fAverage = FALSE;
	else
	    m_fAverage = TRUE;

	//  get iteration count
	if (m_fAverage)
	    m_ulIterations = pInput->GetRealIterations(Name());
	else
	    m_ulIterations = pInput->GetIterations(Name());
	m_pszStringBinding	 = NULL;
	m_hRpc			 = NULL;

	//  initialize timing arrays
	INIT_RESULTS(m_ulVoidTime);
	INIT_RESULTS(m_ulVoidRCTime);

	INIT_RESULTS(m_ulDwordInTime);
	INIT_RESULTS(m_ulDwordOutTime);
	INIT_RESULTS(m_ulDwordInOutTime);

	INIT_RESULTS(m_ulStringInTime);
	INIT_RESULTS(m_ulStringOutTime);
	INIT_RESULTS(m_ulStringInOutTime);

	INIT_RESULTS(m_ulGuidInTime);
	INIT_RESULTS(m_ulGuidOutTime);



	//  get the server exe name and debug flag out of the ini file, then
	//  start the server and wait for it.

	TCHAR	szServer[15];
	pInput->GetConfigString(Name(), TEXT("Server"), TEXT("rawrpc.exe"),
                            szServer, sizeof(szServer)/sizeof(TCHAR));

	//  get input
	TCHAR	szValue[40];

	pInput->GetConfigString(Name(), TEXT("Debug"), TEXT("N"),
                            szValue, sizeof(szValue)/sizeof(TCHAR));

	BOOL fDebug = !lstrcmpi(szValue, TEXT("Y"));

	DWORD dwTimeout = pInput->GetConfigInt(Name(), TEXT("Timeout"), 60000);

	HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE,
                                    TEXT("OleBenchRawRpcServerStarted"));
	if (NULL == hEvent)
	{
	    Log (TEXT("Setup - Event Creation failed."), GetLastError());
	    return E_FAIL;
	}

	//  start the server application and wait for it.
	HRESULT sc = StartServer(fDebug, szServer);

	if (FAILED(sc))
	{
	    Log (TEXT("Setup - Start Server failed."), sc);
            CloseHandle(hEvent);
	    return sc;
	}


	if (WAIT_OBJECT_0 != WaitForSingleObject(hEvent, dwTimeout))
	{
    	    Log (TEXT("Setup - Server never signaled."), GetLastError());
            CloseHandle(hEvent);
    	    return E_FAIL;
	}
	CloseHandle(hEvent);

	//  bind to the server application
	TCHAR	szProtseq[20];
	TCHAR	szNetworkAddr[20];

	pInput->GetConfigString(Name(), TEXT("Protseq"),
#ifdef USE_MSWMSG
                            TEXT("mswmsg"),
#else
                            TEXT("ncalrpc"),
#endif
                            szProtseq, 20);

	pInput->GetConfigString(Name(), TEXT("NetworkAddr"), TEXT(""),
                            szNetworkAddr, 20);

	LPTSTR pszEndPoint	 = TEXT("99999.99999");
	RPC_STATUS rc;

#ifdef UNICODE
	rc = RpcStringBindingCompose(NULL,
				     szProtseq,
				     szNetworkAddr,
				     pszEndPoint,
				     NULL,
				     &m_pszStringBinding);
#else
    //
    // Can't just use TCHAR here because RpcString*() take unsigned
    // chars
    //
	rc = RpcStringBindingCompose(NULL,
				     (unsigned char *)szProtseq,
				     (unsigned char *)szNetworkAddr,
				     (unsigned char *)pszEndPoint,
				     NULL,
				     (unsigned char **)&m_pszStringBinding);
#endif
	if (rc != S_OK)
	{
	    Log(TEXT("Setup - RpcStringBindingCompose failed."), rc);
	    return rc;
	}

#ifdef UNICODE
	rc = RpcBindingFromStringBinding(m_pszStringBinding, &m_hRpc);
#else
	rc = RpcBindingFromStringBinding((unsigned char *)m_pszStringBinding,
                    &m_hRpc);
#endif

	if (rc != S_OK)
	{
	    Log(TEXT("Setup - RpcBindingFromStringBinding failed."), rc);
	    return rc;
	}

	//  all done.
	return S_OK;
}


SCODE CRawRpc::Cleanup ()
{
	if (m_hRpc)
	{
	    RpcBindingFree(&m_hRpc);
	}

	if (m_pszStringBinding)
	{
#ifdef UNICODE
	    RpcStringFree(&m_pszStringBinding);
#else
	    RpcStringFree((unsigned char **)&m_pszStringBinding);
#endif
	}

	return S_OK;
}


SCODE CRawRpc::Run ()
{
	CStopWatch  sw;
	SCODE	    sc;
	ULONG       iIter;

	//
	// void passing tests
	//

	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    Void(m_hRpc);
	    ReadNotAverage( m_fAverage, sw, m_ulVoidTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulVoidTime[0], m_ulIterations );

	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc = VoidRC(m_hRpc);
	    ReadNotAverage( m_fAverage, sw, m_ulVoidRCTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulVoidRCTime[0], m_ulIterations );

	//
	//  dword passing tests
	//

	DWORD dwTmp = 1;
	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  DwordIn(m_hRpc, dwTmp);
	    ReadNotAverage( m_fAverage, sw, m_ulDwordInTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulDwordInTime[0], m_ulIterations );

	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  DwordOut(m_hRpc, &dwTmp);
	    ReadNotAverage( m_fAverage, sw, m_ulDwordOutTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulDwordOutTime[0], m_ulIterations );

	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  DwordInOut(m_hRpc, &dwTmp);
	    ReadNotAverage( m_fAverage, sw, m_ulDwordInOutTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulDwordInOutTime[0], m_ulIterations );

	//
	//  string passing tests
	//

	WCHAR szHello[] = L"C:\\FOOFOO\\FOOBAR\\FOOBAK\\FOOBAZ\\FOOTYPICAL\\PATH\\HELLO";
	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  StringIn(m_hRpc, szHello);
	    ReadNotAverage( m_fAverage, sw, m_ulStringInTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulStringInTime[0], m_ulIterations );

	LPWSTR pwszOut = NULL;
#ifdef STRINGOUT
	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    pwszOut = NULL;
	    sc =  StringOut(m_hRpc, &pwszOut);
	    ReadNotAverage( m_fAverage, sw, m_ulStringOutTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulStringOutTime[0], m_ulIterations );
#endif
	pwszOut = szHello;
	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  StringInOut(m_hRpc, pwszOut);
	    ReadNotAverage( m_fAverage, sw, m_ulStringInOutTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulStringInOutTime[0], m_ulIterations );


	//
	//  guid passing tests
	//

	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  GuidIn(m_hRpc, IID_IRawRpc);
	    ReadNotAverage( m_fAverage, sw, m_ulGuidInTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulGuidInTime[0], m_ulIterations );

	GUID	guid;
	ResetAverage( m_fAverage, sw );
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    ResetNotAverage( m_fAverage, sw );
	    sc =  GuidOut(m_hRpc, &guid);
	    ReadNotAverage( m_fAverage, sw, m_ulGuidOutTime[iIter] );
	}
	ReadAverage( m_fAverage, sw, m_ulGuidOutTime[0], m_ulIterations );

	//  tell the server to quit.
	sc = Quit(m_hRpc);

	return S_OK;
}					



SCODE CRawRpc::Report (CTestOutput &output)
{
    output.WriteSectionHeader (Name(), TEXT("Raw Rpc"), *m_pInput);

    if (m_fAverage)
    {
	output.WriteString (TEXT("\n"));
	output.WriteString (TEXT("Average Times\n"));
	output.WriteString (TEXT("\n"));
	output.WriteResult (TEXT("Void         "), m_ulVoidTime[0]);
	output.WriteResult (TEXT("VoidRC       "), m_ulVoidRCTime[0]);

	output.WriteResult (TEXT("DwordIn      "), m_ulDwordInTime[0]);
	output.WriteResult (TEXT("DwordOut     "), m_ulDwordOutTime[0]);
	output.WriteResult (TEXT("DwordInOut   "), m_ulDwordInOutTime[0]);

	output.WriteResult (TEXT("StringIn     "), m_ulStringInTime[0]);
#ifdef STRINGOUT
	output.WriteResult (TEXT("StringOut    "), m_ulStringOutTime[0]);
#endif
	output.WriteResult (TEXT("StringInOut  "), m_ulStringInOutTime[0]);

	output.WriteResult (TEXT("GuidIn       "), m_ulGuidInTime[0]);
	output.WriteResult (TEXT("GuidOut      "), m_ulGuidOutTime[0]);

    }
    else
    {

	output.WriteString (TEXT("\n"));
	output.WriteResults (TEXT("Void         "), m_ulIterations, m_ulVoidTime);
	output.WriteResults (TEXT("VoidRC       "), m_ulIterations, m_ulVoidRCTime);

	output.WriteResults (TEXT("DwordIn      "), m_ulIterations, m_ulDwordInTime);
	output.WriteResults (TEXT("DwordOut     "), m_ulIterations, m_ulDwordOutTime);
	output.WriteResults (TEXT("DwordInOut   "), m_ulIterations, m_ulDwordInOutTime);

	output.WriteResults (TEXT("StringIn     "), m_ulIterations, m_ulStringInTime);
#ifdef STRINGOUT
	output.WriteResults (TEXT("StringOut    "), m_ulIterations, m_ulStringOutTime);
#endif
	output.WriteResults (TEXT("StringInOut  "), m_ulIterations, m_ulStringInOutTime);

	output.WriteResults (TEXT("GuidIn       "), m_ulIterations, m_ulGuidInTime);
	output.WriteResults (TEXT("GuidOut      "), m_ulIterations, m_ulGuidOutTime);
    }

    return S_OK;
}
	
	



//+-------------------------------------------------------------------------
//
//  Function:	StartServer
//
//  Synopsis:	Start an Rpc server process
//
//  Arguments:	[_fDebug] - start in a debugger or not
//		[_pwszPath] - name of server process
//
//  Returns:	S_OK - Server started
//		S_FALSE - server is already starting
//		CO_E_SERVER_EXEC_FAILURE
//
//  Algorithm:
//
//  History:	21-Apr-93 Ricksa    Created
//		04-Jan-94 Ricksa    Modified for class starting sync.
//
//--------------------------------------------------------------------------
HRESULT StartServer(BOOL _fDebug, LPTSTR _pszPath)
{
    // Where we put the command line
    TCHAR aszTmpCmdLine[MAX_PATH];
    TCHAR *pszTmpCmdLine = aszTmpCmdLine;

    if (_fDebug)
    {
	HKEY  hKey;
	DWORD dwType;
	DWORD cbData = sizeof(aszTmpCmdLine)/sizeof(TCHAR);

	ULONG rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
				TEXT("SOFTWARE\\Microsoft\\scm"),
				0,
				KEY_READ,
				&hKey);

	if (rc == ERROR_SUCCESS)
	{
	    //	copy the debugger info into the command line

	    rc = RegQueryValueEx(hKey, TEXT("Debugger"), 0, &dwType,
				(LPBYTE)pszTmpCmdLine, &cbData);

	    if (rc == ERROR_SUCCESS && dwType == REG_SZ)
	    {
		ULONG ulLen = cbData / sizeof(TCHAR);
		pszTmpCmdLine += ulLen;
		aszTmpCmdLine[ulLen-1] = TEXT(' ');	// whitespace
	    }

	    RegCloseKey(hKey);
	}
    }

#ifdef NOTYET	// following code does not compile!
 #ifndef CAIROLE_DOWNLEVEL
    if (acWinFormat[0] == 0)
    {
	TCHAR acWinDir[MAX_PATH];

	UINT cWinDir = GetSystemDirectory(acWinDir, sizeof(acWinDir)/sizeof(TCHAR));

	Win4Assert(cWinDir && "GetWindowsDir failed!");

	wsprintf(acWinFormat, TEXT("%s%s"), acWinDir, TEXT("\\%s %s"));
    }


    // We make all paths relative to the windows directory unless
    // the path is absolute.
    wsprintf(pszTmpCmdLine,
            (_pszPath[1] != TEXT(':')) ? acWinFormat : TEXT("%s %s"),
             _pwszPath,
            TEXT("-Embedding"));
#else
#endif // CAIROLE_DOWNLEVEL

#endif // NOTYET

    // Just use the current path to find the server.
    wsprintf(pszTmpCmdLine, TEXT("%s %s"), _pszPath, TEXT("-Embedding"));

    // Process info for create process
    PROCESS_INFORMATION     procinfo;

    //	build the win32 startup info structure
    STARTUPINFO startupinfo;
    startupinfo.cb = sizeof(STARTUPINFO);
    startupinfo.lpReserved = NULL;
    startupinfo.lpDesktop = NULL;
    startupinfo.lpTitle = _pszPath;
    startupinfo.dwX = 40;
    startupinfo.dwY = 40;
    startupinfo.dwXSize = 80;
    startupinfo.dwYSize = 40;
    startupinfo.dwFlags = 0;
    startupinfo.wShowWindow = SW_SHOWNORMAL;
    startupinfo.cbReserved2 = 0;
    startupinfo.lpReserved2 = NULL;

    if (!CreateProcess( NULL,		// application name
		       aszTmpCmdLine,	// command line
		       NULL,		// process sec attributes
		       NULL,		// thread sec attributes
		       FALSE,		// dont inherit handles
		       CREATE_NEW_CONSOLE,// creation flags
		       NULL,		// use same enviroment block
		       NULL,		// use same directory
		       &startupinfo,	// no startup info
		       &procinfo))	// proc info returned
    {
	return CO_E_SERVER_EXEC_FAILURE;
    }

    CloseHandle(procinfo.hProcess);
    CloseHandle(procinfo.hThread);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_sbind.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_sbind.cxx
//
//  Contents:	Ole moniker binding test (BindToObject)
//
//  Classes:	CFileMonikerStorageBindTest
//
//  History:    9-July-93 t-martig    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_sbind.hxx>


TCHAR *CFileMonikerStorageBindTest::Name ()
{
	return TEXT("BindToStorage");
}


SCODE CFileMonikerStorageBindTest::Setup (CTestInput *pInput)
{
	IClassFactory	*pICF = NULL;
	IStorage	*pStg = NULL;
	IPersistStorage *pIPS = NULL;
	SCODE		 sc;

	CTestBase::Setup(pInput);

	// get the iteration count from the ini file
	m_ulIterations = pInput->GetIterations(Name());

	//  for each class ctx, get the classid, and init internal state
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    // Get ClsID for this Ctx from the .ini file
	    sc = pInput->GetGUID(&m_ClsID[iCtx], Name(), apszClsIDName[iCtx]);
	    if (FAILED(sc))
	    {
		Log (TEXT("Setup - GetClassID failed."), sc);
		return sc;
	    }

	    INIT_RESULTS(m_ulCreateMkrTime[iCtx]);
	    INIT_RESULTS(m_ulCreateBndCtxTime[iCtx]);
	    INIT_RESULTS(m_ulBindTime[iCtx]);
	}

	sc = InitCOM();
	if (FAILED(sc))
	{
	    Log (TEXT("Setup - CoInitialize failed."), sc);
	    return	sc;
	}

	//  for each class ctx, create a persistent instance on disk
	for (iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    // Create an instance
	    sc = CoGetClassObject(m_ClsID[iCtx], dwaClsCtx[iCtx], NULL,
				  IID_IClassFactory, (void **)&pICF);
	    if (SUCCEEDED(sc))
	    {
		sc = pICF->CreateInstance(NULL, IID_IPersistStorage,
					  (void **)&pIPS);
		pICF->Release();
		if (SUCCEEDED(sc))
		{
		    // create instance of the storage
		    sc = StgCreateDocfile(apszPerstName[iCtx],
					  STGM_READWRITE | STGM_CREATE |
					  STGM_SHARE_EXCLUSIVE,
					  0, &pStg);
		    if (SUCCEEDED(sc))
		    {
			//	save the class instance in the storage
			sc = pIPS->Save(pStg, FALSE);
			pStg->Release();

			if (FAILED(sc))
			{
			    Log (TEXT("Setup - pIPS->Save failed."), sc);
			}
		    }
		    else
		    {
			Log (TEXT("Setup - StgCreateDocfile failed."), sc);
		    }

		    pIPS->Release();
		}
		else
		{
		    Log (TEXT("Setup - CreateInstance failed"), sc);
		}
	    }
	    else
	    {
		Log (TEXT("Setup - CoGetClassObject failed"), sc);
	    }
	}

	return S_OK;
}


SCODE CFileMonikerStorageBindTest::Cleanup ()
{
	UninitCOM();

	CHAR	szPerstName[80];

	//  delete the persistent instances
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	delete original
	    wcstombs(szPerstName, apszPerstName[iCtx],
		     wcslen(apszPerstName[iCtx])+1);
	    _unlink(szPerstName);
	}

	return S_OK;
}


SCODE CFileMonikerStorageBindTest::Run ()
{
	CStopWatch  sw;
	IMoniker   *pmk  = NULL;
	IBindCtx   *pbc  = NULL;
	IStorage   *pStg = NULL;
	SCODE	    sc;

	//  for each class context
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    //	for each iteration
	    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
	    {
		sw.Reset();
		sc = CreateFileMoniker (apszPerstName[iCtx], &pmk);
		m_ulCreateMkrTime[iCtx][iIter] = sw.Read();

		if (!Log (TEXT("CreateFileMoniker"), sc))
		{
		    BIND_OPTS	bindopts;
		    bindopts.cbStruct = sizeof(BIND_OPTS);

		    sw.Reset();
		    sc = CreateBindCtx(0, &pbc);
		    if (SUCCEEDED(sc))
		    {
			sc = pbc->GetBindOptions(&bindopts);
			bindopts.grfMode |= STGM_SHARE_EXCLUSIVE | STGM_DIRECT;
			sc = pbc->SetBindOptions(&bindopts);
		    }
		    m_ulCreateBndCtxTime[iCtx][iIter] = sw.Read();

		    if (!Log (TEXT("CreateBindCtx"), sc))
		    {
			sw.Reset();
			sc = pmk->BindToStorage(pbc, NULL, IID_IStorage, (void**)&pStg);
			m_ulBindTime[iCtx][iIter]=sw.Read();

			if (!Log (TEXT("BindToStorage"), sc))
			{
			    sw.Reset();
			    pStg->Release();
			    m_ulReleaseTime[iCtx][iIter]=sw.Read();
			}
			else
			{
			    m_ulBindTime[iCtx][iIter] = NOTAVAIL;
			}

			pbc->Release();
		    }
		    else
		    {
			m_ulCreateBndCtxTime[iCtx][iIter] = NOTAVAIL;
		    }

		    pmk->Release();
		}
		else
		{
		    m_ulCreateMkrTime[iCtx][iIter] = NOTAVAIL;
		}
	    }
	}

	return S_OK;
}		



SCODE CFileMonikerStorageBindTest::Report (CTestOutput &output)
{
	output.WriteSectionHeader (Name(), TEXT("BindToStorage via FileMoniker"), *m_pInput);

	//  for each clsctx, write the results
	for (ULONG iCtx=0; iCtx<CNT_CLSCTX; iCtx++)
	{
	    output.WriteString(TEXT("\n"));
	    output.WriteClassID(&m_ClsID[iCtx]);
	    output.WriteString(apszClsCtx[iCtx]);
	    output.WriteString(TEXT("\n"));

	    output.WriteResults(TEXT("CreateMoniker"), m_ulIterations, m_ulCreateMkrTime[iCtx]);
	    output.WriteResults(TEXT("CreateBindCtx"), m_ulIterations, m_ulCreateBndCtxTime[iCtx]);
	    output.WriteResults(TEXT("Bind         "), m_ulIterations, m_ulBindTime[iCtx]);
	    output.WriteResults(TEXT("Release      "), m_ulIterations, m_ulReleaseTime[iCtx]);
	}

	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\bm_stg.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//					
//  File:	bm_stg.cxx
//
//  Contents:	Basic Storage test
//
//  Classes:	CStorageTest
//
//  History:    7-June-94 t-vadims    Created
//
//--------------------------------------------------------------------------
#include <headers.cxx>
#pragma hdrstop

#include <bm_stg.hxx>

#define DEF_DATASIZE    16384

//#define TIME_FILEIO	// define this macro to do timing of ole32.dll internal file io
			// requires special ole32.dll

#ifdef TIME_FILEIO
#include <extimeio.hxx>
#endif

TCHAR *CStorageTest::Name ()
{
    return TEXT("StorageTest");
}


SCODE CStorageTest::Setup (CTestInput *pInput)
{
    SCODE sc;
    TCHAR pszValue[16];
    ULONG i;

    CTestBase::Setup(pInput);

    //	get iteration count
    m_ulIterations = pInput->GetIterations(Name());

    sc = InitCOM();
    if (FAILED(sc))
    {
	Log (TEXT("Setup - CoInitialize failed."), sc);
        return	sc;
    }

    // get malloc interface for this task
    m_piMalloc = NULL;
    sc = CoGetMalloc(MEMCTX_TASK, &m_piMalloc);
    if (FAILED(sc))
    {
    	Log (TEXT("Setup - CoGetMalloc"), sc);
	Cleanup();
    	return sc;
    }

    // get values of various paremeters from ini file

    m_iStartSize = pInput->GetConfigInt(Name(), TEXT("StartSize"), 16);
    if(m_iStartSize <= 0)
    	m_iStartSize = 16;

    m_iEndSize = pInput->GetConfigInt(Name(), TEXT("EndSize"), DEF_DATASIZE);

    // initialize array to be written to the file.
    m_pbData = (BYTE *)m_piMalloc->Alloc(m_iEndSize);
    if(m_pbData == NULL)
    {
    	Log (TEXT("Setup - Cannot allocate memory"), E_OUTOFMEMORY);
	Cleanup();
	return E_OUTOFMEMORY;
    }

    for (i=0; i < m_iEndSize; i++)
        m_pbData[i] = (BYTE)i;


    m_iRepeatFactor = pInput->GetConfigInt(Name(), TEXT("RepeatFactor"), 1);

    if (m_iRepeatFactor > MAX_REPS)
    	m_iRepeatFactor = MAX_REPS;

    // Figure out how many different sizes we're going to write.
    // and the size of the final file.
    m_ulTotalSize = 0;
    for(m_ulNumSizes = 0, i = m_iStartSize; i <= m_iEndSize; i *=2, m_ulNumSizes++)
	m_ulTotalSize += i * m_iRepeatFactor;


    if (m_iRepeatFactor * m_ulNumSizes > MAX_READS)
    {
    	Log(TEXT("Too many different sizes and/or repeat factor is too big"), E_FAIL);
	Cleanup();
	return E_FAIL;
    }

    m_flStgCreateFlags = 0;
    // get file name to be used and values of other parameters
    pInput->GetConfigString(Name(), TEXT("FileName"), TEXT("stgtest.bm"),
    			    m_pszFile, MAX_PATH);
#ifdef UNICODE
    wcscpy(m_pwszFile, m_pszFile);
#else
    mbstowcs(m_pwszFile, m_pszFile, strlen(m_pszFile)+1);
#endif

    pInput->GetConfigString(Name(), TEXT("FileMode"), TEXT("DIRECT"),
    			    m_pszFileMode, 15);

    if(lstrcmpi(m_pszFileMode, TEXT("DIRECT")) == 0)
       	m_flStgCreateFlags |= STGM_DIRECT;
    else
       	m_flStgCreateFlags |= STGM_TRANSACTED; 	


    pInput->GetConfigString(Name(), TEXT("SetSize"), TEXT("OFF"), pszValue, 15);

    if (lstrcmpi(pszValue, TEXT("ON")) == 0)
    	m_bDoSetSize = TRUE;
    else
    	m_bDoSetSize = FALSE;

    pInput->GetConfigString(Name(), TEXT("ReadMode"), TEXT("SEQUENTIAL"),
    			    m_pszReadMode, 15);

    if(lstrcmpi(m_pszReadMode, TEXT("SEQUENTIAL")) == 0)
    	m_bSequentialRead = TRUE;
    else
    	m_bSequentialRead = FALSE;


    InitTimings();

    return S_OK;
}


void CStorageTest::InitTimings()
{
    ULONG i;

    //	initialize timing arrays

    INIT_RESULTS(m_ulIsStorageFileYES);
    INIT_RESULTS(m_ulIsStorageFileNO);
    INIT_RESULTS(m_ulStgOpenStorageDRFAIL);


    INIT_RESULTS(m_ulStgCreateDocfile);
    INIT_RESULTS(m_ulCreateStream);
    ZERO_RESULTS(m_ulSetSize);
    INIT_RESULTS(m_ulStreamRelease1);
    ZERO_RESULTS(m_ulStorageCommit);
    INIT_RESULTS(m_ulStorageRelease1);

    INIT_RESULTS(m_ulStgOpenStorage);
    INIT_RESULTS(m_ulOpenStream);
    INIT_RESULTS(m_ulStreamRelease2);
    INIT_RESULTS(m_ulStorageRelease2);

    ZERO_RESULTS(m_ulStreamWriteTotal);
    ZERO_RESULTS(m_ulStreamReadTotal);
    ZERO_RESULTS(m_ulStreamSeekTotal);


    for (i = 0; i < MAX_READS; i++)
    {
    	INIT_RESULTS(m_ulStreamWrite[i]);
    	INIT_RESULTS(m_ulStreamRead[i]);
    	INIT_RESULTS(m_ulStreamSeek[i]);
#ifdef TIME_FILEIO
    	INIT_RESULTS(m_ulActualWrite[i]);
    	INIT_RESULTS(m_ulActualRead[i]);
#endif
    }

#ifdef TIME_FILEIO
    INIT_RESULTS(m_ulActualFlush1);
    INIT_RESULTS(m_ulActualFlush2);
    INIT_RESULTS(m_ulActualCommitW);
#endif

    for (i = 0; i < 2; i++ )
    	ZERO_RESULTS(m_ulTotal[i]);

}


SCODE CStorageTest::Cleanup ()
{
    //	delete the file
    DeleteFile (m_pszFile);
    if(m_piMalloc)
    {
    	if (m_pbData)
    	    m_piMalloc->Free(m_pbData);

	m_pbData = NULL;

	m_piMalloc->Release();
	m_piMalloc = NULL;

    }

    UninitCOM();

    return S_OK;
}


SCODE CStorageTest::Run ()
{
        CStopWatch  sw;
	HRESULT     hr;
        LPSTORAGE   piStorage;
        LPSTREAM    piStream;
        ULONG       cb;
        ULONG       iIter;
	ULONG	    iSize;
	ULONG	    i, iCount;
    	ULARGE_INTEGER  li;

#ifdef TIME_FILEIO
	ULONG	    ulTempTime;
#endif
        //Create and then write to docfile in selected mode
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    hr = StgCreateDocfile(m_pwszFile, m_flStgCreateFlags | STGM_WRITE
	          | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &piStorage);
	    m_ulStgCreateDocfile[iIter] = sw.Read();
            Log(TEXT("StgCreateDocfile for writing"), hr);
            if(FAILED(hr))
                return hr;

            sw.Reset();
            hr = piStorage->CreateStream(L"CONTENTS", STGM_DIRECT |
            		STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE,
            		0, 0, &piStream);
            m_ulCreateStream[iIter] = sw.Read();
            Log(TEXT("CreateStream"), hr);


	    if (m_bDoSetSize)
	    {
		ULISet32(li, m_ulTotalSize);
	    	sw.Reset();
	    	hr = piStream->SetSize(li);
	    	m_ulSetSize[iIter] = sw.Read();
		Log(TEXT("IStream::SetSize"), hr);
	    }

#ifdef TIME_FILEIO
	    // reset all timings
	    GetFlushTiming(NULL, TRUE);
	    GetWriteTiming(NULL, TRUE);
	    GetReadTiming(NULL, TRUE);
	    GetSetFileTiming(NULL, TRUE);
#endif
	    iCount = 0;
	    for ( iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    {
	    	for ( i = 0; i < m_iRepeatFactor; i++)
	    	{
   		    sw.Reset();
		    hr = piStream->Write((LPVOID)m_pbData, iSize, &cb);
         	    m_ulStreamWrite[iCount][iIter] = sw.Read();
     		    m_ulStreamWriteTotal[iIter] += m_ulStreamWrite[iCount][iIter];
#ifdef TIME_FILEIO
		    GetWriteTiming(&m_ulActualWrite[iCount][iIter], TRUE);
            	    GetSetFileTiming(&ulTempTime, TRUE);
		    m_ulActualWrite[iCount][iIter] += ulTempTime;
#endif
		    iCount++;
	    	}
	    }
	    Log(TEXT("IStream->Write X bytes"), hr);
	

            sw.Reset();
            piStream->Release();
            m_ulStreamRelease1[iIter] = sw.Read();

	    if(m_flStgCreateFlags == STGM_TRANSACTED)
	    {
            	sw.Reset();
            	piStorage->Commit(STGC_DEFAULT);
            	m_ulStorageCommit[iIter] = sw.Read();
 	    }

            sw.Reset();
            piStorage->Release();
            m_ulStorageRelease1[iIter] = sw.Read();
#ifdef TIME_FILEIO
	    GetFlushTiming(&m_ulActualFlush1[iIter], TRUE);
	    GetWriteTiming(&m_ulActualCommitW[iIter], TRUE);
#endif

            m_ulTotal[0][iIter] = m_ulStgCreateDocfile[iIter] +
                            	m_ulCreateStream[iIter] +
				m_ulSetSize[iIter] +
                            	m_ulStreamWriteTotal[iIter] +
                            	m_ulStreamRelease1[iIter] +
                            	m_ulStorageCommit[iIter] +
                            	m_ulStorageRelease1[iIter];
        }


        // now try reading from the file.
	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
	    hr = StgOpenStorage(m_pwszFile, NULL, m_flStgCreateFlags | STGM_READ
	          | STGM_SHARE_EXCLUSIVE, NULL, 0, &piStorage);
	    m_ulStgOpenStorage[iIter] = sw.Read();
            Log(TEXT("StgOpenStorage for reading"), hr);

            sw.Reset();
            hr = piStorage->OpenStream(L"CONTENTS", NULL, STGM_DIRECT | STGM_READ
                   | STGM_SHARE_EXCLUSIVE, 0, &piStream);
            m_ulOpenStream[iIter] = sw.Read();
            Log(TEXT("IStorage->OpenStream"), hr);


#ifdef TIME_FILEIO
    	    GetReadTiming(NULL, TRUE);
	    GetSetFileTiming(NULL, TRUE);
#endif

	    iCount = 0;
    	    if (m_bSequentialRead)
	    {
	    	for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    	{
		     for (i = 0; i < m_iRepeatFactor; i++)
		     {
   			sw.Reset();
	        	hr = piStream->Read((LPVOID)m_pbData, iSize, &cb);
         		m_ulStreamRead[iCount][iIter] = sw.Read();
         		m_ulStreamReadTotal[iIter] += m_ulStreamRead[iCount][iIter];
#ifdef TIME_FILEIO
	    	    	GetReadTiming(&m_ulActualRead[iCount][iIter], TRUE);
	    	    	GetSetFileTiming(&ulTempTime, TRUE);
       			m_ulActualRead[iCount][iIter] += ulTempTime;
#endif
   			iCount++;
		     }
	    	}
            	Log(TEXT("IStorage->Read Sequential"), hr);
	    }
	    else
	    {
		LARGE_INTEGER liSeekSize;
	        ULONG 	      cbCurOffset = m_ulTotalSize;

		iCount = 0;
	    	for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
	    	{
	    	  for ( i =0; i< m_iRepeatFactor; i++)
		  {
		    cbCurOffset -= iSize;
		    LISet32(liSeekSize, cbCurOffset);

		    sw.Reset();
            	    hr = piStream->Seek(liSeekSize, STREAM_SEEK_SET, NULL);
            	    m_ulStreamSeek[iCount][iIter] = sw.Read();
         	    m_ulStreamSeekTotal[iIter] += m_ulStreamSeek[iCount][iIter];

		    sw.Reset();
            	    hr = piStream->Read((LPVOID)m_pbData, iSize, &cb);
            	    m_ulStreamRead[iCount][iIter] = sw.Read();
         	    m_ulStreamReadTotal[iIter] += m_ulStreamRead[i][iIter];
#ifdef TIME_FILEIO
	    	    GetReadTiming(&m_ulActualRead[iCount][iIter], TRUE);
	    	    GetSetFileTiming(&ulTempTime, TRUE);
       		    m_ulActualRead[iCount][iIter] += ulTempTime;
#endif		
		    iCount++;
		  }
	    	}

            	Log(TEXT("IStorage->Read Random"), hr);
	    }

            sw.Reset();
            piStream->Release();
            m_ulStreamRelease2[iIter] = sw.Read();

            sw.Reset();
            piStorage->Release();
            m_ulStorageRelease2[iIter] = sw.Read();

#ifdef TIME_FILEIO
	    GetFlushTiming(&m_ulActualFlush2[iIter], TRUE);
#endif

            m_ulTotal[1][iIter] = m_ulStgOpenStorage[iIter] +
                            	  m_ulOpenStream[iIter] +
				  m_ulStreamSeekTotal[iIter] +
                            	  m_ulStreamReadTotal[iIter] +
                         	  m_ulStreamRelease2[iIter] +
                            	  m_ulStorageRelease2[iIter];
        }


        // test if its a storage file (should be yes).
 	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    sw.Reset();
            hr = StgIsStorageFile(m_pwszFile);
            m_ulIsStorageFileYES[iIter] = sw.Read();
            Log(TEXT("StgIsStorageFile on storage file"), hr);
        }

        // create a non-storage file and check if it is storage file
	HANDLE hFile = CreateFile(m_pszFile, GENERIC_READ | GENERIC_WRITE, 0, NULL,
				 CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
	    Log(TEXT("Creation of non storage file"), E_FAIL);
	    return E_FAIL;
	}
        WriteFile(hFile, (LPSTR)m_pbData, m_iEndSize, &cb, NULL);
	CloseHandle(hFile);

	for (iIter=0; iIter<m_ulIterations; iIter++)
	{
	    LPSTORAGE piStorage;

	    sw.Reset();
	    hr = StgIsStorageFile(m_pwszFile);
	    m_ulIsStorageFileNO[iIter] = sw.Read();
	    Log(TEXT("StgIsStorageFile on Non-storage file"),
	    	(hr != S_OK) ? S_OK : E_FAIL);

	    sw.Reset();
	    hr =StgOpenStorage(m_pwszFile, NULL, STGM_DIRECT | STGM_READ
	        | STGM_SHARE_EXCLUSIVE, NULL, 0, &piStorage);
	    m_ulStgOpenStorageDRFAIL[iIter] = sw.Read();
	    Log(TEXT("StgOpenStorage on Non-storage file"),
	    	(hr != S_OK) ? S_OK : E_FAIL);
	}



        return S_OK;
}



SCODE CStorageTest::Report (CTestOutput &output)
{
    TCHAR pszBuf[80];
    ULONG i, iSize, iCount;
#ifdef TIME_FILEIO
    ULONG ulActualTotal[TEST_MAX_ITERATIONS];
#endif

    wsprintf(pszBuf, TEXT("Storage Test in %s Mode with %s Read/Writes"),
    	      m_pszFileMode, m_pszReadMode);

    output.WriteSectionHeader (Name(), pszBuf, *m_pInput);

    wsprintf(pszBuf, TEXT("SetSize is %s\n\n"), m_bDoSetSize ? TEXT("ON") : TEXT("OFF"));
    output.WriteString (pszBuf);

    output.WriteResults (TEXT("IsStorageFile - YES"), m_ulIterations,
    			 m_ulIsStorageFileYES);
    output.WriteResults (TEXT("IsStorageFile - NO "), m_ulIterations,
    			 m_ulIsStorageFileNO);
    output.WriteResults (TEXT("StgOpenStorage D/R/FAIL"), m_ulIterations,
    			 m_ulStgOpenStorageDRFAIL);
    output.WriteString (TEXT("\n"));


    output.WriteResults (TEXT("StgCreateDocfile    "), m_ulIterations,
    			 m_ulStgCreateDocfile);
    output.WriteResults (TEXT("CreateStream        "), m_ulIterations,
    			 m_ulCreateStream);

    output.WriteString (TEXT("\n"));

    if (m_bDoSetSize)
    	output.WriteResults (TEXT("Stream SetSize      "), m_ulIterations,
    			 m_ulSetSize);

#ifdef TIME_FILEIO
    ZERO_RESULTS(ulActualTotal);
#endif

    iCount = 0;
    for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
    {
        for (i = 0; i < m_iRepeatFactor; i++)
	{
    	     wsprintf(pszBuf, TEXT("StreamWrite %-9d"), iSize);

    	     output.WriteResults (pszBuf, m_ulIterations, m_ulStreamWrite[iCount]);

#ifdef TIME_FILEIO
	output.WriteResults (TEXT("Disk-hit time     "), m_ulIterations, m_ulActualWrite[iCount]);
	
	for ( ULONG xx = 0; xx < m_ulIterations; xx++)
		ulActualTotal[xx] += m_ulActualWrite[iCount][xx];
#endif
	     iCount++;
        }

    }

    output.WriteResults (TEXT("StreamWrite Total   "), m_ulIterations,
    			 m_ulStreamWriteTotal);
#ifdef TIME_FILEIO

    output.WriteResults (TEXT("Actual Write Total  "), m_ulIterations,
    			 ulActualTotal);

#endif



    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("StreamRelease       "), m_ulIterations,
    			 m_ulStreamRelease1);

    if (m_flStgCreateFlags == STGM_TRANSACTED)
    {
        output.WriteResults (TEXT("StorageCommit       "), m_ulIterations,
        		     m_ulStorageCommit);

#ifdef TIME_FILEIO
        output.WriteResults (TEXT("Disk hit time       "), m_ulIterations,
        		     m_ulActualCommitW);
#endif
    }

    output.WriteResults (TEXT("StorageRelease      "), m_ulIterations,
    			 m_ulStorageRelease1);

#ifdef TIME_FILEIO
    output.WriteResults (TEXT("Actual Flush time   "), m_ulIterations,
        		     m_ulActualFlush1);
#endif

    output.WriteResults (TEXT("Total               "), m_ulIterations,
    			 m_ulTotal[0]);
    output.WriteString (TEXT("\n\n"));

    output.WriteResults (TEXT("StgOpenStorage      "), m_ulIterations,
    			 m_ulStgOpenStorage);
    output.WriteResults (TEXT("OpenStream          "), m_ulIterations,
    			 m_ulOpenStream);

    output.WriteString (TEXT("\n"));

#ifdef TIME_FILEIO
    ZERO_RESULTS(ulActualTotal);
#endif

    iCount = 0;
    for (iSize = m_iStartSize ; iSize <= m_iEndSize ; iSize *= 2)
    {
        for (i = 0; i < m_iRepeatFactor; i++)
	{
    	    if (!m_bSequentialRead)
	    {
    	    	wsprintf(pszBuf, TEXT("StreamSeek %-9d"), m_iEndSize - iSize);
    	    	output.WriteResults (pszBuf, m_ulIterations, m_ulStreamSeek[iCount]);
	    }

    	    wsprintf(pszBuf, TEXT("StreamRead %-9d"), iSize);
    	    output.WriteResults (pszBuf, m_ulIterations, m_ulStreamRead[iCount]);

#ifdef TIME_FILEIO
	    output.WriteResults (TEXT("Disk-hit time     "), m_ulIterations, m_ulActualRead[iCount]);
	
	    for ( ULONG xx = 0; xx < m_ulIterations; xx++)
		ulActualTotal[xx] += m_ulActualRead[iCount][xx];
#endif
            iCount++;
	}
    }

    if (!m_bSequentialRead)
    	output.WriteResults (TEXT("StreamSeek Total "), m_ulIterations,
    			 m_ulStreamSeekTotal);

    output.WriteResults (TEXT("StreamRead Total "), m_ulIterations,
    			 m_ulStreamReadTotal);


#ifdef TIME_FILEIO
    output.WriteResults (TEXT("Actual Read  Total  "), m_ulIterations,
    			 ulActualTotal);
#endif


    output.WriteString (TEXT("\n"));

    output.WriteResults (TEXT("StreamRelease       "), m_ulIterations,
    			 m_ulStreamRelease2);
    output.WriteResults (TEXT("StorageRelease      "), m_ulIterations,
    			 m_ulStorageRelease2);
#ifdef TIME_FILEIO
    output.WriteResults (TEXT("Actual Flush time   "), m_ulIterations,
        		     m_ulActualFlush2);
#endif

    output.WriteResults (TEXT("Total               "), m_ulIterations,
    			 m_ulTotal[1]);
    output.WriteString (TEXT("\n"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	headers.cxx
//
//  Contents:	remote2/new precompiled headers
//
//  Classes:	
//
//  Functions:	
//
//  History:	24-Aug-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include <benchmrk.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\tests\rawrpc_x.c ===
#include <string.h>
#include <limits.h>
#include <rpc.h>

#include "rawrpc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\bm_cache.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:    bm_Cache.cxx
//
//  Contents:    Contains the impl of COleCacheTest which deals with Clipboard related
//              apis.
//
//  Classes:    COleCacheTest
//
//  Functions:    
//
//  History:    
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_cache.hxx"
#include <oleauto.h>


//**********************************************************************
//
// CCacheTest::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CCacheTest. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *COleCacheTest::Name ()
{
    return TEXT("CacheTest");
}


SCODE COleCacheTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif

    //    initialize timing arrays
#ifndef STRESS

    //INIT_RESULTS(m_CacheTimesOutl.ulCreateCache);
    for (int xx = 0; xx < TEST_MAX_ITERATIONS; xx++)
        {
        m_CacheTimesOutl[xx].ulCreateCache   = NOTAVAIL;
        m_CacheTimesOutl[xx].ulCache         = NOTAVAIL;
        m_CacheTimesOutl[xx].ulInitCache     = NOTAVAIL;
        m_CacheTimesOutl[xx].ulLoadCache     = NOTAVAIL;
        m_CacheTimesOutl[xx].ulSaveCache     = NOTAVAIL;
        m_CacheTimesOutl[xx].ulUncache       = NOTAVAIL;
        m_CacheTimesOutl[xx].ulUpdateCache   = NOTAVAIL;
        m_CacheTimesOutl[xx].ulDiscardCache  = NOTAVAIL;
        }

#endif


    sc = OleInitialize(NULL);
    if (FAILED(sc))
        {
        Log (TEXT("Setup - OleInitialize failed."), sc);
        return    sc;
        }

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    assert (hres == NOERROR);

    //Create root Doc and STorage for Doc
    m_lpDoc = CSimpleDoc::Create();
        
    //Create Individual Objects and Init the table
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++) {

        // Create an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}


SCODE COleCacheTest::Cleanup ()
{


    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
        {
        delete m_pSite[iIter]; 
        }

    OleUninitialize();
    return S_OK;
}


SCODE COleCacheTest::Run ()
{
    BOOL fRet;

    fRet = CallRunCache(m_clsidOutl, m_pSite, m_pOleCache2, m_ulIterations, m_CacheTimesOutl);
    return S_OK;
}                      



SCODE COleCacheTest::Report (CTestOutput &output)
{
//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("Cache Apis"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));
    output.WriteString (TEXT("\n"));
    WriteCacheOutput(output, TEXT("Outline"), m_CacheTimesOutl, m_ulIterations);
    output.WriteString (TEXT("\n"));


    return S_OK;
}
    
//**********************************************************************
//
// CallRunCache
//
// Purpose:
//          Creates an embedded object and calls routines to create cache
//          Initialize them and then Save and load them.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleCreate               OLE2 api 
//      CreateCacheObjects      Create Cache objects
//      FillCache               To fill  up the caches with pDO
//      SaveAndLoadCache        Get the estimates for Save and Load Cache
//
//
// Comments:
//          
//
//********************************************************************


BOOL CallRunCache(REFCLSID rclsid, CSimpleSite *pSite[], LPOLECACHE2 pOleCache2[], 
                ULONG ulIterations, CacheTimes Cachetimes[])
{
        HRESULT         hres;
        ULONG           iIter;
        BOOL            retVal = FALSE;
        LPDATAOBJECT    pDO = NULL;

        CSimpleSite*    pTempSite = CSimpleSite::Create(pSite[0]->m_lpDoc, -1); //Some temporary name
        if (!pTempSite)
            goto error;

        //If we have not had any problem then 
        HEAPVALIDATE() ;
        hres = OleCreate(rclsid,  IID_IOleObject, OLERENDER_DRAW, NULL, 
                         &pTempSite->m_OleClientSite, pTempSite->m_lpObjStorage, 
                         (VOID FAR* FAR*)&pTempSite->m_lpOleObject);

        LOGRESULTS (TEXT("OleCreate "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        hres = pTempSite->m_lpOleObject->QueryInterface(IID_IDataObject, (LPVOID FAR*)&pDO);
        if (hres != NOERROR)
            goto error;
        

        //Now call Appropriate routines to Save and Cache the objects
        hres = CreateCacheObjects( pSite, pOleCache2, ulIterations, Cachetimes);
        if (hres != NOERROR)
            goto error; //there is no point in going if we had problem with creation
        FillCache(pDO, pOleCache2, ulIterations, Cachetimes);
        SaveAndLoadCache(pSite, pOleCache2, ulIterations, Cachetimes);

        retVal = TRUE;

error:

    if (hres != NOERROR)
        Log (TEXT("Routine CallRunCache failed with hres = "), hres);

    if (pDO)
        pDO->Release();
    if (pTempSite)
        {
        pTempSite->UnloadOleObject();
        delete pTempSite;
        }

    for (iIter=0; iIter < ulIterations; iIter++)
        {
        if (pOleCache2[iIter])
            {
            pOleCache2[iIter]->Release();
            pOleCache2[iIter] = NULL;
            }
        }

return retVal;
}

//**********************************************************************
//
// CreateCacheObjects
//
// Purpose:
//      Creates Cache objects and then initlaize them.
//      
//      
//      
//
// Parameters:
//
//      
// Return Value:
//
//      HRESULT that came from IPS->InitNew
//
// Functions called:
//      CreateDataCache        OLE2 api 
//
//
// Comments:
//          
//
//********************************************************************


HRESULT CreateCacheObjects(CSimpleSite *pSite[], LPOLECACHE2 pOleCache2[], 
                        ULONG ulIterations, CacheTimes Cachetimes[]) 

{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;
    BOOL        retVal = FALSE;

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Reset();
        hres = CreateDataCache(NULL, CLSID_NULL, IID_IOleCache2, (LPVOID FAR*)&pOleCache2[iIter]);
        GetTimerVal(Cachetimes[iIter].ulCreateCache);

        LOGRESULTS (TEXT("CreateDataCache "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        //
        //Initlaize the cache for use later
        //
        LPPERSISTSTORAGE lpStg = NULL;
        hres = pOleCache2[iIter]->QueryInterface(IID_IPersistStorage, (LPVOID FAR*) &lpStg);
        if (hres == NOERROR)
            {
            hres = lpStg->InitNew(pSite[iIter]->m_lpObjStorage);
            lpStg->Release();
            }
        }
error:
    
    if (hres != NOERROR)
        Log (TEXT("Routine CreateCacheObject failed with hres = "), hres);
    return hres;
}
    

VOID FillCache(LPDATAOBJECT pDO, LPOLECACHE2 pOleCache2[], ULONG ulIterations, 
                       CacheTimes Cachetimes[])

{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;
    BOOL        retVal = FALSE;

    //Initalize the cache
    //NOTE: What I am doing below is trying to Init the cache with format that
    //I think are very basic and common. So that we can profile the rest of the
    //Cache methods with these options
    //
    //Work On: Create more Cache nodes!!!
    //
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        FORMATETC fmte;
        DWORD     dwConnection = 0L;

        fmte.cfFormat = CF_METAFILEPICT;
        fmte.dwAspect = DVASPECT_CONTENT;
        fmte.ptd      = NULL; 
        fmte.tymed    = TYMED_MFPICT;
        fmte.lindex   = -1;

        sw.Reset();
        hres = pOleCache2[iIter]->Cache(&fmte, ADVF_PRIMEFIRST | ADVFCACHE_ONSAVE | ADVF_DATAONSTOP, 
                &dwConnection);
        GetTimerVal(Cachetimes[iIter].ulCache);

        LOGRESULTS (TEXT("IOleCache:Cache "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }

        }

    //Fill the Cache from Data object provided
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Reset();
        hres = pOleCache2[iIter]->InitCache(pDO);
        GetTimerVal(Cachetimes[iIter].ulInitCache);

        LOGRESULTS (TEXT("IOleCache:InitCache "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        }

error:
    
    if (hres != NOERROR)
        Log (TEXT("Routine FillCache failed with hres = "), hres);
}

VOID SaveAndLoadCache(CSimpleSite *pSite[], LPOLECACHE2 pOleCache2[], 
                ULONG ulIterations, CacheTimes Cachetimes[])
{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;

    // Save the Cache, i.e. save the formats Cached
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        LPPERSISTSTORAGE lpStg = NULL;

        hres = pOleCache2[iIter]->QueryInterface(IID_IPersistStorage, (LPVOID FAR*)&lpStg);
        if (hres != NOERROR)
            continue; //TRy next Cache, it is unexpected condition though

        sw.Reset();
        hres = lpStg->Save(pSite[iIter]->m_lpObjStorage, TRUE);
        hres = lpStg->SaveCompleted(NULL);

        GetTimerVal(Cachetimes[iIter].ulSaveCache);
        if (lpStg)
            lpStg->Release();
        LOGRESULTS (TEXT("Cache- Save and SaveCompleted "), hres);
        }

    //
    //To test IOC:Load we need to destroy old cache nodes, create new
    //ones and ask them to laod themselves
    //
    for (iIter=0; iIter < ulIterations; iIter++)
        {
        if (pOleCache2[iIter])
            {
            pOleCache2[iIter]->Release();
            pOleCache2[iIter] = NULL;
            }
        }

    //Create new set of Cache
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Reset();
        hres = CreateDataCache(NULL, CLSID_NULL, IID_IOleCache2, (LPVOID FAR*)&pOleCache2[iIter]);
        GetTimerVal(Cachetimes[iIter].ulCreateCache);

        LOGRESULTS (TEXT("CreateDataCache "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        }

    //Load the Cache from the storage provided
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        LPPERSISTSTORAGE lpStg = NULL;

        //Query for IPS to load the object
        hres = pOleCache2[iIter]->QueryInterface(IID_IPersistStorage, (LPVOID FAR*) &lpStg);
        if (hres != NOERROR)
            continue; //Try next Cache

        sw.Reset();
        hres = lpStg->Load(pSite[iIter]->m_lpObjStorage);
        GetTimerVal(Cachetimes[iIter].ulLoadCache);

        if (lpStg)
            lpStg->Release();
        LOGRESULTS (TEXT("Cache- Load "), hres);
        } //End For

error:

    if (hres != NOERROR)
        Log (TEXT("Routine SaveAndLoadCache failed with hres = "), hres);

}

void WriteCacheOutput(CTestOutput &output, LPTSTR lpstr, CacheTimes *CTimes, ULONG ulIterations)
{
    UINT iIter;

    output.WriteString (TEXT("Name"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("Create"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("IOC:Cache"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("IOC:InitCache"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("LoadCache"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("SaveCache"));
    output.WriteString (TEXT("\n"));

    for (iIter = 0; iIter < ulIterations; iIter++)
        {
        output.WriteString (lpstr);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (CTimes[iIter].ulCreateCache);
        output.WriteString (lpszTab);
        output.WriteLong (CTimes[iIter].ulCache);
        output.WriteString (lpszTab);
        output.WriteLong (CTimes[iIter].ulInitCache);
        output.WriteString (lpszTab);
        output.WriteLong (CTimes[iIter].ulLoadCache);
        output.WriteString (lpszTab);
        output.WriteLong (CTimes[iIter].ulSaveCache);
        output.WriteString (TEXT("\n"));
        }

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\bm_clip.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:    bm_Clip.cxx
//
//  Contents:   Contains the impl of CClipbrdTest which deals with
//              Clipboard related apis.
//
//  Classes:    CClipbrdTest
//
//  Functions:    
//
//  History:    Doesn't work yet.  The code to place data on the clipboard
//              uses autoamation which isn't supported in the server.
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_Clip.hxx"
#include <oleauto.h>


//**********************************************************************
//
// CClipbrd::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CClipbrd. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *CClipbrdTest::Name ()
{
    return TEXT("ClipbrdTest");
}



SCODE CClipbrdTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif

    //    initialize timing arrays

#ifndef STRESS

    INIT_RESULTS(m_ulOleGetClipbrd);
    INIT_RESULTS(m_ulOleQueryCreate);
    INIT_RESULTS(m_ulOleQueryLink);

    INIT_RESULTS(m_ulCreateFromClipOutl);
    INIT_RESULTS(m_ulCreateFromClipRenderDrawOutl);
    INIT_RESULTS(m_ulCreateFromClipRenderAsisOutl);

    INIT_RESULTS(m_ulCreateLinkFromClipOutl);
    INIT_RESULTS(m_ulCreateLinkFromClipRenderDrawOutl);

    INIT_RESULTS(m_ulCreateStaticFromClipRenderDrawOutl);
    INIT_RESULTS(m_ulCreateStaticFromClipRenderDrawBMOutl);
#endif //STRESS

    sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
    Log (TEXT("Setup - OleInitialize failed."), sc);
    return    sc;
    }

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    assert (hres == NOERROR);

    //Create root Doc and STorage for Doc
    m_lpDoc = CSimpleDoc::Create();
        
    //Create Individual Objects and Init the table
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++) {

        // CreateLink an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}


SCODE CClipbrdTest::Cleanup ()
{

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
        delete m_pSite[iIter]; 
    }

    OleUninitialize();
    return S_OK;
}


//**********************************************************************
//
// CClipbrd::Run
//
// Purpose:
//      This is the work horse routine which calls OLE apis.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleSetClipboard     OLE - Is profiled here
//      OleGetClipboard     OLE - Is profiled here
//      OleCreateFromClip   defined below
//
//
// Comments:
//
//********************************************************************


SCODE CClipbrdTest::Run ()
{
    CStopWatch  sw;
    HRESULT     hres;
    BOOL        fRet;

    TCHAR       szTemp[MAX_PATH];
    OLECHAR     szOutlFileName[MAX_PATH];


    //  Get file name of .ini file. if not specified in the command
    //  line, use the default BM.INI in the local directory
    GetCurrentDirectory (MAX_PATH, szTemp);
    swprintf(szOutlFileName,
#ifdef UNICODE
                L"%s\\foo.oln",
#else
                L"%S\\foo.oln",
#endif
                szTemp);

    //Empty clipboard and get the estimate on empty clipboard
    hres = OleSetClipboard(NULL);
    sw.Reset();
    hres = OleSetClipboard(NULL);
    GetTimerVal(m_ulSetClipEmpty);
        
    fRet = CallOleGetClipbrd(szOutlFileName, m_ulIterations, m_ulOleGetClipbrd,
                        m_ulOleQueryCreate, m_ulOleQueryLink);

    //Now Empty clipboard again. This time Data on clipboard from SvrOutl
    sw.Reset();
    hres = OleSetClipboard(NULL);
    GetTimerVal(m_ulSetClipOutl);


    //
    //Test cases for OleCreateFromData
    //

    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_NONE, 
                            NULL, m_ulIterations, m_ulCreateFromClipOutl, OLECREATE);
    //Empty clipboard for next test case
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulCreateFromClipRenderDrawOutl, OLECREATE);
    //Empty clipboard for next test case
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_ASIS, 
                            NULL, m_ulIterations, m_ulCreateFromClipRenderAsisOutl, OLECREATE);
    
    //
    //Test cases for OleCreateLinkFromData
    //
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_NONE, 
                            NULL, m_ulIterations, m_ulCreateLinkFromClipOutl, OLECREATELINK);
    //Empty clipboard for next test case
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulCreateLinkFromClipRenderDrawOutl, OLECREATELINK);

    //
    //Test cases for OleCreateLinkFromData
    //
    //I would have liked Bitmap but SvrOutl only supports Metafile
    FORMATETC fmte = {CF_ENHMETAFILE, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulCreateStaticFromClipRenderDrawBMOutl, OLECREATESTATIC);
    //Empty clipboard for next test case
    hres = OleSetClipboard(NULL);
    fRet = CallCreateFromClip(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulCreateStaticFromClipRenderDrawOutl, OLECREATESTATIC);
    return S_OK;
}                      



SCODE CClipbrdTest::Report (CTestOutput &output)
{
//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("Clipbrd Apis"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleGetClipbrd \t\t\t"), m_ulIterations, m_ulOleGetClipbrd);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSetClipbrd  Empty\t\t"), 1, &m_ulSetClipEmpty);
    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSetClipbrd  Data\t\t"), 1, &m_ulSetClipOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("***************************************\n"));
    output.WriteResults (TEXT("OleCreateFromClip  Outline \t\t\t"), m_ulIterations, m_ulCreateFromClipOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateFromClip  with RenderDraw Outline\t"), m_ulIterations, m_ulCreateFromClipRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateFromClip  with RenderFormatMF Outline\t "), m_ulIterations, m_ulCreateFromClipRenderFormatMFOutl);
    output.WriteString (TEXT("\n"));


    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateFromClip  with RenderAsIs Outline \t"), m_ulIterations, m_ulCreateFromClipRenderAsisOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("***************************************\n"));
    output.WriteResults (TEXT("OleCreateLinkFromClip  Outline \t\t"), m_ulIterations, m_ulCreateLinkFromClipOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLinkFromClip  with RenderDraw Outline \t"), m_ulIterations, m_ulCreateLinkFromClipRenderDrawOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("***************************************\n"));
    output.WriteResults (TEXT("OleCreateStaticFromClip  Outline\t"), m_ulIterations, m_ulCreateStaticFromClipRenderDrawOutl);
    output.WriteString (TEXT("\n"));

#if VERIFYSTATICBEHAVIOR

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateStaticFromClip  with RenderDraw Outline \t"), m_ulIterations, m_ulCreateStaticFromClipRenderDrawBMOutl);
    output.WriteString (TEXT("\n"));
#endif


    return S_OK;
}
    
    

//**********************************************************************
//
// OleGetClipboard
//
// Purpose:
//      This routine is called CallOleGetClipboard but it also instruments
//      OLeQueryXX apis! (This was the best place to do that otherwise what 
//      to do with Clipboard data).
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CreateFileMoniker   OLE - creates file moniker
//      CreateBindCtx       OLE 
//      IDispatch::GetIDsOfNames Dispatch routine which makes call into SvrOutl (yet another version!)
//      OleGetClipboard     OLE - Is profiled here
//      OleQueryCreateFromData     OLE - Is profiled here
//      OleLinkFromData     OLE - Is profiled here
//
//
// Comments:
//
//********************************************************************



BOOL CallOleGetClipbrd(LPCOLESTR lpFileName, ULONG ulIterations, ULONG uOleClipbrdtime[], 
                       ULONG uOleQCreatetime[], ULONG uOleQLinktime[])
{
        CStopWatch  sw;
        HRESULT     hres;
        ULONG       iIter;
        BOOL        retVal = FALSE;

        LPDATAOBJECT pDO = NULL;
        LPMONIKER   pmk = NULL;
        LPBC        pbc = NULL;
        IDispatch FAR* pDisp = NULL;

        hres = CreateFileMoniker(lpFileName, &pmk);

        if (hres != NOERROR)
                goto error;
        else {
                
            
            //Bind to moniker object and ask for IID_IDispatch
            hres = CreateBindCtx(NULL, &pbc);
            if (hres != NOERROR)
                goto error;

            hres = pmk->BindToObject(pbc, NULL, IID_IDispatch, (LPVOID FAR*) &pDisp);
            if (hres != NOERROR)
                goto error;


            //Now Make outline copy object to clipboard
            OLECHAR FAR* pCopy = L"COPY";
            DISPID   dispid;
            EXCEPINFO expinfo;
            DISPPARAMS vNullDisp = {NULL, 0, 0, NULL};   

            hres = pDisp->GetIDsOfNames(
                            IID_NULL,
                            &pCopy,
                            1, LOCALE_USER_DEFAULT,
                            &dispid);                

            if (hres == NOERROR) {
                //Invoke Method Copy so that SvrOutl copies data to clipboard
                hres = pDisp->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
                     &vNullDisp, NULL, &expinfo, NULL);
                if (hres != NOERROR)
                     goto error;
                }

            pDisp->Release();
            pDisp = NULL; 
        }
        
        for ( iIter=0; iIter<ulIterations; iIter++) {

            //If we have not had any problem then 
            sw.Reset();
            //Get the Clipboard data
            hres = OleGetClipboard(&pDO);
            GetTimerVal(uOleClipbrdtime[iIter]);

            LOGRESULTS (TEXT("OleGetClipboard "), hres);
            if (hres != NOERROR)
                {
                goto error;
                }
                
            //Now call QueryCreate and QueryLinkFromCLip Apis

            sw.Reset();
            hres = OleQueryCreateFromData(pDO);
            GetTimerVal(uOleQCreatetime[iIter]);
            LOGRESULTS (TEXT("OleQueryCreateFromData "), hres);

            sw.Reset();
            hres = OleQueryLinkFromData(pDO);
            GetTimerVal(uOleQLinktime[iIter]);
            LOGRESULTS (TEXT("OleQueryCreateLinkFromData "), hres);

            
            if (pDO) {
                pDO->Release();
                pDO = NULL;
            }
        }


        retVal = TRUE;

error:
        if (hres != NOERROR)
            Log (TEXT("Routine OleGetClipbrd failed with hres = "), hres);

        if (pmk)
                pmk->Release();
        if (pDO)
                pDO->Release();
        if (pbc)
                pbc->Release();
        if (pDisp)
                pDisp->Release();

return retVal;
}




//**********************************************************************
//
// CallCreateFromClip
//
// Purpose:
//      This routine creates the OLE object from Clipboard data. It creates 
//      both embedded and linked object.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CreateFileMoniker       OLE - creates file moniker
//      CreateBindCtx           OLE 
//      IDispatch::GetIDsOfNames Dispatch routine which makes call into SvrOutl (yet another version!)
//      IDispatch::Invoke       Dispatch routine asking Svroutl to copy to clipboard
//      OleGetClipboard         OLE - called to get Data object on Clip
//      OleCreateFromData       OLE - Is profiled here
//      OleCreateLinkFromData   OLE - Is profiled here
//      OleCreateStaticFromData    OLE - Is profiled here
//
//
// Comments:
//
//********************************************************************

BOOL CallCreateFromClip(LPCOLESTR lpFileName, CSimpleSite * pSite[], REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, ULONG ulIterations, ULONG uOleClipbrdtime[], CREATE_METHOD MethodID)
{
        CStopWatch  sw;
        HRESULT     hres;
        ULONG       iIter;
        BOOL        retVal = FALSE;

        LPDATAOBJECT pDO = NULL;
        LPMONIKER   pmk = NULL;
        LPBC        pbc = NULL;
        IDispatch FAR* pDisp = NULL;

        hres = CreateFileMoniker(lpFileName, &pmk);

        if (hres != NOERROR)
                goto error;
        else {
                
            
            //Bind to moniker object and ask for IID_IDispatch
            hres = CreateBindCtx(NULL, &pbc);
            if (hres != NOERROR)
                goto error;

            hres = pmk->BindToObject(pbc, NULL, IID_IDispatch, (LPVOID FAR*)&pDisp);
            if (hres != NOERROR)
                goto error;


            //Now Make outline copy object to clipboard
            OLECHAR FAR* pCopy = L"COPY";
            DISPID   dispid;
            EXCEPINFO expinfo;
            DISPPARAMS vNullDisp = {NULL, 0, 0, NULL};   


            hres = pDisp->GetIDsOfNames(
                            IID_NULL,
                                &pCopy,
                            1, LOCALE_USER_DEFAULT,
                                &dispid);                
            if (hres == NOERROR) {
                hres = pDisp->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
                     &vNullDisp, NULL, &expinfo, NULL);
                if (hres != NOERROR)
                     goto error;
                }

            pDisp->Release();
            pDisp = NULL;
        }
        //Get the Clipboard data
        hres = OleGetClipboard(&pDO);
        if (hres != NOERROR)
                goto error;

        
        for ( iIter=0; iIter<ulIterations; iIter++) {

            //If we have not had any problem then 
            HEAPVALIDATE() ;
            switch(MethodID) {
                case OLECREATE:
                    {
            
                    sw.Reset();
                    hres = OleCreateFromData(pDO, riid, renderopt, 
                                    pFormatEtc, &pSite[iIter]->m_OleClientSite,
                                    pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);
                    break;
                    }
    
                case OLECREATELINK:
                    {
            
                    sw.Reset();
                    hres = OleCreateLinkFromData(pDO, riid, renderopt, 
                                    pFormatEtc, &pSite[iIter]->m_OleClientSite,
                                    pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);
                    break;
                    }
    
                case OLECREATESTATIC:
                    {
            
                    sw.Reset();
                    hres = OleCreateStaticFromData(pDO, riid, renderopt, 
                                    pFormatEtc, &pSite[iIter]->m_OleClientSite,
                                    pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);
                    break;
                    }
                default:
                    assert(FALSE);
                }
            GetTimerVal(uOleClipbrdtime[iIter]);

            LOGRESULTS (TEXT("OleCreate/Link/Static "), hres);
            if (hres != NOERROR)
                {
                goto error;
                }
            
        }


    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }
        retVal = TRUE;

error:
        if (hres != NOERROR)
            Log (TEXT("Routine CallCreateFromClip failed with hres = "), hres);

        if (pmk)
                pmk->Release();
        if (pDO)
                pDO->Release();
        if (pbc)
                pbc->Release();
        if (pDisp)
                pDisp->Release();
return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\bm_crt.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:    bm_Crt.cxx
//
//  Contents:    Create apis
//
//  Classes:    CCreateApi
//
//  Functions:    
//
//  History:    
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_Crt.hxx"

TCHAR    vlpScratchBuf[256];

//**********************************************************************
//
// CCreate::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CCreateTest. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *CCreateTest::Name ()
{
    return TEXT("CreateTest");
}


SCODE CCreateTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif
    
#ifndef STRESS
    //    initialize timing arrays
    INIT_RESULTS(m_ulOleCreateSr32);
    INIT_RESULTS(m_ulOleCreateOutl);
    INIT_RESULTS(m_ulOleCreateRenderDrawSr32);
    INIT_RESULTS(m_ulOleCreateRenderDrawOutl);
#endif


    sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
    Log (TEXT("Setup - OleInitialize failed."), sc);
    return    sc;
    }

    hres = CLSIDFromString(L"Sr32test", &m_clsidSr32);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    //Create Doc and Root storage
    m_lpDoc = CSimpleDoc::Create();
        
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++) {

        // Create an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}



SCODE CCreateTest::Cleanup ()
{
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
        delete m_pSite[iIter]; 
    }


    OleUninitialize();
    return S_OK;
}


//**********************************************************************
//
// CCreateTest::Run
//
// Purpose:
//      This is the work horse routine which calls OLE apis.
//      The profile is done by calling OleCreate on Sr32test and SvrOutl.
//      We get results for different FormatEtc types.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CallOleCreate       defined below
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



SCODE CCreateTest::Run ()
{
        CStopWatch  sw;
        BOOL        fRet;

        fRet = CallOleCreate(m_clsidSr32, m_pSite, IID_IOleObject, 
                            NULL, NULL, m_ulIterations, m_ulOleCreateSr32);
        fRet = CallOleCreate(m_clsidOutl, m_pSite, IID_IOleObject, NULL, NULL, 
                            m_ulIterations, m_ulOleCreateOutl);

        fRet = CallOleCreate(m_clsidSr32, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulOleCreateRenderDrawSr32);
        fRet = CallOleCreate(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulOleCreateRenderDrawOutl);

        //Create the objects with RenderFormat = Metafile

        FORMATETC fmte = {CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT};
        fRet = CallOleCreate(m_clsidSr32, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatMFSr32);
        fRet = CallOleCreate(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_FORMAT,  
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatMFOutl);


        //Create the objects with RenderFormat = Bitmap
        fmte.cfFormat = CF_BITMAP;
        fmte.dwAspect = DVASPECT_CONTENT;
        fmte.tymed    = TYMED_GDI;
        fRet = CallOleCreate(m_clsidSr32, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatBMSr32);
        fRet = CallOleCreate(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_FORMAT,  
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatBMOutl);

        //Create the objects with RenderFormat = Text
        fmte.cfFormat = CF_TEXT;
        fmte.dwAspect = DVASPECT_CONTENT;
        fmte.tymed    = TYMED_HGLOBAL;
        fRet = CallOleCreate(m_clsidSr32, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatTextSr32);
        fRet = CallOleCreate(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_FORMAT,  
                            &fmte, m_ulIterations, m_ulOleCreateRenderFormatTextOutl);

    return S_OK;
}                      



SCODE CCreateTest::Report (CTestOutput &output)
{
//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("Create Apis\t\t"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate  Sr32test \t\t\t"), m_ulIterations, m_ulOleCreateSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate  Outline\t\t\t "), m_ulIterations, m_ulOleCreateOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate  with RenderDraw Sr32test \t"), m_ulIterations, m_ulOleCreateRenderDrawSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate  with RenderDraw Outline \t "), m_ulIterations, m_ulOleCreateRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate with RenderFormatMF Sr32test \t"), m_ulIterations, m_ulOleCreateRenderFormatMFSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate  with RenderFormatMF Outline \t "), m_ulIterations, m_ulOleCreateRenderFormatMFOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate with RenderFormatBM Sr32test \t"), m_ulIterations, m_ulOleCreateRenderFormatBMSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate with RenderFormatBM Outline \t "), m_ulIterations, m_ulOleCreateRenderFormatBMOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate with RenderFormatTxt Sr32test\t "), m_ulIterations, m_ulOleCreateRenderFormatTextSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreate with RenderFormatTxt Outline\t "), m_ulIterations, m_ulOleCreateRenderFormatTextOutl);
    output.WriteString (TEXT("\n"));

    return S_OK;
}
    
    




//**********************************************************************
//
// CallOleCreate
//
// Purpose:
//      Calls OleCreate to create the object and then destroys them.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleCreate       OLE2 api - Is profiled here
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



BOOL CallOleCreate(REFCLSID rclsid, CSimpleSite * pSite[], REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, ULONG ulIterations, ULONG uOleCreatetime[])
{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;

    for ( iIter=0; iIter<ulIterations; iIter++)
        {
        HEAPVALIDATE();
        sw.Reset();
        hres = OleCreate(rclsid, riid, renderopt, pFormatEtc, 
                         &pSite[iIter]->m_OleClientSite,
                         pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);

        GetTimerVal(uOleCreatetime[iIter]);
        LOGRESULTS (TEXT("OleCreate "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        }

    //CleanUp before going to Next
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();

#ifdef REVIEW //BIG REVIEW I am keeping same ClientSIte and Reusing
         //delete pSite[iIter]; 
#endif
        }
    return TRUE;

error:
    if (hres != NOERROR)
        Log (TEXT("Routine CallOleCreate failed with hres = "), hres);
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\bm_link.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:        bm_Link.cxx
//
//  Contents:    Profile methods which manipulate Links, i.e. interface IOleLink
//
//  Classes:    CIOLTest
//
//  Functions:    
//
//  History:    
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_link.hxx"


//**********************************************************************
//
// CIOLTest::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CIOLTest. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *CIOLTest::Name ()
{
    return TEXT("IOLTest");
}



SCODE CIOLTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif
    
#ifndef STRESS 
    //    initialize timing arrays
    INIT_LINKRESULTS(m_ulOleLinkSr32);
    INIT_LINKRESULTS(m_ulOleLinkOutl);

#endif

    sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
    Log (TEXT("Setup - OleInitialize failed."), sc);
    return    sc;
    }

    hres = CLSIDFromString(L"Sr32test", &m_clsidSr32);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    //CreateLink Doc and Root Storage
    m_lpDoc = CSimpleDoc::Create();
        
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
        {
        // CreateLink an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}


SCODE CIOLTest::Cleanup ()
{

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
        delete m_pSite[iIter]; 
    }


    OleUninitialize();
    return S_OK;
}


//**********************************************************************
//
// CIOLTest::Run
//
// Purpose:
//      This is the work horse routine which calls OLE apis.
//      The profile is done by creating moniker then calling OleCreateLink  on moniker.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CallOleCreate       defined below
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



SCODE CIOLTest::Run ()
{
    CStopWatch  sw;
    BOOL        fRet;

    TCHAR       szTemp[MAX_PATH];
    OLECHAR     szSr2FileName[MAX_PATH];
    OLECHAR     szOutlFileName[MAX_PATH];


    GetCurrentDirectory (MAX_PATH, szTemp);
    swprintf(szSr2FileName,
#ifdef UNICODE
                L"%s\\foo.sr2",
#else
                L"%S\\foo.sr2",
#endif
                szTemp);
    swprintf(szOutlFileName,
#ifdef UNICODE
                L"%s\\foo.oln",
#else
                L"%S\\foo.oln",
#endif
                szTemp);

    fRet = CallOleLinkMethods(szSr2FileName, m_pSite, m_ulIterations, 
                                m_ulOleLinkSr32, L"OTS001", L"OTS002");
    fRet = CallOleLinkMethods(szOutlFileName, m_pSite, m_ulIterations, 
                                m_ulOleLinkOutl, L"Name1", L"Name2");

    return S_OK;
}                      



SCODE CIOLTest::Report (CTestOutput &output)
{

//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("IOleLink Methods"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));

    output.WriteString (TEXT("\n"));
    WriteLinkOutput(output, TEXT(" Sr32test "), m_ulOleLinkSr32, m_ulIterations);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("******************************************\n"));
    WriteLinkOutput (output, TEXT(" Outline "), m_ulOleLinkOutl, m_ulIterations);
    output.WriteString (TEXT("\n"));

    return S_OK;
}
    
    


//**********************************************************************
//
// CallOleCreateLink
//
// Purpose:
//      Calls OleCreateLink to create the link and then destroys them.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CreateFileMoniker      OLE2 api 
//      OleCreateLink          OLE2 api - Is profiled here
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



BOOL CallOleLinkMethods(LPCOLESTR lpFileName, CSimpleSite * pSite[], 
        ULONG ulIterations, LinkTimes IOLTime[],  LPCOLESTR lpNm1, LPCOLESTR lpNm2)
{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;
    LPMONIKER   pmk = NULL;
    BOOL        retVal = FALSE;
#ifdef STRESS
    LPOLELINK   pLink[STRESSCOUNT] = { NULL };
#else
    LPOLELINK   pLink[TEST_MAX_ITERATIONS] = { NULL };
#endif

    //
    //Create the Links and also cache link pointer for rest of the tests
    //this pointer is reqd for all the tests later
    //
    for ( iIter=0; iIter<ulIterations; iIter++)
        {
        HEAPVALIDATE() ;
        if (!pSite[iIter])
            goto error;
        hres = OleCreateLinkToFile(lpFileName,
                                    IID_IOleObject,
                                    OLERENDER_DRAW,
                                    NULL,
                                    &pSite[iIter]->m_OleClientSite,
                                    pSite[iIter]->m_lpObjStorage,
                                    (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject
                                    );
        if (hres != NOERROR)
            goto error;

        //Cache IOleLink pointer for rest of the tests that follow below
        hres = pSite[iIter]->m_lpOleObject->QueryInterface(IID_IOleLink, (LPVOID FAR*)&pLink[iIter]);
        if (hres != NOERROR)
            goto error;
        }

    //
    //Run those tests which deal with simple running
    //
    CallOleLinkRunMethods(IOLTime, pLink, ulIterations);

    //
    //Call those tests that deal with SourceDisplayName
    //
    CallOleLinkDisplayName(IOLTime, pLink, lpFileName,
                            lpNm1, lpNm2, ulIterations);


    retVal = TRUE;
error:
    if (hres != NOERROR)
        Log (TEXT("Routine CallOleCreateLink failed with hres = "), hres);

    //CleanUp before going to Next
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        if (pLink[iIter])
            pLink[iIter]->Release();
        if (pSite[iIter])
            pSite[iIter]->UnloadOleObject();
        }

    return retVal;
}



BOOL CallOleLinkRunMethods(LinkTimes IOLTime[], LPOLELINK pLink[], ULONG ulIterations)
{
    HRESULT     hres;
    CStopWatch  sw;
    ULONG       iIter;
    BOOL        retVal = FALSE;
    LPBINDCTX   pBindCtx = NULL;

    //
    //1. get the first estimates using NULL BindCtx
    //
    for ( iIter=0; iIter< ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->BindToSource(NULL /* !BIND_EVEN_IF_CLASSDIF */,
                                   NULL /*Bind Ctx*/);
        GetTimerVal(IOLTime[iIter].ulBindToSourceNull);
        LOGRESULTS (TEXT("IOL:BindToSource "), hres);
        } //End Bind To Source with Null BindCtx

    //Unbind links to start next estimates. Which also BindToSource with Non 
    //NULL BindCtx
    for ( iIter=0; iIter< ulIterations; iIter++)
        {
        hres = pLink[iIter]->UnbindSource();
        } 

    //
    //2. Following tests are to be done with BindContext that we get here
    //
    hres = CreateBindCtx(NULL, &pBindCtx);
    if (hres != NOERROR)
        goto error;
    //Now get the Estimates when Binding with same BindContext
    //
    for ( iIter=0; iIter< ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->BindToSource(NULL /* !BIND_EVEN_IF_CLASSDIF */,
                                   pBindCtx /*Bind Ctx*/);
        GetTimerVal(IOLTime[iIter].ulBindToSourceBindCtx);
        LOGRESULTS (TEXT("IOL:BindToSource  "), hres);
        } //End Bind To Source with BindCtx


    //
    //3. Get Estimates for IOL:BindIfRunning
    //
    for ( iIter=0; iIter<ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->BindIfRunning();
        GetTimerVal(IOLTime[iIter].ulBindIfRunning);
        LOGRESULTS (TEXT("IOL:BindIfRunning "), hres);
        } //End BindIfRunning, when actually running.


    //
    //4. Get Estimates for IOL:UnbindSource    
    //
    for ( iIter=0; iIter<ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->UnbindSource();
        GetTimerVal(IOLTime[iIter].ulUnbindSource);
        LOGRESULTS (TEXT("IOL:UnbindSource "), hres);
        sw.Reset();
        hres = pLink[iIter]->UnbindSource();
        GetTimerVal(IOLTime[iIter].ulUnbindSource2);
        LOGRESULTS (TEXT("IOL:UnbindSource2 "), hres);
        } 
    //
    //5. Get Estimates for IOL:BindIfRunning
    //
    for ( iIter=0; iIter<ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->BindIfRunning();
        GetTimerVal(IOLTime[iIter].ulBindIfRunning2);
        LOGRESULTS (TEXT("IOL:BindIfRunning2 "), hres);
        } //End BindIfRunning, when not running.
    //
    //6. Get Estimates for IOL:UnbindSource    
    //
    for ( iIter=0; iIter<ulIterations; iIter++) 
        {
        sw.Reset();
        hres = pLink[iIter]->UnbindSource();
        GetTimerVal(IOLTime[iIter].ulUnbindSource3);
        LOGRESULTS (TEXT("IOL:UnbindSource3 "), hres);
        } 

    retVal = TRUE;

error:
    if (pBindCtx)
        pBindCtx->Release();
    return hres;
}
    



//**********************************************************************
//
// CallOleLinkDisplayName
//
// Purpose:
//      Calls 
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleLoad               OLE2 api 
//      OleSave               OLE2 api
//
//
// Comments:
//          
//
//********************************************************************

BOOL CallOleLinkDisplayName(LinkTimes IOLTime[], LPOLELINK pLink[],
                            LPCOLESTR lpFileName, LPCOLESTR lpNm1, 
                            LPCOLESTR lpNm2, ULONG ulIterations)
{
    CStopWatch  sw;
    HRESULT     hres;
    HRESULT     hres2;
    ULONG       iIter;
    BOOL        retVal = FALSE;
    OLECHAR     szMkName1[256];
    OLECHAR     szMkName2[256];
    LPBINDCTX   pBindCtx = NULL;

    //
    //Set the display name to something known and then call IOL:SetDisplayName
    //Then update the link so that rest of its info is now updated by OLE.
    //

    // This code used to grab the moniker from the link, compose with an item
    // moniker and then the displayname from the composite moniker.  This
    // works, although it's rather convoluted, the first time but then the
    // code would end up doing it a second time and the first item moniker
    // name would still be on the end and it would fail.  Just creating the
    // new display name ourselves seems much easier anyway.
    //
    //First get the Moniker Name by following routine 
    //hres = GetLinkCompositeName(pLink[0], lpNm1, &lpMkName1);
    //if (hres != NOERROR)
    //    goto error;

    swprintf(szMkName1, L"%s!%s", lpFileName, lpNm1);

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Read();
        hres = pLink[iIter]->SetSourceDisplayName(szMkName1);
        hres2 = pLink[iIter]->Update(NULL);
        GetTimerVal(IOLTime[iIter].ulUpdateNull);
        LOGRESULTS (TEXT("IOL:SetSourceDisplayName "), hres);
        LOGRESULTS (TEXT("IOL:Update "), hres2);

        } //End SetSourceDisplayName and Update


    //
    //Repeate the iteration when we have BindContext available. Check the 
    //results.
    //
    //hres = GetLinkCompositeName(pLink[0], lpNm2, &lpMkName2);
    //if (hres != NOERROR)
    //    goto error;

    swprintf(szMkName2, L"%s!%s", lpFileName, lpNm2);

    hres = CreateBindCtx(NULL, &pBindCtx);
    if (hres != NOERROR)
        goto error;

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Read();
        hres = pLink[iIter]->SetSourceDisplayName(szMkName2);
        hres2 = pLink[iIter]->Update(pBindCtx);
        GetTimerVal(IOLTime[iIter].ulUpdateBindCtx);
        LOGRESULTS (TEXT("IOL:SetSourceDisplayName "), hres);
        LOGRESULTS (TEXT("IOL:Update "), hres2);

        } //End SetSourceDisplayName and Update


    retVal = TRUE;

error:
    if (pBindCtx)
        pBindCtx->Release();

return retVal;
}

HRESULT GetLinkCompositeName(LPOLELINK lpLink, LPCOLESTR lpItem,  LPOLESTR FAR* lpComposeName)
{
    HRESULT     hres;
    LPMONIKER   lpLinkMon = NULL;
    LPMONIKER   lpItemMk = NULL;
    LPMONIKER   lpCompose = NULL;
    //SInce NULL BindContext not allowed any more
    LPBINDCTX   pBindCtx = NULL;

    //Get the source moniker of the link
    hres = lpLink->GetSourceMoniker(&lpLinkMon);
    if (hres != NOERROR)
        goto error;
    //Create item moniker from String Item
    hres = CreateItemMoniker(L"!", lpItem, &lpItemMk);
    if (hres != NOERROR)
        goto error;

    //Ask moniker to compose itself with another one in the end to get Composite
    //moniker.
    hres = lpLinkMon->ComposeWith(lpItemMk, FALSE, &lpCompose);
    if (hres != NOERROR)
        goto error;

    hres = CreateBindCtx(NULL, &pBindCtx);
    if (hres != NOERROR)
        goto error;
    //Get the display Name of the moniker
    hres = lpCompose->GetDisplayName(pBindCtx /*BindCtx*/, NULL /*pmkToLeft*/, 
                                    lpComposeName);
    if (hres != NOERROR)
        goto error;

error:
    if (lpLinkMon)
        lpLinkMon->Release();
    if (lpItemMk)
        lpItemMk->Release();
    if (lpCompose)
        lpCompose->Release();
    if (pBindCtx)
        pBindCtx->Release();
        

    return hres;
}

void WriteLinkOutput(CTestOutput &output, LPTSTR lpstr, LinkTimes *lnkTimes, ULONG ulIterations)
{
    UINT iIter;

    output.WriteString (TEXT("Name"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("BindToSource (NULL)"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("BindToSource"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("BindIfRunning"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("UnBindSource"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("UnBindSource2"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("BindIfRunning2"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("UnBindSource3"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("Update(NULL)"));
    output.WriteString (lpszTab);
    output.WriteString (TEXT("Update"));
    output.WriteString (TEXT("\n"));

    for (iIter = 0; iIter < ulIterations; iIter++)
        {
        output.WriteString (lpstr);
        output.WriteLong (lnkTimes[iIter].ulBindToSourceNull);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulBindToSourceBindCtx);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulBindIfRunning);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulUnbindSource);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulUnbindSource2);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulBindIfRunning2);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulUnbindSource3);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulUpdateNull);
        output.WriteString (lpszTab);
        output.WriteString (lpszTab);
        output.WriteLong (lnkTimes[iIter].ulUpdateBindCtx);
        output.WriteString (TEXT("\n"));
        }

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\bm_load.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:    bm_Load.cxx
//
//  Contents:    Contains the impl of COleLoadTest which deals with Clipboard related
//              apis.
//
//  Classes:    COleLoadTest
//
//  Functions:    
//
//  History:    
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_Load.hxx"
#include <oleauto.h>


//**********************************************************************
//
// CLoadTest::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CLoadTest. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *COleLoadTest::Name ()
{
    return TEXT("LoadTest");
}


SCODE COleLoadTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif

    //    initialize timing arrays
#ifndef STRESS

    INIT_RESULTS(m_ulEmbedLoadOutl);
    INIT_RESULTS(m_ulEmbedSaveOutl);

    INIT_RESULTS(m_ulEmbedLoadRenderDrawOutl);
    INIT_RESULTS(m_ulEmbedSaveRenderDrawOutl);

    INIT_RESULTS(m_ulEmbedLoadRenderAsisOutl);
    INIT_RESULTS(m_ulEmbedSaveRenderAsisOutl);

    INIT_RESULTS(m_ulLinkLoadOutl);
    INIT_RESULTS(m_ulLinkAndSaveOutl);

    INIT_RESULTS(m_ulLinkLoadRenderDrawOutl);
    INIT_RESULTS(m_ulLinkAndSaveRenderDrawOutl);

    INIT_RESULTS(m_ulStaticAndLoadRenderDrawOutl);
    INIT_RESULTS(m_ulStaticAndSaveRenderDrawOutl);

    INIT_RESULTS(m_ulStaticAndLoadRenderBMOutl);
    INIT_RESULTS(m_ulStaticAndSaveRenderBMOutl);
#endif


    sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
    Log (TEXT("Setup - OleInitialize failed."), sc);
    return    sc;
    }

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    //Create root Doc and STorage for Doc
    m_lpDoc = CSimpleDoc::Create();
        
    //Create Individual Objects and Init the table
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++) {

        // CreateLink an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}


SCODE COleLoadTest::Cleanup ()
{

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
        delete m_pSite[iIter]; 
    }


    OleUninitialize();
    return S_OK;
}


SCODE COleLoadTest::Run ()
{
    CStopWatch  sw;
    BOOL        fRet;

    TCHAR       szTemp[MAX_PATH];
    OLECHAR     szOutlFileName[MAX_PATH];


    //  Get file name of .ini file. if not specified in the command
    //  line, use the default BM.INI in the local directory
    GetCurrentDirectory (MAX_PATH, szTemp);
    swprintf(szOutlFileName,
#ifdef UNICODE
                L"%s\\foo.oln",
#else
                L"%S\\foo.oln",
#endif
                szTemp);

    //
    //Test cases for OleSave and OleLoad on Embedding
    //

    fRet = CallCreateLoadAndSave(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_NONE, 
                            NULL, m_ulIterations, m_ulEmbedLoadOutl, m_ulEmbedSaveOutl );

    fRet = CallCreateLoadAndSave(m_clsidOutl, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulEmbedLoadRenderDrawOutl, m_ulEmbedSaveRenderDrawOutl);

    fRet = CallCreateLoadAndSave(m_clsidOutl,  m_pSite, IID_IOleObject, OLERENDER_ASIS, 
                            NULL, m_ulIterations, m_ulEmbedLoadRenderAsisOutl, m_ulEmbedSaveRenderAsisOutl );
    
    FORMATETC fmte = {CF_BITMAP, NULL, DVASPECT_CONTENT, -1, TYMED_GDI};
    fRet = CallCreateLoadAndSave(m_clsidOutl,  m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulEmbedLoadRenderBMOutl, m_ulEmbedSaveRenderBMOutl );
    //
    //Test cases for OleSave and OleLoad on Links
    //
    fRet = CallLinkLoadAndSave(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_NONE, 
                            NULL, m_ulIterations, m_ulLinkLoadOutl, m_ulLinkAndSaveOutl);
    fRet = CallLinkLoadAndSave(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulLinkLoadRenderDrawOutl, m_ulLinkAndSaveRenderDrawOutl);

    //
    //Test cases for OleSave and OleLoad on Static objects
    //
    fRet = CallStaticLoadAndSave(m_clsidOutl, m_lpDoc, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulStaticAndLoadRenderDrawOutl, m_ulLinkAndSaveRenderDrawOutl);
    //fRet = CallStaticLoadAndSave(m_clsidOutl, m_lpDoc, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
    //                        &fmte, m_ulIterations, m_ulStaticAndLoadRenderBMOutl, m_ulStaticAndSaveRenderBMOutl);
    return S_OK;
}                      



SCODE COleLoadTest::Report (CTestOutput &output)
{
//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("Load Apis"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleLoad Embedding \t\t  "), m_ulIterations, m_ulEmbedLoadOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave  Embedding  \t\t"), m_ulIterations, m_ulEmbedSaveOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleLoad Embedding with RenderDraw \t"), m_ulIterations, m_ulEmbedLoadRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave Embedding with RenderDraw \t"), m_ulIterations, m_ulEmbedSaveRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleLoad Embedding with RenderFormatBM Outline \t"), m_ulIterations, m_ulEmbedLoadRenderBMOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave  with RenderFormatBM \t\t "), m_ulIterations, m_ulEmbedLoadRenderBMOutl);
    output.WriteString (TEXT("\n"));


    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleLoad  Embedding with RenderAsIs \t "), m_ulIterations, m_ulEmbedLoadRenderAsisOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave Embedding with RenderAsIs   \t"), m_ulIterations, m_ulEmbedLoadRenderAsisOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("***************************************\n"));
    output.WriteResults (TEXT("OleLoad Link  Outline   \t\t  "), m_ulIterations, m_ulLinkLoadOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave Link  Outline    \t\t "), m_ulIterations, m_ulLinkAndSaveOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleLoad Link with RenderDraw \t\t"), m_ulIterations, m_ulLinkLoadRenderDrawOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleSave Link with RenderDraw Outline  \t"), m_ulIterations, m_ulLinkAndSaveRenderDrawOutl);
    output.WriteString (TEXT("\n"));
    output.WriteString (TEXT("***************************************\n"));
    output.WriteResults (TEXT("OleCreateStaticAndLoad  Outline   \t  "), m_ulIterations, m_ulStaticAndLoadRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateStaticAndLoad  with RenderDraw Outline \t"), m_ulIterations, m_ulStaticAndLoadRenderBMOutl);
    output.WriteString (TEXT("\n"));


    return S_OK;
}
    
//**********************************************************************
//
// CallCreateLoadAndSave
//
// Purpose:
//      Calls OleCreate to create the object and then 
//      call OleLoad and OleSave to get the performance results on them.        
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleCreate               OLE2 api 
//      LoadAndSave             routine defined in this file
//
//
// Comments:
//          
//
//********************************************************************


BOOL CallCreateLoadAndSave(REFCLSID rclsid, CSimpleSite * pSite[], REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, ULONG ulIterations, 
                ULONG uOleLoadtime[], ULONG uOleSavetime[])
{
        HRESULT     hres;
        ULONG       iIter;
        BOOL        retVal = FALSE;

        //Create the objects 
        for ( iIter=0; iIter<ulIterations; iIter++) {

            //If we have not had any problem then 
            HEAPVALIDATE() ;
            hres = OleCreate(rclsid, riid, renderopt, pFormatEtc, 
                             &pSite[iIter]->m_OleClientSite,
                             pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);

            if (hres != NOERROR)
                goto error;
            
            }

        //Now call Appropriate routines to Save and Load the objects
        LoadAndSave( pSite, ulIterations, uOleLoadtime, uOleSavetime);
                
        retVal = TRUE;

error:

    if (hres != NOERROR)
        Log (TEXT("Routine CallCreateLoadAndSave failed with hres = "), hres);

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }

return retVal;
}

BOOL CallLinkLoadAndSave(LPCOLESTR lpFileName, CSimpleSite * pSite[], REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, ULONG ulIterations, 
                ULONG uOleLoadtime[], ULONG uOleSavetime[])
{
        HRESULT     hres;
        ULONG       iIter;
        BOOL        retVal = FALSE;

        //Create the objects 
        for ( iIter=0; iIter<ulIterations; iIter++) {

            //If we have not had any problem then 
            HEAPVALIDATE() ;
            hres = OleCreateLinkToFile(lpFileName, riid, renderopt, pFormatEtc, 
                             &pSite[iIter]->m_OleClientSite,
                             pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);

            if (hres != NOERROR)
                goto error;
            
            }

        //Now call Appropriate routines to Save and Load the objects
        LoadAndSave( pSite, ulIterations, uOleLoadtime, uOleSavetime);
                
        retVal = TRUE;

error:

    if (hres != NOERROR)
        Log (TEXT("Routine CallCreateLoadAndSave failed with hres = "), hres);

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }

return retVal;
}

//**********************************************************************
//
// LoadAndSave
//
// Purpose:
//      Calls OleLoad and OleSave on the object and timing results.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleLoad               OLE2 api 
//      OleSave               OLE2 api
//
//
// Comments:
//          
//
//********************************************************************

BOOL LoadAndSave(CSimpleSite * pSite[], ULONG ulIterations, 
                ULONG uOleLoadtime[], ULONG uOleSavetime[])
{
    LPPERSISTSTORAGE pStg = NULL;
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;
    BOOL        retVal = FALSE;

    //Save the objects
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        hres = pSite[iIter]->m_lpOleObject->QueryInterface(IID_IPersistStorage, 
                                                        (LPVOID FAR*)&pStg);
        if (hres != NOERROR)
            goto error;

        sw.Reset();
        hres = OleSave(pStg, pSite[iIter]->m_lpObjStorage, TRUE);
        GetTimerVal(uOleSavetime[iIter]);

        LOGRESULTS (TEXT("OleSave "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        pStg->Release();
        pStg = NULL;

        }


    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }

    //Load the objects
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        sw.Reset();
        hres = OleLoad( pSite[iIter]->m_lpObjStorage, IID_IOleObject, 
                       &pSite[iIter]->m_OleClientSite, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);

        GetTimerVal(uOleLoadtime[iIter]);
        LOGRESULTS (TEXT("OleLoad "), hres);
        }


    retVal = TRUE;

error:
    if (hres != NOERROR)
        Log (TEXT("Routine LoadAndSave failed with hres = "), hres);
    if (pStg)
        pStg->Release();

return retVal;
}


//**********************************************************************
//
// CallStaticLoadAndSave
//
// Purpose:
//      Calls OleCreateStaticFromDara to create the object and then 
//      call OleLoad and OleSave to get the performance results on them.        
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      OleCreate               OLE2 api 
//      OleCreateStaticFromData OLE2 api 
//      LoadAndSave             routine defined in this file
//
//
// Comments:
//          In this case we call OleCreateStaticFromData from data object
//          given by application.
//
//********************************************************************



BOOL CallStaticLoadAndSave(REFCLSID rclsid, CSimpleDoc FAR * m_lpDoc, CSimpleSite * pSite[], 
                REFIID riid, DWORD renderopt, LPFORMATETC pFormatEtc, ULONG ulIterations, 
                ULONG uOleLoadtime[], ULONG uOleSavetime[])
{
        HRESULT     hres;
        ULONG       iIter;
        BOOL        retVal = FALSE;
        LPDATAOBJECT pDO = NULL;
        CSimpleSite* pTempSite = CSimpleSite::Create(m_lpDoc, -1); //-1 is unique in this case

        //Create the ole object and ask for IID_IDataObject interface
        hres = OleCreate(rclsid, IID_IOleObject, renderopt, pFormatEtc, 
                         &pTempSite->m_OleClientSite,
                         pTempSite->m_lpObjStorage, (VOID FAR* FAR*)&pTempSite->m_lpOleObject);

        if (hres != NOERROR)
            goto error;
        hres = pTempSite->m_lpOleObject->QueryInterface(IID_IDataObject, (LPVOID FAR*)&pDO);
        if (hres != NOERROR)
            goto error;

        //Create the static objects from pDO 
        for ( iIter=0; iIter<ulIterations; iIter++) {
            hres = OleCreateStaticFromData(pDO, riid, renderopt, pFormatEtc,
                                    &pSite[iIter]->m_OleClientSite, pSite[iIter]->m_lpObjStorage, 
                                    (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);
                                            
            if (hres != NOERROR)
                goto error;

            HEAPVALIDATE() ;
            }

        //Now call Appropriate routines to Save and Load the objects
        LoadAndSave( pSite, ulIterations, uOleLoadtime, uOleSavetime);
                
        retVal = TRUE;

error:

    if (hres != NOERROR)
        Log (TEXT("Routine CallCreateLoadAndSave failed with hres = "), hres);

    if (pDO)
        pDO->Release();

    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }

    if (pTempSite) //this should also release the object
        {
        pTempSite->UnloadOleObject();
        //delete pTempSite;
        }

return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\bm_crtl.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:    bm_crtl.cxx
//
//  Contents:    CreateLink apis
//
//  Classes:    CCreateLinkApi
//
//  Functions:    
//
//  History:    
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "hlp_util.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"
#include "bm_crtl.hxx"


//**********************************************************************
//
// CCreateLinkTest::Name, SetUp, Run, CleanUp
//
// Purpose:
//
//      These routines provide the implementation for the Name, Setup,
//      Run and CleanUp of the class CCreateLinkTest. For details see the doc 
//      for driver what are these routines supposed to do.
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
//
// Comments:
//      If STRESS is defined don't do anything with timer variable! We are
//      not  interested in time values.
//
//********************************************************************


TCHAR *CCreateLinkTest::Name ()
{
    return TEXT("CreateLinkTest");
}



SCODE CCreateLinkTest::Setup (CTestInput *pInput)
{
    CTestBase::Setup(pInput);
    HRESULT sc;
    HRESULT hres;

#ifdef STRESS
    //If stress condition loop number of time = STRESSCOUNT
    m_ulIterations = STRESSCOUNT;
#else
    //    get iteration count
    m_ulIterations = pInput->GetIterations(Name());
#endif
    
#ifndef STRESS
    //    initialize timing arrays
    INIT_RESULTS(m_ulOleCreateLinkSr32);
    INIT_RESULTS(m_ulOleCreateLinkOutl);
    INIT_RESULTS(m_ulOleCreateLinkRenderDrawSr32);
    INIT_RESULTS(m_ulOleCreateLinkRenderDrawOutl);

#endif

    sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
    Log (TEXT("Setup - OleInitialize failed."), sc);
    return    sc;
    }

    hres = CLSIDFromString(L"Sr32test", &m_clsidSr32);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    hres = CLSIDFromString(OutlineClassName, &m_clsidOutl);
    Log (TEXT("CLSIDFromString returned ."), hres);
    if (hres != NOERROR)
        return E_FAIL;

    //CreateLink Doc and Root Storage
    m_lpDoc = CSimpleDoc::Create();
        
    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
        {
        // CreateLink an instance of Site
        CSimpleSite *pObj  =  CSimpleSite::Create(m_lpDoc, iIter);
        if (pObj)
            m_pSite[iIter] = pObj;
        }
    
    return sc;
}


SCODE CCreateLinkTest::Cleanup ()
{

    for (ULONG iIter=0; iIter<m_ulIterations; iIter++)
    {
        delete m_pSite[iIter]; 
    }

    OleUninitialize();
    return S_OK;
}


//**********************************************************************
//
// CCreateLinkTest::Run
//
// Purpose:
//      This is the work horse routine which calls OLE apis.
//      The profile is done by creating moniker then calling OleCreateLink  on moniker.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CallOleCreateLink       defined below
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



SCODE CCreateLinkTest::Run ()
{
    CStopWatch  sw;
    BOOL        fRet;

    TCHAR       szTemp[MAX_PATH];
    OLECHAR     szSr2FileName[MAX_PATH];
    OLECHAR     szOutlFileName[MAX_PATH];


    //  Get file name of .ini file. if not specified in the command
    //  line, use the default BM.INI in the local directory

    GetCurrentDirectory (MAX_PATH, szTemp);
    swprintf(szSr2FileName,
#ifdef UNICODE
                L"%s\\foo.sr2",
#else
                L"%S\\foo.sr2",
#endif
                szTemp);
    swprintf(szOutlFileName,
#ifdef UNICODE
                L"%s\\foo.oln",
#else
                L"%S\\foo.oln",
#endif
                szTemp);

    fRet = CallOleCreateLink(szSr2FileName, m_pSite, IID_IOleObject, NULL, 
                            NULL, m_ulIterations, m_ulOleCreateLinkSr32);
    fRet = CallOleCreateLink(szOutlFileName, m_pSite, IID_IOleObject, NULL, 
                            NULL, m_ulIterations, m_ulOleCreateLinkOutl);

    fRet = CallOleCreateLink(szSr2FileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulOleCreateLinkRenderDrawSr32);
    fRet = CallOleCreateLink(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_DRAW, 
                            NULL, m_ulIterations, m_ulOleCreateLinkRenderDrawOutl);

    //Create the objects with RenderFormat = Metafile
    FORMATETC fmte = {CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT};
    fRet = CallOleCreateLink(szSr2FileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateLinkRenderFormatMFSr32);
    fRet = CallOleCreateLink(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT,  
                            &fmte, m_ulIterations, m_ulOleCreateLinkRenderFormatMFOutl);

    //Create the objects with RenderFormat = Bitmap
    fmte.cfFormat = CF_BITMAP;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.tymed    = TYMED_GDI;
    fRet = CallOleCreateLink(szSr2FileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateLinkRenderFormatBMSr32);

    //Create the objects with RenderFormat = Text
    fmte.cfFormat = CF_TEXT;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.tymed    = TYMED_HGLOBAL;
    fRet = CallOleCreateLink(szSr2FileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT, 
                            &fmte, m_ulIterations, m_ulOleCreateLinkRenderFormatTextSr32);
    fRet = CallOleCreateLink(szOutlFileName, m_pSite, IID_IOleObject, OLERENDER_FORMAT,  
                            &fmte, m_ulIterations, m_ulOleCreateLinkRenderFormatTextOutl);


    return S_OK;
}                      



SCODE CCreateLinkTest::Report (CTestOutput &output)
{
//Bail out immediately on STRESS because none of the following variables
//will have sane value
#ifdef STRESS
    return S_OK;
#endif

    output.WriteString (TEXT("*************************************************\n"));
    output.WriteSectionHeader (Name(), TEXT("CreateLink Apis"), *m_pInput);
    output.WriteString (TEXT("*************************************************\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink  Sr32test\t\t\t"), m_ulIterations, m_ulOleCreateLinkSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink  Outline \t\t\t"), m_ulIterations, m_ulOleCreateLinkOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderDraw Sr32test\t"), m_ulIterations, m_ulOleCreateLinkRenderDrawSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderDraw Outline\t"), m_ulIterations, m_ulOleCreateLinkRenderDrawOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderFormatMF Sr32test\t"), m_ulIterations, m_ulOleCreateLinkRenderFormatMFSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderFormatMF Outline\t"), m_ulIterations, m_ulOleCreateLinkRenderFormatMFOutl);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderFormatBM Sr32test\t "), m_ulIterations, m_ulOleCreateLinkRenderFormatBMSr32);
    output.WriteString (TEXT("\n"));

#ifdef DOESNOTWORKFOROUTLINE
    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderFormatBM Outline\t"), m_ulIterations, m_ulOleCreateLinkRenderFormatBMOutl);
    output.WriteString (TEXT("\n"));
#endif

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink with RenderFormatTxt Sr32test\t"), m_ulIterations, m_ulOleCreateLinkRenderFormatTextSr32);
    output.WriteString (TEXT("\n"));

    output.WriteString (TEXT("\n"));
    output.WriteResults (TEXT("OleCreateLink  with RenderFormatTxt Outline\t "), m_ulIterations, m_ulOleCreateLinkRenderFormatTextOutl);
    output.WriteString (TEXT("\n"));

    return S_OK;
}
    
    


//**********************************************************************
//
// CallOleCreateLink
//
// Purpose:
//      Calls OleCreateLink to create the link and then destroys them.
//      
//
// Parameters:
//
//      
// Return Value:
//
//      None
//
// Functions called:
//      CreateFileMoniker      OLE2 api 
//      OleCreateLink          OLE2 api - Is profiled here
//
//
// Comments:
//          Need to add more Server types including In-Proc servers.
//
//********************************************************************



BOOL CallOleCreateLink(LPCOLESTR lpFileName, CSimpleSite * pSite[], REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, ULONG ulIterations, ULONG uOleCreateLinktime[])
{
    CStopWatch  sw;
    HRESULT     hres;
    ULONG       iIter;
    LPMONIKER   pmk = NULL;
    BOOL        retVal = FALSE;

    hres = CreateFileMoniker(lpFileName, &pmk);
    if (hres != NOERROR)
            goto error;

    for ( iIter=0; iIter<ulIterations; iIter++)
        {
        HEAPVALIDATE() ;
        sw.Reset();
        hres = OleCreateLink(pmk, riid, renderopt, pFormatEtc, &pSite[iIter]->m_OleClientSite,
                            pSite[iIter]->m_lpObjStorage, (VOID FAR* FAR*)&pSite[iIter]->m_lpOleObject);
        GetTimerVal(uOleCreateLinktime[iIter]);

        LOGRESULTS (TEXT("OleCreateLink "), hres);
        if (hres != NOERROR)
            {
            goto error;
            }
        }

    //CleanUp before going to Next
    for (iIter=0; iIter<ulIterations; iIter++)
        {
        // Unload the object and release the Ole Object
        pSite[iIter]->UnloadOleObject();
        }
    retVal = TRUE;

error:
    if (hres != NOERROR)
        Log (TEXT("Routine CallOleCreateLink failed with hres = "), hres);

    if (pmk)
        pmk->Release();
    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\hlp_iocs.cxx ===
//**********************************************************************
// File name: HLP_IOCS.cxx
//
//      Implementation file for COleClientSite
//
// Functions:
//
//      See IOCS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include <headers.cxx>
#pragma hdrstop

#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"


//**********************************************************************
//
// COleClientSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at this interface
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      E_NOINTERFACE       -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleSite::QueryInterface SITE.cxx
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	DEBUGOUT(L"In IOCS::QueryInterface\r\n");

        HEAPVALIDATE();

	// delegate to the container Site
	return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the interface level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::AddRef()
{
	DEBUGOUT(L"In IOCS::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the container Site
	return m_pSite->AddRef();
}


//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::Release()
{
	DEBUGOUT(L"In IOCS::Release\r\n");

	// decrement the interface reference count (for debugging only)
	--m_nCount;

	// delegate to the container Site
	return m_pSite->Release();
}

//**********************************************************************
//
// COleClientSite::SaveObject
//
// Purpose:
//
//      Called by the object when it wants to be saved to persistant
//      storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      OutputDebugString                   Windows API
//      IOleObject::QueryInterface          Object
//      IPersistStorage::SaveCompleted      Object
//      IPersistStorage::Release            Object
//      OleSave                             OLE API
//      ResultFromScode                     OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::SaveObject()
{
	LPPERSISTSTORAGE lpPS;
	SCODE sc = E_FAIL;

        HEAPVALIDATE();
	DEBUGOUT(L"In IOCS::SaveObject\r\n");

	// get a pointer to IPersistStorage
	HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(IID_IPersistStorage, (LPVOID FAR *)&lpPS);

	// save the object
	if (hErr == NOERROR)
		{
		sc = GetScode( OleSave(lpPS, m_pSite->m_lpObjStorage, TRUE) );
		lpPS->SaveCompleted(NULL);
		lpPS->Release();
		}

        HEAPVALIDATE();
	return ResultFromScode(sc);
}

//**********************************************************************
//
// COleClientSite::GetMoniker
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
	DEBUGOUT(L"In IOCS::GetMoniker\r\n");

	// need to null the out pointer
	*ppmk = NULL;

        HEAPVALIDATE();
	return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::GetContainer
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
	DEBUGOUT(L"In IOCS::GetContainer\r\n");

	// NULL the out pointer
	*ppContainer = NULL;

	return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::ShowObject
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::ShowObject()
{
	DEBUGOUT(L"In IOCS::ShowObject\r\n");
        HEAPVALIDATE();
	return NOERROR;
}

//**********************************************************************
//
// COleClientSite::OnShowWindow
//
// Purpose:
//
//      Object calls this method when it is opening/closing non-InPlace
//      Window
//
// Parameters:
//
//      BOOL fShow  - TRUE if Window is opening, FALSE if closing
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      InvalidateRect              Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
	DEBUGOUT(L"In IOCS::OnShowWindow\r\n");
	m_pSite->m_fObjectOpen = fShow;
	InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);

	// if object window is closing, then bring container window to top
	if (! fShow) {
		BringWindowToTop(m_pSite->m_lpDoc->m_hDocWnd);
		SetFocus(m_pSite->m_lpDoc->m_hDocWnd);
	}
	return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleClientSite::RequestNewObjectLayout
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::RequestNewObjectLayout()
{
	DEBUGOUT(L"In IOCS::RequestNewObjectLayout\r\n");
	return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\hlp_ias.cxx ===
//**********************************************************************
// File name: HLP_IAS.cxx
//
//      Implementation file of CAdviseSink
//
//
// Functions:
//
//      See IAS.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#include <headers.cxx>
#pragma hdrstop


#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"

//**********************************************************************
//
// CAdviseSink::QueryInterface
//
// Purpose:
//
//      Returns a pointer to a requested interface.
//
// Parameters:
//
//      REFIID riid         - The requested interface
//
//      LPVOID FAR* ppvObj  - Place to return the interface
//
// Return Value:
//
//      HRESULT from CSimpleSite::QueryInterface
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::QueryInterface SITE.cxx
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function simply delegates to the Object class, which is
//      aware of the supported interfaces.
//
//********************************************************************

STDMETHODIMP CAdviseSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	DEBUGOUT(L"In IAS::QueryInterface\r\n");

	// delegate to the document Object
	return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CAdviseSink::AddRef
//
// Purpose:
//
//      Increments the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::AddReff        SITE.cxx
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function adds one to the ref count of the interface,
//      and calls then calls CSimpleSite to increment its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::AddRef()
{
	DEBUGOUT(L"In IAS::AddRef\r\n");

	// increment the interface reference count (for debugging only)
	++m_nCount;

	// delegate to the container Site
	return m_pSite->AddRef();
}

//**********************************************************************
//
// CAdviseSink::Release
//
// Purpose:
//
//      Decrements the reference count on this interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The current reference count on this interface.
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Release        SITE.cxx
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function subtracts one from the ref count of the interface,
//      and calls then calls CSimpleSite to decrement its ref.
//      count.
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::Release()
{
	DEBUGOUT(L"In IAS::Release\r\n");

	// decrement the interface reference count (for debugging only)
	m_nCount--;

	// delegate to the container Site
	return m_pSite->Release();
}

//**********************************************************************
//
// CAdviseSink::OnDataChange
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnDataChange (FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed)
{
	DEBUGOUT(L"In IAS::OnDataChange\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnViewChange
//
// Purpose:
//
//      Notifies us that the view has changed and needs to be updated.
//
// Parameters:
//
//      DWORD dwAspect  - Aspect that has changed
//
//      LONG lindex     - Index that has changed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      InvalidateRect              Windows API
//      IViewObject2::GetExtent     Object
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnViewChange (DWORD dwAspect, LONG lindex)
{
	LPVIEWOBJECT2 lpViewObject2;
	DEBUGOUT(L"In IAS::OnViewChange\r\n");

	// get a pointer to IViewObject2
	HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(
			IID_IViewObject2,(LPVOID FAR *)&lpViewObject2);

	if (hErr == NOERROR) {
		// get extent of the object
		// NOTE: this method will never be remoted; it can be called w/i this async method
		lpViewObject2->GetExtent(DVASPECT_CONTENT, -1 , NULL, &m_pSite->m_sizel);
		lpViewObject2->Release();
	}

	InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);
}

//**********************************************************************
//
// CAdviseSink::OnRename
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnRename (LPMONIKER pmk)
{
	DEBUGOUT(L"In IAS::OnRename\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnSave
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnSave ()
{
	DEBUGOUT(L"In IAS::OnSave\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnClose
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      Not Implemented (needs to be stubbed out)
//
// Return Value:
//
//      Not Implemented (needs to be stubbed out)
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Not Implemented (needs to be stubbed out)
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnClose()
{
	DEBUGOUT(L"In IAS::OnClose\r\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\hlp_app.cxx ===
//**********************************************************************
// File name: hlp_app.cxx
//
//    Implementation file for the CSimpleApp Class
//
// Functions:
//
//    See app.hxx for a list of member functions.
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "hlp_pre.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"

HWND m_hAppWnd;         // main window handle
HINSTANCE m_hInst;          // application instance
CMDIWnd* v_pMDIWnd;
//**********************************************************************
//
// CSimpleApp::CSimpleApp()
//
// Purpose:
//
//      Constructor for CSimpleApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      SetRectEmpty                Windows API
//
// Comments:
//
//      CSimpleApp has a contained COleInPlaceFrame.  On construction
//      of CSimpleApp, we explicitly call the constructor of this
//      contained class and pass a copy of the this pointer, so that
//      COleInPlaceFrame can refer back to this class
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
								// tells us that we are passing this in
								// an initializer, before "this" is through
								// initializing.  This is ok, because
								// we just store the ptr in the other
								// constructor

CSimpleApp::CSimpleApp() : m_OleInPlaceFrame(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
	DEBUGOUT("In CSimpleApp's Constructor \r\n");

	// Set Ref Count
	m_nCount = 0;

	// clear members
	m_hAppWnd = NULL;
	m_hInst = NULL;
	m_lpDoc = NULL;
    m_hwndUIActiveObj = NULL;
    
	// clear flags
	m_fInitialized = FALSE;
	m_fCSHMode = FALSE;
	m_fMenuMode = FALSE;

	// used for inplace
	SetRectEmpty(&nullRect);
}

//**********************************************************************
//
// CSimpleApp::~CSimpleApp()
//
// Purpose:
//
//      Destructor for CSimpleApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      OleUninitialize             OLE API
//
// Comments:
//
//********************************************************************

CSimpleApp::~CSimpleApp()
{
	DEBUGOUT("In CSimpleApp's Destructor\r\n");

	if (m_hStdPal)
		DeleteObject(m_hStdPal);

	// need to uninit the library...
	if (m_fInitialized)
		OleUninitialize();
}

//**********************************************************************
//
// CSimpleApp::DestroyDocs()
//
// Purpose:
//
//      Destroys all of the open documents in the application (Only one
//      since this is an SDI app, but could easily be modified to
//      support MDI).
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************

void CSimpleApp::DestroyDocs()
{
	m_lpDoc->Close();   // we have only 1 document
}

//**********************************************************************
//
// CSimpleApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Frame level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      COleInPlaceFrame::AddRef    IOIPF.cxx
//
// Comments:
//
//      Note that this QueryInterface is associated with the frame.
//      Since the application could potentially have multiple documents
//      and multiple objects, a lot of the interfaces are ambiguous.
//      (ie. which IOleObject is returned?).  For this reason, only
//      pointers to interfaces associated with the frame are returned.
//      In this implementation, Only IOleInPlaceFrame (or one of the
//      interfaces it is derived from) can be returned.
//
//********************************************************************

STDMETHODIMP CSimpleApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	DEBUGOUT("In CSimpleApp::QueryInterface\r\n");

	*ppvObj = NULL;     // must set out pointer parameters to NULL

	// looking for IUnknown
	if ( riid == IID_IUnknown)
		{
		AddRef();
		*ppvObj = this;
		return ResultFromScode(S_OK);
		}

	// looking for IOleWindow
	if ( riid == IID_IOleWindow)
		{
		m_OleInPlaceFrame.AddRef();
		*ppvObj=&m_OleInPlaceFrame;
		return ResultFromScode(S_OK);
		}

	// looking for IOleInPlaceUIWindow
	if ( riid == IID_IOleInPlaceUIWindow)
		{
		m_OleInPlaceFrame.AddRef();
		*ppvObj=&m_OleInPlaceFrame;
		return ResultFromScode(S_OK);
		}

	// looking for IOleInPlaceFrame
	if ( riid == IID_IOleInPlaceFrame)
		{
		m_OleInPlaceFrame.AddRef();
		*ppvObj=&m_OleInPlaceFrame;
		return ResultFromScode(S_OK);
		}

	// Not a supported interface
	return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::AddRef()
{
	DEBUGOUT("In CSimpleApp::AddRef\r\n");
	return ++m_nCount;
}

//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::Release()
{
	DEBUGOUT("In CSimpleApp::Release\r\n");

	if (--m_nCount == 0) {
		delete this;
		return 0;
	}
	return m_nCount;
}

//**********************************************************************
//
// CSimpleApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//
// Comments:
//
//********************************************************************

BOOL CSimpleApp::fInitApplication(HANDLE hInstance)
{
	WNDCLASS  wc;

	// Fill in window class structure with parameters that describe the
	// main window.

	wc.style = NULL;                    // Class style(s).
	wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
										// windows of this class.
	wc.cbClsExtra = 0;                  // No per-class extra data.
	wc.cbWndExtra = 0;                  // No per-window extra data.
	wc.hInstance = hInstance;           // Application that owns the class.
	wc.hIcon = LoadIcon(hInstance, "SimpCntr");
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = GetStockObject(WHITE_BRUSH);
	wc.lpszMenuName =  "SIMPLEMENU";    // Name of menu resource in .RC file.
	wc.lpszClassName = "SimpCntrAppWClass";  // Name used in CreateWindow call

	if (!RegisterClass(&wc))
		return FALSE;

	wc.style = CS_DBLCLKS;              // Class style(s). allow DBLCLK's
	wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
										// windows of this class.
	wc.cbClsExtra = 0;                  // No per-class extra data.
	wc.cbWndExtra = 0;                  // No per-window extra data.
	wc.hInstance = hInstance;           // Application that owns the class.
	wc.hIcon = NULL;
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = GetStockObject(WHITE_BRUSH);
	wc.lpszMenuName =  NULL;
	wc.lpszClassName = "SimpCntrDocWClass"; // Name used in CreateWindow call.

	// Register the window class and return success/failure code.

	return (RegisterClass(&wc));
}

//**********************************************************************
//
// CSimpleApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpleApp::fInitInstance (HANDLE hInstance, int nCmdShow)
{
	DWORD dwVer = OleBuildVersion();
	LPMALLOC lpMalloc = NULL;

	// check to see if we are compatible with this version of the libraries
	if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup) {
#ifdef _DEBUG
		OutputDebugString("WARNING: Incompatible OLE library version\r\n");
#else
		return FALSE;
#endif
	}

#if defined( _DEBUG )
	/* OLE2NOTE: Use a special debug allocator to help track down
	**    memory leaks.
	*/
	OleStdCreateDbAlloc(0, &lpMalloc);
#endif

	if (OleInitialize(lpMalloc) == NOERROR)
		m_fInitialized = TRUE;

#if defined( _DEBUG )
	/* OLE2NOTE: release the special debug allocator so that only OLE is
	**    holding on to it. later when OleUninitialize is called, then
	**    the debug allocator object will be destroyed. when the debug
	**    allocator object is destoyed, it will report (to the Output
	**    Debug Terminal) whether there are any memory leaks.
	*/
	if (lpMalloc) lpMalloc->Release();
#endif

	m_hInst = hInstance;

	// Create the "application" windows
	m_hAppWnd = CreateWindow ("SimpCntrAppWClass",
							  "Simple OLE 2.0 In-Place Container",
							  WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
							  CW_USEDEFAULT,
							  CW_USEDEFAULT,
							  CW_USEDEFAULT,
							  CW_USEDEFAULT,
							  NULL,
							  NULL,
							  hInstance,
							  NULL);

	if (!m_hAppWnd)
		return FALSE;

    m_pMDIWnd = new (CMDIWnd);
    v_pMDIWnd.Create();

	m_hStdPal = OleStdCreateStandardPalette();

	ShowWindow (m_hAppWnd, nCmdShow);
	UpdateWindow (m_hAppWnd);

	return m_fInitialized;
}

//**********************************************************************
//
// CSimpleApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      IOleInPlaceActiveObject::QueryInterface     Object
//      IOleInPlaceObject::ContextSensitiveHelp     Object
//      IOleInPlaceObject::Release                  Object
//      IOleObject::DoVerb                          Object
//      GetClientRect                               Windows API
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      CSimpleDoc::InsertObject                    DOC.cxx
//
// Comments:
//
//********************************************************************

long CSimpleApp::lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	RECT rect;

	// context sensitive help...
	if (m_fMenuMode || m_fCSHMode)
		{
		if (m_fCSHMode)
			{
			// clear context sensitive help flag
			m_fCSHMode = FALSE;

			// if there is an InPlace active object, call its context sensitive help
			// method with the FALSE parameter to bring the object out of the
			// csh state.  See the technotes for details.
			if (m_lpDoc->m_lpActiveObject)
				{
				LPOLEINPLACEOBJECT lpInPlaceObject;
				m_lpDoc->m_lpActiveObject->QueryInterface(IID_IOleInPlaceObject, (LPVOID FAR *)&lpInPlaceObject);
				lpInPlaceObject->ContextSensitiveHelp(FALSE);
				lpInPlaceObject->Release();
				}
			}

		// see the technotes for details on implementing context sensitive
		// help
		if (m_fMenuMode)
			{
			m_fMenuMode = FALSE;

			if (m_lpDoc->m_lpActiveObject)
				m_lpDoc->m_lpActiveObject->ContextSensitiveHelp(FALSE);
			}
		// if we provided help, we would do it here...
		MessageBox (hWnd, "Help", "Help", MB_OK);

		return NULL;
		}

	// see if the command is a verb selections
	if (wParam >= IDM_VERB0)
		{
		// get the rectangle of the object
		m_lpDoc->m_lpSite->GetObjRect(&rect);

		m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(wParam - IDM_VERB0, NULL, &m_lpDoc->m_lpSite->m_OleClientSite, -1, m_lpDoc->m_hDocWnd, &rect);
		}
	else
		{
		switch (wParam) {
			// bring up the About box
			case IDM_ABOUT:
				{
				FARPROC lpProcAbout = MakeProcInstance((FARPROC)About, m_hInst);

				DialogBox(m_hInst,               // current instance
					"AboutBox",                  // resource to use
					m_hAppWnd,                   // parent handle
					lpProcAbout);                // About() instance address

				FreeProcInstance(lpProcAbout);
				break;
				}

			// bring up the InsertObject Dialog
			case IDM_INSERTOBJECT:
				m_lpDoc->InsertObject();
				break;

			// exit the application
			case IDM_EXIT:
				SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
				break;

			case IDM_NEW:
				m_lpDoc->Close();
				m_lpDoc = NULL;
				lCreateDoc(hWnd, 0, 0, 0);
				break;

            case IDM_COPYLINE:
            case IDM_ADDLINE:
            case IDM_UNINDENTLINE:
                m_lpDoc->HandleDispatch(wParam);
                break;


			default:
				//return (DefWindowProc(hWnd, message, wParam, lParam));
				return (DefFrameProc(hWnd, v_pMDIWnd->hwndMDIClient, message, wParam, lParam));
			}   // end of switch
		}  // end of else
	return NULL;
}

//**********************************************************************
//
// CSimpleApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::lResizeDoc      DOC.cxx
//
// Comments:
//
//********************************************************************

long CSimpleApp::lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	RECT rect;

	GetClientRect(m_hAppWnd, &rect);
	return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpleApp::lCreateDoc
//
// Purpose:
//
//      Handles the creation of a document.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::CSimpleDoc      DOC.cxx
//
// Comments:
//
//********************************************************************

long CSimpleApp::lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	RECT rect;

	GetClientRect(hWnd, &rect);

	m_lpDoc = CSimpleDoc::Create(this, &rect, hWnd);

	return NULL;
}

//**********************************************************************
//
// CSimpleApp::AddFrameLevelUI
//
// Purpose:
//
//      Used during InPlace negotiation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                            Location
//
//      COleInPlaceFrame::SetMenu           IOIPF.cxx
//      CSimpleApp::AddFrameLevelTools      APP.cxx
//
// Comments:
//
//      Be sure to read the Technotes included in the OLE 2.0 toolkit
//
//********************************************************************

void CSimpleApp::AddFrameLevelUI()
{
	m_OleInPlaceFrame.SetMenu(NULL, NULL, NULL);
	AddFrameLevelTools();
}

//**********************************************************************
//
// CSimpleApp::AddFrameLevelTools
//
// Purpose:
//
//      Used during InPlace negotiation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                              Location
//
//      COleInPlaceFrame::SetBorderSpace      IOIPF.cxx
//      InvalidateRect                        Windows API
//
// Comments:
//
//      Be sure to read the Technotes included in the OLE 2.0 toolkit
//
//********************************************************************

void CSimpleApp::AddFrameLevelTools()
{
	m_OleInPlaceFrame.SetBorderSpace(&nullRect);
	InvalidateRect(m_hAppWnd, NULL, TRUE);
}

//**********************************************************************
//
// CSimpleApp::HandleAccelerators
//
// Purpose:
//
//      To properly handle accelerators in the Message Loop
//
// Parameters:
//
//      LPMSG lpMsg -   A pointer to the message structure.
//
// Return Value:
//
//      TRUE    -   The accelerator was handled
//      FALSE   -   The accelerator was not handled
//
// Function Calls:
//      Function                                        Location
//
//      IOleInPlaceActiveObject::TranslateAccelerator   Object
//
// Comments:
//
//      If an object is InPlace active, it gets the first shot at
//      handling the accelerators.
//
//********************************************************************

BOOL CSimpleApp::HandleAccelerators(LPMSG lpMsg)
{
	HRESULT hResult;
	BOOL retval = FALSE;

	// if we have an InPlace Active Object
	if (m_lpDoc->m_lpActiveObject)
		{
		// Pass the accelerator on...
		hResult = m_lpDoc->m_lpActiveObject->TranslateAccelerator(lpMsg);
		if (hResult == NOERROR)
			retval = TRUE;
		}

	return retval;
}

//**********************************************************************
//
// CSimpleApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::PaintDoc        DOC.cxx
//
// Comments:
//
//      This is an app level function in case we want to do palette
//      management.
//
//********************************************************************

void CSimpleApp::PaintApp (HDC hDC)
{
	// at this level, we could enumerate through all of the
	// visible objects in the application, so that a palette
	// that best fits all of the objects can be built.

	// This app is designed to take on the same palette
	// functionality that was provided in OLE 1.0, the palette
	// of the last object drawn is realized.  Since we only
	// support one object at a time, it shouldn't be a big
	// deal.

	// if we supported multiple documents, we would enumerate
	// through each of the open documents and call paint.

	if (m_lpDoc)
		m_lpDoc->PaintDoc(hDC);

}

//**********************************************************************
//
// CSimpleApp::ContextSensitiveHelp
//
// Purpose:
//      Used in supporting context sensitive haelp at the app level.
//
//
// Parameters:
//
//      BOOL fEnterMode    -   Entering/Exiting Context Sensitive
//                             help mode.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                    Location
//
//      IOleInPlaceActiveObject::QueryInterface     Object
//      IOleInPlaceObject::ContextSensitiveHelp     Object
//      IOleInPlaceObject::Release                  Object
//
// Comments:
//
//      This function isn't used because we don't support Shift+F1
//      context sensitive help.  Be sure to look at the technotes
//      in the OLE 2.0 toolkit.
//
//********************************************************************

void CSimpleApp::ContextSensitiveHelp (BOOL fEnterMode)
{
	if (m_fCSHMode != fEnterMode)
		{
		m_fCSHMode = fEnterMode;

		// this code "trickles" the context sensitive help via shift+f1
		// to the inplace active object.  See the technotes for implementation
		// details.
		if (m_lpDoc->m_lpActiveObject)
			{
			LPOLEINPLACEOBJECT lpInPlaceObject;
			m_lpDoc->m_lpActiveObject->QueryInterface(IID_IOleInPlaceObject, (LPVOID FAR *)&lpInPlaceObject);
			lpInPlaceObject->ContextSensitiveHelp(fEnterMode);
			lpInPlaceObject->Release();
			}
		}
}


/* OLE2NOTE: forward the WM_QUERYNEWPALETTE message (via
**    SendMessage) to UIActive in-place object if there is one.
**    this gives the UIActive object the opportunity to select
**    and realize its color palette as the FOREGROUND palette.
**    this is optional for in-place containers. if a container
**    prefers to force its color palette as the foreground
**    palette then it should NOT forward the this message. or
**    the container can give the UIActive object priority; if
**    the UIActive object returns 0 from the WM_QUERYNEWPALETTE
**    message (ie. it did not realize its own palette), then
**    the container can realize its palette.
**    (see ContainerDoc_ForwardPaletteChangedMsg for more info)
**
**    (It is a good idea for containers to use the standard
**    palette even if they do not use colors themselves. this
**    will allow embedded object to get a good distribution of
**    colors when they are being drawn by the container)
**
*/

LRESULT CSimpleApp::QueryNewPalette(void)
{
	if (m_hwndUIActiveObj) {
		if (SendMessage(m_hwndUIActiveObj, WM_QUERYNEWPALETTE,
				(WPARAM)0, (LPARAM)0)) {
			/* Object selected its palette as foreground palette */
			return (LRESULT)1;
		}
	}

	return wSelectPalette(m_hAppWnd, m_hStdPal, FALSE/*fBackground*/);
}


/* This is just a helper routine */

LRESULT wSelectPalette(HWND hWnd, HPALETTE hPal, BOOL fBackground)
{
	HDC hdc;
	HPALETTE hOldPal;
	UINT iPalChg = 0;

	if (hPal == 0)
		return (LRESULT)0;

	hdc = GetDC(hWnd);
	hOldPal = SelectPalette(hdc, hPal, fBackground);
	iPalChg = RealizePalette(hdc);
	SelectPalette(hdc, hOldPal, TRUE /*fBackground*/);
	ReleaseDC(hWnd, hdc);

	if (iPalChg > 0)
		InvalidateRect(hWnd, NULL, TRUE);

	return (LRESULT)1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\hlp_site.cxx ===
//**********************************************************************
// File name: HLP_SITE.cxx
//
//      Implementation file for CSimpleSite
//
// Functions:
//
//      See SITE.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include <headers.cxx>
#pragma hdrstop

#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"

//**********************************************************************
//
// CSimpleSite::Create
//
// Purpose:
//
//      Creation routine for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      IStorage::CreateStorage     OLE API
//      assert                      C Runtime
//
// Comments:
//
//********************************************************************

CSimpleSite FAR * CSimpleSite::Create(CSimpleDoc FAR *lpDoc, INT iIter)
{
	CSimpleSite FAR * lpTemp = new CSimpleSite(lpDoc);

	if (!lpTemp)
		return NULL;

    OLECHAR szTempName[128];
    swprintf(szTempName, L"Object %d", iIter);

	// create a sub-storage for the object
	HRESULT hErr = lpDoc->m_lpStorage->CreateStorage( szTempName,
				STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
				0,
				0,
				&lpTemp->m_lpObjStorage);

	assert(hErr == NOERROR);

	if (hErr != NOERROR)
		{
		delete lpTemp;
		return NULL;
		}

	// we will add one ref count on our Site. later when we want to destroy
	// the Site object we will release this  ref count. when the Site's ref
	// count goes to 0, it will be deleted.
	lpTemp->AddRef();

    HEAPVALIDATE();

	return lpTemp;
}

//**********************************************************************
//
// CSimpleSite::CSimpleSite
//
// Purpose:
//
//      Constructor for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
								// tells us that we are passing this in
								// an initializer, before "this" is through
								// initializing.  This is ok, because
								// we just store the ptr in the other
								// constructors

CSimpleSite::CSimpleSite (CSimpleDoc FAR *lpDoc) : m_OleClientSite(this),
							 m_AdviseSink(this)
//							 m_OleInPlaceSite(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
	// remember the pointer to the doc
	m_lpDoc = lpDoc;

	// clear the reference count
	m_nCount = 0;

	m_dwDrawAspect = DVASPECT_CONTENT;
	m_lpOleObject = NULL;
	m_lpInPlaceObject = NULL;
	m_hwndIPObj = NULL;
	m_fInPlaceActive = FALSE;
	m_fObjectOpen = FALSE;

    HEAPVALIDATE();

}

//**********************************************************************
//
// CSimpleSite::~CSimpleSite
//
// Purpose:
//
//      Destructor for CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      OutputDebugString                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

CSimpleSite::~CSimpleSite ()
{
	DEBUGOUT (L"In CSimpleSite's Destructor \r\n");

	if (m_lpOleObject)
	   m_lpOleObject->Release();

	if (m_lpObjStorage)
	   m_lpObjStorage->Release();
}


//**********************************************************************
//
// CSimpleSite::CloseOleObject
//
// Purpose:
//
//      Call IOleObject::Close on the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      OutputDebugString                       Windows API
//      IOleObject::QueryInterface              Object
//      IOleObject::Close                       Object
//      IOleInPlaceObject::UIDeactivate         Object
//      IOleInPlaceObject::InPlaceDeactivate    Object
//      IOleInPlaceObject::Release              Object
//
// Comments:
//
//********************************************************************

void CSimpleSite::CloseOleObject (void)
{
	LPOLEINPLACEOBJECT lpObject;
	LPVIEWOBJECT lpViewObject = NULL;

	DEBUGOUT (L"In CSimpleSite::CloseOleObject \r\n");

	if (m_lpOleObject)
	   {
	   if (m_fInPlaceActive)
		   {
		   m_lpOleObject->QueryInterface(IID_IOleInPlaceObject, (LPVOID FAR *)&lpObject);
		   lpObject->UIDeactivate();
		   // don't need to worry about inside-out because the object
		   // is going away.
		   lpObject->InPlaceDeactivate();
		   lpObject->Release();
		   }

	   m_lpOleObject->Close(OLECLOSE_NOSAVE);
	   }

    //Make sure Heap is proper before leaving the routine
    HEAPVALIDATE();
}


//**********************************************************************
//
// CSimpleSite::UnloadOleObject
//
// Purpose:
//
//      Close and release all pointers to the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      OutputDebugString                       Windows API
//      CSimpleSite::CloseOleObject             SITE.cxx
//      IOleObject::QueryInterface              Object
//      IViewObject::SetAdvise                  Object
//      IViewObject::Release                    Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

void CSimpleSite::UnloadOleObject (void)
{
	DEBUGOUT (L"In CSimpleSite::UnloadOleObject \r\n");
    HEAPVALIDATE();

	if (m_lpOleObject)
	   {
	   LPVIEWOBJECT lpViewObject;
	   CloseOleObject();    // ensure object is closed; NOP if already closed

	   m_lpOleObject->QueryInterface(IID_IViewObject, (LPVOID FAR *)&lpViewObject);

	   if (lpViewObject)
		   {
		   // Remove the view advise
		   lpViewObject->SetAdvise(m_dwDrawAspect, 0, NULL);
		   lpViewObject->Release();
		   }

	   m_lpOleObject->Release();
	   m_lpOleObject = NULL;
	   } 

}


//**********************************************************************
//
// CSimpleSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the container Site.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CSimpleSite::AddRef          OBJ.cxx
//      COleClientSite::AddRef      IOCS.cxx
//      CAdviseSink::AddRef         IAS.cxx
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CSimpleSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	DEBUGOUT(L"In CSimpleSite::QueryInterface\r\n");

    HEAPVALIDATE();
	*ppvObj = NULL;     // must set out pointer parameters to NULL

	if ( riid == IID_IUnknown)
		{
		AddRef();
		*ppvObj = this;
		return ResultFromScode(S_OK);
		}

	if ( riid == IID_IOleClientSite)
		{
		m_OleClientSite.AddRef();
		*ppvObj = &m_OleClientSite;
		return ResultFromScode(S_OK);
		}

	if ( riid == IID_IAdviseSink)
		{
		m_AdviseSink.AddRef();
		*ppvObj = &m_AdviseSink;
		return ResultFromScode(S_OK);
		}

#if 0
	if ( riid == IID_IOleInPlaceSite)
		{
		m_OleInPlaceSite.AddRef();
		*ppvObj = &m_OleInPlaceSite;
		return ResultFromScode(S_OK);
		}
#endif

	// Not a supported interface
        HEAPVALIDATE();
	return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the container Site.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the site.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::AddRef()
{
	DEBUGOUT(L"In CSimpleSite::AddRef\r\n");

	return ++m_nCount;
}

//**********************************************************************
//
// CSimpleSite::Release
//
// Purpose:
//
//      Decrements the reference count of the container Site
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Site.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::Release()
{
	DEBUGOUT(L"In CSimpleSite::Release\r\n");

	if (--m_nCount == 0) {
		delete this;
		return 0;
	}
        HEAPVALIDATE();
	return m_nCount;
}

//**********************************************************************
//
// CSimpleSite::InitObject
//
// Purpose:
//
//      Used to initialize a newly create object (can't be done in the
//      constructor).
//
// Parameters:
//
//      BOOL fCreateNew -   TRUE if insert NEW object
//                          FALSE if create object FROM FILE
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::SetHostNames        Object
//      IOleObject::QueryInterface      Object
//      IViewObject2::GetExtent         Object
//      IOleObject::DoVerb              Object
//      IViewObject::SetAdvise          Object
//      IViewObject::Release            Object
//      GetClientRect                   Windows API
//      OleSetContainedObject           OLE API
//
// Comments:
//
//********************************************************************

void CSimpleSite::InitObject(BOOL fCreateNew)
{
	LPVIEWOBJECT2 lpViewObject2;
	RECT rect;

	// Set a View Advise
	m_lpOleObject->QueryInterface(IID_IViewObject2,(LPVOID FAR *)&lpViewObject2);
	lpViewObject2->SetAdvise(m_dwDrawAspect, ADVF_PRIMEFIRST, &m_AdviseSink);

	// get the initial size of the object
	lpViewObject2->GetExtent(m_dwDrawAspect, -1 /*lindex*/, NULL /*ptd*/, &m_sizel);
	GetObjRect(&rect);  // get the rectangle of the object in pixels
	lpViewObject2->Release();

	// give the object the name of the container app/document
	m_lpOleObject->SetHostNames(L"Simple Application", L"Simple OLE 2.0 In-Place Container");

	// inform object handler/DLL object that it is used in the embedding container's context
	OleSetContainedObject(m_lpOleObject, TRUE);

	if (fCreateNew) {
	   // force new object to save to guarantee valid object in our storage.
	   // OLE 1.0 objects may close w/o saving. this is NOT necessary if the
	   // object is created FROM FILE; its data in storage is already valid.
	   m_OleClientSite.SaveObject();

	   // we only want to DoVerb(SHOW) if this is an InsertNew object.
	   // we should NOT DoVerb(SHOW) if the object is created FromFile.
	   m_lpOleObject->DoVerb(
			   OLEIVERB_SHOW,
			   NULL,
			   &m_OleClientSite,
			   -1,
			   m_lpDoc->m_hDocWnd,
			   &rect);
	}
}

//**********************************************************************
//
// CSimpleSite::PaintObj
//
// Purpose:
//
//      Paints the object
//
// Parameters:
//
//      HDC hDC     - Device context of the document window
//
// Return Value:
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::QueryInterface      Object
//      IViewObject::GetColorSet        Object
//      IViewObject::Release            Object
//      SetMapMode                      Windows API
//      LPtoDP                          Windows API
//      CreateHatchBrush                Windows API
//      SelectObject                    Windows API
//      DeleteObject                    Windows API
//      CreatePalette                   Windows API
//      SelectPalette                   Windows API
//      RealizePalette                  Windows API
//      OleStdFree                      OUTLUI Function
//      OleDraw                         OLE API
//
// Comments:
//
//********************************************************************

void CSimpleSite::PaintObj(HDC hDC)
{
RECT rect;

	// need to check to make sure there is a valid object
	// available.  This is needed if there is a paint msg
	// between the time that CSimpleSite is instantiated
	// and OleUIInsertObject returns.
	if (!m_lpOleObject)
		return;

	// convert it to pixels
	GetObjRect(&rect);

	LPLOGPALETTE pColorSet = NULL;
	LPVIEWOBJECT lpView = NULL;

	// get a pointer to IViewObject
	m_lpOleObject->QueryInterface(IID_IViewObject,(LPVOID FAR *) &lpView);

	// draw the object
	OleDraw(m_lpOleObject, m_dwDrawAspect, hDC, &rect);
#if 0
	// if the object is open, draw a hatch rect.
	if (m_fObjectOpen)
		{
		HBRUSH hBrush = CreateHatchBrush ( HS_BDIAGONAL, RGB(0,0,0) );
		HBRUSH hOldBrush = SelectObject (hDC, hBrush);
		SetROP2(hDC, R2_MASKPEN);
		Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom);
		SelectObject(hDC, hOldBrush);
		DeleteObject(hBrush);
		}
#endif

	// if a view pointer was successfully returned, it needs to be released.
	if (lpView)
		lpView->Release();
}

#define HIMETRIC_PER_INCH   2540      // number HIMETRIC units per inch
#define PTS_PER_INCH        72        // number points (font size) per inch
#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

STDAPI_(int) XformWidthInHimetricToPixels(HDC hDC, int iWidthInHiMetric)
	{
	int     iXppli;     //Pixels per logical inch along width
	int     iWidthInPix;
	BOOL    fSystemDC=FALSE;

	if (NULL==hDC)
		{
		hDC=GetDC(NULL);
		fSystemDC=TRUE;
		}

	iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

	//We got logical HIMETRIC along the display, convert them to pixel units
	iWidthInPix = MAP_LOGHIM_TO_PIX(iWidthInHiMetric, iXppli);

	if (fSystemDC)
		ReleaseDC(NULL, hDC);

	return iWidthInPix;
	}


STDAPI_(int) XformHeightInHimetricToPixels(HDC hDC, int iHeightInHiMetric)
	{
	int     iYppli;     //Pixels per logical inch along height
	int     iHeightInPix;
	BOOL    fSystemDC=FALSE;

	if (NULL==hDC)
		{
		hDC=GetDC(NULL);
		fSystemDC=TRUE;
		}

	iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

	//* We got logical HIMETRIC along the display, convert them to pixel units
	iHeightInPix = MAP_LOGHIM_TO_PIX(iHeightInHiMetric, iYppli);

	if (fSystemDC)
		ReleaseDC(NULL, hDC);

	return iHeightInPix;
	}


//**********************************************************************
//
// CSimpleSite::GetObjRect
//
// Purpose:
//
//      Retrieves the rect of the object in pixels
//
// Parameters:
//
//      LPRECT lpRect - Rect structure filled with object's rect in pixels
//
// Return Value:
//
// Function Calls:
//      Function                        Location
//
//      XformWidthInHimetricToPixels    OUTLUI Function
//      XformHeightInHimetricToPixels   OUTLUI Function
//
// Comments:
//
//********************************************************************

void CSimpleSite::GetObjRect(LPRECT lpRect)
{
	// convert it to pixels
	lpRect->left = lpRect->top = 0;
	lpRect->right = XformWidthInHimetricToPixels(NULL,(int)m_sizel.cx);
	lpRect->bottom = XformHeightInHimetricToPixels(NULL,(int)m_sizel.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\hlp_iopf.cxx ===
//**********************************************************************
// File name: HLP_IOIPF.cxx
//
//      Implementation file for COleInPlaceFrame
//
// Functions:
//
//      See IOIPF.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "hlp_pre.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_iopf.hxx"
#include "hlp_iops.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"


//**********************************************************************
//
// COleInPlaceFrame::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK            -   The interface is supported.
//      E_NOINTERFACE   -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleApp::QueryInterface  APP.cxx
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    DEBUGOUT(TEXT("In IOIPF::QueryInterface\r\n"));

    // delegate to the application Object
    return m_pApp->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceFrame::AddRef
//
// Purpose:
//
//      Increments the reference count of the CSimpleApp. Since
//      COleInPlaceFrame is a nested class of CSimpleApp, we don't need an
//      extra reference count for COleInPlaceFrame. We can safely use the
//      reference count of CSimpleApp.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the CSimpleApp
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleApp::AddRef          APP.cxx
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::AddRef()
{
    DEBUGOUT(TEXT("In IOIPF::AddRef\r\n"));

    // delegate to the application Object
    return m_pApp->AddRef();
}

//**********************************************************************
//
// COleInPlaceFrame::Release
//
// Purpose:
//
//      Decrements the reference count of the CSimpleApp. Since
//      COleInPlaceFrame is a nested class of CSimpleApp, we don't need an
//      extra reference count for COleInPlaceFrame. We can safely use the
//      reference count of CSimpleApp.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleApp.
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleApp::Release         APP.cxx
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::Release()
{
    DEBUGOUT(TEXT("In IOIPF::Release\r\n"));

    // delegate to the document object
    return m_pApp->Release();

}

//**********************************************************************
//
// COleInPlaceFrame::GetWindow
//
// Purpose:
//
//      Returns the frame window handle
//
// Parameters:
//
//      HWND FAR* lphwnd    - Location to return the window handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetWindow (HWND FAR* lphwnd)
{
    DEBUGOUT(TEXT("In IOIPF::GetWindow\r\n"));
    *lphwnd = m_pApp->m_hAppWnd;
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::ContextSensitiveHelp
//
// Purpose:
//
//      Used in implementing Context sensitive help
//
// Parameters:
//
//      BOOL fEnterMode -   TRUE if starting Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes in the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::ContextSensitiveHelp (BOOL fEnterMode)
{
    DEBUGOUT(TEXT("In IOIPF::ContextSensitiveHelp\r\n"));

    m_pApp->m_fMenuMode = fEnterMode;

    return ResultFromScode(S_OK);
}
//**********************************************************************
//
// COleInPlaceFrame::GetBorder
//
// Purpose:
//
//      Returns the outermost border that frame adornments can be attached
//      during InPlace Activation.
//
// Parameters:
//
//      LPRECT lprectBorder - return parameter to contain the outermost
//                            rect for frame adornments
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      GetClientRect               Windows API
//      CopyRect                    Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetBorder (LPRECT lprectBorder)
{
    RECT rect;

    DEBUGOUT(TEXT("In IOIPF::GetBorder\r\n"));

    // get the rect for the entire frame.
    GetClientRect(m_pApp->m_hAppWnd, &rect);

    CopyRect(lprectBorder, &rect);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::RequestBorderSpace
//
// Purpose:
//
//      Approves/Denies requests for border space during InPlace
//      negotiation.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - The width in pixels needed on
//                                        each side of the frame.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      This implementation doesn't care about how much border space
//      is used.  It always returns S_OK.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RequestBorderSpace (LPCBORDERWIDTHS
                                                         lpborderwidths)
{
    DEBUGOUT(TEXT("In IOIPF::RequestBorderSpace\r\n"));

    // always approve the request
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetBorderSpace
//
// Purpose:
//
//      The object calls this method when it is actually going to
//      start using the border space.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - Border space actually being used
//                                        by the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::AddFrameLevelTools  APP.cxx
//      OutputDebugString               Windows API
//      GetClientRect                   Windows API
//      MoveWindow                      Windows API
//      ResultFromScode                 Windows API
//
// Comments:
//
//      This routine could be a little smarter and check to see if
//      the object is requesting the entire client area of the
//      window.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetBorderSpace (LPCBORDERWIDTHS lpborderwidths)
{

    DEBUGOUT(TEXT("In IOIPF::SetBorderSpace\r\n"));

    if (lpborderwidths == NULL)
        m_pApp->AddFrameLevelTools();
    else
    {
        RECT rect;

        GetClientRect(m_pApp->m_hAppWnd, &rect);

        MoveWindow( m_pApp->m_lpDoc->m_hDocWnd,
                   rect.left + lpborderwidths->left,
                   rect.top + lpborderwidths->top,
                   rect.right - lpborderwidths->right - lpborderwidths->left,
                   rect.bottom - lpborderwidths->bottom - lpborderwidths->top,
                   TRUE);
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetActiveObject
//
// Purpose:
//  install the object being activated in-place
//
//
// Parameters:
//
//  LPOLEINPLACEACTIVEOBJECT lpActiveObject     -   Pointer to the
//                                                  objects
//                                                  IOleInPlaceActiveObject
//                                                  interface
//
//  LPCOLESTR lpszObjName                       -   Name of the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      OutputDebugString                   Windows API
//      IOleInPlaceActiveObject::AddRef     Object
//      IOleInPlaceActiveObject::Release    Object
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetActiveObject (LPOLEINPLACEACTIVEOBJECT
                                        lpActiveObject, LPCOLESTR lpszObjName)
{

    DEBUGOUT(TEXT("In IOIPF::SetActiveObject\r\n"));

    // AddRef() it and save it...
    if (lpActiveObject)
    {
        lpActiveObject->AddRef();

        lpActiveObject->GetWindow(&m_pApp->m_hwndUIActiveObj);
        if (m_pApp->m_hwndUIActiveObj)
            SendMessage(m_pApp->m_hwndUIActiveObj, WM_QUERYNEWPALETTE, 0, 0L);
    }
    else
    {
        if (m_pApp->m_lpDoc->m_lpActiveObject)
            m_pApp->m_lpDoc->m_lpActiveObject->Release();
        m_pApp->m_hwndUIActiveObj = NULL;
    }

    // in an MDI app, this method really shouldn't be called,
    // this method associated with the doc is called instead.

    m_pApp->m_lpDoc->m_lpActiveObject = lpActiveObject;
    // should set window title here

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::InsertMenus
//
// Purpose:
//
//      Inserts the container menu into the combined menu
//
// Parameters:
//
//      HMENU hmenuShared                   -   Menu Handle to be set.
//      LPOLEMENUGROUPWIDTHS lpMenuWidths   -   Width of menus
//
// Return Value:
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      AppendMenu                  Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::InsertMenus (HMENU hmenuShared,
                                            LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    DEBUGOUT(TEXT("In IOIPF::InsertMenus\r\n"));

    AppendMenu(hmenuShared, MF_BYPOSITION | MF_POPUP,
               (UINT) m_pApp->m_lpDoc->m_hFileMenu, TEXT("&File"));
    AppendMenu(hmenuShared, MF_BYPOSITION | MF_POPUP,
               (UINT) m_pApp->m_lpDoc->m_hHelpMenu, TEXT("&Other"));

    lpMenuWidths->width[0] = 1;
    lpMenuWidths->width[2] = 0;
    lpMenuWidths->width[4] = 1;

    return ResultFromScode(S_OK);
}


//**********************************************************************
//
// COleInPlaceFrame::SetMenu
//
// Purpose:
//
//      Sets the application menu to the combined menu
//
// Parameters:
//
//      HMENU hmenuShared       - The combined menu
//
//      HOLEMENU holemenu       - Used by OLE
//
//      HWND hwndActiveObject   - Used by OLE
//
// Return Value:
//
//      S_OK                -  if menu was correctly installed
//      E_FAIL              -  otherwise
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      SetMenu                     Windows API
//      OleSetMenuDescriptor        OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetMenu (HMENU hmenuShared, HOLEMENU holemenu,
                                        HWND hwndActiveObject)
{

    DEBUGOUT(TEXT("In IOIPF::SetMenu\r\n"));

    HMENU hMenu = m_pApp->m_lpDoc->m_hMainMenu;

    if (holemenu)
        hMenu = hmenuShared;

    // call the windows api, not this method
    ::SetMenu (m_pApp->m_hAppWnd, hMenu);

    HRESULT hRes = OleSetMenuDescriptor(holemenu, m_pApp->m_hAppWnd,
                                        hwndActiveObject, this,
                                        m_pApp->m_lpDoc->m_lpActiveObject);

    return hRes;
}


//**********************************************************************
//
// COleInPlaceFrame::RemoveMenus
//
// Purpose:
//
//      Removes the container menus from the combined menu
//
// Parameters:
//
//      HMENU hmenuShared   - Handle to the combined menu.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      GetMenuItemCount            Windows API
//      RemoveMenu                  Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RemoveMenus (HMENU hmenuShared)
{
    int retval;

    DEBUGOUT(TEXT("In IOIPF::RemoveMenus\r\n"));

    while ((retval = GetMenuItemCount(hmenuShared)) && (retval != -1))
        RemoveMenu(hmenuShared, 0, MF_BYPOSITION);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetStatusText
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPCOLESTR  lpszStatusText  -  character string containing the message
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      This function is not implemented due to the fact
//      that this application does not have a status bar.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetStatusText (LPCOLESTR lpszStatusText)
{
    DEBUGOUT(TEXT("In IOIPF::SetStatusText\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceFrame::EnableModeless
//
// Purpose:
//
//      Enables/Disables container modeless dialogs
//
// Parameters:
//
//      BOOL fEnable    - Enable/Disable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
// Comments:
//
//      There are no modeless dialogs in this application, so the
//      implementation of this method is trivial.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::EnableModeless (BOOL fEnable)
{
    DEBUGOUT(TEXT("In IOIPF::EnableModeless\r\n"));
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::TranslateAccelerator
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPMSG   lpmsg     -   structure containing keystroke message
//      WORD    wID       -   identifier value corresponding to the keystroke
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::TranslateAccelerator (LPMSG lpmsg, WORD wID)
{
    DEBUGOUT(TEXT("In IOIPF::TranslateAccelerator\r\n"));
    return ::TranslateAccelerator(m_pApp->m_hAppWnd, m_pApp->m_hAccel, lpmsg)
        ? ResultFromScode(S_OK)
        : ResultFromScode(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\hlp_doc.cxx ===
//**********************************************************************
// File name: HLP_DOC.CXX
//
//      Implementation file for CSimpleDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include <headers.cxx>
#pragma hdrstop

#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"

//**********************************************************************
//
// CSimpleDoc::Create
//
// Purpose:
//
//      Creation for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpleDoc FAR * CSimpleDoc::Create()
{
	CSimpleDoc FAR * lpTemp = new CSimpleDoc();

	if (!lpTemp)
		return NULL;

	// create storage for the doc.
	HRESULT hErr = StgCreateDocfile (NULL, STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
									 0, &lpTemp->m_lpStorage);

	if (hErr != NOERROR)
		goto error;

	// we will add one ref count on our document. later in CSimpleDoc::Close
	// we will release this  ref count. when the document's ref count goes
	// to 0, the document will be deleted.
	lpTemp->AddRef();

	return (lpTemp);

error:
	delete (lpTemp);
	return NULL;

}

//**********************************************************************
//
// CSimpleDoc::Close
//
// Purpose:
//
//      Close CSimpleDoc object.
//      when the document's reference count goes to 0, the document
//      will be destroyed.
//
// Parameters:
//
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      RevokeDragDrop              OLE API
//      CoLockObjectExternal        OLE API
//      OleFlushClipboard           OLE API
//      ShowWindow                  Windows API
//
// Comments:
//
//********************************************************************

void CSimpleDoc::Close(void)
{
	DEBUGOUT(L"In CSimpleDoc::Close\r\n");

	ShowWindow(m_hDocWnd, SW_HIDE);  // Hide the window

	// Close the OLE object in our document
	if (m_lpSite)
		m_lpSite->CloseOleObject();

	// Release the ref count added in CSimpleDoc::Create. this will make
	// the document's ref count go to 0, and the document will be deleted.
	Release();
}

//**********************************************************************
//
// CSimpleDoc::CSimpleDoc
//
// Purpose:
//
//      Constructor for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
// Comments:
//
//********************************************************************

CSimpleDoc::CSimpleDoc()
{
}

//**********************************************************************
//
// CSimpleDoc::~CSimpleDoc
//
// Purpose:
//
//      Destructor for CSimpleDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Release        SITE.CPP
//      IStorage::Release           OLE API
//
// Comments:
//
//********************************************************************

CSimpleDoc::~CSimpleDoc()
{
	DEBUGOUT(L"In CSimpleDoc's Destructor\r\n");

	// Release all pointers we hold to the OLE object. also release
	// the ref count added in CSimpleSite::Create. this will make
	// the Site's ref count go to 0, and the Site will be deleted.
	if (m_lpSite) {
		m_lpSite->UnloadOleObject();
		m_lpSite->Release();
		m_lpSite = NULL;
	}

	// Release the Storage
	if (m_lpStorage) {
		m_lpStorage->Release();
		m_lpStorage = NULL;
	}

	// if the edit menu was modified, remove the menu item and
	// destroy the popup if it exists
	if (m_fModifiedMenu)
		{
		int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);
		RemoveMenu(m_lpApp->m_hEditMenu, nCount-1, MF_BYPOSITION);
		if (m_lpApp->m_hCascadeMenu)
			DestroyMenu(m_lpApp->m_hCascadeMenu);
		}

	DestroyWindow(m_hDocWnd);
}


//**********************************************************************
//
// CSimpleDoc::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_FALSE -   Always
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//      In this implementation, there are no doc level interfaces.
//      In an MDI application, there would be an IOleInPlaceUIWindow
//      associated with the document to provide document level tool
 //     space negotiation.
//
//********************************************************************

STDMETHODIMP CSimpleDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	DEBUGOUT(L"In CSimpleDoc::QueryInterface\r\n");

	*ppvObj = NULL;     // must set out pointer parameters to NULL

	// Not a supported interface
	return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleDoc::AddRef
//
// Purpose:
//
//      Increments the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      CSimpleApp::AddRef          APP.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::AddRef()
{
	DEBUGOUT(L"In CSimpleDoc::AddRef\r\n");
	return ++m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::Release
//
// Purpose:
//
//      Decrements the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::Release()
{
	DEBUGOUT(L"In CSimpleDoc::Release\r\n");

	if (--m_nCount == 0) {
		delete this;
		return 0;
	}
	return m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::InsertObject
//
// Purpose:
//
//      Inserts a new object to this document
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::CSimpleSite    SITE.CPP
//      CSimpleSite::InitObject     SITE.CPP
//      memset                      C Runtime
//      OleUIInsertObject           OUTLUI function
//      CSimpleDoc::DisableInsertObject DOC.CPP
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another.
//
//********************************************************************

void CSimpleDoc::InsertObject()
{
#if 0
	m_lpSite = CSimpleSite::Create(this);
	iret = OleUIInsertObject(&io);

	if (iret == OLEUI_OK)
		{
		m_lpSite->InitObject((BOOL)(io.dwFlags & IOF_SELECTCREATENEW));
		// disable Insert Object menu item
		DisableInsertObject();
		}
	else
		{
		m_lpSite->Release();
		m_lpSite = NULL;
		m_lpStorage->Revert();
		}
#endif
 
}

//**********************************************************************
//
// CSimpleDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      IOleInPlaceActiveObject::ResizeBorder   Object
//      MoveWindow                              Windows API
//
// Comments:
//
//********************************************************************

long CSimpleDoc::lResizeDoc(LPRECT lpRect)
{
	// if we are InPlace, then call ResizeBorder on the object, otherwise
	// just move the document window.
	//if (m_fInPlaceActive)
		//m_lpActiveObject->ResizeBorder(lpRect, &m_lpApp->m_OleInPlaceFrame, TRUE);
	//else
		MoveWindow(m_hDocWnd, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, TRUE);

	return NULL;
}

//**********************************************************************
//
// CSimpleDoc::lAddVerbs
//
// Purpose:
//
//      Adds the objects verbs to the edit menu.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetMenuItemCount            Windows API
//      OleUIAddVerbMenu            OUTLUI function
//
// Comments:
//
//********************************************************************

long CSimpleDoc::lAddVerbs(void)
{
#if 0
	// m_fModifiedMenu is TRUE if the menu has already been modified
	// once.  Since we only support one obect every time the application
	// is run, then once the menu is modified, it doesn't have
	// to be done again.
	if (m_lpSite && !m_fInPlaceActive  && !m_fModifiedMenu)
		{
		int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);

		OleUIAddVerbMenu ( m_lpSite->m_lpOleObject,
						   NULL,
						   m_lpApp->m_hEditMenu,
						   nCount + 1,
						   IDM_VERB0,
						   0,           // no maximum verb IDM enforced
						   FALSE,
						   0,
						   &m_lpApp->m_hCascadeMenu);

		m_fModifiedMenu = TRUE;
		}
#endif
	return (NULL);
}

//**********************************************************************
//
// CSimpleDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::PaintObj       SITE.CPP
//
// Comments:
//
//********************************************************************

void CSimpleDoc::PaintDoc (HDC hDC)
{
	// if we supported multiple objects, then we would enumerate
	// the objects and call paint on each of them from here.

	if (m_lpSite)
		m_lpSite->PaintObj(hDC);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\bmcomm.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmcomm.cxx
//
//  Contents:	definitions for benchmark test 
//
//  Classes:
//
//  Functions:	
//
//  History:    30-June-93 t-martig    Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>

//  the external definitions for these are in bmcomm.hxx

DWORD dwaClsCtx[] = {CLSCTX_INPROC_SERVER, CLSCTX_LOCAL_SERVER};

LPTSTR apszClsCtx[] = {TEXT("InProc Server"), TEXT("Local Server")};
LPTSTR apszClsIDName[] = {TEXT("ClsID_InProc"), TEXT("ClsID_Local")};
LPOLESTR apszPerstName[] = {aszPerstName[0], aszPerstName[1]};
LPOLESTR apszPerstNameNew[] = {aszPerstNameNew[0], aszPerstNameNew[1]};


LPTSTR saModeNames[] = { TEXT("InProc"),
			 TEXT("Local"),
			 TEXT("Handler"),
			 NULL };

DWORD dwaModes[]     = { CLSCTX_INPROC_SERVER,
			 CLSCTX_LOCAL_SERVER,
			 CLSCTX_INPROC_HANDLER };


OLECHAR  aszPerstName[2][80];	// actual name for persistent instances
OLECHAR  aszPerstNameNew[2][80]; // actual name for persistent instances


HRESULT OleInitializeEx(LPMALLOC pMalloc, DWORD dwIgnored)
{
    return OleInitialize(pMalloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\cairole\ui\hlp_iops.cxx ===
//**********************************************************************
// File name: HLP_IOPS.cxx
//
//      Implementation file for COleInPlaceSite
//
// Functions:
//
//      See IOIPS.H for class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "hlp_pre.hxx"
#include "hlp_iocs.hxx"
#include "hlp_ias.hxx"
#include "hlp_iopf.hxx"
#include "hlp_iops.hxx"
#include "hlp_app.hxx"
#include "hlp_site.hxx"
#include "hlp_doc.hxx"

//**********************************************************************
//
// COleInPlaceSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleSite::QueryInterface SITE.cxx
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    DEBUGOUT(TEXT("In IOIPS::QueryInterface\r\n"));

    // delegate to the container Site
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the CSimpleSite. Since
//      COleInPlaceSite is a nested class of CSimpleSite, we don't need an
//      extra reference count for COleInPlaceSite. We can safely use the
//      reference count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleSite::QueryInterface SITE.cxx
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::AddRef()
{
    DEBUGOUT(TEXT("In IOIPS::AddRef\r\n"));

    // delegate to the container Site
    return m_pSite->AddRef();
}

//**********************************************************************
//
// COleInPlaceSite::Release
//
// Purpose:
//
//      Decrements the reference count of the CSimpleSite. Since
//      COleInPlaceSite is a nested class of CSimpleSite, we don't need an
//      extra reference count for COleInPlaceSite. We can safely use the
//      reference count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleSite::Release        SITE.cxx
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::Release()
{
    DEBUGOUT(TEXT("In IOIPS::Release\r\n"));

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// COleInPlaceSite::GetWindow
//
// Purpose:
//
//      Returns the Window Handle of the client site
//
// Parameters:
//
//      HWND FAR* lphwnd    - place to return the handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindow (HWND FAR* lphwnd)
{
    DEBUGOUT(TEXT("In IOIPS::GetWindow\r\n"));

    // return the handle to our editing window.
    *lphwnd = m_pSite->m_lpDoc->m_hDocWnd;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::ContextSensitiveHelp
//
// Purpose:
//      set/reset context sensitive help mode
//
// Parameters:
//
//      BOOL fEnterMode - TRUE for entering Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes included with the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::ContextSensitiveHelp (BOOL fEnterMode)
{
    DEBUGOUT(TEXT("In IOIPS::ContextSensitiveHelp\r\n"));

    if (m_pSite->m_lpDoc->m_lpApp->m_fCSHMode != fEnterMode)
        m_pSite->m_lpDoc->m_lpApp->m_fCSHMode = fEnterMode;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::CanInPlaceActivate
//
// Purpose:
//
//      Object calls to find out if the container can InPlace activate
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::CanInPlaceActivate ()
{
    DEBUGOUT(TEXT("In IOIPS::CanInPlaceActivate\r\n"));

    // return S_OK to indicate we can in-place activate
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceActivate
//
// Purpose:
//
//      Called by the object on InPlace Activation
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK             -  if the interface can be found
//      E_FAIL           -  otherwise
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//      IOleObject::QueryInterface  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceActivate ()
{
    HRESULT hrErr;
    DEBUGOUT(TEXT("In IOIPS::OnInPlaceActivate\r\n"));

    hrErr = m_pSite->m_lpOleObject->QueryInterface(
           IID_IOleInPlaceObject, (LPVOID FAR *)&m_pSite->m_lpInPlaceObject);
    if (hrErr != NOERROR)
        return ResultFromScode(E_FAIL);

    // return S_OK to indicate we can in-place activate.
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIActivate
//
// Purpose:
//
//      Object calls this method when it displays it's UI.
//
// Parameters:
//
//      None.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                      Location
//
//      OutputDebugString             Windows API
//      ResultFromScode               OLE API
//      IOleInPlaceObject::GetWindow  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIActivate ()
{
    DEBUGOUT(TEXT("In IOIPS::OnUIActivate\r\n"));

    m_pSite->m_lpDoc->m_fAddMyUI=FALSE;
    m_pSite->m_lpDoc->m_fInPlaceActive = TRUE;
    m_pSite->m_fInPlaceActive = TRUE;

    m_pSite->m_lpInPlaceObject->GetWindow((HWND FAR*)&m_pSite->m_hwndIPObj);

    // return S_OK to continue in-place activation
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::GetWindowContext
//
// Purpose:
//
//      Called by the object to get information for InPlace Negotiation.
//
// Parameters:
//
//      LPOLEINPLACEFRAME FAR* lplpFrame    - Location to return a pointer
//                                            to IOleInPlaceFrame.
//
//      LPOLEINPLACEUIWINDOW FAR* lplpDoc   - Location to return a pointer
//                                            to IOleInPlaceUIWindow.
//
//      LPRECT lprcPosRect                  - The rect that the object
//                                            occupies
//
//      LPRECT lprcClipRect                 - The clipping rect
//
//      LPOLEINPLACEFRAMEINFO lpFrameInfo   - Pointer to FRAMEINFO
//
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      COleInPlaceFrame::AddRef    IOIPF.cxx
//      CSimpleSite::GetObjRect     SITE.cxx
//      OutputDebugString           Windows API
//      CopyRect                    Windows API
//      GetClientRect               Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindowContext (
                               LPOLEINPLACEFRAME FAR* lplpFrame,
                               LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                               LPRECT lprcPosRect,
                               LPRECT lprcClipRect,
                               LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    RECT rect;

    DEBUGOUT(TEXT("In IOIPS::GetWindowContext\r\n"));

    // the frame is associated with the application object.
    // need to AddRef() it...
    m_pSite->m_lpDoc->m_lpApp->m_OleInPlaceFrame.AddRef();
    *lplpFrame = &m_pSite->m_lpDoc->m_lpApp->m_OleInPlaceFrame;
    *lplpDoc = NULL;  // must be NULL, cause we're SDI.

    // get the size of the object in pixels
    m_pSite->GetObjRect(&rect);

    // Copy this to the passed buffer
    CopyRect(lprcPosRect, &rect);

    // fill the clipping region
    GetClientRect(m_pSite->m_lpDoc->m_hDocWnd, &rect);
    CopyRect(lprcClipRect, &rect);

    // fill the FRAMEINFO
    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame = m_pSite->m_lpDoc->m_lpApp->m_hAppWnd;
    lpFrameInfo->haccel = m_pSite->m_lpDoc->m_lpApp->m_hAccel;
    lpFrameInfo->cAccelEntries = SIMPCNTR_ACCEL_CNT;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::Scroll
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      SIZE scrollExtent  - number of pixels scrolled in X and Y direction
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::Scroll (SIZE scrollExtent)
{
    DEBUGOUT(TEXT("In IOIPS::Scroll\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIDeactivate
//
// Purpose:
//
//      Called by the object when its UI goes away
//
// Parameters:
//
//       BOOL fUndoable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      CSimpleAPP::QueryNewPalette APP.cxx
//      CSimpleAPP::AddFrameLevelUI APP.cxx
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIDeactivate (BOOL fUndoable)
{
    DEBUGOUT(TEXT("In IOIPS::OnUIDeactivate\r\n"));

    // need to clear this flag first
    m_pSite->m_lpDoc->m_fInPlaceActive = FALSE;
    m_pSite->m_fInPlaceActive = FALSE;

    m_pSite->m_lpDoc->m_lpApp->QueryNewPalette();
    m_pSite->m_lpDoc->m_lpApp->AddFrameLevelUI();
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceDeactivate
//
// Purpose:
//
//      Called when the inplace session is over
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//      ResultFromScode             OLE API
//      IOleInPlaceObject::Release  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceDeactivate ()
{
    DEBUGOUT(TEXT("In IOIPS::OnInPlaceDeactivate\r\n"));

    if (m_pSite->m_lpInPlaceObject)
    {
        m_pSite->m_lpInPlaceObject->Release();
        m_pSite->m_lpInPlaceObject = NULL;
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::DiscardUndoState
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DiscardUndoState ()
{
    DEBUGOUT(TEXT("In IOIPS::DiscardUndoState\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::DeactivateAndUndo
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      OutputDebugString           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DeactivateAndUndo ()
{
    DEBUGOUT(TEXT("In IOIPS::DeactivateAndUndo\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnPosRectChange
//
// Purpose:
//
//      The object calls this method when it's size changes during an
//      InPlace Session
//
// Parameters:
//
//      LPCRECT lprcPosRect -   The new object rect
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      OutputDebugString                   Windows API
//      GetClientRect                       Windows API
//      IOleObject::GetExtent               Object
//      IOleInPlaceObject::SetObjectRects   Object
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnPosRectChange (LPCRECT lprcPosRect)
{
    DEBUGOUT(TEXT("In IOIPS::OnPosRectChange\r\n"));

    // update the size in the document object
    // NOTE: here we must call IOleObject::GetExtent to get actual extents
    //       of the running object. IViewObject2::GetExtent returns the
    //       last cached extents.
    m_pSite->m_lpOleObject->GetExtent(DVASPECT_CONTENT, &m_pSite->m_sizel);
    RECT rect;
    GetClientRect(m_pSite->m_lpDoc->m_hDocWnd, &rect);

    // tell the object its new size
    m_pSite->m_lpInPlaceObject->SetObjectRects(lprcPosRect, &rect);

    return ResultFromScode(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\bmconfig.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmconfig.cxx
//
//  Contents:	configuration inquiry and reporting
//
//  Classes:	
//
//  Functions:	ReportBMConfig
//
//  History:    2-July-93 t-martig    Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bmdriver.hxx>


//+-------------------------------------------------------------------
//
//  Function: 	ReportBMConfig
//
//  Synopsis:	Writes the current system / hardware configuration
//		to a specified output class
//
//  Parameters: [lpswzConfigFile]	Name and path of .ini file 
//		[output]		Output class
//
//  History:   	2-July-93   t-martig	Created
//
//--------------------------------------------------------------------

void ReportBMConfig (CTestInput &input, CTestOutput &output)
{
	TCHAR cname[MAX_COMPUTERNAME_LENGTH+1];
	SYSTEM_INFO sinf;
	TCHAR *temp;
	DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;

	GetComputerName (cname, &dwSize);
	output.WriteTextString (cname);

	output.WriteString (TEXT("\t"));
	output.WriteConfigEntry (input, TEXT("Config"), TEXT("Mfg"), TEXT("n/a"));

	GetSystemInfo (&sinf);
	
	switch (sinf.dwProcessorType)
	{
		case 386:
			temp = TEXT("i386");
			break;
		case 486:
			temp = TEXT("i486");
			break;
		case 860:
			temp = TEXT("i860");
			break;
		case 2000:
			temp = TEXT("R2000");
			break;		
		case 3000:
			temp = TEXT("R3000");
			break;		
		case 4000:
			temp = TEXT("R4000");
			break;		
		default:
			temp = TEXT("Unknown");

		break;
	}
	output.WriteString (TEXT("\t"));
	output.WriteConfigEntry (input, TEXT("Config"), TEXT("CPU"), temp);
	output.WriteString (TEXT("\t"));
	output.WriteConfigEntry (input, TEXT("Config"), TEXT("RAM"), TEXT("n/a"));
	output.WriteString (TEXT("\t"));
	output.WriteConfigEntry (input, TEXT("Config"), TEXT("OS"), TEXT("Cairo"));
	output.WriteString (TEXT("\t"));
	output.WriteConfigEntry (input, TEXT("Driver"), TEXT("InitFlag"), TEXT("COINIT_MULTITHREADED"));

	output.WriteString (TEXT("\n\t\t\t\t"));

	output.WriteString (TEXT("All times in microseconds\n"));

//	NtQuerySystemInformation
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\bminput.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bminput.cxx
//
//  Contents:	input class for benchmark config
//
//  Classes:	CTestinput
//
//  Functions:	
//
//  History:    14-July-93 t-martig    Created
//		07-July-94 t-vadims    Added GetConfigInt and changed
// 				       GetIterations to use it.
//
//--------------------------------------------------------------------------
#include <benchmrk.hxx>
#include <bminput.hxx>

//+-------------------------------------------------------------------
//
//  Member:	CTestInput,public
//
//  Synopsis:	constructor for test input class
//
//+-------------------------------------------------------------------
CTestInput::CTestInput (LPTSTR lpszFileName)
{
	lstrcpy (m_szFileName, lpszFileName);
}


//+-------------------------------------------------------------------
//
//  Member:	GetConfigString,public
//
//  Synopsis:	returns profile string from specified section and
//		parameter.
//
//+-------------------------------------------------------------------
LPTSTR CTestInput::GetConfigString (LPTSTR lpszSection, LPTSTR lpszEntry,
				    LPTSTR lpszDefault, LPTSTR lpszDest,
				    DWORD dwLen)
{
	GetPrivateProfileString (lpszSection, lpszEntry, lpszDefault,
				  lpszDest, dwLen, m_szFileName);
	return lpszDest;
}

//+-------------------------------------------------------------------
//
//  Member:	GetConfigInt,public
//
//  Synopsis:	returns profile integer from specified section and
//		parameter.
//
//+-------------------------------------------------------------------
DWORD CTestInput::GetConfigInt (LPTSTR lpszSection, LPTSTR lpszEntry,
				DWORD dwDefault)
{
	return GetPrivateProfileInt (lpszSection, lpszEntry,
				      dwDefault, m_szFileName);
}

//+-------------------------------------------------------------------
//
//  Member: 	GetClassCtx,public
//
//  Synopsis:	Gets the custom class activation context from .ini
//		file (entry name = "ClsCtx")
//
//  Parameters: [lpszTestName]		Section under which "ClsCtx"
//					is listed
//
//  Returns:	CLSCTX_... mode according to entry:
//
//			"InProc"   CLSCTX_INPROC_SERVER
//			"Local"	   CLSCTX_LOCAL_SERVER,
//			"Handler"  CLSCTX_INPROC_HANDLER
//			any other  CLSCTX_INPROC_SERVER
//
//  History:   	12-July-93   t-martig	Created
//
//--------------------------------------------------------------------
DWORD CTestInput::GetClassCtx (LPTSTR lpszTestName)
{
	TCHAR szMode[50];
	int i;

	GetConfigString (lpszTestName, TEXT("ClsCtx"), TEXT("InProc"),
                    szMode, sizeof(szMode)/sizeof(TCHAR));

	i = 0;
	while (saModeNames[i])
	{
	    if (lstrcmpi (saModeNames[i], szMode) == 0)
		return dwaModes[i];
	    i++;
	}

	return dwaModes[0];
}


//+-------------------------------------------------------------------
//
//  Member:	GetOleInitFlag,public
//
//  Synopsis:	Gets OleInitialize flag
//
//  Parameters:
//
//  History:   	13-August-93   t-martig	Created
//
//--------------------------------------------------------------------
DWORD CTestInput::GetOleInitFlag(void)
{
	TCHAR szInitFlag[60];

	GetPrivateProfileString (TEXT("Driver"), TEXT("InitFlag"),
				  TEXT("COINIT_APARTMENTTHREADED"),
				  szInitFlag, sizeof(szInitFlag)/sizeof(TCHAR),
				  m_szFileName);

#ifdef THREADING_SUPPORT
	if (lstrlen(szInitFlag)==0)
	    return COINIT_APARTMENTTHREADED;

	if (!lstrcmpi(szInitFlag, TEXT("COINIT_MULTITHREADED")))
	    return COINIT_MULTITHREADED;
	else
#endif
	    return 2; // COINIT_APARTMENTTHREADED;
}


//+-------------------------------------------------------------------
//
//  Member:	GetInfoLevelFlag,public
//
//  Synopsis:	Gets InfoLevel flag
//
//  Parameters:
//
//  History:   	13-August-93   t-martig	Created
//
//--------------------------------------------------------------------
DWORD CTestInput::GetInfoLevelFlag(void)
{
	TCHAR szInfoFlag[60];

	GetPrivateProfileString (TEXT("Driver"), TEXT("InfoLevel"),
				  TEXT("BASE"),
				  szInfoFlag, sizeof(szInfoFlag)/sizeof(TCHAR),
				  m_szFileName);

	if (lstrlen(szInfoFlag)==0)
	    return 0;

	if (!lstrcmpi(szInfoFlag, TEXT("FULL")))
	    return 1;
	else
	    return 0;
}


//+-------------------------------------------------------------------
//
//  Member: 	GetGUID,public
//
//  Synopsis:	Gets GUID from .ini file
//
//  Parameters: [pClsID]		Address where to put class ID
//		[lpszTestName]		Section
//		[lpszEntry]		Entry name
//
//  History:   	13-August-93   t-martig	Created
//
//--------------------------------------------------------------------
SCODE CTestInput::GetGUID (CLSID *pClsID, LPTSTR lpszTestName,
			   LPTSTR lpszEntry)
{
	TCHAR szClsID[60];
    LPOLESTR lpszClsID;

	GetConfigString (lpszTestName, lpszEntry, TEXT(""),
                    szClsID, sizeof(szClsID)/sizeof(TCHAR));

	if (lstrlen(szClsID)==0)
	    return E_FAIL;
#ifdef UNICODE
    lpszClsID = szClsID;
#else
    OLECHAR szTmp[60];
    MultiByteToWideChar(CP_ACP, 0, szClsID, -1, szTmp, 60);
    lpszClsID = szTmp;
#endif

	return CLSIDFromString(lpszClsID, pClsID);
}



//+-------------------------------------------------------------------
//
//  Member: 	GetClassID,public
//
//  Synopsis:	Gets the custom class ID from .ini file
//		(entry name = "ClsID")
//
//  Parameters: [pClsID]		Address where to put class ID
//		[lpszTestName]		Section under which "ClsID"
//					is listed
//
//  History:   	13-July-93   t-martig	Created
//
//--------------------------------------------------------------------
SCODE CTestInput::GetClassID (CLSID *pClsID, LPTSTR lpszTestName)
{
	return GetGUID(pClsID, lpszTestName, TEXT("ClsID"));
}



//+-------------------------------------------------------------------
//
//  Member:	GetIterations, public
//
//  Synopsis:	returns the iteration count for the test. if out of
//		range, it returns either 1 or TEST_MAX_ITERATIONS.
//
//  History:	07-July-94  t-vadims  Modified to use new GetConfigInt function.
//
//+-------------------------------------------------------------------
DWORD CTestInput::GetIterations (LPTSTR lpszTestName, int iIterDefault)
{
	int iIterations;

	iIterations = GetConfigInt (lpszTestName, TEXT("Iterations"), iIterDefault);

	if (iIterations > TEST_MAX_ITERATIONS)
	    iIterations = TEST_MAX_ITERATIONS;

	return (iIterations > 0) ? iIterations : 1;
}


//+-------------------------------------------------------------------
//
//  Member:	GetRealIterations, public
//
//  Synopsis:	returns the iteration count for the test.  Does not
//		range check.
//
//  History:	07-July-94  t-vadims  Modified to use new GetConfigInt function.
//
//+-------------------------------------------------------------------
DWORD CTestInput::GetRealIterations (LPTSTR lpszTestName, int iIterDefault)
{
	int iIterations;

	iIterations = GetConfigInt (lpszTestName, TEXT("Iterations"), iIterDefault);

	return (iIterations > 0) ? iIterations : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\bmoutput.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmoutput.cxx
//
//  Contents:	output class for benchmark results
//
//  Classes:	CTestOutput
//
//  Functions:	
//
//  History:    30-June-93 t-martig    Created
//              15-Aug-94  davidfie    Make ASCII/Unicode for chicago
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bmoutput.hxx>

//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::CTestOutput, public
//
//  Synopsis:	Generates output file
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

CTestOutput::CTestOutput (LPTSTR lpszFileName)
{
#ifdef UNICODE
	char szFileName[80];

	wcstombs (szFileName, lpszFileName, wcslen(lpszFileName)+1);
	fpOut = fopen (szFileName, "wt");
#else
	fpOut = fopen (lpszFileName, "wt");
#endif
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::~CTestOutput, public
//
//  Synopsis:	Closes output file
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------


CTestOutput::~CTestOutput ()
{
	if (fpOut)
		fclose (fpOut);
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::Flush, public
//
//  Synopsis:	flushes the buffers associated with the output file
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::Flush(void)
{
	fflush (fpOut);
}



//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteTextString, public
//
//  Synopsis:	Writes a TEXT format string to output file
//
//  Parameters: [lpswzString]	String to be printed
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteTextString (LPTSTR lpszString)
{
	WriteString(lpszString);
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteString, public
//
//  Synopsis:	Writes string to output file
//
//  Parameters: [lpszString]	String to be printed
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteString (LPTSTR lpszString)
{
#ifdef UNICODE
	char *fmt = "%ws";
#else
	char *fmt = "%s";
#endif

	if (!fpOut)
		return;
	fprintf (fpOut, fmt, lpszString);
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteLong, public
//
//  Synopsis:	Writes long to output file
//
//  Parameters: [lpswzString]	String to be printed
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteLong (ULONG l)
{
	if (!fpOut)
		return;
	fprintf (fpOut, "%lu", l);
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteConfigEntry, public
//
//  Synopsis:	Writes string from config file to output file
//
//  Parameters:	[input]		Input class (config file)
//		[lpszSection]	Section name of entry to be printed
//		[lpszEntry]	Entry name to be printed
//		[lpszDefault]	Default string in case entry does
//				not exist
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteConfigEntry (CTestInput &input, LPTSTR lpszSection,
	LPTSTR lpszEntry, LPTSTR lpszDefault)
{
	TCHAR destName[160];

	if (!fpOut)
		return;
	
	input.GetConfigString (lpszSection, lpszEntry, lpszDefault,
		destName, sizeof(destName)/sizeof(TCHAR));

	WriteString (destName);
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteSectionHeader, public
//
//  Synopsis:	Writes general test section header to output file
//
//  Parameters: [lpszTestName]		General test name (from
//					[TestClass].Name(),like "OLE")
//		[lpszSectionName]	Specific test name (like
//					"Object Bind Test")
//		[input]			.ini file class
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteSectionHeader (LPTSTR lpszTestName,
	LPTSTR lpszSectionName, CTestInput &input)
{
	if (!fpOut)
		return;

	if (!lpszSectionName)
		lpszSectionName = TEXT("");


	if (g_fFullInfo)
	{
#ifdef UNICODE
    char *fmt = "\n\n%ws - %ws\n\nComments:\t";
#else
    char *fmt = "\n\n%s - %s\n\nComments:\t";
#endif
	    //	we conditionally skip writing the comment to make it
	    //	easier to format for excel.
	    fprintf (fpOut, fmt, lpszTestName, lpszSectionName);

	    WriteConfigEntry (input, lpszTestName, TEXT("comment"));
	    fprintf (fpOut, "\n");
	}
	else
	{
#ifdef UNICODE
    char *fmt = "\n\n%ws\n";
#else
    char *fmt = "\n\n%s\n";
#endif
	    fprintf (fpOut, fmt, lpszSectionName);
	}
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteResult, public
//
//  Synopsis:	Writes test result line to output file, in the form
//		"Create moniker <tab> 30800"
//
//  Parameters: [lpszMeasurementName]	Name of result (like
//					"Create moniker"
//		[ulTime]		Measured time in microseconds
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteResult (LPTSTR lpszMeasurementName, ULONG ulTime)
{
	if (fpOut)
	{
	    WriteString (lpszMeasurementName);
	    fprintf (fpOut, "\t");

	    if (ulTime == NOTAVAIL)
	    {
		fprintf (fpOut, "n/a\n");
	    }
	    else if (ulTime == TEST_FAILED)
	    {
		fprintf (fpOut, "F\n");
	    }
	    else
	    {
		fprintf (fpOut, "%lu\n", ulTime);
	    }
	}
}


//+-------------------------------------------------------------------
//
//  Member:	CTestOutput::WriteResult, public
//
//  Synopsis:	Writes test results over several columns
//
//  Parameters: [lpszMeasurementName]	Name of result (like
//					"Create moniker"
//		[iIterations]		Number of results
//		[paUlTime]		Array with measurement times
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteResults (LPTSTR lpszMeasurementName, int iIterations,
				ULONG *paUlTimes)
{
	int i;

	if (fpOut)
	{
	    WriteString (lpszMeasurementName);

	    for (i=0; i<iIterations; i++)
	    {
		if (paUlTimes[i] == NOTAVAIL)
		{
		    fprintf (fpOut, "\tn/a");
		}
		else  if (paUlTimes[i] == TEST_FAILED)
		{
		    fprintf (fpOut, "\tF");
		}
		else
		{
		    fprintf (fpOut, "\t%lu", paUlTimes[i]);
		}
	    }

	    fprintf (fpOut, "\n");
	}
}


//+-------------------------------------------------------------------
//
//  Member: 	WriteClassCtx, public
//
//  Synopsis:	Prints the class activation conL as string to
//		a specified output class
//
//  Parameters: [dwClsCtx]		Class conL to be printed
//
//		CLSCTX_INPROC_SERVER	--> "InProc"
//		CLSCTX_LOCAL_SERVER	--> "LocaL"
//		CLSCTX_INPROC_HANDLER	--> "Handler"
//		any other				--> "Unknown"
//
//  History:   	12-July-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteClassCtx (DWORD dwClsCtx)
{
	LPTSTR pc = TEXT("Unknown");
	int i = 0;

	while (saModeNames[i])
	{
	    if (dwaModes[i] == dwClsCtx)
	    {
		pc = saModeNames[i];
		break;
	    }
	    i++;
	}

	WriteString (TEXT("ClsCtx\t"));
	WriteString (pc);
	WriteString (TEXT("\n"));
}


//+-------------------------------------------------------------------
//
//  Member:	WriteClassID
//
//  Synopsis:	Prints the class ID as string to
//		a specified output class
//
//  Parameters: [pClsID]     Class ID to be printed
//
//  History:   	13-July-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteClassID (CLSID *pClsID)
{
    if (g_fFullInfo)
    {
	TCHAR szGUID[50];

	WriteString (TEXT("ClsID\t"));
	StringFromGUID(*pClsID, szGUID);
	WriteString (szGUID);
	WriteString (TEXT("\n"));
    }
}


//+-------------------------------------------------------------------
//
//  Member:	WriteTime
//
//  Synopsis:	Prints time to a specified output class
//
//  Parameters: [pstTime]	 System time
//
//  History:   	5-August-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteTime (_SYSTEMTIME *pstTime)
{
	WORD wHour;
	char cAmpm;

	if (fpOut)
	{
		cAmpm = 'a';
		wHour = pstTime->wHour;

		if (wHour >= 12)
		{
			cAmpm = 'p';
			if (wHour > 12)
				wHour-=12;
		}
		if (wHour==0)
			wHour=12;

		fprintf (fpOut, "%d:%02d%c", wHour, pstTime->wMinute, cAmpm);
	}
}


//+-------------------------------------------------------------------
//
//  Member:	WriteDate
//
//  Synopsis:	Prints date to a specified output class
//
//  Parameters: [pstdate]	  System date
//
//  History:   	5-August-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteDate (_SYSTEMTIME *pstDate)
{
	if (fpOut)
	{
		fprintf (fpOut, "%02d-%02d-%02d",
			pstDate->wMonth, pstDate->wDay, pstDate->wYear % 100);
	}
}


//+-------------------------------------------------------------------
//
//  Member:	WriteSCODE
//
//  Synopsis:	Prints an SCODE to a specified output class
//
//  Parameters: [sc]	  	  SCODE	
//
//  History:   	5-August-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::WriteSCODE (SCODE sc)
{
	if (fpOut)
		fprintf (fpOut, "%xh/%xh", SCODE_FACILITY(sc), SCODE_CODE(sc));
}


//+-------------------------------------------------------------------
//
//  Member:	StringFromGUID
//
//  Synopsis:	converts a GUID into a string so that it may be
//		printed to a specified output class
//
//  Parameters: [pClsID]     Class ID to be printed
//
//  History:   	13-July-93   t-martig	Created
//
//--------------------------------------------------------------------

void CTestOutput::StringFromGUID(GUID &rguid, LPTSTR lpsz)
{
    wsprintf(lpsz, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
            rguid.Data1, rguid.Data2, rguid.Data3,
            rguid.Data4[0], rguid.Data4[1],
            rguid.Data4[2], rguid.Data4[3],
            rguid.Data4[4], rguid.Data4[5],
            rguid.Data4[6], rguid.Data4[7]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\bmlog.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmlog.cxx
//
//  Contents:	Benchmark test error logging
//
//  Classes:	
//
//  Functions:	
//
//  History:    29-July-93 t-martig    Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bmoutput.hxx>
#include <bmlog.hxx>

CTestOutput *logOutput;


//+------------------------------------------------------------------------
//
//  funtion:	LogTo
//
//  purpose:	writes the benchmark header to the logfile
//
//+------------------------------------------------------------------------

void LogTo (CTestOutput *_logOutput)
{
    logOutput = _logOutput;
    _SYSTEMTIME stTimeDate;

    logOutput->WriteString (TEXT("CairOLE Benchmark Log File\t"));
    GetLocalTime (&stTimeDate);
    logOutput->WriteDate (&stTimeDate);
    logOutput->WriteString (TEXT("\t"));
    logOutput->WriteTime (&stTimeDate);
    logOutput->WriteString (TEXT("\n\n"));
}


//+------------------------------------------------------------------------
//
//  funtion:	LogSection
//
//  purpose:	writes the section header to the logfile
//
//+------------------------------------------------------------------------

void LogSection (LPTSTR lpszName)
{
    if (!logOutput)
	return;

    logOutput->WriteString (lpszName);
    logOutput->WriteString (TEXT("\n"));
}
	

//+------------------------------------------------------------------------
//
//  funtion:	Log
//
//  purpose:	records the result of one action taken by the benchmark test
//
//+------------------------------------------------------------------------

int Log (LPTSTR lpszActionName, SCODE hr)
{
    if (!logOutput)
	return !SUCCEEDED(hr);

    logOutput->WriteString (TEXT("    "));
    logOutput->WriteString (lpszActionName);

    if (SUCCEEDED(hr))
    {
	logOutput->WriteString (TEXT("\tOK\n"));
	return FALSE;
    }
    else
    {
	logOutput->WriteString (TEXT("\tERROR: "));
	logOutput->WriteSCODE (hr);
	logOutput->WriteString (TEXT("\n"));
	return TRUE;
    }
}

		
int Log (LPTSTR lpszActionName, ULONG ulCode)
{
    if (!logOutput)
        return FALSE;

    logOutput->WriteString (TEXT("    "));
    logOutput->WriteString (lpszActionName);
	logOutput->WriteLong(ulCode);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\stream.cxx ===
//+-------------------------------------------------------------------
//
//  File:	stream.cxx
//
//  Contents:	Stream interface on flat File.
//
//  Classes:	CStreamOnFile
//
//  Macros:     DEFINE_INTERFACE_XMIT_ROUTINES
//
//  History:	08-08-95    Rickhi  Created
//
//--------------------------------------------------------------------
#include    <ole2.h>
#include    <stream.hxx>


CStreamOnFile::CStreamOnFile(const WCHAR *pwszFileName, SCODE &sc, BOOL fRead) :
    _clRefs(1),
    _hFile(NULL),
    _lOffset(0),
    _cSize(0),
    _cbData(0),
    _fRead(fRead)
{
    _pbData = new BYTE[2048];		    // should be big enough
    if (!_pbData)
    {
	sc = E_OUTOFMEMORY;
	return;
    }

    _cbData = 2048;

    // open the file.
    DWORD fdwCreate = (_fRead) ? OPEN_EXISTING : CREATE_ALWAYS;


    _hFile = CreateFile(pwszFileName,
			GENERIC_READ | GENERIC_WRITE,	    // fdwAccess
			FILE_SHARE_READ | FILE_SHARE_WRITE, // fdwShareMode
			NULL,			// lpsaSecurity
			fdwCreate,		// creation options
			FILE_ATTRIBUTE_NORMAL,	// attributes & flags
			NULL			// hTemplateFile
			);

    if (_hFile == INVALID_HANDLE_VALUE)
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    // read the file into the memory block
    DWORD cbRead = 0;
    if (_fRead && ! ReadFile(_hFile,
			    _pbData,
			    _cbData,
			    &cbRead,
			    NULL))
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    if (_fRead)
    {
	_cSize = _cbData;
    }

    sc = S_OK;
}

CStreamOnFile::~CStreamOnFile(void)
{
    if (_hFile)
    {
	if (!_fRead)
	{
	    // write the data to the file
	    DWORD cbWritten = 0;
	    if (!WriteFile(_hFile,
			   _pbData,
			   _cbData,
			   &cbWritten,
			   NULL))
	    {
		SCODE sc = HRESULT_FROM_WIN32(GetLastError());
	    }
	}

	CloseHandle(_hFile);
    }
}



STDMETHODIMP CStreamOnFile::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and IStream
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
	IsEqualIID(iidInterface, IID_IStream))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) CStreamOnFile::AddRef(void)
{
    InterlockedIncrement(&_clRefs);
    return _clRefs;
}

STDMETHODIMP_(ULONG) CStreamOnFile::Release(void)
{
    if (InterlockedDecrement(&_clRefs) == 0)
    {
	delete this;
	return 0;
    }

    return _clRefs;
}

STDMETHODIMP CStreamOnFile::Read(
    VOID HUGEP* pv,
    ULONG cb,
    ULONG FAR* pcbRead)
{
    HRESULT hresult = S_OK;

    if (pcbRead)
    {
        *pcbRead = 0L;
    }

    if ((LONG)cb + _lOffset > _cSize)
    {
	cb = _cSize - _lOffset;
        hresult = STG_E_READFAULT;
    }

    memcpy(pv, _pbData + _lOffset, (size_t) cb);
    _lOffset += cb;

    if (pcbRead != NULL)
    {
        *pcbRead = cb;
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::Write(
    VOID  const HUGEP* pv,
    ULONG cbToWrite,
    ULONG FAR* pcbWritten)
{
    HRESULT hresult = S_OK;

    if (pcbWritten)
    {
        *pcbWritten = 0L;
    }

    if (cbToWrite + _lOffset > _cbData)
    {
	return E_OUTOFMEMORY;
    }

    // copy in the new data
    memcpy(_pbData + _lOffset, pv, (size_t) cbToWrite);
    _lOffset += cbToWrite;

    if (pcbWritten != NULL)
    {
	*pcbWritten = cbToWrite;
    }

    // We assume maxium size of buffer is the size to send on the network.
    if (_cSize < _lOffset)
    {
	_cSize = _lOffset;
    }

    return hresult;
}



STDMETHODIMP CStreamOnFile::Seek(
    LARGE_INTEGER dlibMoveIN,
    DWORD dwOrigin,
    ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = S_OK;

    LONG  dlibMove = dlibMoveIN.LowPart;
    ULONG cbNewPos = dlibMove;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:

        if (dlibMove >= 0)
        {
            _lOffset = dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:

        if (!(dlibMove < 0 && (-dlibMove > _lOffset)))
        {
            _lOffset += (ULONG) dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_END:

	if (!(dlibMove < 0 && ((ULONG) -dlibMove) > _cbData))
        {
	    _lOffset = _cbData + dlibMove;
        }
	else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    default:

        hresult = STG_E_SEEKERROR;
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, _lOffset);
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::SetSize(ULARGE_INTEGER cb)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::CopyTo(
    IStream FAR* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER FAR* pcbRead,
    ULARGE_INTEGER FAR* pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::Revert(void)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::Stat(
    STATSTG FAR* pstatstg,
    DWORD statflag)
{
    memset(pstatstg, 0, sizeof(STATSTG));
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Clone(IStream FAR * FAR *ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\bm_base.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bm_base.cxx
//
//  Contents:	output class for benchmark results
//
//  Classes:	CTestBase
//
//  Functions:	
//
//  History:    30-June-93 t-martig    Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bm_base.hxx>


SCODE CTestBase::Setup (CTestInput *pInput)
{
    m_pInput = pInput;

    // get the OleInitialize flag.
    m_dwInitFlag = m_pInput->GetOleInitFlag();

    return S_OK;
}


SCODE CTestBase::Cleanup ()
{
    return S_OK;
}


SCODE CTestBase::InitOLE()
{
    SCODE sc;

#ifdef OLE_THREADING_SUPPORT
    if (m_dwInitFlag == COINIT_MULTITHREADED)
    {
	// we are Cairo and want MULTI_THREADING, call OleInitEx
	sc = OleInitializeEx(NULL, m_dwInitFlag);
    }
    else
#endif // OLE_THREADING_SUPPORT
    {
	sc = OleInitialize(NULL);
    }

    return sc;
}

void CTestBase::UninitOLE()
{
    OleUninitialize();
}


SCODE CTestBase::InitCOM()
{
    SCODE sc;

#ifdef COM_THREADING_SUPPORT
    if (m_dwInitFlag == COINIT_MULTITHREADED)
    {
	// we are Cairo and want MULTI_THREADING, call OleInitEx
	sc = CoInitializeEx(NULL, m_dwInitFlag);
    }
    else
#endif // COM_THREADING_SUPPORT
    {
	sc = CoInitialize(NULL);
    }

    return sc;
}


void CTestBase::UninitCOM()
{
    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\cqisrv.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	cqi.cxx
//
//  Contents:	implementations for QueryInterface test
//
//  Functions:
//		CQI::CQI
//		CQI::~CQI
//		CQI::QueryInterface
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
#include    <headers.cxx>
#pragma     hdrstop
#include    <cqisrv.hxx>	 // class definition

//+-------------------------------------------------------------------------
//
//  Method:	CQI::CQI
//
//  Synopsis:	Creates an instance of CQI
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
CQI::CQI(void) : _cRefs(1)
{
}

CQI::~CQI(void)
{
    //	automatic actions are enough
}

//+-------------------------------------------------------------------------
//
//  Method:	CQI::AddRef/Release
//
//  Synopsis:	track reference counts
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CQI::AddRef(void)
{
    InterlockedIncrement((LONG *)&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) CQI::Release(void)
{
    if (InterlockedDecrement((LONG *)&_cRefs) == 0)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

//+-------------------------------------------------------------------------
//
//  Method:	CQI::QueryInterface
//
//  Synopsis:	returns ptr to requested interface.
//
//		DANGER: this returns SUCCESS on almost every interface,
//		though the only valid methods on any interface are IUnknown.
//
//  Arguments:	[riid] - interface instance requested
//		[ppv]  - where to put pointer to interface instance
//
//  Returns:	S_OK or E_NOINTERFACE
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CQI::QueryInterface(REFIID riid, void **ppv)
{
    //	the interface cant be one of these or marshalling will fail.

    if (IsEqualIID(riid,IID_IUnknown) ||
	IsEqualIID(riid,IID_IAdviseSink) ||
	IsEqualIID(riid,IID_IDataObject) ||
	IsEqualIID(riid,IID_IOleObject) ||
	IsEqualIID(riid,IID_IOleClientSite) ||
	IsEqualIID(riid,IID_IParseDisplayName) ||
	IsEqualIID(riid,IID_IPersistStorage) ||
	IsEqualIID(riid,IID_IPersistFile) ||
	IsEqualIID(riid,IID_IStorage) ||
	IsEqualIID(riid,IID_IOleContainer) ||
	IsEqualIID(riid,IID_IOleItemContainer) ||
	IsEqualIID(riid,IID_IOleInPlaceSite) ||
	IsEqualIID(riid,IID_IOleInPlaceActiveObject) ||
	IsEqualIID(riid,IID_IOleInPlaceObject) ||
	IsEqualIID(riid,IID_IOleInPlaceUIWindow) ||
	IsEqualIID(riid,IID_IOleInPlaceFrame) ||
	IsEqualIID(riid,IID_IOleWindow))
    {
	*ppv = (void *)(IUnknown *) this;
	AddRef();
	return S_OK;
    }
    else
    {
	*ppv = NULL;
	return E_NOINTERFACE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\bm_parse.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//					 
//  File:	bm_parse.cxx
//
//  Contents:	Implementation of Base class for generic parsers
//
//  Classes:	CTimerBase
//
//  Functions:	
//
//  History:    16-June-94 t-vadims    Created
//
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bm_parse.hxx>

#define  MAX_INSTR_LENGTH    150

#define BLANK_LINE	(FIRST_INTERNALID + 2)

//
// Structure for linked list of instructions with their timings
//
struct SInstruction
{
    ULONG ulID;
    ULONG ulTime[TEST_MAX_ITERATIONS];
    SInstruction *pNext;
};



//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::Setup, public
//
//  Synopsis:	Makes all neccessary initializations.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::Setup (CTestInput *pInput)
{
    SCODE 	sc;
    char 	szFileName[80];
    TCHAR	szBuf[80];


    CTestBase::Setup(pInput);

    m_iIterations = pInput->GetIterations(Name());

    // get name of the script file
    pInput->GetConfigString(Name(), TEXT("ScriptName"), TEXT("script.txt"), szBuf, 80);

#ifdef UNICODE
    wcstombs(szFileName, szBuf, 80);
#else
    strcpy(szFileName, szBuf);
#endif

    m_fpIn = fopen(szFileName, "r");
    if(m_fpIn == NULL)
    {
    	Log(TEXT("Can't open script file"), STG_E_FILENOTFOUND);
    	return STG_E_FILENOTFOUND;
    }


    m_pParser = NULL;
    sc = SetParserObject();       // virtual call to setup m_pParser object.

    if(m_pParser == NULL)
    	sc = E_FAIL;

    if(FAILED(sc))
    {
    	Log(TEXT("Setup failed to initialize parser object"), sc);
	fclose(m_fpIn);
    	return sc;
    }

#ifdef THREADING_SUPPORT
    OleInitializeEx(NULL, pInput->GetOleInitFlag());
#else
    OleInitialize(NULL);
#endif

    sc = m_pParser->Setup(pInput);
    if(FAILED(sc))
    {
    	Log(TEXT("Setup of Parser object failed"), sc);
	DeleteParserObject();
	OleUninitialize();
	fclose(m_fpIn);
    	return sc;
    }

    m_pHead = NULL;
    m_iLine = 0;
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::Cleanup, public
//
//  Synopsis:	Clean everything up.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::Cleanup ()
{
    SInstruction *pInstr, *pNextInstr;

    pInstr = m_pHead;
    while (pInstr != NULL)
    {
	pNextInstr = pInstr->pNext;
	delete pInstr;
	pInstr = pNextInstr;
    }
    m_pHead = NULL;

    m_pParser->Cleanup();
    DeleteParserObject();
    fclose (m_fpIn);

    OleUninitialize();

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::Run, public
//
//  Synopsis:	Read and execute the script file.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------

SCODE CTimerBase::Run ()
{
    ReadFile ();
    ExecuteFile ();
    return S_OK;
}



BOOL CTimerBase::IsEmptyLine (LPTSTR pszLine)
{
    while (*pszLine)
    {
    	if ( *pszLine != TEXT(' ') && *pszLine != TEXT('\n') &&
	     *pszLine != TEXT('\t'))
	   return FALSE;

	pszLine++;
    }

    return TRUE;
}



BOOL CTimerBase::IsInternalID (ULONG ulID)
{
    return (ulID >= FIRST_INTERNALID);
}

//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::ReadFile, private
//
//  Synopsis:	Reads script file, adding each instruction to the
//		link list.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::ReadFile ()
{
    TCHAR 	   szBuf[MAX_INSTR_LENGTH];
    SInstruction  *pTail 	= NULL;
    ULONG	   ulID;
    	

    while ( SUCCEEDED(GetNextLine(szBuf)))  // get line from file to szBuf
    {
    	m_iLine ++;
		
     	if (IsEmptyLine(szBuf))
    	{
	    pTail = AddNewInstruction(pTail, BLANK_LINE);
    	}
    	else
    	{    
    	    ulID = m_pParser->ParseNewInstruction(szBuf);

	    if (ulID == INVALID_INSTRUCTION)
	    {
	    	wsprintf(szBuf, TEXT("Invalid instruction on line %d"), m_iLine );
		Log(szBuf, E_FAIL);
	    }
    	    else if(ulID != NOT_INSTRUCTION)     // valid instruction
	    {
	    	pTail = AddNewInstruction(pTail, ulID);
	    }
    	}
    }
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::AddNewInstruction, private
//
//  Synopsis:	Adds new instruction to linked list
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SInstruction *CTimerBase::AddNewInstruction(SInstruction *pTail, ULONG ulID)
{
    SInstruction *pInstruction = new SInstruction;

    pInstruction->ulID = ulID;
    pInstruction->pNext = NULL;
    INIT_RESULTS(pInstruction->ulTime);

    if (m_pHead == NULL)           // first instruction
    {
    	m_pHead = pTail = pInstruction;
    }
    else
    {
	pTail->pNext = pInstruction;
	pTail = pInstruction;
    }		      

    return pTail;
}


//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::GetNextLine, private
//
//  Synopsis:	Reads the next line from the file.
//		Returns E_FAIL on end of file
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::GetNextLine(LPTSTR pszLine)
{
#ifdef UNICODE
    CHAR szBuf[MAX_INSTR_LENGTH];

    if (fgets(szBuf, MAX_INSTR_LENGTH, m_fpIn) != NULL)
    {
    	mbstowcs(pszLine, szBuf, MAX_INSTR_LENGTH); 
    	return S_OK;
    }
#else
    if (fgets(pszLine, MAX_INSTR_LENGTH, m_fpIn) != NULL)
    {
    	return S_OK;
    }
#endif
    else
    	return E_FAIL;
}


//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::ExecuteFile, private
//
//  Synopsis:	Loops throug the linked list execute each command, and 
//		recording timings.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::ExecuteFile()
{
    ULONG 	   iIter;
    SInstruction  *pInstr;

    for (iIter = 0; iIter < m_iIterations; iIter++)
    {
        pInstr = m_pHead;
	while (pInstr != NULL)
	{
	    if (!IsInternalID(pInstr->ulID))
	    	pInstr->ulTime[iIter] = m_pParser->ExecuteInstruction(pInstr->ulID);
	    pInstr = pInstr->pNext;
	}
    }

    return S_OK;
}



//+-------------------------------------------------------------------
//
//  Member:	CTimerBase::Report, public
//
//  Synopsis:	Loops throug the linked list, outputing timings of each command.
//
//  History:   	16-June-94   t-vadims	Created
//
//--------------------------------------------------------------------
SCODE CTimerBase::Report (CTestOutput &output)
{
    SInstruction  *pInstr = m_pHead;

    output.WriteSectionHeader (Name(), SectionHeader(), *m_pInput);
    output.WriteString (TEXT("\n"));

    while (pInstr != NULL)
    {
    	if (pInstr->ulID == BLANK_LINE)
	    output.WriteString (TEXT("\n"));
	else
    	    output.WriteResults (m_pParser->InstructionName(pInstr->ulID), 
    			   	 m_iIterations, pInstr->ulTime);

	pInstr = pInstr->pNext;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\bmrpc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmrpc.cxx
//
//  Contents:	common Raw Rpc code
//
//  Classes:	None
//
//  Functions:	
//
//  History:	02-Feb-94   Rickhi	Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <rawrpc.h>

extern "C" const GUID IID_IRawRpc =
    {0x00000145,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};



extern "C" void _gns__GUID (GUID* _target, PRPC_MESSAGE _prpcmsg);


//+-------------------------------------------------------------------------
//
//  Function:	MIDL_user_allocate
//
//  Synopsis:   Allocate memory via OLE task allocator.
//
//--------------------------------------------------------------------------
void *__stdcall MIDL_user_allocate(size_t size)
{
    void *pMemory = (void *) new BYTE[size];

    if(pMemory == 0)
	RaiseException((unsigned long)E_OUTOFMEMORY, 0, 0, 0);

    return pMemory;
}

//+-------------------------------------------------------------------------
//
//  Function:	MIDL_user_free
//
//  Synopsis:   Free memory using OLE task allocator.
//
//--------------------------------------------------------------------------
void __stdcall MIDL_user_free(void *pMemory)
{
    delete pMemory;
}



/* routine that gets node for struct _GUID */
void _gns__GUID (GUID  * _target, PRPC_MESSAGE _prpcmsg)
{
  unsigned long _alloc_total;
  ((void)( _alloc_total ));
  *(unsigned long *)&_prpcmsg->Buffer += 3;
  *(unsigned long *)&_prpcmsg->Buffer &= 0xfffffffc;
  /* receive data into &_target->Data1 */
  long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&_target->Data1);
  /* receive data into &_target->Data2 */
  short_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned short *)&_target->Data2);
  /* receive data into &_target->Data3 */
  short_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned short *)&_target->Data3);
  char_array_from_ndr ((PRPC_MESSAGE)_prpcmsg, 0, 0 + 8, (unsigned char *)_target->Data4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\driver\bmdriver.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmdriver.cxx
//
//  Contents:	Main module of the benchmark test
//
//  Classes:	CBenchMarkDriver
//
//  Functions:	WinMain
//
//  History:    30-June-93 t-martig    Created
//		        07-June-94 t-vadims    Added Storage tests
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <bmdriver.hxx>

#include <bm_activ.hxx>
#include <bm_alloc.hxx>
#include <bm_api.hxx>
#include <bm_cgps.hxx>
#include <bm_iid.hxx>
#include <bm_init.hxx>
#include <bm_marsh.hxx>
#include <bm_mrsh2.hxx>
#include <bm_noise.hxx>
#include <bm_nest.hxx>
#include <bm_obind.hxx>
#include <bm_props.hxx>
#include <bm_qi.hxx>
#include <bm_regis.hxx>
#include <bm_rot.hxx>
#include <bm_rpc.hxx>
#include <bm_rpc2.hxx>
#include <bm_rrpc.hxx>
#include <bm_sbind.hxx>
#include <bm_filio.hxx>
#include <bm_stg.hxx>
#include <bm_nstg.hxx>
#include <bmp_stg.hxx>
#include "..\cairole\ui\hlp_iocs.hxx"
#include "..\cairole\ui\hlp_ias.hxx"
#include "..\cairole\ui\hlp_site.hxx"
#include "..\cairole\ui\hlp_doc.hxx"
#include "..\cairole\ui\bm_crt.hxx"
#include "..\cairole\ui\bm_crtl.hxx"
//#include "..\cairole\ui\bm_clip.hxx"
#include "..\cairole\ui\bm_load.hxx"
#include "..\cairole\ui\bm_link.hxx"
#include "..\cairole\ui\bm_cache.hxx"


#define REGISTRY_ENTRY_LEN 256

typedef struct
{
  const char *key;
  const char *value;
} RegistryKeyValue;

const RegistryKeyValue REG_CONST_KEY[] =
{
  ".bm1", "CLSID\\{99999999-0000-0008-C000-000000000052}",
  ".bm2", "CLSID\\{99999999-0000-0008-C000-000000000051}",

  "CLSID\\{20730701-0001-0008-C000-000000000046}", "OleTestClass",
  "CLSID\\{20730711-0001-0008-C000-000000000046}", "OleTestClass1",
  "CLSID\\{20730712-0001-0008-C000-000000000046}", "OleTestClass2",
  "CLSID\\{20730713-0001-0008-C000-000000000046}", "OleTestClass3",
  "CLSID\\{20730714-0001-0008-C000-000000000046}", "OleTestClass4",
  "CLSID\\{20730715-0001-0008-C000-000000000046}", "OleTestClass5",
  "CLSID\\{20730716-0001-0008-C000-000000000046}", "OleTestClass6",
  "CLSID\\{20730717-0001-0008-C000-000000000046}", "OleTestClass7",
  "CLSID\\{20730718-0001-0008-C000-000000000046}", "OleTestClass8",

  "CLSID\\{00000138-0001-0008-C000-000000000046}", "CPrxyBalls",
  "Interface\\{00000138-0001-0008-C000-000000000046}", "IBalls",
  "Interface\\{00000139-0001-0008-C000-000000000046}", "ICube",
  "Interface\\{00000136-0001-0008-C000-000000000046}", "ILoops",
  "Interface\\{00000137-0001-0008-C000-000000000046}", "IRpcTest",

  "Interface\\{00000138-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "Interface\\{00000139-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "Interface\\{00000136-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "Interface\\{00000137-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "CLSID\\{0000013a-0001-0008-C000-000000000046}\\ProgID", "ProgID60",
  "CLSID\\{0000013a-0001-0008-C000-000000000046}", "CBallsClassFactory",
  "CLSID\\{0000013b-0001-0008-C000-000000000046}", "CCubesClassFactory",
  "CLSID\\{0000013c-0001-0008-C000-000000000046}", "CLoopClassFactory",
  "CLSID\\{0000013d-0001-0008-C000-000000000046}", "CRpcTestClassFactory",
  "CLSID\\{00000140-0000-0008-C000-000000000046}", "CQueryInterface",
  "CLSID\\{00000142-0000-0008-C000-000000000046}", "Dummy",


  ".ut4", "ProgID50",
  ".ut5", "ProgID51",
  ".ut6", "ProgID52",
  ".ut7", "ProgID53",
  ".ut8", "ProgID54",
  ".ut9", "ProgID55",
  ".bls", "ProgID60",

  "CLSID\\{99999999-0000-0008-C000-000000000050}", "SDI",
  "CLSID\\{99999999-0000-0008-C000-000000000051}", "MDI",
  "CLSID\\{99999999-0000-0008-C000-000000000052}", "InprocNoRegister",
  "CLSID\\{99999999-0000-0008-C000-000000000053}", "InprocRegister",
  "CLSID\\{99999999-0000-0008-C000-000000000054}", "InprocRegister",
  "CLSID\\{99999999-0000-0008-C000-000000000054}\\TreatAs", "{99999999-0000-0008-C000-000000000050}",
  "CLSID\\{99999999-0000-0008-C000-000000000055}", "MDI",
  "CLSID\\{99999999-0000-0008-C000-000000000055}\\ActivateAtBits", "Y",

  "ProgID50", "objact sdi",
  "ProgID50\\CLSID", "{99999999-0000-0008-C000-000000000050}",
  "ProgID51", "objact mdi",
  "ProgID51\\CLSID", "{99999999-0000-0008-C000-000000000051}",
  "ProgID52", "objact dll",
  "ProgID52\\CLSID", "{99999999-0000-0008-C000-000000000052}",
  "ProgID53", "objact dll reg",
  "ProgID53\\CLSID", "{99999999-0000-0008-C000-000000000053}",
  "ProgID54", "objact dll reg",
  "ProgID54\\CLSID", "{99999999-0000-0008-C000-000000000054}",
  "ProgID55", "remote activation",
  "ProgID55\\CLSID", "{99999999-0000-0008-C000-000000000055}",
  "ProgID60", "CLSIDFromProgID test",
  "ProgID60\\CLSID", "{0000013a-0001-0008-C000-000000000046}",

  // Indicates end of list.
  "", ""
};

const RegistryKeyValue REG_EXE_KEY[] =
{
  "CLSID\\{20730701-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730711-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730712-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730713-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730714-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730715-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730716-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730717-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730718-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",

  "CLSID\\{20730712-0001-0008-C000-000000000046}\\LocalServer32", "bmtstsvr.exe",
  "CLSID\\{20730701-0001-0008-C000-000000000046}\\LocalServer32", "bmtstsvr.exe",

  "CLSID\\{0000013a-0001-0008-C000-000000000046}\\LocalServer32", "ballsrv.exe",
  "CLSID\\{00000138-0001-0008-C000-000000000046}\\InprocServer32", "iballs.dll",
  "CLSID\\{0000013b-0001-0008-C000-000000000046}\\LocalServer32", "cubesrv.exe",
  "CLSID\\{0000013c-0001-0008-C000-000000000046}\\LocalServer32", "loopsrv.exe",
  "CLSID\\{0000013d-0001-0008-C000-000000000046}\\LocalServer32", "rpctst.exe",
  "CLSID\\{00000140-0000-0008-C000-000000000046}\\LocalServer32", "qisrv.exe",
  "CLSID\\{00000140-0000-0008-C000-000000000046}\\InprocServer32", "qisrv.dll",
  "CLSID\\{00000142-0000-0008-C000-000000000046}\\InprocServer32", "ballsrv.dll",


  "CLSID\\{99999999-0000-0008-C000-000000000050}\\LocalServer32", "sdi.exe",
  "CLSID\\{99999999-0000-0008-C000-000000000051}\\LocalServer32", "mdi.exe",
  "CLSID\\{99999999-0000-0008-C000-000000000052}\\InprocServer32", "dlltest.dll",
  "CLSID\\{99999999-0000-0008-C000-000000000053}\\InprocServer32", "dlltest.dll",
  "CLSID\\{99999999-0000-0008-C000-000000000055}\\LocalServer32", "db.exe",

  // Indicates end of list.
  "", ""
};

DWORD g_fFullInfo = 0;		    //	write full info or not
DWORD g_dwPauseBetweenTests = 0;    //	time delay between running tests



//+-------------------------------------------------------------------
//
//  Member: 	CBenchMarkDriver::RunTest, public
//
//  Synopsis:	Sets up, runs, reports and cleans up test procedure
//		of specified class
//
//  Parameters: [output]	Output class for results
//		[pTest]		Test object
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------
	
SCODE CBenchMarkDriver::RunTest (CTestInput  &input,
				 CTestOutput &output, CTestBase *pTest)
{
	TCHAR szConfigString[80];
	SCODE sc;

	input.GetConfigString (TEXT("Tests"), pTest->Name(),
			       TEXT("OFF"), szConfigString, 80);

	if (lstrcmpi (szConfigString, TEXT("OFF")) != 0 &&
	    lstrcmpi (szConfigString, TEXT("FALSE")) != 0)
	{
		LogSection (pTest->Name());

		sc=pTest->Setup(&input);
		if (FAILED(sc))
		    return sc;

		//  pause between test invocations
		Sleep(g_dwPauseBetweenTests);

		sc = pTest->Run();
		pTest->Report(output);
		pTest->Cleanup();

		if (FAILED(sc))
		{
		    output.WriteString (TEXT("\nStatus:\tERROR, see log file\n"));
		}

		//  pause between test invocations
		Sleep(g_dwPauseBetweenTests);
    }

	return sc;
}


//+-------------------------------------------------------------------
//
//  Member: 	CBenchMarkDriver::WriteHeader, public
//
//  Synopsis:	Prints test form header into output file
//
//  History:   	5-August-93 	  t-martig	Created
//
//--------------------------------------------------------------------

void CBenchMarkDriver::WriteHeader (CTestInput &input, CTestOutput &output)
{
	_SYSTEMTIME stTimeDate;

	output.WriteString (TEXT("CairOLE Benchmarks\n"));
	output.WriteConfigEntry (input, TEXT("Driver"), TEXT("Tester"), TEXT(""));
	GetLocalTime (&stTimeDate);
	output.WriteDate (&stTimeDate);
	output.WriteString (TEXT("\t"));
	output.WriteTime (&stTimeDate);
	output.WriteString (TEXT("\n\n"));
}	


//+-------------------------------------------------------------------
//
//  Member: 	CBenchMarkDriver::Run, public
//
//  Synopsis:	Runs all tests specified in .ini file
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

#define RUN_TEST(CMyTestClass)		 \
{					 \
	CTestBase *pTest;		 \
	pTest = new CMyTestClass;	 \
	RunTest (input, output, pTest);  \
	delete pTest;			 \
	output.Flush();			 \
}


SCODE CBenchMarkDriver::Run (LPSTR lpCmdLine)
{
	TCHAR szBenchMarkIniFile[MAX_PATH];
	TCHAR szOutputFileName[MAX_PATH];
	TCHAR szLogFileName[MAX_PATH];
	TCHAR szTemp[MAX_PATH];


	//  Get file name of .ini file. if not specified in the command
	//  line, use the default BM.INI in the local directory

	GetCurrentDirectory (MAX_PATH, szTemp);

	lstrcpy(szBenchMarkIniFile, szTemp);
	lstrcat (szBenchMarkIniFile, TEXT("\\BM.INI"));

	//  create the names for the temporary files. uses pid.xxx. Its the
	//  current directory appended with the pid and a file extension.
	OLECHAR	szPid[9];
	DWORD pid = GetCurrentProcessId();
	CHAR	aszPid[9];
	_itoa(pid, aszPid, 16);
	mbstowcs(szPid, aszPid, strlen(aszPid)+1);

#ifdef UNICODE
	wcscpy(aszPerstName[0], szTemp);
#else
	mbstowcs(aszPerstName[0], szTemp, strlen(szTemp)+1);
#endif
	wcscat(aszPerstName[0], L"\\");
	wcscat(aszPerstName[0], szPid);

	wcscpy(aszPerstName[1],    aszPerstName[0]);
	wcscpy(aszPerstNameNew[0], aszPerstName[0]);
	wcscpy(aszPerstNameNew[1], aszPerstName[0]);

	wcscat(aszPerstName[0],    L".BM1");
	wcscat(aszPerstNameNew[0], L"NEW.BM1");
	wcscat(aszPerstName[1],    L".BM2");
	wcscat(aszPerstNameNew[1], L"NEW.BM2");



	// Define input, output and log file

	CTestInput input (szBenchMarkIniFile);
	CTestOutput output (input.GetConfigString (TEXT("Driver"), TEXT("Report"),
		TEXT("BM.RES"), szOutputFileName, MAX_PATH));
	CTestOutput log (input.GetConfigString (TEXT("Driver"), TEXT("Log"),
		TEXT("BM.LOG"), szLogFileName, MAX_PATH));

	LogTo (&log);


	//  Get the pause time between test invocations

	g_dwPauseBetweenTests = input.GetConfigInt (TEXT("Driver"),
                                                TEXT("PauseBetweenTests"),
                                                2000);

	// Get global info level flag

	g_fFullInfo = input.GetInfoLevelFlag();


	// Write the correct OleInitialize flag to win.ini for the various
	// OLE servers to use, based on the init flag in bm.ini.

	LPTSTR pszOleInit;
#ifdef THREADING_SUPPORT
	if (input.GetOleInitFlag() == COINIT_MULTITHREADED)
	{
//	    pszOleInit = TEXT("MultiThreaded");
	}
	else
#endif
	{
//	    pszOleInit = TEXT("ApartmentThreaded");
	}

//	WriteProfileString(TEXT("TestSrv"), TEXT("ThreadMode"), pszOleInit);
//	WriteProfileString(TEXT("OleSrv"), TEXT("ThreadMode"), pszOleInit);


	// Write header and configuration info

	WriteHeader (input, output);
	ReportBMConfig (input, output);


	// Run all the tests
	// To add tests, use macro RUN_TEST, the parameter is the name of
	// the test class. Be sure to include a sction called [<TestClass>] in
	// the BM.INI file, as well as a switch under the [Tests] section
	// (<TestClass> = ON, e.g.)

	Sleep(1000);

	RUN_TEST (COleMarshalTest2);
	RUN_TEST (CNoiseTest);
	RUN_TEST (CRawRpc);		// NOTE: must come before any OLE tests
	RUN_TEST (COleInitializeTest);
	RUN_TEST (COleRegistrationTest);
	RUN_TEST (COleActivationTest);
	RUN_TEST (CFileMonikerStorageBindTest);
	RUN_TEST (CFileMonikerObjBindTest);
	RUN_TEST (CROTTest);
	RUN_TEST (COlePropertyTest);
	RUN_TEST (COleMarshalTest);
	RUN_TEST (CRpcTest);
	RUN_TEST (CRpcTest2);
	RUN_TEST (CNestTest);
	RUN_TEST (CQueryInterfaceTest);
	RUN_TEST (CApiTest);
	RUN_TEST (CCGPSTest);
	RUN_TEST (COleAllocTest);
	RUN_TEST (CGuidCompareTest);
	RUN_TEST (CFileIOTest);
	RUN_TEST (CStorageTest);
	RUN_TEST (CNestedStorageTest);
	RUN_TEST (CStorageParserTest);

	//Upper layer tests
	RUN_TEST (CCreateTest);
	RUN_TEST (CCreateLinkTest);
//	RUN_TEST (CClipbrdTest);
	RUN_TEST (COleLoadTest);
	RUN_TEST (CIOLTest);
	RUN_TEST (COleCacheTest);


	return S_OK;
}


//+-------------------------------------------------------------------
//
//  Function: 	RegistrySetup
//
//  Synopsis:	If the registry entries for this program are not set,
//              write them
//
//  Note:       This function uses all Ascii characters and character
//              arithmatic because it has to run on NT and Chicago.
//
//  History:   	16 Dec 94	AlexMit		Created
//
//--------------------------------------------------------------------

BOOL RegistrySetup()
{
    char value[REGISTRY_ENTRY_LEN];
    LONG  value_size;
    LONG  result;
    char  directory[MAX_PATH];
    char *appname;
    BOOL  success = FALSE;

    // Write constant entries.
    for (int i = 0; REG_CONST_KEY[i].key[0] != '\0'; i++)
    {
        result = RegSetValueA(
                 HKEY_CLASSES_ROOT,
                 REG_CONST_KEY[i].key,
                 REG_SZ,
                 REG_CONST_KEY[i].value,
                 strlen(REG_CONST_KEY[i].value) );

        if (result != ERROR_SUCCESS)
	        goto cleanup;
    }

    // Compute the path to the application.
    result = GetFullPathNameA("benchmrk", sizeof(directory), directory, &appname);
    if (result == 0)
        goto cleanup;

    // Add the path to all the dll and exe entries.
    for (i = 0; REG_EXE_KEY[i].key[0] != '\0'; i++)
    {
        // Verify that the path will fit in the buffer and compute the path
        // to the next executable.
        if (strlen(REG_EXE_KEY[i].value) >=
            (ULONG)(MAX_PATH - (appname - directory)))
	        goto cleanup;

        strcpy(appname, REG_EXE_KEY[i].value);

        // Write the next entry.
        result = RegSetValueA(
                 HKEY_CLASSES_ROOT,
                 REG_EXE_KEY[i].key,
                 REG_SZ,
                 directory,
                 strlen(directory));

        if (result != ERROR_SUCCESS)
	        goto cleanup;
    }

    success = TRUE;

cleanup:
    return success;
}

//+-------------------------------------------------------------------
//
//  Function: 	WinMain
//
//  Synopsis:	Program entry point, starts benchmark driver
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    CBenchMarkDriver driver;

    if (!_stricmp(lpCmdLine, "/r") || !_stricmp(lpCmdLine, "-r"))
    {
        if (!RegistrySetup())
        {
            printf("Registry Updated\n");
            return 0;
        }
        else
        {
            printf("Registry Update Failed\n");
            return 1;
        }
    }

    driver.Run (lpCmdLine);
    return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\rawrpc.h ===
#ifndef __RAWRPC_H__
#define __RAWRPC_H__

#ifdef __cplusplus
extern "C" {
#endif

#define small char

#include "rpc.h"
#include "rpcndr.h"



#include "wtypes.h"

extern RPC_IF_HANDLE IRawRpc_ServerIfHandle;

extern RPC_IF_HANDLE IRawRpc_ClientIfHandle;

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef _ERROR_STATUS_T_DEFINED
typedef unsigned long error_status_t;
#define _ERROR_STATUS_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

SCODE Quit(
	handle_t hRpc);
void Void(
	handle_t hRpc);
SCODE VoidRC(
	handle_t hRpc);
SCODE VoidPtrIn(
	handle_t hRpc,
	ULONG cb,
	void *pv);
SCODE VoidPtrOut(
	handle_t hRpc,
	ULONG cb,
	ULONG *pcb,
	void *pv);
SCODE DwordIn(
	handle_t hRpc,
	DWORD dw);
SCODE DwordOut(
	handle_t hRpc,
	DWORD *pdw);
SCODE DwordInOut(
	handle_t hRpc,
	DWORD *pdw);
SCODE LiIn(
	handle_t hRpc,
	LARGE_INTEGER li);
SCODE LiOut(
	handle_t hRpc,
	LARGE_INTEGER *pli);
SCODE ULiIn(
	handle_t hRpc,
	ULARGE_INTEGER uli);
SCODE ULiOut(
	handle_t hRpc,
	ULARGE_INTEGER *puli);
SCODE StringIn(
	handle_t hRpc,
	LPWSTR pwsz);
SCODE StringOut(
	handle_t hRpc,
	LPWSTR *ppwsz);
SCODE StringInOut(
	handle_t hRpc,
	LPWSTR pwsz);
SCODE GuidIn(
	handle_t hRpc,
	GUID guid);
SCODE GuidOut(
	handle_t hRpc,
	GUID *pguid);

#if !defined(IMPORT_USED_MULTIPLE) && !defined(IMPORT_USED_SINGLE)

#endif /*!defined(IMPORT_USED_MULTIPLE) && !defined(IMPORT_USED_SINGLE)*/

typedef struct _IRawRpc_SERVER_EPV
  {
  SCODE (__RPC_FAR * Quit)(
	handle_t hRpc);
  void (__RPC_FAR * Void)(
	handle_t hRpc);
  SCODE (__RPC_FAR * VoidRC)(
	handle_t hRpc);
  SCODE (__RPC_FAR * VoidPtrIn)(
	handle_t hRpc,
	ULONG cb,
	void *pv);
  SCODE (__RPC_FAR * VoidPtrOut)(
	handle_t hRpc,
	ULONG cb,
	ULONG *pcb,
	void *pv);
  SCODE (__RPC_FAR * DwordIn)(
	handle_t hRpc,
	DWORD dw);
  SCODE (__RPC_FAR * DwordOut)(
	handle_t hRpc,
	DWORD *pdw);
  SCODE (__RPC_FAR * DwordInOut)(
	handle_t hRpc,
	DWORD *pdw);
  SCODE (__RPC_FAR * LiIn)(
	handle_t hRpc,
	LARGE_INTEGER li);
  SCODE (__RPC_FAR * LiOut)(
	handle_t hRpc,
	LARGE_INTEGER *pli);
  SCODE (__RPC_FAR * ULiIn)(
	handle_t hRpc,
	ULARGE_INTEGER uli);
  SCODE (__RPC_FAR * ULiOut)(
	handle_t hRpc,
	ULARGE_INTEGER *puli);
  SCODE (__RPC_FAR * StringIn)(
	handle_t hRpc,
	LPWSTR pwsz);
  SCODE (__RPC_FAR * StringOut)(
	handle_t hRpc,
	LPWSTR *ppwsz);
  SCODE (__RPC_FAR * StringInOut)(
	handle_t hRpc,
	LPWSTR pwsz);
  SCODE (__RPC_FAR * GuidIn)(
	handle_t hRpc,
	GUID guid);
  SCODE (__RPC_FAR * GuidOut)(
	handle_t hRpc,
	GUID *pguid);
  }
IRawRpc_SERVER_EPV;
void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t);
void __RPC_API MIDL_user_free(void __RPC_FAR *);
#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\common\stopwtch.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	stopwtch.cxx
//
//  Contents:	StopWatch timer
//
//  Classes:	CStopWatch
//
//  Functions:	
//
//  History:    30-June-93 t-martig    Created
//
//--------------------------------------------------------------------------

extern "C" 
{
	#include <nt.h>
	#include <ntrtl.h>
	#include <nturtl.h>
};
#include <windows.h>
#include <stopwtch.hxx>


//+-------------------------------------------------------------------
//
//  Member: 	CStopWatch::Resolution, public
//
//  Synopsis:	Inquires performance timer resolution
//
//	Returns:	Performance counter ticks / second
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------
CStopWatch::CStopWatch ()
{
	QueryPerformanceFrequency (&liFreq);
}

//+-------------------------------------------------------------------
//
//  Member: 	CStopWatch::Reset, public
//
//  Synopsis:	Starts measurement cycle
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

void CStopWatch::Reset ()
{
	QueryPerformanceCounter (&liStart); // BUGBUG - test for error !
}


//+-------------------------------------------------------------------
//
//  Member: 	CStopWatch::Read, public
//
//  Synopsis:	Reads stop watch timer
//
//  Returns:	Time since call of CStopWatch::Reset (in microseconds)
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------
	
ULONG CStopWatch::Read ()
{
	LARGE_INTEGER liNow, liDelta, liRemainder;

	QueryPerformanceCounter (&liNow);	// BUGBUG - test for error
   
	liDelta = RtlLargeIntegerSubtract (liNow, liStart);
	liDelta = RtlExtendedIntegerMultiply (liDelta, 1000000);
	liDelta = RtlLargeIntegerDivide (liDelta, liFreq, &liRemainder);

	return liDelta.LowPart;
}


//+-------------------------------------------------------------------
//
//  Member: 	CStopWatch::Resolution, public
//
//  Synopsis:	Inquires performance timer resolution
//
//	Returns:	Performance counter ticks / second
//
//  History:   	30-June-93   t-martig	Created
//
//--------------------------------------------------------------------

ULONG CStopWatch::Resolution ()
{
	return liFreq.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\driver\bmguid.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	bmguid.cxx
//
//  Contents:	OLE test guids
//
//  Classes:	
//
//  Functions:	
//
//  History:    12-August-93 t-martig    Created
//
//--------------------------------------------------------------------------


#define INITGUID
#include "windows.h"

#ifdef _NTIDW340
// Handle port problems easily
// #define WIN32

#ifdef __cplusplus
// PORT: Handle the fact that jmp_buf doesn't make any sense in cpp.
#define jmp_buf int
#endif // __cplusplus
#endif // _NTIDW340

// PORT: HTASK no longer seems to be defined in Win32
#define HTASK DWORD
#define HINSTANCE_ERROR 32
#define __loadds
#define __segname
#define BASED_CODE
#define HUGE
#define _ffree free
#define __based(x)
#include <port1632.h>

DEFINE_OLEGUID(CLSID_COleTestClass,  0x20730701, 1, 8);	    // CT Test GUID
DEFINE_OLEGUID(CLSID_COleTestClass2, 0x20730712, 1, 8);	    // CT Test GUID                          
DEFINE_OLEGUID(CLSID_TestProp,	     0x20730722, 1, 8);	    // CT Test GUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\rawrpc\rawrpc_y.c ===
#include <string.h>
#include <limits.h>
#include <rpc.h>

#include "rawrpc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\le\create\ocperf.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:  	ocperf.cpp
//
//  Contents: 	OleCreate performance test
//
//  Classes: 	CBareServer
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//		01-Jan-95 alexgo    author
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include <initguid.h>

DEFINE_GUID(CLSID_BareServer, 0xce3d5220, 0x25fa, 0x11ce, 0x90, 0xeb, 0x00,
0x00, 0x4c, 0x75, 0x2a, 0x63);

class CBareServer : public IOleObject, public IDataObject,
	public IPersistStorage
{

public:

    // IUnknown methods

    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IDataObject methods

    STDMETHOD(GetData) ( LPFORMATETC pformatetcIn,
	    LPSTGMEDIUM pmedium );
    STDMETHOD(GetDataHere) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium );
    STDMETHOD(QueryGetData) ( LPFORMATETC pformatetc );
    STDMETHOD(GetCanonicalFormatEtc) ( LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut);
    STDMETHOD(SetData) ( LPFORMATETC pformatetc,
            LPSTGMEDIUM pmedium, BOOL fRelease);
    STDMETHOD(EnumFormatEtc) ( DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc);
    STDMETHOD(DAdvise) ( FORMATETC FAR* pFormatetc, DWORD advf,
            IAdviseSink FAR* pAdvSink,
            DWORD FAR* pdwConnection);
    STDMETHOD(DUnadvise) ( DWORD dwConnection);
    STDMETHOD(EnumDAdvise) ( LPENUMSTATDATA FAR* ppenumAdvise);

    // IOleObject methods

    STDMETHOD(SetClientSite) ( LPOLECLIENTSITE pClientSite);
    STDMETHOD(GetClientSite) ( LPOLECLIENTSITE FAR* ppClientSite);
    STDMETHOD(SetHostNames) ( LPCOLESTR szContainerApp,
		LPCOLESTR szContainerObj);
    STDMETHOD(Close) ( DWORD reserved);
    STDMETHOD(SetMoniker) ( DWORD dwWhichMoniker, LPMONIKER pmk);
    STDMETHOD(GetMoniker) ( DWORD dwAssign, DWORD dwWhichMoniker,
		LPMONIKER FAR* ppmk);
    STDMETHOD(InitFromData) ( LPDATAOBJECT pDataObject,
		BOOL fCreation,
		DWORD dwReserved);
    STDMETHOD(GetClipboardData) ( DWORD dwReserved,
		LPDATAOBJECT FAR* ppDataObject);
    STDMETHOD(DoVerb) ( LONG iVerb,
		LPMSG lpmsg,
		LPOLECLIENTSITE pActiveSite,
		LONG lindex,
		HWND hwndParent,
		const RECT FAR* lprcPosRect);
    STDMETHOD(EnumVerbs) ( IEnumOLEVERB FAR* FAR* ppenumOleVerb);
    STDMETHOD(Update) (void);
    STDMETHOD(IsUpToDate) (void);
    STDMETHOD(GetUserClassID) ( CLSID FAR* pClsid);
    STDMETHOD(GetUserType) ( DWORD dwFormOfType,
		LPOLESTR FAR* pszUserType);
    STDMETHOD(SetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHOD(GetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHOD(Advise)(IAdviseSink FAR* pAdvSink,
		DWORD FAR* pdwConnection);
    STDMETHOD(Unadvise)( DWORD dwConnection);
    STDMETHOD(EnumAdvise) ( LPENUMSTATDATA FAR* ppenumAdvise);
    STDMETHOD(GetMiscStatus) ( DWORD dwAspect,
		DWORD FAR* pdwStatus);
    STDMETHOD(SetColorScheme) ( LPLOGPALETTE lpLogpal);

    // IPeristStorage methods

    STDMETHOD(GetClassID) ( LPCLSID pClassID);
    STDMETHOD(IsDirty) (void);
    STDMETHOD(InitNew) ( LPSTORAGE pstg);
    STDMETHOD(Load) ( LPSTORAGE pstg);
    STDMETHOD(Save) ( LPSTORAGE pstgSave, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted) ( LPSTORAGE pstgNew);
    STDMETHOD(HandsOffStorage) ( void);


    CBareServer();

private:

    ~CBareServer();

    ULONG		_cRefs;
    IStorage *		_pstg;
    IOleClientSite *	_pclientsite;
    IOleAdviseHolder *	_poaholder;

};

CBareServer::CBareServer()
{
    _cRefs = 1;
    _pstg  = NULL;
    _pclientsite = NULL;
    _poaholder = NULL;
}

CBareServer::~CBareServer()
{
    if( _poaholder )
    {
	_poaholder->Release();
	_poaholder = NULL;
    }

    if( _pclientsite )
    {
	_pclientsite->Release();
	_pclientsite = NULL;
    }
	
    if( _pstg )
    {
	_pstg->Release();
	_pstg = NULL;
    }
}

// IUnknown methods

STDMETHODIMP CBareServer::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hresult = NOERROR;

    if( IsEqualIID(riid, IID_IUnknown) )
    {
	*ppvObj = (void *)(IOleObject *)this;
    }
    else if( IsEqualIID(riid, IID_IOleObject) )
    {
	*ppvObj = (void *)(IOleObject *)this;
    }
    else if( IsEqualIID(riid, IID_IDataObject) )
    {
	*ppvObj = (void *)(IDataObject *)this;
    }
    else if( IsEqualIID(riid, IID_IPersistStorage) )
    {
	*ppvObj = (void *)(IPersistStorage *)this;
    }
    else
    {
	hresult = E_NOINTERFACE;
	*ppvObj = NULL;
    }

    if( hresult == NOERROR )
    {
	AddRef();
    }

    return hresult;
}

STDMETHODIMP_(ULONG) CBareServer::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}

STDMETHODIMP_(ULONG) CBareServer::Release(void)
{
    _cRefs--;

    if( _cRefs == 0 )
    {
	delete this;
	return 0;
    }

    return _cRefs;
}	

// IDataObject methods

STDMETHODIMP CBareServer::GetData ( LPFORMATETC pformatetcIn,
	LPSTGMEDIUM pmedium )
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::GetDataHere ( LPFORMATETC pformatetc,
	LPSTGMEDIUM pmedium )
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::QueryGetData ( LPFORMATETC pformatetc )
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::GetCanonicalFormatEtc ( LPFORMATETC pformatetc,
	LPFORMATETC pformatetcOut)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::SetData ( LPFORMATETC pformatetc,
	LPSTGMEDIUM pmedium, BOOL fRelease)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::EnumFormatEtc ( DWORD dwDirection,
	LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    *ppenumFormatEtc = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::DAdvise ( FORMATETC FAR* pFormatetc, DWORD advf,
	IAdviseSink FAR* pAdvSink,
	DWORD FAR* pdwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::DUnadvise ( DWORD dwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::EnumDAdvise ( LPENUMSTATDATA FAR* ppenumAdvise)
{
    return E_NOTIMPL;
}

// IOleObject methods

STDMETHODIMP CBareServer::SetClientSite ( LPOLECLIENTSITE pClientSite)
{
    _pclientsite = pClientSite;
    _pclientsite->AddRef();

    return NOERROR;
}

STDMETHODIMP CBareServer::GetClientSite ( LPOLECLIENTSITE FAR* ppClientSite)
{
    return E_NOTIMPL;
}


STDMETHODIMP CBareServer::SetHostNames ( LPCOLESTR szContainerApp,
	    LPCOLESTR szContainerObj)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::Close ( DWORD reserved)
{
    printf("close called\n");

    if( _poaholder )
    {
	_poaholder->SendOnClose();
    }

    CoDisconnectObject((IOleObject *)this, 0);

    return NOERROR;
}

STDMETHODIMP CBareServer::SetMoniker ( DWORD dwWhichMoniker, LPMONIKER pmk)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::GetMoniker ( DWORD dwAssign, DWORD dwWhichMoniker,
	    LPMONIKER FAR* ppmk)
{
    *ppmk = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::InitFromData ( LPDATAOBJECT pDataObject,
	    BOOL fCreation,
	    DWORD dwReserved)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::GetClipboardData ( DWORD dwReserved,
	    LPDATAOBJECT FAR* ppDataObject)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBareServer::DoVerb ( LONG iVerb,
	    LPMSG lpmsg,
	    LPOLECLIENTSITE pActiveSite,
	    LONG lindex,
	    HWND hwndParent,
	    const RECT FAR* lprcPosRect)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::EnumVerbs ( IEnumOLEVERB FAR* FAR* ppenumOleVerb)
{
    return OLE_S_USEREG;
}

STDMETHODIMP CBareServer::Update (void)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::IsUpToDate (void)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::GetUserClassID ( CLSID FAR* pClsid)
{
    *pClsid = CLSID_BareServer;

    return NOERROR;
}

STDMETHODIMP CBareServer::GetUserType ( DWORD dwFormOfType,
	    LPOLESTR FAR* pszUserType)
{
    return OLE_S_USEREG;
}

STDMETHODIMP CBareServer::SetExtent ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::GetExtent ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::Advise (IAdviseSink FAR* pAdvSink,
	    DWORD FAR* pdwConnection)
{

    printf("Advise called\n");

    HRESULT hresult;

    if( !_poaholder )
    {	
	hresult = CreateOleAdviseHolder(&_poaholder);
    }

    if( _poaholder )
    {
	hresult = _poaholder->Advise(pAdvSink, pdwConnection);
    }

    return hresult;
}

STDMETHODIMP CBareServer::Unadvise ( DWORD dwConnection)
{
    if( _poaholder )
    {
	return _poaholder->Unadvise(dwConnection);
    }

    return E_FAIL;
}

STDMETHODIMP CBareServer::EnumAdvise ( LPENUMSTATDATA FAR* ppenumAdvise)
{
    if( _poaholder )
    {
	return _poaholder->EnumAdvise(ppenumAdvise);
    }

    return E_FAIL;
}

STDMETHODIMP CBareServer::GetMiscStatus ( DWORD dwAspect,
	    DWORD FAR* pdwStatus)
{
    return OLE_S_USEREG;
}

STDMETHODIMP CBareServer::SetColorScheme ( LPLOGPALETTE lpLogpal)
{
    return NOERROR;
}


// IPeristStorage methods

STDMETHODIMP CBareServer::GetClassID ( LPCLSID pClassID)
{
    *pClassID = CLSID_BareServer;

    return NOERROR;
}

STDMETHODIMP CBareServer::IsDirty (void)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::InitNew ( LPSTORAGE pstg)
{
    printf("InitNew called\n");

    _pstg = pstg;
    _pstg->AddRef();

    return NOERROR;
}

STDMETHODIMP CBareServer::Load ( LPSTORAGE pstg)
{
    _pstg = pstg;
    _pstg->AddRef();

    return NOERROR;
}

STDMETHODIMP CBareServer::Save ( LPSTORAGE pstgSave, BOOL fSameAsLoad)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::SaveCompleted ( LPSTORAGE pstgNew)
{
    return NOERROR;
}

STDMETHODIMP CBareServer::HandsOffStorage ( void)
{
    _pstg->Release();
    _pstg = NULL;

    return NOERROR;
}


// class factory

class CBareFactory : public IClassFactory
{

public:
    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);
    STDMETHOD(CreateInstance) (LPUNKNOWN pUnkOuter, REFIID iid,
				    LPVOID FAR* ppv);
    STDMETHOD(LockServer) ( BOOL fLock );

    CBareFactory();

private:
    ULONG		_cRefs;
};

CBareFactory::CBareFactory()
{
    _cRefs = 1;
}

STDMETHODIMP CBareFactory::QueryInterface (REFIID iid, LPVOID FAR* ppvObj)
{
    if( IsEqualIID(iid, IID_IClassFactory) ||
	IsEqualIID(iid, IID_IUnknown) )
    {
	*ppvObj = this;
	AddRef();
	return NOERROR;
    }
    else
    {
	*ppvObj = NULL;
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CBareFactory::AddRef (void)
{
    _cRefs++;
    return _cRefs;
}

STDMETHODIMP_(ULONG) CBareFactory::Release (void)
{
    _cRefs--;

    if( _cRefs == 0 )
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

STDMETHODIMP CBareFactory::CreateInstance (LPUNKNOWN pUnkOuter, REFIID iid,
				LPVOID FAR* ppv)
{
    *ppv = (IOleObject *)new CBareServer();

    return NOERROR;
}

STDMETHODIMP CBareFactory::LockServer ( BOOL fLock )
{
    return NOERROR;
}

// Client Site

class CBareClientSite : public IOleClientSite
{
public:

    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // *** IOleClientSite methods ***
    STDMETHOD(SaveObject)();
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker,
                            LPMONIKER FAR* ppmk);
    STDMETHOD(GetContainer)(LPOLECONTAINER FAR* ppContainer);
    STDMETHOD(ShowObject)();
    STDMETHOD(OnShowWindow)(BOOL fShow);
    STDMETHOD(RequestNewObjectLayout)();

    CBareClientSite();

private:

    ULONG	_cRefs;
};

CBareClientSite::CBareClientSite()
{
    _cRefs = 1;
}

STDMETHODIMP CBareClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if( IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IOleClientSite) )
    {
	*ppvObj = this;
	AddRef();
	return NOERROR;
    }
    else
    {
	*ppvObj = NULL;
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CBareClientSite::AddRef()
{
    _cRefs++;
    return _cRefs;
}

STDMETHODIMP_(ULONG) CBareClientSite::Release()
{
    _cRefs--;

    if( _cRefs == 0 )
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

// *** IOleClientSite methods ***
STDMETHODIMP CBareClientSite::SaveObject()
{
    return NOERROR;
}

STDMETHODIMP CBareClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
			LPMONIKER FAR* ppmk)
{
    *ppmk = NULL;
    return E_FAIL;
}

STDMETHODIMP CBareClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    *ppContainer = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP CBareClientSite::ShowObject()
{
    return NOERROR;
}

STDMETHODIMP CBareClientSite::OnShowWindow(BOOL fShow)
{
    return NOERROR;
}

STDMETHODIMP CBareClientSite::RequestNewObjectLayout()
{
    return NOERROR;
}


void RunServerSide(void)
{
    DWORD dwcf = 0;
    HWND hwnd;
    MSG msg;

    IClassFactory *pcf = new CBareFactory();

    WNDCLASS	wc;

    // Register Clipboard window class
    //
    wc.style = 0;
    wc.lpfnWndProc = DefWindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 4;
    wc.hInstance = NULL;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = "BareServerWindow";

    // don't bother checking for errors
    RegisterClass(&wc);
	
    hwnd = CreateWindow("BareServerWindow","",WS_POPUP,CW_USEDEFAULT,
			CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
			NULL,NULL,NULL,NULL);

    CoRegisterClassObject( CLSID_BareServer, pcf, CLSCTX_LOCAL_SERVER,
	REGCLS_MULTIPLEUSE, &dwcf );

    while (GetMessage(&msg, NULL, NULL, NULL))
    {
        TranslateMessage(&msg);    /* Translates virtual key codes  */
        DispatchMessage(&msg);     /* Dispatches message to window  */
    }

    CoRevokeClassObject(dwcf);
}

void RunContainerSide()
{
    DWORD dwStart, dwFinish, i;
    HRESULT hresult;
    IStorage *pstg;
    IOleObject *poo;
    IOleClientSite *pcs;

    hresult = StgCreateDocfile(NULL, STGM_CREATE | STGM_READWRITE |
		STGM_SHARE_EXCLUSIVE,
		0, &pstg);

    if( hresult != NOERROR )
    {
	printf("CreateDocFile failed! (%lx)\n", hresult);
	exit(hresult);
    }

    pcs = (IOleClientSite *)new CBareClientSite();

    // prime the server

    hresult = OleCreate( CLSID_BareServer, IID_IOleObject, OLERENDER_NONE,
		NULL, pcs, pstg, (void **)&poo);

    if( hresult != NOERROR )
    {
	printf("OleCreate failed! (%lx)\n", hresult);
	exit(hresult);
    }

    hresult = OleRun(poo);

    if( hresult != NOERROR )
    {
	printf("OleRun failed! (%lx)\n", hresult);
	exit(hresult);
    }

    poo->Close(0);
    poo->Release();
    poo = NULL;

    pcs->Release();
    pcs = NULL;

    for( i = 0; i < 100; i++ )
    {

	pcs = (IOleClientSite *)new CBareClientSite();

	dwStart = GetTickCount();

	hresult = OleCreate(CLSID_BareServer, IID_IOleObject, OLERENDER_NONE,
		NULL, pcs, pstg, (void **)&poo);

	if( hresult == NOERROR )
	{
	    hresult = OleRun(poo);
	}

	dwFinish = GetTickCount();

	if( hresult == NOERROR )
	{
	    poo->Close(0);
	    poo->Release();
	    poo = NULL;

	    printf("%ld\n", dwFinish - dwStart);
     	}
	else
	{
	    printf("%ld failed! (%lx)\n", i, hresult);
	}

	pcs->Release();
	pcs = NULL;
    }

    pstg->Release();
}


int main( int argc, char **argv )
{
    OleInitialize(NULL);

    if( argc == 2 )
    {
	// assume -Embedding
	RunServerSide();
    }
    else
    {
	RunContainerSide();
    }

    OleUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\procswap\procswap.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	procswap.cxx
//
//  Contents:	Program for measuring task switching performance
//		between two windows programs. The program creates
//		CTaskSwitch objects...
//
//		Each Object can wait on one of three things...
//		    1. GetMessage
//		    2. MsgWaitForMultipleObjects
//		    3. WaitForSingleObject (event)
//
//		and when awoken, will signal another Object in one
//		of three ways...
//		    1. PostMessage
//		    2. SendMessage
//		    3. SetEvent
//
//		These cases can be combined in any manner to obtain
//		a maxtrix of possible scenarios.
//
//		The CTaskSwitch objects can be in the same process on
//		different threads, or in different processes.
//
//  Classes:	CEvent	      -	event handling class
//		CTaskSwitch   -	main task switch class
//
//
//  Functions:	WinMain       - entry point of process
//		ThreadEntry   - entry point of spawned threads
//		ThreadWndProc -	processes windows messages
//
//
//  History:	08-Feb-94   Rickhi	Created
//
//--------------------------------------------------------------------------

#include <benchmrk.hxx>
#include <tchar.h>


//  execution parameter structure

typedef struct tagSExecParms
{
    int 	oloop;		//  outer loop count
    int 	iloop;		//  inner loop count
    HWND	hWndOther;	//  HWND of other process
    HANDLE	hEventOther;	//  Event Handle of other process
    WNDPROC	pfnWndProc;	//  ptr to WndProc function
    TCHAR	szFile[20];	//  output file name
    TCHAR	szWaitEvent[20];   // event name to wait on
    TCHAR	szSignalEvent[20]; // event name to signal
} SExecParms;


typedef enum tagWAITTYPES
{
    WAIT_EVENT		    = 1,
    WAIT_MSGWAITFORMULTIPLE = 2,
    WAIT_GETMESSAGE	    = 3,
    WAIT_SYNCHRONOUS	    = 4
} WAITTYPES;

typedef enum tagSIGNALTYPES
{
    SIGNAL_EVENT	    = 1,
    SIGNAL_POSTMESSAGE	    = 2,
    SIGNAL_SENDMESSAGE	    = 3,
    SIGNAL_SYNCHRONOUS	    = 4
} SIGNALTYPES;

//  input names corresponding to the wait types
LPSTR aszWait[] = {"", "event", "msgwait", "getmsg", "sync", NULL};

//  input names corresponding to the signal types
LPSTR aszSignal[] = {"", "event", "postmsg", "sendmsg", "sync", NULL};



//  Name of window class for dispatching messages.

#define MY_WINDOW_CLASS TEXT("ProcSwapWindowClass")

#define MAX_OLOOP   100


//  globals

DWORD		g_fFullInfo = 0;	    //	write full info or not
HINSTANCE	g_hInst     = NULL;	    //	misc windows junk.
ATOM		g_MyClass   = 0;
UINT		g_MyMessage = WM_USER;


//  function prototype
LRESULT	ThreadWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam);
DWORD	ThreadEntry(void *param);


//--------------------------------------------------------------------------
//
//  Class:	CEvent
//
//  Purpose:	class for blocking & starting threads.
//
//--------------------------------------------------------------------------

class	CEvent
{
public:
	    CEvent(LPTSTR szName, HRESULT &hr) { Init(szName, hr); }
	    CEvent(void) {m_hdl = NULL; }

	    ~CEvent()	 { CloseHandle(m_hdl); }

    void    Signal(void) { SetEvent(m_hdl); }
    void    Reset(void)  { ; }		      // ResetEvent(m_hdl); }
    void    BlockS(void) { WaitForSingleObject(m_hdl, 60000); }
    void    BlockM(void) { WaitForMultipleObjects(1, &m_hdl, FALSE, 60000); }
    HANDLE *GetHdl(void) { return &m_hdl; };

    void    Init(LPTSTR szName, HRESULT &hr);

private:

    HANDLE  m_hdl;
};


void CEvent::Init(LPTSTR szName, HRESULT &hr)
{
    hr = S_OK;

    //	first try opening the event
    m_hdl = OpenEvent(EVENT_ALL_ACCESS,
		      FALSE,
		      szName);

    if (m_hdl == NULL)
    {
	//  doesnt exist yet so create it.
	m_hdl = CreateEvent(NULL,	    // security
			    FALSE,	    // auto reset
			    FALSE,	    // initially not signalled
			    szName);

	if (m_hdl == NULL)
	{
	    _tprintf (TEXT("Error Creating CEvent (%s)\n"), szName);
	    hr = GetLastError();
	}
	else
	{
	    _tprintf (TEXT("Created CEvent (%s)\n"), szName);
	}
    }
    else
    {
        _tprintf (TEXT("Opened CEvent (%s)\n"), szName);
    }
}



//--------------------------------------------------------------------------
//
//  Class:	CTaskSwitch
//
//  Purpose:	class for timing task switches.
//
//--------------------------------------------------------------------------

class	CTaskSwitch
{
public:
		CTaskSwitch(LPSTR lpszCmdLine, HRESULT &hr);
		~CTaskSwitch(void);

    int		MainProcessLoop(void);
    LRESULT	ThreadWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam);
    HRESULT	SpawnOtherSide(void);

private:

    //	initialization / cleanup methods

    HRESULT	ParseCmdLine(LPSTR lpszCmdLine, SExecParms &execp);
    HRESULT	WindowInitialize(WNDPROC pfnWndProc, HWND &hWnd);
    void	WindowUninitialize(HWND hWnd);
    void	CreateOtherParms(void);
    void	WriteExecParms(void);
    void	WriteResults(void);
    void	Help(void);
    DWORD	GetWaitType(LPSTR pszCmd);
    DWORD	GetSignalType(LPSTR pszCmd);
    DWORD	CreateProc(void);

    //	processing methods

    HRESULT	SendOrWaitFirstSignal(void);
    void	ProcessMsgWaitForMultiple(DWORD dwRet);
    void	ProcessIncommingEvent(void);
    void	UpdateLoopCounters(void);
    void	SignalOtherSide(void);

    //	data

    BOOL		g_fDone;	    //	when to exit the loop
    BOOL		g_fKicker;	    //	we kick the other guy
    BOOL		g_fThreadSwitch;    //	thread or process switching?
    BOOL		g_fWaitMultiple;    //	wait single or multiple

    ULONG		g_oloop;	    //	outer loop counter
    ULONG		g_iloop;	    //	inner loop counter

    DWORD		g_WaitType;	    //	what to wait on
    DWORD		g_SignalType;	    //	what to signal

    //	used only for parameter parseing
    DWORD		g_WaitType1;	    //	what to wait on
    DWORD		g_SignalType1;	    //	what to signal
    DWORD		g_WaitType2;	    //	what to wait on
    DWORD		g_SignalType2;	    //	what to signal


    HWND		g_hWndOther;	    //	hWnd of other side
    HWND		g_hWndMe;	    //	my hWnd

    CEvent		g_WaitEvent;	    //	event to wait on
    CEvent		g_SignalEvent;	    //	event to signal

    ULONG		g_time[MAX_OLOOP];  //	place to store the timings.
    CStopWatch		g_timer;	    //	global timer proc 1

    SExecParms		g_execp;	    //	execution parameters
    CTestOutput       * g_output;	    //	output log

    HRESULT		g_hr;		    //	result code

    CHAR		g_szOtherParms[MAX_PATH]; // parm string for other guy
};




//  task switch objects - must be global for ThreadWndProc

CTaskSwitch	*g_pTaskSwitch1 = NULL;
CTaskSwitch	*g_pTaskSwitch2 = NULL;


//--------------------------------------------------------------------------
//
//  WinMain - main entry point of program.  May just call ThreadEntry, or
//	      may spawn another thread in the case of thread switching.
//
//
//--------------------------------------------------------------------------

int WinMain(HINSTANCE hinst, HINSTANCE hPrev, LPSTR lpszCmdLine, int CmdShow)
{
    HRESULT hr;

    //	create the first task switch object for this process
    g_pTaskSwitch1 = new CTaskSwitch(lpszCmdLine, hr);

    if (hr == S_OK)
    {
	//  spawn a new thread or a new process to do task switching with.
	hr = g_pTaskSwitch1->SpawnOtherSide();

	if (hr == S_OK)
	{
	    //	enter the main processing loop
	    g_pTaskSwitch1->MainProcessLoop();
	}
    }

    //	print the results
    delete g_pTaskSwitch1;
    return 1;
}



//--------------------------------------------------------------------------
//
//  ThreadEntry - main entry point for a thread spawned by CreateThread
//	    in the case of task switching between threads.
//
//	    Creates an instance of the CTaskSwitch class and invokes it
//	    main function.
//
//--------------------------------------------------------------------------

DWORD ThreadEntry(void *param)
{
    LPSTR lpszCmdLine = (LPSTR) param;

    HRESULT hr;

    //	create the second task switch object for this process
    g_pTaskSwitch2 = new CTaskSwitch(lpszCmdLine, hr);

    if (hr == S_OK)
    {
	//  enter the main processing loop
	g_pTaskSwitch2->MainProcessLoop();
    }

    //	print the results
    delete g_pTaskSwitch2;
    return hr;
}




//--------------------------------------------------------------------------
//
//  Dipatch to the correct CTaskSwitch object if the message is our
//  special message.
//
//--------------------------------------------------------------------------

LRESULT ThreadWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    if (msg == g_MyMessage)
    {
	//  its my special message, go handle it.
	//  here i have to select which object to dispatch to for the
	//  multithreaded case. i base that decision on lparam.

	if (lparam == 0)
	{
	    //	use the first task switch object
	    return g_pTaskSwitch1->ThreadWndProc(hWnd, msg, wparam, lparam);
	}
	else
	{
	    //	use the second task switch object
	    return g_pTaskSwitch2->ThreadWndProc(hWnd, msg, wparam, lparam);
	}
    }
    else
    {
	// let the default window procedure have the message.
	return DefWindowProc(hWnd, msg, wparam, lparam);
    }
}




//--------------------------------------------------------------------------
//
//  Constructor : parse the command line, create the events, create the
//		  window, and open a log file.
//
//--------------------------------------------------------------------------

CTaskSwitch::CTaskSwitch(LPSTR lpszCmdLine, HRESULT &hr) :
    g_fDone(FALSE),
    g_fKicker(FALSE),
    g_fThreadSwitch(FALSE),
    g_fWaitMultiple(FALSE),
    g_oloop(10),
    g_iloop(100),
    g_WaitType(WAIT_EVENT),
    g_SignalType(SIGNAL_EVENT),
    g_hWndMe(NULL),
    g_hWndOther(NULL),
    g_output(NULL),
    g_hr(S_OK)
{
    //	parse command line and write the parms to log file.
    g_hr = ParseCmdLine(lpszCmdLine, g_execp);

    if (g_hr == S_OK)
    {
	//  Create a log file & write execution parameters
	g_output = new CTestOutput(g_execp.szFile);
	WriteExecParms();

	//  create the window for this thread
	g_hr = WindowInitialize(g_execp.pfnWndProc, g_hWndMe);
	if (g_hr == S_OK)
	{
	    //	Create the Wait event.
	    g_WaitEvent.Init(g_execp.szWaitEvent, g_hr);
	    if (g_hr == S_OK)
	    {
		//  Create the Signal event.
		g_SignalEvent.Init(g_execp.szSignalEvent, g_hr);

		if (g_hr == S_OK)
		{
		    //	create paramters to send to other side.
		    CreateOtherParms();
		}
	    }
	}
    }

    //	return the results
    hr = g_hr;
}


//--------------------------------------------------------------------------
//
//  Desructor
//
//--------------------------------------------------------------------------

CTaskSwitch::~CTaskSwitch(void)
{
    //	write the results
    WriteResults();

    //	cleanup window registration
    WindowUninitialize(g_hWndMe);

    //	close the log file
    delete g_output;
}


//--------------------------------------------------------------------------
//
//  Spawns either another process or another thread to perform the task
//  switching with.
//
//--------------------------------------------------------------------------

HRESULT CTaskSwitch::SpawnOtherSide(void)
{
    if (g_fKicker)
    {
	//  i'm already the second entry, dont spawn anything.
	//  sleep for a bit to make sure both sides are ready
	//  when i kick things off.

	Sleep(1000);
	return S_OK;
    }


    if (g_fThreadSwitch)
    {
	//  spawn a thread

	HANDLE	hdl;
	DWORD  dwId;
	hdl = CreateThread(NULL,	    //	default security
			   0,		    //	default stack size
			   ThreadEntry,     //	entry point
			   g_szOtherParms,  //	command line parms
			   0,		    //	flags
			   &dwId);	    //	threadid

	if (hdl)
	{
	    //	dont need the handle
	    CloseHandle(hdl);
	}
	else
	{
	    //	what went wrong?
	    return GetLastError();
	}
    }
    else
    {
	//  spawn a process
	DWORD dwRet = CreateProc();
	if (dwRet != S_OK)
	{
	    return dwRet;
	}
    }

    return S_OK;
}



//--------------------------------------------------------------------------
//
//  MainProcessLoop - does the main wait & process the event
//
//--------------------------------------------------------------------------

int CTaskSwitch::MainProcessLoop(void)
{
    MSG     msg;
    DWORD   dwRet;


    //	Send, or wait on, the first signal.
    SendOrWaitFirstSignal();


    //	Reset the timer and enter the main loop.
    g_timer.Reset();


    //	wait loop - based on the type of event we should receive, we
    //	wait here until such an event occurs. Then we send a signal
    //	to the other side based on what it expects from us.

    while (!g_fDone)
    {
	switch (g_WaitType)
	{

	case WAIT_MSGWAITFORMULTIPLE:

	    //	wait here for a message or an event to be signalled
	    dwRet = MsgWaitForMultipleObjects(1,
					    g_WaitEvent.GetHdl(),
					    FALSE,
					    600000,
					    QS_ALLINPUT);

	    //	Dispatch to ThreadWndProc if a message, or
	    //	to ProcessEvent if an event was signalled
	    ProcessMsgWaitForMultiple(dwRet);
	    break;


	case WAIT_GETMESSAGE:

	    //	wait for a windows message
	    if (GetMessage(&msg, NULL, 0, 0))
	    {
		//  dispatches to my ThreadWndProc
		DispatchMessage(&msg);
	    }
	    break;


	case WAIT_EVENT:

	    //	wait for the event to be signalled
	    if (g_fWaitMultiple)
		g_WaitEvent.BlockM();
	    else
		g_WaitEvent.BlockS();

	    //	process the event
	    ProcessIncommingEvent();
	    break;


	case WAIT_SYNCHRONOUS:

	    //	we have a synchronous singal to the other side, so there is
	    //	nothing to wait on, we will just go make another synchronous
	    //	call. this is valid only if the g_SignalType is
	    //	SIGNAL_SENDMESSAGE.

	    ProcessIncommingEvent();
	    break;


	default:

	    //	unknown event
	    break;
	}

    }	// while

    return msg.wParam;	 // Return value from PostQuitMessage
}



//--------------------------------------------------------------------------
//
//  processes a wakeup from MsgWaitForMultiple. Determines if the event was
//  a message arrival (in which case it Peeks it and Dispatches it, or if it
//  was an event signalled, in which case it calls the event handler.
//
//--------------------------------------------------------------------------

void CTaskSwitch::ProcessMsgWaitForMultiple(DWORD dwRet)
{
	MSG msg;

	if (dwRet == WAIT_OBJECT_0)
	{
	    // our event got signalled, update the counters
	    ProcessIncommingEvent();
	}

	else if (dwRet == WAIT_OBJECT_0 + 1)
	{
	    //	some windows message was received. dispatch it.

	    if (PeekMessage(&msg, g_hWndMe, 0, 0, PM_REMOVE))
	    {
		DispatchMessage(&msg);
	    }
	}
	else
	{
	    //	our event timed out or our event was abandoned or
	    //	an error occurred.

	    g_fDone = TRUE;
	}
}



//--------------------------------------------------------------------------
//
//  processes an incomming event. Just updates the counters and
//  signals the other side.
//
//--------------------------------------------------------------------------

void CTaskSwitch::ProcessIncommingEvent(void)
{
    //	update the loop counters
    UpdateLoopCounters();

    //	Signal the other side
    SignalOtherSide();
}



//--------------------------------------------------------------------------
//
//  process the incomming message
//
//--------------------------------------------------------------------------

LRESULT CTaskSwitch::ThreadWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    //	save the callers hWnd
    g_hWndOther = (HWND) wparam;

    //	process as usual
    ProcessIncommingEvent();

    return 0;
}



//--------------------------------------------------------------------------
//
//  updates the global loop counters, reseting the time when the inner
//  loop counter expires, and setting the fDone when the outer and inner
//  loop counters expire.
//
//--------------------------------------------------------------------------

void CTaskSwitch::UpdateLoopCounters(void)
{
    if (g_iloop == 0)
    {
	//  get time for latest outer loop
	g_time[g_oloop] = g_timer.Read();

	if (g_oloop == 0)
	{
	    //	that was the last outerloop, we're done.
	    g_fDone = TRUE;
	}
	else
	{
	    //	update the counters
	    g_iloop = g_execp.iloop;
	    --g_oloop;

	    //	restart the timer
	    g_timer.Reset();
	}
    }
    else
    {
	//  just update the inner loop count
	--g_iloop;
    }
}



//--------------------------------------------------------------------------
//
//  signals the other process or thread according to the SendType (either
//  signals an event or posts a message).
//
//--------------------------------------------------------------------------

void CTaskSwitch::SignalOtherSide(void)
{
    switch (g_SignalType)
    {

    case SIGNAL_EVENT:

	//  signal the other sides event
	g_SignalEvent.Signal();
	break;


    case SIGNAL_POSTMESSAGE:

	//  post a message to the other sides window handle.
	//  lparam tells ThreadWndProc which object to dispatch to, either
	//  g_pTaskSwitch1 or g_pTaskSwitch2.  We only go to 2 if we are
	//  doing thread switches AND the poster is not the kicker.

	PostMessage(g_hWndOther,
		    g_MyMessage,
		    (WPARAM)g_hWndMe,
		    (g_fThreadSwitch && !g_fKicker));
	break;


    case SIGNAL_SENDMESSAGE:

	//  send a message to the other side. this is a synchronous
	//  event. see comment in PostMessage above regarding lparam.

	SendMessage(g_hWndOther,
		    g_MyMessage,
		    (WPARAM)g_hWndMe,
		    (g_fThreadSwitch && !g_fKicker));
	break;


    case SIGNAL_SYNCHRONOUS:

	//  the event we received is a synchronous event. there is no need
	//  to do anything to wake the other side.

	break;


    default:

	//  unknown signal type
	break;
    }
}


//--------------------------------------------------------------------------
//
//  signals the other process or thread that it can begin the test. this
//  avoids timings skewed due to process startup latency.
//
//--------------------------------------------------------------------------

HRESULT CTaskSwitch::SendOrWaitFirstSignal(void)
{
    if (g_fKicker)
    {
	//  send a signal to drop the otherside into its wait loop, and
	//  then call SignalOtherSide to start the cycle, kicking the
	//  other side out of his first wait.

	printf ("Initial Signal to Other Side\n");
	g_SignalEvent.Signal();
	SignalOtherSide();
    }
    else
    {
	printf ("Waiting for Signal From Other Side\n");
	g_WaitEvent.BlockS();
    }

    return S_OK;
}



//--------------------------------------------------------------------------
//
//  initializes the window with the specified window proc.
//
//--------------------------------------------------------------------------

HRESULT CTaskSwitch::WindowInitialize(WNDPROC pfnWndProc, HWND &hWnd)
{

	if (!g_MyMessage)
	{
	    //	Register my message type
	    g_MyMessage = RegisterWindowMessage(
			  TEXT("Component Object Model Remote Request Arrival") );
	}

	if (!g_MyClass)
	{
	    // Register my window class.
	    WNDCLASS wcls;

	    wcls.style	       = 0;
	    wcls.lpfnWndProc   = pfnWndProc;
	    wcls.cbClsExtra    = 0;
	    wcls.cbWndExtra    = 0;
	    wcls.hInstance     = g_hInst;
	    wcls.hIcon	       = NULL;
	    wcls.hCursor       = NULL;
	    wcls.hbrBackground = (HBRUSH) COLOR_BACKGROUND + 1;
	    wcls.lpszMenuName  = NULL;
	    wcls.lpszClassName = MY_WINDOW_CLASS;

	    g_MyClass = RegisterClass( &wcls );
	}


	if (g_MyClass)
	{
	    // Create a hidden window.
	    hWnd  = CreateWindowEx( 0,
				    (LPCTSTR) g_MyClass,
				    TEXT("Task Switcher"),
                                    WS_DISABLED,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    NULL,
                                    NULL,
				    g_hInst,
				    NULL );


	    if (hWnd)
	    {
		printf ("Created Window with hWnd %x\n", hWnd);
		return S_OK;
	    }
	}

	return E_OUTOFMEMORY;
}


//--------------------------------------------------------------------------
//
//  destroys the window and unregisters the class.
//
//--------------------------------------------------------------------------

void CTaskSwitch::WindowUninitialize(HWND hWnd)
{
    if (hWnd != NULL)
    {
	DestroyWindow(hWnd);
    }

    if (g_MyClass != 0)
    {
	UnregisterClass(MY_WINDOW_CLASS, g_hInst);
    }
}



//--------------------------------------------------------------------------
//
//  parses the command line and returns the execution parameters
//
//--------------------------------------------------------------------------

HRESULT CTaskSwitch::ParseCmdLine(LPSTR lpszCmdLine, SExecParms &execp)
{
    BOOL fFile	       = FALSE;

    //	set the default values for execution parameters.

    execp.oloop        = 10;
    execp.iloop        = 100;
    execp.hWndOther    = NULL;
    execp.pfnWndProc   = ::ThreadWndProc;



    //	check the input parameters

    LPSTR pszCmd = lpszCmdLine;
    LPSTR pszCmdNext = NULL;

    while (pszCmd)
    {
	pszCmdNext = strchr(pszCmd, ' ');
	if (pszCmdNext)
	{
	    *pszCmdNext = '\0';
	    pszCmdNext++;
	}

	//  check for outer loop count
	if (!_strnicmp(pszCmd, "/o:", 3))
	{
	    execp.oloop = atoi (pszCmd+3);
	    if (execp.oloop > MAX_OLOOP)
		execp.oloop = MAX_OLOOP;
	}

	//  check for inner loop count
	else if (!_strnicmp(pszCmd, "/i:", 3))
	{
	    execp.iloop = atoi (pszCmd+3);
	    if (execp.iloop < 1)
		execp.iloop = 1;
	}

	//  check for window handle
	else if (!_strnicmp(pszCmd, "/hwnd:", 6))
	{
	    execp.hWndOther = (HWND) atoi (pszCmd+6);
	}

	//  check for waiter or Kicker
	else if (!_strnicmp(pszCmd, "/k", 2))
	{
	    g_fKicker = TRUE;
	}

	//  check for thread or process switch
	else if (!_strnicmp(pszCmd, "/p", 2))
	{
	    g_fThreadSwitch = FALSE;
	}

	//  check for thread or process switch
	else if (!_strnicmp(pszCmd, "/t", 2))
	{
	    g_fThreadSwitch = TRUE;
	}

	//  check for wait single or multiple
	else if (!_strnicmp(pszCmd, "/m", 2))
	{
	    g_fWaitMultiple = TRUE;
	}

	//  check for wait event name
	else if (!_strnicmp(pszCmd, "/e1:", 4))
	{
#ifdef UNICODE
	    mbstowcs(execp.szWaitEvent, pszCmd+4, strlen(pszCmd+4)+1);
#else
	    strcpy(execp.szWaitEvent, pszCmd+4);
#endif
	}

	//  check for signal event name
	else if (!_strnicmp(pszCmd, "/e2:", 4))
	{
#ifdef UNICODE
	    mbstowcs(execp.szSignalEvent, pszCmd+4, strlen(pszCmd+4)+1);
#else
	    strcpy(execp.szSignalEvent, pszCmd+4);
#endif
	}

	//  check for output file name
	else if (!_strnicmp(pszCmd, "/f:", 3))
	{
	    fFile = TRUE;
#ifdef UNICODE
	    mbstowcs(execp.szFile, pszCmd+3, strlen(pszCmd+3)+1);
#else
	    strcpy(execp.szFile, pszCmd+3);
#endif
	}

	//  check for wait type
	else if (!_strnicmp(pszCmd, "/w1:", 4))
	{
	    g_WaitType1 = GetWaitType(pszCmd+4);
	}
	else if (!_strnicmp(pszCmd, "/w2:", 4))
	{
	    g_WaitType2 = GetWaitType(pszCmd+4);
	}

	//  check for signal type
	else if (!_strnicmp(pszCmd, "/s1:", 4))
	{
	    g_SignalType1 = GetSignalType(pszCmd+4);
	}
	else if (!_strnicmp(pszCmd, "/s2:", 4))
	{
	    g_SignalType2 = GetSignalType(pszCmd+4);
	}

	//  check for help request
	else if ((!_strnicmp(pszCmd, "/?", 2)) || (!_strnicmp(pszCmd, "/h", 2)))
	{
	    Help();
	    return -1;
	}

	pszCmd = pszCmdNext;
    }


    g_iloop = execp.iloop;
    g_oloop = execp.iloop;
    g_hWndOther = execp.hWndOther;


    if (g_fKicker)
    {
	g_WaitType = g_WaitType2;
	g_SignalType = g_SignalType2;
	if (!fFile)
	    _tcscpy(execp.szFile, TEXT("kicker"));
    }
    else
    {
	g_WaitType = g_WaitType1;
	g_SignalType = g_SignalType1;
	if (!fFile)
	    _tcscpy(execp.szFile, TEXT("waiter"));

    }

    return S_OK;
}



DWORD	CTaskSwitch::GetWaitType(LPSTR pszCmd)
{
    ULONG   i=0;

    while (aszWait[++i])	// slot 0 is not used
    {
	if (!_stricmp(pszCmd, aszWait[i]))
	    return i;
    }

    Help();
    return 0;
}


DWORD	CTaskSwitch::GetSignalType(LPSTR pszCmd)
{
    ULONG   i=0;

    while (aszSignal[++i])	// slot 0 is not used
    {
	if (!_stricmp(pszCmd, aszSignal[i]))
	    return i;
    }

    Help();
    return 0;
}



//--------------------------------------------------------------------------
//
//  creates the command line parameters for the other guy
//
//--------------------------------------------------------------------------

void  CTaskSwitch::CreateOtherParms(void)
{




    //	write the formatted parms to the parm string

    sprintf(g_szOtherParms, "/k %s %s /i:%d /o:%d /hWnd:%ld "
        "/e1:%hs /e2:%hs /w1:%s /s1:%s /w2:%s /s2:%s",
	    (g_fThreadSwitch) ? "/t" : "/p",
	    (g_fWaitMultiple) ? "/m" : " ",
	    g_execp.iloop,		// same loop counts as me
	    g_execp.oloop,
	    g_hWndMe,			// posts to my window
	    g_execp.szSignalEvent,		// it waits on my signal event
	    g_execp.szWaitEvent,		// it signals my wait event
	    aszWait[g_WaitType1],	// signal what i wait on
	    aszSignal[g_SignalType1],	// wait on what i signal
	    aszWait[g_WaitType2],	// signal what i wait on
	    aszSignal[g_SignalType2]);	// wait on what i signal

}



//--------------------------------------------------------------------------
//
//  writes the execution parameters to a log file.
//
//--------------------------------------------------------------------------

void CTaskSwitch::WriteExecParms()
{
    //	write the run parameters to the output file

    g_output->WriteString(TEXT("Using Parametes:\n"));
    g_output->WriteResult(TEXT("\tInner Loop Count = "), g_execp.iloop);
    g_output->WriteResult(TEXT("\tOuter Loop Count = "), g_execp.oloop);
    g_output->WriteString(TEXT("\n\n"));

    //	flush to avoid disk io during the test
    g_output->Flush();
}


//--------------------------------------------------------------------------
//
//  writes the results to a log file.
//
//--------------------------------------------------------------------------

void CTaskSwitch::WriteResults(void)
{
    if (g_hr == S_OK)
    {
	//  compute the averages

	ULONG tTotal = 0;

	//  skip the first & last value as they are sometimes skewed
	for (int i=0; i<g_execp.oloop; i++)
	{
	    tTotal += g_time[i];
	}

	//  compute average for 1 call/response
	tTotal /= (g_execp.oloop * g_execp.iloop);


	//	display the results

	g_output->WriteResults(TEXT("Times "), g_execp.oloop, g_time);
	g_output->WriteResult(TEXT("\nAverage "), tTotal);
    }
}


//--------------------------------------------------------------------------
//
//  writes the help info to the screen
//
//--------------------------------------------------------------------------

void CTaskSwitch::Help()
{
    printf ("msgtask\n");
    printf ("\t/o:<nnn>             - outer loop count def 10\n");
    printf ("\t/i:<nnn>             - inner loop count def 100\n");
    printf ("\t/f:<name>            - name of output file. def [kick | wait]\n");
    printf ("\t/w1:<event|getmsg|msgwait> - what to wait on\n");
    printf ("\t/s1:<event|postmsg>   - what to signal\n");
    printf ("\t/w2:<event|getmsg|msgwait> - what to wait on\n");
    printf ("\t/s2:<event|postmsg>   - what to signal\n");
    printf ("\t/e1:<name>           - name of wait event\n");
    printf ("\t/e2:<name>           - name of signal event\n");
    printf ("\t/k                   - kicker (as opposed to waiter)\n");
    printf ("\t/t                   - use thread switching\n");
    printf ("\t/p                   - use process switching\n");
    printf ("\t/m                   - use WaitMultiple vs WaitSingle\n");
    printf ("\t/hWnd:<nnnn>         - window handle of other side\n");

    printf ("\n");
    printf ("timings are given for the inner loop count calls\n");

    return;
}


//--------------------------------------------------------------------------
//
//  creates a process
//
//--------------------------------------------------------------------------

DWORD CTaskSwitch::CreateProc(void)
{
    //	create the command line

    TCHAR szCmdLine[256];

    _stprintf(szCmdLine, TEXT("ntsd procswap %hs"), g_szOtherParms);



    //	build the win32 startup info structure

    STARTUPINFO startupinfo;
    startupinfo.cb	    = sizeof(STARTUPINFO);
    startupinfo.lpReserved  = NULL;
    startupinfo.lpDesktop   = NULL;
    startupinfo.lpTitle     = TEXT("Task Switcher");
    startupinfo.dwX	    = 40;
    startupinfo.dwY	    = 40;
    startupinfo.dwXSize     = 80;
    startupinfo.dwYSize     = 40;
    startupinfo.dwFlags     = 0;
    startupinfo.wShowWindow = SW_SHOWNORMAL;
    startupinfo.cbReserved2 = 0;
    startupinfo.lpReserved2 = NULL;

    PROCESS_INFORMATION	ProcInfo;


    BOOL fRslt = CreateProcess(NULL,	    //	app name
			 szCmdLine,	    //	command line
			 NULL,		    //	lpsaProcess
			 NULL,		    //	lpsaThread
			 FALSE,		    //	inherit handles
			 CREATE_NEW_CONSOLE,//	creation flags
			 NULL,		    //	lpEnvironment
			 NULL,		    //	curr Dir
			 &startupinfo,	    //	Startup Info
			 &ProcInfo);	    //	process info

    if (fRslt)
    {
	//  we dont need the handles
	CloseHandle(ProcInfo.hProcess);
	CloseHandle(ProcInfo.hThread);
	printf ("Created Process (%ws) pid=%x\n", szCmdLine, ProcInfo.dwProcessId);
	return S_OK;
    }
    else
    {
	//  what went wrong?
	DWORD dwRet = GetLastError();
	printf ("CreateProcess (%ws) failed %x\n", szCmdLine, dwRet);
	return dwRet;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\rawrpc\rawrpc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:	rawrpc.cxx
//
//  Contents:	definitions for benchmark test 
//
//  Classes:
//
//  Functions:	
//
//  History:	08-Feb-94   Rickhi	Created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <rpc.h>
#include <rawrpc.h>

extern "C" const GUID IID_IRawRpc;


int _cdecl main (int argc, char ** argv)
{
    //	start Rpc
    RPC_STATUS	rc;
#ifdef USE_MSWMSG
    LPTSTR	pszProtseq  = TEXT("mswmsg");
    MSG msg;
#else
    LPTSTR	pszProtseq  = TEXT("ncalrpc");
#endif
    LPTSTR	pszEndPoint = TEXT("99999.99999");
    HANDLE hEvent;

#ifdef UNICODE
    rc = RpcServerUseProtseqEp(pszProtseq,
			       RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
			       pszEndPoint,
			       NULL);
#else
    rc = RpcServerUseProtseqEp((unsigned char *)pszProtseq,
			       RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
			       (unsigned char *)pszEndPoint,
			       NULL);
#endif
    if (rc != RPC_S_OK)
    {
	return rc;
    }


    rc = RpcServerRegisterIf(IRawRpc_ServerIfHandle, 0, 0);
    if (rc != RPC_S_OK)
    {
	return rc;
    }


    I_RpcSsDontSerializeContext();

    //
    // Signal the client that we're up and running
    //
    hEvent = CreateEvent(NULL, TRUE, FALSE,
                        TEXT("OleBenchRawRpcServerStarted"));

    //	start server listening. this call blocks until we get an
    //	RpcMgmtStopServerListening call.

    rc = RpcServerListen(1, 0xffff, 1);
    if (rc != RPC_S_OK)
    {
        CloseHandle(hEvent);
	return rc;
    }
    if (!SetEvent(hEvent))
    {
        CloseHandle(hEvent);
	return GetLastError();
    }
    CloseHandle(hEvent);

#ifdef USE_MSWMSG
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
#endif
    rc = RpcMgmtWaitServerListen();
    if (rc != RPC_S_OK)
    {
	return rc;
    }

    //	done, exit.
    return 0;
}



//  Server side of Rpc functions.

SCODE  Quit(handle_t hRpc)
{
    SCODE rc;

    rc = RpcMgmtStopServerListening(NULL);
#ifdef USE_MSWMSG
    PostQuitMessage(0);
#endif
    return rc;
}


//+-------------------------------------------------------------------------
//
//  Method:	Void
//
//  Synopsis:	tests passing no parameters
//
//  Arguments:
//
//  Returns:
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
void  Void(handle_t hRpc)
{
    return;
}

SCODE  VoidRC(handle_t hRpc)
{
    return RPC_S_OK;
}

SCODE  VoidPtrIn(handle_t hRpc, ULONG cb, void *pv)
{
    return RPC_S_OK;
}
    
SCODE  VoidPtrOut(handle_t hRpc, ULONG cb, ULONG *pcb, void *pv)
{
    memset(pv, 1, cb);
    *pcb = cb;
    return RPC_S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	 Dword
//
//  Synopsis:	tests passing dwords in and out
//
//  Arguments:
//
//  Returns:	RPC_S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
SCODE  DwordIn(handle_t hRpc, DWORD dw)
{
    return RPC_S_OK;
}


SCODE  DwordOut(handle_t hRpc, DWORD *pdw)
{
    *pdw = 1;
    return RPC_S_OK;
}


SCODE  DwordInOut(handle_t hRpc, DWORD *pdw)
{
    *pdw = 1;
    return RPC_S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	 Li
//
//  Synopsis:	tests passing LARGE INTEGERS in and out
//
//  Arguments:
//
//  Returns:	RPC_S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

SCODE  LiIn(handle_t hRpc, LARGE_INTEGER li)
{
    return RPC_S_OK;
}


SCODE  LiOut(handle_t hRpc, LARGE_INTEGER *pli)
{
    pli->LowPart = 0;
    pli->HighPart = 1;
    return RPC_S_OK;
}


SCODE  ULiIn(handle_t hRpc, ULARGE_INTEGER uli)
{
    return RPC_S_OK;
}


SCODE  ULiOut(handle_t hRpc, ULARGE_INTEGER *puli)
{
    puli->LowPart = 0;
    puli->HighPart = 1;
    return RPC_S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	 String
//
//  Synopsis:	tests passing strings in and out
//
//  Arguments:
//
//  Returns:	RPC_S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
SCODE  StringIn(handle_t hRpc, LPWSTR pwsz)
{
    return RPC_S_OK;
}


SCODE  StringOut(handle_t hRpc, LPWSTR *ppwsz)
{
    // LPOLESTR pwsz = new OLECHAR[80];
    // *ppwsz = pwsz;
    wcscpy(*ppwsz, L"Hello World This is a Message");
    return RPC_S_OK;
}


SCODE  StringInOut(handle_t hRpc, LPWSTR pwsz)
{
    wcscpy(pwsz, L"Hello World This is a Message");
    return RPC_S_OK;
}



//+-------------------------------------------------------------------------
//
//  Function:	 Guid
//
//  Synopsis:	tests passing GUIDs in and out
//
//  Arguments:
//
//  Returns:	RPC_S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
SCODE  GuidIn(handle_t hRpc, GUID guid)
{
    return RPC_S_OK;
}

SCODE  GuidOut(handle_t hRpc, GUID *piid)
{
    memcpy(piid, &IID_IRawRpc, sizeof(GUID));
    return  RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server1\ctestcf.cxx ===
//+-------------------------------------------------------------------
//  File:       ctestcf.cxx
//
//  Contents:
//
//  Classes:    CTestEmbedCF - IClassFactory
//
//  History:    7-Dec-92   DeanE   Created
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"

//+-------------------------------------------------------------------
//  Member:     CTestEmbedCF::CTestEmbedCF()
//
//  Synopsis:   The constructor for CTestEmbedCF.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbedCF::CTestEmbedCF(CTestServerApp *ptsaServer) : _cRef(1)
{
    _ptsaServer = ptsaServer;

    return;
}


//+-------------------------------------------------------------------
//  Member:     CTestEmbedCF::~CTestEmbedCF()
//
//  Synopsis:   The destructor for CTestEmbedCF.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbedCF::~CTestEmbedCF()
{
    _ptsaServer = NULL;
}


//+-------------------------------------------------------------------
//  Member:     CTestEmbedCF::Create()
//
//  Synopsis:   Creates a new CTestEmbedCF object.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
IClassFactory FAR* CTestEmbedCF::Create(CTestServerApp *ptsaServer)
{
    CTestEmbedCF FAR* pteCF = new FAR CTestEmbedCF(ptsaServer);
//    if (NULL != pteCF)
//    {
//        _ptsaServer = ptsaServer;
//    }
    return(pteCF);
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbedCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//              return pointer to the actual object
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbedCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (GuidEqual(iid, IID_IUnknown) || GuidEqual(iid, IID_IClassFactory))
    {
        *ppv = this;
	AddRef();
        return(S_OK);
    }
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) CTestEmbedCF::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CTestEmbedCF::Release(void)
{
    ULONG cRefs = --_cRef;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}





//+-------------------------------------------------------------------
//  Method:     CTestEmbedCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object.
//
//  Parameters: [pUnkOuter]    - Ignored.  Affects aggregation.
//              [iidInterface] - Interface ID object should support.
//              [ppv]          - Pointer to the object.
//
//  Returns:    S_OOM if object couldn't be created, or SCODE from
//              QueryInterface call.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbedCF::CreateInstance(
        IUnknown FAR  *pUnkOuter,
        REFIID         iidInterface,
        void FAR* FAR *ppv)
{
    CTestEmbed FAR *pteObj;
    SCODE           sc;

    pteObj = new FAR CTestEmbed();
    if (pteObj == NULL)
    {
        return(E_OUTOFMEMORY);
    }
    sc = pteObj->InitObject(_ptsaServer, g_hwndMain);
    if (S_OK != sc)
    {
        delete pteObj;
        return(E_OUTOFMEMORY);
    }

    // Having created the actual object, ensure desired
    // interfaces are available.
    //
    sc = pteObj->QueryInterface(iidInterface, ppv);


    // We are done with the CTestEmbed instance - it's now referenced by ppv
    pteObj->Release();

    return(sc);
}

//+-------------------------------------------------------------------
//  Method:     CTestEmbedCF::LockServer
//
//  Synopsis:   What does this do?
//
//  Parameters: [fLock] - ???
//
//  Returns:    ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbedCF::LockServer(BOOL fLock)
{
    // BUGBUG - What does this do?
    return(E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server1\idataobj.cxx ===
//+-------------------------------------------------------------------
//  File:       idataobj.cxx
//
//  Contents:   IDataObject methods of CTestEmbed class.
//
//  Classes:    CTestEmbed - IDataObject implementation
//
//  History:    7-Dec-92   DeanE   Created
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"


//+-------------------------------------------------------------------
//  Member:     CDataObject::CDataObject()
//
//  Synopsis:   The constructor for CDataObject.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CDataObject::CDataObject(CTestEmbed *pteObject)
{
    _cRef      = 1;
    _pDAHolder = NULL;
    _pteObject = pteObject;
}


//+-------------------------------------------------------------------
//  Member:     CDataObject::~CDataObject()
//
//  Synopsis:   The destructor for CDataObject.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CDataObject::~CDataObject()
{
    // _cRef count should be 1
    if (1 != _cRef)
    {
        // BUGBUG - Log error
        // Someone hasn't released one of these - Log error
    }
    return;
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::QueryInterface
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::QueryInterface(REFIID iid, void FAR * FAR *ppv)
{
    return(_pteObject->QueryInterface(iid, ppv));
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::AddRef
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDataObject::AddRef(void)
{
    ++_cRef;
    return(_pteObject->AddRef());
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::Release
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDataObject::Release(void)
{
    --_cRef;
    return(_pteObject->Release());
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::GetData
//
//  Synopsis:   See spec 2.00.09 p129.  Retrieve data for this object
//              using the FORMATETC passed.
//
//  Parameters: [pformatetcIn] - The format caller wants returned data
//              [pmedium]      - Returned data
//
//  Returns:    S_OK, or E_FORMAT if we don't support the format requested
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::GetData(
        LPFORMATETC pformatetcIn,
        LPSTGMEDIUM pmedium)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::GetDataHere
//
//  Synopsis:   See spec 2.00.09 p130.  Like GetData, but the pmedium is
//              allocated and ready for us to use.
//
//  Parameters: [pformatetc] - The format caller wants returned data
//              [pmedium]    - STGMEDIUM object ready for our use
//
//  Returns:    S_OK, E_FORMAT
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::GetDataHere(
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::QueryGetData
//
//  Synopsis:   See spec 2.00.09 p130.  Answer if the format requested
//              would be honored by GetData.
//
//  Parameters: [pformatetc] - The format being queried about
//
//  Returns:    S_OK or S_FALSE
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC pformatetc)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::GetCanonicalFormatEtc
//
//  Synopsis:   See spec 2.00.09 p131
//
//  Parameters: [pformatetc]    -
//              [pformatetcOut] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::GetCanonicalFormatEtc(
        LPFORMATETC pformatetc,
        LPFORMATETC pformatetcOut)

{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::SetData
//
//  Synopsis:   See spec 2.00.09 p131.
//
//  Parameters: [pformatetc] -
//              [pmedium]    -
//              [fRelease]   -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::SetData(
        LPFORMATETC    pformatetc,
        STGMEDIUM FAR *pmedium,
        BOOL           fRelease)
{
    // BUGBUG - NYI
    return(DV_E_CLIPFORMAT);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::EnumFormatEtc
//
//  Synopsis:   See spec 2.00.09 p131.
//
//  Parameters: [dwDirection]    -
//              [ppenmFormatEtc] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::EnumFormatEtc(
        DWORD                dwDirection,
        LPENUMFORMATETC FAR *ppenmFormatEtc)
{
    // BUGBUG - NYI
    *ppenmFormatEtc = NULL;
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:	CDataObject::DAdvise
//
//  Synopsis:   See spec 2.00.09 p132
//
//  Parameters: [pFormatetc]    -
//              [advf]          -
//              [pAdvSink]      -
//              [pdwConnection] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::DAdvise(
        FORMATETC FAR *pFormatetc,
        DWORD          advf,
        LPADVISESINK   pAdvSink,
        DWORD     FAR *pdwConnection)
{
    if (NULL == _pDAHolder)
    {
        if (S_OK != CreateDataAdviseHolder(&_pDAHolder))
        {
            return(E_OUTOFMEMORY);
        }
    }

    return(_pDAHolder->Advise(this, pFormatetc, advf, pAdvSink, pdwConnection));
}


//+-------------------------------------------------------------------
//  Method:	CDataObject::DUnadvise
//
//  Synopsis:   See spec 2.00.09 p133
//
//  Parameters: [dwConnection] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::DUnadvise(DWORD dwConnection)
{
    if (NULL == _pDAHolder)
    {
        // Nobody is registered
        return(E_INVALIDARG);
    }

    return(_pDAHolder->Unadvise(dwConnection));
}


//+-------------------------------------------------------------------
//  Method:	CDataObject::EnumDAdvise
//
//  Synopsis:   See spec 2.00.09 p133
//
//  Parameters: [ppenmAdvise] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::EnumDAdvise(LPENUMSTATDATA FAR *ppenmAdvise)
{
    if (NULL == _pDAHolder)
    {
	return(E_FAIL);
    }

    return(_pDAHolder->EnumAdvise(ppenmAdvise));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server1\ioleobj.cxx ===
//+-------------------------------------------------------------------
//  File:       ioleobj.cxx
//
//  Contents:   IOleObject methods of COleObject class.
//
//  Classes:    COleObject - IOleObject implementation
//
//  History:    7-Dec-92   DeanE   Created
//              31-Dec-93  ErikGav Chicago port
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"


//+-------------------------------------------------------------------
//  Member:     COleObject::COleObject()
//
//  Synopsis:   The constructor for COleObject.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
COleObject::COleObject(CTestEmbed *pteObject)
{
    _cRef      = 1;
    _pOAHolder = NULL;
    _pocs      = NULL;
    _pteObject = pteObject;
    _pmkContainer = NULL;
}


//+-------------------------------------------------------------------
//  Member:     COleObject::~COleObject()
//
//  Synopsis:   The destructor for COleObject.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
COleObject::~COleObject()
{
    // _cRef should be 1
    if (1 != _cRef)
    {
        // BUGBUG - Log error - someone hasn't released
    }

    if (_pocs != NULL)
    {
	_pocs->Release();
    }

    if (_pmkContainer != NULL)
    {
	_pmkContainer->Release();
    }

}


//+-------------------------------------------------------------------
//  Method:     COleObject::QueryInterface
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::QueryInterface(REFIID iid, void FAR * FAR *ppv)
{
    return(_pteObject->QueryInterface(iid, ppv));
}


//+-------------------------------------------------------------------
//  Method:     COleObject::AddRef
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) COleObject::AddRef(void)
{
    ++_cRef;
    return(_pteObject->AddRef());
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Release
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) COleObject::Release(void)
{
    --_cRef;
    return(_pteObject->Release());
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetClientSite
//
//  Synopsis:   Save the IOleClientSite pointer passed - it's this
//              object's client site object.
//
//  Parameters: [pClientSite] - Pointer to the new client site object.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    if (_pocs != NULL)
    {
	_pocs->Release();
    }

    _pocs = pClientSite;

    if (pClientSite)
    {
	_pocs->AddRef();
    }

    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetClientSite
//
//  Synopsis:   Return this objects current client site - NULL indicates
//              it hasn't been set yet.
//
//  Parameters: [ppClientSite] - Save current client site pointer here.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetClientSite(LPOLECLIENTSITE FAR *ppClientSite)
{
    *ppClientSite = _pocs;
    _pocs->AddRef();
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetHostNames
//
//  Synopsis:   See spec 2.00.09 p99.  Returns names the caller can use
//              to display our object name (in window titles and such).
//
//  Parameters: [szContainerApp] - Name of container application.
//              [szContainerObj] - Name of this object.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetHostNames(
	LPCWSTR szContainerApp,
	LPCWSTR szContainerObj)
{
    szContainerApp = L"Test Server";
    szContainerObj = L"Test Server:Test Object";
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Close
//
//  Synopsis:   See spec 2.00.09 p104.  Short story is:  if fMerelyHide,
//              turn off the UI of this object, else return to the
//              "loaded" state, which for us means to shut down (since we
//              don't do any caching).
//
//  Parameters: [dwSaveOption] - ???
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - what if we have multiple instances?  Do we
//                return the server app to the loaded state or do we
//                return this object to the loaded state?
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Close(DWORD dwSaveOption)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetMoniker
//
//  Synopsis:   See spec 2.00.09 p99.  The moniker for this object
//              (or it's container) has been changed to that passed
//              in.  Take appropriate actions (de-register old object
//              and register new, inform contained objects, etc).
//
//  Parameters: [dwWhichMoniker] - Moniker type being sent.
//              [pmk]            - The new moniker.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    if (_pmkContainer)
    {
	_pmkContainer->Release();

    }

    _pmkContainer = pmk;

    pmk->AddRef();

    // Set moniker in container
    IOleObject *pobj;

    HRESULT hresult = _pocs->QueryInterface(IID_IOleObject, (void **) &pobj);

    pobj->SetMoniker(dwWhichMoniker, pmk);

    pobj->Release();

    return S_OK;
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetMoniker
//
//  Synopsis:   See spec 2.00.09 p100.  Return either this objects
//              container moniker, this objects relative moniker, or
//              this objects full moniker.
//
//  Parameters: [dwAssign]       - Condition to get moniker.
//              [dwWhichMoniker] - Kind of moniker being requested.
//              [ppmk]           - Return moniker here.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetMoniker(
        DWORD          dwAssign,
        DWORD          dwWhichMoniker,
        LPMONIKER FAR *ppmk)
{
    *ppmk = _pmkContainer;
    _pmkContainer->AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------
//  Method:     COleObject::InitFromData
//
//  Synopsis:   See spec 2.00.09 p100.  Initialize this object from
//              the format passed in.
//
//  Parameters: [pDataObject] - IDataObject providing data.
//              [fCreation]   - TRUE if this is the initial creation.
//              [dwReserved]  - Ignored.
//
//  Returns:    S_OK if we attempt to initialize, S_FALSE if we don't
//              want to.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::InitFromData(
        LPDATAOBJECT pDataObject,
        BOOL         fCreation,
        DWORD        dwReserved)
{
    // BUGBUG - NYI
    return(S_FALSE);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetClipboardData
//
//  Synopsis:   See spec 2.00.09 p101.  Return clipboard object that would
//              be created if Edit/Copy were done to this item.
//
//  Parameters: [dwReserved]   - Ignored.
//              [ppDataObject] - IDataObject return locale.
//
//  Returns:    S_OK or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetClipboardData(
        DWORD             dwReserved,
        LPDATAOBJECT FAR *ppDataObject)
{
    // BUGBUG - NYI
    *ppDataObject = NULL;
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::DoVerb
//
//  Synopsis:   See spec 2.00.09 p101.  Execute the verb passed in.
//
//  Parameters: [iVerb]       - Verb being requested.
//              [pMsg]        - Message that triggered the request.
//              [pActiveSite] - IOleClientSite for this object.
//              [lReserved]   - Ignored.
//
//  Returns:    S_OK, or other ones specified but not defined yet...
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::DoVerb(
        LONG            iVerb,
        LPMSG           pMsg,
        LPOLECLIENTSITE pActiveSite,
	LONG		lReserved,
	HWND		hwndParent,
	LPCRECT 	lprcPosRect)
{
    // HWND hwndObj;

    if (OLEIVERB_SHOW == iVerb)
    {
        // BUGBUG - NYI
        // Display the object (we're not in-place yet)
	// PostMessage(g_hwndMain, WM_REPORT, MB_SHOWVERB, 0);
        // PostMessage(0xFFFF, WM_REPORT, MB_SHOWVERB, 0);
	// MessageBox(g_hwndMain, L"Received OLEIVERB_SHOW", L"OLE Server", MB_ICONINFORMATION | MB_OK);

        // Get hwndObj
        //_pteObject->GetWindow(&hwndObj);
	//MessageBox(hwndObj, L"Received OLEIVERB_SHOW", L"OLE Server", MB_ICONINFORMATION | MB_OK);
    }
    else
    {
        // Return alternate error code?
    }

    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::EnumVerbs
//
//  Synopsis:   See spec 2.00.09 p103.  Enumerate all the verbs available
//              on this object in increasing numerical order.
//
//  Parameters: [ppenmOleVerb] - Enumeration object return locale.
//
//  Returns:    S_OK or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::EnumVerbs(IEnumOLEVERB FAR* FAR *ppenmOleVerb)
{
    // BUGBUG - NYI
    *ppenmOleVerb = NULL;
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Update
//
//  Synopsis:   See spec 2.00.09 p105.  Ensure any data or view caches
//              maintained inside the object are up to date.
//
//  Parameters: None
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Update()
{
    // We don't use any caches, so we don't have to do anything
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::IsUpToDate
//
//  Synopsis:   See spec 2.00.09 p105. Check to see if this object is
//              up to date - including embedded children, etc.
//
//  Parameters: None
//
//  Returns:    S_OK, S_FALSE, or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::IsUpToDate()
{
    // We should always be up to date as we don't have any caches
    // or children or links
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:	COleObject::GetUserClassID
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Parameters: [dwFormOfType] -
//              [pszUserType]  -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetUserClassID(
	CLSID FAR *pClsid)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetUserType
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Parameters: [dwFormOfType] -
//              [pszUserType]  -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetUserType(
        DWORD      dwFormOfType,
	LPWSTR FAR *pszUserType)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetExtent
//
//  Synopsis:   See spec 2.00.09 p106.  Set the rectangular extent of
//              this object.  Container will call us with the size
//              it will give us; we must fit accordingly.
//
//  Parameters: [dwDrawAspect] - DVASPECT specified for this object.
//              [lpsizel]      - Extent structure.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetExtent
//
//  Synopsis:   See spec 2.00.09 p106.  Size of the object given in the
//              the last SetExtent call is returned.  If SetExtent has
//              not been called, the natural size of the object is
//              returned.
//
//  Parameters: [dwDrawAspect] - DVASPECT specified for this object.
//              [lpsizel]      - Extent structure to set.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Advise
//
//  Synopsis:   See spec 2.00.09 p121.  Set up an advisory connection
//              between this object and an advisory sink; when certain
//              events happen (birthdays?) this sink should be informed
//              by this object.  Use the OleAdviseHolder object as a
//              helper (see p122).
//
//  Parameters: [pAdvSink]      - Sink that should be informed of changes.
//              [pdwConnection] - Pass advisory token returned so our
//                                caller can shut down the link.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Advise(
        IAdviseSink FAR *pAdvSink,
        DWORD       FAR *pdwConnection)
{
//    if (NULL == _pOAHolder)
//    {
//	 if (S_OK != CreateOleAdviseHolder(&_pOAHolder))
//	 {
//	     return(E_OUTOFMEMORY);
//	 }
//    }
//
//    return(_pOAHolder->Advise(pAdvSink, pdwConnection));
    return S_OK;
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Unadvise
//
//  Synopsis:   See spec 2.00.09 p121.  Tear down an advisory connection
//              set up previously.
//
//  Parameters: [dwConnection] - Connection established earlier.
//
//  Returns:    S_OK or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Unadvise(DWORD dwConnection)
{
    if (NULL == _pOAHolder)
    {
        // No one is registered - see ellipswt.cpp for this
        return(E_INVALIDARG);
    }

    return(_pOAHolder->Unadvise(dwConnection));
}


//+-------------------------------------------------------------------
//  Method:     COleObject::EnumAdvise
//
//  Synopsis:   See spec 2.00.09 p122.  Enumerate the advisory connections
//              currently attached to this object.
//
//  Parameters: [ppenmAdvise] - Enumeration object to return.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::EnumAdvise(LPENUMSTATDATA FAR *ppenmAdvise)
{
    if (NULL == _pOAHolder)
    {
	return(E_FAIL);
    }
    return(_pOAHolder->EnumAdvise(ppenmAdvise));
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetMiscStatus
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Returns:    S_OK?
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetMiscStatus(
        DWORD dwAspect,
        DWORD FAR *pdwStatus)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetColorScheme
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Returns:    S_OK?
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetColorScheme(LPLOGPALETTE lpLogpal)
{
    // BUGBUG - NYI
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\perform\rawrpc\rawrpc_s.c ===
#include <string.h>
#include <limits.h>
#include <rpc.h>

#include "rawrpc.h"
extern RPC_DISPATCH_TABLE IRawRpc_DispatchTable;

static RPC_SERVER_INTERFACE ___RpcServerInterface =  {
  sizeof(RPC_SERVER_INTERFACE),
  {{0x00000145,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}},
  {0,0}},
    {
    {0x8A885D04L,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},
    {2,0}
    }
  ,
  &IRawRpc_DispatchTable,0,0,
  0
  }
;
RPC_IF_HANDLE IRawRpc_ServerIfHandle = (RPC_IF_HANDLE) &___RpcServerInterface;
void __RPC_STUB IRawRpc_Quit(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->Quit(hRpc);
    }
  else
    {
	_ret_value = Quit(hRpc);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_Void(
	PRPC_MESSAGE _prpcmsg)
  {
  handle_t hRpc = _prpcmsg->Handle;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->Void(hRpc);
    }
  else
    {
	Void(hRpc);
    }
  _prpcmsg->BufferLength = 0;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  }
void __RPC_STUB IRawRpc_VoidRC(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->VoidRC(hRpc);
    }
  else
    {
	_ret_value = VoidRC(hRpc);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_VoidPtrIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  ULONG cb;
  void *pv = 0;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    /* receive data into &cb */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&cb);
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    // recv total number of elements
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
    if (pv ==0)
      {
      pv = (void *)MIDL_user_allocate ((size_t)(_alloc_total * sizeof(unsigned char)));
      }
    byte_array_from_ndr ((PRPC_MESSAGE)_prpcmsg, 0, _alloc_total, pv);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->VoidPtrIn(hRpc, cb, pv);
      }
    else
      {
	_ret_value = VoidPtrIn(hRpc, cb, pv);
      }
    _prpcmsg->BufferLength = 4;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    MIDL_user_free((void  *)(pv));
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_VoidPtrOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  ULONG cb;
  ULONG *pcb = 0;
  void *pv = 0;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    /* receive data into &cb */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&cb);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  pcb = (unsigned long  *)MIDL_user_allocate ((size_t)(sizeof(long)));
  _alloc_total = cb;
  pv = (void *)MIDL_user_allocate ((size_t)(_alloc_total * sizeof(unsigned char)));
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->VoidPtrOut(hRpc, cb, pcb, pv);
      }
    else
      {
	_ret_value = VoidPtrOut(hRpc, cb, pcb, pv);
      }
    _prpcmsg->BufferLength = 24;
    if (pv ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    if (cb)
      {
      if (((*(pcb))) > (cb)) RpcRaiseException(RPC_X_INVALID_BOUND);
      }
    else
      {
      if (((*(pcb))) != (cb)) RpcRaiseException(RPC_X_INVALID_BOUND);
      }
    _prpcmsg->BufferLength += 12;
    _prpcmsg->BufferLength += (unsigned int)((*(pcb)));
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from *pcb */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)*pcb;
    // send total number of elements
    *(*(long **)&_prpcmsg->Buffer)++ = cb;
    // send valid range
    *(*(long **)&_prpcmsg->Buffer)++ = 0;
    *(*(long **)&_prpcmsg->Buffer)++ = (*(pcb));
    /* send data from pv */
    NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) ((unsigned char *)pv+0), (unsigned int)((*(pcb))));
    *(unsigned long *)&_prpcmsg->Buffer += (*(pcb));
    /* send data from _ret_value */
    *(unsigned long *)&_prpcmsg->Buffer += 3;
    *(unsigned long *)&_prpcmsg->Buffer &= 0xfffffffc;
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    MIDL_user_free((void  *)(pv));
    MIDL_user_free((void  *)(pcb));
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_DwordIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  DWORD dw;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    /* receive data into &dw */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&dw);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->DwordIn(hRpc, dw);
    }
  else
    {
	_ret_value = DwordIn(hRpc, dw);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_DwordOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  DWORD pdw;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->DwordOut(hRpc, &pdw);
      }
    else
      {
	_ret_value = DwordOut(hRpc, &pdw);
      }
    _prpcmsg->BufferLength = 8;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from pdw */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)pdw;
    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_DwordInOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  DWORD pdw;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    /* receive data into &pdw */
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, (unsigned long *)&pdw);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->DwordInOut(hRpc, &pdw);
      }
    else
      {
	_ret_value = DwordInOut(hRpc, &pdw);
      }
    _prpcmsg->BufferLength = 8;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from pdw */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)pdw;
    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_LiIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  LARGE_INTEGER li;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (&li), "4ll", 8);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->LiIn(hRpc, li);
    }
  else
    {
	_ret_value = LiIn(hRpc, li);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_LiOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  LARGE_INTEGER pli;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->LiOut(hRpc, &pli);
      }
    else
      {
	_ret_value = LiOut(hRpc, &pli);
      }
    _prpcmsg->BufferLength = 12;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from &pli */
    NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&pli), (unsigned int)(8));
    *(unsigned long *)&_prpcmsg->Buffer += 8;
    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_ULiIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  ULARGE_INTEGER uli;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (&uli), "4ll", 8);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->ULiIn(hRpc, uli);
    }
  else
    {
	_ret_value = ULiIn(hRpc, uli);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_ULiOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  ULARGE_INTEGER puli;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->ULiOut(hRpc, &puli);
      }
    else
      {
	_ret_value = ULiOut(hRpc, &puli);
      }
    _prpcmsg->BufferLength = 12;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from &puli */
    NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&puli), (unsigned int)(8));
    *(unsigned long *)&_prpcmsg->Buffer += 8;
    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_StringIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  LPWSTR pwsz = 0;
  unsigned long _alloc_total;
  unsigned long _valid_lower;
  unsigned long _valid_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _valid_total ));
  ((void)( _valid_lower ));
  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    _treebuf = 0;
    // recv total number of elements
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
    if (pwsz ==0)
      {
      pwsz = (WCHAR *)MIDL_user_allocate ((size_t)(_alloc_total * sizeof(WCHAR)));
      }
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (pwsz), "s2", 1);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->StringIn(hRpc, pwsz);
      }
    else
      {
	_ret_value = StringIn(hRpc, pwsz);
      }
    _prpcmsg->BufferLength = 4;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    MIDL_user_free((void  *)(pwsz));
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_StringOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  LPWSTR ppwsz = 0;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->StringOut(hRpc, &ppwsz);
      }
    else
      {
	_ret_value = StringOut(hRpc, &ppwsz);
      }
    _prpcmsg->BufferLength = 16;
    _prpcmsg->BufferLength += 4;
    if (ppwsz !=0)
      {
      tree_size_ndr((void __RPC_FAR *)&(ppwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
      }
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from ppwsz */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)ppwsz;
    if (ppwsz !=0)
      {
      tree_into_ndr((void __RPC_FAR *)&(ppwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
      }
    /* send data from _ret_value */
    *(unsigned long *)&_prpcmsg->Buffer += 3;
    *(unsigned long *)&_prpcmsg->Buffer &= 0xfffffffc;
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    if (ppwsz !=0)
      {
      MIDL_user_free((void  *)(ppwsz));
      }
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_StringInOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  LPWSTR pwsz = 0;
  unsigned long _alloc_total;
  unsigned long _valid_lower;
  unsigned long _valid_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _buffer;
  unsigned char * _treebuf;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _valid_total ));
  ((void)( _valid_lower ));
  ((void)( _packet ));
  ((void)( _buffer ));
  ((void)( _treebuf ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    _tempbuf = (unsigned char *)_prpcmsg->Buffer;
    _treebuf = 0;
    // recv total number of elements
    long_from_ndr((PRPC_MESSAGE)_prpcmsg, &_alloc_total);
    if (pwsz ==0)
      {
      pwsz = (WCHAR *)MIDL_user_allocate ((size_t)(_alloc_total * sizeof(WCHAR)));
      }
    data_from_ndr((PRPC_MESSAGE)_prpcmsg, (void __RPC_FAR *) (pwsz), "s2", 1);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->StringInOut(hRpc, pwsz);
      }
    else
      {
	_ret_value = StringInOut(hRpc, pwsz);
      }
    _prpcmsg->BufferLength = 16;
    if (pwsz ==0)
	RpcRaiseException(RPC_X_NULL_REF_POINTER);
    tree_size_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    tree_into_ndr((void __RPC_FAR *)&(pwsz), (PRPC_MESSAGE)_prpcmsg, "s2", 1);
    /* send data from _ret_value */
    *(unsigned long *)&_prpcmsg->Buffer += 3;
    *(unsigned long *)&_prpcmsg->Buffer &= 0xfffffffc;
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    MIDL_user_free((void  *)(pwsz));
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
void __RPC_STUB IRawRpc_GuidIn(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  GUID guid;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  RpcTryExcept
    {
    _gns__GUID ((GUID *)&guid, (PRPC_MESSAGE)_prpcmsg);
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  if (_prpcmsg->ManagerEpv)
    {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->GuidIn(hRpc, guid);
    }
  else
    {
	_ret_value = GuidIn(hRpc, guid);
    }
  _prpcmsg->BufferLength = 4;
  _prpcmsg->Buffer = _packet;
  _status = I_RpcGetBuffer(_prpcmsg);
  if (_status) RpcRaiseException(_status);
  _packet = (unsigned char 
*)_prpcmsg->Buffer;  /* send data from _ret_value */
  *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
  _prpcmsg->Buffer = _packet;
  }
void __RPC_STUB IRawRpc_GuidOut(
	PRPC_MESSAGE _prpcmsg)
  {
  SCODE _ret_value;
  handle_t hRpc = _prpcmsg->Handle;
  GUID pguid;
  unsigned long _alloc_total;
  unsigned char * _packet;
  unsigned int    _length;
  unsigned char * _tempbuf;
  unsigned char * _savebuf;
  RPC_STATUS _status;
  _packet = _prpcmsg->Buffer;
  ((void)( _alloc_total ));
  ((void)( _packet ));
  ((void)( _tempbuf ));
  ((void)( _savebuf ));
  ((void)( _length ));
  RpcTryExcept
    {
    }
  RpcExcept(1)
    {
        RpcRaiseException(RpcExceptionCode());
    }
  RpcEndExcept
  if (((unsigned int)(((unsigned char *)_prpcmsg->Buffer) - _packet)) > _prpcmsg->BufferLength)
  RpcRaiseException(RPC_X_BAD_STUB_DATA);
  RpcTryFinally
    {
    if (_prpcmsg->ManagerEpv)
      {
	_ret_value = ((IRawRpc_SERVER_EPV *)(_prpcmsg->ManagerEpv))->GuidOut(hRpc, &pguid);
      }
    else
      {
	_ret_value = GuidOut(hRpc, &pguid);
      }
    _prpcmsg->BufferLength = 20;
    _prpcmsg->Buffer = _packet;
    _status = I_RpcGetBuffer(_prpcmsg);
    if (_status) RpcRaiseException(_status);
    _packet = (unsigned char 
*)_prpcmsg->Buffer;    _length = _prpcmsg->BufferLength;
    _prpcmsg->BufferLength = 0;
    /* send data from &pguid */
    NDRcopy (_prpcmsg->Buffer, (void __RPC_FAR *) (&pguid), (unsigned int)(16));
    *(unsigned long *)&_prpcmsg->Buffer += 16;
    /* send data from _ret_value */
    *(*(long **)&_prpcmsg->Buffer)++ = (long)_ret_value;
    }
  RpcFinally
    {
    }
  RpcEndFinally
  _prpcmsg->Buffer = _packet;
  _prpcmsg->BufferLength = _length;
  }
static RPC_DISPATCH_FUNCTION IRawRpc_table[] =
  {
  IRawRpc_Quit,
  IRawRpc_Void,
  IRawRpc_VoidRC,
  IRawRpc_VoidPtrIn,
  IRawRpc_VoidPtrOut,
  IRawRpc_DwordIn,
  IRawRpc_DwordOut,
  IRawRpc_DwordInOut,
  IRawRpc_LiIn,
  IRawRpc_LiOut,
  IRawRpc_ULiIn,
  IRawRpc_ULiOut,
  IRawRpc_StringIn,
  IRawRpc_StringOut,
  IRawRpc_StringInOut,
  IRawRpc_GuidIn,
  IRawRpc_GuidOut,
  0
  }
;
RPC_DISPATCH_TABLE IRawRpc_DispatchTable =
  {
  17,
  IRawRpc_table
  }
;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server1\csrvapp.cxx ===
//+-------------------------------------------------------------------
//  File:       csrvapp.cxx
//
//  Contents:   Implementation of CTestServerApp
//
//  Classes:    CTestServerApp
//
//  History:    17-Dec-92   DeanE   Created
//              31-Dec-93   ErikGav Chicago port
//              25-Apr-95   BruceMa CoRevokeClassObject before shutting down
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"
#include <except.hxx>

void ProcessCmdLine(LPSTR, BOOL *);

// Used to send a quit message
extern HWND g_hwndMain;


//+--------------------------------------------------------------
//  Function:   CTestServerApp::CTestServerApp
//
//  Synopsis:   Constructor - initialize members
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
CTestServerApp::CTestServerApp()
{
    _pteClassFactory = NULL;
    _dwRegId         = 0;
    _fRegistered     = FALSE;
    _fInitialized    = FALSE;
    _fEmbedded	     = TRUE;
    _cEmbeddedObjs   = 0;
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::~CTestServerApp
//
//  Synopsis:   Insure pointers are free - note this is mainly for
//              error-checking.
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
CTestServerApp::~CTestServerApp()
{
    Win4Assert(_pteClassFactory == NULL &&
               "Class factory should have been released");
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::InitApp
//
//  Synopsis:   Initialize this instance of the app.
//
//  Parameters: [lpszCmdline] - Command line of the application.
//
//  Returns:    S_OK if everything was initialized, or an error if not.
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      If this does not return, the CloseApp method should
//              still be called for proper cleanup.
//---------------------------------------------------------------
SCODE CTestServerApp::InitApp(LPSTR lpszCmdline)
{
    SCODE sc;

    // Check OLE version running
    // BUGBUG - NYI by OLE
    //   Bail out if we are not running with an acceptable version of OLE

    // Process Command Line arguments
    ProcessCmdLine(lpszCmdline, &_fEmbedded);

    // Look up the thread mode from the win.ini file.
    DWORD thread_mode;
    TCHAR buffer[80];
    int len;

    len = GetProfileString( TEXT("TestSrv"),
                            TEXT("ThreadMode"),
                            TEXT("MultiThreaded"),
                            buffer,
			    sizeof(buffer) / sizeof(TCHAR));

    if (lstrcmp(buffer, TEXT("ApartmentThreaded")) == 0)
    {
	thread_mode = COINIT_APARTMENTTHREADED;
	sc = CoInitialize(NULL);
    }
    else
    {
#ifdef MULTI_THREADING
	thread_mode = COINIT_MULTITHREADED;
	sc = CoInitializeEx(NULL, thread_mode);
#else
	// multi-threading not supported
	sc = E_INVALIDARG;
#endif
    }

    if (S_OK == sc)
    {
        _fInitialized = TRUE;
    }
    else
    {
        return(sc);
    }

    // Create the applications class factory - note that we have to free
    //   at a later time
    _pteClassFactory = CTestEmbedCF::Create(this);
    if (NULL == _pteClassFactory)
    {
        return(E_ABORT);
    }

    // Register the class with OLE
    sc = CoRegisterClassObject(
           CLSID_TestEmbed,
           _pteClassFactory,
           CLSCTX_LOCAL_SERVER,
	   REGCLS_MULTIPLEUSE,
           &_dwRegId);
    if (S_OK == sc)
    {
        _fRegistered = TRUE;
    }

    return(sc);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::CloseApp
//
//  Synopsis:   Clean up resources this instance of the app is using.
//
//  Parameters: None
//
//  Returns:    S_OK if everything was cleaned up, or an error if not.
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
SCODE CTestServerApp::CloseApp()
{
    // Release this apps class factory, and insure the returned count is 0
    if (NULL != _pteClassFactory)
    {
        if (0 == _pteClassFactory->Release())
        {
            _pteClassFactory = NULL;
        }
        else
        {
            // BUGBUG - Log error
        }
    }

    // Uninitialize OLE only if OleInitialize succeeded
    if (TRUE == _fInitialized)
    {
	CoUninitialize();
    }
    return(S_OK);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::GetEmbeddedFlag
//
//  Synopsis:   Returns TRUE if app was started for an embedded object,
//              FALSE if standalone.
//
//  Parameters: None
//
//  Returns:    BOOL (_fEmbedded)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
CTestServerApp::GetEmbeddedFlag()
{
    return(_fEmbedded);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::IncEmbeddedCount
//
//  Synopsis:   Increments the count of embedded objects the server
//              has open.
//
//  Parameters: None
//
//  Returns:    ULONG (_cEmbeddedObjs)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
ULONG CTestServerApp::IncEmbeddedCount()
{
    return(++_cEmbeddedObjs);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::DecEmbeddedCount
//
//  Synopsis:   Decrements the count of embedded objects the server
//              has open.  If 0 are left and we were running for an
//              embedded object(s), shut down.
//
//  Parameters: None
//
//  Returns:    ULONG (_cEmbeddedObjs)
//
//  History:    17-Dec-92   DeanE   Created
//
//---------------------------------------------------------------
ULONG CTestServerApp::DecEmbeddedCount()
{
    if ((0 == --_cEmbeddedObjs) && _fEmbedded)
    {
        // Revoke the class object, if registered
        if (TRUE == _fRegistered)
        {
            CoRevokeClassObject(_dwRegId);
//            OutputDebugStringA("Revoking class object now!\n");
        }

        // Shut down the app
	SendMessage(g_hwndMain, WM_USER, 0xFFFFFFFF, 0xFFFFFFFF);
    }

    return(_cEmbeddedObjs);
}


//+--------------------------------------------------------------
// Function:    ProcessCmdline
//
// Synopsis:    Checks the cmd line parameters, in particular for
//              '/Embedding' or '-Embedding'.
//
// Parameters:  [lpszCmdLine] - Command line buffer.
//              [pfEmbedded]  - Flag should be set to true if we get
//                              the '/Embedding' switch.
//
// Returns:     void
//
// History:	25-Nov-92   DeanE   Created
//
// Notes:	Only two valid commandlines for this program:
//		(1) -Embedding when started by OLE or (2) Null
//		string if started from the command line.
//---------------------------------------------------------------
void ProcessCmdLine(LPSTR lpszCmdline, BOOL *pfEmbedded)
{
    if (lpszCmdline[0] == 0)
    {
	*pfEmbedded = FALSE;
	return;
    }

    if (strcmp(lpszCmdline, "-Embedding") == 0)
    {
	*pfEmbedded = TRUE;
	return;
    }

    Win4Assert(!"testsrv received an invalid command line!");
    *pfEmbedded = FALSE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server1\ipersist.cxx ===
//+-------------------------------------------------------------------
//  File:       ipersist.cxx
//
//  Contents:   IPersist and IPersistStorage methods of CPersistStorage class.
//
//  Classes:    CPersistStorage - IPersist, IPersistStorage implementations
//
//  History:    7-Dec-92   DeanE   Created
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"


//+-------------------------------------------------------------------
//  Member:     CPersistStorage::CPersistStorage()
//
//  Synopsis:   The constructor for CPersistStorage.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CPersistStorage::CPersistStorage(CTestEmbed *pteObject)
{
    _cRef      = 1;
    _pteObject = pteObject;
    _fDirty    = FALSE;
}


//+-------------------------------------------------------------------
//  Member:     CPersistStorage::~CPersistStorage()
//
//  Synopsis:   The destructor for CPersistStorage.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CPersistStorage::~CPersistStorage()
{
    // _cRef should be 1
    if (1 != _cRef)
    {
        // BUGBUG - Log error, someone hasn't released
    }
    return;
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::QueryInterface
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::QueryInterface(REFIID iid, void FAR * FAR *ppv)
{
    return(_pteObject->QueryInterface(iid, ppv));
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::AddRef
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPersistStorage::AddRef(void)
{
    ++_cRef;
    return(_pteObject->AddRef());
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::Release
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPersistStorage::Release(void)
{
    --_cRef;
    return(_pteObject->Release());
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::GetClassId
//
//  Synopsis:   See spec 2.00.09 p197.  Answer the Class ID of this
//              object.
//
//  Parameters: [pClassId] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::GetClassID(LPCLSID pClassId)
{
    if (NULL != pClassId)
    {
        *pClassId = CLSID_TestEmbed;
    }
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::IsDirty
//
//  Synopsis:   See spec 2.00.09 p200.  Return S_OK if the object needs
//              to be saved in order to avoid data loss, or S_FALSE
//              if not.
//
//  Parameters: None
//
//  Returns:    S_OK or S_FALSE
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::IsDirty()
{
    // BUGBUG - NYI
    //   Because we are NYI, just return S_FALSE
    return(S_FALSE);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::InitNew
//
//  Synopsis:   See spec 2.00.09 p197.  This method provides a way
//              for a container to provide persistent storage to this
//              object.  Call AddRef on the pStg passed if we do save
//              it.
//
//  Parameters: [pStg] - IStorage instance this object can use.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::InitNew(LPSTORAGE pStg)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::Load
//
//  Synopsis:   See spec 2.00.09 p200.  Called by handler to put this
//              object into the running state.  Object should use the
//              pStg passed to "initialize" itself.  We can hold onto
//              this pStg, but when ::Save is called, this can be
//              a different IStorage.
//
//  Parameters: [pStg] - IStorage to initialize object from.
//
//  Returns:    S_OK?
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::Load(LPSTORAGE pStg)
{
    // BUGBUG - NYI
    //   Initialize the object here, though, just as if we had obtained
    //   data from an IStorage
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::Save
//
//  Synopsis:   See spec 2.00.09 p197.  Save the data in the IStorage
//              passed.  Ignore flags for now.
//
//  Parameters: [pStgSave]    - Save data in here.
//              [fSameAsLoad] - Indicates this object is the same one
//                              that was initially started.
//              [fRemember]   - Only matters if fSameAsLoad is FALSE.
//
//  Returns:    STG_E_MEDIUMFULL - why???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::Save(
        LPSTORAGE pStgSave,
	BOOL	  fSameAsLoad)
{
    // BUGBUG - NYI
    return(STG_E_MEDIUMFULL);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::SaveCompleted
//
//  Synopsis:   See spec 2.00.09 p198.  Used only in certain circumstances.
//
//  Parameters: [pStgSaved] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::SaveCompleted(LPSTORAGE pStgSaved)
{
    // BUGBUG - NYI
    //   We don't have to worry about this unless we allow a "Save As"
    //   operation
    return(S_OK);
}



//+-------------------------------------------------------------------
//  Method:	CPersistStorage::HandsOffStorage
//
//  Synopsis:   See spec 2.00.09 p198.  Used only in certain circumstances.
//
//  Parameters: [pStgSaved] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::HandsOffStorage(void)
{
    // BUGBUG - NYI
    //   We don't have to worry about this unless we allow a "Save As"
    //   operation
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\rot\rotut.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	rotut.cxx
//
//  Contents:	Unit Test for ROT
//
//  Classes:	MISSING
//
//  Functions:	MISSING
//
//  History:	16-Oct-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <windows.h>
#include    <widewrap.h>    // For chicago build
#include    <ole2.h>
#include    <stdio.h>
#include    <safepnt.hxx>
#include    <com.hxx>

#define TEST_FAILED(x, y) \
    if (x) \
    { \
	printf("%s:%d %s\n", __FILE__, __LINE__, y); \
	return TRUE; \
    }

GUID clsidLocal =
    {0xbbbbbbbb,0xbbbb,0xbbbb,{0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb}};

CHAR szTmpCurrrentDirectory[MAX_PATH];
WCHAR szCurrentDirectory[MAX_PATH];


SAFE_INTERFACE_PTR(CSafeROT, IRunningObjectTable)
SAFE_INTERFACE_PTR(CSafeUnk, IUnknown)
SAFE_INTERFACE_PTR(CSafePersist, IPersist)
SAFE_INTERFACE_PTR(CSafeEnumMoniker, IEnumMoniker)
SAFE_INTERFACE_PTR(CSafeMoniker, IMoniker)
SAFE_INTERFACE_PTR(CSafeStorage, IStorage)

class COleInit
{
public:
			COleInit(HRESULT& hr);

			~COleInit(void);
private:

    // No private data
};

inline COleInit::COleInit(HRESULT& hr)
{
    hr = OleInitialize(NULL);
}

inline COleInit::~COleInit(void)
{
    // Do the clean up
    OleUninitialize();
}



class CRotTestObject : public IPersist
{
public:
			CRotTestObject(WCHAR *pwszID);

    // IUnknown Interface
    STDMETHODIMP	QueryInterface(REFIID riid, void **ppv);

    STDMETHODIMP_(ULONG)AddRef(void);

    STDMETHODIMP_(ULONG)Release(void);

    STDMETHODIMP	GetClassID(LPCLSID pclsid);

private:

    WCHAR		_awcID[256];

    ULONG		_cRefs;

};




CRotTestObject::CRotTestObject(WCHAR *pwszID) : _cRefs(1)
{
    wcscpy(_awcID, pwszID);
}




STDMETHODIMP CRotTestObject::QueryInterface(REFIID riid, void **ppv)
{
    if ((memcmp((void *) &riid, (void *) &IID_IUnknown, sizeof(GUID)) == 0)
	|| (memcmp((void *) &riid, (void *) &IID_IPersist, sizeof(GUID)) == 0))
    {
	_cRefs++;
	*ppv = (IUnknown *) this;
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}



STDMETHODIMP_(ULONG) CRotTestObject::AddRef(void)
{
    _cRefs++;
    return (ULONG) _awcID;
}



STDMETHODIMP_(ULONG) CRotTestObject::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
    }

    return _cRefs;
}



STDMETHODIMP CRotTestObject::GetClassID(LPCLSID pclsid)
{
    memcpy(pclsid, &clsidLocal, sizeof(clsidLocal));
    return S_OK;
}






BOOL VerifyRegistration(
    IMoniker *pmk,
    REFCLSID clsidExpected,
    FILETIME *pFileTimeExpected)
{
    CSafeROT prot;

    HRESULT hr = GetRunningObjectTable(0, &prot);

    TEST_FAILED(FAILED(hr),
	"VerifyRegistration:GetRunningObjectTable failed!\n")

    // Verify the object is running
    hr = prot->IsRunning(pmk);

    TEST_FAILED((hr != S_OK),
	"VerifyRegistration:Unexpected return from IsRunning\n")

    // Test Get Object
    CSafeUnk punk;

    hr = prot->GetObject(pmk, &punk);

    TEST_FAILED((hr != S_OK),
	"VerifyRegistration:Unexpected from GetObject\n")

    // Confirm object class
    CSafePersist prst;

    hr = punk->QueryInterface(IID_IPersist, (void **) &prst);

    TEST_FAILED((hr != S_OK),
	"VerifyRegistration:QI to IPersist failed\n")

    CLSID clsid;

    hr = prst->GetClassID(&clsid);

    TEST_FAILED((hr != S_OK),
	"VerifyRegistration:GetClassID on IPersist failed\n")

    TEST_FAILED((memcmp(&clsid, &clsidExpected, sizeof(clsid)) != 0),
	"VerifyRegistration:GetClassID mismatch with expected\n")

    // Test get the time
    FILETIME filetime;

    hr = prot->GetTimeOfLastChange(pmk, &filetime);

    TEST_FAILED((hr != S_OK), "VerifyRegistration:GetTimeOfLastChange Failed\n")

    TEST_FAILED((memcmp(&filetime, pFileTimeExpected, sizeof(filetime)) != 0),
	"VerifyRegistration:GetTimeOfLastChange != NoteChangeTime value")

    // Enumerate all the running monikers
    CSafeEnumMoniker penummk;

    hr = prot->EnumRunning(&penummk);

    TEST_FAILED(FAILED(hr), "VerifyRegistration:EnumRunning Failed\n")

    // Cycle through running object table
    BOOL fFound = FALSE;
    IMoniker *pmkTable;
    int cIdx = 0;
    int cOurMoniker;

    while (SUCCEEDED(hr = penummk->Next(1, &pmkTable, NULL))
	&& (hr != S_FALSE))
    {
	if (pmk->IsEqual(pmkTable) == S_OK)
	{
	    fFound = TRUE;
	    cOurMoniker = cIdx;
	    pmkTable->Release();
	    break;
	}

	pmkTable->Release();

	cIdx++;
    }

    TEST_FAILED(FAILED(hr),
	"VerifyRegistration:ROT Moniker Enumeration ended in failure")

    TEST_FAILED((!fFound),
	"VerifyRegistration:Did not find our moniker in the table");

    // Reset the pointer
    hr = penummk->Reset();

    TEST_FAILED(FAILED(hr),
	"VerifyRegistration:ROT IEnumMoniker::Reset Failed");

    // Skip to our moniker
    hr = penummk->Skip(cOurMoniker);

    TEST_FAILED(FAILED(hr),
	"VerifyRegistration:ROT IEnumMoniker::Skip Failed");

    // Read it from the enumerator
    hr = penummk->Next(1, &pmkTable, NULL);

    TEST_FAILED(FAILED(hr),
	"VerifyRegistration:ROT IEnumMoniker::Next Failed");

    TEST_FAILED((pmk->IsEqual(pmkTable) != S_OK),
	"VerifyRegistration:ROT IEnumMoniker::Next after skip monikers !=");

    // If we get to here the test passed
    return FALSE;
}



BOOL VerifyNotRunning(IMoniker *pmk)
{
    CSafeROT prot;

    HRESULT hr = GetRunningObjectTable(0, &prot);

    TEST_FAILED(FAILED(hr), "GetRunningObjectTable failed!\n")

    // Check result from IsRunning
    hr = prot->IsRunning(pmk);

    TEST_FAILED((hr != S_FALSE),
	"Unexpected return from IsRunning\n")

    // Test Get Object
    CSafeUnk punk;

    hr = prot->GetObject(pmk, &punk);

    TEST_FAILED((hr != MK_E_UNAVAILABLE), "Unexpected from GetObject\n")

    // Test get the time
    FILETIME filetime2;

    hr = prot->GetTimeOfLastChange(pmk, &filetime2);

    TEST_FAILED((hr != MK_E_UNAVAILABLE), "GetTimeOfLastChange Failed\n")

    // Enumerate all the running monikers
    CSafeEnumMoniker penummk;

    hr = prot->EnumRunning(&penummk);

    TEST_FAILED(FAILED(hr), "EnumRunning Failed\n")

    // Cycle through running object table
    BOOL fFound = FALSE;
    IMoniker *pmkTable;

    while (SUCCEEDED(hr = penummk->Next(1, &pmkTable, NULL))
	&& (hr != S_FALSE))
    {
	if (pmk->IsEqual(pmkTable) == S_OK)
	{
	    pmkTable->Release();
	    fFound = TRUE;
	    break;
	}

	pmkTable->Release();
    }

    TEST_FAILED(FAILED(hr), "ROT Moniker Enumeration ended in failure")

    TEST_FAILED((fFound), "Found our non-running moniker in the table");

    // If we get to here the test passed
    return FALSE;

}



BOOL TestInvalidParameters(void)
{
    CSafeROT prot;

    HRESULT hr = GetRunningObjectTable(0, &prot);

    // Test set the time
    FILETIME filetime;
    memset(&filetime, 'A', sizeof(filetime));

    // Test with invalid pointer
    hr = prot->Revoke(0xFFFFFFFF);

    TEST_FAILED((hr != E_INVALIDARG),
	"WrongResult from Revoke Invalid Address");

    hr = prot->NoteChangeTime(0xFFFFFFFF, &filetime);

    TEST_FAILED((hr != E_INVALIDARG),
	"WrongResult from NoteChangeTime Invalid Address");

    // Test with valid pointer but invalid data
    DWORD dwValidAddress[30];

    hr = prot->Revoke((DWORD) dwValidAddress);

    TEST_FAILED((hr != E_INVALIDARG),
	"WrongResult from Revoke Invalid Data");

    hr = prot->NoteChangeTime((DWORD) dwValidAddress, &filetime);

    TEST_FAILED((hr != E_INVALIDARG),
	"WrongResult from NoteChangeTime Invalid Data");

    return FALSE;
}


BOOL TestLocalROT(void)
{
    CSafeMoniker pmk2;
    CSafeROT prot;

    HRESULT hr = GetRunningObjectTable(0, &prot);

    TEST_FAILED(FAILED(hr), "GetRunningObjectTable failed!\n")

    // Make sure that we can do something on the pointer that
    // we got back.
    prot->AddRef();
    prot->Release();

    // Create an IUnknown pointer for the class.
    CSafeUnk punk;
    punk.Attach(new CRotTestObject(L"First Test Object"));

    hr = CreateItemMoniker(L"\\", L"Bob", &pmk2);

    TEST_FAILED(FAILED(hr), "CreateItemMoniker for \\Bob failed\n")

    // Make sure new object is not running
    TEST_FAILED(VerifyNotRunning(pmk2), "TestLocalROT:Object Already running\n")

    // Cookie for deregistering object
    DWORD dwRegister;

    hr = prot->Register(0, punk, pmk2, &dwRegister);

    TEST_FAILED(FAILED(hr), "TestLocalROT:Register in ROT for \\Bob failed\n")

    // Test set the time
    FILETIME filetime;

    memset(&filetime, 'A', sizeof(filetime));

    hr = prot->NoteChangeTime(dwRegister, &filetime);

    TEST_FAILED((hr != S_OK), "TestLocalROT:NoteChangeTime Failed\n")

    // Verify that this is running
    TEST_FAILED(VerifyRegistration(pmk2, clsidLocal, &filetime),
	"TestLocalROT: Registration failed\n");

    // Revoke registration
    hr = prot->Revoke(dwRegister);

    TEST_FAILED((hr != S_OK), "TestLocalROT:Revoke failed\n");

    // Verify no longer registered
    TEST_FAILED(VerifyNotRunning(pmk2),
	"TestLocalROT:VerifyNotRunning failed\n")

    // If we get to here the test passed
    return FALSE;
}



void CreatePath(int iId, WCHAR *pwszPath)
{
    wsprintf(pwszPath, L"%s\\%s%ld", szCurrentDirectory, L"ROTUT", iId);
}


BOOL CreateObjectAndBind(WCHAR *pwszPath, IUnknown **ppunk)
{
    HRESULT hr;

    // create a storage for the object
    {
	CSafeStorage pstg;

	hr = StgCreateDocfile(pwszPath,
	    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, &pstg);

	TEST_FAILED(FAILED(hr), "CreateObjectAndBind:StgCreateDocfile failed")

	// Write the class id to the storage
	hr = pstg->SetClass(CLSID_AdvBnd);
    }

    TEST_FAILED(FAILED(hr), "CreateObjectAndBind IStorage::SetClass Failed")

    // Bind to the path
    CSafeMoniker pmk;

    hr = CreateFileMoniker(pwszPath, &pmk);

    TEST_FAILED(FAILED(hr), "CreateObjectAndBind:CreateFileMoniker failed")

    hr = BindMoniker(pmk, 0, IID_IUnknown, (void **) ppunk);

    TEST_FAILED(FAILED(hr), "CreateObjectAndBind:BindMoniker failed")

    // Test set the time
    FILETIME filetime;

    memset(&filetime, 'B', sizeof(filetime));

    // Verify that it is running
    TEST_FAILED(VerifyRegistration(pmk, CLSID_AdvBnd, &filetime),
	"CreateObjectAndBind: Registration failed\n");

    return FALSE;
}



BOOL RemoteROT(void)
{
    // Create an object of the class
    WCHAR szPath[MAX_PATH];

    CreatePath(0, szPath);

    CSafeUnk punk;

    // Bind to the object
    if (CreateObjectAndBind(szPath, &punk))
    {
	printf("RemoteRot: Failed on CreateObjectAndBind\n");
	return TRUE;
    }

    // Release object
    punk->Release();
    punk.Detach();

    // Bind to the path
    CSafeMoniker pmk;

    HRESULT hr = CreateFileMoniker(szPath, &pmk);

    TEST_FAILED(FAILED(hr), "RemoteROT:CreateFileMoniker failed")

    // Verify that it is freed
    TEST_FAILED(VerifyNotRunning(pmk),
	"RemoteROT:VerifyNotRunning failed\n")

    DeleteFile(szPath);

    return FALSE;
}


#define MAX_TO_TEST 100
IUnknown *apunk[MAX_TO_TEST];



BOOL TestManyRegistrations(void)
{
    // Create an object of the class
    WCHAR szPath[MAX_PATH];

    for (int i = 0; i < MAX_TO_TEST; i++)
    {
	// Create name of bound object
	CreatePath(i, szPath);

	// Create object
	printf("Many create %ld\n", i);

	if (CreateObjectAndBind(szPath, &apunk[i]))
	{
	    printf("TestManyRegistrations failed on %ld\n", i);
	    return TRUE;
	}
    }

    for (i = 0; i < MAX_TO_TEST; i++)
    {
	printf("Many Release %ld\n", i);

	// Create name of bound object
	CreatePath(i, szPath);

	// Bind to the path
	CSafeMoniker pmk;

	HRESULT hr = CreateFileMoniker(szPath, &pmk);

	TEST_FAILED(FAILED(hr),
	    "TestManyRegistrations:CreateFileMoniker failed")

	// Release object
	apunk[i]->Release();

	// Verify object is not running
	if (VerifyNotRunning(pmk))
	{
	    printf("TestManyRegistrations:VerifyNotRunning failed on %ld\n", i);
	    return TRUE;
	}

	DeleteFile(szPath);
    }

    return FALSE;
}



int _cdecl main(int argc, TCHAR **argv)
{
    // Get the current directory
    int len = GetCurrentDirectoryA(sizeof(szTmpCurrrentDirectory),
	szTmpCurrrentDirectory);

    // Convert to UNICODE
    mbstowcs(szCurrentDirectory, szTmpCurrrentDirectory, len + 1);

    // Result of test - TRUE == passed
    BOOL fTest = FALSE;

    // Initialize Ole
    HRESULT hr;

    COleInit oleinit(hr);

    if (FAILED(hr))
    {
	printf("OleInitialize Failed\n");
	return -1;
    }

    // Test Invalidad Parameters and Local ROT
    if (!TestInvalidParameters() && !TestLocalROT())
    {
	// Test Remote Registration for object
	if (!RemoteROT())
	{
	    // Test Large Registration
	    if (!TestManyRegistrations())
	    {
		fTest = TRUE;
	    }
	}
    }

    if (fTest)
    {
	printf("Test Passed\n");
    }
    else
    {
	printf("Test FAILED!!!\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server1\ctestemb.cxx ===
//+-------------------------------------------------------------------
//  File:       ctestemb.cxx
//
//  Contents:   CTestEmbed class implementation.
//
//  Classes:    CTestEmbed
//
//  History:    7-Dec-92   DeanE   Created
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"



//+-------------------------------------------------------------------
//  Method:     CTestEmbed::CTestEmbed
//
//  Synopsis:   Constructor for CTestEmbed objects
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbed::CTestEmbed() : _cRef(1)
{
    _ptsaServer  = NULL;
    _pDataObject = NULL;
    _pOleObject  = NULL;
    _pPersStg    = NULL;
    _hwnd	 = NULL;
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbed::~CTestEmbed
//
//  Synopsis:   Performs cleanup for CTestEmbed objects by releasing
//              internal pointers.
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbed::~CTestEmbed()
{
    // Inform controlling server app this object is gone
    _ptsaServer->DecEmbeddedCount();

    // Delete all of this objects interface classes
    delete _pDataObject;
    delete _pOleObject;
    delete _pPersStg;
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbed::InitObject
//
//  Synopsis:   Initialize this CTestEmbed object - ie, set everything
//              up for actual use.
//
//  Parameters: None
//
//  Returns:    S_OK if everything is okay to use, or an error code
//
//  History:    7-Dec-92   DeanE   Created
//
//  Notes:      The state of the object must be cleaned up in case of
//              failure - so the destructor will not blow up.
//--------------------------------------------------------------------
SCODE CTestEmbed::InitObject(CTestServerApp *ptsaServer, HWND hwnd)
{
    SCODE sc = S_OK;

    // Initialize controlling server app
    if (NULL != ptsaServer)
    {
        _ptsaServer = ptsaServer;
    }
    else
    {
        sc = E_ABORT;
    }

    // Initilize this objects window handle
    _hwnd = hwnd;

    // Create a CDataObject
    if (SUCCEEDED(sc))
    {
        _pDataObject = new CDataObject(this);
        if (NULL == _pDataObject)
        {
            sc = E_ABORT;
        }
    }

    // Create a COleObject
    if (SUCCEEDED(sc))
    {
        _pOleObject = new COleObject(this);
        if (NULL == _pOleObject)
        {
            sc = E_ABORT;
        }
    }

    // Create a CPersistStorage
    if (SUCCEEDED(sc))
    {
        _pPersStg = new CPersistStorage(this);
        if (NULL == _pPersStg)
        {
            sc = E_ABORT;
        }
    }

    if (FAILED(sc))
    {
        delete _pDataObject;
        delete _pOleObject;
        delete _pPersStg;
        _pDataObject = NULL;
        _pOleObject  = NULL;
        _pPersStg    = NULL;
        _ptsaServer  = NULL;
        _hwnd        = NULL;
    }

    // Inform controlling server we are a new embedded object
    if (SUCCEEDED(sc))
    {
        _ptsaServer->IncEmbeddedCount();
    }

    return(sc);
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbed::QueryInterface
//
//  Synopsis:   IUnknown, IOleObject, IPersist, IPersistStorage supported
//              return pointer to the actual object
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbed::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    SCODE scRet;

    if (GuidEqual(IID_IUnknown, iid))
    {
        *ppv = (IUnknown *)this;
	AddRef();
        scRet = S_OK;
    }
    else
    if (GuidEqual(IID_IOleObject, iid))
    {
        *ppv = _pOleObject;
	AddRef();
        scRet = S_OK;
    }
    else
    if (GuidEqual(IID_IPersist, iid) || GuidEqual(IID_IPersistStorage, iid))
    {
        *ppv = _pPersStg;
	AddRef();
        scRet = S_OK;
    }
    else
    if (GuidEqual(IID_IDataObject, iid))
    {
        *ppv = _pDataObject;
	AddRef();
        scRet = S_OK;
    }
    else
    {
        *ppv  = NULL;
        scRet = E_NOINTERFACE;
    }

    return(scRet);
}


STDMETHODIMP_(ULONG) CTestEmbed::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CTestEmbed::Release(void)
{
    ULONG cRefs = --_cRef;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}
SCODE CTestEmbed::GetWindow(HWND *phwnd)
{
    if (NULL != phwnd)
    {
        *phwnd = _hwnd;
        return(S_OK);
    }
    else
    {
        return(E_ABORT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server2\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	headers.cxx
//
//  Contents:	class precompiled headers
//
//  Classes:	
//
//  Functions:	
//
//  History:	24-Aug-93	PhilipLa	Created
//
//----------------------------------------------------------------------------
#include    <headers.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server2\wterm.h ===
#ifndef __WTERM__
#define __WTERM__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Message to print a line on the window
#define WM_PRINT_LINE (WM_USER + 1)

// Message to print a character on the window
#define WM_PUTC (WM_USER + 2)

// Message used to terminate this window
#define WM_TERM_WND (WM_USER + 3)

//
//  Typedefs for call back functions for the window
//
typedef long (*MFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);
typedef long (*CFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);
typedef long (*TFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);

// Register the terminal window class
BOOL TermRegisterClass(
    HANDLE hInstance,
    LPTSTR MenuName,
    LPTSTR ClassName,
    LPTSTR ICON);

// Create a window for the terminal
BOOL
TermCreateWindow(
    LPTSTR lpClassName,
    LPTSTR lpWindowName,
    HMENU hMenu,
    MFUNCP MenuProc,
    CFUNCP CharProc,
    TFUNCP CloseProc,
    int nCmdShow,
    HWND *phNewWindow,
    void *pvCallBackData);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __WTERM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server2\olesrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:       oleimpl.cxx
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      DllGetClassObject (Bindings key func)
//			CAdvBndCF (class factory)
//			CAdvBnd   (actual class implementation)
//
//  Classes:	CAdvBndCF, CAdvBnd
//
//
//  History:	30-Nov-92      SarahJ      Created
//              31-Dec-93      ErikGav     Chicago port
//---------------------------------------------------------------------

// Turn off ole Cairol IUnknown
#include    "headers.cxx"
#pragma hdrstop
#include    <stdio.h>
#include    <stdarg.h>
#include    "wterm.h"


#define IDM_DEBUG 0x100

static const TCHAR *szAppName = TEXT("Test OLE Server");
static const char *szFatalError = "OLESRV - Fatal Error";

void MsgBox(char *pszMsg)
{
    MessageBoxA(NULL, pszMsg, szFatalError, MB_OK);
}

void HrMsgBox(char *pszMsg, HRESULT hr)
{
    char awcBuf[512];

    // Build string for output
    wsprintfA(awcBuf, "%s HRESULT = %lx", pszMsg, hr);

    // Display message box
    MessageBoxA(NULL, &awcBuf[0], szFatalError, MB_OK);
}

//+-------------------------------------------------------------------
//  Class:    CTestServerApp
//
//  Synopsis: Class that holds application-wide data and methods
//
//  Methods:  InitApp
//            CloseApp
//            GetEmbeddedFlag
//
//  History:  17-Dec-92     DeanE   Created
//--------------------------------------------------------------------
class FAR CTestServerApp
{
public:

// Constructor/Destructor
    CTestServerApp();
    ~CTestServerApp();

    SCODE InitApp         (LPSTR lpszCmdline);
    SCODE CloseApp        (void);
    BOOL  GetEmbeddedFlag (void);
    ULONG IncEmbeddedCount(void);
    ULONG DecEmbeddedCount(void);

private:
    IClassFactory *_pteClassFactory;
    ULONG          _cEmbeddedObjs;  // Count of embedded objects this server
                                    // is controlling now
    DWORD          _dwRegId;        // OLE registration ID
    BOOL           _fRegistered;    // TRUE if srv was registered w/OLE
    BOOL           _fEmbedded;      // TRUE if OLE started us at the request
                                    //   of an embedded obj in a container app
};

CTestServerApp tsaMain;
HWND g_hMain;

void ProcessCmdLine(LPSTR, BOOL *);

//+--------------------------------------------------------------
//  Function:   CTestServerApp::CTestServerApp
//
//  Synopsis:   Constructor - initialize members
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
CTestServerApp::CTestServerApp()
{
    _pteClassFactory = NULL;
    _dwRegId         = 0;
    _fRegistered     = FALSE;
    _fEmbedded	     = TRUE;
    _cEmbeddedObjs   = 0;
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::~CTestServerApp
//
//  Synopsis:   Insure pointers are free - note this is mainly for
//              error-checking.
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
CTestServerApp::~CTestServerApp()
{
    Win4Assert(_pteClassFactory == NULL &&
               "Class factory should have been released");
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::InitApp
//
//  Synopsis:   Initialize this instance of the app.
//
//  Parameters: [lpszCmdline] - Command line of the application.
//
//  Returns:    S_OK if everything was initialized, or an error if not.
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      If this does not return, the CloseApp method should
//              still be called for proper cleanup.
//---------------------------------------------------------------
SCODE CTestServerApp::InitApp(LPSTR lpszCmdline)
{
    SCODE sc;

    // Check OLE version running
    // BUGBUG - NYI by OLE
    //   Bail out if we are not running with an acceptable version of OLE

    // Process Command Line arguments
    ProcessCmdLine(lpszCmdline, &_fEmbedded);

    // Create the applications class factory - note that we have to free
    //   at a later time
    _pteClassFactory = new CAdvBndCF();

    if (NULL == _pteClassFactory)
    {
        MsgBox("Class Object Creation Failed");
        return(E_ABORT);
    }

    // Register the class with OLE
    sc = CoRegisterClassObject(
           CLSID_AdvBnd,
           _pteClassFactory,
           CLSCTX_LOCAL_SERVER,
	   REGCLS_MULTIPLEUSE,
           &_dwRegId);

    if (S_OK == sc)
    {
        _fRegistered = TRUE;
    }
    else
    {
        HrMsgBox("CoRegisterClassObject FAILED", sc);
    }

    return(sc);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::CloseApp
//
//  Synopsis:   Clean up resources this instance of the app is using.
//
//  Parameters: None
//
//  Returns:    S_OK if everything was cleaned up, or an error if not.
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
SCODE CTestServerApp::CloseApp()
{
    // Revoke the class object, if registered
    if (TRUE == _fRegistered)
    {
        CoRevokeClassObject(_dwRegId);
    }

    // Release this apps class factory, and insure the returned count is 0
    if (NULL != _pteClassFactory)
    {

      // NB: Workaround for ref count problem.

      #define HACK 1
      #if HACK
        _pteClassFactory->Release();
        _pteClassFactory = NULL;
      #else
        if (0 == _pteClassFactory->Release())
        {
            _pteClassFactory = NULL;
        }
        else
        {
            Win4Assert("Release on class factory returned positive ref count");
            // BUGBUG - Log error
        }
      #endif
    }

    return(S_OK);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::GetEmbeddedFlag
//
//  Synopsis:   Returns TRUE if app was started for an embedded object,
//              FALSE if standalone.
//
//  Parameters: None
//
//  Returns:    BOOL (_fEmbedded)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
CTestServerApp::GetEmbeddedFlag()
{
    return(_fEmbedded);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::IncEmbeddedCount
//
//  Synopsis:   Increments the count of embedded objects the server
//              has open.
//
//  Parameters: None
//
//  Returns:    ULONG (_cEmbeddedObjs)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
ULONG CTestServerApp::IncEmbeddedCount()
{
    return(++_cEmbeddedObjs);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::DecEmbeddedCount
//
//  Synopsis:   Decrements the count of embedded objects the server
//              has open.  If 0 are left and we were running for an
//              embedded object(s), shut down.
//
//  Parameters: None
//
//  Returns:    ULONG (_cEmbeddedObjs)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
ULONG CTestServerApp::DecEmbeddedCount()
{
    if ((0 == --_cEmbeddedObjs) && _fEmbedded)
    {
        // We are done so revoke our OLE stuff. We need to do this as
        // soon as we know that we are shutting down so that the window
        // for returning a bad class object is shut.
        CloseApp();

        // Tell window to die
	SendMessage(g_hMain, WM_USER, 0xFFFFFFFF, 0xFFFFFFFF);
    }

    return(_cEmbeddedObjs);
}


//+--------------------------------------------------------------
// Function:    ProcessCmdline
//
// Synopsis:    Checks the cmd line parameters, in particular for
//              '/Embedding' or '-Embedding'.
//
// Parameters:  [lpszCmdLine] - Command line buffer.
//              [pfEmbedded]  - Flag should be set to true if we get
//                              the '/Embedding' switch.
//
// Returns:     void
//
// History:	25-Nov-92   DeanE   Created
//
// Notes:	Only two valid commandlines for this program:
//		(1) -Embedding when started by OLE or (2) Null
//		string if started from the command line.
//---------------------------------------------------------------
void ProcessCmdLine(LPSTR lpszCmdline, BOOL *pfEmbedded)
{
    if (lpszCmdline[0] == 0)
    {
	*pfEmbedded = FALSE;
	return;
    }

    if (strcmp(lpszCmdline, "-Embedding") == 0)
    {
	*pfEmbedded = TRUE;
	return;
    }

    MsgBox("Received an invalid command line!");
    *pfEmbedded = FALSE;

    return;
}

void Display(TCHAR *pszFmt, ...)
{
    va_list marker;
    TCHAR szBuffer[256];

    va_start(marker, pszFmt);

    #ifdef UNICODE
    int iLen = vswprintf(szBuffer, pszFmt, marker);
    #else
    int iLen = vsprintf(szBuffer, pszFmt, marker);
    #endif

    va_end(marker);

    // Display the message on terminal window
    SendMessage(g_hMain, WM_PRINT_LINE, iLen, (LONG) szBuffer);
}




//+-------------------------------------------------------------------------
//
//  Function:	ProcessMenu
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessMenu(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
    void *)
{
    if ((uiMessage == WM_SYSCOMMAND) && (wParam == IDM_DEBUG))
    {
	// Request for a debug breakpoint!
	DebugBreak();
    }


    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}


//+-------------------------------------------------------------------------
//
//  Function:	ProcessChar
//
//  Synopsis:	Gets called when a WM_CHAR message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessChar(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
    void *)
{
    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}


//+-------------------------------------------------------------------------
//
//  Function:	ProcessClose
//
//  Synopsis:	Gets called when a NC_DESTROY message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessClose(
    HWND hWindow,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam,
    void *pvCallBackData)
{
    // Take default action with message
    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    char *lpszCmdLine,
    int nCmdShow)
{
    // For windows message
    MSG msg;
    BOOL bRet;
    HRESULT hr;

    // Register the window class
    bRet = TermRegisterClass(hInstance, NULL, (LPTSTR) szAppName,
	                     (LPTSTR) MAKEINTRESOURCE(IDI_APPLICATION));

    if (!bRet)
    {
        MsgBox("TermRegisterClass FAILED");
        return 1;
    }

    // Create the server window
    bRet = TermCreateWindow(
	(LPTSTR) szAppName,
	(LPTSTR) szAppName,
	NULL,
	ProcessMenu,
	ProcessChar,
	ProcessClose,
	SW_SHOWMINIMIZED,
	&g_hMain,
	NULL);

    if (!bRet)
    {
        MsgBox("TermCreateWindow FAILED");
        return 1;
    }

    // Add debug option to system menu
    HMENU hmenu = GetSystemMenu(g_hMain, FALSE);

    AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hmenu, MF_STRING | MF_ENABLED, IDM_DEBUG, TEXT("Debug"));

    // Look up the thread mode from the win.ini file.
    DWORD thread_mode;
    TCHAR buffer[80];
    int len;

    len = GetProfileString( TEXT("OleSrv"),
                            TEXT("ThreadMode"),
                            TEXT("MultiThreaded"),
                            buffer,
                            sizeof(buffer) / sizeof(TCHAR));

    if (lstrcmp(buffer, TEXT("ApartmentThreaded")) == 0)
    {
	thread_mode = COINIT_APARTMENTTHREADED;
	hr = CoInitialize(NULL);
    }
    else
    {
#ifdef MULTI_THREADING
	thread_mode = COINIT_MULTITHREADED;
	hr = CoInitializeEx(NULL, thread_mode);
#else
	hr = E_INVALIDARG;
#endif
    }

    if (S_OK != hr)
    {
	HrMsgBox("CoInitialize FAILED", hr);
        return(1);
    }


    // Initialize Application
    if (S_OK != tsaMain.InitApp(lpszCmdLine))
    {
        tsaMain.CloseApp();
        return(1);
    }

    if (tsaMain.GetEmbeddedFlag())
    {
        // We're running as an embedded app
        // Don't show the main window unless we're instructed to do so
        // BUGBUG - In-place editing is NYI
	ShowWindow(g_hMain, SW_SHOWMINIMIZED);
    }
    else
    {
        // We are not running as an embedded app - show the main window
        ShowWindow(g_hMain, nCmdShow);
    }

    UpdateWindow(g_hMain);


    // message loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // If we get here, we initialized OLE so let's uninitialize it.
    CoUninitialize();

    return (msg.wParam);	   /* Returns the value from PostQuitMessage */
}



//+-------------------------------------------------------------------
//
//  Class:    CAdvBndCF
//
//  Synopsis: Class Factory for CAdvBnd
//
//  Interfaces:  IUnknown      - QueryInterface, AddRef, Release
//               IClassFactory - CreateInstance
//
//  History:  21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------


//+-------------------------------------------------------------------
//
//  Member:	CAdvBndCF::CAdvBndCF()
//
//  Synopsis:	The constructor for CAdvBnd.
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBndCF::CAdvBndCF() : _cRefs(1)
{
    // Load the class object for the class to aggregate.
    HRESULT hresult = CoGetClassObject(CLSID_BasicBnd, CLSCTX_SERVER, NULL,
	IID_IClassFactory, (void **) &_xifac);

    return;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::~CAdvBndObj()
//
//  Synopsis:	The destructor for CAdvBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBndCF::~CAdvBndCF()
{
    return;
}


//+-------------------------------------------------------------------
//
//  Method:	CAdvBndCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBndCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (GuidEqual(iid, IID_IUnknown)
	|| GuidEqual(iid, IID_IClassFactory))
    {
	*ppv = (IUnknown *) this;
	AddRef();
	return S_OK;
    }
    else
    {
        *ppv = NULL;
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CAdvBndCF::AddRef(void)
{
    return(++_cRefs);
}

STDMETHODIMP_(ULONG) CAdvBndCF::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
        return(0);
    }

    return _cRefs;
}





//+-------------------------------------------------------------------
//
//  Method:	CAdvBndCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object
//
//--------------------------------------------------------------------

STDMETHODIMP CAdvBndCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    Display(TEXT("CAdvBndCF::CreateInstance called\n"));

    if (pUnkOuter != NULL)
    {
	return E_FAIL;
    }

    CAdvBnd * lpcBB = new FAR CAdvBnd((IClassFactory *) _xifac);

    if (lpcBB == NULL)
    {
	return E_OUTOFMEMORY;
    }

    HRESULT hresult = lpcBB->QueryInterface(iidInterface, ppv);

    lpcBB->Release();

    return hresult;
}

STDMETHODIMP CAdvBndCF::LockServer(BOOL fLock)
{
    return E_FAIL;
}


//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::CAdvBnd()
//
//  Synopsis:	The constructor for CAdvBnd. I
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBnd::CAdvBnd(IClassFactory *pcfBase) : _xiunk(), _dwRegister(0), _cRefs(1)
{
    HRESULT hresult = pcfBase->CreateInstance((IUnknown *) this, IID_IUnknown,
	(void **) &_xiunk);

    tsaMain.IncEmbeddedCount();

    return;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::~CAdvBndObj()
//
//  Synopsis:	The destructor for CAdvBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBnd::~CAdvBnd()
{
    Display(TEXT("CAdvBndCF::~CAdvBnd called\n"));

    if (_dwRegister != 0)
    {
	// Get the running object table
	IRunningObjectTable *prot;

	HRESULT hresult = GetRunningObjectTable(0, &prot);

        if (hresult != S_OK)
        {
            HrMsgBox("CAdvBnd::~CAdvBnd GetRunningObjectTable failed", hresult);
        }
        else
        {
	    hresult = prot->Revoke(_dwRegister);

            if (hresult != S_OK)
            {
                HrMsgBox("CAdvBnd::~CAdvBnd Revoke failed", hresult);
            }

	    prot->Release();
        }
    }

    tsaMain.DecEmbeddedCount();
    return;
}


//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::QueryInterface
//
//  Returns:    SUCCESS_SUCCCESS
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::QueryInterface(REFIID iid, void ** ppunk)
{
    Display(TEXT("CAdvBnd::QueryInterface called\n"));

    if (GuidEqual(iid, IID_IUnknown))
    {
	*ppunk = (IUnknown *) this;
	AddRef();
	return S_OK;
    }
    else if ((GuidEqual(iid, IID_IPersistFile))
	|| (GuidEqual(iid, IID_IPersist)))
    {
	*ppunk = (IPersistFile *) this;
	AddRef();
	return S_OK;
    }

    return _xiunk->QueryInterface(iid, ppunk);
}

STDMETHODIMP_(ULONG) CAdvBnd::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CAdvBnd::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
        return(0);
    }

    return _cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::Load
//
//  Synopsis:   IPeristFile interface - needed 'cause we bind with
//              file moniker and BindToObject insists on calling this
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::Load(LPCWSTR lpszFileName, DWORD grfMode)
{
    Display(TEXT("CAdvBndCF::Load called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->Load(lpszFileName, grfMode);

    pipfile->Release();

    if (FAILED(hresult))
    {
	// Make sure delegated too class liked what it got/
	// BUGBUG: Can't just forward hresults!
	return hresult;
    }

    // Create a file moniker
    IMoniker *pmk;
    hresult = CreateFileMoniker((LPWSTR)lpszFileName, &pmk);

    if (FAILED(hresult))
    {
        HrMsgBox("CAdvBnd::Load CreateFileMoniker failed", hresult);
        return hresult;
    }

    // Get the running object table
    IRunningObjectTable *prot;

    hresult = GetRunningObjectTable(0, &prot);

    if (FAILED(hresult))
    {
        HrMsgBox("CAdvBnd::Load GetRunningObjectTable failed", hresult);
        return hresult;
    }

    // Register in the running object table
    IUnknown *punk;
    QueryInterface(IID_IUnknown, (void **) &punk);

    hresult = prot->Register(0, punk, pmk, &_dwRegister);

    if (FAILED(hresult))
    {
        HrMsgBox("CAdvBnd::Load Register failed", hresult);
        return hresult;
    }

    // Set filetime to known value
    FILETIME filetime;
    memset(&filetime, 'B', sizeof(filetime));

    // Set time to some known value
    prot->NoteChangeTime(_dwRegister, &filetime);

    // Release uneeded objects
    pmk->Release();
    prot->Release();
    punk->Release();

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::Save
//
//  Synopsis:   IPeristFile interface - save
//              does little but here for commentry
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::Save(LPCWSTR lpszFileName, BOOL fRemember)
{
    Display(TEXT("CAdvBndCF::Save called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->Save(lpszFileName, fRemember);

    pipfile->Release();

    return hresult;
}


//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::SaveCpmpleted
//		CAdvBnd::GetCurFile
//		CAdvBnd::IsDirty
//
//  Synopsis:   More IPeristFile interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::SaveCompleted(LPCWSTR lpszFileName)
{
    Display(TEXT("CAdvBndCF::SaveCompleted called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->SaveCompleted(lpszFileName);

    pipfile->Release();

    return hresult;
}

STDMETHODIMP CAdvBnd::GetCurFile(LPWSTR FAR *lpszFileName)
{
    Display(TEXT("CAdvBndCF::GetCurFile called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->GetCurFile(lpszFileName);

    pipfile->Release();

    return hresult;
}

STDMETHODIMP CAdvBnd::IsDirty()
{
    Display(TEXT("CAdvBndCF::IsDirty called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->IsDirty();

    pipfile->Release();

    return hresult;
}

//+-------------------------------------------------------------------
//
//  Interface:  IPersist
//
//  Synopsis:   IPersist interface methods
//              Need to return a valid class id here
//
//  History:    21-Nov-92  SarahJ  Created
//

STDMETHODIMP CAdvBnd::GetClassID(LPCLSID classid)
{
    Display(TEXT("CAdvBndCF::GetClassID called\n"));

    *classid = CLSID_AdvBnd;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server2\wterm.c ===
/****************************************************************************

    PROGRAM: wterm.c

    PURPOSE: Implementation of TermWClass Windows

    FUNCTIONS:


    COMMENTS:


****************************************************************************/

#include "windows.h"
#include "stdlib.h"
#include "memory.h"
#include "wterm.h"

#define MAX_ROWS 24
#define MAX_COLS 80

typedef struct WData
{
    // Function to execute for processing a menu
    MFUNCP pMenuProc;

    // Function to execute for processing a single character
    CFUNCP pCharProc;

    // Function to execute when window is closed (terminated)
    TFUNCP pCloseProc;

    // Pass on callback
    void *pvCallBackData;

    BOOL fGotFocus;

    BOOL fCaretHidden;

    // Rows on the screen
    int cRows;

    // Columns on the screen
    int cCols;

    // Row at top of screen
    int iTopRow;

    // Row at bottom of the screen
    int iBottomRow;

    // First Column on screen
    int iFirstCol;

    // Column at bottom of the screen
    int iBottomCol;

    // Row for next character
    int iNextRow;

    // Row for next column
    int iNextCol;

    // Width of character
    int cxChar;

    // Height of character
    int cyChar;

    // Memory image of screen this is treated as a circular buffer
    TCHAR aImage[MAX_ROWS] [MAX_COLS];

    // First row in circular screen buffer
    int iBufferTop;
} WData;

static HANDLE hInst = 0;
TCHAR BlankLine[80];

static int
row_diff(
    int row1,
    int row2)
{
    return (row2 > row1)
        ? MAX_ROWS - (row2 - row1)
        : row1 - row2;
}

static void
set_vscroll_pos(
    HWND hwnd,
    WData *pwdata)
{
    if (pwdata->cRows != 0)
    {
        // Save a few indirections by caching cRows
        register int cRows = pwdata->cRows;

        // calculate distance bottom of screen from top of data buffer
        register int top_from_row = row_diff(pwdata->iBottomRow,
            pwdata->iBufferTop);

        // Output position of scroll bar
        int new_pos = 0;

        if (top_from_row >= cRows)
        {
            // Calculate number of screens to display entire buffer
            int screens_for_data = MAX_ROWS / cRows
               + ((MAX_ROWS % cRows != 0) ? 1 : 0);

            // Figure out which screen the row falls in
            int screen_loc = top_from_row / cRows
                + ((top_from_row % cRows != 0) ? 1 : 0);

            // If the screen is in the last one set box to max
            new_pos = (screen_loc == screens_for_data)
                ? MAX_ROWS : screen_loc * cRows;
        }

        SetScrollPos(hwnd, SB_VERT, new_pos, TRUE);
    }
}

static int
calc_row(
    register int row,
    WData *pwdata)
{
    register int top = pwdata->iTopRow;
    static int boopa = 0;

    if (top > row)
        boopa++;

    return (row >= top) ? row - top : (MAX_ROWS - (top - row));
}

static void
display_text(
    HWND hwnd,
    int row,
    int col,
    LPTSTR text,
    int text_len,
    WData *pWData)
{
    // Get the DC to display the text
    HDC hdc = GetDC(hwnd);

    // Select Font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    // Hide caret while we are printing
    HideCaret(hwnd);

    // Update the screen
    TextOut(hdc, (col - pWData->iFirstCol) * pWData->cxChar,
        calc_row(row, pWData) * pWData->cyChar, text, text_len);

    // Done with DC
    ReleaseDC(hwnd, hdc);

    // Put the caret back now that we are done
    ShowCaret(hwnd);
}

static void
display_char(
    HWND hwnd,
    TCHAR char_to_display,
    WData *pWData)
{
    // Update image buffer
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = char_to_display;

    display_text(hwnd, pWData->iNextRow, pWData->iNextCol,
      &char_to_display, 1, pWData);
}

static void
do_backspace(
    HWND hwnd,
    WData *pWData)
{
    // Point to the previous character in the line
    if (--pWData->iNextCol < 0)
    {
        // Can't backspace beyond the current line
        pWData->iNextCol = 0;
        return;
    }

    display_char(hwnd, ' ', pWData);

    // Null character for repaint
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = '\0';
}

static int
inc_row(
    int row,
    int increment)
{
    row += increment;

    if (row >= MAX_ROWS)
    {
        row -= MAX_ROWS;
    }
    else if (row < 0)
    {
        row += MAX_ROWS;
    }

    return row;
}

void
inc_next_row(
    HWND hwnd,
    WData *pWData)
{
    if (pWData->iNextRow == pWData->iBottomRow)
    {
        // Line is at bottom -- scroll the client area one row
        ScrollWindow(hwnd, 0, -pWData->cyChar, NULL, NULL);

        // Increment the top & bottom of the screen
        pWData->iTopRow = inc_row(pWData->iTopRow, 1);
        pWData->iBottomRow = inc_row(pWData->iBottomRow, 1);
    }

    // Increment the row
    pWData->iNextRow = inc_row(pWData->iNextRow, 1);

    if (pWData->iNextRow == pWData->iBufferTop)
    {
        // Have to reset circular buffer to next
        pWData->iBufferTop = inc_row(pWData->iBufferTop, 1);

        // Reset line to nulls for repaint
        memset(&pWData->aImage[pWData->iNextRow][0], '\0', MAX_COLS);
    }

    pWData->iNextCol = 0;
}

static void
do_cr(
    HWND hwnd,
    WData *pWData)
{
    // Set position to next row
    inc_next_row(hwnd, pWData);
    pWData->iNextCol = 0;

    // Make sure next character is null for repaint of line
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = '\0';

    // Update the vertical scroll bar's position
    set_vscroll_pos(hwnd, pWData);
}

static void
do_char(
    HWND hwnd,
    WPARAM wParam,
    WData *pWData)
{
    display_char(hwnd, (TCHAR) wParam, pWData);

    // Point to the next character in the line
    if (++pWData->iNextCol > MAX_COLS)
    {
        // Handle switch to next line
        inc_next_row(hwnd, pWData);
    }
}

static void
do_tab(
    HWND hwnd,
    WData *pWData)
{
    int c = pWData->iNextCol % 8;

    if ((pWData->iNextCol + c) <= MAX_COLS)
    {
        for ( ; c; c--)
        {
            do_char(hwnd, ' ', pWData);
        }
    }
    else
    {
        do_cr(hwnd, pWData);
    }
}

static void
EchoChar(
    HWND hwnd,
    WORD cRepeats,
    WPARAM wParam,
    WData *pWData)
{
    for ( ; cRepeats; cRepeats--)
    {
        switch (wParam)
        {
        // Backspace
        case '\b':
            do_backspace(hwnd, pWData);
            break;

        // Carriage return
        case '\n':
        case '\r':
            do_cr(hwnd, pWData);
            break;

        // Tab
        case '\t':
            do_tab(hwnd, pWData);
            break;

        // Regular characters
        default:
            do_char(hwnd, wParam, pWData);
        }
    }

    // The row is guaranteed to be on the screen because we will
    // scroll on a CR. However, the next column for input may be
    // beyond the window we are working in.
    if (pWData->iNextCol > pWData->iBottomCol)
    {
        // We are out of the window so scroll the window one
        // column to the right.
        SendMessage(hwnd, WM_HSCROLL, SB_LINEDOWN, 0L);
    }
    else if (pWData->iNextCol < pWData->iFirstCol)
    {
        // We are out of the window so repaint the window using
        // iNextCol as the first column for the screen.
        pWData->iFirstCol = pWData->iNextCol;
        pWData->iBottomCol = pWData->iFirstCol + pWData->cCols - 1;

        // Reset scroll bar
        SetScrollPos(hwnd, SB_HORZ, pWData->iFirstCol, TRUE);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
    else
    {
        // Reset Caret's position
        SetCaretPos((pWData->iNextCol - pWData->iFirstCol) * pWData->cxChar,
            calc_row(pWData->iNextRow, pWData) * pWData->cyChar);
    }
}

/****************************************************************************

    FUNCTION: WmCreate(HWND)

    PURPOSE:  Initializes control structures for a TermWClass Window

    MESSAGES:
              WM_CREATE

    COMMENTS:

            This prepares a window for processing character based
            I/O. In particular it does stuff like calculate the
            size of the window needed.

****************************************************************************/
static void
WmCreate(
    HWND hwnd,
    CREATESTRUCT *pInit)
{
    WData *pData = (WData *) (pInit->lpCreateParams);
    HDC hdc = GetDC(hwnd);
    TEXTMETRIC tm;

    // Store pointer to window data
    SetWindowLong(hwnd, 0, (LONG) pData);

    // Set font to system fixed font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    // Calculate size of a character
    GetTextMetrics(hdc, &tm);
    pData->cxChar = tm.tmAveCharWidth;
    pData->cyChar = tm.tmHeight;
    ReleaseDC(hwnd, hdc);

    // Set up vertical scroll bars
    SetScrollRange(hwnd, SB_VERT, 0, MAX_ROWS, TRUE);
    SetScrollPos(hwnd, SB_VERT, 0, TRUE);

    // Set up horizontal scroll bars
    SetScrollRange(hwnd, SB_HORZ, 0, MAX_COLS, TRUE);
    SetScrollPos(hwnd, SB_HORZ, 0, TRUE);
}

/****************************************************************************

    FUNCTION: WmSize(HWND, WORD, LONG)

    PURPOSE:  Processes a size message

    MESSAGES:

    COMMENTS:

****************************************************************************/
static void
WmSize(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    // Get the new size of the window
    int cxClient;
    int cyClient;
    int cRowChange = pwdata->cRows;
    RECT rect;

    // Get size of client area
    GetClientRect(hwnd, &rect);

    // Calculate size of client area
    cxClient = rect.right - rect.left;
    cyClient = rect.bottom - rect.top;

    // Calculate size of area in rows
    pwdata->cCols = cxClient / pwdata->cxChar;
    pwdata->cRows = min(MAX_ROWS, cyClient / pwdata->cyChar);
    pwdata->iBottomCol = min(pwdata->iFirstCol + pwdata->cCols, MAX_COLS);
    cRowChange = pwdata->cRows - cRowChange;

    // Keep input line toward bottom of screen
    if (cRowChange < 0)
    {
        // Screen has shrunk in size.
        if (pwdata->iNextRow != pwdata->iTopRow)
        {
            // Has input row moved out of screen?
            if (row_diff(pwdata->iNextRow, pwdata->iTopRow) >= pwdata->cRows)
            {
                // Yes -- Calculate top new top that puts input line on
                // the bottom.
                pwdata->iTopRow =
                    inc_row(pwdata->iNextRow, 1 - pwdata->cRows);
            }
        }
    }
    else
    {
        // Screen has gotten bigger -- Display more text if possible
        if (pwdata->iTopRow != pwdata->iBufferTop)
        {
            pwdata->iTopRow = inc_row(pwdata->iTopRow,
                -(min(row_diff(pwdata->iTopRow, pwdata->iBufferTop),
                    cRowChange)));
        }
    }

    // Calculate new bottom
    pwdata->iBottomRow = inc_row(pwdata->iTopRow, pwdata->cRows - 1);

    InvalidateRect(hwnd, NULL, TRUE);
    UpdateWindow(hwnd);
}

static void
WmSetFocus(
    HWND hwnd,
    WData *pwdata)
{
    // save indirections
    register int cxchar = pwdata->cxChar;
    register int cychar = pwdata->cyChar;
    pwdata->fGotFocus = TRUE;
    CreateCaret(hwnd, NULL, cxchar, cychar);

    if (!pwdata->fCaretHidden)
    {
        SetCaretPos(pwdata->iNextCol * cxchar,
            calc_row(pwdata->iNextRow, pwdata) * cychar);
    }

    ShowCaret(hwnd);
}

static void
WmKillFocus(
    HWND hwnd,
    WData *pwdata)
{
    pwdata->fGotFocus = FALSE;

    if (!pwdata->fCaretHidden)
    {
        HideCaret(hwnd);
    }

    DestroyCaret();
}

static void
WmVscroll(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    int cVscrollInc = 0;
    register int top_diff = row_diff(pwdata->iTopRow, pwdata->iBufferTop);
    register int bottom_diff = MAX_ROWS - (top_diff + pwdata->cRows);

    switch(wParam)
    {
    case SB_TOP:

        if (top_diff != 0)
        {
            cVscrollInc = -top_diff;
        }

        break;

    case SB_BOTTOM:

        if (bottom_diff != 0)
        {
            cVscrollInc = bottom_diff;
        }

        break;

    case SB_LINEUP:

        if (top_diff != 0)
        {
            cVscrollInc = -1;
        }

        break;

    case SB_LINEDOWN:

        if (bottom_diff != 0)
        {
            cVscrollInc = 1;
        }

        break;

    case SB_PAGEUP:

        if (top_diff != 0)
        {
            cVscrollInc = - ((top_diff > pwdata->cRows)
                ? pwdata->cRows : top_diff);
        }

        break;

    case SB_PAGEDOWN:

        if (bottom_diff != 0)
        {
            cVscrollInc = (bottom_diff > pwdata->cRows)
                ? pwdata->cRows : bottom_diff;
        }

        break;

    case SB_THUMBTRACK:

        if (LOWORD(lParam) != 0)
        {
            cVscrollInc = LOWORD(lParam)
                - row_diff(pwdata->iTopRow, pwdata->iBufferTop);
        }
    }

    // Cacluate new top row
    if (cVscrollInc != 0)
    {
        // Calculate new top and bottom
        pwdata->iTopRow = inc_row(pwdata->iTopRow, cVscrollInc);
        pwdata->iBottomRow = inc_row(pwdata->iTopRow, pwdata->cRows);

        // Scroll window
        ScrollWindow(hwnd, 0, pwdata->cyChar * cVscrollInc, NULL, NULL);

        // Reset scroll bar
        set_vscroll_pos(hwnd, pwdata);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
}

static void
WmHscroll(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    register int cHscrollInc = 0;

    switch(wParam)
    {
    case SB_LINEUP:

        cHscrollInc = -1;
        break;

    case SB_LINEDOWN:

        cHscrollInc = 1;
        break;

    case SB_PAGEUP:

        cHscrollInc = -8;
        break;

    case SB_PAGEDOWN:

        cHscrollInc = 8;
        break;

    case SB_THUMBTRACK:

        if (LOWORD(lParam) != 0)
        {
            cHscrollInc = LOWORD(lParam) - pwdata->iFirstCol;
        }
    }

    if (cHscrollInc != 0)
    {
        // Cacluate new first column
        register int NormalizedScrollInc = cHscrollInc + pwdata->iFirstCol;

        if (NormalizedScrollInc < 0)
        {
            cHscrollInc = -pwdata->iFirstCol;
        }
        else if (NormalizedScrollInc > MAX_COLS - pwdata->cCols)
        {
            cHscrollInc = (MAX_COLS - pwdata->cCols) - pwdata->iFirstCol;
        }

        pwdata->iFirstCol += cHscrollInc;
        pwdata->iBottomCol = pwdata->iFirstCol + pwdata->cCols - 1;

        // Scroll window
        ScrollWindow(hwnd, -(pwdata->cxChar * cHscrollInc), 0, NULL, NULL);

        // Reset scroll bar
        SetScrollPos(hwnd, SB_HORZ, pwdata->iFirstCol, TRUE);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
}

static void
WmPaint(
    HWND hwnd,
    WData *pwdata)
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hwnd, &ps);
    register int row = pwdata->iTopRow;
    register int col = pwdata->iFirstCol;
    int bottom_row = pwdata->iBottomRow;
    int cxChar = pwdata->cxChar;
    int cyChar = pwdata->cyChar;
    int y;

    // Select System Font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    while (TRUE)
    {
	int len = lstrlen(&pwdata->aImage[row][col]);

        if (len != 0)
        {
            y = calc_row(row, pwdata) * cyChar;
	    TextOut(hdc, 0, y, &pwdata->aImage[row][col], len);
        }

        if (row == bottom_row)
        {
            break;
        }

        row = inc_row(row, 1);
    }

    if (pwdata->fGotFocus)
    {
        if ((pwdata->iNextCol >= pwdata->iFirstCol)
            && (row_diff(pwdata->iNextRow, pwdata->iTopRow) < pwdata->cRows))
        {
            if (pwdata->fCaretHidden)
            {
                pwdata->fCaretHidden = FALSE;
                ShowCaret(hwnd);
            }

            SetCaretPos(
                (pwdata->iNextCol - pwdata->iFirstCol) * pwdata->cxChar,
                calc_row(pwdata->iNextRow, pwdata) * pwdata->cyChar);
        }
        else
        {
            if (!pwdata->fCaretHidden)
            {
                pwdata->fCaretHidden = TRUE;
                HideCaret(hwnd);
            }
        }
    }

    EndPaint(hwnd, &ps);
}





//
//  FUNCTION:   WmPrintLine
//
//  PURPOSE:    Print a line on the screen.
//
//  Note: this is a user message not an intrinsic Window's message.
//
void
WmPrintLine(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pTermData)
{
    TCHAR *pBuf = (TCHAR *) lParam;

    // MessageBox(hwnd, L"WmPrintLine", L"Debug", MB_OK);

    // DebugBreak();

    while (wParam--)
    {
        // Is character a lf?
        if (*pBuf == '\n')
        {
            // Convert to cr since that is what this window uses
            *pBuf = '\r';
        }

        // Write the character to the window
        EchoChar(hwnd, 1, *pBuf++, pTermData);
    }

}

//
//  FUNCTION:   WmPutc
//
//  PURPOSE:    Print a single character on the screen
//
//  Note: this is a user message not an intrinsic Window's message.
//
void
WmPutc(
    HWND hwnd,
    WPARAM wParam,
    WData *pTermData)
{
    // Is character a lf?
    if (wParam == '\n')
    {
        // Convert to cr since that is what this window uses
        wParam = '\r';
    }

    // Write the character to the window
    EchoChar(hwnd, 1, wParam, pTermData);
}


/****************************************************************************

    FUNCTION: TermWndProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

    MESSAGES:

    COMMENTS:

****************************************************************************/

long TermWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    WData *pTerm = (WData *) GetWindowLong(hWnd, 0);

    switch (message)
    {
        case WM_CREATE:
            WmCreate(hWnd, (CREATESTRUCT *) lParam);
            break;

        case WM_COMMAND:
        case WM_SYSCOMMAND:
            // Call procedure that processes the menus
            return (*(pTerm->pMenuProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_SIZE:
            WmSize(hWnd, wParam, lParam, pTerm);
            break;

        case WM_SETFOCUS:
            WmSetFocus(hWnd, pTerm);
            break;

        case WM_KILLFOCUS:
            WmKillFocus(hWnd, pTerm);
            break;

        case WM_VSCROLL:
            WmVscroll(hWnd, wParam, lParam, pTerm);
            break;

        case WM_HSCROLL:
            WmHscroll(hWnd, wParam, lParam, pTerm);
            break;

        case WM_CHAR:
            // Character message echo and put in buffer
            return (*(pTerm->pCharProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_PAINT:
            WmPaint(hWnd, pTerm);
            break;

        case WM_USER:
        case WM_CLOSE:
	    DestroyWindow(hWnd);
            break;

        case WM_NCDESTROY:
            // Call close notification procedure
            return (*(pTerm->pCloseProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_PRINT_LINE:
            WmPrintLine(hWnd, wParam, lParam, pTerm);
            break;

        case WM_PUTC:
            WmPutc(hWnd, wParam, pTerm);
	    break;

	case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

	case WM_TERM_WND:
	    DestroyWindow(hWnd);
	    break;

        default:                          /* Passes it on if unproccessed    */
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }

    return 0;
}


/****************************************************************************

    FUNCTION: TermRegisterClass(HANDLE)

    PURPOSE:  Register a class for a terminal window

    COMMENTS:


****************************************************************************/

BOOL TermRegisterClass(
    HANDLE hInstance,
    LPTSTR MenuName,
    LPTSTR ClassName,
    LPTSTR Icon)
{
    WNDCLASS  wc;
    BOOL retVal;

    // Make sure blank line is blank
    memset(BlankLine, ' ', 80);

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = 0;
    wc.lpfnWndProc = TermWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(WData *);
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, Icon);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  MenuName;
    wc.lpszClassName = ClassName;

    /* Register the window class and return success/failure code. */
    if (retVal = RegisterClass(&wc))
    {
        // Class got registered -- so finish set up
        hInst = hInstance;
    }

    return retVal;
}


/****************************************************************************

    FUNCTION:  TermCreateWindow(LPWSTR, LPWSTR, HMENU, void *, void *, int)

    PURPOSE:   Create a window of a previously registered window class

    COMMENTS:


****************************************************************************/

BOOL
TermCreateWindow(
    LPTSTR lpClassName,
    LPTSTR lpWindowName,
    HMENU hMenu,
    MFUNCP MenuProc,
    CFUNCP CharProc,
    TFUNCP CloseProc,
    int nCmdShow,
    HWND *phNewWindow,
    void *pvCallBackData)
{
    HWND            hWnd;               // Main window handle.
    WData           *pTermData;

    // Allocate control structure for the window
    if ((pTermData = malloc(sizeof(WData))) == NULL)
    {
        return FALSE;
    }

    // Set entire structure to nulls
    memset((TCHAR *) pTermData, '\0', sizeof(WData));

    // Initialize function pointers
    pTermData->pMenuProc = MenuProc;
    pTermData->pCharProc = CharProc;
    pTermData->pCloseProc = CloseProc;

    // Initialize callback data
    pTermData->pvCallBackData = pvCallBackData;

    // Create a main window for this application instance.
    hWnd = CreateWindow(
        lpClassName,
        lpWindowName,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        hMenu,
        hInst,
	(LPTSTR) pTermData
    );

    // If window could not be created, return "failure"

    if (!hWnd)
    {
        free(pTermData);
        return FALSE;
    }

    // BUGBUG - Why would we want to set focus?
    // SetFocus(hWnd);

    // Make the window visible; update its client area; and return "success"

    //  ShowWindow(hWnd, nCmdShow);
    //  UpdateWindow(hWnd);
    *phNewWindow = hWnd;
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server1\testsrv.cxx ===
//+-------------------------------------------------------------------
//  File:       testsrv.cxx
//
//  Contents:
//
//  Classes:    CBasicSrvCF - IUnknown IClassFactory
//              CBasicSrv   - IUnknown IPersist IPersistFile IParseDisplayName
//
//  Notes:      This code is written based on OLE2.0 code. Therefore
//              all error codes, defines etc are OLE style rather than Cairo
//
//  History:    24-Nov-92   DeanE   Created
//              31-Dec-93   ErikGav Chicago port
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include "testsrv.hxx"
#include <stdio.h>

// BUGBUG - memory allocation hacks need these so new and delete don't
//   break us
//
#include <malloc.h>
#include <dos.h>

#define IDM_DEBUG 0x100

extern "C" LRESULT FAR PASCAL MainWndProc(HWND, UINT, WPARAM, LPARAM);
void ReportMessage(HWND, WORD);

// This is global because we're still in $%E#$#K 16-bit world
HWND g_hwndMain = NULL;

// Note constructor cannot fail
CTestServerApp tsaMain;


//+--------------------------------------------------------------
//  Function:   WinMain
//
//  Synopsis:   Initializes application and controls message pump.
//
//  Returns:    Exits with exit code 0 if success, non-zero otherwise
//
//  History:    25-Nov-92   DeanE   Created
//---------------------------------------------------------------
int PASCAL WinMain(
	HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
        LPSTR  lpszCmdline,
        int    nCmdShow)
{
    static TCHAR szAppName[] = TEXT("OleServer");
    MSG         msg;
    WNDCLASS    wndclass;

    if (!hPrevInstance)
    {
        wndclass.style         = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc   = MainWndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = 0;
        wndclass.hInstance     = hInstance;
        wndclass.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(125));
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH) GetStockObject(BLACK_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = szAppName;

        if (0==RegisterClass(&wndclass))
        {
            // Error! Clean up and exit
            return(LOG_ABORT);
        }
    }

    g_hwndMain	 = CreateWindow(
                       szAppName,
		               TEXT("OLE Server"),
                       WS_OVERLAPPEDWINDOW | WS_VSCROLL,
                       GetSystemMetrics(SM_CXSCREEN)/12,      // Init X pos
                       GetSystemMetrics(SM_CYSCREEN)/12,      // Init Y pos
                       GetSystemMetrics(SM_CXSCREEN)*2/3,     // width
                       GetSystemMetrics(SM_CYSCREEN)*2/3,     // height
                       NULL,
                       NULL,
                       hInstance,
		       NULL);

    if (NULL==g_hwndMain)
    {
        // Error! Clean up and exit
        return(LOG_ABORT);
    }

    // Add debug option to system menu
    HMENU hmenu = GetSystemMenu(g_hwndMain, FALSE);

    AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hmenu, MF_STRING | MF_ENABLED, IDM_DEBUG, TEXT("Debug"));


    // Initialize Application
    if (S_OK != tsaMain.InitApp(lpszCmdline))
    {
        tsaMain.CloseApp();
        return(LOG_ABORT);
    }

    if (tsaMain.GetEmbeddedFlag())
    {
        // We're running as an embedded app
        // Don't show the main window unless we're instructed to do so
        // BUGBUG - In-place editing is NYI
	ShowWindow(g_hwndMain, SW_SHOWMINIMIZED);
    }
    else
    {
        // We are not running as an embedded app - show the main window
        ShowWindow(g_hwndMain, nCmdShow);
    }

    UpdateWindow(g_hwndMain);


    // message loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Clean up and exit
    // BUGBUG - check return code?
    tsaMain.CloseApp();

    return(0);
}


//+--------------------------------------------------------------
// Function:    MainWndProc
//
// Synopsis:    Callback for the server window
//
// Returns:     Varies dependent on message received.
//
// History:     25-Nov-92   DeanE   Created
//---------------------------------------------------------------
extern "C" LRESULT FAR PASCAL MainWndProc(
        HWND   hwnd,
        UINT   wMsg,
        WPARAM wParam,
        LPARAM lParam)
{
    switch(wMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
	return(0);

    case WM_USER:
	DestroyWindow(hwnd);
	return 0;

    case WM_SYSCOMMAND:

	if (wParam == IDM_DEBUG)
	{
	    // Request for a debug breakpoint!
	    DebugBreak();
	}

    default:
	break;
    }

    return(DefWindowProc(hwnd, wMsg, wParam, lParam));
}


void ReportMessage(HWND hwnd, WORD wParam)
{
    TCHAR szBuffer[256];
    szBuffer[0] = '\0';

    switch (wParam)
    {
    case MB_SHOWVERB:
	lstrcpy(szBuffer, TEXT("OLEIVERB_SHOW Received"));
        break;

    case MB_PRIMVERB:
	lstrcpy(szBuffer, TEXT("OLEIVERB_PRIMARY Received"));
        break;

    default:
	lstrcpy(szBuffer, TEXT("Unrecognized ReportMessage code"));
        break;
    }

    MessageBox(hwnd, szBuffer, TEXT("OLE Server"), MB_ICONINFORMATION | MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\app.cpp ===
//**********************************************************************
// File name: app.cpp
//
//    Implementation file for the CSimpleApp Class
//
// Functions:
//
//    See app.h for a list of member functions.
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>

extern void DeactivateIfActive(HWND hWnd);

#ifdef WIN32
extern INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam,
                           LPARAM lParam);
#endif


//**********************************************************************
//
// CSimpleApp::CSimpleApp()
//
// Purpose:
//
//      Constructor for CSimpleApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetRectEmpty                Windows API
//
// Comments:
//
//      CSimpleApp has a contained COleInPlaceFrame.  On construction
//      of CSimpleApp, we explicitly call the constructor of this
//      contained class and pass a copy of the this pointer, so that
//      COleInPlaceFrame can refer back to this class
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                 // tells us that we are passing this in
                                 // an initializer, before "this" is through
                                 // initializing.  This is ok, because
                                 // we just store the ptr in the other
                                 // constructor

CSimpleApp::CSimpleApp() : m_OleInPlaceFrame(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
    TestDebugOut(TEXT("In CSimpleApp's Constructor \r\n"));

    // Set Ref Count
    m_nCount = 0;

    // clear members
    m_hAppWnd = NULL;
    m_hInst = NULL;
    m_lpDoc = NULL;

    // Make sure we don't think we are deactivating
    m_fDeactivating = FALSE;

    // We haven't got a unit test accelerator so ...
    m_fGotUtestAccelerator = FALSE;

    // clear flags
    m_fInitialized = FALSE;
    m_fCSHMode = FALSE;
    m_fMenuMode = FALSE;

    // used for inplace
    SetRectEmpty(&nullRect);
}

//**********************************************************************
//
// CSimpleApp::~CSimpleApp()
//
// Purpose:
//
//      Destructor for CSimpleApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DeleteObject                Windows API
//      OleUninitialize             OLE API
//
//
//********************************************************************

CSimpleApp::~CSimpleApp()
{
    TestDebugOut(TEXT("In CSimpleApp's Destructor\r\n"));

    if (m_hStdPal)
        DeleteObject(m_hStdPal);

    // need to uninit the library...
    if (m_fInitialized)
        OleUninitialize();
}

//**********************************************************************
//
// CSimpleApp::DestroyDocs()
//
// Purpose:
//
//      Destroys all of the open documents in the application (Only one
//      since this is an SDI app, but could easily be modified to
//      support MDI).
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//      CSimpDoc::Close             DOC.CPP
//
//
//********************************************************************

void CSimpleApp::DestroyDocs()
{
    m_lpDoc->Close();   // we have only 1 document
}

//**********************************************************************
//
// CSimpleApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the application level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK            -   The interface is supported.
//      E_NOINTERFACE   -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      COleInPlaceFrame::AddRef    IOIPF.CPP
//      CSimpleApp::AddRef          APP.CPP
//
// Comments:
//
//      Note that this QueryInterface is associated with the frame.
//      Since the application could potentially have multiple documents
//      and multiple objects, a lot of the interfaces are ambiguous.
//      (ie. which IOleObject is returned?).  For this reason, only
//      pointers to interfaces associated with the frame are returned.
//      In this implementation, Only IOleInPlaceFrame (or one of the
//      interfaces it is derived from) can be returned.
//
//********************************************************************

STDMETHODIMP CSimpleApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpleApp::QueryInterface\r\n"));

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    // looking for IUnknown
    if ( IsEqualIID(riid, IID_IUnknown))
        {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
        }

    // looking for IOleWindow
    if ( IsEqualIID(riid, IID_IOleWindow))
        {
        m_OleInPlaceFrame.AddRef();
        *ppvObj=&m_OleInPlaceFrame;
        return ResultFromScode(S_OK);
        }

    // looking for IOleInPlaceUIWindow
    if ( IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        {
        m_OleInPlaceFrame.AddRef();
        *ppvObj=&m_OleInPlaceFrame;
        return ResultFromScode(S_OK);
        }

    // looking for IOleInPlaceFrame
    if ( IsEqualIID(riid, IID_IOleInPlaceFrame))
        {
        m_OleInPlaceFrame.AddRef();
        *ppvObj=&m_OleInPlaceFrame;
        return ResultFromScode(S_OK);
        }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::AddRef()
{
    TestDebugOut(TEXT("In CSimpleApp::AddRef\r\n"));
    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::Release()
{
    TestDebugOut(TEXT("In CSimpleApp::Release\r\n"));

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//
//
//********************************************************************

BOOL CSimpleApp::fInitApplication(HANDLE hInstance)
{
    // Initialize our accelerator table
    if ((m_hAccel = LoadAccelerators((HINSTANCE) hInstance,
        TEXT("SimpcntrAccel"))) == NULL)
    {
        // Load failed so abort
        TestDebugOut(TEXT("ERROR: Accelerator Table Load FAILED\r\n"));
        return FALSE;
    }

    WNDCLASS  wc;

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style = NULL;                    // Class style(s).
    wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = (HINSTANCE) hInstance;     // Application that owns the
                                              // class.
    wc.hIcon   = LoadIcon((HINSTANCE) hInstance, TEXT("SimpCntr"));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  =  TEXT("SIMPLEMENU");        // Name of menu resource in
                                                   // .RC file.
    wc.lpszClassName = TEXT("SimpCntrAppWClass");  // Name used in
                                                   // CreateWindow call

    if (!RegisterClass(&wc))
        return FALSE;

    wc.style = CS_DBLCLKS;              // Class style(s). allow DBLCLK's
    wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = (HINSTANCE) hInstance;           // Application that owns
                                                    // the class.
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("SimpCntrDocWClass");   // Name used in
                                                    // CreateWindow call.

    // Register the window class and return success/failure code.

    return (RegisterClass(&wc));
}

//**********************************************************************
//
// CSimpleApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpleApp::fInitInstance (HANDLE hInstance, int nCmdShow)
{
    LPMALLOC lpMalloc = NULL;

#ifndef WIN32
   /* Since OLE is part of the operating system in Win32, we don't need to
    * check the version number in Win32.
    */
    DWORD dwVer = OleBuildVersion();

    // check to see if we are compatible with this version of the libraries
    if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup)
    {
#ifdef _DEBUG
      TestDebugOut(TEXT("WARNING:Incompatible OLE library version\r\n"));
#else
      return FALSE;
#endif
    }
#endif // WIN32

#if defined( _DEBUG )
    /* OLE2NOTE: Use a special debug allocator to help track down
    **    memory leaks.
    */
    OleStdCreateDbAlloc(0, &lpMalloc);
#endif

    //  We try passing in our own allocator first - if that fails we
    //  try without overriding the allocator.

    if (SUCCEEDED(OleInitialize(lpMalloc)) ||
        SUCCEEDED(OleInitialize(NULL)))
    {
        m_fInitialized = TRUE;
    }

#if defined( _DEBUG )
    /* OLE2NOTE: release the special debug allocator so that only OLE is
    **    holding on to it. later when OleUninitialize is called, then
    **    the debug allocator object will be destroyed. when the debug
    **    allocator object is destoyed, it will report (to the Output
    **    Debug Terminal) whether there are any memory leaks.
    */
    if (lpMalloc) lpMalloc->Release();
#endif

    m_hInst = (HINSTANCE) hInstance;

    // Create the "application" windows
    m_hAppWnd = CreateWindow (TEXT("SimpCntrAppWClass"),
                              TEXT("Simple OLE 2.0 In-Place Container"),
                              WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              NULL,
                              NULL,
                              (HINSTANCE) hInstance,
                              NULL);

    if (!m_hAppWnd)
        return FALSE;

    m_hStdPal = OleStdCreateStandardPalette();

    ShowWindow (m_hAppWnd, nCmdShow);
    UpdateWindow (m_hAppWnd);

    // if we have been launched by the test driver, tell it our window handle
    if( m_hDriverWnd )
    {
        PostMessage(m_hDriverWnd, WM_TESTREG, (WPARAM)m_hAppWnd, 0);
    }



    return m_fInitialized;
}

//**********************************************************************
//
// CSimpleApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      IOleInPlaceActiveObject::QueryInterface     Object
//      IOleInPlaceObject::ContextSensitiveHelp     Object
//      IOleInPlaceObject::Release                  Object
//      IOleObject::DoVerb                          Object
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      CSimpleDoc::InsertObject                    DOC.CPP
//      CSimpleSite::GetObjRect                     SITE.CPP
//      CSimpleApp::lCreateDoc                      APP.CPP
//
//
//********************************************************************

long CSimpleApp::lCommandHandler (HWND hWnd, UINT message,
                                  WPARAM wParam, LPARAM lParam)
{
    RECT rect;

    // Win32 uses high word to tell were command came from so we dump it.
    wParam = LOWORD(wParam);

    // context sensitive help...
    if (m_fMenuMode || m_fCSHMode)
    {
        if (m_fCSHMode)
        {
            // clear context sensitive help flag
            m_fCSHMode = FALSE;

            // if there is an InPlace active object, call its context
            // sensitive help method with the FALSE parameter to bring the
            // object out of the csh state.  See the technotes for details.
            if (m_lpDoc->m_lpActiveObject)
            {
                LPOLEINPLACEOBJECT lpInPlaceObject;
                m_lpDoc->m_lpActiveObject->QueryInterface(
                                             IID_IOleInPlaceObject,
                                             (LPVOID FAR *)&lpInPlaceObject);
                lpInPlaceObject->ContextSensitiveHelp(FALSE);
                lpInPlaceObject->Release();
            }
        }

        // see the technotes for details on implementing context sensitive
        // help
        if (m_fMenuMode)
        {
            m_fMenuMode = FALSE;

            if (m_lpDoc->m_lpActiveObject)
                m_lpDoc->m_lpActiveObject->ContextSensitiveHelp(FALSE);
        }
        // if we provided help, we would do it here...
        MessageBox (hWnd, TEXT("Help"), TEXT("Help"), MB_OK);

        return NULL;
    }

    // see if the command is a verb selections
    if (wParam >= IDM_VERB0)
    {
        // get the rectangle of the object
        m_lpDoc->m_lpSite->GetObjRect(&rect);

        m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(wParam - IDM_VERB0, NULL,
                                    &m_lpDoc->m_lpSite->m_OleClientSite,
                                    -1, m_lpDoc->m_hDocWnd, &rect);
    }
    else
    {
        switch (wParam)
           {
            // bring up the About box
            case IDM_ABOUT:
                {
#ifdef WIN32
                  DialogBox(m_hInst,             // current instance
                          TEXT("AboutBox"),      // resource to use
                          m_hAppWnd,             // parent handle
                          About);                // About() instance address
#else
                  FARPROC lpProcAbout = MakeProcInstance((FARPROC)About,
                                                         m_hInst);

                  DialogBox(m_hInst,               // current instance
                          TEXT("AboutBox"),        // resource to use
                          m_hAppWnd,               // parent handle
                          lpProcAbout);            // About() instance address

                  FreeProcInstance(lpProcAbout);
#endif

                  break;
                }

            // bring up the InsertObject Dialog
            case IDM_INSERTOBJECT:
                m_lpDoc->InsertObject();
                break;

            // exit the application
            case IDM_EXIT:
                SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                break;

            case IDM_NEW:
                m_lpDoc->Close();
                m_lpDoc = NULL;
                lCreateDoc(hWnd, 0, 0, 0);
                break;

            case IDM_DEACTIVATE:
                DeactivateIfActive(hWnd);
                break;

            case IDM_UTEST:
                m_fGotUtestAccelerator = TRUE;
                break;

            default:
                return (DefWindowProc(hWnd, message, wParam, lParam));
           }   // end of switch
    }  // end of else
    return NULL;
}

//**********************************************************************
//
// CSimpleApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::lResizeDoc      DOC.CPP
//
//
//********************************************************************

long CSimpleApp::lSizeHandler (HWND hWnd, UINT message, WPARAM wParam,
                               LPARAM lParam)
{
    RECT rect;

    GetClientRect(m_hAppWnd, &rect);
    return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpleApp::lCreateDoc
//
// Purpose:
//
//      Handles the creation of a document.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::CSimpleDoc      DOC.CPP
//
//
//********************************************************************

long CSimpleApp::lCreateDoc (HWND hWnd, UINT message, WPARAM wParam,
                             LPARAM lParam)
{
    RECT rect;

    GetClientRect(hWnd, &rect);

    m_lpDoc = CSimpleDoc::Create(this, &rect, hWnd);

    return NULL;
}

//**********************************************************************
//
// CSimpleApp::AddFrameLevelUI
//
// Purpose:
//
//      Used during InPlace negotiation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                            Location
//
//      COleInPlaceFrame::SetMenu           IOIPF.CPP
//      CSimpleApp::AddFrameLevelTools      APP.CPP
//
// Comments:
//
//      Be sure to read the Technotes included in the OLE 2.0 toolkit
//
//********************************************************************

void CSimpleApp::AddFrameLevelUI()
{
    m_OleInPlaceFrame.SetMenu(NULL, NULL, NULL);
    AddFrameLevelTools();
}

//**********************************************************************
//
// CSimpleApp::AddFrameLevelTools
//
// Purpose:
//
//      Used during InPlace negotiation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                              Location
//
//      COleInPlaceFrame::SetBorderSpace      IOIPF.CPP
//      InvalidateRect                        Windows API
//
// Comments:
//
//      Be sure to read the Technotes included in the OLE 2.0 toolkit
//
//********************************************************************

void CSimpleApp::AddFrameLevelTools()
{
    m_OleInPlaceFrame.SetBorderSpace(&nullRect);
    InvalidateRect(m_hAppWnd, NULL, TRUE);
}

//**********************************************************************
//
// CSimpleApp::HandleAccelerators
//
// Purpose:
//
//      To properly handle accelerators in the Message Loop
//
// Parameters:
//
//      LPMSG lpMsg -   A pointer to the message structure.
//
// Return Value:
//
//      TRUE    -   The accelerator was handled
//      FALSE   -   The accelerator was not handled
//
// Function Calls:
//      Function                                        Location
//
//      IOleInPlaceActiveObject::TranslateAccelerator   Object
//
// Comments:
//
//      If an object is InPlace active, it gets the first shot at
//      handling the accelerators.
//
//********************************************************************

BOOL CSimpleApp::HandleAccelerators(LPMSG lpMsg)
{
    HRESULT hResult;
    BOOL retval = FALSE;

    // The following is what you would do if this were an inproc DLL.
    // A local server will be passing us commands to process
#if 0
    // if we have an InPlace Active Object
    if (m_lpDoc->m_lpActiveObject)
    {
        // Pass the accelerator on...
        hResult = m_lpDoc->m_lpActiveObject->TranslateAccelerator(lpMsg);
        if (hResult == NOERROR)
            retval = TRUE;
    }
#endif

    // We process our accelerators
    return TranslateAccelerator(m_hAppWnd, m_hAccel, lpMsg);
}

//**********************************************************************
//
// CSimpleApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::PaintDoc        DOC.CPP
//
// Comments:
//
//      This is an app level function in case we want to do palette
//      management.
//
//********************************************************************

void CSimpleApp::PaintApp (HDC hDC)
{
    // at this level, we could enumerate through all of the
    // visible objects in the application, so that a palette
    // that best fits all of the objects can be built.

    // This app is designed to take on the same palette
    // functionality that was provided in OLE 1.0, the palette
    // of the last object drawn is realized.  Since we only
    // support one object at a time, it shouldn't be a big
    // deal.

    // if we supported multiple documents, we would enumerate
    // through each of the open documents and call paint.

    if (m_lpDoc)
        m_lpDoc->PaintDoc(hDC);

}

//**********************************************************************
//
// CSimpleApp::ContextSensitiveHelp
//
// Purpose:
//      Used in supporting context sensitive help at the app level.
//
//
// Parameters:
//
//      BOOL fEnterMode    -   Entering/Exiting Context Sensitive
//                             help mode.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                    Location
//
//      IOleInPlaceActiveObject::QueryInterface     Object
//      IOleInPlaceObject::ContextSensitiveHelp     Object
//      IOleInPlaceObject::Release                  Object
//
// Comments:
//
//      This function isn't used because we don't support Shift+F1
//      context sensitive help.  Be sure to look at the technotes
//      in the OLE 2.0 toolkit.
//
//********************************************************************

void CSimpleApp::ContextSensitiveHelp (BOOL fEnterMode)
{
    if (m_fCSHMode != fEnterMode)
    {
        m_fCSHMode = fEnterMode;

        // this code "trickles" the context sensitive help via shift+f1
        // to the inplace active object.  See the technotes for implementation
        // details.
        if (m_lpDoc->m_lpActiveObject)
        {
            LPOLEINPLACEOBJECT lpInPlaceObject;
            m_lpDoc->m_lpActiveObject->QueryInterface(IID_IOleInPlaceObject,
                                            (LPVOID FAR *)&lpInPlaceObject);
            lpInPlaceObject->ContextSensitiveHelp(fEnterMode);
            lpInPlaceObject->Release();
        }
    }
}

/* OLE2NOTE: forward the WM_QUERYNEWPALETTE message (via
**    SendMessage) to UIActive in-place object if there is one.
**    this gives the UIActive object the opportunity to select
**    and realize its color palette as the FOREGROUND palette.
**    this is optional for in-place containers. if a container
**    prefers to force its color palette as the foreground
**    palette then it should NOT forward the this message. or
**    the container can give the UIActive object priority; if
**    the UIActive object returns 0 from the WM_QUERYNEWPALETTE
**    message (ie. it did not realize its own palette), then
**    the container can realize its palette.
**    (see ContainerDoc_ForwardPaletteChangedMsg for more info)
**
**    (It is a good idea for containers to use the standard
**    palette even if they do not use colors themselves. this
**    will allow embedded object to get a good distribution of
**    colors when they are being drawn by the container)
**
*/

//**********************************************************************
//
// CSimpleApp::QueryNewPalette
//
// Purpose:
//      See above
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      0 if the handle to palette (m_hStdPal) is NULL,
//      1 otherwise
//
// Function Calls:
//      Function                                    Location
//
//      SendMessage                                 Windows API
//
//
//********************************************************************

LRESULT CSimpleApp::QueryNewPalette(void)
{
	if (m_hwndUIActiveObj)
   {
		if (SendMessage(m_hwndUIActiveObj, WM_QUERYNEWPALETTE,
				(WPARAM)0, (LPARAM)0))
      {
			/* Object selected its palette as foreground palette */
			return (LRESULT)1;
		}	
	}

	return wSelectPalette(m_hAppWnd, m_hStdPal, FALSE/*fBackground*/);
}


/* This is just a helper routine */

LRESULT wSelectPalette(HWND hWnd, HPALETTE hPal, BOOL fBackground)
{
	HDC hdc;
	HPALETTE hOldPal;
	UINT iPalChg = 0;

	if (hPal == 0)
		return (LRESULT)0;

	hdc = GetDC(hWnd);
	hOldPal = SelectPalette(hdc, hPal, fBackground);
	iPalChg = RealizePalette(hdc);
	SelectPalette(hdc, hOldPal, TRUE /*fBackground*/);
	ReleaseDC(hWnd, hdc);
				
	if (iPalChg > 0)
		InvalidateRect(hWnd, NULL, TRUE);

	return (LRESULT)1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\server3\fail.cxx ===
//+-------------------------------------------------------------------
//
//  File:       fail.cxx
//
//  Contents:   An exe that just returns: to test failure of process start.
//
//  History:	1-Dec-94 BillMo Created.
//
//---------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>

#define FILE_SHARE_DELETE               0x00000004

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to EXE - does little else
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    1-Dec-94  BillMo  Created
//
//--------------------------------------------------------------------

int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    char *lpszCmdLine,
    int nCmdShow)
{
    //
    // We indicate that we ran by touching a file that olebind will look at the
    // timestamps of. This is because we don't have a unique error code
    // to distinguish errors during start of a server.
    //
    HANDLE hTouchFile;
    TCHAR  tszFileName[MAX_PATH+1];
    DWORD dw;
    SYSTEMTIME st;
    FILETIME ft;

    GetSystemDirectory(tszFileName, MAX_PATH+1);
    _tcscat(tszFileName, TEXT("\\failtst.tst"));
    hTouchFile = CreateFile(tszFileName, 
                                   GENERIC_READ|GENERIC_WRITE,
                                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);
    if (hTouchFile == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            MessageBox(GetDesktopWindow(), 
                       TEXT("This program (fail.exe) must be run from olebind.exe"),
                       TEXT("Error in test"),
                       MB_OK);
        }
        else
        {
            MessageBox(GetDesktopWindow(), 
                       TEXT("This program (fail.exe) failed for unknown reason"),
                       TEXT("Error in test"),
                       MB_OK);
            GetLastError();
        }
        return 0;
    }
    
    GetSystemTime(&st);
    WriteFile(hTouchFile, &st, sizeof(st), &dw, NULL);
    CloseHandle(hTouchFile);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\app.h ===
//**********************************************************************
// File name: app.h
//
//      Definition of CSimpleApp
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _APP_H_)
#define _APP_H_

#include <ole2.h>
#include "ioipf.h"

class CSimpleDoc;

class CSimpleApp : public IUnknown
{
public:

    int m_nCount;           // reference count
    HWND m_hAppWnd;         // main window handle
    HACCEL m_hAccel;        // Handle to accelerator table
    HINSTANCE m_hInst;          // application instance

    COleInPlaceFrame m_OleInPlaceFrame; // IOleInPlaceFrame Implementation

    CSimpleDoc FAR * m_lpDoc;   // pointer to document object
    BOOL m_fInitialized;        // OLE initialization flag
    BOOL m_fCSHMode;
    BOOL m_fMenuMode;
    HWND m_hwndUIActiveObj; // HWND of UIActive Object
    HPALETTE m_hStdPal;     // Color palette used by container
    BOOL m_fAppActive;      // TRUE if app is active

    BOOL m_fDeactivating;   // TRUE if we are in the process of deactivating
                            // an inplace object.

    BOOL m_fGotUtestAccelerator;// Received a unit test accelerator

    HWND m_hDriverWnd;      // Window of test driver

    CSimpleApp();           // Constructor
    ~CSimpleApp();          // Destructor
    RECT nullRect;


    // IUnknown Interfaces
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Initialization methods

    BOOL fInitApplication (HANDLE hInstance);
    BOOL fInitInstance (HANDLE hInstance, int nCmdShow);

    // Message handling methods

    long lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    long lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    long lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    BOOL HandleAccelerators (LPMSG lpMsg);
    void PaintApp(HDC hDC);
    void DestroyDocs();

    // In-Place support functions
    void AddFrameLevelUI();
    void AddFrameLevelTools();
    void ContextSensitiveHelp (BOOL fEnterMode);
    LRESULT QueryNewPalette(void);
};

LRESULT wSelectPalette(HWND hWnd, HPALETTE hPal, BOOL fBackground);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\doc.h ===
//**********************************************************************
// File name: doc.h
//
//      Definition of CSimpleDoc
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DOC_H_ )
#define _DOC_H_

class CSimpleSite;
class CSimpleApp;

class CSimpleDoc : public IUnknown 
{   
public:                  
    int 			m_nCount;  
    LPSTORAGE 		m_lpStorage;
    HMENU 			m_hMainMenu;    
    HMENU 			m_hFileMenu;
    HMENU 			m_hEditMenu;
    HMENU 			m_hHelpMenu;  
    HMENU 			m_hCascadeMenu;
    LPOLEINPLACEACTIVEOBJECT m_lpActiveObject;
    BOOL 			m_fInPlaceActive;
    BOOL 			m_fAddMyUI;
    BOOL 			m_fModifiedMenu;
    
    CSimpleSite FAR * m_lpSite;
    CSimpleApp FAR * m_lpApp;
    
    HWND m_hDocWnd;

    static CSimpleDoc FAR * Create(CSimpleApp FAR *lpApp, LPRECT lpRect,HWND hWnd);

    void Close(void);

    CSimpleDoc();          
    CSimpleDoc(CSimpleApp FAR *lpApp, HWND hWnd);
    ~CSimpleDoc();        
    
    // IUnknown Interface    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj); 
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release(); 
    
    void InsertObject(void);
    void DisableInsertObject(void);
    long lResizeDoc(LPRECT lpRect);
    long lAddVerbs(void);
    void PaintDoc(HDC hDC);
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\ias.cpp ===
//**********************************************************************
// File name: IAS.CPP
//
//      Implementation file of CAdviseSink
//
//
// Functions:
//
//      See IAS.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CAdviseSink::QueryInterface
//
// Purpose:
//
//      used for interface negotiation
//
// Parameters:
//
//      REFIID riid         - The requested interface
//
//      LPVOID FAR* ppvObj  - Place to return the interface
//
// Return Value:
//
//      HRESULT from CSimpleSite::QueryInterface
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::QueryInterface SITE.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function simply delegates to the Object class, which is
//      aware of the supported interfaces.
//
//********************************************************************

STDMETHODIMP CAdviseSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In IAS::QueryInterface\r\n"));

    // delegate to the document Object
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CAdviseSink::AddRef
//
// Purpose:
//
//      Increments the reference count of CSimpleSite. Since CAdviseSink is
//      a nested class of CSimpleSite, we don't need to have a separate
//      reference count for CAdviseSink. We can safely use the reference
//      count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::AddReff        SITE.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::AddRef()
{
    TestDebugOut(TEXT("In IAS::AddRef\r\n"));

    // delegate to the container Site
    return m_pSite->AddRef();
}

//**********************************************************************
//
// CAdviseSink::Release
//
// Purpose:
//
//      Decrements the reference count of CSimpleSite. Since CAdviseSink is
//      a nested class of CSimpleSite, we don't need to have a separate
//      reference count for CAdviseSink. We can safely use the reference
//      count of CSimpleSite.
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Release        SITE.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::Release()
{
    TestDebugOut(TEXT("In IAS::Release\r\n"));

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// CAdviseSink::OnDataChange
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      FORMATETC pFormatetc   -  data format info that was originally set up
//      STGMEDIUM pStgmed      -  storage medium which data is passed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnDataChange (FORMATETC FAR* pFormatetc,
                                               STGMEDIUM FAR* pStgmed)
{
    TestDebugOut(TEXT("In IAS::OnDataChange\r\n"));
}

//**********************************************************************
//
// CAdviseSink::OnViewChange
//
// Purpose:
//
//      Notifies us that the view has changed and needs to be updated.
//
// Parameters:
//
//      DWORD dwAspect  - Aspect that has changed
//
//      LONG lindex     - Index that has changed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      IOleObject::QueryInterface  Object
//      IViewObject2::GetExtent     Object
//      IViewObject2::Release       Object
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnViewChange (DWORD dwAspect, LONG lindex)
{
    LPVIEWOBJECT2 lpViewObject2;

    TestDebugOut(TEXT("In IAS::OnViewChange\r\n"));

    // get a pointer to IViewObject2
    HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(
                            IID_IViewObject2,(LPVOID FAR *)&lpViewObject2);

    if (hErr == NOERROR)
    {
        // get extent of the object
        // NOTE: this method will never be remoted; it can be called w/i
        // this async method
        lpViewObject2->GetExtent(DVASPECT_CONTENT, -1 , NULL,
                                 &m_pSite->m_sizel);
        lpViewObject2->Release();
    }

    InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);
}

//**********************************************************************
//
// CAdviseSink::OnRename
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      LPMONIKER  pmk       -  new name of the object
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnRename (LPMONIKER pmk)
{
    TestDebugOut(TEXT("In IAS::OnRename\r\n"));
}

//**********************************************************************
//
// CAdviseSink::OnSave
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnSave ()
{
    TestDebugOut(TEXT("In IAS::OnSave\r\n"));
}

//**********************************************************************
//
// CAdviseSink::OnClose
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnClose()
{
    TestDebugOut(TEXT("In IAS::OnClose\r\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\ias.h ===
//**********************************************************************
// File name: IAS.H
//
//      Definition of CAdviseSink
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IAS_H_ )
#define _IAS_H_

#include <assert.h>

class CSimpleSite;

interface CAdviseSink : public IAdviseSink
{
    CSimpleSite FAR * m_pSite;

    CAdviseSink(CSimpleSite FAR * pSite)
       {
        TestDebugOut(TEXT("In IAS's constructor\r\n"));
        m_pSite = pSite;
       };

    ~CAdviseSink()
       {
        TestDebugOut(TEXT("In IAS's destructor\r\n"));
       } ;

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    // *** IAdviseSink methods ***
    STDMETHODIMP_(void) OnDataChange (FORMATETC FAR* pFormatetc,
                                      STGMEDIUM FAR* pStgmed);
    STDMETHODIMP_(void) OnViewChange (DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename (LPMONIKER pmk);
    STDMETHODIMP_(void) OnSave ();
    STDMETHODIMP_(void) OnClose ();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\iocs.h ===
//**********************************************************************
// File name: IOCS.H
//
//      Definition of COleClientSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOCS_H_ )
#define _IOCS_H_

#include <assert.h>

class CSimpleSite;

interface COleClientSite : public IOleClientSite
{
    CSimpleSite FAR * m_pSite;

    COleClientSite(CSimpleSite FAR * pSite)
       {
        TestDebugOut(TEXT("In IOCS's constructor\r\n"));
        m_pSite = pSite;
       }

    ~COleClientSite()
       {
        TestDebugOut(TEXT("In IOCS's destructor\r\n"));
       }

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IOleClientSite methods ***
    STDMETHODIMP SaveObject();
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
                            LPMONIKER FAR* ppmk);
    STDMETHODIMP GetContainer(LPOLECONTAINER FAR* ppContainer);
    STDMETHODIMP ShowObject();
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\doc.cpp ===
//**********************************************************************
// File name: DOC.CPP
//
//      Implementation file for CSimpleDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CSimpleDoc::Create
//
// Purpose:
//
//      Creation for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      EnableMenuItem              Windows API
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpleDoc FAR * CSimpleDoc::Create(CSimpleApp FAR *lpApp, LPRECT lpRect,
                                    HWND hWnd)
{
    CSimpleDoc FAR * lpTemp = new CSimpleDoc(lpApp, hWnd);

    if (!lpTemp)
        return NULL;

    // create storage for the doc.
    HRESULT hErr = StgCreateDocfile (NULL,
                                     STGM_READWRITE | STGM_TRANSACTED |
                                     STGM_SHARE_EXCLUSIVE,
                                     0, &lpTemp->m_lpStorage);

    if (hErr != NOERROR)
        goto error;

    // create the document Window
    lpTemp->m_hDocWnd = CreateWindow(
            TEXT("SimpCntrDocWClass"),
            NULL,
            WS_CHILD | WS_CLIPCHILDREN,
            lpRect->left,
            lpRect->top,
            lpRect->right,
            lpRect->bottom,
            hWnd,
            NULL,
            lpApp->m_hInst,
            NULL);

    if (!lpTemp->m_hDocWnd)
        goto error;

    ShowWindow(lpTemp->m_hDocWnd, SW_SHOWNORMAL);  // Show the window
    UpdateWindow(lpTemp->m_hDocWnd);               // Sends WM_PAINT message

    // Ensable InsertObject menu choice
    EnableMenuItem( lpTemp->m_hEditMenu, 0, MF_BYPOSITION | MF_ENABLED);

    // we will add one ref count on our document. later in CSimpleDoc::Close
    // we will release this  ref count. when the document's ref count goes
    // to 0, the document will be deleted.
    lpTemp->AddRef();

    return (lpTemp);

error:
    delete (lpTemp);
    return NULL;

}

//**********************************************************************
//
// CSimpleDoc::Close
//
// Purpose:
//
//      Close CSimpleDoc object.
//      when the document's reference count goes to 0, the document
//      will be destroyed.
//
// Parameters:
//      None
//
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::CloseOleObject SITE.CPP
//      ShowWindow                  Windows API
//      TestDebugOut           Windows API
//
//
//********************************************************************

void CSimpleDoc::Close(void)
{
    TestDebugOut(TEXT("In CSimpleDoc::Close\r\n"));

    ShowWindow(m_hDocWnd, SW_HIDE);  // Hide the window

    // Close the OLE object in our document
    if (m_lpSite)
    	m_lpSite->CloseOleObject();

    // Release the ref count added in CSimpleDoc::Create. this will make
    // the document's ref count go to 0, and the document will be deleted.
    Release();
}

//**********************************************************************
//
// CSimpleDoc::CSimpleDoc
//
// Purpose:
//
//      Constructor for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
//
//********************************************************************

CSimpleDoc::CSimpleDoc(CSimpleApp FAR * lpApp,HWND hWnd)
{
    TestDebugOut(TEXT("In CSimpleDoc's Constructor\r\n"));
    m_lpApp = lpApp;
    m_lpSite = NULL;
    m_nCount = 0;
    // set up menu handles
    m_hMainMenu = GetMenu(hWnd);
    m_hFileMenu = GetSubMenu(m_hMainMenu, 0);
    m_hEditMenu = GetSubMenu(m_hMainMenu, 1);
    m_hHelpMenu = GetSubMenu(m_hMainMenu, 2);
    m_hCascadeMenu = NULL;

    m_lpActiveObject = NULL;

    // flags
    m_fInPlaceActive = FALSE;
    m_fAddMyUI = FALSE;
    m_fModifiedMenu = FALSE;
}

//**********************************************************************
//
// CSimpleDoc::~CSimpleDoc
//
// Purpose:
//
//      Destructor for CSimpleDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                     Location
//
//      TestDebugOut            Windows API
//      CSimpleSite::UnloadOleObject SITE.CPP
//      CSimpleSite::Release         SITE.CPP
//      IStorage::Release            OLE API
//      GetMenuItemCount             Windows API
//      RemoveMenu                   Windows API
//      DestroyMenu                  Windows API
//      DestroyWindows               Windows API
//
//
//********************************************************************

CSimpleDoc::~CSimpleDoc()
{
    TestDebugOut(TEXT("In CSimpleDoc's Destructor\r\n"));

    // Release all pointers we hold to the OLE object. also release
    // the ref count added in CSimpleSite::Create. this will make
    // the Site's ref count go to 0, and the Site will be deleted.
    if (m_lpSite)
    {
      m_lpSite->UnloadOleObject();
    	m_lpSite->Release();
    	m_lpSite = NULL;
    }

    // Release the Storage
    if (m_lpStorage)
    {
        m_lpStorage->Release();
        m_lpStorage = NULL;
    }

    // if the edit menu was modified, remove the menu item and
    // destroy the popup if it exists
    if (m_fModifiedMenu)
    {
        int nCount = GetMenuItemCount(m_hEditMenu);
        RemoveMenu(m_hEditMenu, nCount-1, MF_BYPOSITION);
        if (m_hCascadeMenu)
            DestroyMenu(m_hCascadeMenu);
    }

    DestroyWindow(m_hDocWnd);
}


//**********************************************************************
//
// CSimpleDoc::QueryInterface
//
// Purpose:
//
//      interface negotiation at document level
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      E_NOINTERFACE       -   Always
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      In this implementation, there are no doc level interfaces.
//      In an MDI application, there would be an IOleInPlaceUIWindow
//      associated with the document to provide document level tool
//      space negotiation.
//
//********************************************************************

STDMETHODIMP CSimpleDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpleDoc::QueryInterface\r\n"));

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleDoc::AddRef
//
// Purpose:
//
//      Increments the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::AddRef()
{
    TestDebugOut(TEXT("In CSimpleDoc::AddRef\r\n"));
    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::Release
//
// Purpose:
//
//      Decrements the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::Release()
{
    TestDebugOut(TEXT("In CSimpleDoc::Release\r\n"));

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::InsertObject
//
// Purpose:
//
//      Inserts a new object to this document
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                         Location
//
//      CSimpleSite::CSimpleSite         SITE.CPP
//      CSimpleSite::InitObject          SITE.CPP
//      CSimpleSite::Release             SITE.CPP
//      memset                           C Runtime
//      OleUIInsertObject                OLE2UI function
//      CSimpleDoc::DisableInsertObject  DOC.CPP
//      IStorage::Revert                 OLE API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another.
//
//********************************************************************

void CSimpleDoc::InsertObject()
{
    OLEUIINSERTOBJECT io;
    UINT iret;
    TCHAR szFile[OLEUI_CCHPATHMAX];

    m_lpSite = CSimpleSite::Create(this);

    if (!m_lpSite)
    {
       /* memory allocation problem! cannot carry on.
        */
       TestDebugOut(TEXT("Memory allocation error!\n"));
       return;
    }

    // clear the structure
    _fmemset(&io, 0, sizeof(OLEUIINSERTOBJECT));

    // fill the structure
    io.cbStruct = sizeof(OLEUIINSERTOBJECT);
    io.dwFlags = IOF_SELECTCREATENEW      | IOF_DISABLELINK     |
                 IOF_DISABLEDISPLAYASICON | IOF_CREATENEWOBJECT |
                 IOF_CREATEFILEOBJECT;
    io.hWndOwner = m_hDocWnd;
    io.lpszCaption = (LPTSTR) TEXT("Insert Object");
    io.iid = IID_IOleObject;
    io.oleRender = OLERENDER_DRAW;
    io.lpIOleClientSite = &m_lpSite->m_OleClientSite;
    io.lpIStorage = m_lpSite->m_lpObjStorage;
    io.ppvObj = (LPVOID FAR *)&m_lpSite->m_lpOleObject;
    io.lpszFile = szFile;
    io.cchFile = sizeof(szFile)/sizeof(TCHAR);
                            // cchFile is the number of characters of szFile
    _fmemset((LPTSTR)szFile, 0, sizeof(szFile));

    // call OUTLUI to do all the hard work
    iret = OleUIInsertObject(&io);

    if (iret == OLEUI_OK)
    {
        m_lpSite->InitObject((BOOL)(io.dwFlags & IOF_SELECTCREATENEW));
        // disable Insert Object menu item
        DisableInsertObject();
    }
    else
    {
        m_lpSite->Release();
        m_lpSite = NULL;
        m_lpStorage->Revert();
    }

}

//**********************************************************************
//
// CSimpleDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      IOleInPlaceActiveObject::ResizeBorder   Object
//      MoveWindow                              Windows API
//
//
//********************************************************************

long CSimpleDoc::lResizeDoc(LPRECT lpRect)
{
    // if we are InPlace, then call ResizeBorder on the object, otherwise
    // just move the document window.
    if (m_fInPlaceActive)
        m_lpActiveObject->ResizeBorder(lpRect, &m_lpApp->m_OleInPlaceFrame,
                                       TRUE);
    else
        MoveWindow(m_hDocWnd, lpRect->left, lpRect->top, lpRect->right,
                   lpRect->bottom, TRUE);

    return NULL;
}

//**********************************************************************
//
// CSimpleDoc::lAddVerbs
//
// Purpose:
//
//      Adds the objects verbs to the edit menu.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetMenuItemCount            Windows API
//      OleUIAddVerbMenu            OLE2UI function
//
//
//********************************************************************

long CSimpleDoc::lAddVerbs(void)
{
    // m_fModifiedMenu is TRUE if the menu has already been modified
    // once.  Since we only support one obect every time the application
    // is run, then once the menu is modified, it doesn't have
    // to be done again.
    if (m_lpSite && !m_fInPlaceActive  && !m_fModifiedMenu)
    {
        int nCount = GetMenuItemCount(m_hEditMenu);

        if (!OleUIAddVerbMenu ( m_lpSite->m_lpOleObject,
                           NULL,
                           m_hEditMenu,
                           nCount + 1,
                           IDM_VERB0,
                           0,           // no maximum verb IDM enforced
                           FALSE,
                           0,
                           &m_hCascadeMenu))
        {
           TestDebugOut(TEXT("Fail in OleUIAddVerbMenu"));
        }

        m_fModifiedMenu = TRUE;
    }
    return (NULL);
}

//**********************************************************************
//
// CSimpleDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::PaintObj       SITE.CPP
//
//
//********************************************************************

void CSimpleDoc::PaintDoc (HDC hDC)
{
    // if we supported multiple objects, then we would enumerate
    // the objects and call paint on each of them from here.

    if (m_lpSite)
        m_lpSite->PaintObj(hDC);

}

//**********************************************************************
//
// CSimpleDoc::DisableInsertObject
//
// Purpose:
//
//      Disable the ability to insert a new object in this document.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      EnableMenuItem              Windows API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another.
//
//********************************************************************

void CSimpleDoc::DisableInsertObject(void)
{
    // Disable InsertObject menu choice
    EnableMenuItem( m_hEditMenu, 0, MF_BYPOSITION | MF_DISABLED | MF_GRAYED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\ioipf.h ===
//**********************************************************************
// File name: IOIPF.H
//
//      Definition of COleInPlaceFrame
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOIPF_H_ )
#define _IOIPF_H_


class CSimpleApp;

interface COleInPlaceFrame : public IOleInPlaceFrame
{
    CSimpleApp FAR * m_pApp;

    COleInPlaceFrame(CSimpleApp FAR * pApp)
       {
        TestDebugOut(TEXT("In IOIPF's constructor\r\n"));
        m_pApp = pApp;
       };

    ~COleInPlaceFrame()
       {
        TestDebugOut(TEXT("In IOIPFS's destructor\r\n"));
       };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP GetWindow (HWND FAR* lphwnd);
    STDMETHODIMP ContextSensitiveHelp (BOOL fEnterMode);

    // *** IOleInPlaceUIWindow methods ***
    STDMETHODIMP GetBorder (LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace (LPCBORDERWIDTHS lpborderwidths);
    STDMETHODIMP SetBorderSpace (LPCBORDERWIDTHS lpborderwidths);
    STDMETHODIMP SetActiveObject (LPOLEINPLACEACTIVEOBJECT lpActiveObject,LPCOLESTR lpszObjName);

    // *** IOleInPlaceFrame methods ***
    STDMETHODIMP InsertMenus (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenu (HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHODIMP RemoveMenus (HMENU hmenuShared);
    STDMETHODIMP SetStatusText (LPCOLESTR lpszStatusText);
    STDMETHODIMP EnableModeless (BOOL fEnable);
    STDMETHODIMP TranslateAccelerator (LPMSG lpmsg, WORD wID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\ioipf.cpp ===
//**********************************************************************
// File name: IOIPF.CPP
//
//      Implementation file for COleInPlaceFrame
//
// Functions:
//
//      See IOIPF.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"


//**********************************************************************
//
// COleInPlaceFrame::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK            -   The interface is supported.
//      E_NOINTERFACE   -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleApp::QueryInterface  APP.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In IOIPF::QueryInterface\r\n"));

    // delegate to the application Object
    return m_pApp->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceFrame::AddRef
//
// Purpose:
//
//      Increments the reference count of the CSimpleApp. Since
//      COleInPlaceFrame is a nested class of CSimpleApp, we don't need an
//      extra reference count for COleInPlaceFrame. We can safely use the
//      reference count of CSimpleApp.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the CSimpleApp
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleApp::AddRef          APP.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::AddRef()
{
    TestDebugOut(TEXT("In IOIPF::AddRef\r\n"));

    // delegate to the application Object
    return m_pApp->AddRef();
}

//**********************************************************************
//
// COleInPlaceFrame::Release
//
// Purpose:
//
//      Decrements the reference count of the CSimpleApp. Since
//      COleInPlaceFrame is a nested class of CSimpleApp, we don't need an
//      extra reference count for COleInPlaceFrame. We can safely use the
//      reference count of CSimpleApp.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleApp.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleApp::Release         APP.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::Release()
{
    TestDebugOut(TEXT("In IOIPF::Release\r\n"));

    // delegate to the document object
    return m_pApp->Release();

}

//**********************************************************************
//
// COleInPlaceFrame::GetWindow
//
// Purpose:
//
//      Returns the frame window handle
//
// Parameters:
//
//      HWND FAR* lphwnd    - Location to return the window handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetWindow (HWND FAR* lphwnd)
{
    TestDebugOut(TEXT("In IOIPF::GetWindow\r\n"));
    *lphwnd = m_pApp->m_hAppWnd;
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::ContextSensitiveHelp
//
// Purpose:
//
//      Used in implementing Context sensitive help
//
// Parameters:
//
//      BOOL fEnterMode -   TRUE if starting Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes in the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::ContextSensitiveHelp (BOOL fEnterMode)
{
    TestDebugOut(TEXT("In IOIPF::ContextSensitiveHelp\r\n"));

    m_pApp->m_fMenuMode = fEnterMode;

    return ResultFromScode(S_OK);
}
//**********************************************************************
//
// COleInPlaceFrame::GetBorder
//
// Purpose:
//
//      Returns the outermost border that frame adornments can be attached
//      during InPlace Activation.
//
// Parameters:
//
//      LPRECT lprectBorder - return parameter to contain the outermost
//                            rect for frame adornments
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetClientRect               Windows API
//      CopyRect                    Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetBorder (LPRECT lprectBorder)
{
    RECT rect;

    TestDebugOut(TEXT("In IOIPF::GetBorder\r\n"));

    // get the rect for the entire frame.
    GetClientRect(m_pApp->m_hAppWnd, &rect);

    CopyRect(lprectBorder, &rect);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::RequestBorderSpace
//
// Purpose:
//
//      Approves/Denies requests for border space during InPlace
//      negotiation.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - The width in pixels needed on
//                                        each side of the frame.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      This implementation doesn't care about how much border space
//      is used.  It always returns S_OK.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RequestBorderSpace (LPCBORDERWIDTHS
                                                         lpborderwidths)
{
    TestDebugOut(TEXT("In IOIPF::RequestBorderSpace\r\n"));

    // always approve the request
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetBorderSpace
//
// Purpose:
//
//      The object calls this method when it is actually going to
//      start using the border space.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - Border space actually being used
//                                        by the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::AddFrameLevelTools  APP.CPP
//      TestDebugOut               Windows API
//      GetClientRect                   Windows API
//      MoveWindow                      Windows API
//      ResultFromScode                 Windows API
//
// Comments:
//
//      This routine could be a little smarter and check to see if
//      the object is requesting the entire client area of the
//      window.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetBorderSpace (LPCBORDERWIDTHS lpborderwidths)
{

    TestDebugOut(TEXT("In IOIPF::SetBorderSpace\r\n"));

    if (lpborderwidths == NULL)
        m_pApp->AddFrameLevelTools();
    else
    {
        RECT rect;

        GetClientRect(m_pApp->m_hAppWnd, &rect);

        MoveWindow( m_pApp->m_lpDoc->m_hDocWnd,
                   rect.left + lpborderwidths->left,
                   rect.top + lpborderwidths->top,
                   rect.right - lpborderwidths->right - lpborderwidths->left,
                   rect.bottom - lpborderwidths->bottom - lpborderwidths->top,
                   TRUE);
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetActiveObject
//
// Purpose:
//  install the object being activated in-place
//
//
// Parameters:
//
//  LPOLEINPLACEACTIVEOBJECT lpActiveObject     -   Pointer to the
//                                                  objects
//                                                  IOleInPlaceActiveObject
//                                                  interface
//
//  LPCOLESTR lpszObjName                       -   Name of the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleInPlaceActiveObject::AddRef     Object
//      IOleInPlaceActiveObject::Release    Object
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetActiveObject (LPOLEINPLACEACTIVEOBJECT
                                        lpActiveObject, LPCOLESTR lpszObjName)
{

    TestDebugOut(TEXT("In IOIPF::SetActiveObject\r\n"));

    // AddRef() it and save it...
    if (lpActiveObject)
    {
        lpActiveObject->AddRef();

        lpActiveObject->GetWindow(&m_pApp->m_hwndUIActiveObj);
        if (m_pApp->m_hwndUIActiveObj)
            SendMessage(m_pApp->m_hwndUIActiveObj, WM_QUERYNEWPALETTE, 0, 0L);
    }
    else
    {
        if (m_pApp->m_lpDoc->m_lpActiveObject)
            m_pApp->m_lpDoc->m_lpActiveObject->Release();
        m_pApp->m_hwndUIActiveObj = NULL;
    }

    // in an MDI app, this method really shouldn't be called,
    // this method associated with the doc is called instead.

    m_pApp->m_lpDoc->m_lpActiveObject = lpActiveObject;
    // should set window title here

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::InsertMenus
//
// Purpose:
//
//      Inserts the container menu into the combined menu
//
// Parameters:
//
//      HMENU hmenuShared                   -   Menu Handle to be set.
//      LPOLEMENUGROUPWIDTHS lpMenuWidths   -   Width of menus
//
// Return Value:
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      AppendMenu                  Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::InsertMenus (HMENU hmenuShared,
                                            LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    TestDebugOut(TEXT("In IOIPF::InsertMenus\r\n"));

    AppendMenu(hmenuShared, MF_BYPOSITION | MF_POPUP,
               (UINT) m_pApp->m_lpDoc->m_hFileMenu, TEXT("&File"));
    AppendMenu(hmenuShared, MF_BYPOSITION | MF_POPUP,
               (UINT) m_pApp->m_lpDoc->m_hHelpMenu, TEXT("&Other"));

    lpMenuWidths->width[0] = 1;
    lpMenuWidths->width[2] = 0;
    lpMenuWidths->width[4] = 1;

    return ResultFromScode(S_OK);
}


//**********************************************************************
//
// COleInPlaceFrame::SetMenu
//
// Purpose:
//
//      Sets the application menu to the combined menu
//
// Parameters:
//
//      HMENU hmenuShared       - The combined menu
//
//      HOLEMENU holemenu       - Used by OLE
//
//      HWND hwndActiveObject   - Used by OLE
//
// Return Value:
//
//      S_OK                -  if menu was correctly installed
//      E_FAIL              -  otherwise
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetMenu                     Windows API
//      OleSetMenuDescriptor        OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetMenu (HMENU hmenuShared, HOLEMENU holemenu,
                                        HWND hwndActiveObject)
{

    TestDebugOut(TEXT("In IOIPF::SetMenu\r\n"));

    HMENU hMenu = m_pApp->m_lpDoc->m_hMainMenu;

    if (holemenu)
        hMenu = hmenuShared;

    // call the windows api, not this method
    ::SetMenu (m_pApp->m_hAppWnd, hMenu);

    HRESULT hRes = OleSetMenuDescriptor(holemenu, m_pApp->m_hAppWnd,
                                        hwndActiveObject, this,
                                        m_pApp->m_lpDoc->m_lpActiveObject);

    return hRes;
}


//**********************************************************************
//
// COleInPlaceFrame::RemoveMenus
//
// Purpose:
//
//      Removes the container menus from the combined menu
//
// Parameters:
//
//      HMENU hmenuShared   - Handle to the combined menu.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenuItemCount            Windows API
//      RemoveMenu                  Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RemoveMenus (HMENU hmenuShared)
{
    int retval;

    TestDebugOut(TEXT("In IOIPF::RemoveMenus\r\n"));

    while ((retval = GetMenuItemCount(hmenuShared)) && (retval != -1))
        RemoveMenu(hmenuShared, 0, MF_BYPOSITION);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetStatusText
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPCOLESTR  lpszStatusText  -  character string containing the message
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented due to the fact
//      that this application does not have a status bar.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetStatusText (LPCOLESTR lpszStatusText)
{
    TestDebugOut(TEXT("In IOIPF::SetStatusText\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceFrame::EnableModeless
//
// Purpose:
//
//      Enables/Disables container modeless dialogs
//
// Parameters:
//
//      BOOL fEnable    - Enable/Disable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      There are no modeless dialogs in this application, so the
//      implementation of this method is trivial.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::EnableModeless (BOOL fEnable)
{
    TestDebugOut(TEXT("In IOIPF::EnableModeless\r\n"));
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::TranslateAccelerator
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPMSG   lpmsg     -   structure containing keystroke message
//      WORD    wID       -   identifier value corresponding to the keystroke
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::TranslateAccelerator (LPMSG lpmsg, WORD wID)
{
    TestDebugOut(TEXT("In IOIPF::TranslateAccelerator\r\n"));
    return ::TranslateAccelerator(m_pApp->m_hAppWnd, m_pApp->m_hAccel, lpmsg)
        ? ResultFromScode(S_OK)
        : ResultFromScode(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\ioips.cpp ===
//**********************************************************************
// File name: IOIPS.CPP
//
//      Implementation file for COleInPlaceSite
//
// Functions:
//
//      See IOIPS.H for class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// COleInPlaceSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::QueryInterface SITE.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In IOIPS::QueryInterface\r\n"));

    // delegate to the container Site
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the CSimpleSite. Since
//      COleInPlaceSite is a nested class of CSimpleSite, we don't need an
//      extra reference count for COleInPlaceSite. We can safely use the
//      reference count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::QueryInterface SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::AddRef()
{
    TestDebugOut(TEXT("In IOIPS::AddRef\r\n"));

    // delegate to the container Site
    return m_pSite->AddRef();
}

//**********************************************************************
//
// COleInPlaceSite::Release
//
// Purpose:
//
//      Decrements the reference count of the CSimpleSite. Since
//      COleInPlaceSite is a nested class of CSimpleSite, we don't need an
//      extra reference count for COleInPlaceSite. We can safely use the
//      reference count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Release        SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::Release()
{
    TestDebugOut(TEXT("In IOIPS::Release\r\n"));

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// COleInPlaceSite::GetWindow
//
// Purpose:
//
//      Returns the Window Handle of the client site
//
// Parameters:
//
//      HWND FAR* lphwnd    - place to return the handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindow (HWND FAR* lphwnd)
{
    TestDebugOut(TEXT("In IOIPS::GetWindow\r\n"));

    // return the handle to our editing window.
    *lphwnd = m_pSite->m_lpDoc->m_hDocWnd;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::ContextSensitiveHelp
//
// Purpose:
//      set/reset context sensitive help mode
//
// Parameters:
//
//      BOOL fEnterMode - TRUE for entering Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes included with the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::ContextSensitiveHelp (BOOL fEnterMode)
{
    TestDebugOut(TEXT("In IOIPS::ContextSensitiveHelp\r\n"));

    if (m_pSite->m_lpDoc->m_lpApp->m_fCSHMode != fEnterMode)
        m_pSite->m_lpDoc->m_lpApp->m_fCSHMode = fEnterMode;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::CanInPlaceActivate
//
// Purpose:
//
//      Object calls to find out if the container can InPlace activate
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::CanInPlaceActivate ()
{
    TestDebugOut(TEXT("In IOIPS::CanInPlaceActivate\r\n"));

    // return S_OK to indicate we can in-place activate
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceActivate
//
// Purpose:
//
//      Called by the object on InPlace Activation
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK             -  if the interface can be found
//      E_FAIL           -  otherwise
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IOleObject::QueryInterface  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceActivate ()
{
    HRESULT hrErr;
    TestDebugOut(TEXT("In IOIPS::OnInPlaceActivate\r\n"));

    hrErr = m_pSite->m_lpOleObject->QueryInterface(
           IID_IOleInPlaceObject, (LPVOID FAR *)&m_pSite->m_lpInPlaceObject);
    if (hrErr != NOERROR)
        return ResultFromScode(E_FAIL);

    // return S_OK to indicate we can in-place activate.
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIActivate
//
// Purpose:
//
//      Object calls this method when it displays it's UI.
//
// Parameters:
//
//      None.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                      Location
//
//      TestDebugOut             Windows API
//      ResultFromScode               OLE API
//      IOleInPlaceObject::GetWindow  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIActivate ()
{
    TestDebugOut(TEXT("In IOIPS::OnUIActivate\r\n"));

    m_pSite->m_lpDoc->m_fAddMyUI=FALSE;
    m_pSite->m_lpDoc->m_fInPlaceActive = TRUE;
    m_pSite->m_fInPlaceActive = TRUE;

    m_pSite->m_lpInPlaceObject->GetWindow((HWND FAR*)&m_pSite->m_hwndIPObj);

    // return S_OK to continue in-place activation
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::GetWindowContext
//
// Purpose:
//
//      Called by the object to get information for InPlace Negotiation.
//
// Parameters:
//
//      LPOLEINPLACEFRAME FAR* lplpFrame    - Location to return a pointer
//                                            to IOleInPlaceFrame.
//
//      LPOLEINPLACEUIWINDOW FAR* lplpDoc   - Location to return a pointer
//                                            to IOleInPlaceUIWindow.
//
//      LPRECT lprcPosRect                  - The rect that the object
//                                            occupies
//
//      LPRECT lprcClipRect                 - The clipping rect
//
//      LPOLEINPLACEFRAMEINFO lpFrameInfo   - Pointer to FRAMEINFO
//
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      COleInPlaceFrame::AddRef    IOIPF.CPP
//      CSimpleSite::GetObjRect     SITE.CPP
//      TestDebugOut           Windows API
//      CopyRect                    Windows API
//      GetClientRect               Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindowContext (
                               LPOLEINPLACEFRAME FAR* lplpFrame,
                               LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                               LPRECT lprcPosRect,
                               LPRECT lprcClipRect,
                               LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    RECT rect;

    TestDebugOut(TEXT("In IOIPS::GetWindowContext\r\n"));

    // the frame is associated with the application object.
    // need to AddRef() it...
    m_pSite->m_lpDoc->m_lpApp->m_OleInPlaceFrame.AddRef();
    *lplpFrame = &m_pSite->m_lpDoc->m_lpApp->m_OleInPlaceFrame;
    *lplpDoc = NULL;  // must be NULL, cause we're SDI.

    // get the size of the object in pixels
    m_pSite->GetObjRect(&rect);

    // Copy this to the passed buffer
    CopyRect(lprcPosRect, &rect);

    // fill the clipping region
    GetClientRect(m_pSite->m_lpDoc->m_hDocWnd, &rect);
    CopyRect(lprcClipRect, &rect);

    // fill the FRAMEINFO
    if (sizeof(OLEINPLACEFRAMEINFO) != lpFrameInfo->cb)
    {
        TestDebugOut(TEXT("WARNING IOIPS::GetWindowContext "
                               "lpFrameInfo->cb size may be incorrect\r\n"));
    }

    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame = m_pSite->m_lpDoc->m_lpApp->m_hAppWnd;
    lpFrameInfo->haccel = m_pSite->m_lpDoc->m_lpApp->m_hAccel;
    lpFrameInfo->cAccelEntries = SIMPCNTR_ACCEL_CNT;

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::Scroll
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      SIZE scrollExtent  - number of pixels scrolled in X and Y direction
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::Scroll (SIZE scrollExtent)
{
    TestDebugOut(TEXT("In IOIPS::Scroll\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIDeactivate
//
// Purpose:
//
//      Called by the object when its UI goes away
//
// Parameters:
//
//       BOOL fUndoable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleAPP::QueryNewPalette APP.CPP
//      CSimpleAPP::AddFrameLevelUI APP.CPP
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIDeactivate (BOOL fUndoable)
{
    TestDebugOut(TEXT("In IOIPS::OnUIDeactivate\r\n"));

    // need to clear this flag first
    m_pSite->m_lpDoc->m_fInPlaceActive = FALSE;
    m_pSite->m_fInPlaceActive = FALSE;

    m_pSite->m_lpDoc->m_lpApp->QueryNewPalette();
    m_pSite->m_lpDoc->m_lpApp->AddFrameLevelUI();
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceDeactivate
//
// Purpose:
//
//      Called when the inplace session is over
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IOleInPlaceObject::Release  Object
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceDeactivate ()
{
    TestDebugOut(TEXT("In IOIPS::OnInPlaceDeactivate\r\n"));

    if (m_pSite->m_lpInPlaceObject)
    {
        m_pSite->m_lpInPlaceObject->Release();
        m_pSite->m_lpInPlaceObject = NULL;
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::DiscardUndoState
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DiscardUndoState ()
{
    TestDebugOut(TEXT("In IOIPS::DiscardUndoState\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::DeactivateAndUndo
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DeactivateAndUndo ()
{
    TestDebugOut(TEXT("In IOIPS::DeactivateAndUndo\r\n"));
    return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnPosRectChange
//
// Purpose:
//
//      The object calls this method when it's size changes during an
//      InPlace Session
//
// Parameters:
//
//      LPCRECT lprcPosRect -   The new object rect
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      GetClientRect                       Windows API
//      IOleObject::GetExtent               Object
//      IOleInPlaceObject::SetObjectRects   Object
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnPosRectChange (LPCRECT lprcPosRect)
{
    TestDebugOut(TEXT("In IOIPS::OnPosRectChange\r\n"));

    // update the size in the document object
    // NOTE: here we must call IOleObject::GetExtent to get actual extents
    //       of the running object. IViewObject2::GetExtent returns the
    //       last cached extents.
    m_pSite->m_lpOleObject->GetExtent(DVASPECT_CONTENT, &m_pSite->m_sizel);
    RECT rect;
    GetClientRect(m_pSite->m_lpDoc->m_hDocWnd, &rect);

    // tell the object its new size
    m_pSite->m_lpInPlaceObject->SetObjectRects(lprcPosRect, &rect);

    return ResultFromScode(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\iocs.cpp ===
//**********************************************************************
// File name: IOCS.CPP
//
//      Implementation file for COleClientSite
//
// Functions:
//
//      See IOCS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"


//**********************************************************************
//
// COleClientSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      E_NOINTERFACE       -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::QueryInterface SITE.CPP
//
//
//********************************************************************

STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In IOCS::QueryInterface\r\n"));

    // delegate to the container Site
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleClientSite::AddRef
//
// Purpose:
//
//      Increments the reference count of CSimpleSite. Since COleClientSite
//      is a nested class of CSimpleSite, we don't need to have a separate
//      reference count for COleClientSite. We can safely use the reference
//      count of CSimpleSite.
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::AddRef         SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::AddRef()
{
    TestDebugOut(TEXT("In IOCS::AddRef\r\n"));

    // delegate to the container Site
    return m_pSite->AddRef();
}


//**********************************************************************
//
// COleClientSite::Release
//
// Purpose:
//
//      Decrements the reference count of CSimpleSite. Since COleClientSite
//      is a nested class of CSimpleSite, we don't need to have a separate
//      reference count for COleClientSite. We can safely use the reference
//      count of CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Release        SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::Release()
{
    TestDebugOut(TEXT("In IOCS::Release\r\n"));

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// COleClientSite::SaveObject
//
// Purpose:
//
//      Called by the object when it wants to be saved to persistant
//      storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleObject::QueryInterface          Object
//      IPersistStorage::SaveCompleted      Object
//      IPersistStorage::Release            Object
//      OleSave                             OLE API
//      GetScode                            OLE API
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::SaveObject()
{
    LPPERSISTSTORAGE lpPS;
    SCODE sc = E_FAIL;

    TestDebugOut(TEXT("In IOCS::SaveObject\r\n"));

    // get a pointer to IPersistStorage
    HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(IID_IPersistStorage,
                                                        (LPVOID FAR *)&lpPS);

    // save the object
    if (hErr == NOERROR)
    {
        sc = GetScode( OleSave(lpPS, m_pSite->m_lpObjStorage, TRUE) );
        lpPS->SaveCompleted(NULL);
        lpPS->Release();
    }

    return ResultFromScode(sc);
}

//**********************************************************************
//
// COleClientSite::GetMoniker
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      DWORD  dwAssign         -   type of moniker to return
//      DWORD  dwWhichMoniker   -   which moniker to return
//
// Return Value:
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    TestDebugOut(TEXT("In IOCS::GetMoniker\r\n"));

    // need to null the out pointer
    *ppmk = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::GetContainer
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPOLECONTAINER  FAR * ppContainer  -  where IOleContainer interface
//                                            pointer to be returned
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    TestDebugOut(TEXT("In IOCS::GetContainer\r\n"));

    // NULL the out pointer
    *ppContainer = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::ShowObject
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NOERROR
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::ShowObject()
{
    TestDebugOut(TEXT("In IOCS::ShowObject\r\n"));
    return NOERROR;
}

//**********************************************************************
//
// COleClientSite::OnShowWindow
//
// Purpose:
//
//      Object calls this method when it is opening/closing non-InPlace
//      Window
//
// Parameters:
//
//      BOOL fShow  - TRUE if Window is opening, FALSE if closing
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      BringWindowToTop            Windows API
//      SetFocus                    Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
    TestDebugOut(TEXT("In IOCS::OnShowWindow\r\n"));
    m_pSite->m_fObjectOpen = fShow;
    InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);

    // if object window is closing, then bring container window to top
    if (! fShow)
    {
        BringWindowToTop(m_pSite->m_lpDoc->m_hDocWnd);
        SetFocus(m_pSite->m_lpDoc->m_hDocWnd);
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleClientSite::RequestNewObjectLayout
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::RequestNewObjectLayout()
{
    TestDebugOut(TEXT("In IOCS::RequestNewObjectLayout\r\n"));
    return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <ole2.h>
#include <ole2ui.h>
#include <assert.h>
#include <string.h>
#include "simpcntr.h"
#include "resource.h"

extern "C" void TestDebugOut(LPSTR psz);



#ifndef WIN32
/* Since OLE is part of the operating system in Win32, we don't need to
 * check the version number in Win32.
 */
#include <ole2ver.h>
#endif  // WIN32


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\pre.cpp ===
//**********************************************************************
// File name: pre.cpp
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SIMPCNTR.RC
//
#define IDM_OPEN                        102
#define IDM_SAVE                        103
#define IDM_SAVEAS                      104
#define IDM_PRINT                       105
#define IDM_EXIT                        106
#define IDM_UNDO                        107
#define IDM_CUT                         108
#define IDM_COPY                        109
#define IDM_PASTE                       110
#define ID_EDIT_INSERTOBJECT            111
#define IDM_INSERTOBJECT                111
#define IDM_NEW                         112
#define IDM_DEACTIVATE                  113
#define IDM_UTEST                       998

#define SIMPCNTR_ACCEL_CNT              3

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         113
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\ioips.h ===
//**********************************************************************
// File name: IOIPS.H
//
//      Definition of COleInPlaceSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOIPS_H_ )
#define _IOIPS_H_


class CSimpleSite;

interface COleInPlaceSite : public IOleInPlaceSite
{
    CSimpleSite FAR * m_pSite;

    COleInPlaceSite(CSimpleSite FAR *pSite)
       {
        TestDebugOut(TEXT("In IOIPS's constructor\r\n"));
        m_pSite = pSite;
       };

    ~COleInPlaceSite()
       {
        TestDebugOut(TEXT("In IOIPS;s destructor\r\n"));
       };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP GetWindow (HWND FAR* lphwnd);
    STDMETHODIMP ContextSensitiveHelp (BOOL fEnterMode);

    // *** IOleInPlaceSite methods ***
    STDMETHODIMP CanInPlaceActivate ();
    STDMETHODIMP OnInPlaceActivate ();
    STDMETHODIMP OnUIActivate ();
    STDMETHODIMP GetWindowContext (LPOLEINPLACEFRAME FAR* lplpFrame,
                                   LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                                   LPRECT lprcPosRect,
                                   LPRECT lprcClipRect,
                                   LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHODIMP Scroll (SIZE scrollExtent);
    STDMETHODIMP OnUIDeactivate (BOOL fUndoable);
    STDMETHODIMP OnInPlaceDeactivate ();
    STDMETHODIMP DiscardUndoState ();
    STDMETHODIMP DeactivateAndUndo ();
    STDMETHODIMP OnPosRectChange (LPCRECT lprcPosRect);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\simpcntr.cpp ===
//**********************************************************************
// File name: Simple.cpp
//
//      Main source file for the Simple OLE 2.0 object container
//
// Functions:
//
//      WinMain         - Program entry point
//      MainWndProc     - Processes messages for the frame window
//      About           - Processes messages for the about dialog
//      DocWndProc      - Processes messages for the doc window
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "tests.h"

// This line is needed for the debug utilities in OLE2UI
extern "C" {
    OLEDBGDATA_MAIN(TEXT("SIMPCNTR"))
}

CSimpleApp FAR * lpCSimpleApp;

void DeactivateIfActive(HWND hWnd)
{
    LPOLEINPLACEOBJECT lpObject;
    MSG msg;
    msg.message = WM_LBUTTONDOWN;


    if (lpCSimpleApp->m_lpDoc->m_fInPlaceActive)
    {
        // We are in the process of deactiving the in place object
        lpCSimpleApp->m_fDeactivating = TRUE;

        lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject->QueryInterface(
                            IID_IOleInPlaceObject, (LPVOID FAR *)&lpObject);
        lpObject->UIDeactivate();

        // this code is needed because we don't support inside out.
        RECT rect;
        lpCSimpleApp->m_lpDoc->m_lpSite->GetObjRect(&rect);
        lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                           OLEIVERB_HIDE,
                           &msg,
                           &lpCSimpleApp->m_lpDoc->m_lpSite->m_OleClientSite,
                           -1, hWnd, &rect);

        lpObject->Release();

        // We are done deactiving
        lpCSimpleApp->m_fDeactivating = FALSE;
    }

}


BOOL fBeVerbose = FALSE;
extern "C"
void TestDebugOut(LPSTR psz)
{
    if (fBeVerbose)
    {
	OutputDebugStringA(psz);
    }
}


//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::CSimpleApp          APP.CPP
//      CSimpleApp::AddRef              APP.CPP
//      CSimpleApp::Release             APP.CPP
//      CSimpleApp::fInitApplication    APP.CPP
//      CSimpleApp::fInitInstance       APP.CPP
//      CSimpleApp::HandleAccelerators  APP.CPP
//      CSimpleApp::~CSimpleApp         APP.CPP
//      OleUIInitialize                 OLE2UI
//      OleUIUninitialize               OLE2UI
//      GetMessage                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
//********************************************************************
int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
#endif
{
    MSG msg;

    // needed for LRPC to work properly...
    SetMessageQueue(96);

    lpCSimpleApp = new CSimpleApp;
    fBeVerbose = GetProfileInt("OLEUTEST","BeVerbose",0);

    if(fBeVerbose == 0)
    {
	fBeVerbose = GetProfileInt("OLEUTEST","simpcntr",0);
    }

    if (!lpCSimpleApp)
    {
       /* memory allocation error. cannot carry on.
        */
       return(FALSE);
    }

    // we will add one ref count on our App. later when we want to destroy
    // the App object we will release this  ref count. when the App's ref
    // count goes to 0, it will be deleted.
    lpCSimpleApp->AddRef();

    char *pszTemp;

    // process the command line
    if( (pszTemp = strstr(lpCmdLine, "-driver")) )
    {
    	//we were launched by the test driver
	lpCSimpleApp->m_hDriverWnd = (HWND)strtoul(pszTemp+8, NULL, 10);
    }

    // app initialization
    if (!hPrevInstance)
        if (!lpCSimpleApp->fInitApplication(hInstance))
        {
            lpCSimpleApp->Release();
            return (FALSE);
        }

    // instance initialization
    if (!lpCSimpleApp->fInitInstance(hInstance, nCmdShow))
    {
        lpCSimpleApp->Release();
        return (FALSE);
    }

    /* Initialization required for OLE 2 UI library.  This call is
    **    needed ONLY if we are using the static link version of the UI
    **    library. If we are using the DLL version, we should NOT call
    **    this function in our application.
    **    The 3rd and 4th parameters passed the OleUIInitialize
    **    function are strings which are used to name two custom
    **    control classes used by the OLE2UI library. These strings
    **    must be unique for each application that uses the OLE2UI
    **    library. These strings are typically composed by combining
    **    the APPNAME with a suffix in order to be unique for a
    **    particular application. The special symbols "SZCLASSICONBOX"
    **    and "SZCLASSRESULTIMAGE" are used define these strings. These
    **    symbols must be defined in a header file that is included
    **    both in this file AND the resource file that included the
    **    "OLE2UI.RC" resoure file. These symbols should be used in the
    **    call to OleUIInitialize and are referenced in the INSOBJ.DLG
    **    and PASTESPL.DLG resouce files of the OLE2UI library.
    */
#if 0   //  We use the DLL form of OLE2U32A
    if (!OleUIInitialize(hInstance, hPrevInstance, TEXT(SZCLASSICONBOX),
                         TEXT(SZCLASSRESULTIMAGE)))
    {
        OleDbgOut(TEXT("Could not initialize OLEUI library\n"));
        lpCSimpleApp->Release();
        return FALSE;
    }
#endif

    // message loop
    while (GetMessage(&msg, NULL, NULL, NULL))
        if (!lpCSimpleApp->HandleAccelerators(&msg))
        {
            TranslateMessage(&msg);    /* Translates virtual key codes */
            DispatchMessage(&msg);     /* Dispatches message to window */
        }


#if 0   //  We use the DLL form of OLE2U32A
    // De-initialization for UI libraries.  Just like OleUIInitialize, this
    // funciton is needed ONLY if we are using the static link version of the
    // OLE UI library.
    OleUIUninitialize();
#endif

    // Release the ref count added on the App above. this will make
    // the App's ref count go to 0, and the App object will be deleted.
    lpCSimpleApp->Release();

    return (msg.wParam);         /* Returns the value from PostQuitMessage */
}


//**********************************************************************
//
// MainWndProc
//
// Purpose:
//
//      Processes messages for the frame window
//
// Parameters:
//
//      HWND hWnd       - Window handle for frame window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      long
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::lCommandHandler     APP.CPP
//      CSimpleApp::DestroyDocs         APP.CPP
//      CSimpleApp::lCreateDoc          APP.CPP
//      CSimpleApp::lSizeHandler        APP.CPP
//      CSimpleDoc::lAddVerbs           DOC.CPP
//      CSimpleDoc::QueryNewPalette     APP.CPP
//      SendMessage                     Windows API
//      PostQuitMessage                 Windows API
//      DefWindowProc                   Windows API
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message,
                                   WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_CLOSE:
            DestroyWindow(lpCSimpleApp->m_hAppWnd);
            break;

        case WM_TEST1:
            // Do the unit test
            Test1(lpCSimpleApp);
            break;

        case WM_SETFOCUS:
            // If we have an inplace application it needs to get the focus
            if (lpCSimpleApp->m_lpDoc->m_fInPlaceActive
                && !lpCSimpleApp->m_fDeactivating)
            {
                SetFocus(lpCSimpleApp->m_hwndUIActiveObj);
                break;
            }

            // Othewise default behavior is enough
            return (DefWindowProc(hWnd, message, wParam, lParam));

        case WM_COMMAND:           // message: command from application menu
            return lpCSimpleApp->lCommandHandler(hWnd, message,
                                                 wParam, lParam);
            break;

        case WM_CREATE:
            return lpCSimpleApp->lCreateDoc(hWnd, message, wParam, lParam);
            break;

        case WM_DESTROY:                  // message: window being destroyed
            lpCSimpleApp->DestroyDocs();  // need to destroy the doc...
            PostQuitMessage(0);
            break;

        case WM_INITMENUPOPUP:
            // is this the edit menu?
            if ( LOWORD(lParam) == 1)
                return lpCSimpleApp->m_lpDoc->lAddVerbs();

            break;

        // this code is needed for 256 color objects to work properly.
        case WM_QUERYNEWPALETTE:
            if (! lpCSimpleApp->m_fAppActive)
                return 0L;

            return lpCSimpleApp->QueryNewPalette();


	case WM_PALETTECHANGED:
        {
			  HWND hWndPalChg = (HWND) wParam;
			
			  if (hWnd != hWndPalChg)
				  wSelectPalette(hWnd, lpCSimpleApp->m_hStdPal,
                             TRUE/*fBackground*/);

			/* OLE2NOTE: always forward the WM_PALETTECHANGED message (via
			**    SendMessage) to any in-place objects that currently have
			**    their window visible. this gives these objects the chance
			**    to select their palettes. this is
			**    REQUIRED by all in-place containers independent of
			**    whether they use color palettes themselves--their objects
			**    may use color palettes.
			**    (see ContainerDoc_ForwardPaletteChangedMsg for more info)
			*/
			  if (lpCSimpleApp->m_lpDoc && lpCSimpleApp->m_lpDoc->m_lpSite &&
                   lpCSimpleApp->m_lpDoc->m_lpSite->m_hwndIPObj)
           {
                SendMessage(lpCSimpleApp->m_lpDoc->m_lpSite->m_hwndIPObj,
                        WM_PALETTECHANGED, wParam, lParam);
           }

           return 0L;
        }

        case WM_ACTIVATEAPP:
            if ((lpCSimpleApp->m_fAppActive = (BOOL)wParam) == TRUE)
                lpCSimpleApp->QueryNewPalette();

            if (lpCSimpleApp->m_lpDoc->m_lpActiveObject)
            {
               lpCSimpleApp->m_lpDoc->m_lpActiveObject->OnFrameWindowActivate(
                        (BOOL)wParam);
            }
            break;

        case WM_SIZE:
            return lpCSimpleApp->lSizeHandler(hWnd, message, wParam, lParam);

        default:                          // Passes it on if unproccessed
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}


//**********************************************************************
//
// About
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for dialog box
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//      TRUE if message processed, FALSE otherwise
//
// Function Calls:
//      Function                    Location
//
//      EndDialog                   Windows API
//
//
//********************************************************************

INT_PTR FAR PASCAL EXPORT About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)

{
    switch (message)
    {
    case WM_INITDIALOG:               /* message: initialize dialog box */
        return (TRUE);

    case WM_COMMAND:                  /* message: received a command */
        if (wParam == IDOK            /* "OK" box selected?          */
            || wParam == IDCANCEL)    /* System menu close command?  */
        {
           EndDialog(hDlg, TRUE);     /* Exits the dialog box        */
           return (TRUE);
        }
        break;
    }
    return (FALSE);                   /* Didn't process a message    */
}

//**********************************************************************
//
// DocWndProc
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for doc window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//      NULL
//
// Function Calls:
//      Function                            Location
//
//      CSimpleApp::PaintApp                APP.CPP
//      BeginPaint                          Windows API
//      EndPaint                            Windows API
//      DefWindowProc                       Windows API
//      PtInRect                            Windows API
//      CSimpleSite::GetObjRect             SITE.CPP
//      IOleObject::QueryInterface          Object
//      IOleInPlaceObject::UIDeactivate     Object
//      IOleObject::DoVerb                  Object
//      IOleInPlaceObject::Release          Object
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message,
                                  WPARAM wParam, LPARAM lParam)
{
    HDC hDC;
    PAINTSTRUCT ps;

    switch (message)
    {
        case WM_SETFOCUS:
            // If we have an inplace application it needs to get the focus
            if (lpCSimpleApp->m_lpDoc->m_fInPlaceActive
                && !lpCSimpleApp->m_fDeactivating)
            {
                SetFocus(lpCSimpleApp->m_hwndUIActiveObj);
                break;
            }

            // Otherwise default behavior is enough
            return (DefWindowProc(hWnd, message, wParam, lParam));

        case WM_PAINT:

            hDC = BeginPaint(hWnd, &ps);

            if (lpCSimpleApp)
                lpCSimpleApp->PaintApp (hDC);

            EndPaint(hWnd, &ps);
            break;


        case WM_LBUTTONDBLCLK:
        {
            POINT pt;

            pt.x = (int)(short)LOWORD (lParam );
            pt.y = (int)(short)HIWORD (lParam );

            if (lpCSimpleApp->m_lpDoc->m_lpSite &&
                lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject)
            {
                RECT rect;

                lpCSimpleApp->m_lpDoc->m_lpSite->GetObjRect(&rect);

                if ( PtInRect(&rect, pt) )
                {
                    // Execute object's default verb
                    lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                            OLEIVERB_PRIMARY, (LPMSG)&message,
                            &lpCSimpleApp->m_lpDoc->m_lpSite->m_OleClientSite,
                            -1, hWnd, &rect);
                }
            }
        }
            break;

    // no code is added to WM_LBUTTONDOWN for context sensitive help, because
    // this app does not do context sensitive help.

        case WM_LBUTTONDOWN:
           DeactivateIfActive(hWnd);
           break;
	
    	  default:                        /* Passes it on if unproccessed */
        	  return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\simpcntr.h ===
//**********************************************************************
// File name: simple.h
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#define IDM_ABOUT 100
#define IDM_INSERT  101
#define IDM_VERB0 1000

int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#endif

BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);
LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef WIN32
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#else
BOOL FAR PASCAL EXPORT About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#endif


/* These strings are used to name two custom control classes used by
**    the OLE2UI library. These strings must be unique for each
**    application that uses the OLE2UI library. These strings should be
**    composed by combining the APPNAME with a suffix in order to be
**    unique for a particular application. The special symbols
**    "SZCLASSICONBOX" and "SZCLASSRESULTIMAGE" are used define these
**    strings. These symbols are passed in the OleUIInitialize call and
**    are referenced in the INSOBJ.DLG and PASTESPL.DLG resouce files
**    of the OLE2UI library.
*/
#define SZCLASSICONBOX "simpcntrIBClass"
#define SZCLASSRESULTIMAGE "simpcntrRIClass"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\site.h ===
//**********************************************************************
// File name: SITE.H
//
//      Definition of CSimpleSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _SITE_H_ )
#define _SITE_H_

#include <ole2.h>
#include "ias.h"
#include "ioips.h"
#include "iocs.h"

class CSimpleDoc;

class CSimpleSite : public IUnknown
{
public:
    int m_nCount;
    DWORD m_dwConnection;
    LPOLEOBJECT m_lpOleObject;
    LPOLEINPLACEOBJECT m_lpInPlaceObject;
    HWND m_hwndIPObj;
    DWORD m_dwDrawAspect;
    SIZEL m_sizel;
    BOOL m_fInPlaceActive;
    BOOL m_fObjectOpen;
    LPSTORAGE m_lpObjStorage;

    CAdviseSink m_AdviseSink;
    COleInPlaceSite m_OleInPlaceSite;
    COleClientSite m_OleClientSite;

    CSimpleDoc FAR * m_lpDoc;

    // IUnknown Interfaces
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    void InitObject(BOOL fCreateNew);
    static CSimpleSite FAR * Create(CSimpleDoc FAR *lpDoc);
    CSimpleSite(CSimpleDoc FAR *lpDoc);
    ~CSimpleSite();
    void PaintObj(HDC hDC);
    void GetObjRect(LPRECT lpRect);
    void CloseOleObject(void);
    void UnloadOleObject(void);
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\tests.h ===
#ifndef _TESTS_H_
#define _TESTS_H_

#include <testmess.h>

void Test1(CSimpleApp *pApp);

#endif // _TESTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\utaccel.h ===
#ifndef _UTACCEL_H_
#define _UTACCEL_H_

#define SIMPCNTR_UT_ACCEL   1
#define SIMPSVR_UT_ACCEL    3

#endif // _UTACCEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\tests.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   	tests.cpp
//
//  Contents:	Implementations of the Upper Layer unit tests for Inplace
//
//  Classes:
//
//  Functions: 	Test1
//
//  History:    dd-mmm-yy Author    Comment
//		27-Apr-94 ricksa    author
//
//--------------------------------------------------------------------------

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "tests.h"
#include "utaccel.h"

const CLSID CLSID_SimpleServer = {0xbcf6d4a0, 0xbe8c, 0x1068, { 0xb6, 0xd4,
	0x00, 0xdd, 0x01, 0x0c, 0x05, 0x09 }};

const TCHAR *pszErrorTitle = TEXT("Unit Test FAILURE");

//+-------------------------------------------------------------------------
//
//  Function:   TestMsgPostThread
//
//  Synopsis:   We use this thread to post messages to the inplace server
//
//  Arguments:  [pvApp] - application object
//
//  Algorithm:  Post key board message for the accelerator for the container
//              and wait 3 seconds to see if we get response. If we do, then
//              continue by posting an accelerator to the embeddinging and
//              waiting three seconds for a response. Finally post messages
//              to everyone telling them the test is over.
//
//  History:    dd-mmm-yy Author    Comment
//              02-May-94 ricksa    author
//
//  Notes:      
//
//--------------------------------------------------------------------------
extern "C" DWORD TestMsgPostThread(void *pvApp)
{
    CSimpleApp *pApp = (CSimpleApp *) pvApp;
    HRESULT hr = ResultFromScode(E_UNEXPECTED);

    // Send an accelerator bound for the container
    PostMessage(pApp->m_hwndUIActiveObj, WM_CHAR, SIMPCNTR_UT_ACCEL, 1);

    // Give 6 seconds for chance to process an accelerator
    for (int i = 0; i < 6; i++)
    {
        // Get embedding and container a chance to process the accelerator
        Sleep(1000);

        // See if it got processed
        if (pApp->m_fGotUtestAccelerator)
        {
            break;
        }
    }

    if (pApp->m_fGotUtestAccelerator)
    {
        hr = S_OK;
    }
    else
    {
        // The container did not received the accelerator
        MessageBox(pApp->m_hAppWnd,
            TEXT("Container didn't recieve accelerator"),
                pszErrorTitle, MB_OK);
    }

    PostMessage(pApp->m_hDriverWnd, WM_TESTEND,
        SUCCEEDED(hr) ? TEST_SUCCESS : TEST_FAILURE, (LPARAM) hr);

    PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);

    return 0;
}




//+-------------------------------------------------------------------------
//
//  Function:	Test1
//
//  Synopsis:   Inserts an inplace object into this container
//
//  Arguments:	pApp	-- a pointer to the CSimpleApp that we're a part of  
//
//  Algorithm:  Create a simple server object. Activate the simple server
//              object. Send the container an accelerator and confirm that
//              the accelerator worked. Send the object an accelerator and
//              make sure that that accelerator worked. Then return the
//              result of the test to the test driver.
//
//  History:    dd-mmm-yy Author    Comment
//              27-Apr-94 ricksa    author
//
//  Notes:      
//
//--------------------------------------------------------------------------
void Test1(CSimpleApp *pApp)
{
    // Create the inplace object
    HRESULT hr;
    static FORMATETC formatetc;

    //insert the simple server object

    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.cfFormat = NULL;
    formatetc.lindex = -1;

    //need to create the client site

    pApp->m_lpDoc->m_lpSite = CSimpleSite::Create(pApp->m_lpDoc);

    hr = OleCreate(
                CLSID_SimpleServer,
                IID_IOleObject,
		OLERENDER_DRAW,
                &formatetc,
		&pApp->m_lpDoc->m_lpSite->m_OleClientSite,
		pApp->m_lpDoc->m_lpSite->m_lpObjStorage, 
		(void **) &(pApp->m_lpDoc->m_lpSite->m_lpOleObject));

    if(hr == NOERROR)
    {
        // Activate the inplace object
        pApp->m_lpDoc->m_lpSite->InitObject(TRUE);

        // Default to unexpected failure
        hr = ResultFromScode(E_UNEXPECTED);

        if (pApp->m_lpDoc->m_fInPlaceActive)
        {
            // Create thread to send windows messages to container and
            // embedding
            DWORD dwThreadId;

            HANDLE hThread = CreateThread(
                NULL,               // Security attributes - default
                0,                  // Stack size - default
                TestMsgPostThread,  // Addresss of thread function
                pApp,               // Parameter to thread
                0,                  // Flags - run immediately
                &dwThreadId);       // Thread ID returned - unused.

            if (hThread != NULL)
            {
                // Thread was created so tell routine & dump handle
                // we won't use.
                hr = S_OK;
                CloseHandle(hThread);
            }
            else
            {
                // The container did not received the accelerator
                MessageBox(pApp->m_hAppWnd,
                    TEXT("Could not create message sending thread"),
                        pszErrorTitle, MB_OK);
            }
        }
        else
        {
            // The object did not get activated in place
            MessageBox(pApp->m_hAppWnd, TEXT("Could not activate in place"),
                pszErrorTitle, MB_OK);
        }
    }
    else
    {
        // We could not create the object
        MessageBox(pApp->m_hAppWnd, TEXT("Could not create embedding"),
            pszErrorTitle, MB_OK);
    }

    if (FAILED(hr))
    {
        PostMessage(pApp->m_hDriverWnd, WM_TESTEND,
            SUCCEEDED(hr) ? TEST_SUCCESS : TEST_FAILURE, (LPARAM) hr);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\enumfetc.h ===
// This file is now OBSOLETE (include olestd.h instead)

/*************************************************************************
** 
**    OLE 2 Utility Code
**    
**    enumfetc.c
**    
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

// Function prototypes moved to olestd.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpcntr\site.cpp ===
//**********************************************************************
// File name: SITE.CPP
//
//      Implementation file for CSimpleSite
//
// Functions:
//
//      See SITE.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "ioipf.h"
#include "ioips.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CSimpleSite::Create
//
// Purpose:
//
//      Creation routine for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::CSimpleSite    SITE.CPP
//      IStorage::CreateStorage     OLE API
//      CSimpleSite::AddRef         SITE.CPP
//      assert                      C Runtime
//
//
//********************************************************************

CSimpleSite FAR * CSimpleSite::Create(CSimpleDoc FAR *lpDoc)
{
    CSimpleSite FAR * lpTemp = new CSimpleSite(lpDoc);

    if (!lpTemp)
        return NULL;

    // create a sub-storage for the object
    HRESULT hErr = lpDoc->m_lpStorage->CreateStorage( OLESTR("Object"),
                STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &lpTemp->m_lpObjStorage);

    assert(hErr == NOERROR);

    if (hErr != NOERROR)
    {
        delete lpTemp;
        return NULL;
    }

    // we will add one ref count on our Site. later when we want to destroy
    // the Site object we will release this  ref count. when the Site's ref
    // count goes to 0, it will be deleted.
    lpTemp->AddRef();

    return lpTemp;
}

//**********************************************************************
//
// CSimpleSite::CSimpleSite
//
// Purpose:
//
//      Constructor for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                 // tells us that we are passing this in
                                 // an initializer, before "this" is through
                                 // initializing.  This is ok, because
                                 // we just store the ptr in the other
                                 // constructors

CSimpleSite::CSimpleSite (CSimpleDoc FAR *lpDoc) : m_OleClientSite(this),
                                                   m_AdviseSink(this),
                                                   m_OleInPlaceSite(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
    TestDebugOut (TEXT("In CSimpleSite's Constructor \r\n"));

    // remember the pointer to the doc
    m_lpDoc = lpDoc;

    // clear the reference count
    m_nCount = 0;

	 m_dwDrawAspect = DVASPECT_CONTENT;
    m_lpOleObject = NULL;
    m_lpInPlaceObject = NULL;
    m_hwndIPObj = NULL;
    m_fInPlaceActive = FALSE;
    m_fObjectOpen = FALSE;
}

//**********************************************************************
//
// CSimpleSite::~CSimpleSite
//
// Purpose:
//
//      Destructor for CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
//
//********************************************************************

CSimpleSite::~CSimpleSite ()
{
    TestDebugOut (TEXT("In CSimpleSite's Destructor \r\n"));

    if (m_lpOleObject)
       m_lpOleObject->Release();

    if (m_lpObjStorage)
       m_lpObjStorage->Release();
}


//**********************************************************************
//
// CSimpleSite::CloseOleObject
//
// Purpose:
//
//      Call IOleObject::Close on the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::QueryInterface              Object
//      IOleObject::Close                       Object
//      IOleInPlaceObject::UIDeactivate         Object
//      IOleInPlaceObject::InPlaceDeactivate    Object
//      IOleInPlaceObject::Release              Object
//
//
//********************************************************************

void CSimpleSite::CloseOleObject (void)
{
    LPOLEINPLACEOBJECT lpObject;
    LPVIEWOBJECT lpViewObject = NULL;

    TestDebugOut (TEXT("In CSimpleSite::CloseOleObject \r\n"));

    if (m_lpOleObject)
    {
       if (m_fInPlaceActive)
       {
           m_lpOleObject->QueryInterface(IID_IOleInPlaceObject,
                                         (LPVOID FAR *)&lpObject);
           lpObject->UIDeactivate();
           // don't need to worry about inside-out because the object
           // is going away.
           lpObject->InPlaceDeactivate();
           lpObject->Release();
       }

       m_lpOleObject->Close(OLECLOSE_NOSAVE);
    }
}


//**********************************************************************
//
// CSimpleSite::UnloadOleObject
//
// Purpose:
//
//      Close and release all pointers to the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpleSite::CloseOleObject             SITE.CPP
//      IOleObject::QueryInterface              Object
//      IOleObject::Release                     Object
//      IViewObject::SetAdvise                  Object
//      IViewObject::Release                    Object
//
//
//********************************************************************

void CSimpleSite::UnloadOleObject (void)
{
    TestDebugOut (TEXT("In CSimpleSite::UnloadOleObject \r\n"));

    if (m_lpOleObject)
    {
       LPVIEWOBJECT lpViewObject;
       CloseOleObject();    // ensure object is closed; NOP if already closed

       m_lpOleObject->QueryInterface(IID_IViewObject,
                                     (LPVOID FAR *)&lpViewObject);

       if (lpViewObject)
       {
           // Remove the view advise
           lpViewObject->SetAdvise(m_dwDrawAspect, 0, NULL);
           lpViewObject->Release();
       }

       m_lpOleObject->Release();
       m_lpOleObject = NULL;
    }
}


//**********************************************************************
//
// CSimpleSite::QueryInterface
//
// Purpose:
//
//      Used for inte