\\")

//------ This NUMBER have to be changed when GPC file (or FMPR.RC) is modified.
#define DMBIN_180BIN1			269
#define DMBIN_180BIN2			270
#define DMBIN_360BIN1			271
#define DMBIN_360BIN2			272
#define DMBIN_FI_TRACTOR		273      // Tractor (FI2 FMPR-359F1)
#define DMBIN_FI_FRONT			274      // Front inserter (FI2 FMPR-359F1)
#define DMBIN_SUIHEI_BIN1		275      // Suihei printer BIN1 (FMPR601)
#define DMBIN_TAMOKUTEKI_BIN1	276      // Tamokuteki printer BIN1 (FMPR671, 654)

// NTRAID#NTBUG9-588420-2002/04/09-yasuho-: Device "Mincho" can not print out.
#define TEXT_COLOR_UNKNOWN 0
#define TEXT_COLOR_YELLOW  1
#define TEXT_COLOR_MAGENTA 2
#define TEXT_COLOR_RED     (TEXT_COLOR_YELLOW|TEXT_COLOR_MAGENTA)
#define TEXT_COLOR_CYAN    4
#define TEXT_COLOR_GREEN   (TEXT_COLOR_YELLOW|TEXT_COLOR_CYAN)
#define TEXT_COLOR_BLUE    (TEXT_COLOR_MAGENTA|TEXT_COLOR_CYAN)
#define TEXT_COLOR_BLACK   8
#define TEXT_COLOR_BANDW   (0xFF)       // for monochrome case

VOID
SetRibbonColor(
    PDEVOBJ pdevobj,
    BYTE jColor);

//
// Minidriver device data block which we maintain.
// Its address is saved in the DEVOBJ.pdevOEM of
// OEM customiztion I/F.
//

typedef struct {
    VOID *pData; // Minidriver private data.
    VOID *pIntf; // a.k.a. pOEMHelp
} MINIDEV;

//
// Easy access to the OEM data and the printer
// driver helper functions.
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

    extern
    HRESULT
    XXXDrvWriteSpoolBuf(
        VOID *pIntf,
        PDEVOBJ pDevobj,
        PVOID pBuffer,
        DWORD cbSize,
        DWORD *pdwResult);

#ifdef __cplusplus
}
#endif // __cplusplus

#define MINIDEV_DATA(p) \
    (((MINIDEV *)(p)->pdevOEM)->pData)

#define MINIDEV_INTF(p) \
    (((MINIDEV *)(p)->pdevOEM)->pIntf)

#define WRITESPOOLBUF(p, b, n, r) \
    XXXDrvWriteSpoolBuf(MINIDEV_INTF(p), (p), (b), (n), (r))

#ifdef __cplusplus
	extern "C" {
#endif // __cplusplus
	BOOL	myOEMOutputCharStr( PDEVOBJ pdevobj,PUNIFONTOBJ pUFObj,DWORD dwType,DWORD dwCount,PVOID pGlyph );
#ifdef __cplusplus
	}
#endif // __cplusplus

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuband.h ===
//
// fuband.h
//
// August.26,1997 H.Ishida(FPL)
// fjxlres.dll (NT5.0 MiniDriver)
// 
// July.31,1996 H.Ishida (FPL)
// FUXL.DLL (NT4.0 MiniDriver)
//
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997


#ifndef fuband_h
#define	fuband_h

#define	OUTPUT_MH		0x0001
#define	OUTPUT_RTGIMG2	0x0002
#define	OUTPUT_MH2		0x0004
#define	OUTPUT_RTGIMG4	0x0008


void fuxlInitBand(PFUXLPDEV pFjxlPDEV);
void fuxlDisableBand(PFUXLPDEV pFjxlPDEV);

void fuxlRefreshBand(PDEVOBJ pdevobj);


#endif // !fuband_h
// end of fuband.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\comoem.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuband.c ===
//
// fuband.c
//
// August.26,1997 H.Ishida(FPL)
//  fuxlres.dll (NT5.0 MiniDriver)
//
// July.31,1996 H.Ishida (FPL)
// FUXL.DLL (NT4.0 MiniDriver)
//

#include "fuxl.h"
#include "fumh.h"
#include "fumh2.h"
#include "fuband.h"
#include "fuimg2.h"
#include "fuimg4.h"
#include "fudebug.h"



//
// FjBAND:
//     In Win-F image command(RTGIMG2 and RTGIMG4), image coordinate must
// be a multiple of 32. But I can't create such a GPC file for RasDD.
// Some image data, not on 32x32 grid, must be buffered in FjBAND,
// width:papser width, height:32, x-coordinate:0, y-coordinate:a multiple
// of 32.
// 
//  Image to be output
//     (0, y)
//          A----------------------------------+
//          |  partA                           |
//          B----------------------------------+
//          |  partB                           |
//          |                                  |
//          |                                  |
//          C----------------------------------+
//          |  partC                           |
//          D----------------------------------+
//
//  I split source image to 3 part.
//     A: top of image, is not a multiple of 32.
//     B: top of image, is a multiple of 32.
//     C: bottom of image, is a multilpe of 32.
//     D: bottom of image, is not a multile of 32.
//
//     partA: A to B. this part is buffered in FjBAND, ORed on 
//            previousely written image.
//     partB: B to C. this part is not bufferd, output immediately.
//     partC: C to D. this part is buffered in FjBAND, may be ORed
//            partA of next image.
//


#define	FUXL_BANDHEIGHT	32



//
// void fuxlInitBand(PFUXLPDEV pFuxlPDEV)      // fuxlres private PDEV
//
// This function initializes FjBAND, but not allocate memory for band.
//
void fuxlInitBand(PFUXLPDEV pFuxlPDEV)
{
	int			i;

	pFuxlPDEV->cBandByteWidth = (pFuxlPDEV->cxPage + 7) / 8;
	i = 0x10000L / pFuxlPDEV->cBandByteWidth;
	pFuxlPDEV->cyBandSegment = i - (i % FUXL_BANDHEIGHT);
	pFuxlPDEV->pbBand = NULL;
	pFuxlPDEV->cbBand = FUXL_BANDHEIGHT * pFuxlPDEV->cBandByteWidth;
	pFuxlPDEV->yBandTop = 0;
	pFuxlPDEV->bBandDirty = FALSE;
	pFuxlPDEV->bBandError = FALSE;
}



//
// BOOL fuxlEnableBand(
//      PFUXLPDEV pFuxlPDEV      // fuxlres private PDEV
// );
//
// This function allocates memory for FjBAND.
//
// Return Values
//    TRUE:  band memory is allocated.
//    FALSE: band memory is not allocated.
//
BOOL fuxlEnableBand(PFUXLPDEV pFuxlPDEV)
{
	DWORD		cbBand;

	pFuxlPDEV->pbBand = (LPBYTE)MemAllocZ(pFuxlPDEV->cbBand);
	if(pFuxlPDEV->pbBand == NULL){
		pFuxlPDEV->bBandError = TRUE;
		return FALSE;
	}
	memset(pFuxlPDEV->pbBand, 0, pFuxlPDEV->cbBand);
	pFuxlPDEV->bBandDirty = FALSE;
	return TRUE;
}


//
// void fuxlDisableBand(
//      PFUXLPDEV pFuxlPDEV   // fuxlres private PDEV
// );
//
// This function frees memory for FjBAND.
//
void fuxlDisableBand(PFUXLPDEV pFuxlPDEV)
{
	if(pFuxlPDEV->pbBand != NULL){
		MemFree(pFuxlPDEV->pbBand);
		pFuxlPDEV->pbBand = NULL;
	}
	pFuxlPDEV->bBandError = FALSE;
}



//
// void fuxlCopyBand(
//      PDEVOBJ pdevobj,   // MINI5 data
//      LPBYTE  pBuff,     // address of source image data.
//      LONG    lDelta,    // width of source image data(in bytes)
//      int     y,         // y-coordinate of source image.
//      int     cy         // height of source image data(scanline)
// );
//
// This function copies source image data to FjBAND.
//
//
void fuxlCopyBand(PDEVOBJ pdevobj, LPCBYTE pbSrc, int cSrcBandWidth, int y, int cy)
{
	PFUXLPDEV	pFuxlPDEV;
	LPCBYTE		pbSrcTmp;
	LPBYTE		pbDst;
	LPBYTE		pbDstTmp;
	int			i;
	int			j;
	UINT		uTmp;

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;

	if(pFuxlPDEV->yBandTop <= y && y + cy <= pFuxlPDEV->yBandTop + FUXL_BANDHEIGHT){
		pbDst = pFuxlPDEV->pbBand + (y - pFuxlPDEV->yBandTop) * pFuxlPDEV->cBandByteWidth;
		uTmp = 0;
		for(i = cy; i > 0; --i){
			pbDstTmp = pbDst;
			for(j = cSrcBandWidth; j > 0; --j){
				uTmp |= *pbSrc;
				*pbDstTmp++ |= *pbSrc++;
			}
			pbDst += pFuxlPDEV->cBandByteWidth;
		}
		if(uTmp != 0)
			pFuxlPDEV->bBandDirty = TRUE;
	}
}



//
// BOOL fuxlOutputMH(
//      PDEVOBJ	pdevobj   // MINI5 data
//      LPCBYTE pbSrc,    // address of source image data.
//      LONG    lDelta,   // width of source image data(in byte).
//      int     y,        // y-coordinate of source image data.
//      int     cy        // height of source image data(scanline).
// );
//
// This function outputs image, uses FM-MH(old type).
//
// Return Values
//    TRUE: output succeeded.
//    FALSE: output failed. 
//           memory allocate error, or
//           MH compression is not effecive for this image data.
//
BOOL fuxlOutputMH(PDEVOBJ pdevobj, LPCBYTE pbSrc, int cSrcBandWidth, int y, int cy)
{
	BOOL		bResult;
	LPBYTE		pDest;
	LONG		cb;
	LONG		cDestN;
	DWORD		cbMHData;
	BYTE		abTmp[10];

	bResult = FALSE;
	cb = cSrcBandWidth * cy;
	cDestN = (cb + 1) / 2;
	pDest = (LPBYTE)MemAllocZ(cDestN);
	if(pDest != NULL){
		cbMHData = (WORD)MhCompress(pDest, cDestN, (LPBYTE)pbSrc, cSrcBandWidth * cy, cSrcBandWidth, cy);
		if(cbMHData > 0){
			memcpy(abTmp, "\x1d\x30\x20\x62\x00\x00", 6);
	        abTmp[6] = HIBYTE((WORD)y);
	        abTmp[7] = LOBYTE((WORD)y);
	        abTmp[8] = HIBYTE(cbMHData);
	        abTmp[9] = LOBYTE(cbMHData);
	        WRITESPOOLBUF(pdevobj, abTmp, 10);
	        WRITESPOOLBUF(pdevobj, pDest, cbMHData);
	        WRITESPOOLBUF(pdevobj, "\x00\x00", 2 );
			bResult = TRUE;
		}
		MemFree(pDest);
	}

	return bResult;
}




//
// BOOL fuxlOutputMH2(
//      PDEVOBJ pdevobj,    // MINI5 data
//      LPCBYTE pbSrc,      // address of source image data.
//      LONG    lDelta,     // width of source image data(in byte).
//      int     y,          // y-coordinate of source image data.
//      int     cy          // height of source image data(scanline).
// );
//
// This function outputs image, uses FM-MH2(for XL-65K and after).
//
// Return Value
//    TRUE:  output succeeded.
//    FALSE: output failed. 
//           memory allocate error, or
//           MH compression is not effective for this iamge data.
//
BOOL fuxlOutputMH2(PDEVOBJ pdevobj, LPCBYTE pbSrc, int cSrcByteWidth, int y, int cy)
{
	BOOL		bResult;
	LPBYTE		pDest;
	LONG		cb;
	LONG		cDestN;
	DWORD		cbMHData;
	BYTE		abTmp[10];

	bResult = FALSE;
	cb = cSrcByteWidth * cy;
	cDestN = (cb + 1) / 2;
	pDest = (LPBYTE)MemAllocZ(cDestN);
	if(pDest != NULL){
		cbMHData = Mh2Compress(pDest, cDestN, (LPBYTE)pbSrc, cSrcByteWidth * cy, cSrcByteWidth, cy);
		if(cbMHData > 0){
			memcpy(abTmp, "\x1d\x30\x20\x62\x00\x00", 6);
	        abTmp[6] = HIBYTE((WORD)y);
	        abTmp[7] = LOBYTE((WORD)y);
	        abTmp[8] = HIBYTE(cbMHData);
	        abTmp[9] = LOBYTE(cbMHData);
	        WRITESPOOLBUF(pdevobj, abTmp, 10);
	        WRITESPOOLBUF(pdevobj, pDest, cbMHData);
	        WRITESPOOLBUF(pdevobj, "\x00\x00", 2 );
			bResult = TRUE;
		}
		MemFree(pDest);
	}

	return bResult;
}



//
// void fuxlOutputGraphics(
//      PDEVOBJ pdevobj, // MINI5
//      LPCBYTE pbSrc,   // address of source image data.
//      UINT    bx,      // width of source iamge data(in byte).
//      UINT    y,       // y-coordinate of source iamge data.
//      UINT    cy       // height of source iamge data(scanline).
// );
//
// This function outputs source iamge data.
//
void fuxlOutputGraphics(PDEVOBJ pdevobj, LPCBYTE pbSrc, int cSrcByteWidth, UINT y, UINT cy)
{
	PFUXLPDEV	pFuxlPDEV;
	DWORD		dwOutputCmd;

	TRACEOUT(("[fuxlOutputGraphics]y %d cy %d\r\n", y, cy))

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	dwOutputCmd = pFuxlPDEV->dwOutputCmd;

	if((dwOutputCmd & OUTPUT_MH2) != 0){
		TRACEOUT(("[fuxlOutputGraphics]Try MH2\r\n"))
		if(fuxlOutputMH2(pdevobj, pbSrc, cSrcByteWidth, y, cy) != FALSE)
			return;
	}
	if((dwOutputCmd & OUTPUT_RTGIMG4) != 0){
		TRACEOUT(("[fuxlOutputGraphics]Send RTGIMG4\r\n"))
		fuxlOutputRTGIMG4(pdevobj, pbSrc, cSrcByteWidth, y, cy);
		return;
	}
	if((dwOutputCmd & OUTPUT_MH) != 0){
		TRACEOUT(("[fuxlOutputGraphics]Try MH\r\n"))
		if(fuxlOutputMH(pdevobj, pbSrc, cSrcByteWidth, y, cy) != FALSE)
			return;
	}
	TRACEOUT(("[fuxlOutputGraphics]Send RTGIMG2\r\n"))
	fuxlOutputRTGIMG2(pdevobj, pbSrc, cSrcByteWidth, y, cy);
}



//
// BOOL fuxlSetBandPos(
//      PDEVOBJ pdevobj,     // MINI5 data
//      int     yPos         // y-coordinate
// );
//
// This function sets y-coordinate of FjBAND.
//
// Return Value.
//    TRUE:  secceeded
//    FALSE: failed(FjBAND can't move upward)
//
// Remarks
//    Internally, y-coordinate is adjust to a multiple of 32.
//    Then check new y-coordinate, if it is equal to previous y-coordinate,
//    the contents of FjBAND remain. Otherwise, flushes FjBAND.
//     
BOOL fuxlSetBandPos(PDEVOBJ pdevobj, int yPos)
{
	PFUXLPDEV pFuxlPDEV;
	
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	if(yPos < pFuxlPDEV->yBandTop)
		return FALSE;

	yPos -= yPos % FUXL_BANDHEIGHT;
	if(yPos != pFuxlPDEV->yBandTop){
		if(pFuxlPDEV->bBandDirty != FALSE){
			fuxlOutputGraphics(pdevobj, pFuxlPDEV->pbBand, pFuxlPDEV->cBandByteWidth, pFuxlPDEV->yBandTop, FUXL_BANDHEIGHT);
			memset(pFuxlPDEV->pbBand, 0, pFuxlPDEV->cbBand);
			pFuxlPDEV->bBandDirty = FALSE;
		}
		pFuxlPDEV->yBandTop = yPos;
	}
	return TRUE;
}



//
// void fuxlRefreshBand(
//      PDEVOBJ pdevobj        // MINI5 data
// );
//
// This function flushes FjBAND, send FormFeed command, and sets
// y-coordinate to top(0).
//
void fuxlRefreshBand(PDEVOBJ pdevobj)
{
	PFUXLPDEV pFuxlPDEV;
	
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	if(pFuxlPDEV->bBandDirty != FALSE){
		fuxlOutputGraphics(pdevobj, pFuxlPDEV->pbBand, pFuxlPDEV->cBandByteWidth, pFuxlPDEV->yBandTop, FUXL_BANDHEIGHT);
		memset(pFuxlPDEV->pbBand, 0, pFuxlPDEV->cbBand);
		pFuxlPDEV->bBandDirty = FALSE;
	}
	WRITESPOOLBUF(pdevobj, "\x0c", 1);			// FF command
	pFuxlPDEV->yBandTop = 0;
}



//
// WORD OEMFilterGraphics(
//      LPDV   lpdv,     // address of private data, used by RasDD.
//      LPBYTE lpBuf,    // address of source iamge data.
//      WORD wLen        // size of source image data.
// );
//
// This function convert image format to Printer command sequence,
// and spool it.
//
// Return Value
//   the number of bytes of processed raster data.
//   the number of bytes may be the same as wLen, but not necessarily.
//
// Remarks
//
//       | <--------------- pFuxlPDEV->cBlockWidth-----------> |
// lpBuf *--------+--------+--------+--------+--------+--------+---
//       |        |        |        |        |        |        | ^
//       +--------+--------+--------+--------+--------+--------+ |
//       |        |        |        |        |        |        | pFuxlPDEV->
//       +--------+--------+--------+--------+--------+--------+ cBlockHeight
//       |        |        |        |        |        |        | |
//       +--------+--------+--------+--------+--------+--------+ |
//       |        |        |        |        |        |        | v
//       +--------+--------+--------+--------+--------+--------+---
//
//        white dot:0
//        black dot:1
//
//        coordinate of '*' (left-top of image):
//          pFuxlPDEV->x
//          pFuxlPDEV->y
//
//

// MINI5 export
BOOL APIENTRY OEMFilterGraphics(PDEVOBJ pdevobj, LPBYTE pbBuf, DWORD dwLen)
{
	PFUXLPDEV	pFuxlPDEV;
	LPCBYTE		pbSrc;
	int			y;
	int			yAlignTop;
	int			yBottom;
	int			yAlignBottom;
	int			cSrcByteWidth;
	int			cLine;

	TRACEOUT(("[OEMFilterGraphics]\r\n"))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	if(pFuxlPDEV->pbBand == NULL){
		if(pFuxlPDEV->bBandError != FALSE)
			return FALSE;
		if(fuxlEnableBand(pFuxlPDEV) == FALSE)
			return FALSE;
	}

	pbSrc = pbBuf;
	y = pFuxlPDEV->y;
	yAlignTop = y - (y % FUXL_BANDHEIGHT);
	yBottom = y + pFuxlPDEV->cBlockHeight;
	yAlignBottom = yBottom - (yBottom % FUXL_BANDHEIGHT);
	cSrcByteWidth = pFuxlPDEV->cBlockByteWidth;

	if(yAlignTop < y){
		// partA
		if(fuxlSetBandPos(pdevobj, y) == FALSE)		// FUXL band pos can't move up
			return TRUE;
		cLine = FUXL_BANDHEIGHT - (y - yAlignTop);
		if(y + cLine >= yBottom){
			fuxlCopyBand(pdevobj, pbSrc, cSrcByteWidth, y, yBottom - y);
			return TRUE;
		}
		fuxlCopyBand(pdevobj, pbSrc, cSrcByteWidth, y, cLine);
		pbSrc += cSrcByteWidth * cLine;
		y += cLine;
	}
	if(y < yAlignBottom){
		// partB
		if(fuxlSetBandPos(pdevobj, yAlignBottom) == FALSE)		// FUXL band pos can't move up
			return TRUE;
		for(cLine = yAlignBottom - y; cLine >= pFuxlPDEV->cyBandSegment; cLine -= pFuxlPDEV->cyBandSegment){
			fuxlOutputGraphics(pdevobj, pbSrc, cSrcByteWidth, y, pFuxlPDEV->cyBandSegment);
			pbSrc += cSrcByteWidth * pFuxlPDEV->cyBandSegment;
			y += pFuxlPDEV->cyBandSegment;
		}
		if(cLine > 0){
			fuxlOutputGraphics(pdevobj, pbSrc, cSrcByteWidth, y, cLine);
			pbSrc += cSrcByteWidth * cLine;
			y += cLine;
		}
	}
	if(y < yBottom){
		// partC
		if(fuxlSetBandPos(pdevobj, y) == FALSE)		// FUXL band pos can't move up
			return TRUE;
		fuxlCopyBand(pdevobj, pbSrc, cSrcByteWidth, y, yBottom - y);
	}
	return TRUE;
}


// end of fuband.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fudebug.h ===
////////////////////////////////////////////////
// fudebug.h
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#ifndef fudebug_h
#define	fudebug_h

#include <minidrv.h>

#if DBG && defined(TRACE_DDI)
#define	TRACEDDI(a)	dbgPrintf a;
#else
#define	TRACEDDI(a)
#endif


#if DBG && defined(TRACE_OUT)
#define	TRACEOUT(a)	dbgPrintf a;
#else
#define	TRACEOUT(a)
#endif

#if DBG
void dbgPrintf(LPSTR pszMsg, ...);
#endif


#endif // !fudebug_h

// end of fudebug.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuimg2.h ===
//
// fuimg2.h
//
// September.3,1997 H.Ishida (FPL)
// fjxlres.dll (NT5.0 MiniDriver)
//
// Aug.2,1996 H.Ishida(FPL)
// FJXL.DLL (NT4.0 MiniDriver)
//
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997
#ifndef fuimg2_h
#define	fuimg2_h


void fuxlOutputRTGIMG2(PDEVOBJ pdevobj, LPCBYTE lpBuf, UINT bxBuf, UINT y, UINT cy);


#endif // fuimg2_h
// end of fuimg2.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuimg2.c ===
//
// fuimg2.c
//
// September.3,1997 H.Ishida (FPL)
// fuxlers.dll (NT5.0 MiniDriver)
//
// Aug.2,1996 H.Ishida(FPL)
// FJXL.DLL (NT4.0 MiniDriver)
//
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997

#include "fuxl.h"
#include "fuimg2.h"

//
// Win-F RTGIMG2 output routine
// RTGIMG2:
//   GS<\x1D> + P1<\x30> + Space<\x20> + a<\x61>
//       + Pc + Pxh + Pxl + Pyh + Pyl + Pyh + D1 + ... + D64
//       { + D1 + ... + D64 } + Pc
//
//   P1 must be 30(hex)
//
//   Pc:  number of the following block.
//        if Pc is 0, terminate RTGIMG2.
//
//   Pxl, Pxh, Pyl, Pyh:  coordinate of the following block.
//                        it must be a multiple of 32.
//
//            X->
//         <-- 16dot -->
//       1      8 9      16
//      +--------+--------+
//      |  D1    |   D2   |
//      +--------+--------+    ^
//  |   |  D3    |   D4   |    |
//  v   +--------+--------+    |
//  Y   .        .        .  16dot
//      .        .        .    |
//      .        .        .    |
//      +--------+--------+    v
//      |  D63   |   D64  |
//      +--------+--------+
//      White dot:0  Black dot:1
//




const UINT	MAX_BLOCK			= 255;
const UINT	CB_RTGIMG2HEADER	= 5;
const UINT	CB_RTGIMG2BLOCK		= 64;
const UINT	IDX_BLOCK_COUNTER	= 0;


//
// LPBYTE fuxlRtgimg2OutputData(
//     PDEVOJB pdevobj    // MINI5 data
//     LPBYTE lpbDst,     // address of data to be output(spool).
//     UINT   x,          // x-coordinate
//     UINT   y,          // y-coordinate
//     UINT   uTmp        // 00h: entire block is white. otherwise block is not white.
// );
//
//     Output RTGIMG2 block to spool.
//
// Return value:
//      address of next block to be stored.
//
static LPBYTE fuxlRtgimg2OutputData(PDEVOBJ pdevobj, LPBYTE lpbDst, UINT x, UINT y, UINT uTmp)
{
	if(uTmp == 0){
		// entire block is white.
		// igonre this block. flush blocks in buffer.
		if(lpbDst[IDX_BLOCK_COUNTER] > 0){
			WRITESPOOLBUF(pdevobj,
						lpbDst,
						lpbDst[IDX_BLOCK_COUNTER] * CB_RTGIMG2BLOCK + CB_RTGIMG2HEADER);
			lpbDst[IDX_BLOCK_COUNTER] = 0;
		}
	}
	else {
		if(lpbDst[IDX_BLOCK_COUNTER] == 0){
			// first block, in buffer, needs its coordinate.
			lpbDst[1] = HIBYTE((WORD)x);		// Pxh
			lpbDst[2] = LOBYTE((WORD)x);		// Pxl
			lpbDst[3] = HIBYTE((WORD)y);		// Pyh
			lpbDst[4] = LOBYTE((WORD)y);		// Pyl
		}
		lpbDst[IDX_BLOCK_COUNTER]++;
		if(lpbDst[IDX_BLOCK_COUNTER] >= MAX_BLOCK){
			WRITESPOOLBUF(pdevobj,
						lpbDst,
						lpbDst[IDX_BLOCK_COUNTER] * CB_RTGIMG2BLOCK + CB_RTGIMG2HEADER);
			lpbDst[IDX_BLOCK_COUNTER] = 0;
		}
	}
	// return pointer for the address, next block will be stored.
	return lpbDst + lpbDst[IDX_BLOCK_COUNTER] * CB_RTGIMG2BLOCK + CB_RTGIMG2HEADER;
}



//
// void FuxlOutputRTGIMG2(
//     PDEVOBJ pdevobj,      // MINI5 data
//     LPCBYTE lpBuf,        // address of image
//     UINT    bxSrc,        // width of image (in byte)
//     UINT    y,            // y-coordinate
//     UINT    cy            // height of image (scanline)
// );
//
//    Convert image to RTGIMG2 command sequence, and spool.
//
//
//    Souce image data:
//
//            | <-------------------- bxSrc ----------------------> |
//    lpBuf ->*--------+--------+--------+--------+--------+--------+---
//            |        |        |        |        |        |        | ^
//            +--------+--------+--------+--------+--------+--------+ |
//            |        |        |        |        |        |        | cy
//            +--------+--------+--------+--------+--------+--------+ |
//            |        |        |        |        |        |        | |
//            +--------+--------+--------+--------+--------+--------+ |
//            |        |        |        |        |        |        | v
//            +--------+--------+--------+--------+--------+--------+---
//
//        coordinate of '*' (left-top of image) is (0, y)
//        white dot:0
//        black dot:1
//
//
void fuxlOutputRTGIMG2(PDEVOBJ pdevobj, LPCBYTE lpBuf, UINT bxSrc, UINT y, UINT cy)
{
	LPCBYTE	lpbSrc;
	LPBYTE	lpbDst;
	LPCBYTE	lpbTmpSrc;
	LPBYTE	lpbTmpDst;
	UINT	uTmp;
	UINT	x;
	UINT	i, j, ii;

	lpbDst = (LPBYTE)MemAllocZ(CB_RTGIMG2HEADER + MAX_BLOCK * CB_RTGIMG2BLOCK);
	if(lpbDst == NULL)
		return;

	WRITESPOOLBUF(pdevobj, "\x1D\x30\x20\x61", 4);		// RTGIMG2 start

	lpbSrc = lpBuf;
	lpbDst[0] = 0;			// Pc
	lpbDst[1] = 0;			// Pxl
	lpbDst[2] = 0;			// Pxh
	lpbDst[3] = 0;			// Pyl
	lpbDst[4] = 0;			// Pyh
	lpbTmpDst = &lpbDst[CB_RTGIMG2HEADER];

	for(i = cy; i >= 32; i -= 32){
		x = 0;
		for(j = bxSrc; j >= 2; j -= 2){
			lpbTmpSrc = lpbSrc;
			uTmp = 0;
			for(ii = 32; ii > 0; --ii){
				uTmp |= lpbTmpSrc[0];
				*lpbTmpDst++ = lpbTmpSrc[0];
				uTmp |= lpbTmpSrc[1];
				*lpbTmpDst++ = lpbTmpSrc[1];
				lpbTmpSrc += bxSrc;
			}
			lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, uTmp);
			x += 16;
			lpbSrc += 2;
		}
		if(j > 0){
			// right edge of image
			// j must be 1.
			lpbTmpSrc = lpbSrc;
			uTmp = 0;
			for(ii = 32; ii > 0; --ii){
				uTmp |= lpbTmpSrc[0];
				*lpbTmpDst++ =lpbTmpSrc[0];
				*lpbTmpDst++ = 0;				// padding for right side
				lpbTmpSrc += bxSrc;
			}
			lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, uTmp);
			lpbSrc++;
		}
		// flush buffer
		lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, 0);
		lpbSrc += bxSrc * 31;
		y += 32;
	}
	if(i > 0){
		// bottom edge of image
		x = 0;
		for(j = bxSrc; j >= 2; j -= 2){
			lpbTmpSrc = lpbSrc;
			uTmp = 0;
			for(ii = i; ii > 0; --ii){
				uTmp |= lpbTmpSrc[0];
				*lpbTmpDst++ = lpbTmpSrc[0];
				uTmp |= lpbTmpSrc[1];
				*lpbTmpDst++ = lpbTmpSrc[1];
				lpbTmpSrc += bxSrc;
			}
			for(ii = 32 - i; ii > 0; --ii){
				*lpbTmpDst++ = 0;				// padding for bottom lines
				*lpbTmpDst++ = 0;				// padding for bottom lines
			}
			lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, uTmp);
			x += 16;
			lpbSrc += 2;
		}
		if(j > 0){
			// right-bottom corner of image
			// j must be 1.
			lpbTmpSrc = lpbSrc;
			uTmp = 0;
			for(ii = i; ii > 0; --ii){
				uTmp |= lpbTmpSrc[0];
				*lpbTmpDst++ = lpbTmpSrc[0];
				*lpbTmpDst++ = 0;				// padding for right side
				lpbTmpSrc += bxSrc;
			}
			for(ii = 32 - i ; ii > 0; --ii){
				*lpbTmpDst++ = 0;				// padding for bottom lines
				*lpbTmpDst++ = 0;				// padding for bottom lines
			}
			lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, uTmp);
		}
		// flush buffer
		lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, 0);
	}
	WRITESPOOLBUF(pdevobj, "\x00", 1);			// RTGIMG2 terminate
	MemFree(lpbDst);
}


// end of fuimg2.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fudebug.c ===
///////////////////////////////////////////////////
// fudebug.c
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

// NTRAID#NTBUG9-589500-2002/03/29-v-kkon-: Remove dead codes

// end of fudebug.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuimg4.c ===
////////////////////////////////////////////////////
// fuimg4.cpp
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#include "fuxl.h"
#include "fuimg4.h"
#include "fudebug.h"

#define	C_BLOCK_BYTE_WIDTH	4
#define	CY_BLOCK			32



static LPBYTE setImg4Block(LPBYTE pbDest, LPCBYTE pbSrc, int cSrcByteWidth, int cBlockByteWidth, int cyBlock)
{
	LPCBYTE	pbTmp;
	DWORD	dwMask;
	DWORD	dwData;
	int		i;
	int		j;

	dwData = 0xffffffff;
	for(i = 0; i < cyBlock; ++i){
		pbTmp = pbSrc;
		for(j = 0; j < cBlockByteWidth; ++j){
			dwData = (dwData << 8) | (*pbTmp++ & 0xff);
			if((dwData & 0x00ffffff) == 0){
				pbDest[-1] += 1;
			}
			else if((dwData & 0x0000ffff) == 0){
				*pbDest++ = 0;
				*pbDest++ = 2;
			}
			else{
				*pbDest++ = (BYTE)dwData;
			}
		}
		for(; j < 4; ++j){
			dwData <<= 8;
			if((dwData & 0x00ffffff) == 0){
				pbDest[-1] += 1;
			}
			else if((dwData & 0x0000ffff) == 0){
				*pbDest++ = 0;
				*pbDest++ = 2;
			}
			else{
				*pbDest++ = (BYTE)dwData;
			}
		}
		pbSrc += cSrcByteWidth;
	}
	for( ; i < CY_BLOCK; ++i){
		for(j = 0; j < C_BLOCK_BYTE_WIDTH; ++j){
			dwData <<= 8;
			if((dwData & 0x00ffffff) == 0){
				pbDest[-1] += 1;
			}
			else if((dwData & 0x0000ffff) == 0){
				*pbDest++ = 0;
				*pbDest++ = 2;
			}
			else{
				*pbDest++ = (BYTE)dwData;
			}
		}
	}

	return pbDest;
}




void fuxlOutputRTGIMG4(PDEVOBJ pdevobj, LPCBYTE pbSrc, int cSrcByteWidth, int y, int cy)
{
	PFUXLPDEV	pFuxlPDEV;
	LPCBYTE		pbSrcTmp;
	LPBYTE		pbDest;
	UINT		uFlags;
	UINT		uSerialCode;
	BOOL		bCmdHeader;
	int			iy;
	int			ix;
	int			cx;
	int			xPos;
	int			yPos;
	int			cBlockByteWidth;
	int			cyBlock;
	BYTE		abBuff[256];

	TRACEOUT(("[fjxlRTGIMG4]\r\n"))

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	cx = pFuxlPDEV->cxPage;

	bCmdHeader = FALSE;
	uFlags = 0xd0;
	uSerialCode = 0;

	cyBlock = 32;
	for(iy = 0; iy < cy; iy += cyBlock){
		if(iy + cyBlock > cy)
			cyBlock = cy - iy;
		pbSrcTmp = pbSrc;

		cBlockByteWidth = 4;
		for(ix = 0; ix < cSrcByteWidth; ix += cBlockByteWidth){
			if(ix + cBlockByteWidth > cSrcByteWidth)
				cBlockByteWidth = cSrcByteWidth - ix;

			pbDest = abBuff;
			*pbDest++ = (BYTE)(uSerialCode | uFlags);
			if(uFlags == 0xd0){
				xPos = ix * 8;
				yPos = iy + y;
				*pbDest++ = (xPos >> 8) & 0xff;
				*pbDest++ = (xPos & 0xe0) | 0x01;
				*pbDest++ = (yPos >> 8) & 0xff;
				*pbDest++ = (yPos & 0xe0) | 0x01;
			}
			pbDest = setImg4Block(pbDest, pbSrcTmp, cSrcByteWidth, cBlockByteWidth, cyBlock);
			uFlags = 0xd0;
			if(pbDest[-3] != 0 || pbDest[-2] != 0 || pbDest[-1] != 128){
				if(bCmdHeader == FALSE){
					bCmdHeader = TRUE;
					WRITESPOOLBUF(pdevobj, "\x1d\x32\x20\x61", 4);
				}
				WRITESPOOLBUF(pdevobj, abBuff, (DWORD)(pbDest - abBuff));
				uSerialCode = (uSerialCode + 1) & 0x0f;
				uFlags = 0xe0;
			}
			pbSrcTmp += cBlockByteWidth;
		}
		pbSrc += cSrcByteWidth * cyBlock;
		uFlags = 0xd0;
	}

	if(bCmdHeader != FALSE){
		abBuff[0] = uSerialCode | 0xf0;
		WRITESPOOLBUF(pdevobj, abBuff, 1);
	}
}




// end of fuimg4.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuimg4.h ===
///////////////////////////////////////////////
// fuimg4.h
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#ifndef fuimg4_h
#define	fuimg4_h

void fuxlOutputRTGIMG4(PDEVOBJ pdevobj, LPCBYTE pbSrc, int iByteWidth, int y, int cy);

#endif // !fuimg4_h
// end of fuimg4.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fumh.h ===
//----------------------------------------------------------------------
//	FILE NAME	: FUMH.h
//	FUNCTION	: MH Compress
//	AUTHER		: 1996.08.08 FPL)Y.YUTANI
//	NOTE		: for Windows NT V4.0
//----------------------------------------------------------------------
#ifndef fumh_h
#define	fumh_h

DWORD	MhCompress(
	BYTE *pDest,
	DWORD cDestN,
	BYTE *pSrc, 
	DWORD cSrcN,
	DWORD cSrcX,
	DWORD cSrcY
);

#endif // !fumh_h

// end of FUMH.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fumh2.h ===
//----------------------------------------------------------------------
//	FILE NAME	: fumh2.h
//	FUNCTION	: MH2 Compress
//	AUTHER		: 1996.08.01 FPL)Y.YUTANI
//	NOTE		: for Windows NT V4.0
//  MODIFY      : for NT4.0 Minidriver H.Ishida(FPL)
//----------------------------------------------------------------------
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997
#ifndef fumh2_h
#define	fumh2_h

DWORD	Mh2Compress(
	BYTE *pDest,
	DWORD cDestN,
	BYTE *pSrc, 
	DWORD cSrcN,
	DWORD cSrcX,
	DWORD cSrcY
);

#endif // !fumh2_h

// end of fumh2.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\name.h ===
CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fumh2.c ===
//-----------------------------------------------------------------------------
//	FILE NAME	: FUMH2.c
//	FUNCTION	: MH Compress and MH2 Compress
//	AUTHER		: 1996.08.08 FPL)Y.YUTANI
//	NOTE		: for Windows NT V4.0
//  MODIFY      : Reduce data size Oct.31,1996 H.Ishida
//  MODIFY      : for NT5.0 Minidriver Sep.3,1997 H.Ishida(FPL)
//-----------------------------------------------------------------------------
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997

#include <minidrv.h>
#include "fuxl.h"
#include "fumhdef.h"

// NTRAID#NTBUG9-589500-2002/03/29-v-kkon-: Remove dead codes

//-----------------------------------------------------------------------------
//	BOOL SameLineCheck
//		PBYTE	pSrc	Pointer of sources bits image
//		DWORD	cSrcX	Width size of sources image(byte)
//		Return code	:	TRUE	Same image line
//						FALSE	Not same image line
//-----------------------------------------------------------------------------
BOOL SameLineCheck( PBYTE pSrc, DWORD cSrcX )
{
	DWORD	i;
	PBYTE	pLine1, pLine2;
	
	pLine1 = pSrc;
	pLine2 = pSrc + cSrcX;
	for( i = 0; i < cSrcX; i++ ) {
		if( *pLine1 != *pLine2 ) return FALSE;
		pLine1++;
		pLine2++;
	}
	
	return TRUE;
}
//-----------------------------------------------------------------------------
//	DWORD	SamePatternCheck
//		BYTE		*pTmp		Pointer of sources bits image
//		DWORD		cBitsTmp	Bit number from top of sources bits image
//		DWORD		cBitsMax	Maximam bit of sources bits image
//		PATNINFO	*pInfo		Pointer of Same pattern finormation struction
//		Rerutn code	:	Sources bit number
//-----------------------------------------------------------------------------
DWORD SamePatternCheck( BYTE *pTmp, DWORD cBitsTmp, DWORD cBitsMax, PATNINFO *pInfo )
{
	DWORD	cBits, k;
	BYTE	ptn1, ptn2;
	DWORD	dwPtn;

	// Initial same pattern number
	pInfo->dwPatnNum = 1;
	
	// Nothing remain bits
	if( cBitsTmp >= cBitsMax ) return cBitsTmp;
	
	// Caluclation sources bytes and bits
	pTmp += (cBitsTmp / 8);
	k = cBitsTmp % 8;
	
	// If remain bits bolow 16bits, return function
	if( ( cBitsTmp + 16 ) > cBitsMax ) return cBitsTmp;
	
	// Get Top 8bits(bit number is byte baundary?)
// NTRAID#NTBUG9-589500-2002/03/29-v-kkon-: Remove dead codes
	if( k != 0 ) {
		ptn1 = *pTmp << k;
		ptn1 |= *(pTmp+1) >> ( 8 - k );
	} else {
		ptn1 = *pTmp;
	}
	// If 8bits image is all white or black, return function
	if( ptn1 == ALL_BLACK || ptn1 == ALL_WHITE ) return cBitsTmp;
	
	// Compare top 8bits image and next 8bits image
	// (Careful same pattern number maximam)
	for (cBits = cBitsTmp + 8;
		(cBits + 7 < cBitsMax) && (pInfo->dwPatnNum < SAMEPATN_MAX); cBits += 8 ) {
		pTmp++;

// NTRAID#NTBUG9-589500-2002/03/29-v-kkon-: Remove dead codes
		if( k != 0 ) {
			ptn2 = *pTmp << k;
			ptn2 |= *(pTmp+1) >> ( 8 - k );
		} else {
			ptn2 = *pTmp;
		}
		// If top image not iqual next image, stop counting same pattern
		if( ptn1 != ptn2 ) break;

		// Same pattern number addition
		pInfo->dwPatnNum++;
		
	}
	
	// Nothing same pattern
	if( pInfo->dwPatnNum == 1 ) return cBitsTmp;
	
	// Set pattern
	pInfo->dwPatn = (DWORD)ptn1;
	
	// If bits remain, check joint bit's color and set
	if( cBits < cBitsMax ) {
		if ( (*pTmp & (1 << (7 - k)) ) == 0 ) {
			pInfo->dwNextColor = NEXT_COLOR_WHITE;
		} else {
			pInfo->dwNextColor = NEXT_COLOR_BLACK;
		}
	} else {
		pInfo->dwNextColor = NEXT_COLOR_WHITE;
	}
	return cBits;
}
//-----------------------------------------------------------------------------
//	DWORD	Mh2Compress
//		BYTE	*pDest	Pointer of destinaition area
//		DWORD	cDestN	Size of destination area(byte)
//		BYTE	*pSrc	Pointer of sources area
//		DWORD	cSrcN	Size of sources area(byte)
//		DWORD	cSrcX	Sources image x width
//		DWORD	cSrcY	Sources image y height
//		Return code	:	Writing size to destination area
//-----------------------------------------------------------------------------
DWORD Mh2Compress( BYTE *pDest, DWORD cDestN, BYTE *pSrc, DWORD cSrcN, DWORD cSrcX, DWORD cSrcY )
{
	DWORD		cBitsSrc, cBitsSrcMax;
	DWORD		cBitsDest, cBitsDestMax, cBitsDestMark;
	DWORD		cBitsRun;
	DWORD		dwCode, cBits;
	DWORD		i;
	DWORD		dwSameLine;
	PBYTE		pSrcLine;
	PATNINFO	ptnInfo;

	cBitsDest = 0;
	cBitsSrc = 0;
	dwSameLine = 1;

	cBitsDestMax = cDestN * 8;
	
	for (i = 0; i < cSrcY; i++) {

		// Set initial color
		ptnInfo.dwNextColor = NEXT_COLOR_WHITE;

		// Top pointer of now line
		pSrcLine = pSrc + ( i * cSrcX );

		// Now line equal next line image?(No check last line)
		if( i != ( cSrcY - 1 ) ) {
			if( SameLineCheck( pSrcLine, cSrcX ) ) {
				dwSameLine++;
				cBitsSrc += ( cSrcX * 8 );
				if( dwSameLine < SAMELINE_MAX ) continue;
			}
		}
		// Top EOL
		if (cBitsDest + CBITS_EOL_CODE > cBitsDestMax)
 			return 0;
		FjBitsCopy(pDest, cBitsDest, EOL_CODE, CBITS_EOL_CODE);
 		cBitsDest += CBITS_EOL_CODE;
		
		// There are same lines
		if( dwSameLine > 1 ) {
			if (cBitsDest + CBITS_SAMELINE > cBitsDestMax)
				return 0;
			// Set same line code
			FjBitsCopy( pDest, cBitsDest, SAMELINE_CODE, CBITS_SAMELINE_CODE );
			cBitsDest += CBITS_SAMELINE_CODE;
			// Set same line number
			FjBitsCopy( pDest, cBitsDest, dwSameLine << 8, CBITS_SAMELINE_NUM );
			cBitsDest += CBITS_SAMELINE_NUM;
			// Initial same line number
			dwSameLine = 1;
		}
// vvv Oct.31,1996 H.Ishida
		cBitsDestMark = cBitsDest;
// ^^^ Oct.31,1996 H.Ishida

		// Encode
		cBitsSrcMax = cBitsSrc + (cSrcX * 8);
		
		// Compress one line image
		while ( cBitsSrc < cBitsSrcMax ) {

			// Check same pattern
			cBitsSrc = SamePatternCheck( pSrc, cBitsSrc, cBitsSrcMax, &ptnInfo );
			// there are same patterns
			if( ptnInfo.dwPatnNum > 1 ) {
				if ( ( cBitsDest + CBITS_SAMEPATN ) > cBitsDestMax)
					return 0;
				// Set same pattern code
				FjBitsCopy(pDest, cBitsDest, SAMEPATN_CODE, CBITS_SAMEPATN_CODE );
				cBitsDest += CBITS_SAMEPATN_CODE;
				// Set same pattern image
				FjBitsCopy(pDest, cBitsDest, ptnInfo.dwPatn << 8, CBITS_SAMEPATN_BYTE );
				cBitsDest += CBITS_SAMEPATN_BYTE;
				ptnInfo.dwPatnNum <<= 5;
				ptnInfo.dwPatnNum |= ptnInfo.dwNextColor;
				// Set same pattern number & next run color
				FjBitsCopy(pDest, cBitsDest, ptnInfo.dwPatnNum, CBITS_SAMEPATN_NUM );
				cBitsDest += CBITS_SAMEPATN_NUM;
				// Unknown same pattern on after here
				continue;
			}
			
			// Next run is white
 			if( ptnInfo.dwNextColor == NEXT_COLOR_WHITE ) {

				// Count white bits
				cBitsRun = FjCountBits(pSrc, cBitsSrc, (cBitsSrcMax - cBitsSrc), TRUE);
				cBitsSrc += cBitsRun;
// vvv Oct.31,1996 H.Ishida
				// reduce data size
				if(cBitsSrc >= cBitsSrcMax){
					if(cBitsDest > cBitsDestMark)
						break;
					cBitsRun = 2;			// Whole white line is convert to white 2 dots:Minimun MH data.
				}
// ^^^ Oct.31,1996 H.Ishida

				// Careful, white run length over maximam
				while( cBitsRun > RUNLENGTH_MAX ) {
					dwCode = WhiteMakeUpTable[MAKEUP_TABLE_MAX - 1].wCode;
					cBits = WhiteMakeUpTable[MAKEUP_TABLE_MAX - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
					cBitsRun -= RUNLENGTH_MAX;
				}
				if (cBitsRun >= 64) {
					dwCode = WhiteMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].wCode;
					cBits = WhiteMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
				}
				dwCode = WhiteTerminateTable[cBitsRun % TERMINATE_MAX].wCode;
				cBits = WhiteTerminateTable[cBitsRun % TERMINATE_MAX].cBits;
				if (cBitsDest + cBits > cBitsDestMax)
					return 0;
				FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
				cBitsDest += cBits;
				ptnInfo.dwNextColor = NEXT_COLOR_BLACK;
			} else {

				// Black bits
				cBitsRun = FjCountBits(pSrc, cBitsSrc, (cBitsSrcMax - cBitsSrc), FALSE);
				cBitsSrc += cBitsRun;

				// Careful, black run length over maximam
				while( cBitsRun > RUNLENGTH_MAX ) {
					dwCode = BlackMakeUpTable[MAKEUP_TABLE_MAX - 1].wCode;
					cBits = BlackMakeUpTable[MAKEUP_TABLE_MAX - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
					cBitsRun -= RUNLENGTH_MAX;
				}
				if (cBitsRun >= 64) {
					dwCode = BlackMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].wCode;
					cBits = BlackMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
				}
				dwCode = BlackTerminateTable[cBitsRun % TERMINATE_MAX].wCode;
				cBits = BlackTerminateTable[cBitsRun % TERMINATE_MAX].cBits;
				if (cBitsDest + cBits > cBitsDestMax)
					return 0;
				FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
				cBitsDest += cBits;
				ptnInfo.dwNextColor = NEXT_COLOR_WHITE;
			}
		}
        // End of one raster
	}

	// Last EOL.
	if (cBitsDest + CBITS_EOL_CODE > cBitsDestMax)
		return 0;
	FjBitsCopy(pDest, cBitsDest, EOL_CODE, CBITS_EOL_CODE);
	cBitsDest += CBITS_EOL_CODE;

	// Pad with 0 until byte boundary
	if ((cBits = (8 - (cBitsDest % 8)) % 8) != 0) {
		if (cBitsDest + cBits > cBitsDestMax)
			return 0;
		FjBitsCopy(pDest, cBitsDest, FILL_CODE, cBits);
		cBitsDest += cBits;
	}

	return cBitsDest / 8;
}
// end of FUMH2.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fumh.c ===
//-----------------------------------------------------------------------------
//	FILE NAME	: FUMH.C
//	FUNCTION	: MH Compress and MH2 Compress
//	AUTHER		: 1996.08.08 FPL)Y.YUTANI
//	NOTE		: for Windows NT V4.0
//  MODIFY      : Reduce data size Oct.31,1996 H.Ishida
//  MODIFY      : for NT.50 MiniDriver Sep.3,1997 H.Ishida(FPL)
//-----------------------------------------------------------------------------
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997

#include <minidrv.h>
#include "fuxl.h"
#include "fumhdef.h"

const
CODETABLE
WhiteMakeUpTable[] = 
{
    { 0xd800, 5 },
    { 0x9000, 5 },
    { 0x5c00, 6 },
    { 0x6e00, 7 },
    { 0x3600, 8 },
    { 0x3700, 8 },
    { 0x6400, 8 },
    { 0x6500, 8 },
    { 0x6800, 8 },
    { 0x6700, 8 },
    { 0x6600, 9 },
    { 0x6680, 9 },
    { 0x6900, 9 },
    { 0x6980, 9 },
    { 0x6a00, 9 },
    { 0x6a80, 9 },
    { 0x6b00, 9 },
    { 0x6b80, 9 },
    { 0x6c00, 9 },
    { 0x6c80, 9 },
    { 0x6d00, 9 },
    { 0x6d80, 9 },
    { 0x4c00, 9 },
    { 0x4c80, 9 },
    { 0x4d00, 9 },
    { 0x6000, 6 },
    { 0x4d80, 9 },
    { 0x0100, 11 },
    { 0x0180, 11 },
    { 0x01a0, 11 },
    { 0x0120, 12 },
    { 0x0130, 12 },
    { 0x0140, 12 },
    { 0x0150, 12 },
    { 0x0160, 12 },
    { 0x0170, 12 },
    { 0x01c0, 12 },
    { 0x01d0, 12 },
    { 0x01e0, 12 },
    { 0x01f0, 12 },
    { 0x3500, 8 },
    { 0x1c00, 6 },
    { 0x7000, 4 },
    { 0x8000, 4 },
    { 0xb000, 4 },
    { 0xc000, 4 },
    { 0xe000, 4 },
    { 0xf000, 4 },
    { 0x9800, 5 },
    { 0xa000, 5 },
    { 0x3800, 5 },
    { 0x4000, 5 },
    { 0x2000, 6 },
    { 0x0c00, 6 },
    { 0xd000, 6 },
    { 0xd400, 6 },
    { 0xa800, 6 },
    { 0xac00, 6 },
    { 0x4e00, 7 },
    { 0x1800, 7 },
    { 0x1000, 7 },
    { 0x2e00, 7 },
    { 0x0600, 7 },
    { 0x0800, 7 },
};

const
CODETABLE
WhiteTerminateTable[] =
{
    { 0x3500, 8 },
    { 0x1c00, 6 },
    { 0x7000, 4 },
    { 0x8000, 4 },
    { 0xb000, 4 },
    { 0xc000, 4 },
    { 0xe000, 4 },
    { 0xf000, 4 },
    { 0x9800, 5 },
    { 0xa000, 5 },
    { 0x3800, 5 },
    { 0x4000, 5 },
    { 0x2000, 6 },
    { 0x0c00, 6 },
    { 0xd000, 6 },
    { 0xd400, 6 },
    { 0xa800, 6 },
    { 0xac00, 6 },
    { 0x4e00, 7 },
    { 0x1800, 7 },
    { 0x1000, 7 },
    { 0x2e00, 7 },
    { 0x0600, 7 },
    { 0x0800, 7 },
    { 0x5000, 7 },
    { 0x5600, 7 },
    { 0x2600, 7 },
    { 0x4800, 7 },
    { 0x3000, 7 },
    { 0x0200, 8 },
    { 0x0300, 8 },
    { 0x1a00, 8 },
    { 0x1b00, 8 },
    { 0x1200, 8 },
    { 0x1300, 8 },
    { 0x1400, 8 },
    { 0x1500, 8 },
    { 0x1600, 8 },
    { 0x1700, 8 },
    { 0x2800, 8 },
    { 0x2900, 8 },
    { 0x2a00, 8 },
    { 0x2b00, 8 },
    { 0x2c00, 8 },
    { 0x2d00, 8 },
    { 0x0400, 8 },
    { 0x0500, 8 },
    { 0x0a00, 8 },
    { 0x0b00, 8 },
    { 0x5200, 8 },
    { 0x5300, 8 },
    { 0x5400, 8 },
    { 0x5500, 8 },
    { 0x2400, 8 },
    { 0x2500, 8 },
    { 0x5800, 8 },
    { 0x5900, 8 },
    { 0x5a00, 8 },
    { 0x5b00, 8 },
    { 0x4a00, 8 },
    { 0x4b00, 8 },
    { 0x3200, 8 },
    { 0x3300, 8 },
    { 0x3400, 8 },
};

const
CODETABLE
BlackMakeUpTable[] = 
{
    { 0x03c0, 10 },
    { 0x0c80, 12 },
    { 0x0c90, 12 },
    { 0x05b0, 12 },
    { 0x0330, 12 },
    { 0x0340, 12 },
    { 0x0350, 12 },
    { 0x0360, 13 },
    { 0x0368, 13 },
    { 0x0250, 13 },
    { 0x0258, 13 },
    { 0x0260, 13 },
    { 0x0268, 13 },
    { 0x0390, 13 },
    { 0x0398, 13 },
    { 0x03a0, 13 },
    { 0x03a8, 13 },
    { 0x03b0, 13 },
    { 0x03b8, 13 },
    { 0x0290, 13 },
    { 0x0298, 13 },
    { 0x02a0, 13 },
    { 0x02a8, 13 },
    { 0x02d0, 13 },
    { 0x02d8, 13 },
    { 0x0320, 13 },
    { 0x0328, 13 },
    { 0x0100, 11 },
    { 0x0180, 11 },
    { 0x01a0, 11 },
    { 0x0120, 12 },
    { 0x0130, 12 },
    { 0x0140, 12 },
    { 0x0150, 12 },
    { 0x0160, 12 },
    { 0x0170, 12 },
    { 0x01c0, 12 },
    { 0x01d0, 12 },
    { 0x01e0, 12 },
    { 0x01f0, 12 },
    { 0x0dc0, 10 },
    { 0x4000, 3 },
    { 0xc000, 2 },
    { 0x8000, 2 },
    { 0x6000, 3 },
    { 0x3000, 4 },
    { 0x2000, 4 },
    { 0x1800, 5 },
    { 0x1400, 6 },
    { 0x1000, 6 },
    { 0x0800, 7 },
    { 0x0a00, 7 },
    { 0x0e00, 7 },
    { 0x0400, 8 },
    { 0x0700, 8 },
    { 0x0c00, 9 },
    { 0x05c0, 10 },
    { 0x0600, 10 },
    { 0x0200, 10 },
    { 0x0ce0, 11 },
    { 0x0d00, 11 },
    { 0x0d80, 11 },
    { 0x06e0, 11 },
    { 0x0500, 11 },
};

const
CODETABLE
BlackTerminateTable[] =
{
    { 0x0dc0, 10 },
    { 0x4000, 3 },
    { 0xc000, 2 },
    { 0x8000, 2 },
    { 0x6000, 3 },
    { 0x3000, 4 },
    { 0x2000, 4 },
    { 0x1800, 5 },
    { 0x1400, 6 },
    { 0x1000, 6 },
    { 0x0800, 7 },
    { 0x0a00, 7 },
    { 0x0e00, 7 },
    { 0x0400, 8 },
    { 0x0700, 8 },
    { 0x0c00, 9 },
    { 0x05c0, 10 },
    { 0x0600, 10 },
    { 0x0200, 10 },
    { 0x0ce0, 11 },
    { 0x0d00, 11 },
    { 0x0d80, 11 },
    { 0x06e0, 11 },
    { 0x0500, 11 },
    { 0x02e0, 11 },
    { 0x0300, 11 },
    { 0x0ca0, 12 },
    { 0x0cb0, 12 },
    { 0x0cc0, 12 },
    { 0x0cd0, 12 },
    { 0x0680, 12 },
    { 0x0690, 12 },
    { 0x06a0, 12 },
    { 0x06b0, 12 },
    { 0x0d20, 12 },
    { 0x0d30, 12 },
    { 0x0d40, 12 },
    { 0x0d50, 12 },
    { 0x0d60, 12 },
    { 0x0d70, 12 },
    { 0x06c0, 12 },
    { 0x06d0, 12 },
    { 0x0da0, 12 },
    { 0x0db0, 12 },
    { 0x0540, 12 },
    { 0x0550, 12 },
    { 0x0560, 12 },
    { 0x0570, 12 },
    { 0x0640, 12 },
    { 0x0650, 12 },
    { 0x0520, 12 },
    { 0x0530, 12 },
    { 0x0240, 12 },
    { 0x0370, 12 },
    { 0x0380, 12 },
    { 0x0270, 12 },
    { 0x0280, 12 },
    { 0x0580, 12 },
    { 0x0590, 12 },
    { 0x02b0, 12 },
    { 0x02c0, 12 },
    { 0x05a0, 12 },
    { 0x0660, 12 },
    { 0x0670, 12 },
};

//-----------------------------------------------------------------------------
//	DWORD	FjCountBits
//		BYTE	*pTmp		Pointer of sources area
//		DWORD	cBitstmp	Now bit number from top of sources area
//		DWORD	cBitsMax	Last bits number in this line
//		BOOL	hWhite		color flag
//							TRUE	: counting white bits
//							FALSE	: counting black bits
//		Return code	:	Join same color bits number
//-----------------------------------------------------------------------------
DWORD FjCountBits( BYTE *pTmp, DWORD cBitsTmp, DWORD cBitsMax, BOOL bWhite )
{
    DWORD cBits, k;

    pTmp += (cBitsTmp / 8);
    k = cBitsTmp % 8;
    
    for (cBits = 0; cBits < cBitsMax; cBits++) {
        
        if (((*pTmp & (1 << (7 - k))) == 0) != bWhite)
            break;

        k++;
        if (k == 8) {
            k = 0;
            pTmp++;
        }
    } 

    return cBits;
}

//-----------------------------------------------------------------------------
//	VOID	FjBitsCopy
//		BYTE	*pTmp		Pointer of destinaition area
//		DWORD	cBitsTmp	Bit number from top of destination area
//		DWORD	dwCode		Copy code
//		INT		cCopyBits	Copy size(bit)
//-----------------------------------------------------------------------------
VOID FjBitsCopy( BYTE *pTmp, DWORD cBitsTmp, DWORD dwCode, INT cCopyBits )
{
	INT k, cBits;
	DWORD dwMask, dwTmp;

	pTmp += (cBitsTmp / 8);
	k = cBitsTmp % 8;

	cBits = cCopyBits + k;

	dwTmp = (DWORD)*pTmp << 16;
	dwTmp &= 0xff000000L >> k;
	dwTmp |= dwCode << (8 - k);

	if( cBits <= 8 ) {
		*pTmp = (BYTE)(dwTmp >> 16);
	} else if( cBits <= 16 ) {
		*pTmp = (BYTE)(dwTmp >> 16);
		*(pTmp + 1) = (BYTE)(dwTmp >> 8);
	} else {
		*pTmp = (BYTE)(dwTmp >> 16);
		*(pTmp + 1) = (BYTE)(dwTmp >> 8);
		*(pTmp + 2) = (BYTE)dwTmp;
	}
}
//-----------------------------------------------------------------------------
//	DWORD	MhCompress
//		BYTE	*pDest	Pointer of destinaition area
//		DWORD	cDestN	Size of destination area(byte)
//		BYTE	*pSrc	Pointer of sources area
//		DWORD	cSrcN	Size of sources area(byte)
//		DWORD	cSrcX	Sources image x width
//		DWORD	cSrcY	Sources image y height
//		Return code	:	Writing size to destination area
//-----------------------------------------------------------------------------
DWORD MhCompress( BYTE *pDest, DWORD cDestN, BYTE *pSrc, DWORD cSrcN, DWORD cSrcX, DWORD cSrcY )
{
	DWORD		cBitsSrc, cBitsSrcMax;
	DWORD		cBitsDest, cBitsDestMax, cBitsDestMark;
	DWORD		cBitsRun;
	DWORD		dwCode, cBits;
	DWORD		i;
	PATNINFO	ptnInfo;

	cBitsDest = 0;
	cBitsSrc = 0;

	cBitsDestMax = cDestN * 8;
	
	for (i = 0; i < cSrcY; i++) {

		// Set initial color
		ptnInfo.dwNextColor = NEXT_COLOR_WHITE;

		// Top EOL
		if (cBitsDest + CBITS_EOL_CODE > cBitsDestMax)
 			return 0;
		FjBitsCopy(pDest, cBitsDest, EOL_CODE, CBITS_EOL_CODE);
 		cBitsDest += CBITS_EOL_CODE;
// vvv Oct.31,1996 H.Ishida
		cBitsDestMark = cBitsDest;
// ^^^ Oct.31,1996 H.Ishida

		// Encode
		cBitsSrcMax = cBitsSrc + (cSrcX * 8);
		
		// Compress one line image
		while ( cBitsSrc < cBitsSrcMax ) {

			// Next run is white
 			if( ptnInfo.dwNextColor == NEXT_COLOR_WHITE ) {
			
				// Count white bits
				cBitsRun = FjCountBits(pSrc, cBitsSrc, (cBitsSrcMax - cBitsSrc), TRUE);
				cBitsSrc += cBitsRun;
// vvv Oct.31,1996 H.Ishida
				// reduce data size
				if(cBitsSrc >= cBitsSrcMax){
					if(cBitsDest > cBitsDestMark)
						break;
					cBitsRun = 2;			// Whole white line is convert to white 2 dots:Minimun MH data.
				}
// ^^^ Oct.31,1996 H.Ishida
				// Careful, white run length over maximam
				while( cBitsRun > RUNLENGTH_MAX ) {
					dwCode = WhiteMakeUpTable[MAKEUP_TABLE_MAX - 1].wCode;
					cBits = WhiteMakeUpTable[MAKEUP_TABLE_MAX - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
					cBitsRun -= RUNLENGTH_MAX;
				}
				if (cBitsRun >= 64) {
					dwCode = WhiteMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].wCode;
					cBits = WhiteMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
				}
				dwCode = WhiteTerminateTable[cBitsRun % TERMINATE_MAX].wCode;
				cBits = WhiteTerminateTable[cBitsRun % TERMINATE_MAX].cBits;
				if (cBitsDest + cBits > cBitsDestMax)
					return 0;
				FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
				cBitsDest += cBits;
				ptnInfo.dwNextColor = NEXT_COLOR_BLACK;
			} else {

				// Black bits
				cBitsRun = FjCountBits(pSrc, cBitsSrc, (cBitsSrcMax - cBitsSrc), FALSE);
				cBitsSrc += cBitsRun;

				// Careful, black run length over maximam
				while( cBitsRun > RUNLENGTH_MAX ) {
					dwCode = BlackMakeUpTable[MAKEUP_TABLE_MAX - 1].wCode;
					cBits = BlackMakeUpTable[MAKEUP_TABLE_MAX - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
					cBitsRun -= RUNLENGTH_MAX;
				}
				if (cBitsRun >= 64) {
					dwCode = BlackMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].wCode;
					cBits = BlackMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
				}
				dwCode = BlackTerminateTable[cBitsRun % TERMINATE_MAX].wCode;
				cBits = BlackTerminateTable[cBitsRun % TERMINATE_MAX].cBits;
				if (cBitsDest + cBits > cBitsDestMax)
					return 0;
				FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
				cBitsDest += cBits;
				ptnInfo.dwNextColor = NEXT_COLOR_WHITE;
			}
        }
		// End of one raster
	}

	// Last EOL.
	if (cBitsDest + CBITS_EOL_CODE > cBitsDestMax)
		return 0;
	FjBitsCopy(pDest, cBitsDest, EOL_CODE, CBITS_EOL_CODE);
	cBitsDest += CBITS_EOL_CODE;

	// Pad with 0 until byte boundary
	if ((cBits = (8 - (cBitsDest % 8)) % 8) != 0) {
		if (cBitsDest + cBits > cBitsDestMax)
			return 0;
		FjBitsCopy(pDest, cBitsDest, FILL_CODE, cBits);
		cBitsDest += cBits;
	}

	return cBitsDest / 8;
}
// end of FUMH.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuxldm.c ===
///////////////////////////////////////////////////
// fuxldm.c
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#include "fuxl.h"
#include "fudebug.h"

// MINI5 Export func.
BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
	TRACEOUT(("[OEMGetInfo]\r\n"))

	if(pcbNeeded == NULL){
  		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

  	*pcbNeeded = sizeof(DWORD);
  	if(NULL == pBuffer || sizeof(DWORD) > cbSize){
  		SetLastError(ERROR_INSUFFICIENT_BUFFER);
  		return FALSE;
  	}

	switch(dwInfo){
	  case OEMGI_GETSIGNATURE:
		TRACEOUT(("OEMGI_GETSIGNATURE\r\n"))
	  	*(LPDWORD)pBuffer = FUXL_OEM_SIGNATURE;
	  	break;
	  case OEMGI_GETINTERFACEVERSION:
		TRACEOUT(("OEMGI_GETINTERFACEVERSION\r\n"))
	  	*(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
	  	break;
	  case OEMGI_GETVERSION:
		TRACEOUT(("OEMGI_GETVERSION\r\n"))
	  	*(LPDWORD)pBuffer = FUXL_OEM_VERSION;
	  	break;
	  default:
		TRACEOUT(("invalid dwInfo\r\n"))
	  	SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	return TRUE;
}



static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    if(NULL == pOEMDevModeParam){
    	TRACEOUT(("pOEMDevModeParam is NULL\r\n"))
    	return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize){
    	TRACEOUT(("pOEMDevModeParam->cbSize (%d) is less than sizeof(OEMDMPARAM)\r\n", pOEMDevModeParam->cbSize))
        return FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter){
		TRACEOUT(("pOEMDevModeParam->hPrinter is NULL\r\n"))
		return FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule){
		TRACEOUT(("pOEMDevModeParam->hModule is NULL\r\n"))
        return FALSE;
    }

    if((0 != pOEMDevModeParam->cbBufSize) && (NULL == pOEMDevModeParam->pOEMDMOut)){
		TRACEOUT(("pOEMDevModeParam->cbBufSize is not 0, and, pOEMDMOut is NULL\r\n"))
		return FALSE;
    }

    if((OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn)){
		TRACEOUT(("dwMode is OEMDM_MERGE && pOEMDMIn is NULL\r\n"))
		return FALSE;
    }

    return TRUE;
}



static void fuxlInitOEMExtraData(PFUXL_OEM_EXTRADATA pFuxlOEMExtra)
{
	pFuxlOEMExtra->dmExtraHdr.dwSize = sizeof(FUXL_OEM_EXTRADATA);
	pFuxlOEMExtra->dmExtraHdr.dwSignature = FUXL_OEM_SIGNATURE;
	pFuxlOEMExtra->dmExtraHdr.dwVersion = FUXL_OEM_VERSION;
}



static void fuxlMergeOEMExtraData(
	PFUXL_OEM_EXTRADATA pFuxlOEMExtraIn,
	PFUXL_OEM_EXTRADATA pFuxlOEMExtraOut)
{
}



// MINI5 Export func.
BOOL APIENTRY OEMDevMode(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
	TRACEOUT(("[OEMDevMode]\r\n"))

	if(BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam) == FALSE){
		TRACEOUT(("invalid OEMDevModeParam\r\n"))
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	if(dwMode == OEMDM_SIZE){
		pOEMDevModeParam->cbBufSize = sizeof(FUXL_OEM_EXTRADATA);
		TRACEOUT(("OEMDM_SIZE %d\r\n", pOEMDevModeParam->cbBufSize))
		return TRUE;
	}

	if(sizeof(FUXL_OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize){
		TRACEOUT(("cbBufSize %d\r\n", pOEMDevModeParam->cbBufSize))
  		SetLastError(ERROR_INSUFFICIENT_BUFFER);
		return FALSE;
	}

	switch(dwMode){
	  case OEMDM_DEFAULT:
		TRACEOUT(("OEMDM_DEFAULT\r\n"));
	  	fuxlInitOEMExtraData((PFUXL_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  case OEMDM_CONVERT:
		TRACEOUT(("OEMDM_CONVERT\r\n"));
	  	fuxlInitOEMExtraData((PFUXL_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  case OEMDM_MERGE:
		TRACEOUT(("OEMDM_MERGE\r\n"));
		fuxlMergeOEMExtraData((PFUXL_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
							(PFUXL_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  default:
		TRACEOUT(("invalid dwMode\r\n"));
	  	SetLastError(ERROR_INVALID_PARAMETER);
	  	return FALSE;
	  	break;
	}
	return TRUE;
}



// end of fuxldm.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fumhdef.h ===
//-----------------------------------------------------------------------------
//	FILE NAME	: FUMHDEF.H
//	AUTHER		: 1996.08.08 FPL)Y.YUTANI
//	NOTE		: MH,MH2 Compress Heder File for FJXL.DLL
//			:               (for Windows NT V4.0)
//  MODIFY      : for NT5.0 Minidriver Sep.3,1997 H.Ishida (FPL)
//-----------------------------------------------------------------------------
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997
#define	RAMDOM_BIT				1

#define	NEXT_COLOR_WHITE		0x0000
#define	NEXT_COLOR_BLACK		0x0010
#define	ALL_WHITE				0x00
#define	ALL_BLACK				0xFF
#define	EOL_CODE				0x0010
#define	FILL_CODE				0x0000
#define	SAMELINE_CODE			0x0080
#define	SAMEPATN_CODE			0x0090
#define	CBITS_EOL_CODE			12
#define	CBITS_SAMELINE_CODE		12
#define	CBITS_SAMELINE_NUM		8
#define	CBITS_SAMELINE			( CBITS_SAMELINE_CODE + CBITS_SAMELINE_NUM )
#define	CBITS_SAMEPATN_CODE		12
#define	CBITS_SAMEPATN_BYTE		8
#define	CBITS_SAMEPATN_NUM		12
#define	CBITS_SAMEPATN			( CBITS_SAMEPATN_CODE + CBITS_SAMEPATN_BYTE + CBITS_SAMEPATN_NUM )

#define	SAMELINE_MAX			255
#define	SAMEPATN_MAX			2047
#define	RUNLENGTH_MAX			2560
#define	TERMINATE_MAX			64
#define	MAKEUP_TABLE_MAX		40

// MH code table struction
typedef struct {
    WORD	wCode;			//	Run code
    WORD	cBits;			//	Run length
} CODETABLE;

// Same pattern informaiton sturction
typedef struct {
	DWORD	dwPatn;			//	Same pattern image(8bits)
	DWORD	dwPatnNum;		//	Same pattern number
	DWORD	dwNextColor;	//	Color of next bit
} PATNINFO;

extern	const CODETABLE WhiteMakeUpTable[];
extern	const CODETABLE WhiteTerminateTable[];
extern	const CODETABLE BlackMakeUpTable[];
extern	const CODETABLE BlackTerminateTable[];

DWORD	FjCountBits( BYTE *pTmp, DWORD cBitsTmp, DWORD cBitsMax, BOOL bWhite );
VOID	FjBitsCopy( BYTE *pTmp, DWORD cBitsTmp, DWORD dwCode, INT cCopyBits );

// end of FUMHDEF.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuxl.h ===
///////////////////////////////////////////////////////////////
// fuxl.h
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

// NTRAID#NTBUG9-553890-2002/03/22-yasuho-: mandatory changes (strsafe.h)

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
#include <strsafe.h>

#define	FUXL_OEM_SIGNATURE	'FUXL'
#define	FUXL_OEM_VERSION	0x00010000L


typedef	const BYTE FAR*	LPCBYTE;


typedef struct tag_FUXL_OEM_EXTRADATA {
	OEM_DMEXTRAHEADER	dmExtraHdr;
} FUXL_OEM_EXTRADATA, *PFUXL_OEM_EXTRADATA;




#define WRITESPOOLBUF(p, s, n) \
	((p)->pDrvProcs->DrvWriteSpoolBuf((p), (s), (n)))

#define	IS_VALID_FUXLPDEV(p) \
	((p) != NULL && (p)->dwSignature == FUXL_OEM_SIGNATURE)

#define	FUXL_MASTER_UNIT	600
#define	FUXL_MASTER_TO_DEVICE(p,d) \
	((p)->devData.dwResolution * (d) / FUXL_MASTER_UNIT)



typedef struct tag_FUXLDATA {
	DWORD	dwResolution;
	DWORD	dwCopies;
	DWORD	dwSizeReduction;
	DWORD	dwSmoothing;
	DWORD	dwTonerSave;

	DWORD	dwForm;
	DWORD	dwPaperWidth;
	DWORD	dwPaperLength;
	DWORD	dwPaperOrientation;
	DWORD	dwInputBin;
	
	DWORD	dwDuplex;
	DWORD	dwDuplexPosition;
	DWORD	dwDuplexFrontPageMergin;
	DWORD	dwDuplexBackPageMergin;
	DWORD	dwDuplexWhitePage;
} FUXLDATA;

typedef struct tag_FUXLDATA*			PFUXLDATA;
typedef	const struct tag_FUXLDATA*		PCFUXLDATA;


// FUXLDATA.dwForm
#define	FUXL_FORM_A3					0x00000003
#define	FUXL_FORM_A4					0x00000004
#define	FUXL_FORM_A5					0x00000005
#define	FUXL_FORM_B4					0x00010004
#define	FUXL_FORM_B5					0x00010005
#define	FUXL_FORM_LEGAL					0x00020000
#define	FUXL_FORM_LETTER				0x00030000
#define	FUXL_FORM_JAPANESE_POSTCARD		0x00040000
#define	FUXL_FORM_CUSTOM_SIZE			0x00090000

// FUXLDATA.dwInputBin
#define	FUXL_INPUTBIN_AUTO				0
#define	FUXL_INPUTBIN_BIN1				1
#define	FUXL_INPUTBIN_BIN2				2
#define	FUXL_INPUTBIN_BIN3				3
#define	FUXL_INPUTBIN_BIN4				4
#define	FUXL_INPUTBIN_MANUAL			9


typedef struct tag_FUXLPDEV {
	DWORD	dwSignature;

	FUXLDATA	reqData;
	FUXLDATA	devData;

	int			iLinefeedSpacing;	// linefeed spacing[device corrdinate]
	int			x;					// cursor position[device coordinate]
	int			y;

	DWORD		cxPage;				// printable area[dot]
	DWORD		cyPage;

	DWORD		cbBlockData;		// send block data
	DWORD		cBlockByteWidth;
	DWORD		cBlockHeight;

	LPBYTE		pbBand;				// Band memory
	DWORD		cbBand;
	int			yBandTop;			// Top coordinate of Band memory.
	int			cBandByteWidth;		// Byte width of Band memory
	int			cyBandSegment;		// Split Graphics data within 64K
	BOOL		bBandDirty;			// TRUE: Band memory is Dirty(Not all white).
	BOOL		bBandError;			// TRUE: I can't alloc memory for lpbBand
	DWORD		dwOutputCmd;		// Output data format. One of OUTPUT_xxxx macro.

} FUXLPDEV, *PFUXLPDEV;


// @Aug/31/98 ->
#define	MAX_COPIES_VALUE    999
// @Aug/31/98 <-

// end of fuxl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuxlres.c ===
/////////////////////////////////////////
// fuxlres.c
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

// NTRAID#NTBUG9-553890-2002/03/22-yasuho-: mandatory changes (strsafe.h)
// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun

#include "fuxl.h"
#include "fuband.h"
#include "fudebug.h"

// for lib.h debug
DWORD gdwDrvMemPoolTag = 'meoD';

#define	MIN_FREE_WIDTH_300		1063
#define	MAX_FREE_WIDTH_300		3390
#define	MIN_FREE_LENGTH_300		1630
#define	MAX_FREE_LENGTH_300		4843

#define	MIN_FREE_WIDTH_600		2126
#define	MAX_FREE_WIDTH_600		6780
#define	MIN_FREE_LENGTH_600		3260
#define	MAX_FREE_LENGTH_600		9686


#define	FUXL_UNKNOWN			(DWORD)-1


#define	CMDID_ORIENTATION_PORTRAIT			20
#define	CMDID_ORIENTATION_LANDSCAPE			21

#define	CMDID_INPUTBIN_AUTO				30
#define	CMDID_INPUTBIN_MANUAL			31
#define	CMDID_INPUTBIN_BIN1				32
#define	CMDID_INPUTBIN_BIN2				33
#define	CMDID_INPUTBIN_BIN3				34
#define	CMDID_INPUTBIN_BIN4				35

#define	CMDID_RESOLUTION_300				40
#define	CMDID_RESOLUTION_600				41

#define	CMDID_FORM_A3						50
#define	CMDID_FORM_A4						51
#define	CMDID_FORM_A5						52
#define	CMDID_FORM_B4						53
#define	CMDID_FORM_B5						54
#define	CMDID_FORM_LETTER					55
#define	CMDID_FORM_LEGAL					56
#define	CMDID_FORM_JAPANESE_POSTCARD		57
#define	CMDID_FORM_CUSTOM_SIZE				58

#define	CMDID_START_JOB						60
#define	CMDID_END_JOB						61

#define	CMDID_START_DOC						70
#define	CMDID_END_DOC						71


#define	CMDID_START_PAGE					80
#define	CMDID_END_PAGE						81

#define	CMDID_COPIES						90

#define	CMDID_FF							100
#define	CMDID_CR							101
#define	CMDID_LF							102
#define	CMDID_SET_LINE_SPACING				103

#define	CMDID_X_MOVE						110
#define	CMDID_Y_MOVE						111
#define	CMDID_SEND_BLOCK_0					120
#define	CMDID_SEND_BLOCK_1					121

#define	CMDID_SIZEREDUCTION_100				130
#define	CMDID_SIZEREDUCTION_80				131
#define	CMDID_SIZEREDUCTION_70				132

#define	CMDID_SMOOTHING_OFF					140
#define	CMDID_SMOOTHING_ON					141

#define	CMDID_TONERSAVE_OFF					150
#define	CMDID_TONERSAVE_ON					151

#define	CMDID_DUPLEX_NONE					200
#define	CMDID_DUPLEX_VERTICAL				201
#define	CMDID_DUPLEX_HORIZONTAL				202

#define	CMDID_DUPLEX_POSITION_LEFTTOP		210
#define	CMDID_DUPLEX_POSITION_RIGHTBOTTOM	211

#define	CMDID_DUPLEX_WHITEPAGE_OFF			220
#define	CMDID_DUPLEX_WHITEPAGE_ON			221

#define	CMDID_DUPLEX_FRONTPAGE_MERGIN_0		300
#define	CMDID_DUPLEX_FRONTPAGE_MERGIN_30	330

#define	CMDID_DUPLEX_BACKPAGE_MERGIN_0		400
#define	CMDID_DUPLEX_BACKPAGE_MERGIN_30		430




PBYTE fuxlPutULONG(PBYTE pb, size_t *cchCunt_p, ULONG ulData)
{
	if(9 < ulData){
		pb = fuxlPutULONG(pb, cchCunt_p, ulData / 10);
	}

	if ((--(*cchCunt_p)) <= 0)
		return( NULL );
	if (pb)
		*pb++ = (BYTE)('0' + ulData % 10);
	return pb;
}


PBYTE fuxlPutLONG(PBYTE pb, size_t *cchCunt_p, LONG lData)
{
	if(0 > lData){
		if ((--(*cchCunt_p)) <= 0)
			return( NULL );
		*pb++ = '-';
		lData = -lData;
	}
	return fuxlPutULONG(pb, cchCunt_p, (ULONG)lData);
}



BYTE fuxlGetHEX(int hi, int low)
{
	DWORD dwData = 0;

	if('0' <= hi && hi <= '9')
		dwData += (hi - '0');
	else if('a' <= hi && hi <= 'f')
		dwData += (hi - 'a') + 10;
	else if('A' <= hi && hi <= 'F')
		dwData += (hi - 'A') + 10;

	dwData *= 10;

	if('0' <= low && low <= '9')
		dwData += (low - '0');
	else if('a' <= low && low <= 'f')
		dwData += (low - 'a') + 10;
	else if('A' <= low && low <= 'F')
		dwData += (low - 'A') + 10;

	return (BYTE)dwData;
}


// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun
LPBYTE _cdecl fuxlFormatCommand(LPBYTE pbCmd, size_t cchDest, LPCSTR pszFmt, ...)
{
	LPCSTR	pch;
	LPBYTE	pb;
	size_t	cchCunt, cchCunt_p;
	
	va_list arg;
	va_start(arg, pszFmt);
	pb = pbCmd;
	cchCunt = cchDest;
	for(pch = pszFmt; *pch != '\0'; ++pch){
		if(*pch == '%'){
			++pch;
			switch(*pch){
			  case 'd':
				if ((pb=fuxlPutLONG(pb, &cchCunt, va_arg(arg, LONG))) == NULL)
					return( NULL );
				break;
			  case 'u':
				if ((pb=fuxlPutULONG(pb, &cchCunt, va_arg(arg, ULONG))) == NULL)
					return( NULL );
				break;
			  case '%':
				if ((--cchCunt) <= 0)
					return( NULL );
				else
					*pb++ = '%';
				break;
			}
		}
		else if(*pch == '\\'){
			++pch;
			switch(*pch){
			  case 'r':
			  case 'n':
			  case 'f':
			  case '0':
			  case '\\':
			  case 'x':
				if ((--cchCunt) <= 0)
					return( NULL );
				break;
			}
			switch(*pch){
			  case 'r':		*pb++ = '\x0d';		break;
			  case 'n':		*pb++ = '\x0a';		break;
			  case 'f':		*pb++ = '\x0c';		break;
			  case '0':		*pb++ = '\0';		break;
			  case '\\':	*pb++ = '\\';		break;
			  case 'x':	  	*pb++ = fuxlGetHEX(pch[1], pch[2]);	pch += 2;  	break;
			}
		}
		else{
			*pb++ = *pch;
		}
	}
	va_end(arg);

	return pb;
}


void fuxlInitDevData(PFUXLDATA pData)
{
	pData->dwResolution = FUXL_UNKNOWN;
	pData->dwCopies = FUXL_UNKNOWN;
	pData->dwSizeReduction = FUXL_UNKNOWN;
	pData->dwSmoothing = FUXL_UNKNOWN;
	pData->dwTonerSave = FUXL_UNKNOWN;

	pData->dwForm = FUXL_UNKNOWN;
	pData->dwPaperWidth = FUXL_UNKNOWN;
	pData->dwPaperLength = FUXL_UNKNOWN;
	pData->dwPaperOrientation = FUXL_UNKNOWN;
	pData->dwInputBin = FUXL_UNKNOWN;

	pData->dwDuplex = FUXL_UNKNOWN;
	pData->dwDuplexPosition = FUXL_UNKNOWN;
	pData->dwDuplexFrontPageMergin = FUXL_UNKNOWN;
	pData->dwDuplexBackPageMergin = FUXL_UNKNOWN;
	pData->dwDuplexWhitePage = FUXL_UNKNOWN;
}




void fuxlCmdStartJob(PDEVOBJ pdevobj)
{
	TRACEOUT(("[fuxlCmdStartjob]\r\n"))
	WRITESPOOLBUF(pdevobj, "\x1b\x2f\xb2\x40\x7f\x1b\x7f\x00\x00\x01\x07", 11);
}


void fuxlCmdEndJob(PDEVOBJ pdevobj)
{
	TRACEOUT(("[fuxlCmdEndJob]\r\n"))
	WRITESPOOLBUF(pdevobj, "\x1d\x30\x20\x41", 4);
}



static DWORD	getFreeWidth(DWORD dwResolution, DWORD dwPaperWidth)
{
	switch(dwResolution){
	  case 300:
	  	if(dwPaperWidth < MIN_FREE_WIDTH_300)
	  		dwPaperWidth = MIN_FREE_WIDTH_300;
	  	else if(dwPaperWidth > MAX_FREE_WIDTH_300)
	  		dwPaperWidth = MAX_FREE_WIDTH_300;
		break;
	  case 600:
	  	if(dwPaperWidth < MIN_FREE_WIDTH_600)
	  		dwPaperWidth = MIN_FREE_WIDTH_600;
	  	else if(dwPaperWidth > MAX_FREE_WIDTH_600)
	  		dwPaperWidth = MAX_FREE_WIDTH_600;
	  	break;
	  default:
		TRACEOUT(("[getFreeLength]invalid resolution\r\n"))
		break;
	}
	return dwPaperWidth;
}



static DWORD	getFreeLength(DWORD dwResolution, DWORD dwPaperLength)
{
	switch(dwResolution){
	  case 300:
	  	if(dwPaperLength < MIN_FREE_LENGTH_300)
	  		dwPaperLength = MIN_FREE_LENGTH_300;
	  	else if(dwPaperLength > MAX_FREE_LENGTH_300)
	  		dwPaperLength = MAX_FREE_LENGTH_300;
		break;
	  case 600:
	  	if(dwPaperLength < MIN_FREE_LENGTH_600)
	  		dwPaperLength = MIN_FREE_LENGTH_600;
	  	else if(dwPaperLength > MAX_FREE_LENGTH_600)
	  		dwPaperLength = MAX_FREE_LENGTH_600;
	  	break;
	  default:
		TRACEOUT(("[getFreeLength]invalid resolution\r\n"))
		break;
	}
	return dwPaperLength;
}



void fuxlCmdStartDoc(PDEVOBJ pdevobj)
{
	PFUXLPDEV 		pFuxlPDEV;
	PCFUXLDATA		pReq;
	PFUXLDATA		pDev;
	PBYTE			pbCmd;
	BYTE			abCmd[256];
	BOOL			bPaperCommandNeed;
	BOOL			bDuplexChanged;
	DWORD			dwSizeReduction;
	DWORD			dwPaperWidth;
	DWORD			dwPaperLength;

	TRACEOUT(("[fuxlCmdStartDoc]\r\n"))

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pReq = &pFuxlPDEV->reqData;
	pDev = &pFuxlPDEV->devData;
	pbCmd = abCmd;

	bPaperCommandNeed = FALSE;
	bDuplexChanged = FALSE;

	if(pDev->dwResolution != pReq->dwResolution ||
		pDev->dwPaperOrientation != pReq->dwPaperOrientation){
		// NTRAID#NTBUG9-156604-2002/03/22-yasuho-: 
		// Should be perform Res command when orientation was changed.
		pDev->dwResolution = pReq->dwResolution;
		// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun
		if( (pbCmd=fuxlFormatCommand(pbCmd, sizeof(abCmd),
									 "\x1d%d C", pDev->dwResolution)) == NULL )
			return;
	}
	if(pDev->dwSmoothing != pReq->dwSmoothing){
		pDev->dwSmoothing = pReq->dwSmoothing;
		// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun
		if( (pbCmd=fuxlFormatCommand(pbCmd, sizeof(abCmd),
									 "\x1d%d D", pDev->dwSmoothing)) == NULL )
			return;
	}
	if(pDev->dwTonerSave != pReq->dwTonerSave){
		pDev->dwTonerSave = pReq->dwTonerSave;
		// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun
		if( (pbCmd=fuxlFormatCommand(pbCmd, sizeof(abCmd),
									 "\x1d%d E", pDev->dwTonerSave)) == NULL )
			return;
	}

	dwSizeReduction = pReq->dwSizeReduction;
	switch(pReq->dwForm){
	  case FUXL_FORM_A5:
	  case FUXL_FORM_LETTER:
	  case FUXL_FORM_LEGAL:
	  case FUXL_FORM_JAPANESE_POSTCARD:
	  case FUXL_FORM_CUSTOM_SIZE:
	 	dwSizeReduction = 0;
	 	break;
	  case FUXL_FORM_B5:
	  	if(dwSizeReduction != 0 && dwSizeReduction != 1)
	 		dwSizeReduction = 0;
	  	break;
	}
	if(pDev->dwSizeReduction != dwSizeReduction){
		pDev->dwSizeReduction = dwSizeReduction;
		// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun
		if ( (pbCmd=fuxlFormatCommand(pbCmd, sizeof(abCmd),
									  "\x1d%d F", pDev->dwSizeReduction)) == NULL)
			return;
		bPaperCommandNeed = TRUE;
	}
 
 	if(pDev->dwForm != pReq->dwForm){
 		pDev->dwForm = pReq->dwForm;
 		bPaperCommandNeed = TRUE;
 	}
 	if(pDev->dwPaperOrientation != pReq->dwPaperOrientation){
 		pDev->dwPaperOrientation = pReq->dwPaperOrientation;
 		bPaperCommandNeed = TRUE;
 	}
 	if(pDev->dwForm != FUXL_FORM_CUSTOM_SIZE){
	 	if(pDev->dwInputBin != pReq->dwInputBin){
	 		pDev->dwInputBin = pReq->dwInputBin;
	 		bPaperCommandNeed = TRUE;
	 	}
	 	if(bPaperCommandNeed != FALSE){
			// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun
	 		if( (pbCmd=fuxlFormatCommand(pbCmd, sizeof(abCmd),
										 "\x1d%d;%d;%d;%d Q",
										 HIWORD(pDev->dwForm),
										 LOWORD(pDev->dwForm),
										 pDev->dwInputBin,
										 pDev->dwPaperOrientation)) == NULL )
				return;
	 	}
 	}
 	else{
		if(pDev->dwPaperOrientation == 0){
	 		dwPaperWidth = getFreeWidth(pDev->dwResolution, pReq->dwPaperWidth);
 			dwPaperLength = getFreeLength(pDev->dwResolution, pReq->dwPaperLength);
 		}
 		else{
	 		dwPaperLength = getFreeWidth(pDev->dwResolution, pReq->dwPaperWidth);
 			dwPaperWidth = getFreeLength(pDev->dwResolution, pReq->dwPaperLength);
 		}
 		if(pDev->dwPaperWidth != dwPaperWidth){
 			pDev->dwPaperWidth = dwPaperWidth;
 			bPaperCommandNeed = TRUE;
 		}
 		if(pDev->dwPaperLength != dwPaperLength){
 			pDev->dwPaperLength = dwPaperLength;
 			bPaperCommandNeed = TRUE;
 		}
 		if(pDev->dwInputBin != 9){
 			pDev->dwInputBin = 9;
 			bPaperCommandNeed = TRUE;
 		}
 		if(bPaperCommandNeed != FALSE){
			// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun
 			if( (pbCmd=fuxlFormatCommand(pbCmd, sizeof(abCmd),
										 "\x1d%d;%d;%d;%d;%d Q",
										 HIWORD(pDev->dwForm),
										 pDev->dwPaperWidth,
										 pDev->dwPaperLength,
										 pDev->dwInputBin,
										 pDev->dwPaperOrientation)) == NULL )
				return;
 		}
 	}
	if(pDev->dwCopies != pReq->dwCopies){
		pDev->dwCopies = pReq->dwCopies;
		// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun
		if( (pbCmd=fuxlFormatCommand(pbCmd, sizeof(abCmd),
									 "\x1d%d R", pDev->dwCopies)) == NULL )
			return;
	}

	if(pDev->dwDuplex != pReq->dwDuplex){
		bDuplexChanged = TRUE;
		pDev->dwDuplex = pReq->dwDuplex;
	}
	if(pDev->dwDuplex == 0){
		if(bDuplexChanged != FALSE){
			// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun
			if( (pbCmd=fuxlFormatCommand(pbCmd, sizeof(abCmd), "\x1d\x30 G")) == NULL )
				return;
		}
	}
	else{
		if(pDev->dwDuplexPosition != pReq->dwDuplexPosition){
			bDuplexChanged = TRUE;
			pDev->dwDuplexPosition = pReq->dwDuplexPosition;
		}
		if(pDev->dwDuplexFrontPageMergin != pReq->dwDuplexFrontPageMergin){
			bDuplexChanged = TRUE;
			pDev->dwDuplexFrontPageMergin = pReq->dwDuplexFrontPageMergin;
		}
		if(pDev->dwDuplexBackPageMergin != pReq->dwDuplexBackPageMergin){
			bDuplexChanged = TRUE;
			pDev->dwDuplexBackPageMergin = pReq->dwDuplexBackPageMergin;
		}
		if(pDev->dwDuplexWhitePage != pReq->dwDuplexWhitePage){
			bDuplexChanged = TRUE;
			pDev->dwDuplexWhitePage = pReq->dwDuplexWhitePage;
		}
		if(bDuplexChanged != FALSE){
			// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun
			if( (pbCmd=fuxlFormatCommand(pbCmd, sizeof(abCmd),
										 "\x1d%u;%u;%u;%u;%u G",
										 pDev->dwDuplex,
										 pDev->dwDuplexPosition,
										 pDev->dwDuplexFrontPageMergin,
										 pDev->dwDuplexBackPageMergin,
										 pDev->dwDuplexWhitePage)) == NULL )
				return;
			// NTRAID#NTBUG9-199308-2002/03/22-yasuho-: Duplex not work
			// NTRAID#NTBUG9-198813-2002/03/22-yasuho-: Duplex margins not work
			{
				DWORD	dwDuplexCmd;
				DWORD	dwFrontMargin, dwBackMargin;

				dwDuplexCmd = (pDev->dwDuplex - 1) * 2 +
					pDev->dwDuplexPosition;
				dwFrontMargin = (pDev->dwDuplexFrontPageMergin
					* pDev->dwResolution * 10) / 254;
				dwBackMargin = (pDev->dwDuplexBackPageMergin
					* pDev->dwResolution * 10) / 254;
				// NTRAID#NTBUG9-589595-2002/03/29-v-kkon-: Possible buffer overrun
				if( (pbCmd=fuxlFormatCommand(pbCmd, sizeof(abCmd),
											 "\x1BQ2;%u;%u;%u!W",
											 dwDuplexCmd,
											 dwFrontMargin,
											 dwBackMargin)) == NULL )
					return;
			}
		}
	}

	if(pbCmd > abCmd)
		WRITESPOOLBUF(pdevobj, abCmd, (DWORD)(pbCmd - abCmd));
}



void fuxlCmdEndDoc(PDEVOBJ pdevobj)
{
	TRACEOUT(("[fuxlCmdEndJob]\r\n"))
}



void fuxlCmdStartPage(PDEVOBJ pdevobj)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEOUT(("[fuxlCmdStartPage]\r\n"))

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->x = 0;
	pFuxlPDEV->y = 0;
}


void fuxlCmdEndPage(PDEVOBJ pdevobj)
{
	TRACEOUT(("[fuxlCmdEndPage]\r\n"))
}



void fuxlCmdFF(PDEVOBJ pdevobj)
{
	TRACEOUT(("[fuxlCmdFF]\r\n"))
	fuxlRefreshBand(pdevobj);
}



void fuxlCmdCR(PDEVOBJ pdevobj)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEOUT(("[fuxlCmdCR]\r\n"))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->x = 0;
}


void fuxlCmdLF(PDEVOBJ pdevobj)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEOUT(("[fuxlCmdLF]\r\n"))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->y += pFuxlPDEV->iLinefeedSpacing;
}



void fuxlCmdSetLinefeedSpacing(PDEVOBJ pdevobj, int iLinefeedSpacing)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEOUT(("[fuxlCmdSetLinefeedSpacing]%d\r\n", iLinefeedSpacing))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->iLinefeedSpacing = FUXL_MASTER_TO_DEVICE(pFuxlPDEV, iLinefeedSpacing);
}



INT fuxlCmdXMove(PDEVOBJ pdevobj, int x)
{
	PFUXLPDEV	pFuxlPDEV;

	TRACEOUT(("[fuxlCmdXMove] %d\r\n", x))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->x = FUXL_MASTER_TO_DEVICE(pFuxlPDEV, (int)x);
  	if(pFuxlPDEV->x < 0)
  		pFuxlPDEV->x = 0;
  	return pFuxlPDEV->x;
}



INT fuxlCmdYMove(PDEVOBJ pdevobj, int y)
{
	PFUXLPDEV	pFuxlPDEV;

	TRACEOUT(("[fuxlCmdYMove] %d\r\n", y))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->y = FUXL_MASTER_TO_DEVICE(pFuxlPDEV, (int)y);
  	if(pFuxlPDEV->y < 0)
  		pFuxlPDEV->y = 0;
  	return pFuxlPDEV->y;
}



void fuxlCmdSendBlock(PDEVOBJ pdevobj, DWORD dwCount, LPDWORD pdwParams, DWORD dwOutputCmd)
{
	PFUXLPDEV pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;

	TRACEOUT(("[fuxlCmdSendBlock]\r\n"))

	if(3 > dwCount){
		TRACEOUT(("Too less parameter %d\r\n", dwCount))
		return;
	}
	TRACEOUT(("cx %d cy %d\r\n", pdwParams[1] * 8, pdwParams[2]))

	pFuxlPDEV->dwOutputCmd = dwOutputCmd;
	pFuxlPDEV->cbBlockData = pdwParams[0];
	pFuxlPDEV->cBlockByteWidth = (int)pdwParams[1];
	pFuxlPDEV->cBlockHeight = (int)pdwParams[2];
}




// MINI5 Export func.
INT APIENTRY OEMCommandCallback(
	PDEVOBJ pdevobj,
	DWORD 	dwCmdCbID,
	DWORD 	dwCount,
	PDWORD 	pdwParams)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEDDI(("[OEMCommandCallback]dwCmdCbID %d\r\n", dwCmdCbID))

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	if(IS_VALID_FUXLPDEV(pFuxlPDEV) == FALSE)
		return 0;

	switch(dwCmdCbID){
	  case CMDID_START_JOB:					fuxlCmdStartJob(pdevobj);		break;
	  case CMDID_END_JOB:					fuxlCmdEndJob(pdevobj);			break;

	  case CMDID_START_DOC:					fuxlCmdStartDoc(pdevobj);		break;
	  case CMDID_END_DOC:					fuxlCmdEndDoc(pdevobj);			break;

	  case CMDID_START_PAGE:				fuxlCmdStartPage(pdevobj);		break;
	  case CMDID_END_PAGE:					fuxlCmdEndPage(pdevobj);		break;
	
	  case CMDID_FF:						fuxlCmdFF(pdevobj);				break;
	  case CMDID_CR:						fuxlCmdCR(pdevobj);				break;
	  case CMDID_LF:						fuxlCmdLF(pdevobj);				break;
	  case CMDID_SET_LINE_SPACING:			fuxlCmdSetLinefeedSpacing(pdevobj, (int)pdwParams[0]);		break;
	  case CMDID_X_MOVE:					return fuxlCmdXMove(pdevobj, (int)pdwParams[0]);			// no break
	  case CMDID_Y_MOVE:					return fuxlCmdYMove(pdevobj, (int)pdwParams[0]);			// no break

	  case CMDID_SEND_BLOCK_0:				fuxlCmdSendBlock(pdevobj, dwCount, pdwParams, OUTPUT_MH | OUTPUT_RTGIMG2);	break;
	  case CMDID_SEND_BLOCK_1:				fuxlCmdSendBlock(pdevobj, dwCount, pdwParams, OUTPUT_MH2 | OUTPUT_RTGIMG4);	break;

	  case CMDID_RESOLUTION_300:			pFuxlPDEV->reqData.dwResolution = 300;						break;
	  case CMDID_RESOLUTION_600:			pFuxlPDEV->reqData.dwResolution = 600;						break;

	  case CMDID_ORIENTATION_PORTRAIT:		pFuxlPDEV->reqData.dwPaperOrientation = 0;					break;
	  case CMDID_ORIENTATION_LANDSCAPE:		pFuxlPDEV->reqData.dwPaperOrientation = 1;					break;

	  case CMDID_INPUTBIN_AUTO:				pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_AUTO;			break;
	  case CMDID_INPUTBIN_MANUAL:			pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_MANUAL;		break;
	  case CMDID_INPUTBIN_BIN1:				pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_BIN1;			break;
	  case CMDID_INPUTBIN_BIN2:				pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_BIN2;			break;
	  case CMDID_INPUTBIN_BIN3:				pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_BIN3;			break;
	  case CMDID_INPUTBIN_BIN4:				pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_BIN4;			break;
 
	  case CMDID_FORM_A3:					pFuxlPDEV->reqData.dwForm = FUXL_FORM_A3;					break;
	  case CMDID_FORM_A4:					pFuxlPDEV->reqData.dwForm = FUXL_FORM_A4;					break;
	  case CMDID_FORM_A5:					pFuxlPDEV->reqData.dwForm = FUXL_FORM_A5;					break;
	  case CMDID_FORM_B4:					pFuxlPDEV->reqData.dwForm = FUXL_FORM_B4;					break;
	  case CMDID_FORM_B5:					pFuxlPDEV->reqData.dwForm = FUXL_FORM_B5;					break;
	  case CMDID_FORM_LETTER:				pFuxlPDEV->reqData.dwForm = FUXL_FORM_LETTER;				break;
	  case CMDID_FORM_LEGAL:				pFuxlPDEV->reqData.dwForm = FUXL_FORM_LEGAL;				break;
	  case CMDID_FORM_JAPANESE_POSTCARD:	pFuxlPDEV->reqData.dwForm = FUXL_FORM_JAPANESE_POSTCARD;	break;
	  case CMDID_FORM_CUSTOM_SIZE:			pFuxlPDEV->reqData.dwForm = FUXL_FORM_CUSTOM_SIZE;			break;

	  case CMDID_SIZEREDUCTION_100:			pFuxlPDEV->reqData.dwSizeReduction = 0;						break;
	  case CMDID_SIZEREDUCTION_80:			pFuxlPDEV->reqData.dwSizeReduction = 1;						break;
	  case CMDID_SIZEREDUCTION_70:			pFuxlPDEV->reqData.dwSizeReduction = 2;						break;

	  case CMDID_SMOOTHING_OFF:				pFuxlPDEV->reqData.dwSmoothing = 0;							break;
	  case CMDID_SMOOTHING_ON:				pFuxlPDEV->reqData.dwSmoothing = 1;							break;

	  case CMDID_TONERSAVE_OFF:				pFuxlPDEV->reqData.dwTonerSave = 0;							break;
	  case CMDID_TONERSAVE_ON:				pFuxlPDEV->reqData.dwTonerSave = 1;							break;

	  case CMDID_DUPLEX_NONE:				pFuxlPDEV->reqData.dwDuplex = 0;							break;
	  case CMDID_DUPLEX_VERTICAL:			pFuxlPDEV->reqData.dwDuplex = 1;							break;
	  case CMDID_DUPLEX_HORIZONTAL:			pFuxlPDEV->reqData.dwDuplex = 2;							break;

	  case CMDID_DUPLEX_POSITION_LEFTTOP:		pFuxlPDEV->reqData.dwDuplexPosition = 0;				break;
	  case CMDID_DUPLEX_POSITION_RIGHTBOTTOM:	pFuxlPDEV->reqData.dwDuplexPosition = 1;				break;

	  case CMDID_DUPLEX_WHITEPAGE_OFF:		pFuxlPDEV->reqData.dwDuplexWhitePage = 0;					break;
	  case CMDID_DUPLEX_WHITEPAGE_ON:		pFuxlPDEV->reqData.dwDuplexWhitePage = 1;					break;

// @Aug/31/98 ->
    case CMDID_COPIES:
        if (MAX_COPIES_VALUE < pdwParams[0]) {
            pFuxlPDEV->reqData.dwCopies = MAX_COPIES_VALUE;
        }
        else if(1 > pdwParams[0]) {
            pFuxlPDEV->reqData.dwCopies = 1;
        }
        else {
            pFuxlPDEV->reqData.dwCopies = pdwParams[0];
        }
        break;
// @Aug/31/98 <-
	}

	if(CMDID_DUPLEX_FRONTPAGE_MERGIN_0 <= dwCmdCbID && dwCmdCbID <= CMDID_DUPLEX_FRONTPAGE_MERGIN_30){
		pFuxlPDEV->reqData.dwDuplexFrontPageMergin = dwCmdCbID - CMDID_DUPLEX_FRONTPAGE_MERGIN_0;
	}
	else if(CMDID_DUPLEX_BACKPAGE_MERGIN_0 <= dwCmdCbID && dwCmdCbID <= CMDID_DUPLEX_BACKPAGE_MERGIN_30){
		pFuxlPDEV->reqData.dwDuplexBackPageMergin = dwCmdCbID - CMDID_DUPLEX_BACKPAGE_MERGIN_0;
	}

	return 0;
}




// MINI5 Export func.
PDEVOEM APIENTRY OEMEnablePDEV(
	PDEVOBJ			pdevobj,
	PWSTR			pPrinterName,
	ULONG			cPatterns,
	HSURF*			phsurfPatterns,
	ULONG			cjGdiInfo,
	GDIINFO*		pGdiInfo,
	ULONG			cjDevInfo,
	DEVINFO*		pDevInfo,
	DRVENABLEDATA*	pded
	)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEDDI(("[OEMEnablePDEV]\r\n"));

	pFuxlPDEV = (PFUXLPDEV)MemAllocZ(sizeof(FUXLPDEV));
	if(pFuxlPDEV != NULL){
		pFuxlPDEV->dwSignature = FUXL_OEM_SIGNATURE;

		pFuxlPDEV->cbBlockData = 0;
		pFuxlPDEV->cBlockByteWidth = 0;
		pFuxlPDEV->cBlockHeight = 0;
		pFuxlPDEV->iLinefeedSpacing = 0;
		pFuxlPDEV->x = 0;
		pFuxlPDEV->y = 0;

		pFuxlPDEV->cxPage = pGdiInfo->ulHorzRes;
		pFuxlPDEV->cyPage = pGdiInfo->ulVertRes;
		TRACEOUT(("szlPhysSize %d, %d\r\n", pGdiInfo->szlPhysSize.cx, pGdiInfo->szlPhysSize.cy))
		TRACEOUT(("cxPage %d cyPage %d\r\n", pFuxlPDEV->cxPage, pFuxlPDEV->cyPage))

		fuxlInitDevData(&pFuxlPDEV->devData);
		fuxlInitDevData(&pFuxlPDEV->reqData);
		fuxlInitBand(pFuxlPDEV);
	}
	TRACEOUT(("[OEMEnablePDEV]exit\r\n"))
	return pFuxlPDEV;
}


// MINI5 Export func.
VOID APIENTRY OEMDisablePDEV(PDEVOBJ pdevobj)
{
	PFUXLPDEV pFuxlPDEV;
	TRACEDDI(("[OEMDisablePDEV]\r\n"));

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	if(IS_VALID_FUXLPDEV(pFuxlPDEV) == FALSE)
		return;

	fuxlDisableBand(pFuxlPDEV);
	MemFree(pdevobj->pdevOEM);
	pdevobj->pdevOEM = NULL;
}



// MINI5 Export func.
BOOL APIENTRY OEMResetPDEV(
	PDEVOBJ pdevobjOld,
	PDEVOBJ pdevobjNew
	)
{
	PFUXLPDEV pFuxlPDEVOld;
	PFUXLPDEV pFuxlPDEVNew;

	TRACEDDI(("[OemResetPDEV]\r\n"))

	pFuxlPDEVOld = (PFUXLPDEV)pdevobjOld->pdevOEM;
	if(IS_VALID_FUXLPDEV(pFuxlPDEVOld) == FALSE)
		return FALSE;

	pFuxlPDEVNew = (PFUXLPDEV)pdevobjNew->pdevOEM;
	if(IS_VALID_FUXLPDEV(pFuxlPDEVNew) == FALSE)
		return FALSE;

	pFuxlPDEVNew->devData = pFuxlPDEVOld->devData;

	return TRUE;
}



// end of fuxlres.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\fuj\$(ALT_PROJECT)
UNIDIR=$(PRNROOT)\unidrv2
SRCDIR=..

TARGETNAME=fuxlres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),fuxlres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc;$(UNIDIR)\inc

RCCODEPAGE=932

UMTYPE=windows

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
    $(SRCDIR)\fuxlres.rc \
    $(SRCDIR)\fuxlres.c \
    $(SRCDIR)\fuxldm.c \
    $(SRCDIR)\fudebug.c \
    $(SRCDIR)\fuband.c \
    $(SRCDIR)\fumh2.c \
    $(SRCDIR)\fumh.c \
    $(SRCDIR)\fuimg4.c \
    $(SRCDIR)\fuimg2.c

MISCFILES=\
    $(SRCDIR)\fuxlres.ini \
    $(GPDDIR)\fugl340j.gpd \
    $(GPDDIR)\fugl34ej.gpd \
    $(GPDDIR)\fugl360j.gpd \
    $(GPDDIR)\fugl36ej.gpd \
    $(GPDDIR)\fugl740j.gpd \
    $(GPDDIR)\fugl74ej.gpd \
    $(GPDDIR)\fugl760j.gpd \
    $(GPDDIR)\fugl76ej.gpd \
    $(GPDDIR)\fuxl25j.gpd \
    $(GPDDIR)\fuxl50j.gpd \
    $(GPDDIR)\fuxl50mj.gpd \
    $(GPDDIR)\fuxl51j.gpd \
    $(GPDDIR)\fuxl52j.gpd \
    $(GPDDIR)\fuxl53j.gpd \
    $(GPDDIR)\fuxl532j.gpd \
    $(GPDDIR)\fuxl551j.gpd \
    $(GPDDIR)\fuxl56j.gpd \
    $(GPDDIR)\fuxl56mj.gpd \
    $(GPDDIR)\fuxl57j.gpd \
    $(GPDDIR)\fuxl572j.gpd \
    $(GPDDIR)\fuxl58j.gpd \
    $(GPDDIR)\fuxl581j.gpd \
    $(GPDDIR)\fuxl60j.gpd \
    $(GPDDIR)\fuxl601j.gpd \
    $(GPDDIR)\fuxl60mj.gpd \
    $(GPDDIR)\fuxl610j.gpd \
    $(GPDDIR)\fuxl65j.gpd \
    $(GPDDIR)\fuxl65mj.gpd \
    $(GPDDIR)\fuxl66j.gpd

# end of SOURCES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fxartres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fxartres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

// NTRAID#NTBUG9-572152-2002/03/12-yasuho-: Remove the dead code.

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

// NTRAID#NTBUG9-493148-2002/03/12-yasuho-:
// Stress break: PDEV resetting via OEMDevMode().
static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEM_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            VERBOSE(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fxartres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

// NTRAID#NTBUG9-552017-2002/03/12-yasuho-: Use strsafe.h/PREFAST/buffy
// NTRAID#NTBUG9-572151-2002/03/12-yasuho-: Possible buffer overrun.
// NTRAID#NTBUG9-572152-2002/03/12-yasuho-: Remove the dead code.
// NTRAID#NTBUG9-588574-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return E_FAIL;

}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return E_FAIL;

}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

    OEMDisablePDEV(pdevobj);
    return S_OK;
//  return E_NOTIMPL;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));
    VERBOSE((DLLTEXT("        Function:%s:"),pMethodName));

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;

                if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'I':
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'M':
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        VERBOSE(("Supported\n"));
        return S_OK;
    }
    else
    {
        VERBOSE(("NOT supported\n"));
        return E_FAIL;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    if (*piResult >= 0)
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if(OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    if (bOEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    if (bOEMSendFontCmd(pdevobj, pUFObj, pFInv))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE((DLLTEXT("Class factory:\t\tCreate component.")));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//


//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fxartres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fxartres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

// NTRAID#NTBUG9-552017-2002/03/12-yasuho-: Use strsafe.h/PREFAST/buffy
// NTRAID#NTBUG9-572151-2002/03/12-yasuho-: Possible buffer overrun.

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
#include <strsafe.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'FXAT'      // LG GDI x00 series dll
#define DLLTEXT(s)      "FXAT: " s
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

#define STRBUFSIZE  1024	// Must be power of 2.
#define MAX_FONTS   25		// Also see the gFonts[] in fxartres.c.

typedef struct tag_OEM_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
} OEM_EXTRADATA, *POEM_EXTRADATA;

// NTRAID#NTBUG9-493148-2002/03/12-yasuho-: 
// Stress break: PDEV resetting via OEMDevMode().

typedef struct tag_FXPDEV {
    // Private extention
    POINTL  ptlOrg;
    POINTL  ptlCur;
    SIZEL   sizlRes;
    SIZEL   sizlUnit;
    WORD    iCopies;
    CHAR    *chOrient;
    CHAR    *chSize;
    BOOL    bString;
    WORD    cFontId;
    WORD    iFontId;
    WORD    iFontHeight;
    WORD    iFontWidth;
    WORD    iFontWidth2;
    LONG    aFontId[MAX_FONTS];
    POINTL ptlTextCur;
    WORD    iTextFontId;
    WORD    iTextFontHeight;
    WORD    iTextFontWidth;
    WORD    iTextFontWidth2;
    WORD    cTextBuf;
    BYTE    ajTextBuf[STRBUFSIZE];
    WORD    fFontSim;
    BOOL    fSort;
    BOOL    fCallback;  //Is OEMFilterGraphics called?
    BOOL    fPositionReset;
    WORD    iCurFontId; // id of font currently selected
// NTRAID#NTBUG9-365649-2002/03/12-yasuho-: Invalid font size
    WORD    iCurFontHeight;
    WORD    iCurFontWidth;
// For internal calculation of X-pos.
    LONG widBuf[STRBUFSIZE];
    LONG    lInternalXAdd;
    WORD    wSBCSFontWidth;
// For TIFF compression in fxartres
    DWORD   dwTiffCompressBufSize;
    PBYTE   pTiffCompressBuf;
// NTRAID#NTBUG9-208433-2002/03/12-yasuho-: 
// Output images are broken on ART2/3 models.
    BOOL    bART3;	// ART2/3 models can't support the TIFF compression.
} FXPDEV, *PFXPDEV;

// For TIFF compression in fxartres
#define TIFFCOMPRESSBUFSIZE 2048        // It may be resize if needed more buffer dynamically.
#define TIFF_MIN_RUN        4           // Minimum repeats before use RLE
#define TIFF_MAX_RUN        128         // Maximum repeats
#define TIFF_MAX_LITERAL    128         // Maximum consecutive literal data
#define NEEDSIZE4TIFF(s)    ((s)+(((s)+127) >> 7))          // Buffer for TIFF compression requires a byte 
                                                            // per 128 bytes in the worst case.

// Device font height and font width values calculated
// form the IFIMETRICS field values.  Must be the same way
// what Unidrv is doing to calculate stdandard variables.
// (Please check.)

#define FH_IFI(p) ((p)->fwdUnitsPerEm)
#define FW_IFI(p) ((p)->fwdAveCharWidth)

// New interface functions with Unidrv callbacks.

#ifdef __cplusplus
extern "C" {
#endif

BOOL APIENTRY
bOEMSendFontCmd(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION pFInv
    );

BOOL APIENTRY
bOEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph
    );

#ifdef __cplusplus
}
#endif

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fxartres\fxartres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    fxartres.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

// NTRAID#NTBUG9-552017-2002/03/12-yasuho-: Use strsafe.h/PREFAST/buffy
// NTRAID#NTBUG9-572151-2002/03/12-yasuho-: Possible buffer overrun.
// NTRAID#NTBUG9-572152-2002/03/12-yasuho-: Remove the dead code.

#include "pdev.h"

#define FX_VERBOSE VERBOSE

// NTRAID#NTBUG9-493148-2002/03/12-yasuho-: 
// Stress break: PDEV resetting via OEMDevMode().

/*
 *  OEMEnablePDEV
 */
PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PFXPDEV         pOEM;

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(FXPDEV))))
        {
            ERR(("Failed to allocate pdev"));
            return NULL;
        }
    }

    pOEM = (PFXPDEV)pdevobj->pdevOEM;

    // Initialize private data
    pOEM->ptlOrg.x = 0;
    pOEM->ptlOrg.y = 0;
    pOEM->sizlRes.cx = 0;
    pOEM->sizlRes.cy = 0;
    pOEM->sizlUnit.cx = 1;
    pOEM->sizlUnit.cy = 1;
    pOEM->iCopies = 0;
    pOEM->bString = FALSE;
    pOEM->cFontId = 0;
    pOEM->iFontId = 0;
    pOEM->iFontHeight = 0;
    pOEM->iFontWidth = 0;
    pOEM->iFontWidth2 = 0;
    pOEM->ptlTextCur.x = 0;
    pOEM->ptlTextCur.y = 0;
    pOEM->iTextFontId = 0;
    pOEM->iTextFontHeight = 0;
    pOEM->iTextFontWidth = 0;
    pOEM->iTextFontWidth2 = 0;
    pOEM->cTextBuf = 0;
    pOEM->fFontSim = 0;
    pOEM->fCallback = FALSE;
    pOEM->fPositionReset = TRUE;
    pOEM->fSort = FALSE;

    pOEM->iCurFontId = 0;
// NTRAID#NTBUG9-365649-2002/03/12-yasuho-: Invalid font size
    pOEM->iCurFontHeight = 0;
    pOEM->iCurFontWidth = 0;

    // For internal calculation of X-pos.
    pOEM->lInternalXAdd = 0;

    // For TIFF compression in fxartres
    if( !(pOEM->pTiffCompressBuf =(PBYTE)MemAllocZ(TIFFCOMPRESSBUFSIZE)) )
    {
        ERR(("MemAlloc failed.\n"));
        return NULL;
    }
    pOEM->dwTiffCompressBufSize = TIFFCOMPRESSBUFSIZE;

    // Intialize another private buffers
    ZeroMemory(pOEM->widBuf, sizeof(pOEM->widBuf));
    ZeroMemory(pOEM->ajTextBuf, sizeof(pOEM->ajTextBuf));
    ZeroMemory(pOEM->aFontId, sizeof(pOEM->aFontId));

// NTRAID#NTBUG9-208433-2002/03/12-yasuho-: 
// Output images are broken on ART2/3 models.
    pOEM->bART3 = FALSE;

    return pdevobj->pdevOEM;
}

/*
 *  OEMDisablePDEV
 */
VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    PFXPDEV     pOEM;

    if(pOEM = (PFXPDEV)pdevobj->pdevOEM)
    {
        if (pOEM->pTiffCompressBuf) {
            MemFree(pOEM->pTiffCompressBuf);
            pOEM->pTiffCompressBuf = NULL;
            pOEM->dwTiffCompressBufSize = 0;
        }
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
}

/*
 *  OEMResetPDEV
 */
BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PFXPDEV     pOEMOld = (PFXPDEV)pdevobjOld->pdevOEM;
    PFXPDEV     pOEMNew = (PFXPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL) {
        //
        // copy over the private fields, if they are valid
        //

        // Copy private data
        pOEMNew->ptlOrg.x = pOEMOld->ptlOrg.x;
        pOEMNew->ptlOrg.y = pOEMOld->ptlOrg.y;
        pOEMNew->sizlRes.cx = pOEMOld->sizlRes.cx;
        pOEMNew->sizlRes.cy = pOEMOld->sizlRes.cy;
        pOEMNew->sizlUnit.cx = pOEMOld->sizlUnit.cx;
        pOEMNew->sizlUnit.cy = pOEMOld->sizlUnit.cy;
        pOEMNew->iCopies = pOEMOld->iCopies;
        pOEMNew->bString = pOEMOld->bString;
        pOEMNew->cFontId = pOEMOld->cFontId;
        pOEMNew->iFontId = pOEMOld->iFontId;
        pOEMNew->iFontHeight = pOEMOld->iFontHeight;
        pOEMNew->iFontWidth = pOEMOld->iFontWidth;
        pOEMNew->iFontWidth2 = pOEMOld->iFontWidth2;
        pOEMNew->ptlTextCur.x = pOEMOld->ptlTextCur.x;
        pOEMNew->ptlTextCur.y = pOEMOld->ptlTextCur.y;
        pOEMNew->iTextFontId = pOEMOld->iTextFontId;
        pOEMNew->iTextFontHeight = pOEMOld->iTextFontHeight;
        pOEMNew->iTextFontWidth = pOEMOld->iTextFontWidth;
        pOEMNew->iTextFontWidth2 = pOEMOld->iTextFontWidth2;
        pOEMNew->cTextBuf = pOEMOld->cTextBuf;
        pOEMNew->fFontSim = pOEMOld->fFontSim;
        pOEMNew->fCallback = pOEMOld->fCallback;
        pOEMNew->fPositionReset = pOEMOld->fPositionReset;
        pOEMNew->fSort = pOEMOld->fSort;
        pOEMNew->iCurFontId = pOEMOld->iCurFontId;
// NTRAID#NTBUG9-365649-2002/03/12-yasuho-: Invalid font size
        pOEMNew->iCurFontHeight = pOEMOld->iCurFontHeight;
        pOEMNew->iCurFontWidth = pOEMOld->iCurFontWidth;

        // For internal calculation of X-pos.
        pOEMNew->lInternalXAdd = pOEMOld->lInternalXAdd;
        memcpy((PBYTE)pOEMNew->widBuf, (PBYTE)pOEMOld->widBuf, sizeof(pOEMNew->widBuf));

        // Copy private buffer
        pOEMNew->chOrient = pOEMOld->chOrient;
        pOEMNew->chSize = pOEMOld->chSize;
        memcpy((PBYTE)pOEMNew->aFontId, (PBYTE)pOEMOld->aFontId, sizeof(pOEMNew->aFontId));
        memcpy((PBYTE)pOEMNew->ajTextBuf, (PBYTE)pOEMOld->ajTextBuf, sizeof(pOEMNew->ajTextBuf));
    }
    return TRUE;
}

// #######

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

#define DEVICE_MASTER_UNIT 7200
#define DRIVER_MASTER_UNIT 1200

// @Aug/31/98 ->
#define MAX_COPIES_VALUE 99
// @Aug/31/98 <-

#define MAX_COPIES_VALUE_450 999

#define FONT_SIM_ITALIC 1
#define FONT_SIM_BOLD 2
#define FONT_SIM_WHITE 4

// to get physical paper sizes.

typedef struct tagMYFORMS {
    CHAR *id;
    LONG x;
    LONG y;
} MYFORMS, *LPMYFORMS;

// font name to font id mappnig

typedef struct tagMYFONTS {
    LONG id;
    BYTE *fid1;
    BYTE *fid2;
} MYFONTS, *LPMYFONTS;

//
// Load necessary information for specified paper size.
// Make sure PC_OCD_LANDSCAPE and PC_OCD_PORTRAIT are
// called.
//

MYFORMS gForms[] = {
    "a3", 13608, 19422,
    "a4", 9498, 13608,
    "a5", 6570, 9498,
    "a6", 4515, 6570,
    "b4", 11718, 16776,
    "b5", 8178, 11718,
    "b6", 5648, 8178,
    "pc", 4302, 6570, // Postcard
    "o0", 12780, 19980, // Tabloid
    "o1", 9780, 12780, // Letter
    "o2", 9780, 15180, // German Legal Fanfold
    "o3", 9780, 16380, // Legal
    "s1", 4530, 10962, // (Env) Comm 10
    "s2", 4224, 8580, // (Env) Monarch
    "s3", 4776, 9972, // (Env) DL
    "s4", 7230, 10398, // (Env) C5
    "hl", 6390, 9780, // Statement
    NULL, 0, 0
};

MYFONTS gFonts[MAX_FONTS] = {

    150, "fid 150 1 0 0 960 480\n", "fid 151 2 4 0 960 960\n", // Mincho
    156, "fid 156 1 0 0 960 480\n", "fid 157 2 5 0 960 960\n", // @Mincho

    152, "fid 152 1 0 1 960 480\n", "fid 153 2 4 1 960 960\n", // Gothic
    158, "fid 158 1 0 1 960 480\n", "fid 159 2 5 1 960 960\n", // @Gothic

    154, "fid 154 1 0 8 960 480\n", "fid 155 2 4 2 960 960\n", // Maru-Gothic
    160, "fid 160 1 0 8 960 480\n", "fid 161 2 5 2 960 960\n", // @Maru-Gothic

    162, "fid 162 1 130 108 0 0\n", "fid 163 1 128 108 0 0\n", // CS Courier
    164, "fid 164 1 130 109 0 0\n", "fid 165 1 128 109 0 0\n", // CS Courier Italic
    166, "fid 166 1 130 110 0 0\n", "fid 167 1 128 110 0 0\n", // CS Courier Bold
    168, "fid 168 1 130 111 0 0\n", "fid 169 1 128 111 0 0\n", // CS Courier Bold Italic

    172, "fid 172 1 130 100 0 0\n", "fid 173 1 128 100 0 0\n", // CS Times
    174, "fid 174 1 130 102 0 0\n", "fid 175 1 128 102 0 0\n", // CS Times Bold
    176, "fid 176 1 130 101 0 0\n", "fid 177 1 128 101 0 0\n", // CS Times Italic
    178, "fid 178 1 130 103 0 0\n", "fid 179 1 128 103 0 0\n", // CS Times Bold Italic
    180, "fid 180 1 130 104 0 0\n", "fid 181 1 128 104 0 0\n", // CS Triumvirate
    182, "fid 182 1 130 106 0 0\n", "fid 183 1 128 106 0 0\n", // CS Triumvirate Bold
    184, "fid 184 1 130 105 0 0\n", "fid 185 1 128 105 0 0\n", // CS Triumvirate Italic
    186, "fid 186 1 130 107 0 0\n", "fid 187 1 128 107 0 0\n", // CS Triumvirate Bold Italic

    188, "fid 188 1 129 112 0 0\n", NULL, // CS Symbols
    189, "fid 189 1 2 6 0 0\n", NULL, // Enhanced Classic
    190, "fid 190 1 2 7 0 0\n", NULL, // Enhanced Modern

    // Assume there is no device which has both Typebank and Heisei
    // typefaces, we re-use FID #s here.

    150, "fid 150 1 0 0 960 480\n", "fid 151 2 4 0 960 960\n", // (Heisei) Mincho
    156, "fid 156 1 0 0 960 480\n", "fid 157 2 5 0 960 960\n", // (Heisei) @Mincho

    152, "fid 152 1 0 1 960 480\n", "fid 153 2 4 1 960 960\n", // (Heisei) Gothic
    158, "fid 158 1 0 1 960 480\n", "fid 159 2 5 1 960 960\n", // (Heisei) @Gothic

};

#define ISDBCSFONT(i) ((i) < 162)
#define ISVERTFONT(i) ((i) >= 156 && (i) < 162)
#define ISPROPFONT(i) ((i) >= 172 && (i) < 190)

#define MARK_ALT_GSET 0x01
#define BISMARKSBCS(i) ((i) >= 0 && (i) < 0x20)

BOOL
LoadPaperInfo(
    PFXPDEV pOEM,
    CHAR *id ) {

    LPMYFORMS ptmp;

    for ( ptmp = gForms; ptmp->id; ptmp++ ) {
        if ( strcmp( id, ptmp->id) == 0 )
            break;
    }

    if ( ptmp->id == NULL )
        return FALSE;

    FX_VERBOSE(("PI: %s->%s\n", id, ptmp->id ));

    pOEM->chSize = ptmp->id;

    pOEM->ptlOrg.x = 0;
    if ( strcmp( pOEM->chOrient, "l") == 0 ){
        pOEM->ptlOrg.y = ptmp->x;
    }
    else {
        pOEM->ptlOrg.y = ptmp->y;
    }

    pOEM->ptlOrg.x += 210;
    pOEM->ptlOrg.y += 210;

    return TRUE;
}


#define TOHEX(j) ((j) < 10 ? ((j) + '0') : ((j) - 10 + 'a'))

BOOL
HexOutput(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    BYTE Buf[STRBUFSIZE];
    BYTE *pSrc, *pSrcMax;
    LONG iRet, j;

    pSrc = (BYTE *)pBuf;
    pSrcMax = pSrc + dwLen;
    iRet = 0;

    while ( pSrc < pSrcMax ) {

        for ( j = 0; j < sizeof(Buf)-1 && pSrc < pSrcMax; pSrc++ ) {

            BYTE c1, c2;

            c1 = (((*pSrc) >> 4) & 0x0f);
            c2 = (*pSrc & 0x0f);

            Buf[ j++ ] = TOHEX( c1 );
            Buf[ j++ ] = TOHEX( c2 );
        }

        if (WRITESPOOLBUF( pdevobj, Buf, j ) == 0)
            break;

        iRet += j;
    }
    return TRUE;
}


BOOL
BeginString(
    PDEVOBJ pdevobj,
    BOOL bReset )
{
    BYTE buf[512];
    PFXPDEV pOEM;
    BYTE *pbuf;
    size_t rem;

    pOEM = (PFXPDEV)pdevobj->pdevOEM;

    if (pOEM->bString)
        return TRUE;

    pbuf = buf;
    rem = sizeof buf;
    if ( bReset ) {

        FX_VERBOSE(("BS: %d(%d),%d(%d)\n",
            ( pOEM->ptlOrg.x + pOEM->ptlTextCur.x ),
            pOEM->ptlTextCur.x,
            ( pOEM->ptlOrg.y - pOEM->ptlTextCur.y ),
            pOEM->ptlTextCur.y));

        if (FAILED(StringCchPrintfExA(pbuf, rem, &pbuf, &rem, 0,
            "scp %d %d\n",
            ( pOEM->ptlOrg.x + pOEM->ptlTextCur.x ),
            ( pOEM->ptlOrg.y - pOEM->ptlTextCur.y ))))
            return FALSE;
    }

    if (FAILED(StringCchPrintfExA(pbuf, rem, &pbuf, &rem, 0,
        "sh <" )))
        return FALSE;

    if ( (pbuf - buf) > 0 ) {
        WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
    }
    pOEM->bString = TRUE;
    return TRUE;

}

BOOL
EndString(
    PDEVOBJ pdevobj )
{
    BYTE buf[512];
    PFXPDEV pOEM;
    PBYTE pbuf;

    pOEM = (PFXPDEV)pdevobj->pdevOEM;

    if (!pOEM->bString)
        return TRUE;

    pbuf = buf;
    if (FAILED(StringCchPrintfExA(pbuf, sizeof buf, &pbuf, NULL, 0,
        ">\n" )))
        return FALSE;

    if ( (DWORD)(pbuf - buf) > 0 ) {
        WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
    }
    pOEM->bString = FALSE;
    return TRUE;
}

BOOL
BeginVertWrite(
    PDEVOBJ pdevobj )
{
    BYTE buf[512];
    PFXPDEV pOEM;
    BYTE *pbuf;
    size_t rem;

    pOEM = (PFXPDEV)pdevobj->pdevOEM;
    pbuf = buf;
    rem = sizeof buf;

    if (FAILED(StringCchPrintfExA(pbuf, rem, &pbuf, &rem, 0,
        "fo 90\nsrcp %d 0\n", pOEM->iFontHeight)))
        return FALSE;
    if (pOEM->fFontSim & FONT_SIM_ITALIC) {
        if (FAILED(StringCchPrintfExA(pbuf, rem, &pbuf, &rem, 0,
            "trf -18 y\n" )))
            return FALSE;
    }

    pOEM->ptlTextCur.x += pOEM->iFontHeight;

    if ( pbuf > buf ) {
        WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
    }
    return TRUE;
}

BOOL
EndVertWrite(
    PDEVOBJ pdevobj )
{
    BYTE buf[512];
    PFXPDEV pOEM;
    BYTE *pbuf;
    size_t rem;

    pOEM = (PFXPDEV)pdevobj->pdevOEM;
    pbuf = buf;
    rem = sizeof buf;

    if (FAILED(StringCchPrintfExA(pbuf, rem, &pbuf, &rem, 0,
        "fo 0\nsrcp %d 0\n", -(pOEM->iFontHeight) )))
        return FALSE;
    if (pOEM->fFontSim & FONT_SIM_ITALIC) {
        if (FAILED(StringCchPrintfExA(pbuf, rem, &pbuf, &rem, 0,
            "trf x -18\n" )))
            return FALSE;
    }

    if ( pbuf > buf ) {
        WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
    }
    return TRUE;
}

//
// Save the current poistion as the begining position of text output.
// We will cache string output so that we need to remember this.
//

VOID
SaveTextCur(
    PDEVOBJ pdevobj )
{
    PFXPDEV pOEM;

    pOEM = (PFXPDEV)pdevobj->pdevOEM;

    pOEM->ptlTextCur.x = pOEM->ptlCur.x;
    pOEM->ptlTextCur.y = pOEM->ptlCur.y;
    pOEM->iTextFontId = pOEM->iFontId;
    pOEM->iTextFontHeight = pOEM->iFontHeight;
    pOEM->iTextFontWidth = pOEM->iFontWidth;
    pOEM->iTextFontWidth2 = pOEM->iFontWidth2;

    pOEM->fPositionReset = TRUE;
}

//
// Flush out the cached text.  We switch between single byte font and
// double byte font if necesary.
//

BOOL
FlushText(
    PDEVOBJ pdevobj )
{
    INT i;
    BYTE *pStr, *pStrSav, *pStrMax, *pStrSav2;
    BYTE buf[512];
    BOOL bReset;
    PFXPDEV  pOEM;
    INT iMark;
    BOOL bSkipEndString = FALSE;
    PBYTE pbuf;

    pOEM = (PFXPDEV)pdevobj->pdevOEM;
    bReset = pOEM->fPositionReset;

    pStr = pOEM->ajTextBuf;
    pStrMax = &pStr[min(pOEM->cTextBuf, sizeof(pOEM->ajTextBuf))];
    pStrSav = pStr;

    if(!pOEM->cTextBuf)
        return TRUE;

    while(pStr < pStrMax)
    {
        if(ISDBCSFONT(pOEM->iTextFontId))
        {
            // DBCS font case
            for(pStrSav = pStr; pStr < pStrMax; pStr += 2)
            {
                // Search for next SBCS character
                if ( BISMARKSBCS(*pStr) )
                    break;
            }

            if(pStrSav < pStr)
            {
                FX_VERBOSE(("FT: h,w=%d,%d\n",
                    pOEM->iFontHeight, pOEM->iFontWidth));

                // Send DBCS font select command
// NTRAID#NTBUG9-365649-2002/03/12-yasuho-: Invalid font size
                if (pOEM->iCurFontId != (pOEM->iTextFontId + 1) ||
                    pOEM->iCurFontHeight != pOEM->iTextFontHeight ||
                    pOEM->iCurFontWidth != pOEM->iTextFontWidth)
                {
                    if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                        "sfi %d\nfs %d %d\n",
                        (pOEM->iTextFontId + 1),
                        pOEM->iFontHeight, pOEM->iFontWidth2 )))
                        return FALSE;
                    WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
                    pOEM->iCurFontId = (pOEM->iTextFontId + 1);
                    pOEM->iCurFontHeight = pOEM->iTextFontHeight;
                    pOEM->iCurFontWidth = pOEM->iTextFontWidth;
                }

                // If vertical font, send its command
                if( ISVERTFONT(pOEM->iTextFontId) ) {
                    if (!BeginVertWrite(pdevobj)) return FALSE;

                    // Output string: code from BeginString func.
                    if ( bReset ) {
                        if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                            "scp %d %d\n",
                            ( pOEM->ptlOrg.x + pOEM->ptlTextCur.x ),
                            ( pOEM->ptlOrg.y - pOEM->ptlTextCur.y ))))
                            return FALSE;
                        WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
                    }
                    if( 0 == memcmp( pStrSav, "\x21\x25", 2)) {  // 0x2125 = dot character
                        // start with dot character
                        WRITESPOOLBUF( pdevobj, "gs 3\n", 5 );

                        // grset command resets font size, so we have to resend it.
                        if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                            "fs %d %d\n", pOEM->iFontHeight, pOEM->iFontWidth2 )))
                            return FALSE;
                        WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
                    }
                    WRITESPOOLBUF( pdevobj, "sh <", 4 );
                    pOEM->bString = TRUE;      // no need BeginString

                    for( pStrSav2 = pStrSav ; pStrSav2 < pStr ; pStrSav2 += 2 ) {
                        if( 0 == memcmp( pStrSav2, "\x21\x25", 2)) {  // 0x2125 = dot character
                            // special dot printing mode
                            if( pStrSav2 != pStrSav ) {
                                // change glyph set
                                // If pStrSav2 == pStrSav, gs 3 command has already sent.
                                WRITESPOOLBUF( pdevobj, ">\ngs 3\n", 7 );

                                // grset command resets font size, so we have to resend it.
                                if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                                    "fs %d %d\n", pOEM->iFontHeight, pOEM->iFontWidth2 )))
                                    return FALSE;
                                WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );

                                WRITESPOOLBUF( pdevobj, "sh <", 4 );
                                pOEM->bString = TRUE;      // no need BeginString
                            }

                            while( 0 == memcmp( pStrSav2, "\x21\x25", 2) ) {
                                // output a dot character directly
                                WRITESPOOLBUF( pdevobj, "2125", 4 );
                                pStrSav2 += 2;
                            }

                            WRITESPOOLBUF( pdevobj, ">\ngs 5\n", 7 );
                            // Next character exist?
                            if( pStrSav2 < pStr ) {
                                // remain string exists

                                // grset command resets font size, so we have to resend it.
                                if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                                    "fs %d %d\nsh <", pOEM->iFontHeight, pOEM->iFontWidth2 )))
                                    return FALSE;
                                WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
                                pOEM->bString = TRUE;      // no need BeginString
                                bSkipEndString = FALSE;
                            } else { 
                                // no remain string
                                // grset command resets font size, so we have to resend it.
                                if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                                    "fs %d %d\n", pOEM->iFontHeight, pOEM->iFontWidth2 )))
                                    return FALSE;
                                WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
                                pOEM->bString = FALSE;      // need BeginString
                                bSkipEndString = TRUE;
                            }
                        } else {
                            HexOutput(pdevobj, pStrSav2, (WORD)2);
                            bSkipEndString = FALSE;
                        }
                    }

                    if( bSkipEndString == FALSE ) {
                        if (!EndString(pdevobj)) return FALSE;
                    }

                    // send revert command
                    if (!EndVertWrite(pdevobj)) return FALSE;
                } else { 
                    // Horizontal font or no need to change glyph set

                    // Output string
                    if (!BeginString(pdevobj, bReset)) return FALSE;
                    HexOutput(pdevobj, pStrSav, (WORD)(pStr - pStrSav));
                    if (!EndString(pdevobj)) return FALSE;
                }
                bReset = FALSE;
            }

            for(pStrSav = pStr; pStr < pStrMax; pStr += 2)
            {
                // Search for DBCS character
                if (!BISMARKSBCS(*pStr))
                    break;
            }

            if(pStrSav < pStr)
            {
                // Send DBCS font select command
// NTRAID#NTBUG9-365649-2002/03/12-yasuho-: Invalid font size
                if (pOEM->iCurFontId != pOEM->iTextFontId ||
                    pOEM->iCurFontHeight != pOEM->iTextFontHeight ||
                    pOEM->iCurFontWidth != pOEM->iTextFontWidth)
                {
                    if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                        "sfi %d\nfs %d %d\n",
                        pOEM->iTextFontId,
                        pOEM->iFontHeight, pOEM->iFontWidth )))
                        return FALSE;
                    WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
                    pOEM->iCurFontId = pOEM->iTextFontId;
                    pOEM->iCurFontHeight = pOEM->iTextFontHeight;
                    pOEM->iCurFontWidth = pOEM->iTextFontWidth;
                }

                // String output
                if (!BeginString(pdevobj, bReset)) return FALSE;
                for( ; pStrSav < pStr; pStrSav++)
                {
                    if (BISMARKSBCS(*pStrSav))
                        pStrSav++;
                    HexOutput(pdevobj, pStrSav, (WORD)1);
                }
                if (!EndString(pdevobj)) return FALSE;
                bReset = FALSE;
            }
        } else {

            // SBCS font case
            // Send Select Font command

            iMark = *pStr;

// NTRAID#NTBUG9-365649-2002/03/12-yasuho-: Invalid font size
            if (pOEM->iCurFontId != (pOEM->iTextFontId + iMark) ||
                    pOEM->iCurFontHeight != pOEM->iTextFontHeight ||
                    pOEM->iCurFontWidth != pOEM->iTextFontWidth)
            {
                if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                    "sfi %d\nfs %d %d\n",
                    (pOEM->iTextFontId + iMark),
                    pOEM->iFontHeight, pOEM->iFontWidth )))
                    return FALSE;
                WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
                pOEM->iCurFontId = (pOEM->iTextFontId + iMark);
                pOEM->iCurFontHeight = pOEM->iTextFontHeight;
                pOEM->iCurFontWidth = pOEM->iTextFontWidth;
            }

            // String Output
            if (!BeginString(pdevobj, bReset)) return FALSE;
            for(i = 0; i < pOEM->cTextBuf; pStr++)
            {
                if (*pStr != iMark)
                    break;

                // Skip marker character
                pStr++;

                HexOutput(pdevobj, pStr, (WORD)1 );
                i += 2;
            }
            if (!EndString(pdevobj)) return FALSE;
            bReset = FALSE;
            pOEM->cTextBuf -= (WORD)i;

        }
    }

    pOEM->cTextBuf = 0;
    pOEM->fPositionReset = FALSE;
    return TRUE;
}

//*************************************************************
int
iCompTIFF(
    BYTE *pbOBuf,
    int  iBCntO,
    BYTE *pbIBuf,
    int  iBCnt
    )
/*++

Routine Description:

    This function is called to compress a scan line of data using
    TIFF v4 compression.

Arguments:

    pbOBuf      Pointer to output buffer  PRESUMED LARGE ENOUGH
    iBCntO      Size of output buffer
    pbIBuf      Pointer to data buffer to compress
    iBCnt       Number of bytes to compress

Return Value:

    Number of compressed bytes

Note:
    The output buffer is presumed large enough to hold the output.
    In the worst case (NO REPETITIONS IN DATA) there is an extra
    byte added every 128 bytes of input data.  So, you should make
    the output buffer at least 1% larger than the input buffer.

    This routine is copied form UNIDRV.

--*/
{
    BYTE   *pbOut;        /* Output byte location */
    BYTE   *pbStart;      /* Start of current input stream */
    BYTE   *pb;           /* Miscellaneous usage */
    BYTE   *pbEnd;        /* The last byte of input */
    BYTE    jLast;        /* Last byte,  for match purposes */
    BYTE    bLast;
    BYTE   *pbOEnd;       /* The last byte of output */

    int     iSize;        /* Bytes in the current length */
    int     iSend;        /* Number to send in this command */


    pbOut = pbOBuf;
    pbStart = pbIBuf;

	pbEnd  = pbIBuf + iBCnt;     /* The last byte   */
	pbOEnd = pbOBuf + iBCntO;    /* The last buffer */

#if (TIFF_MIN_RUN >= 4)
    // this is a faster algorithm for calculating TIFF compression
    // that assumes a minimum RUN of at least 4 bytes. If the
    // third and fourth byte don't equal then the first/second bytes are
    // irrelevant. This means we can determine non-run data three times
    // as fast since we only check every third byte pair.

   if (iBCnt > TIFF_MIN_RUN)
   {
    // make sure the last two bytes aren't equal so we don't have to check
    // for the buffer end when looking for runs
    bLast = pbEnd[-1];
    pbEnd[-1] = ~pbEnd[-2];
    while( (pbIBuf += 3) < pbEnd )
    {
        if (*pbIBuf == pbIBuf[-1])
        {
            // save the run start pointer, pb, and check whether the first
            // bytes are also part of the run
            //
            pb = pbIBuf-1;
            if (*pbIBuf == pbIBuf[-2])
            {
                pb--;
                if (*pbIBuf == pbIBuf[-3])
                    pb--;
            }

            //  Find out how long this run is
            jLast = *pb;
            do {
                pbIBuf++;
            } while (*pbIBuf == jLast);

            // test whether last byte is also part of the run
            //
            if (jLast == bLast && pbIBuf == (pbEnd-1))
                pbIBuf++;

            // Determine if the run is longer that the required
            // minimum run size.
            //
            if ((iSend = (int)(pbIBuf - pb)) >= (TIFF_MIN_RUN))
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (iSize = (int)(pb - pbStart)) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while (iSize > TIFF_MAX_LITERAL)
                    {
                        // Buffer over run check
                        if ((pbOut+TIFF_MAX_LITERAL) <= pbOEnd) {
                            iSize -= TIFF_MAX_LITERAL;
                            *pbOut++ = TIFF_MAX_LITERAL-1;
                            CopyMemory(pbOut, pbStart, TIFF_MAX_LITERAL);
                            pbStart += TIFF_MAX_LITERAL;
                            pbOut += TIFF_MAX_LITERAL;
                        } else {
                            return 0;
                        }
                    }
                    // Buffer over run check
                    if ((pbOut+iSize) <= pbOEnd) {
                        *pbOut++ = iSize - 1;
                        CopyMemory(pbOut, pbStart, iSize);
                        pbOut += iSize;
                    } else {
                        return 0;
                    }
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */
                iSize = iSend;
                while (iSize > TIFF_MAX_RUN)
                {
                    // Buffer over run check
                    if ((pbOut+2) <= pbOEnd) {
                        *((char *)pbOut)++ = 1 - TIFF_MAX_RUN;
                        *pbOut++ = jLast;
                        iSize -= TIFF_MAX_RUN;
                    } else {
                        return 0;
                    }
                }
                // Buffer over run check
                if ((pbOut+2) <= pbOEnd) {
                   *pbOut++ = 1 - iSize;
                   *pbOut++ = jLast;
                } else {
                   return 0;
                }

                pbStart = pbIBuf;           /* Ready for the next one! */
            }
        }
    }
    pbEnd[-1] = bLast;
   }
#else
    jLast = *pbIBuf++;

    while( pbIBuf < pbEnd )
    {
        if( jLast == *pbIBuf )
        {
            /*  Find out how long this run is.  Then decide on using it */
            pb = pbIBuf;
            do {
                pbIBuf++;
            } while (pbIBuf < pbEnd && *pbIBuf == jLast);

            /*
             *  Note that pb points at the SECOND byte of the pattern!
             *  AND also that pbIBuf points at the first byte AFTER the run.
             */

            if ((iSend = pbIBuf - pb) >= (TIFF_MIN_RUN - 1))
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (iSize = pb - pbStart - 1) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while (iSize > TIFF_MAX_LITERAL)
                    {
                        // Buffer over run check
                        if ((pbOut+TIFF_MAX_LITERAL) <= pbOEnd) {
                            iSize -= TIFF_MAX_LITERAL;
                            *pbOut++ = TIFF_MAX_LITERAL-1;
                            CopyMemory(pbOut, pbStart, TIFF_MAX_LITERAL);
                            pbStart += TIFF_MAX_LITERAL;
                            pbOut += TIFF_MAX_LITERAL;
                        } else {
                            return 0;
                        }
                    }
                    // Buffer over run check
                    if ((pbOut+iSize) <= pbOEnd) {
                        *pbOut++ = iSize - 1;
                        CopyMemory(pbOut, pbStart, iSize);
                        pbOut += iSize;
                    } else {
                        return 0;
                    }
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */

                iSize = iSend + 1;
                while (iSize > TIFF_MAX_RUN)
                {
                    // Buffer over run check
                    if ((pbOut+2) <= pbOEnd) {
                        *((char *)pbOut)++ = 1 - TIFF_MAX_RUN;
                        *pbOut++ = jLast;
                        iSize -= TIFF_MAX_RUN;
                    } else {
                        return 0;
                    }
                }
                // Buffer over run check
                if ((pbOut+2) <= pbOEnd) {
                    *pbOut++ = 1 - iSize;
                    *pbOut++ = jLast;
                } else {
                    return 0;
                }

                pbStart = pbIBuf;           /* Ready for the next one! */
            }
            if (pbIBuf == pbEnd)
                break;
        }

        jLast = *pbIBuf++;                   /* Onto the next byte */

    }
#endif

    if ((iSize = (int)(pbEnd - pbStart)) > 0)
    {
        /*  Left some dangling.  This can only be literal data.   */

        while( (iSend = min( iSize, TIFF_MAX_LITERAL )) > 0 )
        {
            // Buffer over run check
            if ((pbOut+iSend) <= pbOEnd) {
                *pbOut++ = iSend - 1;
                CopyMemory( pbOut, pbStart, iSend );
                pbOut += iSend;
                pbStart += iSend;
                iSize -= iSend;
            } else {
                return 0;
            }
        }
    }

    return  (int)(pbOut - pbOBuf);
}

BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    PFXPDEV         pOEM = (PFXPDEV)(pdevobj->pdevOEM);
    PBYTE           pNewBufPtr;
    DWORD           dwNewBufSize;
    INT             nCompressedSize;

    if(!pOEM->fCallback)
    {
// NTRAID#NTBUG9-208433-2002/03/12-yasuho-: 
// Output images are broken on ART2/3 models.
        if (pOEM->bART3) { // ART2/3 can't support TIFF compression
            WRITESPOOLBUF(pdevobj, pBuf, dwLen);
            return TRUE;
        }

        // For TIFF compression in fxartres
        dwNewBufSize = NEEDSIZE4TIFF(dwLen);
        if( dwNewBufSize > pOEM->dwTiffCompressBufSize)
        {
            if(!(pNewBufPtr = (PBYTE)MemAlloc(dwNewBufSize)))
            {
                ERR(("Re-MemAlloc failed.\n"));
                return TRUE;
            }else {
                // Prepare new buffer
                MemFree(pOEM->pTiffCompressBuf);
                pOEM->pTiffCompressBuf = pNewBufPtr;
                pOEM->dwTiffCompressBufSize = dwNewBufSize;
            }
        }
        // Do TIFF compression 
        nCompressedSize = iCompTIFF( pOEM->pTiffCompressBuf,
                                     pOEM->dwTiffCompressBufSize,  
                                     pBuf, dwLen );
        WRITESPOOLBUF(pdevobj, pOEM->pTiffCompressBuf, nCompressedSize);
        return TRUE;
    }

    return HexOutput(pdevobj, pBuf, dwLen);
}

//-------------------------------------------------------------------
// OEMOutputCmd
// Action :
//-------------------------------------------------------------------

#define CBID_CM_OCD_XM_ABS              1
#define CBID_CM_OCD_YM_ABS              2
#define CBID_CM_OCD_XM_REL              3
#define CBID_CM_OCD_YM_REL              4
#define CBID_CM_OCD_XM_RELLEFT          5
#define CBID_CM_OCD_YM_RELUP            6
#define CBID_CM_CR                      7
#define CBID_CM_FF                      8
#define CBID_CM_LF                      9

#define CBID_PC_OCD_BEGINDOC_ART        11
#define CBID_PC_OCD_BEGINDOC_ART3       12
#define CBID_PC_OCD_BEGINDOC_ART4       13
#define CBID_PC_OCD_BEGINPAGE           14
#define CBID_PC_OCD_ENDPAGE             15
#define CBID_PC_OCD_MULT_COPIES         16
#define CBID_PC_OCD_PORTRAIT            17
#define CBID_PC_OCD_LANDSCAPE           18
#define CBID_PC_OCD_BEGINDOC_ART4_JCL   19
#define CBID_PC_OCD_MULT_COPIES_450     20

#define CBID_RES_OCD_SELECTRES_240DPI   21
#define CBID_RES_OCD_SELECTRES_300DPI   22
#define CBID_RES_OCD_SELECTRES_400DPI   23
#define CBID_RES_OCD_SELECTRES_600DPI   24
#define CBID_RES_OCD_SENDBLOCK_ASCII    25
#define CBID_RES_OCD_SENDBLOCK          26

#define CBID_RES_OCD_SELECTRES_240DPI_ART3_ART   27
#define CBID_RES_OCD_SELECTRES_300DPI_ART3_ART   28

#define CBID_RES_OCD_SELECTRES_450      29

#define CBID_PSZ_OCD_SELECT_A3          30
#define CBID_PSZ_OCD_SELECT_A4          31
#define CBID_PSZ_OCD_SELECT_A5          32
#define CBID_PSZ_OCD_SELECT_B4          33
#define CBID_PSZ_OCD_SELECT_B5          34
#define CBID_PSZ_OCD_SELECT_PC          35
#define CBID_PSZ_OCD_SELECT_DL          36
#define CBID_PSZ_OCD_SELECT_LT          37
#define CBID_PSZ_OCD_SELECT_GG          38
#define CBID_PSZ_OCD_SELECT_LG          39
#define CBID_PSZ_OCD_SELECT_S1          40
#define CBID_PSZ_OCD_SELECT_S2          41
#define CBID_PSZ_OCD_SELECT_S3          42
#define CBID_PSZ_OCD_SELECT_S4          43
#define CBID_PSZ_OCD_SELECT_A6          44
#define CBID_PSZ_OCD_SELECT_B6          45
#define CBID_PSZ_OCD_SELECT_ST          46

#define CBID_FS_OCD_BOLD_ON             51
#define CBID_FS_OCD_BOLD_OFF            52
#define CBID_FS_OCD_ITALIC_ON           53
#define CBID_FS_OCD_ITALIC_OFF          54
#define CBID_FS_OCD_SINGLE_BYTE         55
#define CBID_FS_OCD_DOUBLE_BYTE         56
#define CBID_FS_OCD_WHITE_TEXT_ON       57
#define CBID_FS_OCD_WHITE_TEXT_OFF      58
#define CBID_SRT_OCD_SORTER_ON          59
#define CBID_SRT_OCD_SORTER_OFF         60

#define CBID_PC_OCD_ENDDOC              70

#define CBID_FONT_SELECT_OUTLINE        101

static
BOOL
XYMoveUpdate(
    PDEVOBJ pdevobj)
{
    PFXPDEV pOEM;

    pOEM = (PFXPDEV)(pdevobj->pdevOEM);

    FX_VERBOSE(("XYMoveFlush: %d,%d\n",
        pOEM->ptlCur.x, pOEM->ptlCur.y ));

    if(pOEM->cTextBuf)
        if (!FlushText( pdevobj )) return FALSE;

    SaveTextCur( pdevobj );
    return TRUE;
}

static BOOL
XMoveAbs(PDEVOBJ p, INT i)
{
    ((PFXPDEV)((p)->pdevOEM))->ptlCur.x = (i);
    return XYMoveUpdate(p);
}

// For internal calculation of X-pos.
#define RATE_FONTWIDTH2XPOS 1000
#define VALUE_FONTWIDTH2XPOS_ROUNDUP5   500
static BOOL
YMoveAbs(PDEVOBJ p, INT i)
{
    PFXPDEV pOEM = p->pdevOEM;

    pOEM->ptlCur.y = (i);
    pOEM->ptlCur.x += ((pOEM->lInternalXAdd + VALUE_FONTWIDTH2XPOS_ROUNDUP5) /
        RATE_FONTWIDTH2XPOS);
    pOEM->lInternalXAdd = 0;
    ZeroMemory(pOEM->widBuf, sizeof(pOEM->widBuf));
    return XYMoveUpdate(p);
}

//
//  FreedBuffersInPDEV
//
VOID
FreeCompressBuffers( PDEVOBJ pdevobj )
{
    PFXPDEV  pOEM;

    pOEM = (PFXPDEV)(pdevobj->pdevOEM);
    if( pOEM->pTiffCompressBuf != NULL )
    {
        MemFree(pOEM->pTiffCompressBuf);
        pOEM->pTiffCompressBuf = NULL;
        pOEM->dwTiffCompressBufSize = 0;
    }

    return;
}

/*****************************************************************************/
/*                                                                           */
/*   INT APIENTRY OEMCommandCallback(                                        */
/*                PDEVOBJ pdevobj                                            */
/*                DWORD   dwCmdCbId                                          */
/*                DWORD   dwCount                                            */
/*                PDWORD  pdwParams                                          */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbID,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams ) // points to values of command params
{
    BYTE            buf[512];
    PFXPDEV         pOEM;
    LONG            x, y;
    BOOL            bAscii;
    CHAR           *pStr;
    INT             iRet;
    PBYTE           pbuf;
    size_t          iLen;

    VERBOSE(("OEMCommandCallback entry.\n"));

    ASSERT(VALID_PDEVOBJ(pdevobj));

    pOEM = (PFXPDEV)(pdevobj->pdevOEM);

    bAscii = FALSE;
    iRet = 0;
    pbuf = buf;

    switch( dwCmdCbID )
    {
        // PAPERSIZE
        case CBID_PSZ_OCD_SELECT_A3:
            LoadPaperInfo( pOEM, "a3" );
            break;

        case CBID_PSZ_OCD_SELECT_A4:
            LoadPaperInfo( pOEM, "a4" );
            break;

        case CBID_PSZ_OCD_SELECT_A5:
            LoadPaperInfo( pOEM, "a5" );
            break;

        case CBID_PSZ_OCD_SELECT_A6:
            LoadPaperInfo( pOEM, "a6" );
            break;

        case CBID_PSZ_OCD_SELECT_B4:
            LoadPaperInfo( pOEM, "b4" );
            break;

        case CBID_PSZ_OCD_SELECT_B5:
            LoadPaperInfo( pOEM, "b5" );
            break;

        case CBID_PSZ_OCD_SELECT_B6:
            LoadPaperInfo( pOEM, "b6" );
            break;

        case CBID_PSZ_OCD_SELECT_PC:
            LoadPaperInfo( pOEM, "pc" );
            break;

        case CBID_PSZ_OCD_SELECT_DL:
            LoadPaperInfo( pOEM, "o0" );
            break;

        case CBID_PSZ_OCD_SELECT_LT:
            LoadPaperInfo( pOEM, "o1" );
            break;

        case CBID_PSZ_OCD_SELECT_GG:
            LoadPaperInfo( pOEM, "o2" );
            break;

        case CBID_PSZ_OCD_SELECT_LG:
            LoadPaperInfo( pOEM, "o3" );
            break;

        case CBID_PSZ_OCD_SELECT_ST:
            LoadPaperInfo( pOEM, "hl" );
            break;

        case CBID_PSZ_OCD_SELECT_S1:
            LoadPaperInfo( pOEM, "s1" );
            break;

        case CBID_PSZ_OCD_SELECT_S2:
            LoadPaperInfo( pOEM, "s2" );
            break;

        case CBID_PSZ_OCD_SELECT_S3:
            LoadPaperInfo( pOEM, "s3" );
            break;

        case CBID_PSZ_OCD_SELECT_S4:
            LoadPaperInfo( pOEM, "s4" );
            break;

        case CBID_PC_OCD_PORTRAIT:
            pOEM->chOrient = "p";
            break;

        case CBID_PC_OCD_LANDSCAPE:
            pOEM->chOrient = "l";
            break;

        // PAGECONTROL
        case CBID_PC_OCD_BEGINDOC_ART:
            if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                "stj c\n" ))) {
                iRet = -1;
                break;
            }
            break;

        case CBID_PC_OCD_BEGINDOC_ART3:
            if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                "srl %d %d\nstj c\n", pOEM->sizlRes.cx, pOEM->sizlRes.cy ))) {
                iRet = -1;
                break;
            }
            break;

        case CBID_PC_OCD_BEGINDOC_ART4:
            if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                "\x1b%%-12345X" ))) {
                iRet = -1;
                break;
            }
            break;

        case CBID_PC_OCD_BEGINDOC_ART4_JCL:
            if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                "\x1b%%-12345X\x0d\x0a@JOMO=PRINTER\x0d\x0a"))) {
                iRet = -1;
                break;
            }
            break;

        case CBID_PC_OCD_BEGINPAGE:
// NTRAID#NTBUG9-493148-2002/03/12-yasuho-: 
// Stress break: PDEV resetting via OEMDevMode().

            // bold-simulation width: res / 50
            if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                "stp %s %s\nud i\nscl %d %d\nsb %d\n",
                 pOEM->chOrient,
                 pOEM->chSize,
                 (DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT),
                 (DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT),
                 (pOEM->sizlRes.cy * 2 / 100)))) {
                iRet = -1;
                break;
            }

            pOEM->ptlCur.x = 0;
            pOEM->ptlCur.y = 0;
            break;

        case CBID_PC_OCD_ENDPAGE:
            if(pOEM->fSort == FALSE){
                if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                    "ep %d\n", pOEM->iCopies ))) {
                    iRet = -1;
                    break;
                }
            }else if(pOEM->fSort == TRUE){
                if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                    "ep 1\n"))) {
                    iRet = -1;
                    break;
                }
            }

            if (!FlushText( pdevobj )) {
                iRet = -1;
                break;
            }
            pOEM->cFontId = 0;
            pOEM->iCurFontId = 0;
// NTRAID#NTBUG9-365649-2002/03/12-yasuho-: Invalid font size
            pOEM->iCurFontHeight = 0;
            pOEM->iCurFontWidth = 0;

            FreeCompressBuffers( pdevobj );   // If the buffer is need after, it will be alloced again.

            break;

        case CBID_PC_OCD_ENDDOC:
            WRITESPOOLBUF( pdevobj, "ej\n", 3 );    // Output endjob command
            FreeCompressBuffers( pdevobj );

            break;

        case CBID_PC_OCD_MULT_COPIES:
            if (dwCount < 1 || !pdwParams)
                return -1;
// @Aug/31/98 ->
            if(MAX_COPIES_VALUE < PARAM(pdwParams, 0)) {
                pOEM->iCopies = MAX_COPIES_VALUE;
            }
            else if(1 > PARAM(pdwParams, 0)) {
                pOEM->iCopies = 1;
            }
            else {
                pOEM->iCopies = (WORD)PARAM(pdwParams, 0);
            }
// @Aug/31/98 <-
            break;

        case CBID_PC_OCD_MULT_COPIES_450:
            if (dwCount < 1 || !pdwParams)
                return -1;
            if(MAX_COPIES_VALUE_450 < PARAM(pdwParams, 0)) {
                pOEM->iCopies = MAX_COPIES_VALUE;
            }
            else if(1 > PARAM(pdwParams, 0)) {
                pOEM->iCopies = 1;
            }
            else {
                pOEM->iCopies = (WORD)PARAM(pdwParams, 0);
            }
            break;


        // Cursor Move

        case CBID_CM_OCD_XM_ABS:
        case CBID_CM_OCD_YM_ABS:

            FX_VERBOSE(("CB: XM/YM_ABS %d\n",
                PARAM(pdwParams, 0)));

            if (dwCount < 1 || !pdwParams)
                return -1;
            iRet = (WORD)PARAM(pdwParams, 0);
            if (CBID_CM_OCD_YM_ABS == dwCmdCbID) {
                if (!YMoveAbs(pdevobj, iRet)) {
                    iRet = -1;
                    break;
                }
            }
            else {
                if (!XMoveAbs(pdevobj, iRet)) {
                    iRet = -1;
                    break;
                }
            }
            break;

        // RESOLUTION

        case CBID_RES_OCD_SELECTRES_240DPI:
            pOEM->sizlRes.cx = 240;
            pOEM->sizlRes.cy = 240;
            pOEM->sizlUnit.cx = DRIVER_MASTER_UNIT / 240;
            pOEM->sizlUnit.cy = DRIVER_MASTER_UNIT / 240;
            if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                "@PL > ART\x0D\x0Asrl 240 240\x0D\x0A\nccode j\nstj c\n"))) {
                iRet = -1;
                break;
            }
            break;

        case CBID_RES_OCD_SELECTRES_300DPI:
            pOEM->sizlRes.cx = 300;
            pOEM->sizlRes.cy = 300;
            pOEM->sizlUnit.cx = DRIVER_MASTER_UNIT / 300;
            pOEM->sizlUnit.cy = DRIVER_MASTER_UNIT / 300;
            if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                "@PL > ART\x0D\x0Asrl 300 300\x0D\x0A\nccode j\nstj c\n"))) {
                iRet = -1;
                break;
            }
            break;

        case CBID_RES_OCD_SELECTRES_400DPI:
            pOEM->sizlRes.cx = 400;
            pOEM->sizlRes.cy = 400;
            pOEM->sizlUnit.cx = DRIVER_MASTER_UNIT / 400;
            pOEM->sizlUnit.cy = DRIVER_MASTER_UNIT / 400;
            if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                "@PL > ART\x0D\x0Asrl 400 400\x0D\x0A\nccode j\nstj c\n"))) {
                iRet = -1;
                break;
            }
            break;

        case CBID_RES_OCD_SELECTRES_600DPI:
            pOEM->sizlRes.cx = 600;
            pOEM->sizlRes.cy = 600;
            pOEM->sizlUnit.cx = DRIVER_MASTER_UNIT / 600;
            pOEM->sizlUnit.cy = DRIVER_MASTER_UNIT / 600;
            if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                "@PL > ART\x0D\x0Asrl 600 600\x0D\x0A\nccode j\nstj c\n"))) {
                iRet = -1;
                break;
            }
            break;

        case CBID_RES_OCD_SELECTRES_450:
            pOEM->sizlRes.cx = 600;
            pOEM->sizlRes.cy = 600;
            pOEM->sizlUnit.cx = DRIVER_MASTER_UNIT / 600;
            pOEM->sizlUnit.cy = DRIVER_MASTER_UNIT / 600;

            if(pOEM->fSort == FALSE){
                if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                    "@JOOF=OFF\x0D\x0A@PL > ART\x0D\x0Asrl 600 600\x0D\x0A\nccode j\nstj c\n"))) {
                    iRet = -1;
                    break;
                }
            }else{
                if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                    "@JOOF=OFF\x0D\x0A@PL > ART\x0D\x0Asrl 600 600\x0D\x0A\nccode j\nstj c\nstp jog 0\n"))) {
                    iRet = -1;
                    break;
                }
            }
            break;


        case CBID_RES_OCD_SELECTRES_240DPI_ART3_ART:
            pOEM->sizlRes.cx = 240;
            pOEM->sizlRes.cy = 240;
            pOEM->sizlUnit.cx = DRIVER_MASTER_UNIT / 240;
            pOEM->sizlUnit.cy = DRIVER_MASTER_UNIT / 240;
// NTRAID#NTBUG9-208433-2002/03/12-yasuho-: 
// Output images are broken on ART2/3 models.
            pOEM->bART3 = TRUE;
            break;

        case CBID_RES_OCD_SELECTRES_300DPI_ART3_ART:
            pOEM->sizlRes.cx = 300;
            pOEM->sizlRes.cy = 300;
            pOEM->sizlUnit.cx = DRIVER_MASTER_UNIT / 300;
            pOEM->sizlUnit.cy = DRIVER_MASTER_UNIT / 300;
// NTRAID#NTBUG9-208433-2002/03/12-yasuho-: 
// Output images are broken on ART2/3 models.
            pOEM->bART3 = TRUE;
            break;


        case CBID_RES_OCD_SENDBLOCK_ASCII:
            bAscii = TRUE;
            pOEM->fCallback = TRUE;
            /* FALLTHROUGH */

        case CBID_RES_OCD_SENDBLOCK:
            if (dwCount < 3 || !pdwParams)
                return -1;

            //
            // image x y psx psy pcy pcy [string]
            //

            {
                LONG iPsx, iPsy, iPcx, iPcy;

// NTRAID#NTBUG9-493148-2002/03/12-yasuho-: 
// Stress break: PDEV resetting via OEMDevMode().
                iPsx = pOEM->sizlUnit.cx;
                iPsy = pOEM->sizlUnit.cy;

                iPcx = PARAM(pdwParams, 2) * 8;
                iPcy = PARAM(pdwParams, 1);

                FX_VERBOSE(("CB: SB %d(%d) %d(%d) %d %d %d %d\n",
                    ( pOEM->ptlOrg.x + pOEM->ptlCur.x ),
                    pOEM->ptlCur.x,
                    ( pOEM->ptlOrg.y - pOEM->ptlCur.y ),
                    pOEM->ptlCur.y,
                    iPsx,
                    iPsy,
                    iPcx,
                    (- iPcy)));

// NTRAID#NTBUG9-208433-2002/03/12-yasuho-: 
// Output images are broken on ART2/3 models.
                if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                    "%s%d %d %d %d %d %d %s",
                    ((bAscii || pOEM->bART3) ? "im " : "scm 5\nim "),
                    ( pOEM->ptlOrg.x + pOEM->ptlCur.x ),
                    ( pOEM->ptlOrg.y - pOEM->ptlCur.y ),
                    iPsx,
                    iPsy,
                    iPcx,
                    (- iPcy),
                    (bAscii ? "<" : "[")
                ))) {
                    iRet = -1;
                    break;
                }
            }

            break;

        case CBID_FS_OCD_BOLD_ON:
        case CBID_FS_OCD_BOLD_OFF:
        case CBID_FS_OCD_ITALIC_ON:
        case CBID_FS_OCD_ITALIC_OFF:
        case CBID_FS_OCD_SINGLE_BYTE:
        case CBID_FS_OCD_DOUBLE_BYTE:
        case CBID_FS_OCD_WHITE_TEXT_ON:
        case CBID_FS_OCD_WHITE_TEXT_OFF:
            pStr = NULL;

            switch ( dwCmdCbID ) {

            case CBID_FS_OCD_WHITE_TEXT_ON:
                if(!(pOEM->fFontSim & FONT_SIM_WHITE))
                {
                    pStr = "pm i c\n";
                    pOEM->fFontSim |= FONT_SIM_WHITE;
                }
                break;

            case CBID_FS_OCD_WHITE_TEXT_OFF:
                if(pOEM->fFontSim & FONT_SIM_WHITE)
                {
                    pStr = "pm n o\n";
                    pOEM->fFontSim &= ~FONT_SIM_WHITE;
                }
                break;

            case CBID_FS_OCD_BOLD_ON:
                if(!(pOEM->fFontSim & FONT_SIM_BOLD))
                {
                    pStr = "bb\n";
                    pOEM->fFontSim |= FONT_SIM_BOLD;
                }
                break;

            case CBID_FS_OCD_BOLD_OFF:
                if(pOEM->fFontSim & FONT_SIM_BOLD)
                {
                    pStr = "eb\net\n"; // DCR: Do we need "et\n"(Transform off)?
                    pOEM->fFontSim &= ~FONT_SIM_BOLD;
                }
                break;

            case CBID_FS_OCD_ITALIC_ON:
                if(!(pOEM->fFontSim & FONT_SIM_ITALIC))
                {
                    pStr = "trf x -18\nbt\n";
                    pOEM->fFontSim |= FONT_SIM_ITALIC;
                }
                break;

            case CBID_FS_OCD_ITALIC_OFF:
                if(pOEM->fFontSim & FONT_SIM_ITALIC)
                {
                    pStr = "eb\net\n"; // DCR: Do we need "et\n"(Transform off)?
                    pOEM->fFontSim &= ~FONT_SIM_ITALIC;
                }
                break;
            }

            if ( pStr )
            {
                if (!FlushText( pdevobj )) {
                    iRet = -1;
                    break;
                }
                if (FAILED(StringCchLengthA(pStr, sizeof buf, &iLen))) {
                    iRet = -1;
                    break;
                }
                WRITESPOOLBUF( pdevobj, pStr, iLen );
            }
            break;

            case CBID_CM_CR:
                if (!XMoveAbs(pdevobj, 0)) {
                    iRet = -1;
                    break;
                }
                iRet = 0;
                break;

            case CBID_CM_FF:
            case CBID_CM_LF:
                break;

            case CBID_SRT_OCD_SORTER_OFF:
                pOEM->fSort = FALSE ;
                if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                    "@CLLT=OFF\x0D\x0A"))) {
                    iRet = -1;
                    break;
                }
                break;

           case CBID_SRT_OCD_SORTER_ON:
                pOEM->fSort = TRUE ;
                if (FAILED(StringCchPrintfExA(buf, sizeof buf, &pbuf, NULL, 0,
                    "@CLLT=ON\x0D\x0A@JOCO=%d\x0D\x0A", pOEM->iCopies))) {
                    iRet = -1;
                    break;
                }
                break;


        default:

            break;
    }

    if ( (DWORD)(pbuf - buf) > 0 ) {
        WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
    }

    return iRet;
}


//---------------------------*bOEMSendFontCmd*----------------------------------
// Action:  send Pages-style font selection command.
//-----------------------------------------------------------------------------
BOOL APIENTRY bOEMSendFontCmd(pdevobj, pUFObj, pFInv)
PDEVOBJ      pdevobj;
PUNIFONTOBJ  pUFObj;     // offset to the command heap
PFINVOCATION pFInv;
{
    PFXPDEV         pOEM;
    GETINFO_STDVAR *pSV;
    DWORD           adwSV[2 + 2 * 2];
    INT             iFontId, iMaxId;
    INT             i, j;
    BYTE            buf[512], *pbuf;
    PIFIMETRICS pIFI = pUFObj->pIFIMetrics;
    size_t          rem;

#define SV_HEIGHT (pSV->StdVar[0].lStdVariable)
#define SV_WIDTH (pSV->StdVar[1].lStdVariable)
#define COEF_FIXPITCH_MUL   8
#define COEF_FIXPITCH_DEV   10
#define COEF_ROUNDUP5_VAL   5

    VERBOSE(("OEMSendFontCmd entry.\n"));

    ASSERT(VALID_PDEVOBJ(pdevobj));

    if(!pUFObj || !pFInv)
    {
        ERR(("OEMSendFontCmd: parameter is invalid."));
        return FALSE;
    }

// NTRAID#NTBUG9-498278-2002/03/12-yasuho-: Device font !print
    if(pUFObj->ulFontID < 1 || pUFObj->ulFontID > MAX_FONTS)
    {
        ERR(("OEMSendFontCmd: ulFontID is invalid.\n"));
        return FALSE;
    }

    pbuf = buf;
    rem = sizeof buf;
    pOEM = (PFXPDEV)pdevobj->pdevOEM;

    j = pUFObj->ulFontID - 1;
    iFontId = gFonts[ j ].id;

    if(pOEM->cTextBuf)
        if (!FlushText(pdevobj)) {
            ERR(("OEMSendFontCmd: FlushText failed.\n"));
            return FALSE;
        }

    iMaxId = min(pOEM->cFontId, MAX_FONTS);
    for ( i = 0; i < iMaxId; i++ )
    {
        if( iFontId == pOEM->aFontId[ i ] )
            break;
    }
    if (i >= MAX_FONTS)	// No room!
        return FALSE;
    if ( i >= pOEM->cFontId ) {

        // not declared yet within this page, so let us declare
        // it here.

        if (pOEM->cFontId >= MAX_FONTS)
            return FALSE;
        pOEM->aFontId[ pOEM->cFontId++ ] = (BYTE)iFontId;
        if ( gFonts[ j ].fid2 ) {
            if (FAILED(StringCchPrintfExA(pbuf, rem, &pbuf, &rem, 0,
                "std\n%s%sed\n",
                gFonts[ j ].fid1,
                gFonts[ j ].fid2 ))) {
                ERR(("OEMSendFontCmd: StringCchPrintfExA failed.\n"));
                return FALSE;
            }
        }
        else {
            if (FAILED(StringCchPrintfExA(pbuf, rem, &pbuf, &rem, 0,
                "std\n%sed\n",
                gFonts[ j ].fid1 ))) {
                ERR(("OEMSendFontCmd: StringCchPrintfExA failed.\n"));
                return FALSE;
            }
        }
    }

    pSV = (GETINFO_STDVAR *)&adwSV[0];
    pSV->dwSize               = sizeof(adwSV);
    pSV->dwNumOfVariable      = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return FALSE;
    }

    FX_VERBOSE(("SendFontCmd: SV_FH,SV_FW=%d,%d\n",
        pSV->StdVar[0].lStdVariable,
        pSV->StdVar[1].lStdVariable));

    pOEM->iFontId = (WORD)iFontId;
    pOEM->iFontHeight = (WORD)SV_HEIGHT;

    // Support non-square scaling only when the
    // font is non-proportional. (The w parameter
    // of "fontsize" ART command only valid with
    // non-proportional fonts)

    if (!ISPROPFONT(iFontId)) {
        if (ISDBCSFONT(iFontId)) {
            pOEM->iFontWidth = (WORD)SV_WIDTH;
            pOEM->iFontWidth2 = (WORD)(SV_WIDTH * 2);
            pOEM->wSBCSFontWidth = (WORD)SV_WIDTH;
        }
        else {
            pOEM->iFontWidth = (WORD)SV_WIDTH;
            // If fixed pitch font, real width of device font is 80% of SV_WIDTH
            pOEM->wSBCSFontWidth = (WORD)((SV_WIDTH * COEF_FIXPITCH_MUL + COEF_ROUNDUP5_VAL ) / COEF_FIXPITCH_DEV);
        }
    }
    else {
        // Default.
        pOEM->iFontWidth = 0;
    }

    if ( pbuf > buf )
        WRITESPOOLBUF( pdevobj, buf, (INT)(pbuf - buf));

    // Need set iFontId to iTextFontId
    pOEM->iTextFontId = pOEM->iFontId;
    pOEM->iTextFontHeight = pOEM->iFontHeight;
    pOEM->iTextFontWidth = pOEM->iFontWidth;
    pOEM->iTextFontWidth2 = pOEM->iFontWidth2;

    return TRUE;
}


BOOL APIENTRY
bOEMOutputCharStr(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD dwType,
    DWORD dwCount,
    PVOID pGlyph )
{
    GETINFO_GLYPHSTRING GStr;
    PBYTE               aubBuff = NULL;
    PBYTE               aubBEnd;
    PTRANSDATA          pTrans;
    DWORD               dwI;
    PFXPDEV             pOEM;
    BOOL                ret = FALSE;

    BYTE *pTemp;
    WORD wLen;
    INT iMark = 0;

    // For internal calculation of X-pos.
    DWORD dwGetInfo;
    GETINFO_GLYPHWIDTH  GWidth;

    VERBOSE(("OEMOutputCharStr() entry.\n"));
    ASSERT(VALID_PDEVOBJ(pdevobj));

    if(!pdevobj || !pUFObj || !pGlyph)
    {
        ERR(("OEMOutputCharStr: Invalid parameter.\n"));
        goto out;
    }

// NTRAID#NTBUG9-498278-2002/03/12-yasuho-: Device font !print
    if(dwType == TYPE_GLYPHHANDLE &&
        (pUFObj->ulFontID < 1 || pUFObj->ulFontID > MAX_FONTS) )
    {
        ERR(("OEMOutputCharStr: ulFontID is invalid.\n"));
        goto out;
    }

    pOEM = (PFXPDEV)(pdevobj->pdevOEM);

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:

        if (dwCount > STRBUFSIZE)
            goto out;

        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;

        /* Get TRANSDATA buffer size */
        if (FALSE != pUFObj->pfnGetInfo(pUFObj,
                UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)
            || 0 == GStr.dwGlyphOutSize)
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            goto out;
        }

        /* Alloc TRANSDATA buffer size */
        if(!(aubBuff = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize)) )
        {
            ERR(("MemAlloc failed.\n"));
            goto out;
        }
        aubBEnd = &aubBuff[GStr.dwGlyphOutSize];

        /* Get actual TRANSDATA */
        GStr.pGlyphOut = (PTRANSDATA)aubBuff;

        if (!pUFObj->pfnGetInfo(pUFObj,
                UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
        {
            ERR(("GetInfo failed.\n"));
            goto out;
        }

        // For internal calculation of X-pos.
        GWidth.dwSize = sizeof(GETINFO_GLYPHWIDTH);
        GWidth.dwCount = dwCount;
        GWidth.dwType = TYPE_GLYPHHANDLE;
        GWidth.pGlyph = pGlyph;
        GWidth.plWidth = pOEM->widBuf;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHWIDTH, &GWidth,
            dwGetInfo, &dwGetInfo)) {
            ERR(("UFO_GETINFO_GLYPHWIDTH failed.\n"));
            goto out;
        }

        pTrans = GStr.pGlyphOut;

        for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
        {
            if ( pOEM->cTextBuf >= sizeof ( pOEM->ajTextBuf ))
                if (!FlushText( pdevobj )) {
                    ERR(("OEMOutputCharStr: FlushText failed.\n"));
                    goto out;
                }

            if (pOEM->cTextBuf+2 > sizeof (pOEM->ajTextBuf))
                goto out;
            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_DIRECT:
                pOEM->ajTextBuf[ pOEM->cTextBuf++ ] = 0;
                pOEM->ajTextBuf[ pOEM->cTextBuf++ ] =
                                                (BYTE)pTrans->uCode.ubCode;
                break;

            case MTYPE_PAIRED:
                pOEM->ajTextBuf[ pOEM->cTextBuf++ ] =
                                            (BYTE)pTrans->uCode.ubPairs[0];
                pOEM->ajTextBuf[ pOEM->cTextBuf++ ] =
                                            (BYTE)pTrans->uCode.ubPairs[1];
                break;
            case MTYPE_COMPOSE:
                pTemp = (BYTE *)(GStr.pGlyphOut) + pTrans->uCode.sCode;
                if (&pTemp[3] > aubBEnd) // length(WORD) + MARK
                    goto out;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;

                switch (*pTemp)
                {
                case MARK_ALT_GSET:
                    iMark = MARK_ALT_GSET;
                    pTemp++;
                    wLen--;
                    break;
                }
                if (&pTemp[wLen] > aubBEnd ||
                    (pOEM->cTextBuf + wLen * 2) > sizeof(pOEM->ajTextBuf))
                    goto out;

                while (wLen--)
                {
                    pOEM->ajTextBuf[ pOEM->cTextBuf++ ] = (BYTE)iMark;
                    pOEM->ajTextBuf[ pOEM->cTextBuf++ ] = *pTemp++;
                }
            }
            // For internal calculation of X-pos.
            pOEM->lInternalXAdd += (LONG)((LONG)pOEM->widBuf[dwI] * ((LONG)pOEM->wSBCSFontWidth));
        }
        ret = TRUE;

        break;
    }

// NTRAID#NTBUG9-574495-2002/04/09-yasuho-: Possible memory leak.
out:
    if (aubBuff) MemFree(aubBuff);

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fxartres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\fx\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=fxartres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),fxartres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\fxartres.rc \
    $(SRCDIR)\common.c \
    $(SRCDIR)\fxartres.c

MISCFILES=\
    $(SRCDIR)\fxartres.ini \
    $(GPDDIR)\fx4105j.gpd \
    $(GPDDIR)\fx41082j.gpd \
    $(GPDDIR)\fx4108j.gpd \
    $(GPDDIR)\fx4108vj.gpd \
    $(GPDDIR)\fx41502j.gpd \
    $(GPDDIR)\fx4150j.gpd \
    $(GPDDIR)\fx41602j.gpd \
    $(GPDDIR)\fx4160j.gpd \
    $(GPDDIR)\fx4200j.gpd \
    $(GPDDIR)\fx4300j.gpd \
    $(GPDDIR)\fxablp2j.gpd \
    $(GPDDIR)\fxablprj.gpd \
    $(GPDDIR)\fx4210j.gpd \
    $(GPDDIR)\fx4410j.gpd \
    $(GPDDIR)\fxdc250j.gpd \
    $(GPDDIR)\fxdc450j.gpd \
    $(GPDDIR)\fxdc600j.gpd \
    $(GPDDIR)\fxdc605j.gpd \
    $(GPDDIR)\fxdp250j.gpd \
    $(GPDDIR)\fxdp280j.gpd \
    $(GPDDIR)\fxdp400j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fxartres\name.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fxartres\etc\fxart4.c ===
#define PRINTDRIVER
#include <print.h>
#include "mdevice.h"
#include "gdidefs.inc"
#include "unidrv.h"
#include <memory.h>

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#ifdef WINNT
#define CODESEG /* not used */
#else // WINNT
#define _CODESEG      "_CODESEG"
#define CODESEG    __based(__segname(_CODESEG))
#endif // WINNT

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

char *rgchModuleName = "FXART4";

#define DEVICE_MASTER_UNIT 7200
#define DRIVER_MASTER_UNIT 1200

typedef struct
{
    BYTE  fGeneral;       // General purpose bitfield
    BYTE  bCmdCbId;       // Callback ID; 0 iff no callback
    WORD  wCount;         // # of EXTCD structures following
    WORD  wLength;        // length of the command
} CD, *PCD, FAR * LPCD;

typedef struct tagMYMDV {
    POINTL ptlOrg;
    POINTL ptlCur;
    SIZEL sizlRes;
    WORD iCopies;
    CHAR *chOrient;
    CHAR *chSize;
    BOOL bString;
    WORD cFontId;
    WORD iFontId;
    WORD iFontHeight;
    LONG aFontId[20];
    POINTL ptlTextCur;
    WORD iTextFontId;
    WORD iTextFontHeight;
    WORD cTextBuf;
    BYTE ajTextBuf[1024];
    WORD fFontSim;
} MYMDV, *LPMYMDV;

#define FONT_SIM_ITALIC 1
#define FONT_SIM_BOLD 2

// to get physical paper sizes.

typedef struct tagMYFORMS {
    CHAR *id;
    LONG x;
    LONG y;
} MYFORMS, *LPMYFORMS;

// font name to font id mappnig

typedef struct tagMYFONTS {
    LONG id;
    CHAR *fid1;
    CHAR *fid2;
    CHAR *pface;
} MYFONTS, *LPMYFONTS;

//
// Load necessary information for specified paper size.
// Make sure PC_OCD_LANDSCAPE and PC_OCD_PORTRAIT are
// called.
//

MYFORMS gForms[] = {
    "a3", 13608, 19422,
    "a4", 9498, 13608,
    "a5", 6570, 9498,
    "b4", 11718, 16776,
    "b5", 8178, 11718,
    "pc", 4302, 6570, // Postcard
    "dl", 12780, 19980, // Tabloid
    "lt", 9780, 12780, // Letter
    "gg", 9780, 15180, // German Legal Fanfold
    "lg", 9780, 16380, // Legal
    "s1", 4530, 10962, // (Env) Comm 10
    "s2", 4224, 8580, // (Env) Monarch
    "s3", 4776, 9972, // (Env) DL
    "s4", 7230, 10398, // (Env) C5
    NULL, 0, 0
};

MYFONTS gFonts[] = {
    150, "fid 150 1 0 0 960 480\n", "fid 151 2 4 0 960 960\n",
        "\x96\xbe\x92\xa9", // Mincho
    152, "fid 152 1 0 1 960 480\n", "fid 153 2 4 1 960 960\n",
        "\xba\xde\xbc\xaf\xb8", // Gothic
    154, "fid 154 1 0 2 960 480\n", "fid 155 2 4 2 960 960\n",
        "\x8a\xdb\xba\xde\xbc\xaf\xb8", // Maru-Gothic
    156, "fid 156 1 0 0 960 480\n", "fid 157 2 5 0 960 960\n",
        "\x40\x96\xbe\x92\xa9", // @Mincho
    158, "fid 158 1 0 1 960 480\n", "fid 159 2 5 1 960 960\n",
        "\x40\xba\xde\xbc\xaf\xb8", // @Gothic
    160, "fid 160 1 0 2 960 480\n", "fid 161 2 5 2 960 960\n",
        "\x40\x8a\xdb\xba\xde\xbc\xaf\xb8", // @Maru-Gothic
    180, "fid 180 1 130 100 0 0\n", NULL, "CS TIMES",
    181, "fid 181 1 130 101 0 0\n", NULL, "CS TIMES Italic",
    182, "fid 182 1 130 102 0 0\n", NULL, "CS TIMES Bold",
    183, "fid 183 1 130 103 0 0\n", NULL, "CS TIMES Italic Bold",
    184, "fid 184 1 130 104 0 0\n", NULL, "CS Triumvirate",
    185, "fid 185 1 130 105 0 0\n", NULL, "CS Triumvirate Italic",
    186, "fid 186 1 130 106 0 0\n", NULL, "CS Triumvirate Bold",
    187, "fid 187 1 130 107 0 0\n", NULL, "CS Triumvirate Italic Bold",
    188, "fid 188 1 130 108 0 0\n", NULL, "CS Courier",
    189, "fid 189 1 130 109 0 0\n", NULL, "CS Courier Italic",
    190, "fid 190 1 130 110 0 0\n", NULL, "CS Courier Bold",
    191, "fid 191 1 130 111 0 0\n", NULL, "CS Courier Italic Bold",
    192, "fid 192 1 130 112 0 0\n", NULL, "CS Symbol",
    0, NULL, NULL, NULL
};

#define ISDBCSFONT(i) ((i) < 180)
#define ISVERTFONT(i) ((i) >= 156 && (i) < 180)

#ifdef WINNT
#include <stdio.h>
#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

LPWRITESPOOLBUF WriteSpoolBuf;
LPALLOCMEM UniDrvAllocMem;
LPFREEMEM UniDrvFreeMem;

BOOL
MyIsDBCSLeadByte(
BYTE bByte);
#define IsDBCSLeadByte  MyIsDBCSLeadByte

#endif //WINNT







BOOL
LoadPaperInfo(
    LPMYMDV lpMdv,
    CHAR *id ) {

    LPMYFORMS ptmp;


    for ( ptmp = gForms; ptmp->id; ptmp++ ) {
        if ( strcmp( id, ptmp->id) == 0 )
            break;
    }

    if ( ptmp->id == NULL )
        return FALSE;

    lpMdv->chSize = ptmp->id;

    lpMdv->ptlOrg.x = 0;
    if ( strcmp( lpMdv->chOrient, "l") == 0 ){
        lpMdv->ptlOrg.y = ptmp->x;
    }
    else {
        lpMdv->ptlOrg.y = ptmp->y;
    }

    lpMdv->ptlOrg.x += 210;
//v-jiroya (3/19/1997)
//    lpMdv->ptlOrg.y -= 210;
    lpMdv->ptlOrg.y += 210;

    return TRUE;
}

VOID
SjisToJis(
    BYTE *pDst, BYTE *pSrc
    )
{
    INT c1, c2;


    c1 = *pSrc;
    c2 = *(pSrc + 1);

    // Replace code values which cannot be mapped into 0x2121 - 0x7e7e
    // (94 x 94 cahracter plane) with Japanese defult character, which
    // is KATAKANA MIDDLE DOT.

    if (c1 >= 0xf0) {
        c1 = 0x81;
        c2 = 0x45;
    }

    c1 -= ( c1 > 0x9f ) ? 0xb1 : 0x71;
    c1 = c1 * 2 + 1;
    if ( c2 > 0x9e ) {
        c2 = c2 - 0x7e;
        c1++;
    }
    else {
        if ( c2 > 0x7e )
            c2--;
        c2 -= 0x1f;
    }

    *pDst = c1;
    *(pDst + 1) = c2;
}

#define TOHEX(j) ((j) < 10 ? ((j) + '0') : ((j) - 10 + 'a'))

LONG
HexOutput(
    LPDV lpDv,
    BYTE *lpBuf,
    WORD wLen )
{
    BYTE Buf[1024];
    BYTE *pSrc, *pSrcMax;
    LONG iRet, j;

    pSrc = (BYTE *)lpBuf;
    pSrcMax = pSrc + wLen;
    iRet = 0;

    while ( pSrc < pSrcMax ) {

        for ( j = 0; j < sizeof (Buf) && pSrc < pSrcMax; pSrc++ ) {

            BYTE c1, c2;

            c1 = (((*pSrc) >> 4) & 0x0f);
            c2 = (*pSrc & 0x0f);

            Buf[ j++ ] = TOHEX( c1 );
            Buf[ j++ ] = TOHEX( c2 );
        }

        if (WriteSpoolBuf( lpDv, Buf, j ) < 0)
            break;

        iRet += j;
    }
    return (WORD) iRet;
}

VOID
BeginString(
    LPDV lpdv,
    BOOL bReset )
{
    LONG ilen;
    BYTE buf[512];
    LPMYMDV lpMdv;
    BYTE *pbuf;


    lpMdv = lpdv->lpMdv;

    if (lpMdv->bString)
        return;

    pbuf = buf;
    if ( bReset ) {
        ilen = wsprintf( pbuf,
            "scp %d %d\n",
            ( lpMdv->ptlOrg.x + lpMdv->ptlTextCur.x ),
            ( lpMdv->ptlOrg.y - lpMdv->ptlTextCur.y ));
        pbuf += ilen;
    }

    ilen = wsprintf( pbuf,
        "sh <" );
    pbuf += ilen;

    if ( (pbuf - buf) > 0 ) {
        WriteSpoolBuf( lpdv, buf, (pbuf - buf) );
    }
    lpMdv->bString = TRUE;
}

VOID
EndString(
    LPDV lpdv )
{
    LONG ilen;
    BYTE buf[512];
    LPMYMDV lpMdv;

    lpMdv = lpdv->lpMdv;

    if (!lpMdv->bString)
        return;

    ilen = wsprintf( buf,
        ">\n" );

    if ( ilen > 0 ) {
        WriteSpoolBuf( lpdv, buf, ilen );
    }
    lpMdv->bString = FALSE;
}

VOID
BeginVertWrite(
    LPDV lpdv )
{
    BYTE buf[512];
    LPMYMDV lpMdv;
    INT ilen;
    BYTE *pbuf;


    lpMdv = lpdv->lpMdv;
    pbuf = buf;

    ilen = wsprintf( pbuf,
        "fo 90\nsrcp %d 0\n", lpMdv->iFontHeight );
    pbuf += ilen;
    if (lpMdv->fFontSim & FONT_SIM_ITALIC) {
        ilen = wsprintf( pbuf,
            "trf -18 y\n" );
        pbuf += ilen;
    }

    if ( pbuf > buf ) {
        WriteSpoolBuf( lpdv, buf, (pbuf - buf) );
    }
}

VOID
EndVertWrite(
    LPDV lpdv )
{
    BYTE buf[512];
    LPMYMDV lpMdv;
    INT ilen;
    BYTE *pbuf;

    lpMdv = lpdv->lpMdv;
    pbuf = buf;

    ilen = wsprintf( pbuf,
        "fo 0\nsrcp %d 0\n", -(lpMdv->iFontHeight) );
    pbuf += ilen;
    if (lpMdv->fFontSim & FONT_SIM_ITALIC) {
        ilen = wsprintf( pbuf,
            "trf x -18\n" );
        pbuf += ilen;
    }

    if ( pbuf > buf ) {
        WriteSpoolBuf( lpdv, buf, (pbuf - buf) );
    }
}

//
// Save the current poistion as the begining position of text output.
// We will cache string output so that we need to remember this.
//

VOID
SaveTextCur(
    LPDV lpdv )
{
    LPMYMDV lpMdv;
    lpMdv = lpdv->lpMdv;

    lpMdv->ptlTextCur.x = lpMdv->ptlCur.x;
    lpMdv->ptlTextCur.y = lpMdv->ptlCur.y;
    lpMdv->iTextFontId = lpMdv->iFontId;
    lpMdv->iTextFontHeight = lpMdv->iFontHeight;
}

//
// Flush out the cached text.  We switch between single byte font and
// double byte font if necesary.
//

VOID
FlushText(
    LPDV lpdv )
{
    LPMYMDV lpMdv;
    INT i;
    INT ilen;
    BYTE *pStr, *pStrSav, *pStrMax;
    BYTE buf[512];
    BOOL bReset;

    bReset = TRUE;
    lpMdv = lpdv->lpMdv;

    pStr = lpMdv->ajTextBuf;
    pStrMax = pStr + lpMdv->cTextBuf;
    pStrSav = pStr;

    for ( ; pStr < pStrMax; ) {

        if (ISDBCSFONT( lpMdv->iTextFontId )) {

            for ( pStrSav = pStr; pStr < pStrMax; pStr += 2 ) {
                if (!IsDBCSLeadByte(*pStr))
                    break;
                SjisToJis(pStr, pStr);
            }

            if ((pStr - pStrSav) > 0) {

                // switch font to output double byte characters
                // we have assigned fontid + 1 as the font ids for
                // double byte fonts, so just add 1 to get double
                // byte font id.

                ilen = wsprintf( buf,
                    "sfi %d\nfs %d 0\n",
                    (lpMdv->iTextFontId + 1),
                    lpMdv->iFontHeight );
                WriteSpoolBuf( lpdv, buf, ilen );

                if (ISVERTFONT(lpMdv->iTextFontId))
                    BeginVertWrite( lpdv );
                BeginString( lpdv, bReset );
                HexOutput(lpdv, pStrSav, (WORD)(pStr - pStrSav));
                EndString( lpdv );
                if (ISVERTFONT(lpMdv->iTextFontId))
                    EndVertWrite( lpdv );
                bReset = FALSE;
           }

            if ( pStr >= pStrMax )
                break;

            // switch font to output single byte characters

            for ( pStrSav = pStr; pStr < pStrMax; pStr++ ) {
                if (IsDBCSLeadByte(*pStr))
                    break;
            }

        }
        else {
            pStr = pStrMax;
        }

        if ((pStr - pStrSav) > 0) {

            // switch font to output single byte characters

            ilen = wsprintf( buf,
                "sfi %d\nfs %d 0\n",
                (lpMdv->iTextFontId),
                lpMdv->iFontHeight );
            WriteSpoolBuf( lpdv, buf, ilen );

            BeginString( lpdv, bReset );
            HexOutput(lpdv, pStrSav, (WORD)(pStr - pStrSav));
            EndString( lpdv );
            bReset = FALSE;
        }

        if ( pStr >= pStrMax )
            break;

        pStrSav = pStr;
    }

    lpMdv->cTextBuf = 0;
}

//-------------------------------------------------------------------
// CBFilerGraphics
// Action : Convert binary byte stream into ASCII hexadecimal
//      representation.  This is required for ART1, where no binary
//      transmission of image data is allowed.
//-------------------------------------------------------------------

WORD PASCAL CBFilterGraphics(
    LPDV lpdv, LPSTR lpBuf, WORD wLen )
{
    return (WORD)HexOutput(lpdv, lpBuf, wLen );
}

//-------------------------------------------------------------------
// OEMOutputCmd
// Action :
//-------------------------------------------------------------------

// #define CBID_CM_OCD_XM_ABS 1
// #define CBID_CM_OCD_XM_REL 2
// #define CBID_CM_OCD_YM_ABS 3
// #define CBID_CM_OCD_YM_REL 4
#define CBID_CM_OCD_XY_ABS 5
#define CBID_CM_OCD_XY_REL 6

#define CBID_RES_OCD_SELECTRES_240DPI 21
#define CBID_RES_OCD_SELECTRES_300DPI 22
#define CBID_RES_OCD_SELECTRES_400DPI 23
#define CBID_RES_OCD_SELECTRES_600DPI 24
#define CBID_RES_OCD_SENDBLOCK_ASCII 25
#define CBID_RES_OCD_SENDBLOCK 26

#define CBID_PC_OCD_BEGINDOC_ART 11
#define CBID_PC_OCD_BEGINDOC_ART3 12
#define CBID_PC_OCD_BEGINDOC_ART4 13
#define CBID_PC_OCD_BEGINPAGE 14
#define CBID_PC_OCD_ENDPAGE 15
#define CBID_PC_OCD_MULT_COPIES 16
#define CBID_PC_OCD_PORTRAIT 17
#define CBID_PC_OCD_LANDSCAPE 18

#define CBID_PSZ_OCD_SELECT_A3 30
#define CBID_PSZ_OCD_SELECT_A4 31
#define CBID_PSZ_OCD_SELECT_A5 32
#define CBID_PSZ_OCD_SELECT_B4 33
#define CBID_PSZ_OCD_SELECT_B5 34
#define CBID_PSZ_OCD_SELECT_PC 35
#define CBID_PSZ_OCD_SELECT_DL 36
#define CBID_PSZ_OCD_SELECT_LT 37
#define CBID_PSZ_OCD_SELECT_GG 38
#define CBID_PSZ_OCD_SELECT_LG 39
#define CBID_PSZ_OCD_SELECT_S1 40
#define CBID_PSZ_OCD_SELECT_S2 41
#define CBID_PSZ_OCD_SELECT_S3 42
#define CBID_PSZ_OCD_SELECT_S4 43

#define CBID_FS_OCD_BOLD_ON 51
#define CBID_FS_OCD_BOLD_OFF 52
#define CBID_FS_OCD_ITALIC_ON 53
#define CBID_FS_OCD_ITALIC_OFF 54
#define CBID_FS_OCD_SINGLE_BYTE 55
#define CBID_FS_OCD_DOUBLE_BYTE 56
#define CBID_FS_OCD_WHITE_TEXT_ON 57
#define CBID_FS_OCD_WHITE_TEXT_OFF 58

#define CBID_FONT_SELECT_OUTLINE 101

// @Aug/31/98 ->
#define	MAX_COPIES_VALUE		99
// @Aug/31/98 <-
VOID FAR CODESEG PASCAL
OEMOutputCmd(
    LPDV     lpdv,
    WORD     wCmdCbId,
    LPDWORD  lpdwParams )
{
    BYTE buf[512];
    INT ilen;
    LPMYMDV lpMdv;
    LONG x, y;
    BOOL bAscii;
    CHAR *pStr;

    lpMdv = lpdv->lpMdv;
    bAscii = FALSE;

    ilen = 0;

    switch( wCmdCbId ) {

    // PAPERSIZE

    case CBID_PSZ_OCD_SELECT_A3:
        LoadPaperInfo( lpMdv, "a3" );
        break;

    case CBID_PSZ_OCD_SELECT_A4:
        LoadPaperInfo( lpMdv, "a4" );
        break;

    case CBID_PSZ_OCD_SELECT_A5:
        LoadPaperInfo( lpMdv, "a5" );
        break;

    case CBID_PSZ_OCD_SELECT_B4:
        LoadPaperInfo( lpMdv, "b4" );
        break;

    case CBID_PSZ_OCD_SELECT_B5:
        LoadPaperInfo( lpMdv, "b5" );
        break;

    case CBID_PSZ_OCD_SELECT_PC:
        LoadPaperInfo( lpMdv, "pc" );
        break;

    case CBID_PSZ_OCD_SELECT_DL:
        LoadPaperInfo( lpMdv, "dl" );
        break;

    case CBID_PSZ_OCD_SELECT_LT:
        LoadPaperInfo( lpMdv, "lt" );
        break;

    case CBID_PSZ_OCD_SELECT_GG:
        LoadPaperInfo( lpMdv, "gg" );
        break;

    case CBID_PSZ_OCD_SELECT_LG:
        LoadPaperInfo( lpMdv, "lg" );
        break;

    case CBID_PSZ_OCD_SELECT_S1:
        LoadPaperInfo( lpMdv, "s1" );
        break;

    case CBID_PSZ_OCD_SELECT_S2:
        LoadPaperInfo( lpMdv, "s2" );
        break;

    case CBID_PSZ_OCD_SELECT_S3:
        LoadPaperInfo( lpMdv, "s3" );
        break;
    case CBID_PSZ_OCD_SELECT_S4:
        LoadPaperInfo( lpMdv, "s4" );
        break;

    case CBID_PC_OCD_PORTRAIT:
        lpMdv->chOrient = "p";
        break;

    case CBID_PC_OCD_LANDSCAPE:
        lpMdv->chOrient = "l";
        break;

    // PAGECONTROL

    case CBID_PC_OCD_BEGINDOC_ART:
        ilen = wsprintf( buf,
            "stj c\n" );
        break;

    case CBID_PC_OCD_BEGINDOC_ART3:
        ilen = wsprintf( buf,
            "srl %d %d\nstj c\n",
            lpMdv->sizlRes.cx,
            lpMdv->sizlRes.cy );
        break;

    case CBID_PC_OCD_BEGINDOC_ART4:
        ilen = wsprintf( buf,
            "\x1b%%-12345X@PL > ART \x0d\x0asrl %d %d\nccode j\nstj c\n",
            lpMdv->sizlRes.cx,
            lpMdv->sizlRes.cy );
        break;

    case CBID_PC_OCD_BEGINPAGE:

        // bold-simulation width: res / 50

        ilen = wsprintf( buf,
            "stp %s %s\nud i\nscl %d %d\nsb %d\n",
             lpMdv->chOrient,
             lpMdv->chSize,
             (DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT),
             (DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT),
             (lpMdv->sizlRes.cy * 2 / 100));

        lpMdv->ptlCur.x = 0;
        lpMdv->ptlCur.y = 0;
        break;

    case CBID_PC_OCD_ENDPAGE:

        FlushText( lpdv );
        ilen = wsprintf( buf,
            "ep %d\n",
            lpMdv->iCopies );

        lpMdv->cFontId = 0;

        break;

    case CBID_PC_OCD_MULT_COPIES:
// @Aug/31/98 ->
        if(MAX_COPIES_VALUE < *lpdwParams)
            lpMdv->iCopies = MAX_COPIES_VALUE;
        else if(1 > *lpdwParams)
            lpMdv->iCopies = 1;
        else
            lpMdv->iCopies = (WORD)*lpdwParams;
// @Aug/31/98 <-
        break;\

    case CBID_CM_OCD_XY_ABS:
/////
if (0) {
    char buf[128];
    wsprintf(buf, "\\%% xy_abs %d %d %%\\\n",
        *(LONG *)(lpdwParams),
        *(LONG *)(lpdwParams + 1)
    );
    WriteSpoolBuf( lpdv, buf, strlen(buf));
}
/////
        lpMdv->ptlCur.x = *(LONG *)(lpdwParams);
        lpMdv->ptlCur.y = *(LONG *)(lpdwParams + 1);
        FlushText( lpdv );
        SaveTextCur( lpdv );
        break;

    case CBID_CM_OCD_XY_REL:
/////
if (0) {
    char buf[128];
    wsprintf(buf, "\\%% xy_rel %d %d %%\\\n",
        *(LONG *)(lpdwParams),
        *(LONG *)(lpdwParams + 1)
    );
    WriteSpoolBuf( lpdv, buf, strlen(buf));
}
/////

        lpMdv->ptlCur.x += *(LONG *)(lpdwParams);
        lpMdv->ptlCur.y += *(LONG *)(lpdwParams + 1);
        FlushText( lpdv );
        SaveTextCur( lpdv );
        break;

    // RESOLUTION

    case CBID_RES_OCD_SELECTRES_240DPI:

        lpMdv->sizlRes.cx = 240;
        lpMdv->sizlRes.cy = 240;
        break;

    case CBID_RES_OCD_SELECTRES_300DPI:

        lpMdv->sizlRes.cx = 300;
        lpMdv->sizlRes.cy = 300;
        break;

    case CBID_RES_OCD_SELECTRES_400DPI:

        lpMdv->sizlRes.cx = 400;
        lpMdv->sizlRes.cy = 400;
        break;

    case CBID_RES_OCD_SELECTRES_600DPI:

        lpMdv->sizlRes.cx = 600;
        lpMdv->sizlRes.cy = 600;
        break;

    case CBID_RES_OCD_SENDBLOCK_ASCII:

        bAscii = TRUE;
        /* FALLTHROUGH */

    case CBID_RES_OCD_SENDBLOCK:

        //
        // image x y psx psy pcy pcy [string]
        //

        {
            LONG iPsx, iPsy, iPcx, iPcy;

            iPsx = DRIVER_MASTER_UNIT / lpMdv->sizlRes.cx;
            iPsy = DRIVER_MASTER_UNIT / lpMdv->sizlRes.cy;

            iPcx = lpdwParams[2] * 8;
            iPcy = lpdwParams[1];

            ilen = wsprintf( buf,
                "im %d %d %d %d %d %d %s",
                ( lpMdv->ptlOrg.x + lpMdv->ptlCur.x ),
                ( lpMdv->ptlOrg.y - lpMdv->ptlCur.y ),
                iPsx,
                iPsy,
                iPcx,
                (- iPcy),
                (bAscii ? "<" : "[")
            );
        }

        break;

    case CBID_FS_OCD_BOLD_ON:
    case CBID_FS_OCD_BOLD_OFF:
    case CBID_FS_OCD_ITALIC_ON:
    case CBID_FS_OCD_ITALIC_OFF:
    case CBID_FS_OCD_SINGLE_BYTE:
    case CBID_FS_OCD_DOUBLE_BYTE:
    case CBID_FS_OCD_WHITE_TEXT_ON:
    case CBID_FS_OCD_WHITE_TEXT_OFF:

        FlushText( lpdv );

        pStr = NULL;

        switch ( wCmdCbId ) {

        case CBID_FS_OCD_WHITE_TEXT_ON:
            pStr = "pm i c\n";
            break;

        case CBID_FS_OCD_WHITE_TEXT_OFF:
            pStr = "pm n o\n";
            break;

        case CBID_FS_OCD_BOLD_ON:
            pStr = "bb\n";
            lpMdv->fFontSim |= FONT_SIM_BOLD;
            break;

        case CBID_FS_OCD_BOLD_OFF:
//            pStr = "eb\n";
            pStr = "eb\net\n"; // DCR: Do we need "et\n"(Transform off)?
            lpMdv->fFontSim &= ~FONT_SIM_BOLD;
            lpMdv->fFontSim &= ~FONT_SIM_ITALIC; // DCR: Do we need "et\n"(Transform off)?
            break;

        case CBID_FS_OCD_ITALIC_ON:
            pStr = "trf x -18\nbt\n";
            lpMdv->fFontSim |= FONT_SIM_ITALIC;
            break;

        case CBID_FS_OCD_ITALIC_OFF:
//            pStr = "et\n";
            pStr = "eb\net\n"; // DCR: Do we need "et\n"(Transform off)?
            lpMdv->fFontSim &= ~FONT_SIM_ITALIC;
            lpMdv->fFontSim &= ~FONT_SIM_BOLD; // DCR: Do we need "et\n"(Transform off)?
            break;
        }

        if ( pStr ) {
            ilen = strlen( pStr );
            WriteSpoolBuf( lpdv, pStr, ilen );
        }
        ilen = 0;
        break;

    default:

        break;
    }

    if ( ilen > 0 ) {
        WriteSpoolBuf( lpdv, buf, ilen );
    }
}

BOOL FAR PASCAL
OEMGetFontCmd(
    LPDV lpdv,         // Pointer to PDEVICE structure
    WORD wCmdCbId,     // Command callback id#, defined by minidriver 
    LPFONTINFO lpfont, // Pointer to PFM data
    BOOL fSelect,      // TRUE for selection
    LPBYTE lpBuf,      // Buffer to put command into
    LPWORD lpwSize )   // Ptr to actual size of buffer
{
    INT iFontId;
    CHAR *pface;
    INT j;
    LPMYMDV lpMdv;
    BOOL bRet;

    lpMdv = lpdv->lpMdv;

    if ( !fSelect ) {
        return TRUE;
    }

    iFontId = 0;
    pface = (CHAR *)((BYTE *)lpfont + lpfont->dfFace);
    for ( j = 0; gFonts[ j ].pface; j++ ) {
        if ( !strcmp(pface, gFonts[ j ].pface ) ) {
            iFontId = gFonts[ j ].id;
            break;
        }
    }
    if ( !gFonts[ j ].pface )
        j = 0;

    if ( *lpwSize > 0 ) {
        *lpBuf = j;
        bRet = TRUE;
    }
    else {
        bRet = FALSE;
    }

    *lpwSize = 1;
    return bRet;
}

VOID FAR
OEMSendScalableFontCmd(
    LPDV lpdv,
    LPCD lpcd,
    LPFONTINFO lpFont )
{
    LPMYMDV lpMdv;
    BYTE *lpCmd;
    BYTE buf[512], *pbuf;
    INT ilen;
    LONG iFontHeight;
    LONG i, j;
    LONG iFontId;


    if (!lpcd || !lpFont)
       return;

    lpMdv = lpdv->lpMdv;
    lpCmd = (BYTE *)lpcd + sizeof (CD);
    pbuf = buf;

    j = *lpCmd;
    iFontId = gFonts[ j ].id;
    for ( i = 0; i < lpMdv->cFontId; i++ ) {
        if ( iFontId == lpMdv->aFontId[ i ] )
            break;
    }
    if ( i >= lpMdv->cFontId ) {

        // not declared yet within this page, so let us declare
        // it here.

        lpMdv->aFontId[ lpMdv->cFontId++ ] = (BYTE)iFontId;
        if ( gFonts[ j ].fid2 ) {
            ilen = wsprintf( pbuf,
                "std\n%s%sed\n",
                gFonts[ j ].fid1,
                gFonts[ j ].fid2 );
            pbuf += ilen;
        }
        else {
            ilen = wsprintf( pbuf,
                "std\n%sed\n",
                gFonts[ j ].fid1 );
            pbuf += ilen;
        }
    }

    lpMdv->iFontId = (WORD)iFontId;
    lpMdv->iFontHeight = (WORD)(lpFont->dfPixHeight
        * DRIVER_MASTER_UNIT / lpMdv->sizlRes.cy);

    if ( pbuf > buf ) {
        WriteSpoolBuf( lpdv, buf, (INT)(pbuf - buf) );
    }
    // Need set iFontId to iTextFontId
    SaveTextCur( lpdv );
    
}


/***************************************************************************
    Function Name : OEMOutputChar

    Parameters    : LPDV	lpdv		Private Device Structure
                    LPSTR	lpstr		Print String
                    WORD	len		Length
                    WORD	rcID		Font ID

    Note          : 

***************************************************************************/

VOID FAR
OEMOutputChar(
    LPDV lpdv,
    LPSTR lpStr,
    WORD wLen,
    WORD rcID )
{
    LPMYMDV lpMdv;
    INT i;
    BYTE *pStr;

    lpMdv = lpdv->lpMdv;
    pStr = (BYTE *)lpStr;

    for ( i = 0; i < wLen; i++ ) {
        if ( lpMdv->cTextBuf >= sizeof ( lpMdv->ajTextBuf ))
            FlushText( lpdv );
        lpMdv->ajTextBuf[ lpMdv->cTextBuf++ ] = *pStr++;
    }
}


#ifndef WINNT
//-------------------------------------------------------------------
// Function: Enable()
// Action  : call UniEnable and setup Mdv
//-------------------------------------------------------------------

SHORT CALLBACK Enable(
LPDV lpdv,
WORD style,
PSTR lpModel,
LPSTR lpPort,
LPDM lpStuff )
{
    LPMYMDV lpMdv;
    INT iRet;
    CUSTOMDATA cd;

    cd.cbSize = sizeof(CUSTOMDATA);
    cd.hMd = GetModuleHandle((LPSTR)rgchModuleName);
    cd.fnOEMDump = NULL;
    cd.fnOEMOutputChar = OEMOutputChar;

    iRet = UniEnable( lpdv, style, lpModel, lpPort, lpStuff, &cd );

    if (style == 0x0000 && iRet != 0) {

        if (!(lpMdv = GlobalAllocPtr(GHND, sizeof(MYMDV)))) {

            lpdv->fMdv = FALSE;
            UniDisable( lpdv );
            return FALSE;
        }

        lpdv->lpMdv = lpMdv;

        // default values

        memset( lpMdv, 0, sizeof (MYMDV) );
        lpMdv->iCopies = 1;

        // mark we have initialized it

        lpdv->fMdv = TRUE;
    }

    return iRet;
}

//-------------------------------------------------------------------
// Function: Disable()
// Action  : free Mdv and call Mdv
//-------------------------------------------------------------------
void FAR PASCAL Disable(lpdv)
LPDV lpdv;
{
    if ( lpdv->fMdv ) {
        GlobalFreePtr ( lpdv->lpMdv );
        lpdv->fMdv = FALSE;
    }

    UniDisable( lpdv );
}

#endif // WINNT

#ifdef WINNT
/*************************** Function Header *******************************
 *  MiniDrvEnablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
BOOL
MiniDrvEnablePDEV(
LPDV      lpdv,
ULONG    *pdevcaps)
{
    LPMYMDV lpMdv;


    if (!(lpMdv = UniDrvAllocMem(sizeof(MYMDV)))) {

        lpdv->fMdv = FALSE;
        return FALSE;
    }

    lpdv->lpMdv = lpMdv;

    // default values

    memset( lpMdv, 0, sizeof (MYMDV) );
    lpMdv->iCopies = 1;

    // mark we have initialized it

    lpdv->fMdv = TRUE;


    return TRUE;


}
/*************************** Function Header *******************************
 *  MiniDrvDisablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
VOID
MiniDrvDisablePDEV(
LPDV lpdv)
{

    if ( lpdv->fMdv ) {
        UniDrvFreeMem( lpdv->lpMdv );
        lpdv->fMdv = FALSE;
    }


}
BOOL
MyIsDBCSLeadByte(
BYTE bByte)
{
    if(   ((bByte >= 0x81) && (bByte <= 0x9F)) ||
          ((bByte >= 0xE0) && (bByte <= 0xFC)) )
        return TRUE;

    return FALSE;
}


DRVFN
MiniDrvFnTab[] =
{
    {  INDEX_MiniDrvEnablePDEV,       (PFN)MiniDrvEnablePDEV  },
    {  INDEX_MiniDrvDisablePDEV,      (PFN)MiniDrvDisablePDEV  },
    {  INDEX_OEMGetFontCmd,           (PFN)OEMGetFontCmd  },
    {  INDEX_OEMOutputCmd,            (PFN)OEMOutputCmd  },
    {  INDEX_OEMWriteSpoolBuf,        (PFN)CBFilterGraphics  },
    {  INDEX_OEMSendScalableFontCmd,  (PFN)OEMSendScalableFontCmd  },
    {  INDEX_OEMOutputChar,           (PFN)OEMOutputChar  }
};

BOOL
MiniDrvEnableDriver(
    MINIDRVENABLEDATA  *pEnableData
    )
{
    if (pEnableData == NULL)
        return FALSE;

    if (pEnableData->cbSize == 0)
    {
        pEnableData->cbSize = sizeof (MINIDRVENABLEDATA);
        return TRUE;
    }

    if (pEnableData->cbSize < sizeof (MINIDRVENABLEDATA)
            || HIBYTE(pEnableData->DriverVersion)
            < HIBYTE(MDI_DRIVER_VERSION))
    {
        // Wrong size and/or mismatched version
        return FALSE;
    }

    // Load callbacks provided by the Unidriver

    if (!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvWriteSpoolBuf, (PFN *) &WriteSpoolBuf)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvAllocMem, (PFN *) &UniDrvAllocMem)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvFreeMem, (PFN *) &UniDrvFreeMem))
    {
        return FALSE;
    }

    pEnableData->cMiniDrvFn
        = sizeof (MiniDrvFnTab) / sizeof(MiniDrvFnTab[0]);
    pEnableData->pMiniDrvFn = MiniDrvFnTab;

    return TRUE;
}

#endif //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ib87wres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

#include <strsafe.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ib87wres\ib87wres.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ib587res.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

--*/

#include "pdev.h"

#include <windows.h>
#include <stdio.h>

#include <strsafe.h>

HANDLE	RevertToPrinterSelf( VOID );
BOOL	ImpersonatePrinterClient( HANDLE );

/*--------------------------------------------------------------------------*/
/*                             G L O B A L  V A L U E                         */
/*--------------------------------------------------------------------------*/

//Command strings

//
const BYTE CMD_BEGIN_DOC_1[] = {0x1B,0x7E,0xB0,0x00,0x12,0x01} ;
const BYTE CMD_BEGIN_DOC_2[] = {0x01,0x01,0x00} ;
const BYTE CMD_BEGIN_DOC_3[] = {0x02,0x02,0xFF,0xFF} ;
const BYTE CMD_BEGIN_DOC_4[] = {0x03,0x02,0xFF,0xFF} ;
const BYTE CMD_BEGIN_DOC_5[] = {0x04,0x04,0xFF,0xFF,0xFF,0xFF} ;
// ISSUE-2002/3/18-takashim - Not sure why CMD_BEGIN_PAGE[] was defined as 2 bytes.
//const BYTE CMD_BEGIN_PAGE[]    = {0xD4, 0x00} ;
const BYTE CMD_BEGIN_PAGE[]    = {0xD4} ;
const BYTE CMD_END_JOB[] = {0x1B,0x7E,0xB0,0x00,0x04,0x01,0x01,0x01,0x01} ;
const BYTE CMD_END_PAGE[] = {0x20};

//SetPac
#define CMD_SETPAC pOEM->SetPac

#define CMD_SETPAC_FRONT_TRAY_PAPER_SIZE    4
#define CMD_SETPAC_INPUT_BIN                5
#define CMD_SETPAC_RESOLUTION               12
#define CMD_SETPAC_1ST_CASSETTE_PAPER_SIZE  14
#define CMD_SETPAC_2ND_CASSETTE_PAPER_SIZE  15
#define CMD_SETPAC_PAGE_LENGTH              19 // 4 bytes
#define CMD_SETPAC_TONER_SAVE_MODE          25
#define CMD_SETPAC_CUSTOM_DOTS_PER_LINE     26 // 2 bytes
#define CMD_SETPAC_CUSTOM_LINES_PER_PAGE    28 // 2 bytes

const BYTE CMD_SETPAC_TMPL[
        CMD_SETPAC_SIZE]    ={ 0xD7,
                       0x01,
                       0xD0,
                       0x1D, //CommandLength
                       0x00, //Front tray paper size
                       0x00, //Input-bin
                       0x01,
                       0x04, //Bit-assign1
                       0xD9, //Bit-assign2
                       0x04, //EET
                       0x02, //PrintDensity
                       0x01, 
                       0x00, //Resolution
                       0x01,
                       0x00, //1st cassette paper size
                       0x00, //2nd cassette paper size
                       0x0F, //Time to Power Save
                       0x00, 
                       0x01, //Compression Mode
                       0x00,0x00,0x00,0x00, //PageLength
                       0x07, 
                       0x00, //Number of Copies
                       0x00, //Toner save mode
                       0x00,0x00, //Dot per line for custom size
                       0x00,0x00, //Data lines per page for custom size
                       0x00} ;

const BYTE Mask[]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01} ;

const POINTL phySize300[] = {
//    Width,Height Physical paper size for 300dpi
    {3416,4872},    //A3
    {2392,3416},    //A4
    {1672,2392},    //A5
    {2944,4208},    //B4
    {2056,2944},    //B5
    {1088,1656},    //PostCard
    {2456,3208},    //Letter
    {2456,4112},    //Legal
    {0000,0000},    //user define
};
const POINTL phySize600[] = {
//    Width,Height   Physical paper size for 600dpi
    {6832,9736},    //A3
    {4776,6832},    //A4
    {3336,4776},    //A5
    {5888,8416},    //B4
    {4112,5888},    //B5
    {2176,3312},    //PostCard
    {4912,6416},    //Letter
    {4912,8216},    //Legal
    {0000,0000},    //user define
};


/******************* FUNCTIONS *************************/
BOOL MyDeleteFile(PDEVOBJ pdevobj, LPSB lpsb) ;
BOOL InitSpoolBuffer(LPSB lpsb) ;
BOOL MyCreateFile(PDEVOBJ pdevobj, LPSB lpsb) ;
BOOL MySpool(PDEVOBJ pdevobj, LPSB lpsb, PBYTE pBuf, DWORD dwLen) ;
BOOL SpoolOut(PDEVOBJ pdevobj, LPSB lpsb) ;
BOOL MyEndDoc(PDEVOBJ pdevobj) ;
BOOL WriteFileForP_Paper(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen) ;
BOOL WriteFileForL_Paper(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen) ;
BOOL FillPageRestData(PDEVOBJ pdevobj) ;
BOOL SpoolWhiteData(PDEVOBJ pdevobj, DWORD dwWhiteLen, BOOL fComp) ;
BOOL SendPageData(PDEVOBJ pdevobj, PBYTE pSrcImage, DWORD dwLen) ;
BOOL SpoolOutChangedData(PDEVOBJ pdevobj, LPSB lpsb) ;
WORD GetPrintableArea(WORD physSize, INT iRes) ;
BOOL AllocTempBuffer(PIBMPDEV pOEM, DWORD dwNewBufLen) ;
BOOL MyEndPage(PDEVOBJ pdevobj) ;
BOOL MyStartDoc(PDEVOBJ pdevobj) ;

BOOL SpoolOutCompStart(PSOCOMP pSoc);
BOOL SpoolOutCompEnd(PSOCOMP pSoc, PDEVOBJ pdevobj, LPSB psb);
BOOL SpoolOutComp(PSOCOMP pSoc, PDEVOBJ pdevobj, LPSB psb,
    PBYTE pjBuf, DWORD dwLen);

/*****************************************************************************/
/*                                                                             */
/*    Module:         IB587RES.DLL                                              *
/*                                                                             */
/*    Function:        OEMEnablePDEV                                             */
/*                                                                             */
/*    Syntax:         PDEVOEM APIENTRY OEMEnablePDEV(                          */
/*                                        PDEVOBJ         pdevobj,             */
/*                                        PWSTR            pPrinterName,         */
/*                                        ULONG            cPatterns,             */
/*                                        HSURF           *phsurfPatterns,      */
/*                                        ULONG            cjGdiInfo,             */
/*                                        GDIINFO        *pGdiInfo,             */
/*                                        ULONG            cjDevInfo,             */
/*                                        DEVINFO        *pDevInfo,             */
/*                                        DRVENABLEDATA  *pded)                 */
/*                                                                             */
/*    Description:    Allocate buffer of private data to pdevobj                 */
/*                                                                             */
/*****************************************************************************/
PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR            pPrinterName,
    ULONG            cPatterns,
    HSURF           *phsurfPatterns,
    ULONG            cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG            cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PIBMPDEV    pOEM;

    if (!VALID_PDEVOBJ(pdevobj))
    {
        return NULL;
    }

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAlloc(sizeof(IBMPDEV))))
        {
            //DBGPRINT(DBG_WARNING, (ERRORTEXT("OEMEnablePDEV:Memory alloc failed.\n")));
            return NULL;
        }
    }

    pOEM = (PIBMPDEV)(pdevobj->pdevOEM);

    // Setup pdev specific conrol block fields
    ZeroMemory(pOEM, sizeof(IBMPDEV));
    CopyMemory(pOEM->SetPac, CMD_SETPAC_TMPL, sizeof(CMD_SETPAC_TMPL));

    return pdevobj->pdevOEM;
}


/*****************************************************************************/
/*                                                                             */
/*    Module:         IB587RES.DLL                                              */
/*                                                                             */
/*    Function:        OEMDisablePDEV                                             */
/*                                                                             */
/*    Description:    Free buffer of private data                              */
/*                                                                             */
/*****************************************************************************/
VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    if (!VALID_PDEVOBJ(pdevobj))
    {
        return;
    }

    if(pdevobj->pdevOEM)
    {
        if (((PIBMPDEV)(pdevobj->pdevOEM))->pTempImage) {
            MemFree(((PIBMPDEV)(pdevobj->pdevOEM))->pTempImage);
            ((PIBMPDEV)(pdevobj->pdevOEM))->pTempImage = 0;
        }

        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PIBMPDEV pOEMOld, pOEMNew;
    PBYTE pTemp;
    DWORD dwTemp;

    if (!VALID_PDEVOBJ(pdevobjOld)
            || !VALID_PDEVOBJ(pdevobjNew))
    {
        return FALSE;
    }

    pOEMOld = (PIBMPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PIBMPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL) {

        // Save pointer and length
        pTemp = pOEMNew->pTempImage;
        dwTemp = pOEMNew->dwTempBufLen;

        *pOEMNew = *pOEMOld;

        // Restore..
        pOEMNew->pTempImage = pTemp;
        pOEMNew->dwTempBufLen = dwTemp;
    }

    return TRUE;
}

/*****************************************************************************/
/*                                                                             */
/*    Module:    OEMFilterGraphics                                             */
/*                                                                             */
/*    Function:                                                                 */
/*                                                                             */
/*    Syntax:    BOOL APIENTRY OEMFilterGraphics(PDEVOBJ, PBYTE, DWORD)         */
/*                                                                             */
/*    Input:       pdevobj       address of PDEVICE structure                      */
/*               pBuf        points to buffer of graphics data                 */
/*               dwLen       length of buffer in bytes                         */
/*                                                                             */
/*    Output:    BOOL                                                          */
/*                                                                             */
/*    Notice:    nFunction and Escape numbers are the same                     */
/*                                                                             */
/*****************************************************************************/
BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    PIBMPDEV    pOEM;
    BOOL bRet;

    if (!VALID_PDEVOBJ(pdevobj))
    {
        return FALSE;
    }

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    bRet = TRUE;

    if(pOEM->fChangeDirection) {
        bRet = WriteFileForL_Paper(pdevobj, pBuf, dwLen);

    }else{
        bRet = WriteFileForP_Paper(pdevobj, pBuf, dwLen);
    }

    return bRet;
}

/*****************************************************************************/
/*                                                                             */
/*    Module:    OEMCommandCallback                                             */
/*                                                                             */
/*    Function:                                                                 */
/*                                                                             */
/*    Syntax:    INT APIENTRY OEMCommandCallback(PDEVOBJ,DWORD,DWORD,PDWORD)     */
/*                                                                             */
/*    Input:       pdevobj                                                         */
/*               dwCmdCbID                                                     */
/*               dwCount                                                         */
/*               pdwParams                                                     */
/*                                                                             */
/*    Output:    INT                                                             */
/*                                                                             */
/*    Notice:                                                                  */
/*                                                                             */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD    dwCmdCbID,    // Callback ID
    DWORD    dwCount,    // Counts of command parameter
    PDWORD    pdwParams ) // points to values of command params
{
    PIBMPDEV       pOEM;
    WORD            wPhysWidth;
    WORD            wPhysHeight;
    WORD            wDataLen ;
    WORD            wLines ;
    WORD            wNumOfByte ;
    POINTL            ptlUserDefSize;

    BYTE            byOutput[64];
    DWORD            dwNeeded;
    DWORD            dwOptionsReturned;
    INT iRet;

    if (!VALID_PDEVOBJ(pdevobj))
    {
        return FALSE;
    }

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    iRet = 0;

    switch(dwCmdCbID)
    {

        case PAGECONTROL_BEGIN_DOC:
            if (!InitSpoolBuffer(&(pOEM->sb)))
                goto fail;

            if (!MyCreateFile(pdevobj, &(pOEM->sb)))
                goto fail;
            if (!MyCreateFile(pdevobj, &(pOEM->sbcomp)))
                goto fail;

            pOEM->fChangeDirection = FALSE ;
            pOEM->sPageNum = 0 ;

            if (!MyStartDoc(pdevobj))
                goto fail;

            break;

        case PAGECONTROL_BEGIN_PAGE:
            pOEM->dwCurCursorY = 0 ;
            pOEM->dwOffset = 0 ;
            pOEM->sPageNum ++ ;

            if(pOEM->fChangeDirection == FALSE) {
                if (!MySpool(pdevobj, &(pOEM->sb),
                            (PBYTE)CMD_BEGIN_PAGE, sizeof(CMD_BEGIN_PAGE)))
                    goto fail;
                if (!SpoolOutCompStart(&pOEM->Soc))
                    goto fail;
            }

            break;

        case PAGECONTROL_END_PAGE:
            if(pOEM->fChangeDirection == FALSE){
                if (!FillPageRestData(pdevobj))
                    goto fail;
                if (!SpoolOutCompEnd(&pOEM->Soc, pdevobj, &pOEM->sb))
                    goto fail;
                if (!MySpool(pdevobj,&(pOEM->sb),
                    (PBYTE)CMD_END_PAGE, sizeof(CMD_END_PAGE)))
                    goto fail;
            }else{
               if (!SpoolOutChangedData(pdevobj, &(pOEM->sbcomp)))
                   goto fail;
            }

            if (!MyEndPage(pdevobj))
                goto fail;
            
            break;

        case PAGECONTROL_ABORT_DOC:
        case PAGECONTROL_END_DOC:
                       
            if (!MyEndDoc(pdevobj))
                goto fail;
            break;

        case RESOLUTION_300:
            pOEM->ulHorzRes = 300;
            pOEM->ulVertRes = 300;

            CMD_SETPAC[CMD_SETPAC_RESOLUTION] = 0x02 ;
            
            if (pOEM->sPaperSize < PHYS_PAPER_BASE
                    || pOEM->sPaperSize > PHYS_PAPER_MAX)
            {
                goto fail;
            }
            else if( pOEM->sPaperSize == PHYS_PAPER_UNFIXED){
                pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
                pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);

                ptlUserDefSize.x = GetPrintableArea((WORD)pOEM->szlPhysSize.cx, RESOLUTION_300);
                ptlUserDefSize.y = GetPrintableArea((WORD)pOEM->szlPhysSize.cy, RESOLUTION_300);
                pOEM->ptlLogSize = ptlUserDefSize;

                CMD_SETPAC[CMD_SETPAC_CUSTOM_DOTS_PER_LINE] = LOBYTE((WORD)(ptlUserDefSize.x));
                CMD_SETPAC[CMD_SETPAC_CUSTOM_DOTS_PER_LINE + 1] = HIBYTE((WORD)(ptlUserDefSize.x));
                CMD_SETPAC[CMD_SETPAC_CUSTOM_LINES_PER_PAGE] = LOBYTE((WORD)(ptlUserDefSize.y));
                CMD_SETPAC[CMD_SETPAC_CUSTOM_LINES_PER_PAGE + 1] = HIBYTE((WORD)(ptlUserDefSize.y));
            }
            else
            {
                pOEM->ptlLogSize = phySize300[
                        pOEM->sPaperSize-PHYS_PAPER_BASE];
            }

            break;

        case RESOLUTION_600:
            pOEM->ulHorzRes = 600;
            pOEM->ulVertRes = 600;
            pOEM->ptlLogSize = phySize600[pOEM->sPaperSize-50];
            CMD_SETPAC[CMD_SETPAC_RESOLUTION] = 0x20 ;

            if (pOEM->sPaperSize < PHYS_PAPER_BASE
                    || pOEM->sPaperSize > PHYS_PAPER_MAX)
            {
                goto fail;
            }
            else if( pOEM->sPaperSize == PHYS_PAPER_UNFIXED){
                pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
                pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);

                ptlUserDefSize.x = GetPrintableArea((WORD)pOEM->szlPhysSize.cx, RESOLUTION_600);
                ptlUserDefSize.y = GetPrintableArea((WORD)pOEM->szlPhysSize.cy, RESOLUTION_600);
                pOEM->ptlLogSize = ptlUserDefSize;

                CMD_SETPAC[CMD_SETPAC_CUSTOM_DOTS_PER_LINE] = LOBYTE((WORD)(ptlUserDefSize.x));
                CMD_SETPAC[CMD_SETPAC_CUSTOM_DOTS_PER_LINE + 1] = HIBYTE((WORD)(ptlUserDefSize.x));
                CMD_SETPAC[CMD_SETPAC_CUSTOM_LINES_PER_PAGE] = LOBYTE((WORD)(ptlUserDefSize.y));
                CMD_SETPAC[CMD_SETPAC_CUSTOM_LINES_PER_PAGE + 1] = HIBYTE((WORD)(ptlUserDefSize.y));
            }
            else {
                pOEM->ptlLogSize = phySize600[
                         pOEM->sPaperSize-PHYS_PAPER_BASE];
            }
            break;

        case SEND_BLOCK_DATA:
            wNumOfByte = (WORD)PARAM(pdwParams, 0);

            pOEM->wImgHeight = (WORD)PARAM(pdwParams, 1);
            pOEM->wImgWidth = (WORD)PARAM(pdwParams, 2);
            break;

        case ORIENTATION_PORTRAIT:                   // 28
        case ORIENTATION_LANDSCAPE:                 // 29
             switch(pOEM->sPaperSize){
                case PHYS_PAPER_A3 :
                case PHYS_PAPER_B4 :
                case PHYS_PAPER_LEGAL :
                case PHYS_PAPER_POSTCARD :
                    pOEM->fChangeDirection = FALSE ;
                    pOEM->fComp = TRUE ;
                    break;

                case PHYS_PAPER_A4 :
                case PHYS_PAPER_A5 :
                case PHYS_PAPER_B5 :
                case PHYS_PAPER_LETTER :
                    pOEM->fChangeDirection = TRUE ;
                    pOEM->fComp = FALSE ;
                    break;

                case PHYS_PAPER_UNFIXED :           /* Paper is not rotated in UNFIXED case */
                    pOEM->fChangeDirection = FALSE ;
                    pOEM->fComp = TRUE ;
                    break;
            }
            break;

        case PHYS_PAPER_A3:                 // 50
             pOEM->sPaperSize = PHYS_PAPER_A3 ;
             CMD_SETPAC[CMD_SETPAC_FRONT_TRAY_PAPER_SIZE] = 0x04 ;
             CMD_SETPAC[CMD_SETPAC_1ST_CASSETTE_PAPER_SIZE] = 0x04 ;
             CMD_SETPAC[CMD_SETPAC_2ND_CASSETTE_PAPER_SIZE] = 0x04 ;
             break ;
        case PHYS_PAPER_A4:                 // 51
             pOEM->sPaperSize = PHYS_PAPER_A4 ;
             CMD_SETPAC[CMD_SETPAC_FRONT_TRAY_PAPER_SIZE] = 0x83 ;
             CMD_SETPAC[CMD_SETPAC_1ST_CASSETTE_PAPER_SIZE] = 0x83 ;
             CMD_SETPAC[CMD_SETPAC_2ND_CASSETTE_PAPER_SIZE] = 0x83 ;
             break ;
        case PHYS_PAPER_B4:                 // 54
             pOEM->sPaperSize = PHYS_PAPER_B4 ;
             CMD_SETPAC[CMD_SETPAC_FRONT_TRAY_PAPER_SIZE] = 0x07 ;
             CMD_SETPAC[CMD_SETPAC_1ST_CASSETTE_PAPER_SIZE] = 0x07 ;
             CMD_SETPAC[CMD_SETPAC_2ND_CASSETTE_PAPER_SIZE] = 0x07 ;
             break ;
        case PHYS_PAPER_LETTER:             // 57
             pOEM->sPaperSize = PHYS_PAPER_LETTER ;
             CMD_SETPAC[CMD_SETPAC_FRONT_TRAY_PAPER_SIZE] = 0x90 ;
             CMD_SETPAC[CMD_SETPAC_1ST_CASSETTE_PAPER_SIZE] = 0x90 ;
             CMD_SETPAC[CMD_SETPAC_2ND_CASSETTE_PAPER_SIZE] = 0x90 ;
             break ;
        case PHYS_PAPER_LEGAL:                // 58
             pOEM->sPaperSize = PHYS_PAPER_LEGAL ;
             CMD_SETPAC[CMD_SETPAC_FRONT_TRAY_PAPER_SIZE] = 0x11 ;
             CMD_SETPAC[CMD_SETPAC_1ST_CASSETTE_PAPER_SIZE] = 0x11 ;
             CMD_SETPAC[CMD_SETPAC_2ND_CASSETTE_PAPER_SIZE] = 0x11 ;
             break ;

        case PHYS_PAPER_B5:                 // 55
             pOEM->sPaperSize = PHYS_PAPER_B5 ;
             CMD_SETPAC[CMD_SETPAC_FRONT_TRAY_PAPER_SIZE] = 0x86 ;
             CMD_SETPAC[CMD_SETPAC_1ST_CASSETTE_PAPER_SIZE] = 0x86 ;
             CMD_SETPAC[CMD_SETPAC_2ND_CASSETTE_PAPER_SIZE] = 0x86 ;
             break ;
        case PHYS_PAPER_A5:                 // 52
             pOEM->sPaperSize = PHYS_PAPER_A5 ;
             CMD_SETPAC[CMD_SETPAC_FRONT_TRAY_PAPER_SIZE] = 0x82 ;
             CMD_SETPAC[CMD_SETPAC_1ST_CASSETTE_PAPER_SIZE] = 0x82 ;
             CMD_SETPAC[CMD_SETPAC_2ND_CASSETTE_PAPER_SIZE] = 0x82 ;
             break ;

        case PHYS_PAPER_POSTCARD:            // 59
             pOEM->sPaperSize = PHYS_PAPER_POSTCARD ;
             CMD_SETPAC[CMD_SETPAC_FRONT_TRAY_PAPER_SIZE] = 0x17 ;
             CMD_SETPAC[CMD_SETPAC_1ST_CASSETTE_PAPER_SIZE] = 0x17 ;
             CMD_SETPAC[CMD_SETPAC_2ND_CASSETTE_PAPER_SIZE] = 0x17 ;
             break ;

        case PHYS_PAPER_UNFIXED:            // 60
             pOEM->sPaperSize = PHYS_PAPER_UNFIXED ;
             CMD_SETPAC[CMD_SETPAC_FRONT_TRAY_PAPER_SIZE] = 0x3F ;
             CMD_SETPAC[CMD_SETPAC_1ST_CASSETTE_PAPER_SIZE] = 0x3F ;
             CMD_SETPAC[CMD_SETPAC_2ND_CASSETTE_PAPER_SIZE] = 0x3F ;

             break ;

        case PAPER_SRC_FTRAY:
             CMD_SETPAC[CMD_SETPAC_INPUT_BIN] = 0x01 ;
             break ;

        case PAPER_SRC_CAS1:
            CMD_SETPAC[CMD_SETPAC_INPUT_BIN] = 0x02 ;
            break;

        case PAPER_SRC_CAS2:
            CMD_SETPAC[CMD_SETPAC_INPUT_BIN] = 0x04 ;
            break;

        case PAPER_SRC_AUTO:
            CMD_SETPAC[CMD_SETPAC_INPUT_BIN] = 0x04 ;
            break;


        case TONER_SAVE_MEDIUM:                // 100
            CMD_SETPAC[CMD_SETPAC_TONER_SAVE_MODE] = 0x02 ;
            break;

        case TONER_SAVE_DARK:                // 101
            CMD_SETPAC[CMD_SETPAC_TONER_SAVE_MODE] = 0x04 ;
            break;

        case TONER_SAVE_LIGHT:                // 102
            CMD_SETPAC[CMD_SETPAC_TONER_SAVE_MODE] = 0x01 ;
            break;


        case PAGECONTROL_MULTI_COPIES:
            CMD_SETPAC[24] = (BYTE)PARAM(pdwParams, 0);
            pOEM->sCopyNum = (BYTE)PARAM(pdwParams, 0);
            break;
        
        case Y_REL_MOVE :

            if (0 == pOEM->ulHorzRes)
                goto fail;

            pOEM->dwYmove=(WORD)*pdwParams/(MASTERUNIT/(WORD)pOEM->ulHorzRes);

// ISSUE-2002/3/18-takashim - Faking Unidrv here?
// iRet = 0; below is intentional:  Retuning dwYmove will cause
// incorrect outputs.
// DestYRel in GPD means the coordinate relative to the current
// cursor position.  Here, minidriver is always returning 0 (no move)
// to Unidrv, so it is always absolute coordinate (relative to
// the origin)?

            if(pOEM->dwCurCursorY < pOEM->dwYmove){
                pOEM->dwYmove -= pOEM->dwCurCursorY ;
            }else{
                pOEM->dwYmove = 0 ;
            }

//            iRet = pOEM->dwYmove;
            iRet = 0;

            break;
            

        default:
            break;
    }
    return iRet;

fail:
    return -1;
}


/*****************************************************************************/
/*                                                                             */
/*    Module:    GetPrintableArea                                              */
/*                                                                             */
/*    Function:  Calculate PrintableArea for user defined paper                 */
/*                                                                             */
/*    Syntax:    WORD GetPrintableArea(WORD physSize, INT iRes)                 */
/*                                                                             */
/*    Input:       physSize                                                      */
/*               iRes                                                          */
/*                                                                             */
/*    Output:    WORD                                                          */
/*                                                                             */
/*    Notice:                                                                  */
/*                                                                             */
/*****************************************************************************/
WORD GetPrintableArea(WORD physSize, INT iRes)
{
    DWORD dwArea ;
    DWORD dwPhysSizeMMx10 = physSize * 254 / MASTERUNIT;

    /* Unit of phySize is MASTERUNIT(=1200) */

    if(iRes == RESOLUTION_300){
        dwArea = (((WORD)(( ( (DWORD)(dwPhysSizeMMx10*300/25.4) -
                            2*( (DWORD)(4*300*10/25.4) ) ) / 10 +7)/8))) * 8;
    }else{
        dwArea = (((WORD)(( ( (DWORD)(dwPhysSizeMMx10*600/25.4) -
                            2*( (DWORD)(4*600*10/25.4) ) ) / 10 +7)/8))) * 8;
    }

    return (WORD)dwArea ;
}

// NOTICE-2002/3/18/-takashim - Comment
// // #94193: shold create temp. file on spooler directory.
//

/*++

Routine Description:

  This function comes up with a name for a spool file that we should be
  able to write to.

  Note: The file name returned has already been created.

Arguments:

  hPrinter - handle to the printer that we want a spool file for.

  ppwchSpoolFileName: pointer that will receive an allocated buffer
                      containing the file name to spool to.  CALLER
                      MUST FREE.  Use LocalFree().


Return Value:

  TRUE if everything goes as expected.
  FALSE if anything goes wrong.

--*/

BOOL
GetSpoolFileName(
  IN HANDLE hPrinter,
  IN OUT PWCHAR pwchSpoolPath
)
{
  PBYTE         pBuffer = NULL;
  DWORD         dwAllocSize;
  DWORD         dwNeeded = 0;
  DWORD         dwRetval;
  HANDLE        hToken=NULL;

  hToken = RevertToPrinterSelf();

  //
  //  In order to find out where the spooler's directory is, we add
  //  call GetPrinterData with DefaultSpoolDirectory.
  //

  dwAllocSize = ( MAX_PATH ) * sizeof (WCHAR);

  for (;;)
  {
    pBuffer = LocalAlloc( LMEM_FIXED, dwAllocSize );

    if ( pBuffer == NULL )
    {
      ERR((DLLTEXT("LocalAlloc faild, %d\n"), GetLastError()));
      goto Failure;
    }

    if ( GetPrinterData( hPrinter,
                         SPLREG_DEFAULT_SPOOL_DIRECTORY,
                         NULL,
                         pBuffer,
                         dwAllocSize,
                         &dwNeeded ) == ERROR_SUCCESS )
    {
      break;
    }

    if ( ( dwNeeded < dwAllocSize ) ||( GetLastError() != ERROR_MORE_DATA ))
    {
      ERR((DLLTEXT("GetPrinterData failed in a non-understood way.\n")));
      goto Failure;
    }

    //
    // Free the current buffer and increase the size that we try to allocate
    // next time around.
    //

    LocalFree( pBuffer );

    dwAllocSize = dwNeeded;
  }

// FUTURE-2002/3/18-takashim - Temp file path restricted to ANSI.
// According to the SDK document, the pathname handled by GetTempFileName
// must be consist of ANSI characters.  What happens with double-byte
// characters, etc??

  if( !GetTempFileName( (LPWSTR)pBuffer, TEMP_NAME_PREFIX, 0, pwchSpoolPath ))
  {
      goto Failure;
  }

  //
  //  At this point, the spool file name should be done.  Free the structure
  //  we used to get the spooler temp dir and return.
  //

  LocalFree( pBuffer );

  if (NULL != hToken) {
      if (!ImpersonatePrinterClient(hToken))
      {
        // failure..
        return FALSE;
      }
  }

  return( TRUE );

Failure:

  //
  //  Clean up and fail.
  //
  if ( pBuffer != NULL )
  {
    LocalFree( pBuffer );
  }

  if (hToken != NULL)
  {
      (void)ImpersonatePrinterClient(hToken);
  }
  return ( FALSE );
}

//SPLBUF is used for control temp files.
//This printer need the number of bytes of whole page data.
BOOL InitSpoolBuffer(LPSB lpsb)
{
    lpsb->dwWrite = 0 ;
    lpsb->TempName[0] = __TEXT('\0') ;
    lpsb->hFile = INVALID_HANDLE_VALUE ;

    return TRUE;
}

BOOL MyCreateFile(PDEVOBJ pdevobj, LPSB lpsb)
{
    HANDLE hToken = NULL;
    BOOL bRet = FALSE;

    if (!GetSpoolFileName(pdevobj->hPrinter, lpsb->TempName)) {
        //DBGPRINT(DBG_WARNING, ("GetSpoolFileName failed.\n"));
        goto fail;
    }

    hToken = RevertToPrinterSelf();

    lpsb->hFile = CreateFile((LPCTSTR)lpsb->TempName,
                     (GENERIC_READ | GENERIC_WRITE), 
                     0,                             
                     NULL,                            
                     CREATE_ALWAYS,                 
                     FILE_ATTRIBUTE_NORMAL,         
                     NULL) ;

    if(lpsb->hFile == INVALID_HANDLE_VALUE)
    {
        //DBGPRINT(DBG_WARNING, ("Tmp file cannot create.\n"));
        DeleteFile(lpsb->TempName);
        lpsb->TempName[0] = __TEXT('\0') ;
        goto fail;
    }
    bRet = TRUE;

fail:
    if (hToken) (void)ImpersonatePrinterClient(hToken);
    return bRet ;
}

BOOL MyDeleteFile(PDEVOBJ pdevobj, LPSB lpsb)
{    
    HANDLE hToken = NULL;
    BOOL bRet = FALSE;

    if(lpsb->hFile != INVALID_HANDLE_VALUE){

        if (0 == CloseHandle(lpsb->hFile)) {
            //DBGPRINT(DBG_WARNING, ("CloseHandle error %d\n"));
            goto fail;
        }
        lpsb->hFile = INVALID_HANDLE_VALUE ;
        hToken = RevertToPrinterSelf();
        if (0 == DeleteFile(lpsb->TempName)) {
            //DBGPRINT(DBG_WARNING, ("DeleteName error %d\n",GetLastError()));
            goto fail;
        }
        lpsb->TempName[0] = __TEXT('\0');

    }
    bRet = TRUE;

fail:
    if (hToken) (void)ImpersonatePrinterClient(hToken);
    return bRet;
}

//Spool page data to temp file
BOOL MySpool
    (PDEVOBJ pdevobj,
     LPSB  lpsb,
     PBYTE pBuf,
     DWORD dwLen)
{
    DWORD dwTemp, dwTemp2;
    BYTE *pTemp;

    if (lpsb->hFile != INVALID_HANDLE_VALUE) {

        pTemp = pBuf;
        dwTemp = dwLen;
        while (dwTemp > 0) {

            if (0 == WriteFile(lpsb->hFile,
                               pTemp,
                               dwTemp,
                               &dwTemp2,
                               NULL)
                    || dwTemp2 > dwTemp) {

                ERR((DLLTEXT("WriteFile error in CacheData %d.\n"),
                    GetLastError()));
                return FALSE;
            }
            pTemp += dwTemp2;
            dwTemp -= dwTemp2;
            lpsb->dwWrite += dwTemp2 ;
        }
        return TRUE;
    }
    else {
        return WRITESPOOLBUF(pdevobj, pBuf, dwLen);
    }
}

//Dump out temp file to printer
BOOL
SpoolOut(PDEVOBJ pdevobj, LPSB lpsb)
{
 
   DWORD dwSize, dwTemp, dwTemp2;
   HANDLE hFile;

    BYTE  Buf[SPOOL_OUT_BUF_SIZE];

    hFile = lpsb->hFile ;
    dwSize = lpsb->dwWrite ;

    VERBOSE(("dwSize=%ld\n", dwSize));

    if (0L != SetFilePointer(hFile, 0L, NULL, FILE_BEGIN)) {

        ERR((DLLTEXT("SetFilePointer failed %d\n"),
            GetLastError()));
        return FALSE;
    }

    for ( ; dwSize > 0; dwSize -= dwTemp2) {

        dwTemp = ((SPOOL_OUT_BUF_SIZE < dwSize)
            ? SPOOL_OUT_BUF_SIZE : dwSize);

        if (0 == ReadFile(hFile, Buf, dwTemp, &dwTemp2, NULL)
                || dwTemp2 > dwTemp) {
            ERR((DLLTEXT("ReadFile error in SendCachedData.\n")));
            return FALSE;
        }

        if (dwTemp2 > 0) {
            if (!WRITESPOOLBUF(pdevobj, Buf, dwTemp2))
                return FALSE;
        }
    }

    return TRUE;
}

BOOL MyStartDoc(PDEVOBJ pdevobj)
{
    return
    WRITESPOOLBUF(pdevobj, (PBYTE)CMD_BEGIN_DOC_1, sizeof(CMD_BEGIN_DOC_1)) &&
    WRITESPOOLBUF(pdevobj, (PBYTE)CMD_BEGIN_DOC_2, sizeof(CMD_BEGIN_DOC_2)) &&
    WRITESPOOLBUF(pdevobj, (PBYTE)CMD_BEGIN_DOC_3, sizeof(CMD_BEGIN_DOC_3)) &&
    WRITESPOOLBUF(pdevobj, (PBYTE)CMD_BEGIN_DOC_4, sizeof(CMD_BEGIN_DOC_4)) &&
    WRITESPOOLBUF(pdevobj, (PBYTE)CMD_BEGIN_DOC_5, sizeof(CMD_BEGIN_DOC_5));
}

BOOL MyEndPage(PDEVOBJ pdevobj)
{
    PIBMPDEV    pOEM;
    LPSB        lpsb, lpsbco ;
    DWORD        dwPageLen ;
    WORD        wTmph, wTmpl ;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;
    lpsb = &(pOEM->sb) ;
    lpsbco = &(pOEM->sbcomp) ;

    if(pOEM->fChangeDirection == FALSE) {
        dwPageLen = lpsb->dwWrite;
    }
    else {
        dwPageLen = lpsbco->dwWrite ;
    }

// NOTICE-2002/3/18-takashim - What is this?

    dwPageLen -= 3 ; //End page Command Len

    VERBOSE(("MyEndPage - dwPageLen=%ld\n",
        dwPageLen));

    wTmpl = LOWORD(dwPageLen) ;
    wTmph = HIWORD(dwPageLen) ;
    
    CMD_SETPAC[CMD_SETPAC_PAGE_LENGTH] = LOBYTE(wTmpl);
    CMD_SETPAC[CMD_SETPAC_PAGE_LENGTH + 1] = HIBYTE(wTmpl);
    CMD_SETPAC[CMD_SETPAC_PAGE_LENGTH + 2] = LOBYTE(wTmph);
    CMD_SETPAC[CMD_SETPAC_PAGE_LENGTH + 3] = HIBYTE(wTmph);

    if (!WRITESPOOLBUF(pdevobj, CMD_SETPAC, sizeof(CMD_SETPAC)))
        return FALSE;

    if(pOEM->fChangeDirection == FALSE){
        if (!SpoolOut(pdevobj, lpsb))
            return FALSE;
    }else{
        if (!SpoolOut(pdevobj, lpsbco))
            return FALSE;
    }

    //InitFiles
    lpsbco->dwWrite = 0 ;
    lpsb->dwWrite = 0 ;

    if(INVALID_SET_FILE_POINTER==SetFilePointer(lpsb->hFile,0,NULL,FILE_BEGIN)){
        ERR((DLLTEXT("SetFilePointer failed %d\n"),
             GetLastError()));
        return FALSE;
    }

    if(INVALID_SET_FILE_POINTER==SetFilePointer(lpsbco->hFile,0,NULL,FILE_BEGIN)){
        ERR((DLLTEXT("SetFilePointer failed %d\n"),
             GetLastError()));
        return FALSE;
    }

    return TRUE;
}

BOOL MyEndDoc(PDEVOBJ pdevobj)
{
    PIBMPDEV    pOEM;
    LPSB        lpsb, lpsbco ;
    WORD        wTmph, wTmpl ;
    DWORD        dwPageLen ;
    SHORT        i ;
    LPPD        lppdTemp ;
    BOOL        bRet = FALSE;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;
    lpsb = &(pOEM->sb) ;
    lpsbco = &(pOEM->sbcomp) ;


    if (!WRITESPOOLBUF(pdevobj, (PBYTE)CMD_END_JOB, sizeof(CMD_END_JOB)))
        goto fail;

    if (!MyDeleteFile(pdevobj, lpsb))
        goto fail;
    if (!MyDeleteFile(pdevobj, lpsbco))
        goto fail;
    bRet = TRUE;

fail:
    return bRet;
}

BOOL WriteFileForP_Paper(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen)
{
    PIBMPDEV           pOEM;
    ULONG                ulHorzPixel;
    WORD                wCompLen;
    DWORD                dwWhiteLen ;
    DWORD                dwTmp ;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    if (pOEM->dwYmove > 0) {

        dwWhiteLen = pOEM->wImgWidth * pOEM->dwYmove;

        if (!SpoolWhiteData(pdevobj, dwWhiteLen, TRUE))
            return FALSE;

        pOEM->dwCurCursorY += pOEM->dwYmove;
        pOEM->dwYmove = 0;
    }

    pOEM->dwCurCursorY += dwLen/pOEM->wImgWidth - 1 ;

    return SendPageData(pdevobj, pBuf, dwLen) ;
}

BOOL WriteFileForL_Paper(PDEVOBJ pdevobj, PBYTE pBuf, DWORD dwLen)
{
    PIBMPDEV           pOEM;
    ULONG                ulHorzPixel;
    WORD                wCompLen;
    DWORD                dwWhiteLen ;

    DWORD i, j;
    DWORD dwHeight, dwWidth;
    PBYTE pTemp;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    if (pOEM->dwYmove > 0) {

        dwWhiteLen = pOEM->wImgWidth * pOEM->dwYmove;

        if (!SpoolWhiteData(pdevobj, dwWhiteLen, FALSE))
            return FALSE;

        pOEM->dwCurCursorY += pOEM->dwYmove;
        pOEM->dwYmove = 0;
    }

    pOEM->dwCurCursorY += dwLen/pOEM->wImgWidth - 1 ;
    pOEM->dwOffset ++ ;

    return MySpool(pdevobj, &(pOEM->sb), pBuf,dwLen);
}


//fill page blanks.
BOOL FillPageRestData(PDEVOBJ pdevobj)
{

    PIBMPDEV    pOEM ;
    DWORD        dwRestHigh ;
    DWORD        dwWhiteLen ;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;
    
    dwRestHigh = pOEM->ptlLogSize.y - pOEM->dwCurCursorY ;

    if(dwRestHigh <= 0)
        return TRUE;

    dwWhiteLen = pOEM->ptlLogSize.x * dwRestHigh;

    return SpoolWhiteData(pdevobj, dwWhiteLen, pOEM->fComp);
}

//not white data
BOOL SendPageData(PDEVOBJ pdevobj, PBYTE pSrcImage, DWORD dwLen)
{
    PIBMPDEV           pOEM;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    return SpoolOutComp(&pOEM->Soc, pdevobj, &pOEM->sb, pSrcImage, dwLen);
}

BOOL SpoolWhiteData(PDEVOBJ pdevobj, DWORD dwWhiteLen, BOOL fComp)
{

    PIBMPDEV    pOEM;
    PBYTE        pWhite ;
    WORD        wCompLen ;
    DWORD        dwTempLen ;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;

    if(dwWhiteLen == 0)
        return TRUE;

    if(dwWhiteLen > MAXIMGSIZE){
        dwTempLen = MAXIMGSIZE ;
    }else{
        dwTempLen = dwWhiteLen ;
    }

    if (!AllocTempBuffer(pOEM, dwTempLen))
        return FALSE;
    pWhite = pOEM->pTempImage;

    ZeroMemory(pWhite, dwTempLen);

    if(fComp == TRUE)
    {
        DWORD dwTemp;

        while (0 < dwWhiteLen) {

            if (MAXIMGSIZE <= dwWhiteLen)
                dwTemp = MAXIMGSIZE;
            else
                dwTemp = dwWhiteLen;

            if (!SpoolOutComp(&pOEM->Soc, pdevobj, &pOEM->sb, pWhite, dwTemp))
                return FALSE;
            dwWhiteLen -= dwTemp;
        }

    }
    else{
        if(dwWhiteLen > MAXIMGSIZE){
            while(dwWhiteLen > MAXIMGSIZE){
                if (!MySpool(pdevobj, &pOEM->sb, pWhite, MAXIMGSIZE))
                    return FALSE;

                dwWhiteLen -= MAXIMGSIZE ;
            }
        }

        if(dwWhiteLen > 0){
            if (!MySpool(pdevobj, &pOEM->sb, pWhite, dwWhiteLen))
                return FALSE;

        }
    }

    return TRUE;
}

BOOL SpoolOutChangedData(PDEVOBJ pdevobj, LPSB lpsb)
{
    PIBMPDEV    pOEM;
    POINTL        ptlDataPos ;
    DWORD        dwFilePos, dwTemp;
    HANDLE        hFile ;
    PBYTE        pSaveFileData ;
    PBYTE        pTemp;
    PBYTE        pTransBuf ;
    DWORD        X, Y;
    DWORD        dwFirstPos ;
    INT h, i, j, k;

    POINTL ptlBand;
    PBYTE pSrc, pDst, pSrcSave;
    DWORD dwBandY, dwImageY, dwImageX;
    BOOL bBlank, bZero;
    BOOL bRet = FALSE;

    pOEM = (PIBMPDEV)pdevobj->pdevOEM;
    hFile = pOEM->sb.hFile ;

    // band size in pixels
    ptlBand.x = pOEM->ptlLogSize.y;
    ptlBand.y = TRANS_BAND_Y_SIZE;

    //t@CJnuvZ
    // Calculate read start positoin in the file
    ptlDataPos.x = 0 ;
    ptlDataPos.y = pOEM->dwCurCursorY + pOEM->dwOffset ;

    //cAPs]
    // Y direction, blank area beneth.
    dwImageX = ((ptlDataPos.y + 7) / 8) * 8;

    // Buffer for loading file data (scan lines for a band)
    pSaveFileData = (PBYTE)MemAlloc((ptlBand.y / 8) * dwImageX);
    if (NULL == pSaveFileData) {
        ERR(("Failed to allocate memory.\n"));
        return FALSE;
    }

    // Buffer for transpositions (one scan line)
    pTransBuf = (PBYTE)MemAlloc((ptlBand.x / 8));
    if (NULL == pTransBuf) {
        ERR(("Failed to allocate memory.\n"));
// #441444: PREFIX: reference NULL pointer.
        goto out;
    }

    //t@CuwB
    // Specify read start positoin in the file
    dwFirstPos = pOEM->wImgWidth - 1;

    if (!MySpool(pdevobj,&(pOEM->sbcomp),
                (PBYTE)CMD_BEGIN_PAGE, sizeof(CMD_BEGIN_PAGE)))
        goto out;
    if (!SpoolOutCompStart(&pOEM->Soc))
        goto out;

    dwImageY = pOEM->wImgWidth;

    bBlank = FALSE;
    bZero = FALSE;
    for (X = 0; X < (DWORD)pOEM->ptlLogSize.x / 8; X += dwBandY) {

        //]ZbgBB
        // Set blank area, then read skip.
        dwBandY = ptlBand.y / 8;
        if (dwBandY > (DWORD)pOEM->ptlLogSize.x / 8 - X)
            dwBandY = (DWORD)pOEM->ptlLogSize.x / 8 - X;

        // White scanlines.  Currently the trailing ones only,
        // desired to be udpated to include others.

        if (X >= dwImageY) {
            bBlank = TRUE;
        }

        // Output white scanline.
        if (bBlank) {

            if (!bZero) {
                ZeroMemory(pTransBuf, (ptlBand.x / 8));
                bZero = TRUE;
            }

            for (i = 0; i < (INT)dwBandY * 8; i++) {
                if (!SpoolOutComp(&pOEM->Soc, pdevobj, &pOEM->sbcomp,
                    (PBYTE)pTransBuf, (ptlBand.x / 8)))
                    goto out;
            }
            continue;
        }

        // Non-white scanlines.

        pTemp = pSaveFileData ;
        dwFilePos = pOEM->wImgWidth - X - dwBandY;

        //cPst@CB
        // Read vertial one line from the file.

        for (Y = 0; Y < dwImageX; pTemp += dwBandY, Y++) {

            if (Y >= (DWORD)ptlDataPos.y) {
                ZeroMemory(pTemp, dwBandY);
                continue;
            }

            if(INVALID_SET_FILE_POINTER==SetFilePointer(hFile,dwFilePos,NULL,FILE_BEGIN)){
                 ERR((DLLTEXT("SetFilePointer failed %d\n"),
                     GetLastError()));
// #441442: PREFIX: leaking memory.
                    // return;
                    goto out;
            }

            if (0 == ReadFile(hFile, pTemp, dwBandY, &dwTemp, NULL)
                    || dwTemp > dwBandY) {
                 ERR(("Faild reading data from file. (%d)\n",
                     GetLastError()));
// #441442: PREFIX: leaking memory.
                // return;
                goto out;
            }

            dwFilePos += pOEM->wImgWidth;

        }//End of Y loop

        // Transposition and output dwBandY * 8 scan lines
        for (h = 0; h < (INT)dwBandY; h++) {

            //VERBOSE(("> %d/%d\n", h, dwBandY));

            pSrcSave = pSaveFileData + dwBandY - 1 - h;

            // Transposition and output eight scan lines
            for (j = 0; j < 8; j++) {

                pSrc = pSrcSave;
                pDst = pTransBuf;
                ZeroMemory(pDst, (ptlBand.x / 8));

                // Transposition one scan line

                for (i = 0; i < (INT)(dwImageX / 8); i++){

                    for (k = 0; k < 8; k++) {

                        if (0 != (*pSrc & Mask[7 - j])) {
                            *pDst |= Mask[k];
                        }
                        pSrc += dwBandY;
                    }
                    pDst++;
                }

                // Output one scan line
                if (!SpoolOutComp(&pOEM->Soc, pdevobj, &pOEM->sbcomp,
                    (PBYTE)pTransBuf, (ptlBand.x / 8)))
                    goto out;
            }
        }

    }

    // Mark end of image
    if (!SpoolOutCompEnd(&pOEM->Soc, pdevobj, &pOEM->sbcomp))
        goto out;
    if (!MySpool(pdevobj, &(pOEM->sbcomp),
        (PBYTE)CMD_END_PAGE, sizeof(CMD_END_PAGE)))
        goto out;

    bRet = TRUE;

// #441442: PREFIX: leaking memory.
out:
    if (NULL != pSaveFileData){
        MemFree(pSaveFileData);
    }
    if(NULL != pTransBuf){
        MemFree(pTransBuf);
    }

    return bRet;
}

BOOL
AllocTempBuffer(
    PIBMPDEV pOEM,
    DWORD dwNewBufLen)
{
   if (NULL == pOEM->pTempImage ||
        dwNewBufLen > pOEM->dwTempBufLen) {

        if (NULL != pOEM->pTempImage) {
            MemFree(pOEM->pTempImage);
        }
        pOEM->pTempImage = (PBYTE)MemAlloc(dwNewBufLen);
        if (NULL == pOEM->pTempImage) {
            WARNING(("Failed to allocate memory. (%d)\n",
                GetLastError()));

            pOEM->dwTempBufLen = 0;
            return FALSE;
        }
        pOEM->dwTempBufLen = dwNewBufLen;
    }
    return TRUE;
}

BOOL
SpoolOutCompStart(
    PSOCOMP pSoc)
{
    pSoc->iNRCnt = 0;
    pSoc->iRCnt = 0;
    pSoc->iPrv = -1;

    return TRUE;
}

BOOL
SpoolOutCompEnd(
    PSOCOMP pSoc,
    PDEVOBJ pdevobj,
    LPSB psb)
{
    BYTE jTemp;

    if (0 < pSoc->iNRCnt) {
        jTemp = ((BYTE)pSoc->iNRCnt) - 1;
        if (!MySpool(pdevobj, psb, &jTemp, 1))
            return FALSE;
        if (!MySpool(pdevobj, psb, pSoc->pjNRBuf, pSoc->iNRCnt))
            return FALSE;
        pSoc->iNRCnt = 0;
    }

    if (0 < pSoc->iRCnt) {
        jTemp = (0 - (BYTE)pSoc->iRCnt) + 1;
        if (!MySpool(pdevobj, psb, &jTemp, 1))
            return FALSE;
        if (!MySpool(pdevobj, psb, &pSoc->iPrv, 1))
            return FALSE;
        pSoc->iRCnt = 0;
    }

    return TRUE;
}

BOOL
SpoolOutComp(
    PSOCOMP pSoc,
    PDEVOBJ pdevobj,
    LPSB psb,
    PBYTE pjBuf,
    DWORD dwLen)
{
    BYTE jCur, jTemp;

    while (0 < dwLen--) {

        jCur = *pjBuf++;

        if (pSoc->iPrv == jCur) {

            if (0 < pSoc->iNRCnt) {
                if (1 < pSoc->iNRCnt) {
                    jTemp = ((BYTE)pSoc->iNRCnt - 1) - 1;
                    if (!MySpool(pdevobj, psb, &jTemp, 1))
                        return FALSE;
                    if (!MySpool(pdevobj, psb, pSoc->pjNRBuf, pSoc->iNRCnt - 1))
                        return FALSE;
                }
                pSoc->iNRCnt = 0;
                pSoc->iRCnt = 1;
            }

            pSoc->iRCnt++;

            if (RPEAK == pSoc->iRCnt) {
                jTemp = (0 - (BYTE)pSoc->iRCnt) + 1;
                if (!MySpool(pdevobj, psb, &jTemp, 1))
                    return FALSE;
                if (!MySpool(pdevobj, psb, &jCur, 1))
                    return FALSE;
                pSoc->iRCnt = 0;
            }
        }
        else {

            if (0 < pSoc->iRCnt) {
                jTemp = (0 - (BYTE)pSoc->iRCnt) + 1;
                if (!MySpool(pdevobj, psb, &jTemp, 1))
                    return FALSE;
                if (!MySpool(pdevobj, psb, &pSoc->iPrv, 1))
                    return FALSE;
                pSoc->iRCnt = 0;
            }

            pSoc->pjNRBuf[pSoc->iNRCnt++] = jCur;

            if (NRPEAK == pSoc->iNRCnt) {
                jTemp = ((BYTE)pSoc->iNRCnt) - 1;
                if (!MySpool(pdevobj, psb, &jTemp, 1))
                    return FALSE;
                if (!MySpool(pdevobj, psb, pSoc->pjNRBuf, pSoc->iNRCnt))
                    return FALSE;
                pSoc->iNRCnt = 0;
            }
        }
        pSoc->iPrv = jCur;
    }

    return TRUE;
}

/*++

Routine Name

    ImpersonationToken

Routine Description:

    This routine checks if a token is a primary token or an impersonation 
    token.    
    
Arguments:

    hToken - impersonation token or primary token of the process
    
Return Value:

    TRUE, if the token is an impersonation token
    FALSE, otherwise.
    
--*/
BOOL
ImpersonationToken(
    IN HANDLE hToken
    )
{
    BOOL       bRet = TRUE;
    TOKEN_TYPE eTokenType;
    DWORD      cbNeeded;
    DWORD      LastError;

    //
    // Preserve the last error. Some callers of ImpersonatePrinterClient (which
    // calls ImpersonationToken) rely on the fact that ImpersonatePrinterClient
    // does not alter the last error.
    //
    LastError = GetLastError();
        
    //
    // Get the token type from the thread token.  The token comes 
    // from RevertToPrinterSelf. An impersonation token cannot be 
    // queried, because RevertToPRinterSelf doesn't open it with 
    // TOKEN_QUERY access. That's why we assume that hToken is
    // an impersonation token by default
    //
    if (GetTokenInformation(hToken,
                            TokenType,
                            &eTokenType,
                            sizeof(eTokenType),
                            &cbNeeded))
    {
        bRet = eTokenType == TokenImpersonation;
    }        
    
    SetLastError(LastError);

    return bRet;
}

/*++

Routine Name

    RevertToPrinterSelf

Routine Description:

    This routine will revert to the local system. It returns the token that
    ImpersonatePrinterClient then uses to imersonate the client again. If the
    current thread doesn't impersonate, then the function merely returns the
    primary token of the process. (instead of returning NULL) Thus we honor
    a request for reverting to printer self, even if the thread is not impersonating.
    
Arguments:

    None.
    
Return Value:

    NULL, if the function failed
    HANDLE to token, otherwise.
    
--*/
HANDLE
RevertToPrinterSelf(
    VOID
    )
{
    HANDLE   NewToken, OldToken, cToken;
    BOOL	 Status;

    NewToken = NULL;

    Status = OpenThreadToken(GetCurrentThread(),
							 TOKEN_IMPERSONATE,
							 TRUE,
							 &OldToken);
    if (Status) 
    {
        //
        // We are currently impersonating
        //
		cToken = GetCurrentThread();
        Status = SetThreadToken(&cToken,
								NewToken);       
		if (!Status) {
			return NULL;
		}
    }
	else if (GetLastError() == ERROR_NO_TOKEN)
    {
        //
        // We are not impersonating
        //
        Status = OpenProcessToken(GetCurrentProcess(),
								  TOKEN_QUERY,
								  &OldToken);

		if (!Status) {
			return NULL;
		}
    }
    
    return OldToken;
}

/*++

Routine Name

    ImpersonatePrinterClient

Routine Description:

    This routine attempts to set the passed in hToken as the token for the
    current thread. If hToken is not an impersonation token, then the routine
    will simply close the token.
    
Arguments:

    hToken - impersonation token or primary token of the process
    
Return Value:

    TRUE, if the function succeeds in setting hToken
    FALSE, otherwise.
    
--*/
BOOL
ImpersonatePrinterClient(
    HANDLE  hToken)
{
    BOOL	Status;
	HANDLE	cToken;

    //
    // Check if we have an impersonation token
    //
    if (ImpersonationToken(hToken)) 
    {
		cToken = GetCurrentThread();
        Status = SetThreadToken(&cToken,
								hToken);       

        if (!Status) 
        {
            return FALSE;
        }
    }

    CloseHandle(hToken);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ib87wres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

// NOTICE-2002/3/18-takashim
//     04/07/97 -zhanw-
//         Created it.

--*/

#include "pdev.h"
#include <strsafe.h>

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

BOOL APIENTRY 
OEMGetInfo(
    DWORD dwInfo,
    PVOID pBuffer,
    DWORD cbSize,
    PDWORD pcbNeeded)
{
#if DBG
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\r\n", OEM_INFO[dwInfo]));
#endif // DBG

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DBGPRINT(DBG_WARNING, 
                    (ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
            *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote DWORD bytes.
    *pcbNeeded = sizeof(DWORD);

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (sizeof(DWORD) > cbSize) )
    {
        DBGPRINT(DBG_WARNING, 
                (ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ib87wres\name.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

CONST CHAR pstrCommandCallback[]    = "CommandCallback";
CONST CHAR pstrDevMode[]            = "DevMode";
CONST CHAR pstrDisablePDEV[]        = "DisablePDEV";
CONST CHAR pstrEnablePDEV[]         = "EnablePDEV";
CONST CHAR pstrFilterGraphics[]     = "FilterGraphics";
CONST CHAR pstrGetInfo[]            = "GetInfo";

#define MAX_METHODNAME  16 // include terminating 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ib87wres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#include "pdev.h"
#include "name.h"

#include <initguid.h>
#include <prcomoem.h>
#include <strsafe.h>

// Globals
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"

////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));

    if (NULL == ppv)
    {
        return E_NOINTERFACE;
    }

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver will be
    // called for cleanup.
    return S_OK;
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));

    if (NULL == pIUnknown)
    {
        return E_FAIL;
    }

// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
    if (NULL == pDevOem)
    {
        return E_FAIL;
    }

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    BOOL bReturn;

    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));
    VERBOSE((DLLTEXT("        Function:%s:"), pMethodName));

    bReturn = FALSE;

    if (!SUCCEEDED(StringCchLengthA(
            pMethodName, MAX_METHODNAME, NULL)))
    {
        VERBOSE(("Not supported (1)\n"));
        return E_NOTIMPL;
    }

    switch (*pMethodName)
    {
    case (WCHAR)'C':
        if (!strcmp(pstrCommandCallback, pMethodName))
            bReturn = TRUE;
        break;

    case (WCHAR)'D':
        if (!strcmp(pstrDisablePDEV, pMethodName))
            bReturn = TRUE;

        if (!strcmp(pstrDevMode, pMethodName))
            bReturn = TRUE;
        break;

    case (WCHAR)'E':
        if (!strcmp(pstrEnablePDEV, pMethodName))
            bReturn = TRUE;
        break;

    case (WCHAR)'F':
        if (!strcmp(pstrFilterGraphics, pMethodName))
            bReturn = TRUE;
        break;

    case (WCHAR)'G':
        if (!strcmp(pstrGetInfo, pMethodName))
            bReturn = TRUE;
        break;
    }

    if (bReturn)
    {
        VERBOSE(("Supported\n"));
        return S_OK;
    }
    else
    {
        VERBOSE(("Not supported (2)\n"));
        return E_NOTIMPL;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
    if (NULL == piResult)
        return E_FAIL;

    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

// #94193: shold create temp. file on spooler directory.
    if (*piResult < 0)
        return E_FAIL;

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if(OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if (NULL == ppv)
    {
        return E_NOINTERFACE;
    }

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL; 
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE((DLLTEXT("Class factory:\t\tCreate component.")));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ib87wres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ib87wres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\ibm\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=ib87wres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),ib87wres
!else
DLLBASE=0x8000000
!endif

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\ib87wres.rc \
    $(SRCDIR)\common.c \
    $(SRCDIR)\ib87wres.c

MISCFILES=\
    $(SRCDIR)\ib87wres.ini \
    $(GPDDIR)\ib5587wj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\name.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

// NOTICE-2002/3/18-v-sueyas-
//     04/07/97 -zhanw-
//         Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        WARNING(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        WARNING(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        WARNING(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        WARNING(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            WARNING(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    return TRUE;
}

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
#if DBG
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        INT iTemp = giDebugLevel;

        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));

        giDebugLevel = iTemp;
    }
#endif // DBG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

// NTRAID#NTBUG9-588578-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods


#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == ppv)
        return E_NOINTERFACE;

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pDevOem)
        return E_FAIL;

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));
    VERBOSE((DLLTEXT("        Function:%s:"),pMethodName));

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;

                if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'I':
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'M':
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        VERBOSE(("Supported\n"));
        return S_OK;
    }
    else
    {
        VERBOSE(("NOT supported\n"));
        return E_FAIL;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if(OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));


    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));


    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));


    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
	LONG rc = E_FAIL;
    if( myOEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph) )
		rc = S_OK;
    return rc;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
	LONG rc = E_FAIL;
    if( myOEMSendFontCmd(pdevobj, pUFObj, pFInv) )
	    rc = S_OK;
	return rc;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == ppv)
        return E_NOINTERFACE;

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE((DLLTEXT("Class factory:\t\tCreate component.")));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//



//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ib87wres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#ifdef USERMODE_DRIVER
#ifdef DbgBreakPoint
#undef DbgBreakPoint
extern VOID DbgBreakPoint(VOID);
#endif // DbgBreakPoint
#endif // USERMODE_DRIVER

#include <printoem.h>
#include <prntfont.h>
#include <winsplp.h> // #94193: shold create temp. file on spooler directory.

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

// OEM Signature and version.
#define OEM_SIGNATURE   'IBMW'
#define DLLTEXT(s)      "IB87WRES: " s
#define OEM_VERSION      0x00010000L

/*************  Value   **************/

#define PAPER_SRC_FTRAY                 20
#define PAPER_SRC_CAS1                  21
#define PAPER_SRC_CAS2                  22
#define PAPER_SRC_CAS3                  23
#define PAPER_SRC_AUTO                  24

#define ORIENTATION_PORTRAIT			28
#define ORIENTATION_LANDSCAPE			29

#define PAGECONTROL_BEGIN_DOC           30
#define PAGECONTROL_BEGIN_PAGE          31
#define PAGECONTROL_END_DOC             32
#define PAGECONTROL_END_PAGE            33
#define PAGECONTROL_DUPLEX_OFF          34
#define PAGECONTROL_ABORT_DOC           35
#define PAGECONTROL_POTRAIT             36
#define PAGECONTROL_LANDSCAPE           37
#define PAGECONTROL_MULTI_COPIES        38

#define PHYS_PAPER_BASE                 50
#define PHYS_PAPER_A3                   50
#define PHYS_PAPER_A4                   51
#define PHYS_PAPER_A5                   52
#define PHYS_PAPER_B4                   53
#define PHYS_PAPER_B5                   54
#define PHYS_PAPER_POSTCARD             55
#define PHYS_PAPER_LETTER               56
#define PHYS_PAPER_LEGAL                57
#define PHYS_PAPER_UNFIXED              58
#define PHYS_PAPER_MAX                  58

#define Y_REL_MOVE                      71

#define RESOLUTION_300                  76
#define RESOLUTION_600                  77
#define SEND_BLOCK_DATA                 82

#define TONER_SAVE_MEDIUM               100
#define TONER_SAVE_DARK                 101
#define TONER_SAVE_LIGHT                102

#define MAXIMGSIZE                      0xF000
#define NRPEAK                          0x7F
#define RPEAK                           0x80
#define MASTERUNIT						1200
#define MAXLINESIZE 				   11817

#define TEMP_NAME_PREFIX __TEXT("~IB")

#define TRANS_BAND_Y_SIZE 1024
#define SPOOL_OUT_BUF_SIZE 1024

/*************  Structure   **************/
typedef struct tag_PAGEDATA{
	SHORT	sPageNum ;
	HANDLE	hPageFile ;
	TCHAR   TempName[MAX_PATH];
	DWORD	dwPageLen ;	//Page length of one page in byte.
	DWORD	dwFilePos ;	//Start Position for reading file.
	LPVOID	pPrePage ;
	LPVOID	pNextPage ;
}PAGEDATA, *LPPD ;

typedef struct SPLBUF {
	DWORD	dwWrite ;
	DWORD	dwPageLen ;
	HANDLE	hFile ;
	TCHAR   TempName[MAX_PATH];
}SPLBUF, *LPSB ;

// Status paramters for SpoolOutComp routine.
typedef struct {
    INT iNRCnt;
    INT iRCnt;
    BYTE iPrv;
    BYTE pjNRBuf[NRPEAK];
} SOCOMP, *PSOCOMP;

typedef struct tag_IBMPDEV {
    ULONG   ulHorzRes;
    ULONG   ulVertRes;

    SIZEL   szlPhysSize;
	POINTL  ptlLogSize;
    POINTL  ptlPhysOffset;

    WORD    wImgWidth;
    WORD    wImgHeight;

    BYTE    byPaperSize ;

	SHORT   sPageNum;
	SHORT   sCopyNum;
	
	DWORD   dwYmove ;
	DWORD	dwCurCursorY ;
	DWORD	dwOffset ;
	
	DWORD	wCompLen ;
	SHORT   sPaperSize ;

	BOOL	fComp ;
	BOOL	fChangeDirection ;

	SPLBUF  sb ;		//to count bytes
	SPLBUF  sbcomp ;	//to change direstions

	PBYTE   pTempImage ;
	DWORD   dwTempBufLen ;

	LPPD	lpFstData ;
	LPPD	lpCurData ;
	
	BOOL	fDocCmd ;

#define CMD_SETPAC_SIZE     31
    BYTE SetPac[CMD_SETPAC_SIZE]; // DefineSession + SETPAC

    SOCOMP Soc;

} IBMPDEV, *PIBMPDEV;

/*************  Macro   **************/
// #94193: shold create temp. file on spooler directory.
#define WRITESPOOLBUF(p, s, n) \
    (((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n)) == (n))

#define PARAM(p,n) \
    (NULL == (p) ? 0 : *((p)+(n)))

#define ABS(n) \
    ((n) > 0 ? (n) : -(n))

#endif  //_PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\kpdlres.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

#include "pdev.h"

#define SHIFTJIS_CHARSET  128
#define CCHMAXCMDLEN      128

#include <stdio.h>

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

#define ABS(n) \
    ((n) > 0 ? (n) : -(n))

#define SWAPW(x)    (((WORD)(x)<<8) | ((WORD)(x)>>8))

#define FLAG_SBCS  1
#define FLAG_DBCS  2

WORD SJis2JisNPDL(
WORD usCode)
{

    union {
        USHORT bBuffer;
        struct tags{
            UCHAR al;
            UCHAR ah;
        } s;
    } u;

    // Replace code values which cannot be mapped into 0x2121 - 0x7e7e
    // (94 x 94 cahracter plane) with Japanese defult character, which
    // is KATAKANA MIDDLE DOT.

    if (usCode >= 0xf040) {
        usCode = 0x8145;
    }

    u.bBuffer = usCode;

    u.s.al -= u.s.al >= 0x80 ;
    u.s.al -= 0x1F ;
    u.s.ah &= 0xBF ;
    u.s.ah <<= 1 ;
    u.s.ah += 0x21-0x02 ;

    if (u.s.al > 0x7E )
    {
        u.s.al -= (0x7F-0x21) ;
        u.s.ah++;
    }
     return (u.bBuffer);
}

// In case it is a single byte font, we will some of the characters
// (e.g. Yen-mark) to the actual printer font codepoint.  Note since
// the GPC data sets 0 to default CTT ID value, single byte codes
// are in codepage 1252 (Latin1) values.

WORD
Ltn1ToAnk(
   WORD wCode )
{
    // Not a good mapping table now.

    switch ( wCode ) {
    case 0xa5: // YEN MARK
        wCode = 0x5c;
        break;
    default:
        if ( wCode >= 0x7f)
            wCode = 0xa5;
    }

    return wCode;
}

//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA_FillZero
//
//  Description:  Convert from numeral into a character and
//                fill a field which was specified with 0
//-----------------------------------------------------------------------------
static int
iDwtoA_FillZero(PBYTE buf, long n, int fw)
{
    int  i , j, k, l;

    l = n;  // for later

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    for( k = 0; l; k++ ) {
        l /= 10;
    }
    if( k < 1) k++;

    k = fw - k;
    if(k > 0){;
        for (j = i; 0 < j + 1; j--){
            buf[j + k] = buf[j];
        }
        for ( j = 0; j < k; j++){
            buf[j] = '0';
        }
        i = i + k;
    }

    return i;
}


VOID
InitMyData(PMYDATA pnp)
{
    pnp->wRes = 300;
    pnp->wCopies = 1;
    pnp->sSBCSX = pnp->sDBCSX = pnp->sSBCSXMove =
    pnp->sSBCSYMove = pnp->sDBCSXMove = pnp->sDBCSYMove = 0;
    pnp->sEscapement = 0;
    pnp->fVertFont = FALSE;
    pnp->jAddrMode = ADDR_MODE_NONE;
    pnp->wOldFontID = 0;
    pnp->fPlus = FALSE;
    pnp->wScale = 1;
    pnp->lPointsx =
    pnp->lPointsy = 0;
    pnp->CursorX =
    pnp->CursorY = 0;
    pnp->jColorMode = MONOCHROME;
}


PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ pdevobj,
    PWSTR pPrinterName,
    ULONG cPatterns,
    HSURF *phsurfPatterns,
    ULONG cjGdiInfo,
    GDIINFO* pGdiInfo,
    ULONG cjDevInfo,
    DEVINFO* pDevInfo,
    DRVENABLEDATA *pded)
{
    PMYDATA pTemp;

    VERBOSE((DLLTEXT("OEMEnablePDEV() entry.\n")));

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("Invalid parameter(s).\n"));
        return NULL;
    }

    // Allocate minidriver private PDEV block.

    pTemp = (PMYDATA)MemAllocZ(sizeof(MYDATA));
    if (NULL == pTemp) {
        ERR(("Memory allocation failure.\n"));
        return NULL;
    }
    InitMyData(pTemp);

    MINIDEV_DATA(pdevobj) = (PVOID)pTemp;

    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    VERBOSE((DLLTEXT("OEMDisablePDEV() entry.\n")));

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("Invalid parameter(s).\n"));
        return;
    }

    if ( NULL != pdevobj->pdevOEM ) {

        PMYDATA pnp = (PMYDATA)MINIDEV_DATA(pdevobj);

        if (NULL != pnp) {
            if (NULL != pnp->pTempBuf) {
                MemFree(pnp->pTempBuf);
            }
            MemFree( pnp );
            MINIDEV_DATA(pdevobj) = NULL;
        }
    }

}


BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew )
{
    PMYDATA pTempOld, pTempNew;

    VERBOSE((DLLTEXT("OEMResetPDEV entry.\n")));

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobjOld || NULL == pdevobjNew)
    {
        ERR(("Invalid parameter(s).\n"));
        return FALSE;
    }

    // Do some verificatin on PDEV data passed in.

    pTempOld = (PMYDATA)MINIDEV_DATA(pdevobjOld);
    pTempNew = (PMYDATA)MINIDEV_DATA(pdevobjNew);

    // Copy mindiriver specific part of PDEV

    if (NULL != pTempNew && NULL != pTempOld) {
        if (NULL != pTempNew->pTempBuf) {
            MemFree(pTempNew->pTempBuf);
        }
        *pTempNew = *pTempOld;
        pTempOld->pTempBuf = NULL;
        pTempOld->dwTempBufLen = 0;
    }

    return TRUE;
}


/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMFilterGraphics                                             */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL APIENTRY OEMFilterGraphics(PDEVOBJ, PBYTE, DWORD)        */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pBuf        points to buffer of graphics data                 */
/*             dwLen       length of buffer in bytes                         */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:    nFunction and Escape numbers are the same                     */
/*                                                                           */
/*****************************************************************************/
BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    PMYDATA pnp;
    DWORD i;
    PBYTE pTop, pBot, pTmp;
    DWORD dwBlockX;

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj || NULL == pBuf || 0 == dwLen)
    {
        ERR(("OEMFilterGraphics: Invalid parameter(s).\n"));
        return FALSE;
    }

    pnp = (PMYDATA)MINIDEV_DATA(pdevobj);

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pnp)
    {
        ERR(("OEMFilterGraphics: pdevOEM = 0.\n"));
        return FALSE;
    }

    if (IsColorPlanar(pnp)) {
        WRITESPOOLBUF(pdevobj, pBuf, dwLen);
        // #308001: Garbage appear on device font
        WRITESPOOLBUF(pdevobj, "\x1C!o.", 4);   // end ROP mode
        return TRUE;
    }

    if (IsColorTrueColor(pnp)) {

        // 24bpp color mode:
        // Change byt order from RGB to BGR, which
        // this printer can accept.

        pTop = pBuf;
        for (i = 0; i < dwLen; pTop += 3, i += 3)
        {
            BYTE jTmp;

            jTmp = *pTop;
            *pTop = *(pTop + 2);
            *(pTop + 2) = jTmp;
        }

        if (pnp->dwTempBufLen < pnp->dwTempDataLen + dwLen) {
            ERR(("Internal buffer overflow.\n"));
            return FALSE;
        }
        memcpy(pnp->pTempBuf + pnp->dwTempDataLen, pBuf, dwLen);
        pnp->dwTempDataLen += dwLen;

        if (pnp->dwTempDataLen < pnp->dwBlockLen) {
            // Not all the data has been saved.
            return TRUE;
        }

        // Now send out the block.
        // Need to send the last row first.
        // We have Y + 1 rows of the bufferes and the
        // last row is used as working buffer.

        dwBlockX = pnp->dwBlockX;
        pTop = pnp->pTempBuf;
        pBot = pTop + pnp->dwBlockLen - dwBlockX;
        pTmp = pTop + pnp->dwBlockLen;
		if(pnp->dwBlockLen+sizeof(dwBlockX)>pnp->dwTempBufLen) {
			ERR(("Internal buffer overflow.\n"));
			return FALSE;
		}
        for (i = 0; i < pnp->dwBlockY / 2; i++) {
            memcpy(pTmp, pTop, dwBlockX);
            memcpy(pTop, pBot, dwBlockX);
            memcpy(pBot, pTmp, dwBlockX);
            pTop += dwBlockX;
            pBot -= dwBlockX;
        }
        WRITESPOOLBUF(pdevobj, pnp->pTempBuf,
            pnp->dwTempDataLen);
        pnp->dwTempDataLen = 0;
        return TRUE;
    }

    // Others, should not happen.
    WARNING(("Unknown color mode, cannot handle\n"));
    return FALSE;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMSendFontCmd                                                */
/*                                                                           */
/*  Function:  send font selection command.                                  */
/*                                                                           */
/*  Syntax:    VOID APIENTRY OEMSendFontCmd(                                 */
/*                                    PDEVOBJ, PUNIFONTOBJ, PFINVOCATION)    */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj      address of UNIFONTOBJ structure                   */
/*             pFInv       address of FINVOCATION                            */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/

BOOL
myOEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv )
{
    BYTE                i;
    long                tmpPointsx, tmpPointsy;
    PBYTE               pcmd;
    BYTE                rgcmd[CCHMAXCMDLEN];    // build command here
	// NTRAID#NTBUG9-579199-2002/03/20-v-sueyas-: Initialize un-initialized valiable
    BOOL                fDBCS = TRUE;
    DWORD               dwStdVariable[2 + 2 * 2];
    PGETINFO_STDVAR pSV;
	PBYTE	pch = rgcmd;
	size_t	rem = sizeof rgcmd;
    PMYDATA pnp;

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("myOEMSendFontCmd: Invalid parameter(s).\n"));
        return FALSE;
    }

    pnp = (PMYDATA)MINIDEV_DATA(pdevobj);

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pnp)
    {
        ERR(("myOEMSendFontCmd: pdevOEM = 0.\n"));
        return FALSE;
    }

    if(!pUFObj || !pFInv)
        return FALSE;

    if(!pFInv->pubCommand || !pFInv->dwCount)
    {
        ERR(("Command string is NULL.\n"));
        return FALSE;
    }

    pSV = (PGETINFO_STDVAR)dwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * (3-1) * sizeof(DWORD);
    pSV->dwNumOfVariable = 3;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_FONTMAXWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
                                                            pSV->dwSize, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return FALSE;
    }

	// NTRAID#NTBUG9-579199-2002/03/18-v-sueyas-: Check for deviding by zero
    if (0 == pnp->wRes)
    {
        ERR(("myOEMSendFontCmd: pnp->wRes = 0.\n"));
        return FALSE;
    }

    tmpPointsy = (long)pSV->StdVar[0].lStdVariable * 720 / (long)pnp->wRes;
    i = 0;
    pcmd = pFInv->pubCommand;

    while(pcmd[i] !='#')
    {
		if(rem==0) return FALSE;
		*pch++ = pcmd[i++];
		rem--;
    }

    i++;
    pnp->fVertFont = pnp->fPlus = FALSE;

    switch(pcmd[i])
    {
        case 'R':
            pnp->fPlus = TRUE;
            tmpPointsx = (long)pSV->StdVar[1].lStdVariable * 1200 /
                                                            (long)pnp->wRes;
            break;

        case 'P':
            fDBCS = FALSE;
            tmpPointsx = ((long)pSV->StdVar[1].lStdVariable * 1200 + 600) /
                         (long)pnp->wRes;
            break;

        case 'W':
            pnp->fVertFont = TRUE;
        case 'Q':
            fDBCS = TRUE;
            tmpPointsx = (long)pSV->StdVar[1].lStdVariable * 1440 /
                                                            (long)pnp->wRes;
            break;

        case 'Y':
            pnp->fVertFont = TRUE;

        case 'S':
            pnp->fPlus = TRUE;
            tmpPointsx = (long)pSV->StdVar[1].lStdVariable * 1440 /
                                                            (long)pnp->wRes;
            break;
    }

    if(pnp->fPlus)
    {
        if(tmpPointsy > 9999)
            tmpPointsy = 9999;
        else if(tmpPointsy < 10)
            tmpPointsy = 10;
        if(tmpPointsx > 9999)
            tmpPointsx = 9999;
        else if(tmpPointsx < 10)
            tmpPointsx = 10;

        pnp->wScale = tmpPointsx == tmpPointsy;
        pnp->lPointsx = tmpPointsx;
        pnp->lPointsy = tmpPointsy;

        if(pnp->fVertFont)
        {
            if(pnp->wScale)
            {
// ISSUE-2002/03/11-hiroi- This original line overwrites rgcmd[ocmd]. I don't know how this line should be here.
// Must revisit here later
//              rgcmd[ocmd] = '\034';
//              ocmd += (SHORT)wsprintf(&rgcmd[ocmd], "12S2-");
				*pch = '\034';
				if (FAILED(StringCchPrintfExA(pch, rem, &pch, &rem, 0, 
							"12S2-")))
 					return 0;
				if( rem > 4+1+4 ) { // check to see if the remaining buffer size > 4+1+4
	                pch += (SHORT)iDwtoA_FillZero(pch, tmpPointsx, 4);
		            *pch++ = '-';
        	        pch += (SHORT)iDwtoA_FillZero(pch, tmpPointsy, 4);
				} else
					return FALSE;
            }
        } else {
			if( rem > 4+1+4 ) { // check to see if the remaining buffer size > 4+1+4
	            pch += (SHORT)iDwtoA_FillZero(pch, tmpPointsx, 4);
    	        *pch++ = '-';
        	    pch += (SHORT)iDwtoA_FillZero(pch, tmpPointsy, 4);
			} else
				return FALSE;
        }
        goto SEND_COM;
    }
    pnp->wScale = 1;

    if(tmpPointsy > 9999)
    {
        tmpPointsy = 9999;
        goto MAKE_COM;
    }

    if(tmpPointsy < 10)
    {
        tmpPointsy = 10;
        goto MAKE_COM;
    }
    pnp->wScale = (int)(tmpPointsx / tmpPointsy);

    if(pnp->wScale > 8)
        pnp->wScale = 8;

MAKE_COM:
	if( rem > 4 ) { // check to see if the remaining buffer size > 4
	    pch += (SHORT)iDwtoA_FillZero(pch, tmpPointsy, 4);
	} else
		return FALSE;
SEND_COM:
    // write spool builded command
    WRITESPOOLBUF(pdevobj, rgcmd, (DWORD)(pch-rgcmd));

    i++;
	pch = rgcmd;
	rem = sizeof rgcmd;
    while(pcmd[i] !='#')
    {
		if( rem == 0 ) return FALSE;
		*pch++ = pcmd[i++];
		rem--;
    }

	if( rem > 4+1+4+1 ) { //check to see if the remaining buffer size > 4+1+4+1
	    pch += (SHORT)iDwtoA_FillZero(pch, (fDBCS ?
    	       pSV->StdVar[1].lStdVariable * 2 : pSV->StdVar[1].lStdVariable), 4);
	    *pch++ = ',';
    	pch += (SHORT)iDwtoA_FillZero(pch, pSV->StdVar[0].lStdVariable, 4);
	    *pch++ = '.';
	} else
		return FALSE;

    WRITESPOOLBUF(pdevobj, rgcmd, (DWORD)(pch-rgcmd));

    // save for FS_SINGLE_BYTE and FS_DOUBLE_BYTE
    pnp->sSBCSX = pnp->sSBCSXMove = (short)pSV->StdVar[1].lStdVariable;
    pnp->sDBCSX = pnp->sDBCSXMove = (short)(pSV->StdVar[1].lStdVariable << 1);

    // Reset address mode values.
    pnp->sSBCSYMove = pnp->sDBCSYMove = 0;
    pnp->jAddrMode = ADDR_MODE_NONE;
	return TRUE;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMCommandCallback                                            */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    INT APIENTRY OEMCommandCallback(PDEVOBJ,DWORD,DWORD,PDWORD)   */
/*                                                                           */
/*  Input:     pdevobj                                                       */
/*             ddwCmdCbID                                                    */
/*             dwCount                                                       */
/*             pdwParams                                                     */
/*                                                                           */
/*  Output:    INT                                                           */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbID,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams ) // points to values of command params
{
    BYTE                ch[CCHMAXCMDLEN];
	WORD                wCmdLen = 0;
	PBYTE				pch = ch;
	size_t 				rem = sizeof ch;
    PMYDATA 			pnp;

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("OEMCommandCallback: Invalid parameter(s).\n"));
        return 0;
    }

    pnp = (PMYDATA)MINIDEV_DATA(pdevobj);

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pnp)
    {
        ERR(("OEMCommandCallback: pdevOEM = 0.\n"));
        return 0;
    }

    switch(dwCmdCbID)
    {
    case MONOCHROME:
        pnp->jColorMode = (BYTE)dwCmdCbID;
        // OR mode
        WRITESPOOLBUF(pdevobj, "\x1C\"O.", 4);
        break;

    case COLOR_3PLANE:
    case COLOR_24BPP_2:
    case COLOR_24BPP_4:
    case COLOR_24BPP_8:

        pnp->jColorMode = (BYTE)dwCmdCbID;
        // Replace mode
        WRITESPOOLBUF(pdevobj, "\x1C\"R.", 4);
        break;

    case RES_300:
        pnp->wRes = 300;
        WRITESPOOLBUF(pdevobj, "\x1CYSU1,300,0;\x1CZ", 14);
        WRITESPOOLBUF(pdevobj, "\x1C<1/300,i.", 10);
        break;

    case RES_SENDBLOCK:
        {
            DWORD dwCursorX, dwCursorY;

			// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
            if (dwCount < 1 || !pdwParams)
                return 0;

            pnp->dwBlockLen = PARAM(pdwParams, 0);
            pnp->dwBlockX = PARAM(pdwParams, 1);
            pnp->dwBlockY = PARAM(pdwParams, 2);
            dwCursorX = PARAM(pdwParams, 3);
            dwCursorY = PARAM(pdwParams, 4);

            if (IsColorPlanar(pnp))
            {
                //NTRAID#355334: no need send cursor command. 
                // Send cursor move command using saved parameters
                //wlen = (WORD)wsprintf(ch, FS_E, dwCursorX, dwCursorY);
                //WRITESPOOLBUF(pdevobj, ch, wlen);

                //NTRAID#308001: Garbage appear on device font
                // Send color command for each sendblocks.
                switch (pnp->jCurrentPlane) {
                case PLANE_CYAN:
					if (FAILED(StringCchPrintfExA(pch, rem, &pch, &rem, 0, 
 									"\x1C!s0,,,,,,.\x1C!o4,204,3.")))
	 					return 0;
                    break;
                case PLANE_MAGENTA:
					if (FAILED(StringCchPrintfExA(pch, rem, &pch, &rem, 0, 
 									"\x1C!s0,,,,,,.\x1C!o4,204,2.")))
	 					return 0;
                    break;
                case PLANE_YELLOW:
					if (FAILED(StringCchPrintfExA(pch, rem, &pch, &rem, 0, 
 									"\x1C!s0,,,,,,.\x1C!o4,204,1.")))
	 					return 0;
                    break;
                }
					if (FAILED(StringCchPrintfExA(pch, rem, &pch, &rem, 0, 
 								"\034R\034i%d,%d,0,1/1,1/1,%d,300.",
									(pnp->dwBlockX * 8), pnp->dwBlockY,
									pnp->dwBlockLen )))
	 					return 0;
                WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));
                pnp->jAddrMode = ADDR_MODE_NONE;
            }
            else if (IsColorTrueColor(pnp)) {

                DWORD dwNewBufLen;
                INT iDepth;

                // Allocate working buffer. We allocate Y + 1 rows
                // to save the block data passed from the Unidrv.
                // See the OEMFilterGraphics() code for the details.

                VERBOSE(("sb - l,x,y=%d,%d,%d, t=%d\n",
                    pnp->dwBlockLen, pnp->dwBlockX, pnp->dwBlockY,
                    pnp->dwTempBufLen));

                dwNewBufLen = pnp->dwBlockLen + pnp->dwBlockX;

                if (pnp->dwTempBufLen < dwNewBufLen) {
                    if (NULL != pnp->pTempBuf) {

                        VERBOSE(("sb - realloc\n"));

                        MemFree(pnp->pTempBuf);
                        pnp->pTempBuf = NULL;
                    }
                }
                if (NULL == pnp->pTempBuf) {
                    pnp->pTempBuf = MemAlloc(dwNewBufLen);
                    if (NULL == pnp->pTempBuf) {
                        ERR(("Faild to allocate temp. buffer\n"));
                        return 0;
                    }
                    pnp->dwTempBufLen = dwNewBufLen;
                    pnp->dwTempDataLen = 0;
                }

                // Construct printer command
                // This printer wants left-bottom corner's coordinate
                // for the parameter.

                iDepth = ColorOutDepth(pnp);
				if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, 
						"\034!E%d,%d,%d,%d,%d,%d,%d,%d.",
						iDepth, dwCursorX, (dwCursorY + pnp->dwBlockY - 1),
						(pnp->dwBlockX / 3), pnp->dwBlockY,
						(pnp->dwBlockX / 3), pnp->dwBlockY,
						pnp->dwBlockLen)))
	 				return 0;

                WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));
            }
            else {
                ERR(("Unknown color mode, cannot handle.\n"));
            }
        }
        break;

        case PC_TYPE_F:
			if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, 
						ESC_RESET)))
				return 0;
            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));
            break;

        case PC_END_F:
			if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, 
						FS_RESO0_RESET)))
				return 0;
            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));
            break;

        case PC_ENDPAGE :
			if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, 
						FS_ENDPAGE, pnp->wCopies)))
				return 0;
            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));
            break;

        case PC_MULT_COPIES_N:
        case PC_MULT_COPIES_C:
            // FS_COPIES is neccesary for each page

			// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
            if (dwCount < 1 || !pdwParams)
                return 0;

            if(dwCmdCbID == PC_MULT_COPIES_C)
            {
// ISSUE-2002/03/11-hiroi- This original line overwrites rgcmd[ocmd]. I don't know how this line should be here.
// Must revisit here later
//                ch[wlen] = '\034';
//                wlen += (WORD)wsprintf(&ch[wlen], "05F2-02");
                ch[0] = '\034';
				if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, 
						"05F2-02")))
					return 0;
            }
            pnp->wCopies = (WORD)*pdwParams;
			if (FAILED(StringCchPrintfExA(pch, rem, &pch, &rem, 0, INIT_DOC, pnp->wRes, pnp->wRes)))
				return 0;
            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));
            break;

        case PC_PRN_DIRECTION:
            {
            short  sEsc, sEsc90;
            short  ESin[] = {0, 1, 0, -1};
            short  ECos[] = {1, 0, -1, 0};

			// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
            if (dwCount < 1 || !pdwParams)
                return 0;

            pnp->sEscapement = (short)*pdwParams % 360;
            sEsc = pnp->sEscapement;
            sEsc90 = pnp->sEscapement/90;

            pnp->sSBCSXMove = pnp->sSBCSX * ECos[sEsc90];
            pnp->sSBCSYMove = -pnp->sSBCSX * ESin[sEsc90];
            pnp->sDBCSXMove = pnp->sDBCSX * ECos[sEsc90];
            pnp->sDBCSYMove = -pnp->sDBCSX * ESin[sEsc90];
            }
            break;

    // *** Cursor Movement CM *** //

    case CM_X_ABS:
    case CM_Y_ABS:

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if (dwCount < 1 || !pdwParams)
        return 0;

    {
        INT iRet = (INT)PARAM(pdwParams, 0);

        if (CM_X_ABS == dwCmdCbID) {
            pnp->CursorX = iRet;
        }
        else if (CM_Y_ABS == dwCmdCbID){
            pnp->CursorY = iRet;
        }
		if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, FS_E, pnp->CursorX, pnp->CursorY)))
			return 0;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));

        return iRet;
    }

        case CM_CR:
            pnp->CursorX = 0;
            //NTRAID#355334: ensure CursorX=0 after CR
			if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, "\x0D\034e0,%d.", pnp->CursorY)))
				return 0;
            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));
            break;

        case CM_FF:
            pnp->CursorX = pnp->CursorY = 0;
            WRITESPOOLBUF(pdevobj, "\x0C", 1);
            break;

        case CM_LF:
            pnp->CursorX = 0;
            pnp->CursorY++;
            WRITESPOOLBUF(pdevobj, "\x0A", 1);
            break;

    // *** Font Simulation FS *** //
        case FS_DOUBLE_BYTE:

			if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, FS_ADDRMODE_ON, pnp->sDBCSXMove, pnp->sDBCSYMove)))
				return 0;
            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));

            if(pnp->fVertFont)
            {
                WRITESPOOLBUF(pdevobj, ESC_KANJITATE, 2);

                if(pnp->wScale == 1)
                    break;

                if(!pnp->fPlus)
                {
                    char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                     "4/1", "4/1", "6/1", "6/1", "8/1"};

					rem = sizeof ch;
					if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, 
							FS_M_T, (PBYTE)bcom[pnp->wScale])))
						return 0;
  		            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));
                    break;
                } else {
// ISSUE-2002/03/11-hiroi- This original line overwrites ch[wlen]. I don't know how this line should be here.
// Must revisit here later
//                    ch[wlen] = '\034';
//                    wlen += (WORD)wsprintf(&ch[wlen], "12S2-");
//                    wlen += (WORD)iDwtoA_FillZero(&ch[wlen], pnp->lPointsx, 4);
//                    ch[wlen++] = '-';
//                    wlen += (WORD)iDwtoA_FillZero(&ch[wlen], pnp->lPointsy, 4);
					*pch = '\034';
					if (FAILED(StringCchPrintfExA(pch, rem, &pch, &rem, 0, "12S2-")))
						return 0;
					if( rem > 4+1+4 ) { // check to see if the remaining buffer size > 4+1+4
						pch += (WORD)iDwtoA_FillZero(pch, pnp->lPointsx, 4);
						*pch++ = '-';
						pch += (WORD)iDwtoA_FillZero(pch, pnp->lPointsy, 4);
					} else
						return 0;
                }
	            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));
            }
            break;

        case FS_SINGLE_BYTE:

			if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, FS_ADDRMODE_ON, pnp->sSBCSXMove,pnp->sSBCSYMove)))
				return 0;
            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));

            if(pnp->fVertFont)
            {
                WRITESPOOLBUF(pdevobj, ESC_KANJIYOKO, 2);

                if(pnp->wScale == 1)
                    break;

                if(!pnp->fPlus)
                {
                    char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                     "4/1", "4/1", "6/1", "6/1", "8/1"};

					rem = sizeof ch;
					if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, FS_M_Y, (LPSTR)bcom[pnp->wScale])))
						return 0;
		            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));
                    break;
                } else {
// ISSUE-2002/03/11-hiroi- This original line overwrites ch[wlen]. I don't know how this line should be here.
// Must revisit here later
//                    ch[wlen] = '\034';
//                    wlen += (WORD)wsprintf(&ch[wlen], "12S2-");
//                    wlen += (WORD)iDwtoA_FillZero(&ch[wlen], pnp->lPointsx, 4);
//                    ch[wlen++] = '-';
//                    wlen += (WORD)iDwtoA_FillZero(&ch[wlen], pnp->lPointsy, 4);

                    *pch = '\034';
					if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, "12S2-")))
						return 0;
					if( rem > 4+1+4 ) { // check to see if the remaining buffer size > 4+1+4
	                    pch += (WORD)iDwtoA_FillZero(pch, pnp->lPointsx, 4);
    	                *pch++ = '-';
        	            pch += (WORD)iDwtoA_FillZero(pch, pnp->lPointsy, 4);
					} else
						return 0;
                }
	            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));
            }
            break;

    case CMD_RECT_WIDTH :

		// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
	    if (dwCount < 1 || !pdwParams)
	        return 0;

        pnp->dwRectX = PARAM(pdwParams, 0);
        break;

    case CMD_RECT_HEIGHT :

		// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
	    if (dwCount < 1 || !pdwParams)
	        return 0;

        pnp->dwRectY = PARAM(pdwParams, 0);
        break;

    case CMD_BLACK_FILL:
    case CMD_GRAY_FILL:
    case CMD_WHITE_FILL:

		// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
	    if (dwCount < 1 || !pdwParams)
	        return 0;

    {
        INT iGrayLevel;

        // Disable absolute addres mode, enter graphics.
        // Set fill mode.
		if (FAILED(StringCchPrintfExA(ch, rem, &pch, &rem, 0, "\034R\034YXX1;")))
			return 0;

        if (CMD_BLACK_FILL == dwCmdCbID) {
            iGrayLevel = 0;
        }
        else if (CMD_WHITE_FILL == dwCmdCbID) {
            iGrayLevel = 100;
        }
        else {
            // Gray fill.
            // 0 = Black, 100 = White
            iGrayLevel = (INT)(100 - (WORD)PARAM(pdwParams, 2));
        }

        // Select ray level.
		if (FAILED(StringCchPrintfExA(pch, rem, &pch, &rem, 0, "SG%d;", iGrayLevel)))
			return 0;

        // Move pen, fill rect.
		if (FAILED(StringCchPrintfExA(pch, rem, &pch, &rem, 0, "MA%d,%d;RR%d,%d;",
    	        (WORD)PARAM(pdwParams, 0),
        	    (WORD)PARAM(pdwParams, 1),
            	(pnp->dwRectX - 1), (pnp->dwRectY - 1))))
			return 0;

        // Disable fill mode.
        // Exit graphics.
		if (FAILED(StringCchPrintfExA(pch, rem, &pch, &rem, 0, "XX0;\034Z")))
			return 0;

        // Now send command linet to the printer.
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch-ch));

        // Reset some flags to indicate graphics mode
        // side effects.
        pnp->jAddrMode = ADDR_MODE_NONE;
        break;
    }

//NTRAID#308001: Garbage appear on device font
    case CMD_SENDCYAN:
        pnp->jCurrentPlane = PLANE_CYAN;
        break;

    case CMD_SENDMAGENTA:
        pnp->jCurrentPlane = PLANE_MAGENTA;
        break;

    case CMD_SENDYELLOW:
        pnp->jCurrentPlane = PLANE_YELLOW;
        break;

    default:
        WARNING(("Unknown command cllabck ID %d not handled.\n",
            dwCmdCbID))
        break;
    }
    return 0;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMOutputCharStr                                              */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    VOID APIENTRY OEMOutputCharStr(PDEVOBJ, PUNIFONTOBJ, DWORD,   */
/*                                                   DWORD, PVOID)           */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj                                                        */
/*             dwType                                                        */
/*             dwCount                                                       */
/*             pGlyph                                                        */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/

BOOL
myOEMOutputCharStr(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD dwType,
    DWORD dwCount,
    PVOID pGlyph )

{
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA          pTrans;
    WORD                wlen;
    WORD                i;
    WORD                wTmpChar;
    BYTE                ch[512];
    BOOL                fDBCSFont;
    WORD                wComLen;
	PBYTE				pTempBuf;
	PBYTE				pch = ch;
	DWORD				rem = sizeof ch;

    PMYDATA pnp;

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if(NULL == pdevobj || NULL == pUFObj)
    {
        ERR(("myOEMOutputCharStr: Invalid parameter(s).\n"));
        return FALSE;
    }

    pnp = (PMYDATA)MINIDEV_DATA(pdevobj);

	// NTRAID#NTBUG9-579197-2002/03/18-v-sueyas-: Check for illegal parameters
    if(NULL == pnp)
    {
        ERR(("myOEMOutputCharStr: pdevOEM = 0.\n"));
        return FALSE;
    }

    wlen = 0;

    switch(dwType)
    {
        case TYPE_GLYPHHANDLE:      // Device Font
        {
            if( pUFObj->ulFontID != pnp->wOldFontID )
            {
                pnp->jAddrMode = ADDR_MODE_NONE;
                pnp->wOldFontID = (WORD)pUFObj->ulFontID;
            }

            switch(pUFObj->ulFontID)
            {
                case 5: // Courier
                case 6: // Helv
                case 7: // TmsRmn
                case 8: // TmsRmn Italic
                    fDBCSFont = FALSE;
                    break;

                default:
                    fDBCSFont = TRUE;
                    break;
            }

//NTRAID#333653: Change I/F for GETINFO_GLYPHSTRING begin
            GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
            GStr.dwCount   = dwCount;
            GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
            GStr.pGlyphIn  = pGlyph;
            GStr.dwTypeOut = TYPE_TRANSDATA;
            GStr.pGlyphOut = NULL;
		    GStr.dwGlyphOutSize = 0;		/* new member of GETINFO_GLYPHSTRING */

			/* Get TRANSDATA buffer size */
            if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)
				 || !GStr.dwGlyphOutSize )
            {
                ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
                return FALSE;
            }

			/* Alloc TRANSDATA buffer */
			if(!(pTempBuf = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize)))
			{
				ERR(("Memory alloc failed.\n"));
				return FALSE;
			}
            pTrans = (PTRANSDATA)pTempBuf;

			/* Get actual TRANSDATA */
			GStr.pGlyphOut = pTrans;
			if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,	0, NULL))
			{
				ERR(("GetInfo failed.\n"));
		    	return FALSE;
			}
//NTRAID#333653: Change I/F for GETINFO_GLYPHSTRING end

//NTRAID#346241: SBCS pitch is widely.
            if(fDBCSFont &&
                (pTrans[0].ubType & MTYPE_FORMAT_MASK) == MTYPE_PAIRED &&
                pTrans[0].uCode.ubPairs[0])
            {
                if (ADDR_MODE_DBCS != pnp->jAddrMode)
                {
                    BYTE        cH[CCHMAXCMDLEN];
					PBYTE		pcH = cH;
					size_t		reM = sizeof cH;
					if (FAILED(StringCchPrintfExA(cH, reM, &pcH, &reM, 0, FS_ADDRMODE_ON, pnp->sDBCSXMove, pnp->sDBCSYMove)))
						return FALSE;
                    WRITESPOOLBUF(pdevobj, cH, (DWORD)(pcH-cH));
                    if(pnp->fVertFont)
                    {
                        WRITESPOOLBUF(pdevobj, ESC_KANJITATE, 2);

                        if(pnp->wScale != 1)
                        {
                            if(!pnp->fPlus)
                            {
                                char  *bcom[] = {"1/2","1/1","2/1","3/1",
                                             "4/1","4/1","6/1","6/1","8/1"};

								reM = sizeof cH;
								if (FAILED(StringCchPrintfExA(cH, reM, &pcH, &reM, 0, FS_M_T, (PBYTE)bcom[pnp->wScale])))
									return FALSE;
                            } else {
// ISSUE-2002/03/11-hiroi- This original line overwrites ch[wlen]. I don't know how this line should be here.
// Must revisit here later
//                                cH[wLen] = '\034';
//                                wLen += (WORD)wsprintf(&cH[wLen], "12S2-");
//                                wLen += (WORD)iDwtoA_FillZero(&cH[wLen],
//                                                            pnp->lPointsx, 4);
//                                cH[wLen++] = '-';
//                                wLen += (WORD)iDwtoA_FillZero(&cH[wLen],
//                                                            pnp->lPointsy, 4);
								*pcH  = '\034';
								if (FAILED(StringCchPrintfExA(pcH, reM, &pcH, &reM, 0, "12S2-")))
									return FALSE;
								if( reM > 4+1+4 ) { // check to see if the remaining buffer size > 4+1+4
									pcH += (WORD)iDwtoA_FillZero(pcH,pnp->lPointsx, 4);
    	                            *pcH++ = '-';
	                                pcH += (WORD)iDwtoA_FillZero(pcH,pnp->lPointsy, 4);
								} else
									return FALSE;
                            }
                            WRITESPOOLBUF(pdevobj, cH, (DWORD)(pcH-cH));
                        }
                    }
                    pnp->jAddrMode = ADDR_MODE_DBCS;
                }
            } else {
                if(ADDR_MODE_SBCS != pnp->jAddrMode)
                {
                    BYTE        cH[CCHMAXCMDLEN];
// NTRAID#NTBUG9-629397-2002/05/24-yasuho-: SBCS font can't printed.
					PBYTE		pcH = cH;
					size_t		reM = sizeof cH;

					if (FAILED(StringCchPrintfExA(cH, reM, &pcH, &reM, 0, FS_ADDRMODE_ON, pnp->sSBCSXMove, pnp->sSBCSYMove)))
						return FALSE;
                    WRITESPOOLBUF(pdevobj, cH, (DWORD)(pcH-cH));

                    if(pnp->fVertFont)
                    {
                        WRITESPOOLBUF(pdevobj, ESC_KANJIYOKO, 2);

                        if(pnp->wScale != 1)
                        {
                            if(!pnp->fPlus)
                            {
                                char  *bcom[] = {"1/2","1/1","2/1","3/1",
                                             "4/1","4/1","6/1","6/1","8/1"};

								reM = sizeof cH;
								if (FAILED(StringCchPrintfExA(cH, reM, &pcH, &reM, 0, FS_M_Y,(PBYTE)bcom[pnp->wScale])))
									return FALSE;
                            } else {
// ISSUE-2002/03/11-hiroi- This original line overwrites ch[wlen]. I don't know how this line should be here.
// Must revisit here later
//                                cH[wLen] = '\034';
//                                wLen += (WORD)wsprintf(&cH[wLen], "12S2-");
//                                wLen += (WORD)iDwtoA_FillZero(&cH[wLen],
//                                                            pnp->lPointsx, 4);
//                                cH[wLen++] = '-';
//                                wLen += (WORD)iDwtoA_FillZero(&cH[wLen],
//                                                            pnp->lPointsy, 4);
                                *pcH = '\034';
								if (FAILED(StringCchPrintfExA(pcH, reM, &pcH, &reM, 0,"12S2-")))
									return FALSE;
								if( reM > 4+1+4 ) { // check to see if the remaining buffer size > 4+1+4
	                                pcH += (WORD)iDwtoA_FillZero(pcH,pnp->lPointsx, 4);
    	                            *pcH++ = '-';
        	                        pcH += (WORD)iDwtoA_FillZero(pcH,pnp->lPointsy, 4);
								} else
									return FALSE;
                            }
                            WRITESPOOLBUF(pdevobj, cH, (DWORD)(pcH-cH));
                        }
                    }
                    pnp->jAddrMode = ADDR_MODE_SBCS;
                }
            }

            for(i = 0; i < dwCount; i++, pTrans++)
            {
                switch(pTrans->ubType & MTYPE_FORMAT_MASK)
                {
                    case MTYPE_PAIRED:
                        if(wlen+2<=sizeof ch)
							memcpy(((PBYTE)(ch + wlen)), pTrans->uCode.ubPairs, 2);
						else
							return FALSE;
                        wlen += 2;
                        break;

                    case MTYPE_DIRECT:
                        wTmpChar = (WORD)pTrans->uCode.ubCode;

                        if (!fDBCSFont)
                             wTmpChar = Ltn1ToAnk( wTmpChar );
                        if(wlen+2<=sizeof ch)
	                        *(PWORD)(ch + wlen) = SWAPW(wTmpChar);
						else
							return FALSE;
                        wlen += 2;
                        break;
                }
            }
            if(wlen)
                WRITESPOOLBUF(pdevobj, ch, wlen);

            break;
        }   // case TYPE_GLYPHHANDLE

        default:
            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

//----------------------------------------------------------------------------
// Filename:    pdev.h
// This file contains definitions for KPDL mini-driver
//-----------------------------------------------------------------------------
#ifndef _PDEV_H
#define _PDEV_H


#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
#include <strsafe.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'KPDL'
#define DLLTEXT(s)      "KPDL: " s
#define OEM_VERSION      0x00010000L

// kpdlres mini driver device data structure
typedef struct
{
    WORD            wRes;            // resolution 600 or 400 or 240
    WORD            wCopies;         // number of multi copies
    short           sSBCSX;
    short           sDBCSX;
    short           sSBCSXMove;      // use to set address mode
    short           sSBCSYMove;      // use to set address mode
    short           sDBCSXMove;      // use to set address mode
    short           sDBCSYMove;      // use to set address mode
    short           sEscapement;     // use to set address mode
    BOOL            fVertFont;       // for TATEGAKI font
    WORD            wOldFontID;
    BOOL            fPlus;
    WORD            wScale;
    LONG            lPointsx;
    LONG            lPointsy;
    int             CursorX;
    int             CursorY;

    // Used for rect-fill operations.

    DWORD dwRectX;
    DWORD dwRectY;

    // Temp. buffer parameters.

    DWORD dwBlockX, dwBlockY, dwBlockLen;
    PBYTE pTempBuf;
    DWORD dwTempBufLen;
    DWORD dwTempDataLen;

    // Absolute address mode setting.

#define ADDR_MODE_NONE 0
#define ADDR_MODE_SBCS 1
#define ADDR_MODE_DBCS 2

    BYTE jAddrMode;

    // Color mode values.  Sam values also used
    // for the command callback IDs.

#define COLOR_24BPP_2                120
#define COLOR_24BPP_4                121
#define COLOR_24BPP_8                122
#define COLOR_3PLANE                 123
#define MONOCHROME                   124

    BYTE jColorMode;

// #308001: Garbage appear on device font
#define PLANE_CYAN              1
#define PLANE_MAGENTA           2
#define PLANE_YELLOW            3
    BYTE jCurrentPlane;

// removed #if 0 dead code

} MYDATA, *PMYDATA;

#define MINIDEV_DATA(p) \
    ((p)->pdevOEM)

#define IsColorPlanar(p) \
    ((MONOCHROME == (p)->jColorMode) \
    || (COLOR_3PLANE == (p)->jColorMode))

#define IsColorTrueColor(p) \
    (!IsColorPlanar(p))

// removed #if 0 dead code

#define ColorOutDepth(p) \
    (((p)->jColorMode == COLOR_24BPP_2)?1:\
    (((p)->jColorMode == COLOR_24BPP_4)?2:\
    (((p)->jColorMode == COLOR_24BPP_8)?3:1)))

typedef struct
{
    OEM_DMEXTRAHEADER   dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

// NPDL2 command
#define ESC_RESET         "\033c1"                // software reset
#define ESC_KANJIYOKO     "\033K"                 // kanji yoko mode
#define ESC_KANJITATE     "\033t"                 // kanji yoko mode
#define FS_PAGEMODE       "\034d240.",        6   // page mode
#define FS_DRAWMODE       "\034\"R.",         4   // draw mode
#define FS_ADDRMODE_ON    "\034a%d,%d,0,B."       // set address mode
#define FS_GRPMODE_ON     "\034Y",            2   // set graphic mode
#define FS_GRPMODE_OFF    "\034Z",            2   // reset graphic mode
#define FS_SETMENUNIT     "\034<1/%d,i."          // select men-mode resolution
#define FS_JIS78          "\03405F2-00",      8   // select JIS78
#define FS_JIS90          "\03405F2-02"           // select JIS90
#define FS_ENDPAGE        "\034R\034x%d.\015\014" // end page
#define FS_E              "\034e%d,%d."
#define FS_RESO           "\034&%d."
#define FS_RESO0_RESET    "\034&0.\033c1"
#define INIT_DOC          "\034<1/%d,i.\034YSU1,%d,0;\034Z"
#define RESO_PAGE_KANJI   "\034&%d.\034d240.\033K"
#define FS_I              "\034R\034i%d,%d,0,1/1,1/1,%d,%d."
#define FS_I_2            "\034R\034i%d,%d,5,1/1,1/1,%d,%d."
#define FS_I_D            "%d,%d."
#define FS_M_Y            "\034m1/1,%s."
#define FS_M_T            "\034m%s,1/1."
#define FS_12S2           "\03412S2-%04ld-%04ld"

// Command CallBack ID
#define CALLBACK_ID_MAX              255 //

// PAGECONTROL
#define PC_MULT_COPIES_N               1
#define PC_MULT_COPIES_C               2
#define PC_TYPE_F                      4
#define PC_END_F                       6
#define PC_ENDPAGE                     7
#define PC_PRN_DIRECTION               9

// FONTSIMULATION
#define FS_SINGLE_BYTE                20
#define FS_DOUBLE_BYTE                21

// RESOLUTION
#define RES_240                       30
#define RES_400                       31
#define RES_300                       35
#define RES_SENDBLOCK                 36

//CURSORMOVE
#define CM_X_ABS                     101
#define CM_Y_ABS                     102
#define CM_CR                        103
#define CM_FF                        104
#define CM_LF                        105

#define CMD_RECT_WIDTH              130
#define CMD_RECT_HEIGHT             131
#define CMD_WHITE_FILL              132
#define CMD_GRAY_FILL               133
#define CMD_BLACK_FILL              134

// #308001: Garbage appear on device font
#define CMD_SENDCYAN                141
#define CMD_SENDMAGENTA             142
#define CMD_SENDYELLOW              143

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

WORD Ltn1ToAnk( WORD );
static int iDwtoA_FillZero(PBYTE, long, int );

#ifdef __cplusplus
	extern "C" {
#endif
	BOOL myOEMSendFontCmd( PDEVOBJ pdevobj,PUNIFONTOBJ  pUFObj,PFINVOCATION pFInv );
	BOOL myOEMOutputCharStr( PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph );
#ifdef __cplusplus
	}
#endif

#endif  //PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\konic\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=kpdlres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),kpdlres
!else
DLLBASE=0x8000000
!endif

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\common.c \
    $(SRCDIR)\kpdlres.c \
    $(SRCDIR)\kpdlres.rc

MISCFILES=\
    $(SRCDIR)\kpdlres.ini \
    $(GPDDIR)\kokl21j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\reg_def.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

// REG_DEF.H

#define MULTI_SCALE  "Multi Scale"
#define FAX_ON       "Fax On"
#define FAX_MYNAME   "Fax MyName"
#define FAX_ID       "Fax Id"
#define FAX_RES      "Fax Res"
#define FAX_USEBOOK  "Fax UseBook"
#define FAX_DSTTEL   "Fax DstTel"
#define FAX_IDDSTTEL "Fax DstTelID"
#define FAX_TEL      "Fax Tel  %d"
#define FAX_BOOK     "Fax Book %d"
#define FAX_BOOK1    "Fax Book 1"
#define FAX_BOOK2    "Fax Book 2"
#define FAX_LISTTYPE "Fax ListType"
#define FAX_DRIVE    "Fax Drive"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\etc\reg_def.h ===
// REG_DEF.H

#define MULTI_SCALE  "Multi Scale"
#define FAX_ON       "Fax On"
#define FAX_MYNAME   "Fax MyName"
#define FAX_ID       "Fax Id"
#define FAX_RES      "Fax Res"
#define FAX_USEBOOK  "Fax UseBook"
#define FAX_DSTTEL   "Fax DstTel"
#define FAX_IDDSTTEL "Fax DstTelID"
#define FAX_TEL      "Fax Tel  %d"
#define FAX_BOOK     "Fax Book %d"
#define FAX_BOOK1    "Fax Book 1"
#define FAX_BOOK2    "Fax Book 2"
#define FAX_LISTTYPE "Fax ListType"
#define FAX_DRIVE    "Fax Drive"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\etc\kpdlms.h ===
//----------------------------------------------------------------------------
// Filename:    kpdlms.h
// This file contains definitions for KPDL mini-driver
//-----------------------------------------------------------------------------

// kpdlms mini driver device data structure
typedef struct
{
    GLOBALHANDLE  hKeep;
    char   szDevName[CCHDEVICENAME];
    WORD   wRes;            // resolution 600 or 400 or 240
    WORD   wCopies;         // number of multi copies
    short  sSBCSX;
    short  sDBCSX;
    short  sSBCSXMove;      // use to set address mode
    short  sSBCSYMove;      // use to set address mode
    short  sDBCSXMove;      // use to set address mode
    short  sDBCSYMove;      // use to set address mode
    short  sEscapement;     // use to set address mode
//    WORD   wPenStyle;       //
//    WORD   wPenWidth;       //
    WORD   wPenColor;       //
    WORD   fBrCreated;      //
    WORD   wBrStyle;        //
    BOOL   fVertFont;       // for TATEGAKI font
    BOOL   fFax;            // for 1000FX
    DWORD  dwMulti;         // for Pattern
    BOOL   fFill;           // flag of fill command
    BOOL   fStroke;         // flag of stroke command
//    BOOL   fTrans;          //
    BOOL   fCurve;          // flag for Curves
    HANDLE hBuff;
    LPSTR  lpBuff;
    LPSTR  lpLBuff;
#ifdef WINNT
    WORD   wBitmapX;
    WORD   wBitmapY;
    WORD   wCurrentAddMode;
    WORD   wOldFontID;
#else // WINNT
    WORD   wBitmapY;
    WORD   wBitmapYC;
#endif // WINNT
    WORD   wBitmapLen;
    BOOL   fComp;
    BOOL   fPlus;
    WORD   wScale;
    LONG   lPointsx;
    LONG   lPointsy;
    BOOL   fMono;
    int    CursorX;
    int    CursorY;
    int    Kaicho;
    int    Color;
} NPDL2MDV, FAR *LPNPDL2MDV;

// NPDL2 command
#define ESC_RESET         "\033c1",           3   // software reset
#define ESC_KANJIYOKO     "\033K",            2   // kanji yoko mode
#define ESC_KANJITATE     "\033t",            2   // kanji yoko mode
#define FS_PAGEMODE       "\034d240.",        6   // page mode
#define FS_DRAWMODE       "\034\"R.",         4   // draw mode
#define FS_ADDRMODE_ON    "\034a%d,%d,0,B."       // set address mode
#define FS_GRPMODE_ON     "\034Y",            2   // set graphic mode
#define FS_GRPMODE_OFF    "\034Z",            2   // reset graphic mode
#define FS_SETMENUNIT     "\034<1/%d,i."          // select men-mode resolution
#define FS_JIS78          "\03405F2-00",      8   // select JIS78
#define FS_JIS90          "\03405F2-02",      8   // select JIS90
#define FS_ENDPAGE        "\034R\034x%d.\015\014" // end page
#define FS_E              "\034e%d,%d."
#define FS_RESO           "\034&%d."
#define FS_RESO0_RESET    "\034&0.\033c1",    7
#define VEC_INIT_600      "PD;IP0,0,608,608;", 17
#define VEC_INIT_400      "PD;IP0,0,405,405;", 17
#define VEC_INIT_240      "PD;IP0,0,243,243;", 17
#define VEC_TRANS         "PM0,0;",           6
#define VEC_OPAQUE        "PM1,1;",           6
#define VEC_OPLINE        "PM,1;",            5
#define INIT_DOC          "\034<1/%d,i.\034YSU1,%d,0;\034Z"
#define RESO_PAGE_KANJI   "\034&%d.\034d240.\033K"
#define FS_I              "\034R\034i%d,%d,0,1/1,1/1,%d,%d."
#define FS_I_2            "\034R\034i%d,%d,5,1/1,1/1,%d,%d."
#define FS_I_D            "%d,%d."
#define FS_M_Y            "\034m1/1,%s."
#define FS_M_T            "\034m%s,1/1."
#define FS_12S2           "\03412S2-%04ld-%04ld"

#define FX_MODESET        "\03402ZS",         5
#define FX_DATAEND        "\03402ZE",         5
#define FX_SETSTART       "\03402ZM",         5
#define FX_SETEND         "\03402ZN",         5
#define FX_TEL            "TN%s\015"
#define FX_QUA            "GQ%d\015"
#define FX_MY             "SN%s\015"
#define FX_ID             "ID%s\015"

#define FX_INIT           "\03402ZS\03402ZM",  10

// add 11/28 for PC-PR2000/6W (Naka)
#define FS_PCMODE         "\03406MNPDL1",     9 // return to PC mode
// add 95/5/8 for NPDL2+ Vector command (Nakamura)
#define VEC_ELLIP         "MA%d,%d;CV%d,%d,%d,%d,%d,%d,%d,0;" // draw ellipse
#define VEC_E_PIE         "MA%d,%d;FV%d,%d,%d,%d,%d,%d,%d,0;" // draw pie
#define VEC_E_ARC         "MA%d,%d;AV%d,%d,%d,%d,%d,%d,0;"    // draw arc
#define VEC_RECT          "NP;MA%d,%d;PR%d,0,0,%d,-%d,0,0,-%d;EP;"
#define VEC_RECT_P        "MA%d,%d;RB%d,%d,0,0,%d;"
#define VEC_CENTER        "MA%d,%d;"                 // move pen center
#define PATH_BIGIN        "NP;",              3   // begin path mode
#define VEC_STROKE        "ST1;",             4   // stroke
#define VEC_STROKE_OPA_W  "LT;ST1;LT%d,10;"
#define VEC_WINDFILL      "FL1;",             4   //
#define VEC_ALTFILL       "EF1;",             4   //

#define VEC_LC            "LC%d;"                 // endcap
#define VEC_LJ            "LJ%d;"                 // join

#define VEC_SU            "SU1,%d,0;"           // select graphic resolution
#define VEC_SG            "SG%d,%d;"            // set gray
#define VEC_SG_PEN        "SG,%d;"              // set Pen gray
#define VEC_SG_PEN_B      "SG,0;",            5 // set Pen gray
#define VEC_SG_PEN_W      "SG,100;",          7 // set Pen gray
#define VEC_SG_BR         "SG%d;"               // set Brush gray
#define VEC_PP            "PP%d;"               // select Brush

#define VEC_PEN_WIDTH     "LW%d;"
#define VEC_PEN_WIDTH_1   "LW1;",             4

#define VEC_LT_SOLID      "LT;",              3
#define VEC_LT_STYLE      "LT%d,10;"
#define VEC_LT_STYLE_B    "LT%d,10;SG,0;"
#define VEC_LT_WHITE      "LT;SG,100;",      10

// add 11/28 for PC-PR2000/6W (Naka)
#define VEC_PP6           "PP%d,2,2;"           // selest Brush for 600dpi
#define VEC_PP2           "PP%d,2,2;"           // selest Brush for 2x2
#define VEC_PP3           "PP%d,3,3;"           // selest Brush for 3x3
#define VEC_RP_BYTE       "%02X"                // Brush Pattern Set
#define VEC_RP_HORIZONTAL "RP100,8,8,00,00,00,00,FF,00,00,00;", 34// create PP_HORIZONTAL
#define VEC_RP_VERTICAL   "RP101,8,8,08,08,08,08,08,08,08,08;", 34// create PP_VERTICAL
#define VEC_RP_FDIAGONAL  "RP102,8,8,80,40,20,10,08,04,02,01;", 34// create PP_FDIAGONAL
#define VEC_RP_BDIAGONAL  "RP103,8,8,01,02,04,08,10,20,40,80;", 34// create PP_BDIAGONAL
#define VEC_RP_CROSS      "RP104,8,8,08,08,08,08,FF,08,08,08;", 34// create PP_CROSS
#define VEC_RP_DIAGCROSS  "RP105,8,8,81,42,24,18,18,24,42,81;", 34// creata PP_DIAGCROSS
#define VEC_BEGIN         "MA%d,%d;PR"
#define VEC_CONTINUE      "%d,%d"
#define VEC_BEGIN_BEZ     "MA%d,%d;BA"
#define VEC_CONTINUE_BEZ  "%d,%d,%d,%d,%d,%d"
#define VEC_CLIP          "IW%d,%d,%d,%d;"
//#define VEC_ENDPOLY       ";CP;", 4
#define VEC_ENDPOLY       ";", 1
#define VEC_ENDPOLY_D     "0,0,1,1;", 8


// Pen and Brush Color
#define SG_WHITE            100
#define SG_BLACK              0

// Created Hatch Style Brush

#define RP_HORIZONTAL    0x0001
#define RP_VERTICAL      0x0002
#define RP_FDIAGONAL     0x0004
#define RP_BDIAGONAL     0x0008
#define RP_CROSS         0x0010
#define RP_DIAGCROSS     0x0020

// Select Brush Style
#define PP_NULL               0
#define PP_SOLID              1
#define PP_HATCH            100
#define PP_HORIZONTAL       100
#define PP_VERTICAL         101
#define PP_FDIAGONAL        102
#define PP_BDIAGONAL        103
#define PP_CROSS            104
#define PP_DIAGCROSS        105
#define PP_USERPATERN       105

// Command CallBack ID
#define CALLBACK_ID_MAX              255 //

// PAGECONTROL
#define PC_MULT_COPIES_N               1
#define PC_MULT_COPIES_C               2
#define PC_TYPE_F                      4
#define PC_END_F                       6
#define PC_ENDPAGE                     7
#define PC_PRN_DIRECTION               9
#define PC_TYPE_6                     10  // add 11/25 for PC-PR2000/6W (Naka)

// FONTSIMULATION
#define FS_SINGLE_BYTE                20
#define FS_DOUBLE_BYTE                21

// RESOLUTION
#define RES_240                       30
#define RES_400                       31
#define RES_600                       32  // add 11/25 for PC-PR2000/6W (Naka)
#define RES_BLOCKOUT1                 33
#define RES_BLOCKOUT2                 34
#define RES_300                       35
#define RES_SENDBLOCK                 36

// CAROUSEL
#define CAR_SELECT_PEN_COLOR          40
#define CAR_SET_PEN_WIDTH             41

// BRUSHINFO
#define BI_SELECT_NULL                51
#define BI_SELECT_SOLID               52
#define BI_SELECT_HS_HORIZONTAL       53
#define BI_SELECT_HS_VERTICAL         54
#define BI_SELECT_HS_FDIAGONAL        55
#define BI_SELECT_HS_BDIAGONAL        56
#define BI_SELECT_HS_CROSS            57
#define BI_SELECT_HS_DIAGCROSS        58
#define BI_CREATE_BYTE_2              59
#define BI_SELECT_BRUSHSTYLE          60

// LINEINFO
#define LI_SELECT_SOLID               61
#define LI_SELECT_DASH                62
#define LI_SELECT_DOT                 63
#define LI_SELECT_DASHDOT             64
#define LI_SELECT_DASHDOTDOT          65

// VECTOROUTPUT
// add 95/5/9 for npdl2p (Nakamura)
#define VO_ELLIPSE                    70
#define VO_E_PIE                      71
#define VO_E_ARC                      72
#define VO_E_CHORD                    73
#define VO_CIRCLE                     74
#define VO_RECT                       75
#define VO_RECT_P                     76

// VECTORSUPPORT
#define VS_BIGIN_POLYDEF              81
#define VS_WINDFILL                   83
#define VS_ALTFILL                    84
#define VS_STROKE                     85

// VECTORPAGE
#define VP_E_FLAT_J_BEVEL             91
#define VP_E_ROUND_J_MITER            92
#define VP_E_SQUARE_J_ROUND           93
#define VP_TRANSPARENT                94
#define VP_OPAQUE                     95
#define VP_J_BEVEL                    96
#define VP_J_MITER                    97
#define VP_J_ROUND                    98
#define VP_INIT_VECT                  99
#define VP_CLIP                      100

//CURSORMOVE
#define CM_XY_ABS                    101

//POLYVECT
#define PV_BEGIN                     111
#define PV_CONTINUE                  112
#define PV_BEGIN_BEZ                 113
#define PV_CONTINUE_BEZ              114
#define PV_END                       115

//IMAGE CONTROL
#define KAICHO4                      120
#define KAICHO8                      121

//COLOR MODE
#define COLOR_8                      200
#define COLOR_TRUE                   201
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kpdlres\etc\kpdlms.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

char *rgchModuleName = "KPDLMS";

#define  PRINTDRIVER
#include <print.h>
#include "mdevice.h"
#include "gdidefs.inc"
#include "unidrv.h"

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#include "kpdlms.h"
#include "reg_def.h"
//#include "mydebug.h"

#define BM_DEVICE  0x8080

#define SHIFTJIS_CHARSET  128
#define CCHMAXCMDLEN      128

#define COMP_TH           3

typedef struct
{
    BYTE  fGeneral;       // General purpose bitfield
    BYTE  bCmdCbId;       // Callback ID; 0 iff no callback
    WORD  wCount;         // # of EXTCD structures following
    WORD  wLength;        // length of the command
} CD, *PCD, FAR *LPCD;

typedef struct
{
    SIZEL    sizlExtent;
    POINTFX  pfxOrigin;
    POINTFX  pfxCharInc;
} BITMAPMETRICS, FAR *LPBITMAPMETRICS;

#ifndef WINNT
typedef BYTE huge *LPDIBITS;
#else
typedef BYTE *LPDIBITS;
#endif //WINNT

// add for FAX BEGINDOC & ENDDOC
#define NAME_LENGTH  33
#define ID_LENGTH    17

#define MULTI_SCALE "Multi Scale"

#ifdef WINNT
#include <stdio.h>
#undef wsprintf
#define wsprintf sprintf

LPWRITESPOOLBUF WriteSpoolBuf;
LPALLOCMEM UniDrvAllocMem;
LPFREEMEM UniDrvFreeMem;

#undef  GlobalFreePtr
#define GlobalFreePtr  UniDrvFreeMem

#define DrvGetPrinterData(a,b,c,d,e,f)  TRUE
#define DrvSetPrinterData(a,b,c,d,e)    TRUE

#define SWAPW(x)    (((WORD)(x)<<8) | ((WORD)(x)>>8))

#define FLAG_SBCS  1
#define FLAG_DBCS  2

BYTE ShiftJis[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};

BYTE IsDBCSLeadByteNPDL(
BYTE Ch)
{
    return ShiftJis[Ch];
}
WORD SJis2JisNPDL(
WORD usCode)
{

    union {
        USHORT bBuffer;
        struct tags{
            UCHAR al;
            UCHAR ah;
        } s;
    } u;

    // Replace code values which cannot be mapped into 0x2121 - 0x7e7e
    // (94 x 94 cahracter plane) with Japanese defult character, which
    // is KATAKANA MIDDLE DOT.

    if (usCode >= 0xf040) {
        usCode = 0x8145;
    }

    u.bBuffer = usCode;

    u.s.al -= u.s.al >= 0x80 ;
    u.s.al -= 0x1F ;
    u.s.ah &= 0xBF ;
    u.s.ah <<= 1 ;
    u.s.ah += 0x21-0x02 ;

    if (u.s.al > 0x7E )
    {
        u.s.al -= (0x7F-0x21) ;
        u.s.ah++;
    }
     return (u.bBuffer);
}

// In case it is a single byte font, we will some of the characters
// (e.g. Yen-mark) to the actual printer font codepoint.  Note since
// the GPC data sets 0 to default CTT ID value, single byte codes
// are in codepage 1252 (Latin1) values.

WORD
Ltn1ToAnk(
   WORD wCode )
{
    // Not a good mapping table now.

    switch ( wCode ) {
    case 0xa5: // YEN MARK
        wCode = 0x5c;
        break;
    default:
        if ( wCode >= 0x7f)
            wCode = 0xa5;
    }

    return wCode;
}

#endif // WINNT

#if 0
int Table[]={
    0, 175, 349, 523, 698, 872, 1045, 1219, 1392, 1564,
    1736, 1908, 2079, 2250, 2419, 2588, 2756, 2924, 3090, 3256,
    3420, 3584, 3746, 3907, 4067, 4226, 4384, 4540, 4695, 4848,
    5000, 5150, 5299, 5446, 5592, 5736, 5878, 6018, 6157, 6293,
    6428, 6561, 6691, 6820, 6947, 7071, 7193, 7314, 7431, 7547,
    7660, 7771, 7880, 7986, 8090, 8192, 8290, 8387, 8480, 8572,
    8660, 8746, 8829, 8910, 8988, 9063, 9135, 9205, 9272, 9336,
    9397, 9455, 9511, 9563, 9613, 9659, 9703, 9744, 9781, 9816,
    9848, 9877, 9903, 9925, 9945, 9962, 9976, 9986, 9994, 9998,
10000};

int NEAR PASCAL Tbl(int x)
{
    int a, b;

    a = Table[x / 10];
    b = Table[x / 10 + 1] - a;

    return a + (x % 10) * b / 10;
}

int NEAR PASCAL Tsin(int x)
{
    if(x <= 900) return Tbl(x);

    if(x <= 1800) return Tbl(1800 - x);

    if(x <=2700) return -Tbl(x - 1800);

    return -Tbl(3600 - x);
}

int NEAR PASCAL Tcos(int x)
{
    if(x <= 900) return Tbl(900 - x);

    if(x <= 1800) return -Tbl(x - 900);

    if(x < 2700) return -Tbl(2700 - x);

    return Tbl(x - 2700);
}
#endif

//-------------------------------------------------------------------
// m2d
// Action:convert master unit to device unit
//-------------------------------------------------------------------
int NEAR PASCAL m2d(int x, WORD res)
{
// 300 only : sueyas

    return x;
#if 0
    if(res == 400) return x / 3;

    if(res == 600) return x >> 1;

    return x / 5;
#endif
}

#ifndef WINNT
VOID NEAR PASCAL memcpy(LPSTR lpDst, LPSTR lpSrc, WORD wLen)
{
    while(wLen--) *lpDst++ = *lpSrc++;
}
#endif //WINNT

//------------------------------------------------------------------
// REL1
// Action : compress image data
//------------------------------------------------------------------
WORD NEAR PASCAL RLE1(
LPBYTE lpDst,
LPBYTE lpSrc,
WORD   wLen)
{
    LPBYTE lpTemp, lpEnd, lpDsto;
    WORD   len, deflen;

    lpDsto = lpDst;
    lpEnd = lpSrc + wLen;

    while(lpSrc < lpEnd)
    {
        lpTemp = lpSrc++;

        if(lpSrc == lpEnd)
        {
            *lpDst++ = 0x41;
            *lpDst++ = *lpTemp;
            break;
        }

        if(*lpTemp == *lpSrc)
        {
            lpSrc++;

            while(lpSrc < lpEnd && *lpTemp == *lpSrc) lpSrc++;

            len = lpSrc - lpTemp;

            if(len < 63)
            {
                *lpDst++ = 0x80 + (BYTE)len;
                goto T1;
            }

            *lpDst++ = 0xbf;
            len -= 63;

            while(len >= 255)
            {
                *lpDst++ = 0xff;
                len -= 255;
            }

            *lpDst++ = (BYTE)len;
T1:
            *lpDst++ = *lpTemp;
            continue;
        }

        lpSrc++;

        while(lpSrc < lpEnd)
        {
            if(*lpSrc == *(lpSrc - 1))
            {
                lpSrc--;
                break;
            }

            lpSrc++;
        }

        deflen = len = lpSrc - lpTemp;

        if(len < 63)
        {
            *lpDst++ = 0x40 + (BYTE)len;
            goto T2;
        }

        *lpDst++ = 0x7f;
        len -= 63;

        while(len >= 255)
        {
            *lpDst++ = 0xff;
            len -= 255;
        }

        *lpDst++ = (BYTE)len;
T2:
        memcpy(lpDst, lpTemp, deflen);
        lpDst += deflen;
    }

    return (WORD)(lpDst - lpDsto);
}

//-------------------------------------------------------------------
// CBFilterGraphics
// Action : Compress Bitmap Data
//-------------------------------------------------------------------
WORD FAR PASCAL CBFilterGraphics(
LPDV  lpdv,
LPBYTE lpBuf,
WORD  wLen)
{
    WORD       wlen, wDatalen, wCounter;
    BYTE       ch[CCHMAXCMDLEN];
    LPNPDL2MDV lpnp;
    LPBYTE     lpLBuff;
    LPBYTE     lpBuff, lpTemp, lpBuffo, lpEnd;
    LPBYTE     lpBuff2, lpBuff2o;

    if(!lpdv->fMdv) return wLen;

    lpnp = (LPNPDL2MDV)lpdv->lpMdv;

    if(lpnp->fComp == FALSE)
    {
        if( lpnp->fMono || (lpnp->Color == COLOR_8) ){
            WriteSpoolBuf(lpdv, lpBuf, wLen);
        }
        else{

            WORD   i;
            LPSTR  lpTmp, lpBuf2;
            BYTE   bR, bG, bB;
            BOOL   fAlternate= FALSE;

            lpTmp = lpBuf;
            lpBuf2 = lpBuf;

            // Change order to RGB -> BGR

            for( i = 0; i < wLen; lpBuf+=3, i+=3 ){

   //             if (fAlternate){
   //                 fAlternate = FALSE;
   //                 continue;
   //             }else
   //                 fAlternate = TRUE;

                bR = (BYTE)*lpBuf;
                bG = (BYTE)*(lpBuf+1);
                bB = (BYTE)*(lpBuf+2);

                *lpBuf2 = (BYTE)bB;
                *(lpBuf2+1) = (BYTE)bG;
                *(lpBuf2+2) = (BYTE)bR;

                lpBuf2+=3;
            }
            WriteSpoolBuf(lpdv, lpTmp, wLen);
    //        WriteSpoolBuf(lpdv, lpTmp, wLen/2);
            
        }
        return wLen;
    }

#ifdef WINNT

    memcpy(lpnp->lpBuff, lpBuf, wLen);
    lpnp->lpBuff += wLen;
    if (lpnp->lpBuff
            < lpnp->lpLBuff + lpnp->wBitmapX + lpnp->wBitmapLen)
        return wLen;

#else // WINNT

    if(!lpnp->wBitmapYC) return wLen;

    lpnp->lpBuff += wLen;
    memcpy(lpnp->lpBuff, lpBuf, wLen);

    if(--lpnp->wBitmapYC) return wLen;
#endif // WINNT

    wCounter = lpnp->wBitmapY;
    lpLBuff = lpnp->lpLBuff;

#ifdef WINNT
    lpBuffo = lpBuff = lpTemp = lpLBuff + lpnp->wBitmapX;
#else // WINNT
    lpBuffo = lpBuff = lpTemp = lpLBuff + wLen;
#endif // WINNT
    lpBuff2o = lpBuff2 = lpBuff + lpnp->wBitmapLen;

    do
    {
#ifdef WINNT
        lpEnd = lpBuff + lpnp->wBitmapX;
#else // WINNT
        lpEnd = lpBuff + wLen;
#endif // WINNT

        while(lpBuff < lpEnd)
        {
            while(lpBuff < lpEnd && *lpLBuff != *lpBuff)
            {
                lpLBuff++;
                lpBuff++;
            }

            wlen = lpBuff - lpTemp;

            if(wlen)
            {
                lpBuff2 += RLE1(lpBuff2, lpTemp, wlen);
                lpTemp = lpBuff;
            }

            if(lpBuff == lpEnd) break;

            while(lpBuff < lpEnd && *lpLBuff == *lpBuff)
            {
                lpLBuff++;
                lpBuff++;
            }

            wlen = lpBuff - lpTemp;

            if(wlen < 63)
            {
                *lpBuff2++ = (BYTE)wlen;
                goto T;
            }

            *lpBuff2++ = 0x3f;
            wlen -= 63;

            while(wlen >= 255)
            {
                *lpBuff2++ = (BYTE)0xff;
                wlen -= 255;
            }

            *lpBuff2++ = (BYTE)wlen;
T:
            lpTemp = lpBuff;
        }

        *lpBuff2++ = (BYTE)0x80;
        wDatalen = (WORD)(lpBuff2 - lpBuff2o);

        if(wDatalen > lpnp->wBitmapLen)
        {
#ifdef WINNT
            wlen = wsprintf(ch, FS_I, (lpnp->wBitmapX << 3),
                    lpnp->wBitmapY, lpnp->wBitmapLen, lpnp->wRes);
            lpnp->wCurrentAddMode = 0;
#else // WINNT
            wlen = wsprintf(ch, FS_I, (wLen << 3), lpnp->wBitmapY,
                            lpnp->wBitmapLen, lpnp->wRes);
#endif // WINNT
            WriteSpoolBuf(lpdv, ch, wlen);
            WriteSpoolBuf(lpdv, lpBuffo, lpnp->wBitmapLen);
            GlobalFreePtr(lpnp->lpLBuff);
            return wLen;
        }
    }
    while(--wCounter);

#ifdef WINNT
    wlen = wsprintf(ch, FS_I_2, (lpnp->wBitmapX << 3), lpnp->wBitmapY,
            wDatalen, lpnp->wRes);
    lpnp->wCurrentAddMode = 0;
#else // WINNT
    wlen = wsprintf(ch, FS_I_2, (wLen << 3), lpnp->wBitmapY, wDatalen,
                    lpnp->wRes);
#endif // WINNT
    WriteSpoolBuf(lpdv, ch, wlen);
    WriteSpoolBuf(lpdv, lpBuff2o, wDatalen);
    GlobalFreePtr(lpnp->lpLBuff);
    return wLen;
}

//-------------------------------------------------------------------
// fnOEMTTBitmap
// Action: Dummy
//-------------------------------------------------------------------
BOOL FAR PASCAL fnOEMTTBitmap(
LPDV       lpdv,
LPFONTINFO lpFont,
LPDRAWMODE lpDrawMode)
{
    return TRUE;
}

//-------------------------------------------------------------------
// fnOEMGetFontCmd
// Action: Dummy
//-------------------------------------------------------------------
BOOL FAR PASCAL fnOEMGetFontCmd(
LPDV    lpdv,
WORD    wCmdCbId,
LPSTR   lpfont,
BOOL    fSelect,
LPBYTE  lpBuf,
LPWORD  lpwSize)
{
    return TRUE;
}

//-------------------------------------------------------------------
// OEMSendScalableFontCmd
// Action:  send NPDL2-style font selection command.
//-------------------------------------------------------------------
VOID FAR PASCAL OEMSendScalableFontCmd(
LPDV        lpdv,
LPCD        lpcd,     // offset to the command heap
LPFONTINFO  lpFont)
{
    short  ocmd;
    BYTE   i;
    long   tmpPointsx, tmpPointsy;
    LPSTR  lpcmd;
    BYTE   rgcmd[CCHMAXCMDLEN];    // build command here
    BOOL   fDBCS;


    LPNPDL2MDV  lpnp;

    if(!lpcd || !lpFont) return;

    if(!lpdv->fMdv) return;

    lpnp = (LPNPDL2MDV)lpdv->lpMdv;

    // be careful about integer overflow.
    lpcmd = (LPSTR)(lpcd + 1);

    tmpPointsy = (long)lpFont->dfPixHeight * 720 / (long)lpnp->wRes;
    ocmd = i = 0;

    while(lpcmd[i] !='#')
    {
        rgcmd[ocmd] = lpcmd[i];
        ocmd++;
        i++;
    }

    i++;
    lpnp->fVertFont = lpnp->fPlus = FALSE;

    switch(lpcmd[i])
    {
    case 'R':
        lpnp->fPlus = TRUE;
        tmpPointsx = (long)lpFont->dfAvgWidth * 1200 / (long)lpnp->wRes;
        break;

    case 'P':
        fDBCS = FALSE; 
        tmpPointsx = ((long)lpFont->dfAvgWidth * 1200 + 600) /
                     (long)lpnp->wRes;
        break;

    case 'W':
        lpnp->fVertFont = TRUE;

    case 'Q':
        fDBCS = TRUE; 
        tmpPointsx = (long)lpFont->dfAvgWidth * 1440 / (long)lpnp->wRes;
        break;

    case 'Y':
        lpnp->fVertFont = TRUE;

    case 'S':
        lpnp->fPlus = TRUE;
        tmpPointsx = (long)lpFont->dfAvgWidth * 1440 / (long)lpnp->wRes;
        break;
    }

    if(lpnp->fPlus)
    {
        if(tmpPointsy > 9999)    tmpPointsy = 9999;
        else if(tmpPointsy < 10) tmpPointsy = 10;

        if(tmpPointsx > 9999)    tmpPointsx = 9999;
        else if(tmpPointsx < 10) tmpPointsx = 10;

        lpnp->wScale = tmpPointsx == tmpPointsy;
        lpnp->lPointsx = tmpPointsx;
        lpnp->lPointsy = tmpPointsy;

        if(lpnp->fVertFont)
        {
            if(lpnp->wScale)
                ocmd += wsprintf(&rgcmd[ocmd], FS_12S2, tmpPointsy,
                                 tmpPointsx);
        }
        else
            ocmd += wsprintf(&rgcmd[ocmd], "%04ld-%04ld", tmpPointsx,
                             tmpPointsy);
        goto SEND_COM;
    }

    lpnp->wScale = 1;

    if(tmpPointsy > 9999)
    {
        tmpPointsy = 9999;
        goto MAKE_COM;
    }

    if(tmpPointsy < 10)
    {
        tmpPointsy = 10;
        goto MAKE_COM;
    }

    lpnp->wScale = (int)(tmpPointsx / tmpPointsy);

    if(lpnp->wScale > 8) lpnp->wScale = 8;

MAKE_COM:
    ocmd += wsprintf(&rgcmd[ocmd], "%04ld", tmpPointsy);

SEND_COM:
    // write spool builded command
    WriteSpoolBuf(lpdv, rgcmd, ocmd);

    i++;
    ocmd = 0;
    while(lpcmd[i] !='#')
    {
        rgcmd[ocmd] = lpcmd[i];
        ocmd++;
        i++;
    }
    ocmd += wsprintf(&rgcmd[ocmd], "%04ld,", (fDBCS ? lpFont->dfAvgWidth * 2 : lpFont->dfAvgWidth));
    ocmd += wsprintf(&rgcmd[ocmd], "%04ld.", lpFont->dfPixHeight);
    WriteSpoolBuf(lpdv, rgcmd, ocmd);
#if 0 
    if(!lpnp->fPlus)
    {
        char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                         "4/1", "4/1", "6/1", "6/1", "8/1"};

        if(lpnp->fVertFont)
        {
            if(lpnp->wScale == 1)
            {
                ocmd = wsprintf(rgcmd, FS_M_T, (LPSTR)bcom[lpnp->wScale]);
                WriteSpoolBuf(lpdv, rgcmd, ocmd);
            }
        }
        else
        {
            ocmd = wsprintf(rgcmd, FS_M_Y, (LPSTR)bcom[lpnp->wScale]);
            WriteSpoolBuf(lpdv, rgcmd, ocmd);
        }
    }
#endif

    // save for FS_SINGLE_BYTE and FS_DOUBLE_BYTE
    lpnp->sSBCSX = lpnp->sSBCSXMove = lpFont->dfAvgWidth;
    lpnp->sDBCSX = lpnp->sDBCSXMove = lpFont->dfAvgWidth << 1;
    lpnp->sSBCSYMove = lpnp->sDBCSYMove = 0;
#ifdef WINNT
    lpnp->wCurrentAddMode = 0;
#endif
}

//-------------------------------------------------------------------
// fnOEMOutputCmd
// Action :
//-------------------------------------------------------------------
VOID FAR PASCAL fnOEMOutputCmd(
LPDV     lpdv,
WORD     wCmdCbId,
LPDWORD  lpdwParams)
{
    WORD        wlen;
   BYTE        ch[CCHMAXCMDLEN];
    LPNPDL2MDV  lpnp;


    if(!lpdv->fMdv) return;

    lpnp = (LPNPDL2MDV)lpdv->lpMdv;

    switch(wCmdCbId)
    {
    case COLOR_8:
        lpnp->Color = COLOR_8;
        break;
    case COLOR_TRUE:
        lpnp->Color = COLOR_TRUE;
        break;
    case KAICHO4:
        lpnp->Kaicho = 2;
        break;
    case KAICHO8:
        lpnp->Kaicho = 3;
        break;
// *** Resolutions   RES *** //
    case RES_600:
    case RES_400:
    case RES_240:
        lpnp->wRes = wCmdCbId == RES_600 ? 600 :
                    (wCmdCbId == RES_400 ? 400 : 240);

        wlen = wsprintf(ch, RESO_PAGE_KANJI, lpnp->wRes);
        WriteSpoolBuf(lpdv, ch, wlen);
        break;
    case RES_300:
        lpnp->wRes = 300;
        WriteSpoolBuf(lpdv, "\x1CYSU1,300,0;\x1CZ", 14);
        WriteSpoolBuf(lpdv, "\x1C<1/300,i.", 10);

        if (lpnp->fMono == FALSE){

            WriteSpoolBuf(lpdv, "\x1B\x43\x30", 3);
            WriteSpoolBuf(lpdv, "\x1CYOP2,13;", 9);
            WriteSpoolBuf(lpdv, "QB0,255,255,255,0,0,0;", 22);
            WriteSpoolBuf(lpdv, "XX1;\x1CZ", 6);
        }

        break;

    case RES_SENDBLOCK:
        {
            WORD size, x, y;

            if(!lpdwParams) return;

            size = (WORD)*lpdwParams;
            y = (WORD)*(lpdwParams + 1);
            x = (WORD)*(lpdwParams + 2);

            if( lpnp->fMono || (lpnp->Color == COLOR_8) ){
              
                wlen = wsprintf(ch, "\034R\034i%d,%d,0,1/1,1/1,%d,300.", x * 8, y, size );
                WriteSpoolBuf(lpdv, ch, wlen);
#ifdef WINNT
                lpnp->wCurrentAddMode = 0;
#endif

            }
            else{

                wlen = wsprintf(ch, "\034!E%d,%d,%d,%d,%d,%d,%d,%d.", 
                                lpnp->Kaicho, lpnp->CursorX, lpnp->CursorY,
                                x/3, y, x/3, y, size );
                                //x/3, y, (x/3)/2, y/2, size/2 );
      
                WriteSpoolBuf(lpdv, ch, wlen);

            }
        }
        break;

    case RES_BLOCKOUT2:
        {
        WORD size, x, y;

        if(!lpdwParams) return;

        size = (WORD)*lpdwParams;
        y = (WORD)*(lpdwParams + 1);
        x = (WORD)*(lpdwParams + 2);

#ifdef WINNT
        lpnp->wBitmapX = x;
        lpnp->wBitmapY = y;
#else // WINNT
        lpnp->wBitmapY = lpnp->wBitmapYC = y
#endif // WINNT

        lpnp->wBitmapLen = size;

        if(x < COMP_TH) goto NOCOMP;

#ifndef WINNT
        lpnp->hBuff = GlobalAlloc(GHND, x * 3 + (size << 1) + y);

        if(!lpnp->hBuff) goto NOCOMP;

        lpnp->lpLBuff = lpnp->lpBuff = (LPSTR)GlobalLock(lpnp->hBuff);

        if(!lpnp->lpBuff)
        {
            GlobalFree(lpnp->hBuff);
            goto NOCOMP;
        }
#else // WINNT

        lpnp->lpLBuff = (LPSTR)UniDrvAllocMem(x * 3 + (size << 1) + y);

        if (lpnp->lpBuff == NULL)
        {
            goto NOCOMP;
        }

        memset(lpnp->lpLBuff, 0, (x * 3 + (size << 1) + y));
        lpnp->lpBuff = lpnp->lpLBuff + lpnp->wBitmapX;

#endif // WINNT

        lpnp->fComp = TRUE;
        break;

NOCOMP:
        lpnp->fComp = FALSE;
        wlen = wsprintf(ch, FS_I, (x << 3), y, size, lpnp->wRes);
        WriteSpoolBuf(lpdv, ch, wlen);
#ifdef WINNT
        lpnp->wCurrentAddMode = 0;
#endif
        }
        break;

// *** Page Control PC *** //
    case PC_TYPE_F:
        {
        DWORD dwTmp, dwType, dwData;
        char  szBuff[80];
        short nDouhou;

        WriteSpoolBuf(lpdv, ESC_RESET);

        if(DrvGetPrinterData(lpnp->szDevName, FAX_ON, &dwType, (LPBYTE)&dwTmp,
                             sizeof(DWORD), &dwData))
            dwTmp = 0;

        if(dwTmp)
        {
            lpnp->fFax = TRUE;
            dwTmp = 0;
            DrvSetPrinterData(lpnp->szDevName, FAX_ON, REG_DWORD,
                              (LPBYTE)&dwTmp, sizeof(DWORD));
            WriteSpoolBuf(lpdv, FX_INIT);

            if(DrvGetPrinterData(lpnp->szDevName, FAX_USEBOOK, &dwType,
                                 (LPBYTE)&dwTmp, sizeof(DWORD), &dwData))
                nDouhou = 0;
            else
                nDouhou = (int)dwTmp;

            dwTmp = 0;
            DrvSetPrinterData(lpnp->szDevName, FAX_USEBOOK, REG_DWORD,
                              (LPBYTE)&dwTmp, sizeof(DWORD));

            if(nDouhou)
            {
                int i = 0;
                char telBuf[40];

                while(1)
                {
                    i++;
                    wsprintf(telBuf, FAX_TEL, i);

                    if(DrvGetPrinterData(lpnp->szDevName, telBuf, &dwType,
                                         szBuff, sizeof(szBuff),
                                         &dwData))
                        break;

                    wlen = wsprintf(ch, FX_TEL, (LPSTR)szBuff);
                    WriteSpoolBuf(lpdv, ch, wlen);
                }
            }
            else
            {
                if(DrvGetPrinterData(lpnp->szDevName, FAX_IDDSTTEL, &dwType,
                                     szBuff, sizeof(szBuff), &dwData))
                    szBuff[0] = 0;

                if(szBuff[0])
                {
                    wlen = wsprintf(ch, FX_TEL, (LPSTR)szBuff);
                    WriteSpoolBuf(lpdv, ch, wlen);
                }
            }

            szBuff[0] = 0;
            DrvSetPrinterData(lpnp->szDevName, FAX_DSTTEL, REG_SZ, szBuff, 1);
            DrvSetPrinterData(lpnp->szDevName, FAX_IDDSTTEL, REG_SZ, szBuff,
                              1);

            if(DrvGetPrinterData(lpnp->szDevName, FAX_RES, &dwType,
                                 (LPBYTE)&dwTmp, sizeof(DWORD), &dwData))
                dwTmp = 0;

            wlen = wsprintf(ch, FX_QUA, (int)dwTmp);
            WriteSpoolBuf(lpdv, ch, wlen);

            if(DrvGetPrinterData(lpnp->szDevName, FAX_MYNAME, &dwType, szBuff,
                                 sizeof(szBuff), &dwData))
                szBuff[0] = 0;

            if(szBuff[0])
            {
                wlen = wsprintf(ch, FX_MY, (LPSTR)szBuff);
                WriteSpoolBuf(lpdv, ch, wlen);
            }

            if(DrvGetPrinterData(lpnp->szDevName, FAX_ID, &dwType, szBuff,
                                 sizeof(szBuff), &dwData))
                szBuff[0] = 0;

            if(szBuff[0])
            {
                wlen = wsprintf(ch, FX_ID, (LPSTR)szBuff);
                WriteSpoolBuf(lpdv, ch, wlen);
            }

            WriteSpoolBuf(lpdv, FX_SETEND);
        }
        }
        break;

    case PC_END_F:

        if(lpnp->fFax == TRUE)
        {
            WriteSpoolBuf(lpdv, FX_DATAEND);
            lpnp->fFax = FALSE;
        }

        WriteSpoolBuf(lpdv, FS_RESO0_RESET);
        break;

    case PC_ENDPAGE :
        wlen = wsprintf(ch, FS_ENDPAGE, lpnp->wCopies);
        WriteSpoolBuf(lpdv, ch, wlen);
        break;

    case PC_MULT_COPIES_N:
    case PC_MULT_COPIES_C:
        // FS_COPIES is neccesary for each page
        if(!lpdwParams) return;

        if(wCmdCbId == PC_MULT_COPIES_C)
        {
            int iCharSet;

#ifndef WINNT
            iCharSet = GetProfileInt("system.font", "CharSet", 1);

            if(iCharSet == 8) WriteSpoolBuf(lpdv, FS_JIS78);
            else              WriteSpoolBuf(lpdv, FS_JIS90);
#else
            WriteSpoolBuf(lpdv, FS_JIS90);
#endif //WINNT
        }

        lpnp->wCopies = (WORD)*lpdwParams;
        wlen = wsprintf(ch, INIT_DOC, lpnp->wRes, lpnp->wRes);
        WriteSpoolBuf(lpdv, ch, wlen);
        break;

    case PC_PRN_DIRECTION:
        {
        short  sEsc, sEsc90;
        short  ESin[] = {0, 1, 0, -1};
        short  ECos[] = {1, 0, -1, 0};

        if(!lpdwParams) return;

        lpnp->sEscapement = (short)*lpdwParams % 360;
        sEsc = lpnp->sEscapement;
        sEsc90 = lpnp->sEscapement/90;

#if 0
//if gpc supported any degree character rotation, available here.
        if(!(sEsc % 900))
        {
#endif
        lpnp->sSBCSXMove = lpnp->sSBCSX * ECos[sEsc90];
        lpnp->sSBCSYMove = -lpnp->sSBCSX * ESin[sEsc90];
        lpnp->sDBCSXMove = lpnp->sDBCSX * ECos[sEsc90];
        lpnp->sDBCSYMove = -lpnp->sDBCSX * ESin[sEsc90];
#if 0
//if gpc supported any degree character rotation, available here.
        }
        else
        {
            lpnp->sSBCSXMove = Scale(lpnp->sSBCSX, RCos(1000, sEsc), 1000);
            lpnp->sSBCSYMove = Scale(-lpnp->sSBCSX, RSin(1000, sEsc), 1000);
            lpnp->sDBCSXMove = Scale(lpnp->sDBCSX, RCos(1000, sEsc), 1000);
            lpnp->sDBCSYMove = Scale(-lpnp->sDBCSX, RSin(1000, sEsc), 1000);
        }
#endif
        }
        break;

// *** Cursor Movement CM *** //
    case CM_XY_ABS:
        {
        int x, y;

        if(!lpdwParams) return;

        x = m2d((int)*lpdwParams, lpnp->wRes);
        y = m2d((int)*(lpdwParams + 1), lpnp->wRes);
 
        lpnp->CursorX = x;
        lpnp->CursorY = y;

        wlen = wsprintf(ch, FS_E, x, y);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

// *** Font Simulation FS *** //
    case FS_DOUBLE_BYTE:
#ifndef WINNT
        wlen = wsprintf(ch, FS_ADDRMODE_ON, lpnp->sDBCSXMove,
                        lpnp->sDBCSYMove);
        WriteSpoolBuf(lpdv, ch, wlen);

        if(lpnp->fVertFont)
        {
            WriteSpoolBuf(lpdv, ESC_KANJITATE);

            if(lpnp->wScale == 1) break;

            if(!lpnp->fPlus)
            {
                char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                 "4/1", "4/1", "6/1", "6/1", "8/1"};

                wlen = wsprintf(ch, FS_M_T, (LPSTR)bcom[lpnp->wScale]);
                WriteSpoolBuf(lpdv, ch, wlen);
                break;
            }
            else  wlen = wsprintf(ch, FS_12S2, lpnp->lPointsy, lpnp->lPointsx);

            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif

        break;

    case FS_SINGLE_BYTE:
#ifndef WINNT
        wlen = wsprintf(ch, FS_ADDRMODE_ON, lpnp->sSBCSXMove,
                        lpnp->sSBCSYMove);
        WriteSpoolBuf(lpdv, ch, wlen);

        if(lpnp->fVertFont)
        {
            WriteSpoolBuf(lpdv, ESC_KANJIYOKO);

            if(lpnp->wScale == 1) break;

            if(!lpnp->fPlus)
            {
                char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                 "4/1", "4/1", "6/1", "6/1", "8/1"};

                wlen = wsprintf(ch, FS_M_Y, (LPSTR)bcom[lpnp->wScale]);
                WriteSpoolBuf(lpdv, ch, wlen);
                break;
            }
            else wlen = wsprintf(ch, FS_12S2, lpnp->lPointsx, lpnp->lPointsy);

            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif
        break;

// *** Vector Page VP *** //
    case VP_INIT_VECT:
        if(lpnp->wRes == 400)
        {
            WriteSpoolBuf(lpdv, VEC_INIT_400);
            return;
        }

        if(lpnp->wRes == 600)
        {
            WriteSpoolBuf(lpdv, VEC_INIT_600);
            return;
        }

        WriteSpoolBuf(lpdv, VEC_INIT_240);
        return;

    case VP_CLIP:
        {
        int left, top, right, bottom;

        if(!lpdwParams) return;

        left = m2d((int)*lpdwParams, lpnp->wRes);
        top  = m2d((int)*(lpdwParams + 1), lpnp->wRes);
        right = m2d((int)*(lpdwParams + 2), lpnp->wRes);
        bottom  = m2d((int)*(lpdwParams + 3), lpnp->wRes);
        wlen = wsprintf(ch, VEC_CLIP, left, top, right, bottom);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;
#if 0
    case VP_TRANSPARENT:
        lpnp->fTrans = TRUE;

        if(lpnp->fFill == FALSE) WriteSpoolBuf(lpdv, VEC_TRANS);
        else                     WriteSpoolBuf(lpdv, VEC_OPAQUE);

        break;
#endif

    case VP_OPAQUE:
//        lpnp->fTrans = FALSE;

        if(lpnp->fCurve == TRUE && lpnp->fFill == TRUE)
            WriteSpoolBuf(lpdv, VEC_OPLINE);
        else
            WriteSpoolBuf(lpdv, VEC_OPAQUE);

        break;

// *** Carousel CAR *** //
    case CAR_SELECT_PEN_COLOR:
        lpnp->wPenColor = *lpdwParams ? SG_BLACK : SG_WHITE;

        if(lpnp->wBrStyle == PP_SOLID)
            wlen = wsprintf(ch, VEC_SG, lpnp->wPenColor, lpnp->wPenColor);
        else
            wlen = wsprintf(ch, VEC_SG_PEN, lpnp->wPenColor);

        WriteSpoolBuf(lpdv, ch, wlen);
        break;

    case CAR_SET_PEN_WIDTH:
        {
        int width;

        if(!lpdwParams) return;

        width = m2d((int)*lpdwParams, lpnp->wRes);
        wlen = wsprintf(ch, VEC_PEN_WIDTH, width);

#if 0
// for Opaque Style Pen and Line Width
        lpnp->wPenWidth = m2d((int)*lpdwParams, lpnp->wRes);;
        if(lpnp->wPenWidth < 2)
        {
            WriteSpoolBuf(lpdv, VEC_PEN_WIDTH_1);
            break;
        }

        wlen = wsprintf(ch, VEC_PEN_WIDTH, lpnp->wPenWidth);
#endif

        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

// *** Line Info LI *** //
#if 0
// for Opaque Style Pen and Line Width
    case LI_SELECT_SOLID:
    case LI_SELECT_DASH:
    case LI_SELECT_DOT:
    case LI_SELECT_DASHDOT:
    case LI_SELECT_DASHDOTDOT:
        {
        short n[] = {0, 2, 100, 5, 6};

        lpnp->wPenStyle = n[wCmdCbId - LI_SELECT_SOLID];

        if(!lpnp->wPenStyle)
        {
            WriteSpoolBuf(lpdv, VEC_LT_SOLID);
            break;
        }

        wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
        WriteSpoolBuf(lpdv, ch, wlen);

        }
        break;
#endif

// *** Brush Info BI *** //
// add 11/28 for PC-PR2000/6W (Naka)
// merged 94/12/20 by DAI
    case BI_SELECT_SOLID:
        lpnp->wBrStyle = PP_SOLID;
        wlen = wsprintf(ch, VEC_SG_BR, lpnp->wPenColor);
        WriteSpoolBuf(lpdv, ch, wlen);
        break;

// add 11/28 for PC-PR2000/6W (Naka)
// merged 94/12/20 by DAI
    case BI_SELECT_HS_HORIZONTAL:
    case BI_SELECT_HS_VERTICAL:
    case BI_SELECT_HS_FDIAGONAL:
    case BI_SELECT_HS_BDIAGONAL:
    case BI_SELECT_HS_CROSS:
    case BI_SELECT_HS_DIAGCROSS:
        {
        short  i;

        struct
        {
            WORD   pp;
            WORD   rp;
            LPSTR  vec;
            int   size;
        } BrTbl[]={{PP_HORIZONTAL, RP_HORIZONTAL, VEC_RP_HORIZONTAL},
                   {PP_VERTICAL,   RP_VERTICAL,   VEC_RP_VERTICAL  },
                   {PP_FDIAGONAL,  RP_FDIAGONAL,  VEC_RP_FDIAGONAL },
                   {PP_BDIAGONAL,  RP_BDIAGONAL,  VEC_RP_BDIAGONAL },
                   {PP_CROSS,      RP_CROSS,      VEC_RP_CROSS     },
                   {PP_DIAGCROSS,  RP_DIAGCROSS,  VEC_RP_DIAGCROSS }};

        i = wCmdCbId - BI_SELECT_HS_HORIZONTAL;
        lpnp->wBrStyle = BrTbl[i].pp;

        if(!(lpnp->fBrCreated & BrTbl[i].rp))
        {
            WriteSpoolBuf(lpdv, BrTbl[i].vec, BrTbl[i].size);
            lpnp->fBrCreated |= BrTbl[i].rp;
        }

        switch(lpnp->dwMulti)
        {
        case 0:
            wlen = wsprintf(ch, VEC_PP, lpnp->wBrStyle);
            break;

        case 1:
            wlen = wsprintf(ch, VEC_PP2, lpnp->wBrStyle);
            break;

        case 2:
            wlen = wsprintf(ch, VEC_PP3, lpnp->wBrStyle);
        }

        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

    case BI_CREATE_BYTE_2:
        if(!lpdwParams) return;

        wlen = wsprintf(ch, VEC_RP_BYTE, (BYTE)~*lpdwParams);
        WriteSpoolBuf(lpdv, ch, wlen);
        break;

    case BI_SELECT_BRUSHSTYLE:
        if(!lpdwParams) return;

        lpnp->wBrStyle = (WORD)*lpdwParams + PP_USERPATERN;

        switch(lpnp->dwMulti)
        {
        case 0:
            wlen = wsprintf(ch, VEC_PP, lpnp->wBrStyle);
            break;

        case 1:
            wlen = wsprintf(ch, VEC_PP2, lpnp->wBrStyle);
            break;

        case 2:
            wlen = wsprintf(ch, VEC_PP3, lpnp->wBrStyle);
        }

        WriteSpoolBuf(lpdv, ch, wlen);
        break;

// *** Vector Output VO *** //
// add 11/28 for PC-PR2000/6W (Naka)
// merged 94/12/20 by DAI

    case VO_RECT:
        {
        short x1, y1, dx, dy;

        x1 = m2d((short)*lpdwParams, lpnp->wRes);
        y1 = m2d((short)*(lpdwParams + 1), lpnp->wRes);
        dx = m2d((short)*(lpdwParams + 4), lpnp->wRes);
        dy = m2d((short)*(lpdwParams + 5), lpnp->wRes);

        if(!dx && !dy) dx = dy = 1;

        wlen = wsprintf(ch, VEC_RECT, x1, y1, dx, dy, dx,dy);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

    case VO_RECT_P:
        {
        short x1, y1, x2, y2, n;

        if(lpnp->fCurve == FALSE)
        {
            lpnp->fFill = lpnp->fStroke = FALSE;
            lpnp->fCurve = TRUE;
            return;
        }

        lpnp->fCurve = FALSE;

        if(lpnp->fFill == FALSE && lpnp->fStroke == FALSE) return;

        x1 = m2d((short)*lpdwParams, lpnp->wRes);
        y1 = m2d((short)*(lpdwParams + 1), lpnp->wRes);
        x2 = m2d((short)*(lpdwParams + 2), lpnp->wRes);
        y2 = m2d((short)*(lpdwParams + 3), lpnp->wRes);

        if(x1 == x2 && y1 == y2 )
        {
            x2++;
            y2++;
        }

        if(lpnp->fFill == TRUE) n = lpnp->fStroke == TRUE ? 2 : 1;
        else                    n = 0;

        wlen = wsprintf(ch, VEC_RECT_P, x1, y1, x2, y2, n);
        WriteSpoolBuf(lpdv, ch, wlen);

#if 0
// for opaque style line
        if(n == 1 || lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 ||
           !lpnp->wPenStyle)
        {
            WriteSpoolBuf(lpdv, ch, wlen);
            break;
        }

        if(lpnp->wPenColor == SG_BLACK)
        {
            WriteSpoolBuf(lpdv, VEC_LT_WHITE);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_RECT_P, x1, y1, x2, y2, 0);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
        else
        {
            WriteSpoolBuf(lpdv, VEC_LT_SOLID);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif
        }
        break;

// for NPDL2+ vector graphics mode(add Naka 95/5/11)
    case VO_CIRCLE:
        {
        short n;
        short sX;
        short sXr;
        short sY;
        short sR;

        if(lpnp->fCurve == FALSE)
        {
            lpnp->fFill = lpnp->fStroke = FALSE;
            lpnp->fCurve = TRUE;
            return;
        }

        lpnp->fCurve = FALSE;

        if(lpnp->fFill == FALSE && lpnp->fStroke == FALSE) return;

        sX = m2d((short)*lpdwParams, lpnp->wRes);
        sY = m2d((short)*(lpdwParams + 1), lpnp->wRes);
        sR = m2d((short)*(lpdwParams + 2), lpnp->wRes);

        if(lpnp->fFill == TRUE) n = lpnp->fStroke == TRUE ? 2 : 1;
        else                    n = 0;

        sXr = sX + sR;     // starting point of the circle (X coordinate)
        wlen = wsprintf(ch, VEC_ELLIP, sX, sY, sR, sR, sXr, sY, sXr, sY, n);
        WriteSpoolBuf(lpdv, ch, wlen);

#if 0
// for opaque style line
        if(n == 1 || lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 ||
           !lpnp->wPenStyle)
        {
            WriteSpoolBuf(lpdv, ch, wlen);
            break;
        }

        if(lpnp->wPenColor == SG_BLACK)
        {
            WriteSpoolBuf(lpdv, VEC_LT_WHITE);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_ELLIP, sR, sR, sX, sY, sX, sY, 0);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
        else
        {
            WriteSpoolBuf(lpdv, VEC_LT_SOLID);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif
        }
        break;

// for NPDL2+ vector graphics mode(add Naka 95/5/8)
    case VO_ELLIPSE:
        {
        short n;
        short sEllX1;
        short sEllY1;
        short sEllX2;
        short sEllY2;
        short sEllX;
        short sEllY;
        short sCENTERX;
        short sCENTERY;
        short sR;

        if(lpnp->fCurve == FALSE)
        {
            lpnp->fFill = lpnp->fStroke = FALSE;
            lpnp->fCurve = TRUE;
            return;
        }

        lpnp->fCurve = FALSE;

        if(lpnp->fFill == FALSE && lpnp->fStroke == FALSE) return;

        sEllX1 = m2d((short)*lpdwParams, lpnp->wRes);
        sEllY1 = m2d((short)*(lpdwParams + 1), lpnp->wRes);
        sEllX2 = m2d((short)*(lpdwParams + 2), lpnp->wRes);
        sEllY2 = m2d((short)*(lpdwParams + 3), lpnp->wRes);
        sCENTERX = (sEllX1 + sEllX2) >> 1;
        sCENTERY = (sEllY1 + sEllY2) >> 1;
        sEllX = (sEllX2 - sEllX1) >> 1;
        sEllY = (sEllY2 - sEllY1) >> 1;
        sR = sCENTERX + sEllX;

        if(lpnp->fFill == TRUE) n = lpnp->fStroke == TRUE ? 2 : 1;
        else                    n = 0;

        wlen = wsprintf(ch, VEC_ELLIP, sCENTERX, sCENTERY, sEllX, sEllY,
                        sEllX2, sCENTERY, sEllX2, sCENTERY, n);
        WriteSpoolBuf(lpdv, ch, wlen);

#if 0
// for opaque style line
        if(n == 1 || lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 ||
           !lpnp->wPenStyle)
        {
            WriteSpoolBuf(lpdv, ch, wlen);
            break;
        }

        if(lpnp->wPenColor == SG_BLACK)
        {
            WriteSpoolBuf(lpdv, VEC_LT_WHITE);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_ELLIP, sEllX, sEllY, sEllX2, sCENTERY,
                            sEllX2, sCENTERY, 0);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
        else
        {
            WriteSpoolBuf(lpdv, VEC_LT_SOLID);
            WriteSpoolBuf(lpdv, ch, wlen);
            wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif
        }
        break;

#if 0
// for NPDL2+ vector graphics mode(add Naka 95/5/9)
    case VO_E_PIE:
    case VO_E_ARC:
    case VO_E_CHORD:
        {
        short n;
        short i;
        short sPIEX1;
        short sPIEY1;
        short sPIEX2;
        short sPIEY2;
        long X1;
        long Y1;
        long X2;
        long Y2;
        int iDegree;
        short sCENTERX;
        short sCENTERY;
        short rx;
        short ry;

        if(lpnp->fCurve == FALSE)
        {
            lpnp->fFill = lpnp->fStroke = FALSE;
            lpnp->fCurve = TRUE;
            return;
        }

        lpnp->fCurve = FALSE;

        if(lpnp->fFill == FALSE && lpnp->fStroke == FALSE) return;

        i = wCmdCbId - VO_ELLIPSE;

        if(i == 2 && lpnp->fStroke == FALSE) return;

        sPIEX1  = m2d((short)*lpdwParams, lpnp->wRes);
        sPIEY1  = m2d((short)*(lpdwParams + 1), lpnp->wRes);
        sPIEX2  = m2d((short)*(lpdwParams + 2), lpnp->wRes);
        sPIEY2  = m2d((short)*(lpdwParams + 3), lpnp->wRes);
        X1      = (short)*(lpdwParams + 4);  // transformed(r=5000) scale
        Y1      = (short)*(lpdwParams + 5);  // transformed(r=5000) scale
        iDegree = (short)*(lpdwParams + 6);  // transformed(r=5000) degree

        if(!iDegree) return;

        if(iDegree < 0) iDegree += 3600;

        sCENTERX = (sPIEX1 + sPIEX2) >> 1;
        sCENTERY = (sPIEY1 + sPIEY2) >> 1;
        rx = (sPIEX2 - sPIEX1) >> 1;
        ry = (sPIEY2 - sPIEY1) >> 1;
        wlen = wsprintf(ch, VEC_CENTER, sCENTERX, sCENTERY);
        WriteSpoolBuf(lpdv, ch, wlen);
        X2 = (X1 * Tcos(iDegree) - Y1 * Tsin(iDegree)) / 10000;
        Y2 = (X1 * Tsin(iDegree) + Y1 * Tcos(iDegree)) / 10000;
        X1 = (long)rx * X1 / 5000 + (long)sCENTERX;
        Y1 = (long)ry * Y1 / 5000 + (long)sCENTERY;
        X2 = (long)rx * X2 / 5000 + (long)sCENTERX;
        Y2 = (long)ry * Y2 / 5000 + (long)sCENTERY;

        if(lpnp->fFill == TRUE) n = lpnp->fStroke == TRUE ? 2 : 1;
        else                    n = 0;

        switch(i)
        {
        case 1:
            wlen = wsprintf(ch, VEC_E_PIE, rx, ry, (short)X1, (short)Y1,
                            (short)X2, (short)Y2, n);
#if 0
// for opaque style line
            if(n == 1 || lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 ||
               !lpnp->wPenStyle)
            {
                WriteSpoolBuf(lpdv, ch, wlen);
                break;
            }

            if(lpnp->wPenColor == SG_BLACK)
            {
                WriteSpoolBuf(lpdv, VEC_LT_WHITE);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_E_PIE, rx, ry, (short)X1, (short)Y1,
                                    (short)X2, (short)Y2, 0);
                WriteSpoolBuf(lpdv, ch, wlen);
            }
            else
            {
                WriteSpoolBuf(lpdv, VEC_LT_SOLID);
                wlen = wsprintf(ch, VEC_E_PIE, rx, ry, (short)X1, (short)Y1,
                                (short)X2, (short)Y2, n);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
            }
#endif
            break;

        case 2:
            wlen = wsprintf(ch, VEC_E_ARC, rx, ry, (short)X1, (short)Y1,
                            (short)X2, (short)Y2);
#if 0
// for opaque style line
            {
            BYTE chtmp[CCHMAXCMDLEN];

            wlen = wsprintf(chtmp, VEC_E_ARC, rx, ry, (short)X1, (short)Y1,
                            (short)X2, (short)Y2);

            if(lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 || !lpnp->wPenStyle)
            {
                WriteSpoolBuf(lpdv, chtmp, wlen);
                break;
            }

            if(lpnp->wPenColor == SG_BLACK)
            {
                WriteSpoolBuf(lpdv, VEC_LT_WHITE);
                WriteSpoolBuf(lpdv, chtmp, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
                WriteSpoolBuf(lpdv, chtmp, wlen);
            }
            else
            {
                WriteSpoolBuf(lpdv, VEC_LT_SOLID);
                WriteSpoolBuf(lpdv, chtmp, wlen);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
            }
            }
#endif
            break;

        case 3:
            wlen = wsprintf(ch, VEC_ELLIP, rx, ry, (short)X1, (short)Y1,
                            (short)X2, (short)Y2, n);
#if 0
// for opaque style line
            if(n == 1 || lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 ||
               !lpnp->wPenStyle)
            {
                WriteSpoolBuf(lpdv, ch, wlen);
                break;
            }

            if(lpnp->wPenColor == SG_BLACK)
            {
                WriteSpoolBuf(lpdv, VEC_LT_WHITE);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE_B, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_ELLIP, rx, ry, (short)X1, (short)Y1,
                                (short)X2, (short)Y2, 0);
                WriteSpoolBuf(lpdv, ch, wlen);
            }
            else
            {
                WriteSpoolBuf(lpdv, VEC_LT_SOLID);
                WriteSpoolBuf(lpdv, ch, wlen);
                wlen = wsprintf(ch, VEC_LT_STYLE, lpnp->wPenStyle);
                WriteSpoolBuf(lpdv, ch, wlen);
            }
#endif
            break;
        }

        WriteSpoolBuf(lpdv, ch, wlen);
    }
    break;
#endif

// *** Poly Vector Output PV *** //
    case PV_BEGIN:
        {
        int x, y;

        if(!lpdwParams) return;

        x = m2d((int)*lpdwParams, lpnp->wRes);
        y = m2d((int)*(lpdwParams + 1), lpnp->wRes);
        wlen = wsprintf(ch, VEC_BEGIN, x, y);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

    case PV_CONTINUE:
        {
        int x, y;

        if(!lpdwParams) return;

        x = m2d((int)*(lpdwParams + 4), lpnp->wRes);
        y = m2d((int)*(lpdwParams + 5), lpnp->wRes);
        wlen = wsprintf(ch, VEC_CONTINUE, x, y);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

#if 0
// for Poly Bezier
    case PV_BEGIN_BEZ:
        {
        int x, y;

        if(!lpdwParams) return;

        x = m2d((int)*lpdwParams, lpnp->wRes);
        y = m2d((int)*(lpdwParams + 1), lpnp->wRes);
        wlen = wsprintf(ch, VEC_BEGIN_BEZ, x, y);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;

    case PV_CONTINUE_BEZ:
        {
        int x1, y1, x2, y2, x3, y3;

        if(!lpdwParams) return;

        x1 = m2d((int)*(lpdwParams + 2), lpnp->wRes);
        y1 = m2d((int)*(lpdwParams + 3), lpnp->wRes);
        x2 = m2d((int)*(lpdwParams + 4), lpnp->wRes);
        y2 = m2d((int)*(lpdwParams + 5), lpnp->wRes);
        x3 = m2d((int)*(lpdwParams + 6), lpnp->wRes);
        y3 = m2d((int)*(lpdwParams + 7), lpnp->wRes);
        wlen = wsprintf(ch, VEC_CONTINUE_BEZ, x, y);
        WriteSpoolBuf(lpdv, ch, wlen);
        }
        break;
#endif

// *** Vector SupportVS *** //
    case VS_STROKE:
        lpnp->fStroke = TRUE;

        if(lpnp->fCurve == TRUE) return;

        WriteSpoolBuf(lpdv, VEC_STROKE);
#if 0
// for opaque style line
        if(lpnp->fTrans == TRUE || lpnp->wPenWidth > 1 || !lpnp->wPenStyle)
        {
            WriteSpoolBuf(lpdv, VEC_STROKE);
            return;
        }

        if(lpnp->wPenColor == SG_BLACK)
        {
            WriteSpoolBuf(lpdv, VEC_SG_PEN_W);
            wlen = wsprintf(ch, VEC_STROKE_OPA_W, (short)lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
            WriteSpoolBuf(lpdv, VEC_SG_PEN_B);
            WriteSpoolBuf(lpdv, VEC_STROKE);
        }
        else
        {
            wlen = wsprintf(ch, VEC_STROKE_OPA_W, (short)lpnp->wPenStyle);
            WriteSpoolBuf(lpdv, ch, wlen);
        }
#endif
        break;

#if 0
    case VS_WINDFILL:
        lpnp->fFill = TRUE;
        WriteSpoolBuf(lpdv, VEC_WINDFILL);
        break;
#endif

    case VS_ALTFILL:
        lpnp->fFill = TRUE;

        if(lpnp->fCurve == TRUE) return;

        WriteSpoolBuf(lpdv, VEC_ALTFILL);
        break;
    }
}


#ifndef WINNT
//-------------------------------------------------------------------
// Function: Enable()
// Action  : call UniEnable and setup Mdv
//-------------------------------------------------------------------
short CALLBACK Enable(
LPDV   lpdv,
WORD   style,
LPSTR  lpModel,
LPSTR  lpPort,
LPDM   lpStuff)
{
    CUSTOMDATA  cd;

    short         sRet;
    GLOBALHANDLE  hTmp;
    LPSTR         lpTmp;
    LPNPDL2MDV    lpnp;
    DWORD         dwMulti, dwType, dwData;

    cd.cbSize = sizeof(CUSTOMDATA);
    cd.hMd = GetModuleHandle((LPSTR)rgchModuleName);
    cd.fnOEMDump = NULL;
    cd.fnOEMOutputChar = NULL;

    sRet = UniEnable(lpdv, style, lpModel, lpPort, lpStuff, &cd);

    if(lpdv && lpdv->iType == BM_DEVICE && !lpdv->fMdv && sRet && !style)
    {
        hTmp = GlobalAlloc(GPTR, sizeof(NPDL2MDV));

        if(!hTmp) return sRet;

        lpTmp = GlobalLock(hTmp);

        if(!lpTmp)
        {
            GlobalFree(hTmp);
            return sRet;
        }

        lpdv->fMdv = TRUE;
        lpdv->lpMdv = lpTmp;
        lpnp = (LPNPDL2MDV)lpdv->lpMdv;
        lpnp->hKeep = hTmp;
        lpnp->wPenColor = SG_BLACK;
        lpnp->wBrStyle = PP_SOLID;
        lpnp->fStroke = FALSE;
        lpnp->fFill = FALSE;
        lpnp->fCurve = FALSE;
        lstrcpy(lpnp->szDevName, lpModel);

        if(DrvGetPrinterData(lpModel, MULTI_SCALE, &dwType, (LPBYTE)&dwMulti,
                             sizeof(DWORD), (LPDWORD)&dwData))
            dwMulti = 0;

        lpnp->dwMulti = dwMulti;
    }

    return sRet;
}

//-------------------------------------------------------------------
// Function: Disable()
// Action  : free Mdv and call Mdv
//-------------------------------------------------------------------
void WINAPI Disable(
LPDV lpdv)
{
    if(lpdv && lpdv->iType == BM_DEVICE && lpdv->fMdv)
    {
        LPNPDL2MDV  lpnp;

        lpnp = (LPNPDL2MDV)lpdv->lpMdv;
        GlobalUnlock(lpnp->hKeep);
        GlobalFree(lpnp->hKeep);
    }

    UniDisable(lpdv);
}
#endif // WINNT

#ifdef WINNT

short OEMOutputChar( lpdv, lpstr, len, rcID )
LPDV    lpdv;
LPSTR   lpstr;
WORD    len;
WORD    rcID;
{
    WORD        wlen;
    WORD        i;
    WORD        wTmpChar;
    LPSTR       lpTmpStr;
    BYTE        ch[512];
    LPNPDL2MDV  lpnp;
    BOOL        fDBCSFont;

    wlen = 0;
    lpTmpStr = lpstr;

    lpnp = (LPNPDL2MDV)lpdv->lpMdv;

    if( rcID != lpnp->wOldFontID )
    {
        lpnp->wCurrentAddMode = 0;
        lpnp->wOldFontID = rcID;
    }

    switch(rcID)
    {
    case 5: // Courier
    case 6: // Helv
    case 7: // TmsRmn
    case 8: // TmsRmn Italic
        fDBCSFont = FALSE;
        break;

    default:
        fDBCSFont = TRUE;
    }

    for(i = 0; i < len;i ++)
    {
        if((fDBCSFont == TRUE) && IsDBCSLeadByteNPDL(*lpTmpStr))
        {
            if(lpnp->wCurrentAddMode != FLAG_DBCS)
            {
                WORD        wLen;
                BYTE        cH[CCHMAXCMDLEN];

                wLen = wsprintf(cH, FS_ADDRMODE_ON, lpnp->sDBCSXMove,
                                lpnp->sDBCSYMove);
                WriteSpoolBuf(lpdv, cH, wLen);

                if(lpnp->fVertFont)
                {
                    WriteSpoolBuf(lpdv, ESC_KANJITATE);

                    if(lpnp->wScale != 1)
                    {


                        if(!lpnp->fPlus)
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1", "8/1"};

                            wLen = wsprintf(cH, FS_M_T, (LPSTR)bcom[lpnp->wScale]);
                        }
                        else  wLen = wsprintf(cH, FS_12S2, lpnp->lPointsy, lpnp->lPointsx);

                        WriteSpoolBuf(lpdv, cH, wLen);
                    }
                }
                lpnp->wCurrentAddMode = FLAG_DBCS;
            }
            wTmpChar  = SJis2JisNPDL(SWAPW((WORD)*(LPWORD)lpTmpStr));
            *(LPWORD)(ch+wlen) = SWAPW(wTmpChar);
            wlen+=2;
            lpTmpStr+=2;
            i++;
        }
        else
        {
            if(lpnp->wCurrentAddMode != FLAG_SBCS)
            {
                WORD        wLen;
                BYTE        cH[CCHMAXCMDLEN];

                wLen = wsprintf(cH, FS_ADDRMODE_ON, lpnp->sSBCSXMove,
                                lpnp->sSBCSYMove);
                WriteSpoolBuf(lpdv, cH, wLen);

                if(lpnp->fVertFont)
                {
                    WriteSpoolBuf(lpdv, ESC_KANJIYOKO);

                    if(lpnp->wScale != 1)
                    {

                        if(!lpnp->fPlus)
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1", "8/1"};

                            wLen = wsprintf(cH, FS_M_Y, (LPSTR)bcom[lpnp->wScale]);
                        }
                        else wLen = wsprintf(cH, FS_12S2, lpnp->lPointsx, lpnp->lPointsy);

                        WriteSpoolBuf(lpdv, cH, wLen);
                    }
                }
                lpnp->wCurrentAddMode = FLAG_SBCS;

            }
            wTmpChar = (WORD)((0x00ff)&(*lpTmpStr));
            if (!fDBCSFont) {
                 wTmpChar = Ltn1ToAnk( wTmpChar );
            }
            *(LPWORD)(ch+wlen) = SWAPW(wTmpChar);
            wlen+=2;
            lpTmpStr++;
        }
    }

    WriteSpoolBuf(lpdv, ch, wlen);
    return wlen;
}
/*************************** Function Header *******************************
 *  MiniDrvEnablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
BOOL
MiniDrvEnablePDEV(
LPDV      lpdv,
ULONG    *pdevcaps)
{
    int                    i;
    LPSTR                  lpTmp;
    LPNPDL2MDV    lpnp;

    lpTmp = UniDrvAllocMem(sizeof(NPDL2MDV));

    if(!lpTmp)
    {
        return FALSE;
    }

    lpdv->fMdv = TRUE;
    lpdv->lpMdv = lpTmp;
    lpnp = (LPNPDL2MDV)lpdv->lpMdv;
    lpnp->wPenColor = SG_BLACK;
    lpnp->wBrStyle = PP_SOLID;
    lpnp->fStroke = FALSE;
    lpnp->fFill = FALSE;
    lpnp->fCurve = FALSE;
    lpnp->dwMulti = 0;
    lpnp->fComp = FALSE;
    lpnp->Color = 0;
    lpnp->wCurrentAddMode = 0;
    lpnp->wOldFontID = 0;

    // Check if user selects MONO
    if( (((PGDIINFO)pdevcaps)->cBitsPixel == 1) &&
        (((PGDIINFO)pdevcaps)->cPlanes == 1))
        lpnp->fMono = TRUE;
    else{
        lpnp->fMono = FALSE;
    }

    return TRUE;


}

/*************************** Function Header *******************************
 *  MiniDrvDisablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
VOID
MiniDrvDisablePDEV(
LPDV lpdv)
{
    LPNPDL2MDV    lpnp;


    if ( lpdv && lpdv->fMdv )
    {
        UniDrvFreeMem( lpdv->lpMdv );
    }


}

DRVFN
MiniDrvFnTab[] =
{
    {  INDEX_MiniDrvEnablePDEV,       (PFN)MiniDrvEnablePDEV  },
    {  INDEX_MiniDrvDisablePDEV,      (PFN)MiniDrvDisablePDEV  },
    {  INDEX_OEMWriteSpoolBuf,        (PFN)CBFilterGraphics  },
    {  INDEX_OEMSendScalableFontCmd,  (PFN)OEMSendScalableFontCmd  },
    {  INDEX_OEMGetFontCmd,           (PFN)fnOEMGetFontCmd  },
    {  INDEX_OEMOutputCmd,            (PFN)fnOEMOutputCmd  },
    {  INDEX_OEMOutputChar,           (PFN)OEMOutputChar  },
    {  INDEX_OEMTTBitmap,             (PFN)fnOEMTTBitmap  }
};

BOOL
MiniDrvEnableDriver(
    MINIDRVENABLEDATA  *pEnableData
    )
{
    if (pEnableData == NULL)
        return FALSE;

    if (pEnableData->cbSize == 0)
    {
        pEnableData->cbSize = sizeof (MINIDRVENABLEDATA);
        return TRUE;
    }

    if (pEnableData->cbSize < sizeof (MINIDRVENABLEDATA)
            || HIBYTE(pEnableData->DriverVersion)
            < HIBYTE(MDI_DRIVER_VERSION))
    {
        // Wrong size and/or mismatched version
        return FALSE;
    }

    // Load callbacks provided by the Unidriver

    if (!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvWriteSpoolBuf, (PFN *) &WriteSpoolBuf)
        ||!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvAllocMem, (PFN *) &UniDrvAllocMem)
        ||!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvFreeMem, (PFN *) &UniDrvFreeMem))
    {
        return FALSE;
    }

    pEnableData->cMiniDrvFn
        = sizeof (MiniDrvFnTab) / sizeof(MiniDrvFnTab[0]);
    pEnableData->pMiniDrvFn = MiniDrvFnTab;

    return TRUE;
}

#endif //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
// SECURITY:#553895: Mandatory changes (e.g. strsafe.h)
#include <strsafe.h>

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'KYP5'      // KYOCERA
#define DLLTEXT(s)      "KYP5: " s
#define OEM_VERSION      0x00010000L

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER	dmExtraHdr;
    // Private extention
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);


#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

MAJORCOMP=windows
MINORCOMP=md_kyp5jres

!ifndef PRNROOT
PRNROOT=$(MAKEDIR:\gpdres\kyp5jres=)
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR_KY=$(PRNROOT)\gpd\kyo\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=kyp5jres
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),kyp5jres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc;

C_DEFINES=$(C_DEFINES) -DUNICODE

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\kyp5jres.rc \
    $(SRCDIR)\kyp5jres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(GPDDIR_KY)\kylm180j.gpd \
    $(GPDDIR_KY)\kylm380j.gpd \
    $(GPDDIR_KY)\kylm630j.gpd \
    $(GPDDIR_KY)\kylm670j.gpd \
    $(GPDDIR_KY)\kylm67sj.gpd \
    $(GPDDIR_KY)\kylm680j.gpd \
    $(GPDDIR_KY)\kylm700j.gpd \
    $(GPDDIR_KY)\kylm770j.gpd \
    $(GPDDIR_KY)\kylm900j.gpd \
    $(GPDDIR_KY)\kyls170j.gpd \
    $(GPDDIR_KY)\kyls180j.gpd \
    $(GPDDIR_KY)\kyls370j.gpd \
    $(GPDDIR_KY)\kyls380j.gpd \
    $(GPDDIR_KY)\kyls630j.gpd \
    $(GPDDIR_KY)\kyls670j.gpd \
    $(GPDDIR_KY)\kyls67sj.gpd \
    $(GPDDIR_KY)\kyls680j.gpd \
    $(GPDDIR_KY)\kyls700j.gpd \
    $(GPDDIR_KY)\kyls770j.gpd \
    $(GPDDIR_KY)\kyls800j.gpd \
    $(GPDDIR_KY)\kyls900j.gpd \
    ..\kyp5jres.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

// NOTICE-2002/3/11-takashim
//     04/07/97 -zhanw-
//         Created it.
 
--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
#if DBG
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));
#endif // DBG

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote size of DWORD bytes.
    *pcbNeeded = sizeof(DWORD);

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (sizeof(DWORD) > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
#if DBG
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));
#endif // DBG

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            WARNING(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
// NOTICE-2002/3/11-takashim
// //              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));
        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        WARNING(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
// NOTICE-2002/3/11-takashim
// //              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please make sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
    "CommandCallback",
    "DevMode",
    "GetImplementedMethod",
    "GetInfo",
};

// Maximum lenth of the method name which this
// plug-in has concern.
#define MAX_METHODNAME 21 // "GetImplementedMethod"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\kyp5jres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

// NOTICE-2002/3/11-takashim
//     04/07/97 -zhanw-
//         Created it.

--*/

#include "pdev.h"

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
// NOTICE-2002/3/11-takashim
// //              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
// NOTICE-2002/3/11-takashim
// //          02/11/97        APresley Created.
// //          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
    }

    return TRUE;
}

#define MINJOBLEN       48
#define MAX_NAMELEN     31

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

//
// Command callback ID's
//

// Do not reorder the following CMD_BARCODEPOS_X group.
#define CMD_BARCODEPOS_0        100
#define CMD_BARCODEPOS_1        101
#define CMD_BARCODEPOS_2        102
#define CMD_BARCODEPOS_3        103
#define CMD_BARCODEPOS_4        104
#define CMD_BARCODEPOS_5        105
#define CMD_BARCODEPOS_6        106
#define CMD_BARCODEPOS_7        107
#define CMD_BARCODEPOS_8        108


// SECURITY:#553895: Mandatory changes (e.g. strsafe.h)
/*
 *  OEMCommandCallback
 */
INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT         iRet = 0;
    INT         iBCID;
    INT         iDocument;
    INT         iDocuTemp;
    INT         iUserName;
    INT         iUserTemp;
    DWORD       cbNeeded = 0;
    DWORD       cReturned = 0;
    DWORD       CmdSize;
    PBYTE       pCmd = NULL;
    PBYTE       pDocument = NULL;
    PBYTE       pUserName = NULL;
    PBYTE       pTemp, pNext, pEnd;
    PJOB_INFO_1 pJobInfo = NULL;
    FILETIME    ft, lft;
    SYSTEMTIME  st;
    BYTE        ch[MINJOBLEN];
    PBYTE       pch;

    VERBOSE(("OEMCommandCallback entry - %d, %d\r\n", dwCmdCbID, dwCount));

    ASSERT(VALID_PDEVOBJ(pdevobj));

    switch (dwCmdCbID) {

    case CMD_BARCODEPOS_0:
    case CMD_BARCODEPOS_1:
    case CMD_BARCODEPOS_2:
    case CMD_BARCODEPOS_3:
    case CMD_BARCODEPOS_4:
    case CMD_BARCODEPOS_5:
    case CMD_BARCODEPOS_6:
    case CMD_BARCODEPOS_7:
    case CMD_BARCODEPOS_8:

        iBCID = (dwCmdCbID - CMD_BARCODEPOS_0);

        //
        // Get the first JOB info
        //
        if (0 != EnumJobs(pdevobj->hPrinter, 0, 1, 1, NULL, 0,
                &cbNeeded, &cReturned)
            || ERROR_INSUFFICIENT_BUFFER != GetLastError()
            || 0 == cbNeeded) {

            goto out;
        }

        if ((pJobInfo = (PJOB_INFO_1)MemAlloc(cbNeeded)) == NULL)
            goto out;

        if (!EnumJobs(pdevobj->hPrinter, 0, 1, 1, (LPBYTE)pJobInfo, cbNeeded,
            &cbNeeded, &cReturned))
            goto out;

        // Convert to multi-byte

        iDocument = WideCharToMultiByte(CP_ACP, 0, pJobInfo->pDocument, -1,
            NULL, 0, NULL, NULL);
        if (!iDocument)
            goto out;
        if ((pDocument = (PBYTE)MemAlloc(iDocument)) == NULL)
            goto out;
        if (!WideCharToMultiByte(CP_ACP, 0, pJobInfo->pDocument, -1,
            pDocument, iDocument, NULL, NULL))
            goto out;

        pTemp = pDocument;
        pEnd = &pDocument[min(iDocument - 1, MAX_NAMELEN)];
        while (*pTemp) {
            // Make sure it is the same context as WideCharTo...
            pNext = CharNextExA(CP_ACP, pTemp, 0);
            if (pNext > pEnd)
                break;
            pTemp = pNext;
        }
        iDocument = (INT)(pTemp - pDocument);
        pDocument[iDocument] = '\0';

        // Convert to multi-byte

        iUserName = WideCharToMultiByte(CP_ACP, 0, pJobInfo->pUserName, -1,
            NULL, 0, NULL, NULL);
        if (!iUserName)
            goto out;
        if ((pUserName = (PBYTE)MemAlloc(iUserName)) == NULL)
            goto out;
        if (!WideCharToMultiByte(CP_ACP, 0, pJobInfo->pUserName, -1,
            pUserName, iUserName, NULL, NULL))
            goto out;

        pTemp = pUserName;
        pEnd = &pUserName[min(iUserName - 1, MAX_NAMELEN)];
        while (*pTemp) {
            // Make sure it is the same context as WideCharTo...
            pNext = CharNextExA(CP_ACP, pTemp, 0);
            if (pNext > pEnd)
                break;
            pTemp = pNext;
        }
        iUserName = (INT)(pTemp - pUserName);
        pUserName[iUserName] = '\0';

        // Convert to local time
        if (!SystemTimeToFileTime(&pJobInfo->Submitted, &ft)
                || !FileTimeToLocalFileTime(&ft, &lft)
                || !FileTimeToSystemTime(&lft, &st)) {

            goto out;
        }

        // Output commands
        CmdSize = 10 +  // barcode position and share
            iDocument + // document name
            iUserName + // user name
            16 +        // Date & Time
            32;         // Other characters
        if ((pCmd = (PBYTE)MemAlloc(CmdSize)) == NULL)
            goto out;
        if (FAILED(StringCchPrintfExA(pCmd, CmdSize, &pch, NULL, 0,
            "%d,0,\"%s\",\"%s\",\"%4d/%02d/%02d %02d:%02d\";EXIT;",
            iBCID, pDocument, pUserName,
            st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute)))
            goto out;
        WRITESPOOLBUF(pdevobj, pCmd, (DWORD)(pch - pCmd));
        goto done;

out:
        if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, NULL, 0,
            "%d,0,\"Windows2000\",\"Kyocera\",\"\";EXIT;",
            iBCID)))
            goto done;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

done:
        if (pCmd) MemFree(pCmd);
        if (pUserName) MemFree(pUserName);
        if (pDocument) MemFree(pDocument);
        if (pJobInfo) MemFree(pJobInfo);

        break;
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\kyp5jres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

// NOTICE-2002/3/11-takashim
//         98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

// NTRAID#NTBUG9-588579-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            (NULL == p1 ? "" : *((char **)p1)),
            (NULL == p2 ? "" : *((char **)p2)));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        HRESULT hRet = E_NOTIMPL;
        PSTR pTemp;

        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (SUCCEEDED(StringCchLengthA(
                pMethodName, MAX_METHODNAME, NULL))) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                hRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, hRet = %d\n"), pMethodName, hRet));

        return hRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

// SECURITY:#553895: Mandatory changes (e.g. strsafe.h)
        if (*piResult >= 0)
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\lggdires\lgcomp.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

// NTRAID#NTBUG9-553896-2002/03/19-yasuho-: mandatory changes

#include "pdev.h"
#include "lgcomp.h"

//
// File: LGCOMP.C
//
// Implementations of LG compression algprithms on the
// LG "Raster 1" printers.
//
// printer command:
//     <9B>I{type}#{compressed data length}{compressed data}
//
// type can be:
//   <01> RLE
//   <02> MHE
//

// For MHE debugging.
#define MHEDEBUG 0
//#define MHEDEBUG 1
//#define MHEDEBUGPATTERN 0x81
#define MHEDEBUGPATTERN 0xff

//
// LG RLE compression.  See comments for the details.
//
// You MUST call this function with @pOutBuf is NULL at first.
// Then you can get the enough size of @pOutBuf by the return value.
// Then you should make sure if the buffer size is enough.
// Then call this function again with the actual pointer of @pOutBuf.
INT
LGCompRLE(
    PBYTE pOutBuf,
    PBYTE pSrcBuf, DWORD iSrcBuf,
    INT iMode)
{
    PBYTE pMaxSrcBuf = pSrcBuf + iSrcBuf;
    INT iOutLen = 0, iRun;
    BYTE jTemp;
    PBYTE pSize;

    // Embedd print command if requested.
    if (iMode == 1) {

        // LG Raster 1 
        if (pOutBuf) {
            *pOutBuf++ = (BYTE)'\x9B';
            *pOutBuf++ = (BYTE)'I';
            *pOutBuf++ = COMP_RLE;
            pSize = pOutBuf++;
            pOutBuf++;
       }
       iOutLen += 5;
    }

    while (pSrcBuf < pMaxSrcBuf) {

        // Get Run length.

        jTemp = *pSrcBuf;
        for (iRun = 1; pSrcBuf + iRun < pMaxSrcBuf; iRun++) {
            if (*(pSrcBuf + iRun) != jTemp)
                break;
        }

        // iRun == N means N consective bytes
        // of the same value exists.

        if (iRun > 1) {

            // Run > 1.

            while (iRun >= 0x82) {

                iRun -= 0x82;
                iOutLen += 2;
                if (pOutBuf) {

                    // Mark <- 0x80,
                    // length = 0x82.
                    *pOutBuf++ = 0x80;
                    *pOutBuf++ = jTemp;
                }
                pSrcBuf += 0x82;
            }

            // iRun less than 3 will be output as "copy" block.

            if (iRun >= 3) {

                iOutLen += 2;
                if (pOutBuf) {

                    // Mark <- 0x81 to 0xff,
                    // length = 0x81 to 3.
                    *pOutBuf++ = (0x102 - iRun);
                    *pOutBuf++ = jTemp;
                }
            }
            else if (iRun > 0) {

                iOutLen += (1 + iRun);
                if (pOutBuf) {
                    *pOutBuf++ = (iRun - 1);
                    memcpy(pOutBuf, pSrcBuf, iRun);
                    pOutBuf += iRun;
                }
            }
            pSrcBuf += iRun;

            // Go to the next around.
            continue;
        }

        // Get "different" Run length.  We already know
        // pSrcBuf[0] != pSrcBuf[1].

        for (iRun = 1; pSrcBuf + iRun < pMaxSrcBuf; iRun++) {
            if ((pSrcBuf + iRun + 1 < pMaxSrcBuf) &&
                    (*(pSrcBuf + iRun) == *(pSrcBuf + iRun + 1))) {
                break;
            }
        }

        for (; iRun >= 0x80; iRun -= 0x80) {
            iOutLen += (1 + 0x80);
            if (pOutBuf) {

                // Mark <- 0x7f,
                // copy = 0x80.
                *pOutBuf++ = 0x7f;
                memcpy(pOutBuf, pSrcBuf, 0x80);
                pOutBuf += 0x80;
            }
            pSrcBuf += 0x80;
        }

        if (iRun > 0) {
            iOutLen += (1 + iRun);
            if (pOutBuf) {

                // Mark <- 0x7e to 0,
                // copy = 0x7f to 1.
                *pOutBuf++ = (iRun - 1);
                memcpy(pOutBuf, pSrcBuf, iRun);
                pOutBuf += iRun;
            }
            pSrcBuf += iRun;
        }
    }

    // Embed size information if requested.
    if (iMode == 1) {
        if (pOutBuf) {
            *pSize++ = (BYTE)((iOutLen - 5) >> 8);
            *pSize++ = (BYTE)(iOutLen - 5);
        }
    }

    return iOutLen;
}

//
// MHE compression.  See comments for the details.
//

typedef struct {
    DWORD cswd;    /* compressing signed word */
    INT vbln;    /* cswd's valid bits length, count from MSB */
} ENCfm;                    /* ENC. form */

ENCfm pWhiteTermTbl[64] = {    /* Terminating Code Table (White)*/
    {0x35000000,  8},{0x1c000000,  6},{0x70000000,  4},{0x80000000,  4},
    {0xb0000000,  4},{0xc0000000,  4},{0xe0000000,  4},{0xf0000000,  4},
    {0x98000000,  5},{0xa0000000,  5},{0x38000000,  5},{0x40000000,  5},
    {0x20000000,  6},{0x0c000000,  6},{0xd0000000,  6},{0xd4000000,  6},
    {0xa8000000,  6},{0xac000000,  6},{0x4e000000,  7},{0x18000000,  7},
    {0x10000000,  7},{0x2e000000,  7},{0x06000000,  7},{0x08000000,  7},
    {0x50000000,  7},{0x56000000,  7},{0x26000000,  7},{0x48000000,  7},
    {0x30000000,  7},{0x02000000,  8},{0x03000000,  8},{0x1a000000,  8},
    {0x1b000000,  8},{0x12000000,  8},{0x13000000,  8},{0x14000000,  8},
    {0x15000000,  8},{0x16000000,  8},{0x17000000,  8},{0x28000000,  8},
    {0x29000000,  8},{0x2a000000,  8},{0x2b000000,  8},{0x2c000000,  8},
    {0x2d000000,  8},{0x04000000,  8},{0x05000000,  8},{0x0a000000,  8},
    {0x0b000000,  8},{0x52000000,  8},{0x53000000,  8},{0x54000000,  8},
    {0x55000000,  8},{0x24000000,  8},{0x25000000,  8},{0x58000000,  8},
    {0x59000000,  8},{0x5a000000,  8},{0x5b000000,  8},{0x4a000000,  8},
    {0x4b000000,  8},{0x32000000,  8},{0x33000000,  8},{0x34000000,  8}
};

ENCfm pBlackTermTbl[64] = {    /* Terminating Code Table (Black) */
    {0x0dc00000, 10},{0x40000000,  3},{0xc0000000,  2},{0x80000000,  2},
    {0x60000000,  3},{0x30000000,  4},{0x20000000,  4},{0x18000000,  5},
    {0x14000000,  6},{0x10000000,  6},{0x08000000,  7},{0x0a000000,  7},
    {0x0e000000,  7},{0x04000000,  8},{0x07000000,  8},{0x0c000000,  9},
    {0x05c00000, 10},{0x06000000, 10},{0x02000000, 10},{0x0ce00000, 11},
    {0x0d000000, 11},{0x0d800000, 11},{0x06e00000, 11},{0x05000000, 11},
    {0x02e00000, 11},{0x03000000, 11},{0x0ca00000, 12},{0x0cb00000, 12},
    {0x0cc00000, 12},{0x0cd00000, 12},{0x06800000, 12},{0x06900000, 12},
    {0x06a00000, 12},{0x06b00000, 12},{0x0d200000, 12},{0x0d300000, 12},
    {0x0d400000, 12},{0x0d500000, 12},{0x0d600000, 12},{0x0d700000, 12},
    {0x06c00000, 12},{0x06d00000, 12},{0x0da00000, 12},{0x0db00000, 12},
    {0x05400000, 12},{0x05500000, 12},{0x05600000, 12},{0x05700000, 12},
    {0x06400000, 12},{0x06500000, 12},{0x05200000, 12},{0x05300000, 12},
    {0x02400000, 12},{0x03700000, 12},{0x03800000, 12},{0x02700000, 12},
    {0x02800000, 12},{0x05800000, 12},{0x05900000, 12},{0x02b00000, 12},
    {0x02c00000, 12},{0x05a00000, 12},{0x06600000, 12},{0x06700000, 12}
};
ENCfm pWhiteMkupTbl[41] = {    /* Make-up Code Table (White) */
    {0x00100000, 12},{0xd8000000,  5},{0x90000000,  5},{0x5c000000,  6},
    {0x6e000000,  7},{0x36000000,  8},{0x37000000,  8},{0x64000000,  8},
    {0x65000000,  8},{0x68000000,  8},{0x67000000,  8},{0x66000000,  9},
    {0x66800000,  9},{0x69000000,  9},{0x69800000,  9},{0x6a000000,  9},
    {0x6a800000,  9},{0x6b000000,  9},{0x6b800000,  9},{0x6c000000,  9},
    {0x6c800000,  9},{0x6d000000,  9},{0x6d800000,  9},{0x4c000000,  9},
    {0x4c800000,  9},{0x4d000000,  9},{0x60000000,  6},{0x4d800000,  9},
    {0x01000000, 11},{0x01800000, 11},{0x01a00000, 11},{0x01200000, 12},
    {0x01300000, 12},{0x01400000, 12},{0x01500000, 12},{0x01600000, 12},
    {0x01700000, 12},{0x01c00000, 12},{0x01d00000, 12},{0x01e00000, 12},
    {0x01f00000, 12}
};
ENCfm pBlackMkupTbl[41] = {    /* Make-up Code Table (Black) */
    {0x00100000, 12},{0x03c00000, 10},{0x0c800000, 12},{0x0c900000, 12},
    {0x05b00000, 12},{0x03300000, 12},{0x03400000, 12},{0x03500000, 12},
    {0x03600000, 13},{0x03680000, 13},{0x02500000, 13},{0x02580000, 13},
    {0x02600000, 13},{0x02680000, 13},{0x03900000, 13},{0x03980000, 13},
    {0x03a00000, 13},{0x03a80000, 13},{0x03b00000, 13},{0x03b80000, 13},
    {0x02900000, 13},{0x02980000, 13},{0x02a00000, 13},{0x02a80000, 13},
    {0x02d00000, 13},{0x02d80000, 13},{0x03200000, 13},{0x03280000, 13},
    {0x01000000, 11},{0x01800000, 11},{0x01a00000, 11},{0x01200000, 12},
    {0x01300000, 12},{0x01400000, 12},{0x01500000, 12},{0x01600000, 12},
    {0x01700000, 12},{0x01c00000, 12},{0x01d00000, 12},{0x01e00000, 12},
    {0x01f00000, 12}
};


#define DIV8(k) ((k) >> 3)
#define MOD8(k) ((k) & 7)
#define MUL8(k) ((k) << 3)
#define DIV64(k) ((k) >> 6)
#define MOD64(k) ((k) & 63)

BOOL
ScanBits(
    PBYTE pSrc,
    INT iOffset,
    DWORD dwMaxSrc,
    PDWORD pdwRunLength
)
{
    BOOL bBlack;
    BYTE jTemp, jMask;
    PBYTE pMaxSrc = pSrc + dwMaxSrc;
    INT k;
    DWORD dwRunLength = 0;

    // The 1st byte.
    jTemp = *pSrc++;
#if MHEDEBUG
    jTemp = MHEDEBUGPATTERN;
#endif // MHEDEBUG
    bBlack = ((jTemp & (0x80 >> iOffset)) != 0);
    if (!bBlack) {
        jTemp = ~jTemp;
    }

    // fill previous bits.
    jTemp |= ~(0xff >> iOffset);

    // ...interlim bytes.
    jMask = 0xff;
    for (; pSrc < pMaxSrc; pSrc++) {
        if (jTemp != jMask)
            break;
        dwRunLength += 8;
        jTemp = *pSrc;
#if MHEDEBUG
    jTemp = MHEDEBUGPATTERN;
#endif // MHEDEBUG
        if (!bBlack) {
            jTemp = ~jTemp;
        }
    }

    // The last byte.
    jMask = ~0x80;
    for (k = 0; k < 8; k++) {
    
        if ((jTemp | jMask) != 0xff)
            break;
        jMask >>= 1;
    }
    dwRunLength += k;

    // Return results to the caller.
    *pdwRunLength = (dwRunLength - iOffset);
    return bBlack;
}

VOID
CopyBits(
    PBYTE pBuffer,
    INT iOffset,
    DWORD dwPattern,
    INT iPatternLength
)
{
    INT iNumberOfBytes, k;
    DWORD dwTemp;

    // Decide how many bytes we are to modify.
    iNumberOfBytes = DIV8(iOffset + iPatternLength + 7);

    // Make the pattern mask.
    dwPattern >>= iOffset;

    // Read in a byte if necessary.
    if (iOffset > 0) {
        dwTemp = (*pBuffer << 24);
        dwTemp &= ~((DWORD)~0 >> iOffset);
    }
    else {
        dwTemp = 0;
    }
    dwTemp |= dwPattern;

    // Write back.
    for (k = 3; k >= iNumberOfBytes; k--) {
        dwTemp >>= 8;
    }
    for (; k >= 0; k--) {
        *(pBuffer + k) = (BYTE)(dwTemp & 0xff);
        dwTemp >>= 8;
    }
}

// You MUST call this function with @pOutBuf is NULL at first.
// Then you can get the enough size of @pOutBuf by the return value.
// Then you should make sure if the buffer size is enough.
// Then call this function again with the actual pointer of @pOutBuf.
INT
LGCompMHE(
    PBYTE pBuf,
    PBYTE pSrcBuf,
    DWORD dwMaxSrcBuf,
    INT iMode)
{
    DWORD dwSrcOffset = 0;
    DWORD dwOffset = 0;
    ENCfm *pMkupTbl, *pTermTbl;
    DWORD dwRunLength;
    INT k;
    BOOL bBlack;
    DWORD dwMaxSrcOffset = MUL8(dwMaxSrcBuf);
    PBYTE pSize;
    DWORD dwLength;

    // Embed print command if requested.
    if (iMode == 1) {

        // LG Raster 1 
        if (pBuf) {
            *(pBuf) = (BYTE)'\x9B';
            *(pBuf + 1) = (BYTE)'I';
            *(pBuf + 2) = COMP_MHE;
            pSize = (pBuf + 3);
            // 1 byte more.
        }
        dwOffset += 40;
    }

    while (dwSrcOffset < dwMaxSrcOffset) {

        bBlack = ScanBits(
            (pSrcBuf + DIV8(dwSrcOffset)),
            MOD8(dwSrcOffset),
            DIV8(dwMaxSrcOffset - dwSrcOffset + 7),
            &dwRunLength);

        VERBOSE(("LGCompMHE: %d, %d, %d (%d / %d)\n",
            dwOffset, dwRunLength, bBlack,
            dwSrcOffset, dwMaxSrcOffset));

        if (dwSrcOffset == 0 && bBlack) {

            // The 1st code in the data must be white encoding data.
            // So, we will insert "0 byte white run" record when the
            // data does not begin with white.

            dwLength = pWhiteTermTbl[0].vbln;
            if (pBuf) {
                CopyBits(
                    (pBuf + DIV8(dwOffset)),
                    MOD8(dwOffset),
                    pWhiteTermTbl[0].cswd,
                    dwLength);
            }
            dwOffset += dwLength;
        }

        if (dwRunLength >= 2624) {

            if (pBuf) {
                CopyBits(
                    (pBuf + DIV8(dwOffset)),
                    MOD8(dwOffset),
                    0x01f00000, 12);
            }
            dwOffset += 12;

            if (bBlack) {

                if (pBuf) {
                    CopyBits(
                        (pBuf + DIV8(dwOffset)),
                        MOD8(dwOffset),
                        0x06700000, 12);
                }
                dwOffset += 12;

                if (pBuf) {
                    CopyBits(
                        (pBuf + DIV8(dwOffset)),
                        MOD8(dwOffset),
                        0x35000000, 8);
                }
                dwOffset += 8;
            }
            else {

                if (pBuf) {
                    CopyBits(
                        (pBuf + DIV8(dwOffset)),
                        MOD8(dwOffset),
                        0x34000000, 8);
                }
                dwOffset += 8;

                if (pBuf) {
                    CopyBits(
                        (pBuf + DIV8(dwOffset)),
                        MOD8(dwOffset),
                        0x0dc00000, 10);
                }
                dwOffset += 10;
            }
            dwRunLength -= 2623;
        }

        if (bBlack) {
            pMkupTbl = pBlackMkupTbl;
            pTermTbl = pBlackTermTbl;
        }
        else {
            pMkupTbl = pWhiteMkupTbl;
            pTermTbl = pWhiteTermTbl;
        }

        if (dwRunLength >= 64) {

            dwLength = pMkupTbl[DIV64(dwRunLength)].vbln;
            if (pBuf) {
                CopyBits((pBuf + DIV8(dwOffset)),
                    MOD8(dwOffset),
                    pMkupTbl[DIV64(dwRunLength)].cswd,
                    dwLength);
            }
            dwOffset += dwLength;
        }

        dwLength = pTermTbl[MOD64(dwRunLength)].vbln;
        if (pBuf) {
            CopyBits(
                (pBuf + DIV8(dwOffset)),
                MOD8(dwOffset),
                pTermTbl[MOD64(dwRunLength)].cswd,
                dwLength);
        }
        dwOffset += dwLength;

        // Next
        dwSrcOffset += dwRunLength;
    }

    // Convert unit into # of bytes.
    dwOffset = DIV8(dwOffset + 7);

    // Embed size information if requested.
    if (iMode == 1) {
        if (pBuf) {
            *pSize++ = (BYTE)((dwOffset - 5) >> 8);
            *pSize++ = (BYTE)(dwOffset - 5);
        }
    }

    return (INT)dwOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\lggdires\lgcomp.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#ifndef _LGCOMP_H
#define _LGCOMP_H

#include <minidrv.h>

#define COMP_NONE 0
#define COMP_RLE  1
#define COMP_MHE   2

extern INT LGCompMHE(PBYTE, PBYTE, DWORD, INT);
extern INT LGCompRLE(PBYTE, PBYTE, DWORD, INT);

#endif // _LGCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\lggdires\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

// NTRAID#NTBUG9-553896-2002/03/19-yasuho-: mandatory changes

#include <minidrv.h>
#include <pdev.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\lggdires\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

// NTRAID#NTBUG9-588580-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods


#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {
    	if (ppv == NULL) return E_NOINTERFACE;

        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

		// Parameters will be check in this function, OEMGetInfo().
        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

		// Parameters will be check in this function, OEMGetInfo().
        if (OEMDevMode(dwMode, pOemDMParam))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

			if (pIUnknown == NULL) return E_FAIL;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

		// Added to check the NULL pointer.
		if (pdevobj == NULL) return E_FAIL;
		if (piResult == NULL) return E_FAIL;

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

		if (*piResult < 0)
			return E_FAIL;
		else
	        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));

		if (piResult == NULL) return E_FAIL;

        *piResult = OEMCompression(
                pdevobj, pInBuf, pOutBuf, dwInLen, dwOutLen);
        if (*piResult > 0)
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
    	if (ppv == NULL) return E_NOINTERFACE;

        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\lggdires\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"


DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                            "OUT OF RANGE",
                        };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo < 4? dwInfo: 4]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                    "OUT OF RANGE",
                                };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode < 5? dwMode: 5]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n")));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING,("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DBGPRINT(DBG_WARNING,("\tcbSize = %d.\r\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING,("\thPrinter = %#lx.\r\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING,("\thModule = %#lx.\r\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING,("\tpPublicDMIn = %#lx.\r\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING,("\tpPublicDMOut = %#lx.\r\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING,("\tpOEMDMIn = %#lx.\r\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING,("\tpOEMDMOut = %#lx.\r\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING,("\tcbBufSize = %d.\r\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\lggdires\lggdires.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->bComp = FALSE;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn && pdmOut) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->bComp = pdmIn->bComp;
    }

    return TRUE;
}

#define MASTER_UNIT 600

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

//
// Command callback ID's
//

#define CMD_XMOVE_ABS           10 // X-move Absolute
#define CMD_YMOVE_ABS           11 // Y-move Absolute
#define CMD_CR                  12
#define CMD_LF                  13
#define CMD_SEND_BLOCK_DATA     14
#define CMD_ENABLE_OEM_COMP     15
#define CMD_DISALBE_COMP        16

INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT        i;
    BYTE        Cmd[16];
    DWORD dwDestX, dwDestY;
    DWORD dwDataWidth;
    DWORD dwDataSize;
    INT iRet = 0;

    POEMUD_EXTRADATA lpOemData;

    VERBOSE(("OEMCommandCallback entry - %d, %d\r\n",
        dwCmdCbID, dwCount));

    //
    // verify pdevobj okay
    //

    ASSERT(VALID_PDEVOBJ(pdevobj));

    lpOemData = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

    //
    // fill in printer commands
    //

    i = 0;

    switch (dwCmdCbID) {

    case CMD_XMOVE_ABS:
    case CMD_YMOVE_ABS:

        //
        // The commands require 4 parameters
        //

        if (dwCount < 4 || !pdwParams) return 0;

        VERBOSE(("MOVE_ABS - %d, %d, %d, %d\r\n",
            PARAM(pdwParams, 0),PARAM(pdwParams, 1),
            PARAM(pdwParams, 2),PARAM(pdwParams, 3)));

        dwDestX = (PARAM(pdwParams, 0) * PARAM(pdwParams, 2)) / MASTER_UNIT;
        dwDestY = (PARAM(pdwParams, 1) * PARAM(pdwParams, 3)) / MASTER_UNIT;

        Cmd[i++] = (BYTE)'\x9B';
        Cmd[i++] = 'P';
        Cmd[i++] = (BYTE)(dwDestX >> 8);
        Cmd[i++] = (BYTE)(dwDestX);
        Cmd[i++] = (BYTE)(dwDestY >> 8);
        Cmd[i++] = (BYTE)(dwDestY);

        WRITESPOOLBUF(pdevobj, Cmd, i);

        switch (dwCmdCbID) {
        case CMD_XMOVE_ABS:
            iRet = dwDestX;
            break;
        case CMD_YMOVE_ABS:
            iRet = dwDestY;
            break;
        }
        break;

    case CMD_CR:
		// Added to check the NULL pointer.
        if (pdwParams == NULL) return -1;

        dwDestY = (PARAM(pdwParams, 0) * PARAM(pdwParams, 1)) / MASTER_UNIT;

        Cmd[i++] = (BYTE)'\x9B';
        Cmd[i++] = 'P';
        Cmd[i++] = 0;
        Cmd[i++] = 0;
        Cmd[i++] = (BYTE)(dwDestY >> 8);
        Cmd[i++] = (BYTE)dwDestY;

        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_LF:
        // DUMMY entry.
        break;

    case CMD_SEND_BLOCK_DATA:
		// Added to check the NULL pointer.
        if (pdwParams == NULL) return -1;

        dwDataWidth = PARAM(pdwParams, 0) * 8;

        Cmd[i++] = (BYTE)'\x9B';
        Cmd[i++] = 'S';
        Cmd[i++] = (BYTE)(dwDataWidth >> 8);
        Cmd[i++] = (BYTE)(dwDataWidth);

        // In case it is OEMCompression data, we already
        // embedded printing command and data length.

        if (!lpOemData->bComp) {
            dwDataSize = PARAM(pdwParams, 1);
            Cmd[i++] = (BYTE)'\x9B';
            Cmd[i++] = 'I';
            Cmd[i++] = COMP_NONE;
            Cmd[i++] = (BYTE)(dwDataSize >> 8);
            Cmd[i++] = (BYTE)(dwDataSize);
        }

        WRITESPOOLBUF(pdevobj, Cmd, i);
        break;

    case CMD_ENABLE_OEM_COMP:
        lpOemData->bComp = TRUE;
        break;

    case CMD_DISALBE_COMP:
        lpOemData->bComp = FALSE;
        break;
    }

    return iRet;
}

INT
APIENTRY
OEMCompression(
    PDEVOBJ pdevobj,
    PBYTE pInBuf,
    PBYTE pOutBuf,
    DWORD dwInLen,
    DWORD dwOutLen)
{
    INT iRet = -1;
    INT iRetRLE, iRetMHE;
    DWORD dwMHECeil = 0xc00000; // Can be any.

	if (pInBuf == NULL && dwInLen != 0) return -1;
	if (pOutBuf == NULL && dwOutLen != 0) return -1;

    // Compression algorithm (per each scanline)
#if defined(RLETEST)

    if (LGCompRLE(NULL, pInBuf, dwInLen, 1) <= (INT)(dwOutLen * 2 / 3)) {
        iRet = LGCompRLE(pOutBuf, pInBuf, dwInLen, 1);
    }

#elif defined(MHETEST)

    if (LGCompMHE(NULL, pInBuf, dwInLen, 1) <= (INT)(dwOutLen * 2 / 3)) {
        iRet = LGCompMHE(pOutBuf, pInBuf, dwInLen, 1);
    }

#else // Normal case.

    iRetRLE = LGCompRLE(NULL, pInBuf, dwInLen, 1);
    if (iRetRLE >= 0 && iRetRLE < (INT)dwInLen / 2) {

        // Ok with RLE.
        iRet = LGCompRLE(pOutBuf, pInBuf, dwInLen, 1);
    }
    else if (iRetRLE <= (INT)dwInLen) {

        // Try MHE.
        iRetMHE = LGCompMHE(NULL, pInBuf, dwInLen, 1);
        if (iRetMHE > 0 && iRetMHE < iRetRLE && iRetMHE < (INT)dwMHECeil) {

            // Go with MHE.
            iRet = LGCompMHE(pOutBuf, pInBuf, dwInLen, 1);
        }
        else {
            // Go with RLE.
            iRet = LGCompRLE(pOutBuf, pInBuf, dwInLen, 1);
        }
    }
#endif // NORMAL

    VERBOSE(("OEMCompression - dwInLen=%d,dwOutLen=%d,iRet = %d\n",
        dwInLen, dwOutLen, iRet));

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\lggdires\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF


ALT_PROJECT=KOR
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\lg\$(ALT_PROJECT)
SRCDIR=..

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

TARGETNAME=lggdires
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),lggdires
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\lggdires.rc \
    $(SRCDIR)\lggdires.c \
    $(SRCDIR)\common.c \
    $(SRCDIR)\lgcomp.c

MISCFILES=\
    $(SRCDIR)\lggdires.ini \
    $(GPDDIR)\lglp63jk.gpd \
    $(GPDDIR)\lglp63pk.gpd \
    $(GPDDIR)\lglp66jk.gpd \
    $(GPDDIR)\lglp860k.gpd \
    $(GPDDIR)\lglp86nk.gpd \
    $(GPDDIR)\lgmf700k.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\lggdires\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
    "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
//     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
//     "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
//     "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\lggdires\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

// NTRAID#NTBUG9-553896-2002/03/19-yasuho-: mandatory changes

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
#include <strsafe.h>

#include "lgcomp.h"

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) \
    ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " s

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'LGGD'      // LG GDI x00 series dll
#define DLLTEXT(s)      "LGGD: " s
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER	dmExtraHdr;
    // Private extention
    INT bComp;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc11jres\hlp\nc11jres.h ===
/* PAPER SETTING */
#define POP_11_PAPSET                1150
#define POP_11_PAPSET2               1151


/* PRINT QUALITIES */
#define POP_11_PQUALITIESOLD         1166
#define POP_11_PQUALITIESNEW         1167


/* TextHalftonThreshold */
#define POP_11_TEXTHALFTONE          1180
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc21jres\hlp\nc21jres.h ===
/* PAPER SETTING */
#define POP_21_PAPSET                2150
/* #define POP_21_PAPSET40              2151 */


/* PRINT QUALITIES */
#define POP_21_PQUALITIESOLD         2166
#define POP_21_PQUALITIESNEW         2167

/* KANJI CODE */
#define POP_21_KANJICODE             2170

/* TextHalftoneThreshold */
#define POP_21_TEXTHALFTONE          2180
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc62jres\debug.c ===
#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc24tres\etc\nec24c.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
char *rgchModuleName = "NEC24C";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc62jres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

// NTRAID#NTBUG9-588495-2002/03/28-yasuho-: Remove dead code.

#include "pdev.h"

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING,("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}



//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        DBGPRINT(DBG_WARNING,("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING,("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING,("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING,("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING,("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING,("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING,("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING,("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc62jres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

// NTRAID#NTBUG9-588495-2002/03/28-yasuho-: Remove dead code.
// NTRAID#NTBUG9-588506-2002/03/28-yasuho-: Correct the return values.

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc62jres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// Misc definitions follows.
//

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
//#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'NC62'      // NEC 602 series dll
#define DLLTEXT(s)     "NC62: " s
#define OEM_VERSION      0x00010000L

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
    WORD  wRes;             // resolution / MasterUnit
    DWORD dwSBCSX;          // temp
    DWORD dwDBCSX;          // temp
    LONG  lSBCSXMove;       // SBCS The expectation X movement quantity
    LONG  lSBCSYMove;       // SBCS The expectation Y movement quantity
    LONG  lDBCSXMove;       // DBCS The expectation X movement quantity
    LONG  lDBCSYMove;       // DBCS The expectation Y movement quantity
    LONG  lPrevXMove;       // The previous X movement quantity
    LONG  lPrevYMove;       // The previous Y movement quantity
    DWORD fGeneral;         // general flag
    WORD  wCurrentAddMode;  // draw mode
    DWORD dwDeviceDestX;    // current X coordinate
    DWORD dwDeviceDestY;    // current Y coordinate
    DWORD dwDevicePrevX;    // previous X coordinate
    DWORD dwDevicePrevY;    // previous Y coordinate
// NTRAID#NTBUG9-278517-2002/03/28-yasuho-: RectFill
    DWORD dwRectWidth;      // width for RectFill
    DWORD dwRectHeight;     // height for RectFill
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

// Flags for fGeneral
#define FG_DBCS     0x00000002
#define FG_VERT     0x00000004
// NTRAID#NTBUG9-278517-2002/03/28-yasuho-: RectFill
#define FG_GMINIT   0x00000040

#define FLAG_SBCS  1
#define FLAG_DBCS  2

#define MASTER_UNIT 1200

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc62jres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

// NTRAID#NTBUG9-588495-2002/03/28-yasuho-: Remove dead code.

CONST PSTR
gMethodsSupported[] = {
    "CommandCallback",
    "DevMode",
    "GetImplementedMethod",
    "GetInfo",
    "OutputCharStr",
    "PublishDriverInterface",
    "SendFontCmd",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc62jres\nc62jres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

// NTRAID#NTBUG9-588519-2002/03/28-yasuho-: Possible divide by zero.
// NTRAID#NTBUG9-588527-2002/03/28-yasuho-: Possible buffer overrun.

#include "pdev.h"
#include <strsafe.h>

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

//
// command callback ID's
//
#define CMD_MOVE_X           23
#define CMD_MOVE_Y           24
#define CMD_BEGIN_RASTER     26
#define CMD_RES_240          29     //for PR601,602,602R
#define CMD_SEND_BLOCK_DATA  30     //for PR1000,1000/2,2000
#define CMD_RES_240NEW       31     //for PR1000,1000/2,2000
#define CMD_SEND_BLOCK_DATA2 32     //for PR601,602,602R
#define CMD_INIT_COORDINATE  33
#define CMD_PC_PRN_DIRECTION 50
#define CMD_CR               51
// #define CMD_RECTWIDTH        60
// #define CMD_RECTHEIGHT       61
// #define CMD_RECTWHITE        62
// #define CMD_RECTBLACK        63
// #define CMD_RECTGRAY         64


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->wRes = 1;
    pOEMExtra->dwDeviceDestX = 0;
    pOEMExtra->dwDeviceDestY = 0;
    pOEMExtra->dwDevicePrevX = 0;
    pOEMExtra->dwDevicePrevY = 0;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->wRes    = pdmIn->wRes;
        pdmOut->dwSBCSX = pdmIn->dwSBCSX;
        pdmOut->dwDBCSX = pdmIn->dwDBCSX;
        pdmOut->lSBCSXMove = pdmIn->lSBCSXMove;
        pdmOut->lSBCSYMove = pdmIn->lSBCSYMove;
        pdmOut->lDBCSXMove = pdmIn->lDBCSXMove;
        pdmOut->lDBCSYMove = pdmIn->lDBCSYMove;
        pdmOut->lPrevXMove = pdmIn->lPrevXMove;
        pdmOut->lPrevYMove = pdmIn->lPrevYMove;
        pdmOut->fGeneral = pdmIn->fGeneral;
        pdmOut->wCurrentAddMode = pdmIn->wCurrentAddMode;
        pdmOut->dwDeviceDestX = pdmIn->dwDeviceDestX;
        pdmOut->dwDeviceDestY = pdmIn->dwDeviceDestY;
        pdmOut->dwDevicePrevX = pdmIn->dwDevicePrevX;
        pdmOut->dwDevicePrevY = pdmIn->dwDevicePrevY;
    }
    return TRUE;
}

BYTE ShiftJis[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA
//
//  Description:  Convert from numeral into a character
//-----------------------------------------------------------------------------
static int
iDwtoA(LPSTR buf, DWORD n)
{
    int  i, j;

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA_FillZero
//
//  Description:  Convert from numeral into a character and
//                fill a field which was specified with 0
//-----------------------------------------------------------------------------
static int
iDwtoA_FillZero(LPSTR buf, DWORD n, int fw)
{
    int  i , j, k, l;

    l = n;  // for later

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    for( k = 0; l; k++ ) {
        l /= 10;
    }
    if( k < 1) k++;

    k = fw - k;
    if(k > 0){;
        for (j = i; 0 < j + 1; j--){
            buf[j + k] = buf[j];
        }
        for ( j = 0; j < k; j++){
            buf[j] = '0';
        }
        i = i + k;
    }

    return i;
}

//-----------------------------------------------------------------------------
//
//  Function:   memcopy
//
//  Description:  Copy the memory from Src to Dest
//-----------------------------------------------------------------------------
static int
memcopy(LPSTR lpDst, LPSTR lpSrc, WORD wLen)
{
    WORD rLen;

    rLen = wLen;

    while(wLen--) *lpDst++ = *lpSrc++;

    return rLen;
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMCommandCallback
//
//-----------------------------------------------------------------------------
INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT         i;
    BYTE            *bp;
    BYTE            Cmd[128];
    POEMUD_EXTRADATA    pOEM;

    INT iRet;
    DWORD dwDeviceDestX, dwDeviceDestY;

// 02/04/09 NES Niigata : Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("OEMCommandCallback: Invalid parameter(s).\n"));
        return 0;
    }

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    i = 0;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    iRet = 0;

// 02/04/09 NES Niigata : Check for illegal parameters
    if (NULL == pOEM)
    {
        ERR(("OEMCommandCallback: pdevobj->pOEMDM = 0.\n"));
        return 0;
    }

    switch (dwCmdCbID) {
    case CMD_CR:

        pOEM->dwDeviceDestX = 0;
        WRITESPOOLBUF(pdevobj, "\015", 1);
        break;

    case CMD_MOVE_X:
    case CMD_MOVE_Y:

        if (dwCount < 4)
            return 0;      // cannot do anything

        if (!PARAM(pdwParams, 2) || !PARAM(pdwParams, 3))
            return 0;
        pOEM->dwDeviceDestX = PARAM(pdwParams, 0) /
                (MASTER_UNIT / PARAM(pdwParams, 2));
        pOEM->dwDeviceDestY = PARAM(pdwParams, 1) /
                (MASTER_UNIT / PARAM(pdwParams, 3));

        // Set return value

        switch (dwCmdCbID) {
        case CMD_MOVE_X:
            iRet = (INT)pOEM->dwDeviceDestX;
            break;
        case CMD_MOVE_Y:
            iRet = (INT)pOEM->dwDeviceDestY;
            break;
        }

        break;

    case CMD_RES_240:

        pOEM->wRes = MASTER_UNIT / 240;

        break;

    case CMD_RES_240NEW:

        i = 0;
        i += memcopy(&Cmd[i], "\034<1/240,i.", 10);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 240;

        break;

    case CMD_SEND_BLOCK_DATA:

// 02/04/09 NES Niigata : Check for illegal parameters
        if (dwCount < 3 || !pdwParams)
            return 0;

        /* Send a draw coordinate command to the printer. */
        i = 0;
        i += memcopy(&Cmd[i], "\034e", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
        Cmd[i++] = '.';

        WRITESPOOLBUF(pdevobj, Cmd, i);

        /* Save the present coordinate. */
        pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
        pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;

        /* Send an image data draw command. */
        i = 0;
        i += memcopy(&Cmd[i], "\034R", 2);
        i += memcopy(&Cmd[i], "\034i", 2);
        i += iDwtoA(&Cmd[i], (PARAM(pdwParams, 0) * 8 ));
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], PARAM(pdwParams, 1));
        Cmd[i++] = ',';
        i += memcopy(&Cmd[i], "0,1/1,1/1,", 10);
        i += iDwtoA(&Cmd[i], PARAM(pdwParams, 2));
        Cmd[i++] = ',';
        i += memcopy(&Cmd[i], "240", 3);
        Cmd[i++] = '.';

        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_SEND_BLOCK_DATA2:

// 02/04/09 NES Niigata : Check for illegal parameters
        if (dwCount < 3 || !pdwParams)
            return 0;

        /* Send a draw coordinate command to the printer. */
        i = 0;
        i += memcopy(&Cmd[i], "\034e", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
        Cmd[i++] = '.';

        WRITESPOOLBUF(pdevobj, Cmd, i);

        /* Save the present coordinate. */
        pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
        pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;

        /* Send an image data draw command. */
        i = 0;
        i += memcopy(&Cmd[i], "\034R", 2);
        i += memcopy(&Cmd[i], "\034i", 2);
        i += iDwtoA(&Cmd[i], (PARAM(pdwParams, 0) * 8 ));
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], PARAM(pdwParams, 1));
        Cmd[i++] = ',';
        i += memcopy(&Cmd[i], "0,1/1,1/1,", 10);
        i += iDwtoA(&Cmd[i], PARAM(pdwParams, 2));
        Cmd[i++] = '.';

        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_BEGIN_RASTER:
        if (pOEM->wCurrentAddMode){
            i = 0;
            i += memcopy(&Cmd[i], "\034R", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = 0;
        }
        break;

    case CMD_PC_PRN_DIRECTION:
// 02/04/09 NES Niigata : Check for illegal parameters
	if (dwCount < 1 || !pdwParams)
            return 0;
        {
        LONG lEsc90;
        LONG ESin[] = {0, 1, 0, -1};
        LONG ECos[] = {1, 0, -1, 0};

        lEsc90 = (PARAM(pdwParams, 0) % 360) / 90;

        pOEM->lSBCSXMove = pOEM->dwSBCSX * ECos[lEsc90];
        pOEM->lSBCSYMove = -(LONG)pOEM->dwSBCSX * ESin[lEsc90];
        pOEM->lDBCSXMove = pOEM->dwDBCSX * ECos[lEsc90];
        pOEM->lDBCSYMove = -(LONG)pOEM->dwDBCSX * ESin[lEsc90];
        }
        break;

    case CMD_INIT_COORDINATE:
        if (!pOEM->wRes)
            return 0;
        pOEM->dwDeviceDestX = 0;
        pOEM->dwDeviceDestY = 0;
        pOEM->wCurrentAddMode = 0;

        if (!(pOEM->fGeneral & FG_GMINIT)) {
            i = 0;
            i += memcopy(&Cmd[i], "\x1CYIN;SU1,", 9);
            i += iDwtoA(&Cmd[i], MASTER_UNIT / pOEM->wRes);
            i += memcopy(&Cmd[i], ",0;XX1;PM1;XX0;\x1CZ", 17);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->fGeneral |= FG_GMINIT;
        }
        break;
    }
    return iRet;
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMSendFontCmd
//
//-----------------------------------------------------------------------------
VOID
APIENTRY
OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4];
    DWORD       dwIn, dwOut, dwTemp;    // = i,ocmd = counter
    PBYTE       pubCmd;                 // = lpcmd
    BYTE        aubCmd[128];            // = rgcmd[]
    POEMUD_EXTRADATA    pOEM;           // = LPPR602DATASTRUCTURE like
    DWORD       tmpPoints;
    PIFIMETRICS pIFI;                   // = LPFONTINFO
    DWORD       dwNeeded;

    DWORD       dwCount;
    BOOL        bFound = FALSE;

    char  pcom1[] = {'Q', 'E', 'H'};
    char  *pcom2[] = {"070","105","120"};
    char  *bcom[] = {"1/2,1/2,L.", "1/1,1/1,L.", "2/1,2/1,L.", "3/1,3/1,L.",
                     "4/1,4/1,L.", "6/1,6/1,L.", "8/1,8/1,L."};

    short  PTable1[] = {      0,1,2,0,0,1,1,1,2,2,0,0,0,0,1,1,1,
                        0,0,2,2,2,2,0,0,0,1,1,1,1,2,2,2,2,2,1,1,
                        1,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,1,1,
                        1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,
                        1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2};

    short  BTable1[] = {      0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,
                        3,3,2,2,2,2,4,4,4,3,3,3,3,3,3,3,3,3,4,4,
                        4,5,5,5,5,4,4,4,4,4,4,4,6,6,6,6,6,6,5,5,
                        5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,
                        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6};

    short  PTable2[] = {      0,1,2,0,0,0,1,1,2,2,0,0,0,0,0,1,1,
                        1,1,2,2,2,2,0,0,0,0,1,1,1,1,2,2,2,2,2,1,
                        1,1,1,1,1,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,
                        0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,
                        1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2};

    short  BTable2[] = {      0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,
                        2,2,2,2,2,2,4,4,4,4,3,3,3,3,3,3,3,3,3,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,6,6,6,6,6,6,6,6,
                        6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
                        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6};

    VERBOSE(("OEMSendFontCmd() entry.\r\n"));
    VERBOSE((("CMD size:%ld\r\n"), pFInv->dwCount));

// 02/04/09 NES Niigata : Check for illegal parameters
    if (NULL == pdevobj || NULL == pUFObj || NULL == pFInv)
    {
        ERR(("OEMSendFontCmd: Invalid parameter(s).\n"));
        return;
    }

    if(!pFInv->dwCount){
        VERBOSE(("CMD size is Zero return\r\n"));
        return;
    }

    pubCmd = pFInv->pubCommand;    //Copy Font Selection Command
    dwCount = pFInv->dwCount;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);    //Copy ExtraData
    pIFI = pUFObj->pIFIMetrics;

// 02/04/09 NES Niigata : Check for illegal parameters
    if (NULL == pubCmd || NULL == pOEM || NULL == pIFI)
    {
        ERR(("OEMSendFontCmd: pFInv->pubCommand = 0 Or pdevobj->pOEMDM = 0 Or pUFObj->pIFIMetrics = 0.\n"));
        return;
    }

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;

// 02/04/09 NES Niigata : Check for illegal parameters
    if (NULL == pSV)
    {
        ERR(("OEMSendFontCmd: pSV = 0.\n"));
        return;
    }

    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
            pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return;
    }

    VERBOSE((("FONTHEIGHT=%d\r\n"), pSV->StdVar[0].lStdVariable));
    VERBOSE((("FONTWIDTH=%d\r\n"), pSV->StdVar[1].lStdVariable));

    if (!pOEM->wRes || !pSV->StdVar[2].lStdVariable)
        return;
    tmpPoints = ((pSV->StdVar[0].lStdVariable / pOEM->wRes)  * 72)
                                            / pSV->StdVar[2].lStdVariable;

    if(tmpPoints > 96)     tmpPoints = 96;
    else if(tmpPoints < 4) tmpPoints = 4;

    tmpPoints -= 4;

    dwIn = dwOut = dwTemp = 0;

    pOEM->fGeneral &= ~(FG_VERT | FG_DBCS);

    while(dwIn < pFInv->dwCount && dwOut < 128)
    {
        while(dwCount--)
        {
            if(pubCmd[dwIn] !='#'){
                aubCmd[dwOut] = pubCmd[dwIn];
                dwOut++;
                dwIn++;
            }
            else{
                bFound = TRUE;
                break;
            }
        }

        if(bFound == TRUE)
            dwIn++;
        else
            return;   // mismatch font command


        switch(pubCmd[dwIn])
        {
        case 'T':  // 602,602R 2Byte TATE Size
            pOEM->fGeneral |= FG_VERT;

        case 'Q':  // 602,602R 2Byte YOKO Size
            pOEM->fGeneral |= FG_DBCS;
            if(tmpPoints < 3) tmpPoints = 3;
            dwOut +=
            memcopy(&aubCmd[dwOut], (LPSTR)pcom2[PTable2[tmpPoints]], 3);
            break;

        case 'S':  // NPDL 2Byte TATE Size
           pOEM->fGeneral |= FG_VERT;

        case 'P':  // NPDL 2Byte YOKO Size
            pOEM->fGeneral |= FG_DBCS;
            dwOut +=
            memcopy(&aubCmd[dwOut], (LPSTR)pcom2[PTable2[tmpPoints]], 3);
            break;

        case 'U':  // 601 TATE SIZE
            pOEM->fGeneral |= FG_VERT;

        case 'R':  // 601 2Byte YOKO Size
            pOEM->fGeneral |= FG_DBCS;
            if(tmpPoints < 3) tmpPoints = 3;
            dwTemp = BTable2[tmpPoints] > 2 ? 2 : PTable2[tmpPoints];
            dwOut += memcopy(&aubCmd[dwOut], (LPSTR)pcom2[dwTemp], 3);
            break;

        case 'X':  // 602,602R,NPDL 2Byte Scale
            pOEM->fGeneral |= FG_DBCS;
            dwOut +=
            memcopy(&aubCmd[dwOut], (LPSTR)bcom[BTable2[tmpPoints]], 10);
            break;

        case 'Y':  // 601 2Byte Scale
            pOEM->fGeneral |= FG_DBCS;
            dwTemp = BTable2[tmpPoints] > 1 ? 2 : 1;
            dwOut += memcopy(&aubCmd[dwOut], (LPSTR)bcom[dwTemp], 10);
            break;

        case 'L':  // 1Byte Size
            aubCmd[dwOut] = pcom1[PTable1[tmpPoints]];
            dwOut++;

            break;

        case 'M':  // 1Byte Scale
            dwOut +=
            memcopy(&aubCmd[dwOut], (LPSTR)bcom[BTable2[tmpPoints]], 10);
        }

        dwIn++;
    }

        WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

    /*
     * I expect the interval of the current letter and the next letter
     * from the letter size.
     */
    if(pOEM->fGeneral & FG_DBCS)
    {

        pOEM->dwDBCSX =
        pOEM->lDBCSXMove =
                 (LONG)((pSV->StdVar[1].lStdVariable * 2.04) / pOEM->wRes);

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 (LONG)(pSV->StdVar[1].lStdVariable * 1.03 / pOEM->wRes);
    }
    else{

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 pSV->StdVar[1].lStdVariable / pOEM->wRes;

    }
    pOEM->lDBCSYMove = pOEM->lSBCSYMove = 0;
    pOEM->wCurrentAddMode = 0;

    VERBOSE(("OEMSendFontCmd() end.\r\n"));
}

//-----------------------------------------------------------------------------
//
//  Function:   OEMOutputCharStr
//
//-----------------------------------------------------------------------------
VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    WORD        wlen;
    WORD        j;
    PIFIMETRICS pIFI;
    POEMUD_EXTRADATA    pOEM;
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
    PBYTE       aubBuff;
    DWORD  dwI;
    DWORD       dwNeeded;


    VERBOSE(("OEMOutputCharStr() entry.\r\n"));
    VERBOSE((("FONT Num=%d\r\n"), dwCount));

// 02/04/09 NES Niigata : Check for illegal parameters
    if(NULL == pdevobj || NULL == pUFObj)
    {
        ERR(("OEMOutputCharStr: Invalid parameter(s).\n"));
        return;
    }

    if(dwType != TYPE_GLYPHHANDLE){
        VERBOSE((("NOT TYPE_GLYPHHANDLE\r\n")));
        return;
    }

    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    pIFI = pUFObj->pIFIMetrics;

// 02/04/09 NES Niigata : Check for illegal parameters
    if(NULL == pOEM || NULL == pIFI)
    {
        ERR(("OEMOutputCharStr: pdevobj->pOEMDM = 0 Or pUFObj->pIFIMetrics = 0.\n"));
        return;
    }


    //
    // Call the Unidriver service routine to convert
    // glyph-handles into the character code data.
    //

    GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
    GStr.dwCount   = dwCount;
    GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
    GStr.pGlyphIn  = pGlyph;
    GStr.dwTypeOut = TYPE_TRANSDATA;
    GStr.pGlyphOut = NULL;
    GStr.dwGlyphOutSize = 0;

    if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded) || !GStr.dwGlyphOutSize)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        return;
    }

    if ((aubBuff = MemAlloc(GStr.dwGlyphOutSize)) == NULL)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:MemAlloc failed.\r\n"));
        return;
    }

    GStr.pGlyphOut = aubBuff;

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded))
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        MemFree(aubBuff);
        return;
    }

    /*
     * Three kind of the character cords which is given by UNIDRV
     * 1.SBCS
     * 2.DBCS Kanji
     * 3.DBCS ANK
     */
    pTrans = (PTRANSDATA)aubBuff;

// 02/04/09 NES Niigata : Check for illegal parameters
    if(NULL == pTrans)
    {
        ERR(("OEMOutputCharStr: pTrans = 0.\n"));
        return;
    }

    for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
    {
        switch (pTrans->ubType & MTYPE_FORMAT_MASK)
        {
        case MTYPE_DIRECT:
        /*
         Pattern 1: SBCS
         */
         if(pOEM->wCurrentAddMode != FLAG_SBCS ||
           pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
           pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)

        {
            int i = 0;
            BYTE  Cmd[256];

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
            Cmd[i++] = '.';

            i += memcopy(&Cmd[i], "\034a", 2);
            i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
            Cmd[i++] = ',';
            i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
            Cmd[i++] = ',';
            Cmd[i++] = '0';
            Cmd[i++] = '.';

            WRITESPOOLBUF(pdevobj, Cmd, i);

            pOEM->wCurrentAddMode = FLAG_SBCS;
            pOEM->lPrevXMove = pOEM->lSBCSXMove;
            pOEM->lPrevYMove = pOEM->lSBCSYMove;
        }
        WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubCode, 1);
        break;

        case MTYPE_PAIRED:
        /*
         Pattern 2: kanji
         */
        if(*pTrans->uCode.ubPairs)
        {
             if(pOEM->wCurrentAddMode != FLAG_DBCS ||
            pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
            pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)
            {
                int i = 0;
                BYTE  Cmd[256];

                i += memcopy(&Cmd[i], "\034e", 2);
                i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
                Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lDBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lDBCSYMove);
                Cmd[i++] = ',';
                Cmd[i++] = '0';
                Cmd[i++] = '.';

                if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033t", 2);
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_DBCS;
                pOEM->lPrevXMove = pOEM->lDBCSXMove;
                pOEM->lPrevYMove = pOEM->lDBCSYMove;
            }
        }
        /*
         Pattern 3: ANK
         */
        else
        {
            if(pOEM->wCurrentAddMode != FLAG_SBCS ||
            pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
            pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)
            {
                int i = 0;
                BYTE  Cmd[256];

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
            Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
                Cmd[i++] = ',';
                Cmd[i++] = '0';
                Cmd[i++] = '.';

                /*
                 * ANK can't do vertical writing. We have to do
                 * vertical writing for holizontal writing compulsorily
                 */
                 if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033K", 2);
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_SBCS;
                pOEM->lPrevXMove = pOEM->lSBCSXMove;
                pOEM->lPrevYMove = pOEM->lSBCSYMove;
                }
        }
        WRITESPOOLBUF(pdevobj, pTrans->uCode.ubPairs, 2);
        break;

        }
        pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
        pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;
        pOEM->dwDeviceDestX += pOEM->lPrevXMove;
        pOEM->dwDeviceDestY += pOEM->lPrevYMove;
    }

    MemFree(aubBuff);
    VERBOSE(("OEMOutputCharStr() end.\r\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc62jres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\nec\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=nc62jres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),fjxlres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\nc62jres.rc \
    $(SRCDIR)\nc62jres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\nc62jres.ini \
    $(GPDDIR)\nc62102j.gpd \
    $(GPDDIR)\nc6210j.gpd \
    $(GPDDIR)\nc6220j.gpd \
    $(GPDDIR)\nc6261j.gpd \
    $(GPDDIR)\nc62j.gpd \
    $(GPDDIR)\nc62rj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc75jres\hlp\nc75jres.h ===
/* PRINT QUALITIES */
#define POP_75_PQUALITIESNEW         7560


/* KANJI CODE */
#define POP_75_KANJICODE             7570

/*  */
#define POP_75_TEXTHALFTONE          7580
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc70jres\hlp\nc70jres.h ===
/* PAPER SETTING */
#define POP_70_YOUSIHOUKOU           7050
#define POP_70_YOUSIHOUKOU2          7051
#define POP_70_YOUSIHOUKOU3          7052
#define POP_70_YOUSIHOUKOU4          7053


/* PRINT QUALITIES */
#define POP_70_PQUALITIESNEW         7060
#define POP_70_PQUALITIESNEW2        7061
#define POP_70_PQUALITIESNEW3        7062

/* KANJI CODE */
#define POP_70_KANJICODE             7070

/* TextHalftoneThreshold */
#define POP_70_TEXTHALFTONE          7080
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc82jres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

#include <strsafe.h>

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    //DbgPrint(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        //DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        //DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPTSTR OEMDevMode_fMode[] = {   __TEXT("NULL"),
                                    __TEXT("OEMDM_SIZE"),
                                    __TEXT("OEMDM_DEFAULT"),
                                    __TEXT("OEMDM_CONVERT"),
                                    __TEXT("OEMDM_MERGE"),
                                };

    //DbgPrint(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]);

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        //DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        //DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            //DbgPrint(__TEXT("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        //DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        //DbgPrint(__TEXT("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        //DbgPrint(__TEXT("\tcbSize = %d.\r\n"), pOEMDevModeParam->cbSize);
        //DbgPrint(__TEXT("\thPrinter = %#lx.\r\n"), pOEMDevModeParam->hPrinter);
        //DbgPrint(__TEXT("\thModule = %#lx.\r\n"), pOEMDevModeParam->hModule);
        //DbgPrint(__TEXT("\tpPublicDMIn = %#lx.\r\n"), pOEMDevModeParam->pPublicDMIn);
        //DbgPrint(__TEXT("\tpPublicDMOut = %#lx.\r\n"), pOEMDevModeParam->pPublicDMOut);
        //DbgPrint(__TEXT("\tpOEMDMIn = %#lx.\r\n"), pOEMDevModeParam->pOEMDMIn);
        //DbgPrint(__TEXT("\tpOEMDMOut = %#lx.\r\n"), pOEMDevModeParam->pOEMDMOut);
        //DbgPrint(__TEXT("\tcbBufSize = %d.\r\n"), pOEMDevModeParam->cbBufSize);
    }
}


//
// Functions for outputting debug messages
//
#if 0
VOID DbgPrint(IN LPCTSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc82jres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"

#include <strsafe.h>

////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));

    if (NULL == ppv)
    {
        return E_NOINTERFACE;
    }

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// ######################

// Function Name: GetInfo
// Plug-in: Any
// Driver: Any
// Type: Mandatory
//

LONG __stdcall
IOemCB::GetInfo(
    DWORD dwMode,
    PVOID pBuffer,
    DWORD cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}

// ######################

//
// Function Name: PublishDriverInterface
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

LONG __stdcall
IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));

    if (NULL == pIUnknown)
    {
        return E_FAIL;
    }

// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

//
// Function Name: GetImplementationMethod
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

int __cdecl
iCompNames(
    void *p1,
    void *p2) {

    return strcmp(
        (NULL == (p1) ? "" : *((char **)p1)),
        (NULL == (p2) ? "" : *((char **)p2)));
}

LONG __stdcall
IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    LONG lRet = E_NOTIMPL;
    PSTR pTemp;

    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

    if (NULL != pMethodName) {

        pTemp = (PSTR)bsearch(
            &pMethodName,
            gMethodsSupported,
            (sizeof (gMethodsSupported) / sizeof (PSTR)),
            sizeof (PSTR),
            (int (__cdecl *)(const void *, const void *))iCompNames);

        if (NULL != pTemp)
            lRet = S_OK;
    }

    VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

    return lRet;
}

// #######################

//
// Function Name: EnableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::EnableDriver(
    DWORD dwDriverVersion,
    DWORD cbSize,
    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: DisableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: EnablePDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

    if (NULL == pDevOem)
    {
        return E_FAIL;
    }

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

    if (*pDevOem)
        return S_OK;
    else
        return E_FAIL;
}

//
// Function Name: DisablePDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DisablePDEV(
    PDEVOBJ pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

    OEMDisablePDEV(pdevobj);
    return S_OK;
}

//
// Function Name: ResetPDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));

    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return E_FAIL;
}

//
// Function Name: DevMode
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

// ################


//
// Function Name: CommandCallback
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::CommandCallback(
    PDEVOBJ pdevobj,
    DWORD dwCallbackID,
    DWORD dwCount,
    PDWORD pdwParams,
    OUT INT *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

    if (NULL == piResult)
    {
        return E_FAIL;
    }

    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    if (*piResult < 0) {
        return E_FAIL;
    }
    return S_OK;
}

//
// Function Name: ImageProcessing
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: FilterGraphics
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::FilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if (OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

//
// Function Name: Compression
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: HalftonePattern
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: MemoryUsge
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadFontHeader
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadCharGlyph
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTDonwloadMethod
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: OutputCharStr
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: SendFontCmd
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DriverDMS
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TextOutputAsBitmap
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTYGetInfo
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if (NULL == ppv)
    {
        return E_NOINTERFACE;
    }

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation

HRESULT __stdcall
IOemCF::CreateInstance(
    IUnknown *pUnknownOuter,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

    // Cannot aggregate.
    if (NULL != pUnknownOuter) {

        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB;
    if (NULL == pOemCB) {

        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc82jres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
    "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc82jres\nc82jres.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#define BPB_SIZE 304
#define BPB_CLR  1
#define BPB_COPY 2
#define BPB_AND  3
#define BPB_OR   4

typedef struct {
    int  iColor;
    int  iFirstColor;
    int  iPlaneNumber;
    WORD wXpos;
    WORD wYpos;
    WORD wNumScans;
    WORD wOldNumScans;
    WORD wScanWidth;
    WORD wScanBytes;
    WORD wTopPad;
    WORD wEndPad;
    int  iRibbon;
    int  iColorMode;
    BOOL bComBlackMode;
    BYTE pszSheetSetting[8];
    HANDLE TempFile[4]; // Temp. file handles
    TCHAR TempName[4][MAX_PATH]; // Temp. file names
    BYTE BPBuf[BPB_SIZE]; // Black Pixel Buffer
} PCPRDATASTRUCTURE;
typedef PCPRDATASTRUCTURE FAR *LPPCPRDATASTRUCTURE;

#define SHEET_CMD_DEFAULT "\x1B\x04\x00\x45\x14\x01\x01"
#define SHEET_CMDLEN 7

#define CMDID_PSIZE_LETTER     1
#define CMDID_PSIZE_LEGAL      2
#define CMDID_PSIZE_A4         3
#define CMDID_PSIZE_A4LONG     4
#define CMDID_PSIZE_B5         5
#define CMDID_PSIZE_POSTCARD   6

#define CMDID_PSOURCE_HOPPER   10
#define CMDID_PSOURCE_MANUAL   11

#define CMDID_COLOR_YELLOW     20
#define CMDID_COLOR_MAGENTA    21
#define CMDID_COLOR_CYAN       22
#define CMDID_COLOR_BLACK      23
#define CMDID_COLOR_BLACKONLY  24
#define CMDID_COLOR_RGB        25
#define CMDID_SELECT_RESOLUTION  26
#define CMDID_MODE_COLOR       27
#define CMDID_MODE_MONO        28

#define CMDID_X_ABS_MOVE      30
#define CMDID_Y_ABS_MOVE      31

#define CMDID_RIBBON_MONO           40
#define CMDID_RIBBON_3COLOR_A4      41
#define CMDID_RIBBON_4COLOR_A4      42
#define CMDID_RIBBON_4COLOR_A4LONG  43
#define CMDID_RIBBON_3COLOR_KAICHO  44
#define CMDID_RIBBON_3COLOR_SHOKA   45

#define CMDID_BEGINPAGE        50
#define CMDID_ENDPAGE          51

#define P1_LETTER              0x02
#define P1_LEGAL               0x03
#define P1_A4                  0x14
#define P1_A4LONG              0x18
#define P1_B5                  0x25
#define P1_POSTCARD            0x01

#define P2_HOPPER              0x01
#define P2_MANUAL              0xff

#define P3_PORTRAIT            0x01

#define YELLOW                 1
#define MAGENTA                2
#define CYAN                   3
#define BLACK                  4
#define RGB_COLOR              5

#define TEMP_NAME_PREFIX __TEXT("~82")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc82jres\nc82jres.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

#include "pdev.h"

#include "nc82jres.h"

#include <strsafe.h>

// #undef wsprintf
// #define wsprintf sprintf

HRESULT SendABSMove(
PDEVOBJ pdevobj,
LPDWORD   lpdwParams);

HRESULT SpoolOut(PDEVOBJ pdevobj, FILE* pFile);
HANDLE	RevertToPrinterSelf( VOID );
BOOL	ImpersonatePrinterClient( HANDLE );

HRESULT
MDP_CreateTempFile(
    PDEVOBJ pdevobj,
    LPPCPRDATASTRUCTURE pdevOEM,
    INT iPlane);

HRESULT
DataSpool(
    PDEVOBJ pdevobj,
    HANDLE hFile,
    LPSTR lpBuf,
    DWORD dwLen);

VOID
BPBCalc(
    PDEVOBJ pdevobj,
    PBYTE pDataBuf,
    DWORD dwLen,
    BYTE BPBCommand);

/*************************** Function Header *******************************
 *  OEMEnablePDEV
 *  (MiniDrvEnablePDEV)
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *  15 Apr 1998    -by-    Yoshitaka Oku     [yoshitao]
 *      Conversion to NT5.0 spec driver
 *
 ***************************************************************************/
PDEVOEM APIENTRY OEMEnablePDEV(
PDEVOBJ pdevobj,
PWSTR pPrinterName,
ULONG cPatterns,
HSURF* phsurfPatterns,
ULONG cjGdiInfo,
GDIINFO* pGdiInfo,
ULONG cjDevInfo,
DEVINFO* pDevInfo,
DRVENABLEDATA * pded)
{
    LPPCPRDATASTRUCTURE    lpnp;

    //DbgPrint(DLLTEXT("OEMEnablePDEV(--) entry.\r\n"));

    if ((lpnp = (PCPRDATASTRUCTURE *) MemAllocZ(
            sizeof(PCPRDATASTRUCTURE ))) == NULL)
    {
        return 0;
    }

    memset(lpnp, 0, sizeof (PCPRDATASTRUCTURE));
    memcpy(lpnp->pszSheetSetting, SHEET_CMD_DEFAULT,
        SHEET_CMDLEN );

    pdevobj->pdevOEM = lpnp;

    return lpnp;
}

/*************************** Function Header *******************************
 *  OEMDisablePDEV
 *  (MiniDrvDisablePDEV)
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *  15 Apr 1998    -by-    Yoshitaka Oku     [yoshitao]
 *      Conversion to NT5.0 spec driver
 *
 ***************************************************************************/
VOID APIENTRY OEMDisablePDEV(
PDEVOBJ pdevobj)
{

    //DbgPrint(DLLTEXT("OEMDisablePDEV(--) entry.\r\n"));

    if ( pdevobj && pdevobj->pdevOEM )
    {
        MemFree( pdevobj->pdevOEM );
    }

}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    LPPCPRDATASTRUCTURE pOEMOld, pOEMNew;

    pOEMOld = (LPPCPRDATASTRUCTURE)pdevobjOld->pdevOEM;
    pOEMNew = (LPPCPRDATASTRUCTURE)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL)
        *pOEMNew = *pOEMOld;

    return TRUE;
}

BOOL APIENTRY OEMFilterGraphics (
PDEVOBJ pdevobj,
PBYTE pBuf,
DWORD dwLen)
{

    LPPCPRDATASTRUCTURE lpnp;

    //DbgPrint(DLLTEXT("OEMFilterGraphics(%d bytes) entry.\r\n"),dwLen);

    lpnp = (LPPCPRDATASTRUCTURE)(pdevobj->pdevOEM);

    if (NULL == pBuf || dwLen == 0)
    {
        // Do nothing.
	    return TRUE;
    }

    //if (dwLen != lpnp->wNumScans * lpnp->wScanWidth * 3)
	//DbgPrint(DLLTEXT("OEMFilterGraphics(%d bytes - %d) entry.\r\n"),dwLen,lpnp->wNumScans * lpnp->wScanWidth * 3);

    // YMC(K)
    // lpnp->iColor : data's color
    switch( lpnp->iColor )
    {
    case YELLOW:

        // Send YELLOW data.
        DATASPOOL4FG(pdevobj, lpnp->TempFile[0], pBuf, dwLen);
        if ( (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4) ||
             (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4LONG) ) {
            BPBCalc(pdevobj, pBuf, dwLen, BPB_COPY);
        }
        break;

    case MAGENTA:
        // Send MAGENTA data.
        DATASPOOL4FG(pdevobj, lpnp->TempFile[1], pBuf, dwLen);
        if ( (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4) ||
             (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4LONG) ) {
            BPBCalc(pdevobj, pBuf, dwLen, BPB_AND);
        }
        break;

    case CYAN:
        // Send CYAN data.
        DATASPOOL4FG(pdevobj, lpnp->TempFile[2], pBuf, dwLen);
        if ( (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4) ||
             (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4LONG) ) {
            BPBCalc(pdevobj, pBuf, dwLen, BPB_AND);
            DATASPOOL4FG(pdevobj, lpnp->TempFile[3], lpnp->BPBuf, dwLen);
            BPBCalc(pdevobj, pBuf, dwLen, BPB_CLR);
        }
        break;

    case BLACK:
        // Send BLACK data.
        if(lpnp->bComBlackMode) {
            DATASPOOL4FG(pdevobj, lpnp->TempFile[0], pBuf, dwLen);
            DATASPOOL4FG(pdevobj, lpnp->TempFile[1], pBuf, dwLen);
            DATASPOOL4FG(pdevobj, lpnp->TempFile[2], pBuf, dwLen);
	} else
            DATASPOOL4FG(pdevobj, lpnp->TempFile[3], pBuf, dwLen);
        break;

    case RGB_COLOR:

        //if( lpnp->iPlaneNumber == 4 )
            //break;

        if(((lpnp->iRibbon == CMDID_RIBBON_3COLOR_KAICHO) ||
            (lpnp->iRibbon == CMDID_RIBBON_3COLOR_SHOKA)) &&
            (lpnp->iColorMode == CMDID_MODE_COLOR))
        {
            int	i, j, iDiv;
            LPSTR	lpByte;
	    char	pad[] = "\x00\x00\x00\x00\x00\x00\x00\x00";

            i = dwLen;
            lpByte = pBuf;

            // Convert RGB to CMY
            while( --i > 0 )
                *lpByte++ ^= ~((BYTE)0);

            if(lpnp->iRibbon == CMDID_RIBBON_3COLOR_KAICHO)
                //iDiv = 29;   // KAICHO DATA : 9 step  29=(255+8)/9
                iDiv = 32;  // adjustment
            else
                iDiv = 4;    // SHOKA DATA : 64 step  4=(255+63)/64

            for( j = 0; j < lpnp->wNumScans; j++) {

		if (lpnp->wTopPad > 0 && lpnp->wTopPad <= sizeof(pad)) {
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[0], pad, lpnp->wTopPad);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[1], pad, lpnp->wTopPad);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[2], pad, lpnp->wTopPad);
		}

                for( i = 0; i < lpnp->wScanWidth; i++) {
                    (BYTE)(*pBuf) /= (BYTE)iDiv;
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[2], pBuf, 1);
		    pBuf++;

                    (BYTE)(*pBuf) /= (BYTE)iDiv;
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[1], pBuf, 1);
		    pBuf++;

                    (BYTE)(*pBuf) /= (BYTE)iDiv;
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[0], pBuf, 1);
		    pBuf++;
                }

// ISSUE-2002/3/27-takashim - Please make sure wEndPad < 8!
// It should be, but need to check.

		if (lpnp->wEndPad > 0 && lpnp->wEndPad <= sizeof(pad)) {
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[0], pad, lpnp->wEndPad);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[1], pad, lpnp->wEndPad);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[2], pad, lpnp->wEndPad);
		}
            }
        }
        else
        {
            int     h, i, j, iBlack;
	    char    SpoolBin[8];

            if(lpnp->iRibbon == CMDID_RIBBON_3COLOR_KAICHO)
                iBlack = 8;  // KAICHO DATA : 9 step
            else
                iBlack = 63; // SHOKA DATA : 64 step

            for( j = 0; j < lpnp->wNumScans; j++) {
                for( i = 0; i < lpnp->wScanWidth; i++) {
                    for( h = 0; h < 8; h++)
                        SpoolBin[h] = ((*pBuf << h) & 0x80) ? iBlack : 0;
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[0], SpoolBin, 8);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[1], SpoolBin, 8);
                    DATASPOOL4FG(pdevobj, lpnp->TempFile[2], SpoolBin, 8);
		    pBuf++;
                }
            }
        }
        break;

    default:
	//DbgPrint(DLLTEXT("OEMFilterGraphics: Invalid color(%d).\r\n"), lpnp->iColor);
        break;

    }

    return TRUE;
}


INT APIENTRY OEMCommandCallback(
PDEVOBJ pdevobj,
DWORD dwCmdCbID,
DWORD dwCount,
PDWORD pdwParams)
{

    LPPCPRDATASTRUCTURE lpnp;
    WORD   len;
    BYTE   ch[100];
    WORD   wOutByte;
    WORD   wOld;
    INT    i;
    INT    iRet = 0;
    HANDLE hToken = NULL;

    //DbgPrint(DLLTEXT("OEMCommandCallback(%d) entry.\r\n"),dwCmdCbID );
    //if ((dwCmdCbID != 25) && (dwCmdCbID != 30)&& (dwCmdCbID != 31)&& (dwCmdCbID != 60))
	//DbgPrint(DLLTEXT("OEMCommandCallback(%d) entry.\r\n"),dwCmdCbID );

    lpnp = (LPPCPRDATASTRUCTURE)(pdevobj->pdevOEM);

    switch ( dwCmdCbID ){

    case CMDID_COLOR_YELLOW:
    case CMDID_COLOR_MAGENTA:
    case CMDID_COLOR_CYAN:
    case CMDID_COLOR_BLACK:

//        if(!(lpnp->iPlaneNumber = UniDrvGetPlaneId(pdevobj)))
        if(!(lpnp->iPlaneNumber = 1))
        {
            // MINIDBG("pcpr820!fnOEMOutputCmd: Invalid iPlaneNumber = 0 \n");
        }

        switch( dwCmdCbID )
        {
        case CMDID_COLOR_YELLOW:

            // Color Y
            // Send \x1B%lD\x83
            // pdwParams: cbOut / iBytesPCol (+ 2)

            lpnp->iColor = YELLOW;

            if ( E_FAIL == SendABSMove( pdevobj, pdwParams ) ) {
                return -1;
            }
            wOutByte = (WORD)pdwParams[0] + 2;

//            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x83",
//                           LOBYTE(wOutByte), HIBYTE(wOutByte));
			len = 5;
			StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x83",LOBYTE(wOutByte), HIBYTE(wOutByte));

            DATASPOOL4CCB(pdevobj, lpnp->TempFile[0], ch, len);
            break;


        case CMDID_COLOR_MAGENTA:

            // Color M
            // Send \x1B%lDC
            // pdwParams: cbOut / iBytesPCol (+ 2)

            lpnp->iColor = MAGENTA;

            if ( E_FAIL == SendABSMove( pdevobj, pdwParams )) {
                return -1;
            }
            wOutByte = (WORD)pdwParams[0] + 2;

//            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x43",
//                            LOBYTE(wOutByte), HIBYTE(wOutByte));
			len = 5;
			StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x43",LOBYTE(wOutByte), HIBYTE(wOutByte));

            DATASPOOL4CCB(pdevobj, lpnp->TempFile[1], ch, len);
            break;


        case CMDID_COLOR_CYAN:

            // Color C
            // Send \x1B%lD# with param
            // pdwParams: cbOut / iBytesPCol (+ 2)

            lpnp->iColor = CYAN;

            if ( E_FAIL == SendABSMove( pdevobj, pdwParams )) {
                return -1;
            }
            wOutByte = (WORD)pdwParams[0] + 2;

//            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x23",
//                            LOBYTE(wOutByte), HIBYTE(wOutByte));
			len = 5;
			StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x23",LOBYTE(wOutByte), HIBYTE(wOutByte));

            DATASPOOL4CCB(pdevobj, lpnp->TempFile[2], ch, len);

            if ( (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4) ||
                 (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4LONG) ) {
//                len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x13",
//                        LOBYTE(wOutByte), HIBYTE(wOutByte));
				len = 5;
				StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x13",LOBYTE(wOutByte), HIBYTE(wOutByte));
                DATASPOOL4CCB(pdevobj, lpnp->TempFile[3], ch, len);
            }

            break;


        case CMDID_COLOR_BLACK:

            // Color K
            // Send \x1B%lD\x13
            // pdwParams: cbOut / iBytesPCol (+ 2)

            lpnp->iColor = BLACK;

            if ( E_FAIL == SendABSMove( pdevobj, pdwParams )) {
                return -1;
            }
            wOutByte = (WORD)pdwParams[0] + 2;

//            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x13",
//                    LOBYTE(wOutByte), HIBYTE(wOutByte));
			len = 5;
			StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x13",LOBYTE(wOutByte), HIBYTE(wOutByte));

            DATASPOOL4CCB(pdevobj, lpnp->TempFile[3], ch, len);
            break;
        }
        break;

    case CMDID_COLOR_BLACKONLY:

        if(lpnp->iRibbon == CMDID_RIBBON_3COLOR_A4)
	    lpnp->bComBlackMode = TRUE;

        lpnp->iColor = BLACK;
        lpnp->iPlaneNumber = BLACK;

        if ( E_FAIL == SendABSMove( pdevobj, pdwParams )) {
            return -1;
        }
        wOutByte = (WORD)pdwParams[0] + 2;

        if(lpnp->bComBlackMode)
        {
            // If an user selects glay scale with 3colors ribbon,
            // we print it with CYAN ribbon because there is not black ribbon

	    // Spec change on NT5.
	    // Make black color by 3 colors composite on this situation.

//            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x83",
//                            LOBYTE(wOutByte), HIBYTE(wOutByte));
			len = 5;
			StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x83",LOBYTE(wOutByte), HIBYTE(wOutByte));

            DATASPOOL4CCB(pdevobj, lpnp->TempFile[0], ch, len);

//            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x43",
//                            LOBYTE(wOutByte), HIBYTE(wOutByte));
			len = 5;
			StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x43",LOBYTE(wOutByte), HIBYTE(wOutByte));

            DATASPOOL4CCB(pdevobj, lpnp->TempFile[1], ch, len);

//            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x23",
//                            LOBYTE(wOutByte), HIBYTE(wOutByte));
			len = 5;
			StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x23",LOBYTE(wOutByte), HIBYTE(wOutByte));
            DATASPOOL4CCB(pdevobj, lpnp->TempFile[2], ch, len);
        }
        else
        {
//            len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x13",
//                            LOBYTE(wOutByte), HIBYTE(wOutByte));
			len = 5;
			StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x13",LOBYTE(wOutByte), HIBYTE(wOutByte));
            DATASPOOL4CCB(pdevobj, lpnp->TempFile[3], ch, len);
        }

        break;

    case CMDID_COLOR_RGB:

	if (pdwParams[0] == 0)
	    break;

//    DbgPrint(DLLTEXT("BlockData(%d,%d,%d)\r\n"),pdwParams[0],pdwParams[1],pdwParams[2] );
        lpnp->iColor = RGB_COLOR;

//        if(!(lpnp->iPlaneNumber = UniDrvGetPlaneId(pdevobj)))
        if(!(lpnp->iPlaneNumber = 1))
        {
            // MINIDBG("pcpr820!fnOEMOutputCmd: Invalid iPlaneNumber = 0 \n");
        }

        // This is 3 plane model.
        if( lpnp->iPlaneNumber == 4 )
            break;

        if ( E_FAIL == SendABSMove( pdevobj, pdwParams )) {
            return -1;
        }
        wOutByte = (WORD)(lpnp->wScanBytes * lpnp->wNumScans * 8) + 2;

//		len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x83",
//                            LOBYTE(wOutByte), HIBYTE(wOutByte));
		len = 5;
		StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x83",LOBYTE(wOutByte), HIBYTE(wOutByte));
        DATASPOOL4CCB(pdevobj, lpnp->TempFile[0], ch, len);

//        len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x43",
//                            LOBYTE(wOutByte), HIBYTE(wOutByte));
		len = 5;
		StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x43",LOBYTE(wOutByte), HIBYTE(wOutByte));
        DATASPOOL4CCB(pdevobj, lpnp->TempFile[1], ch, len);

//        len = (WORD)wsprintf( &ch[0], "\x1B%c%cD\x23",
//                            LOBYTE(wOutByte), HIBYTE(wOutByte));
		len = 5;
		StringCchPrintfA(&ch[0],sizeof(ch),"\x1B%c%cD\x23",LOBYTE(wOutByte), HIBYTE(wOutByte));
        DATASPOOL4CCB(pdevobj, lpnp->TempFile[2], ch, len);

        break;


        // \x1B\x09\x00C%l%l  param1 /8  param2 none
        // store x and y positions
    case CMDID_X_ABS_MOVE:
        wOld = lpnp->wXpos;
        lpnp->wXpos = (WORD)pdwParams[0];
        return (lpnp->wXpos > wOld ? lpnp->wXpos - wOld : wOld - lpnp->wXpos);

    case CMDID_Y_ABS_MOVE:
        wOld = lpnp->wYpos;
        lpnp->wYpos = (WORD)pdwParams[0];
        return (lpnp->wYpos > wOld ? lpnp->wYpos - wOld : wOld - lpnp->wYpos);

    case 60: // CmdYMoveRelDown
	//DbgPrint(DLLTEXT("CmdYMoveRelDown(%d) \r\n"),pdwParams[0] );
        lpnp->wYpos += (WORD)pdwParams[0];
	return pdwParams[0];

    case CMDID_BEGINPAGE:

        BPBCalc(pdevobj, 0, BPB_SIZE, BPB_CLR);

        if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x01\x00\x47", 4)) {
            return -1;
        }
        switch (lpnp->iRibbon)
        {

        case CMDID_RIBBON_MONO:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\x10", 5)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_3COLOR_A4:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\xe0", 5)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_4COLOR_A4:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\xf0", 5)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_4COLOR_A4LONG:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\xf1", 5)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_3COLOR_KAICHO:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\xe2", 5)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_3COLOR_SHOKA:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x02\x00\x44\xe3", 5)) {
                return -1;
            }
            break;

        default:
            // MINIDBG("pcpr820!fnOEMOutputCmd: Invalid Ribbon ID = %d \n", lpnp->iRibbon );
            return FALSE;
        }

        if ( E_FAIL == MDP_CreateTempFile(pdevobj, pdevobj->pdevOEM, 0)) {
            return -1;
        }
        if ( E_FAIL == MDP_CreateTempFile(pdevobj, pdevobj->pdevOEM, 1)) {
            return -1;
        }
        if ( E_FAIL == MDP_CreateTempFile(pdevobj, pdevobj->pdevOEM, 2)) {
            return -1;
        }
        if ( E_FAIL == MDP_CreateTempFile(pdevobj, pdevobj->pdevOEM, 3)) {
            return -1;
        }
	lpnp->wXpos = 0;
	lpnp->wYpos = 0;
	lpnp->iFirstColor = 0;
	lpnp->wOldNumScans = 0;
	lpnp->bComBlackMode = FALSE;
        break;

    case CMDID_ENDPAGE:

	SpoolOut(pdevobj, lpnp->TempFile[0]);
	SpoolOut(pdevobj, lpnp->TempFile[1]);
	SpoolOut(pdevobj, lpnp->TempFile[2]);
	SpoolOut(pdevobj, lpnp->TempFile[3]);

        // Close cache files.
        for (i = 0; i < 4; i++) {
            if (INVALID_HANDLE_VALUE != lpnp->TempFile[i]) {
                if (0 == CloseHandle(lpnp->TempFile[i])) {
                    ERR((DLLTEXT("CloseHandle error %d\n"),
                            GetLastError()));
                }
                lpnp->TempFile[i] = INVALID_HANDLE_VALUE;

                hToken = RevertToPrinterSelf();
                if (0 == DeleteFile(lpnp->TempName[i])) {
                    ERR((DLLTEXT("DeleteName error %d\n"),
                            GetLastError()));
                }
                if (hToken != NULL) {
                    (VOID)ImpersonatePrinterClient(hToken);
                }
                lpnp->TempName[i][0] = __TEXT('\0');
            }
        }

        if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x01\x00\x48", 4)) {
            return -1;
        }
        break;


    case CMDID_SELECT_RESOLUTION:

        switch (lpnp->iRibbon)
        {

        case CMDID_RIBBON_3COLOR_KAICHO:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x03\x00\x41\x2c\x01\x1b\x03\x00\x42\x10\x00", 12)) {
                return -1;
            }
            break;

        case CMDID_RIBBON_3COLOR_SHOKA:
            if ( E_FAIL == WRITESPOOLBUF(pdevobj, (LPSTR)"\x1b\x03\x00\x41\x2c\x01\x1b\x03\x00\x42\x20\x00", 12)) {
                return -1;
            }
            break;
        }

        break;

    case CMDID_RIBBON_MONO:
        lpnp->iRibbon = CMDID_RIBBON_MONO;
        break;

    case CMDID_RIBBON_3COLOR_A4:
        lpnp->iRibbon = CMDID_RIBBON_3COLOR_A4;
        break;

    case CMDID_RIBBON_4COLOR_A4:
        lpnp->iRibbon = CMDID_RIBBON_4COLOR_A4;
        break;

    case CMDID_RIBBON_4COLOR_A4LONG:
        lpnp->iRibbon = CMDID_RIBBON_4COLOR_A4LONG;
        break;

    case CMDID_RIBBON_3COLOR_KAICHO:
        lpnp->iRibbon = CMDID_RIBBON_3COLOR_KAICHO;
        break;

    case CMDID_RIBBON_3COLOR_SHOKA:
        lpnp->iRibbon = CMDID_RIBBON_3COLOR_SHOKA;
        break;

    case CMDID_PSIZE_LETTER:
        lpnp->pszSheetSetting[4] = P1_LETTER;
        break;

    case CMDID_PSIZE_LEGAL:
        lpnp->pszSheetSetting[4] = P1_LEGAL;
        break;

    case CMDID_PSIZE_A4:
        lpnp->pszSheetSetting[4] = P1_A4;
        break;

    case CMDID_PSIZE_A4LONG:
        lpnp->pszSheetSetting[4] = P1_A4LONG;
        break;

    case CMDID_PSIZE_B5:
        lpnp->pszSheetSetting[4] = P1_B5;
        break;

    case CMDID_PSIZE_POSTCARD:
        lpnp->pszSheetSetting[4] = P1_POSTCARD;
        break;

    case CMDID_PSOURCE_HOPPER:
        lpnp->pszSheetSetting[5] = P2_HOPPER;
        if ( E_FAIL == WRITESPOOLBUF(pdevobj, lpnp->pszSheetSetting, SHEET_CMDLEN)) {
            return -1;
        }
        break;

    case CMDID_PSOURCE_MANUAL:
        lpnp->pszSheetSetting[5] = P2_MANUAL;
        if ( E_FAIL == WRITESPOOLBUF(pdevobj, lpnp->pszSheetSetting, SHEET_CMDLEN)) {
            return -1;
        }
        break;

    case CMDID_MODE_COLOR:
        lpnp->iColorMode = CMDID_MODE_COLOR;
        break;

    case CMDID_MODE_MONO:
        lpnp->iColorMode = CMDID_MODE_MONO;
        break;
   }
   return iRet;
}

/*
  HRESULT SendABSMove

  When this function succeeds, it returns S_OK.
  When this function fails, it returns E_FAIL
*/
HRESULT SendABSMove(
PDEVOBJ pdevobj,
LPDWORD   lpdwParams)
{
    LPPCPRDATASTRUCTURE lpnp;
    WORD   len;
    BYTE   ch[100];

    lpnp = (LPPCPRDATASTRUCTURE)(pdevobj->pdevOEM);

    lpnp->wNumScans = (WORD)lpdwParams[1];
    lpnp->wScanWidth = (WORD)lpdwParams[2]; // already converted to byte unit in rasdd

    if((lpnp->iColor == RGB_COLOR) &&
       (lpnp->iColorMode == CMDID_MODE_COLOR))
    {
        lpnp->wScanWidth /= 3; // one of RGB byte
        lpnp->wScanBytes = (lpnp->wXpos + lpnp->wScanWidth)/8 - lpnp->wXpos/8 + 1;
        lpnp->wTopPad = lpnp->wXpos % 8;
        lpnp->wEndPad = (lpnp->wScanBytes * 8) - lpnp->wScanWidth - lpnp->wTopPad;
    } else {
        lpnp->wScanBytes = lpnp->wScanWidth;
        lpnp->wTopPad = 0;
        lpnp->wEndPad = 0;
    }


    if (lpnp->iFirstColor == 0)
	lpnp->iFirstColor = lpnp->iColor;

    if (lpnp->iFirstColor == lpnp->iColor) {
	lpnp->wYpos += lpnp->wOldNumScans;
	lpnp->wOldNumScans = lpnp->wNumScans;
    }


    ch[0] = 0x1B; ch[1] = 0x09; ch[2] = 0;

//    len = (WORD)wsprintf( &ch[3], "C%c%c%c%c%c%c%c%c",
//                    LOBYTE(lpnp->wXpos/8), HIBYTE(lpnp->wXpos/8),
//                    LOBYTE(lpnp->wYpos), HIBYTE(lpnp->wYpos),
//                    LOBYTE(lpnp->wScanBytes), HIBYTE(lpnp->wScanBytes),
//                    LOBYTE(lpnp->wNumScans), HIBYTE(lpnp->wNumScans));
	len = 9;
	StringCchPrintfA(&ch[3],(sizeof(ch) - 3),"C%c%c%c%c%c%c%c%c",
                    LOBYTE(lpnp->wXpos/8), HIBYTE(lpnp->wXpos/8),
                    LOBYTE(lpnp->wYpos), HIBYTE(lpnp->wYpos),
                    LOBYTE(lpnp->wScanBytes), HIBYTE(lpnp->wScanBytes),
                    LOBYTE(lpnp->wNumScans), HIBYTE(lpnp->wNumScans));

    switch (lpnp->iColor)
    {
    case YELLOW:
        return( DataSpool(pdevobj, lpnp->TempFile[0], ch, len+3) );

    case MAGENTA:
        return( DataSpool(pdevobj, lpnp->TempFile[1], ch, len+3) );
        break;

    case CYAN:
        if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[2], ch, len+3) ){
            return E_FAIL;
        }

        if ( (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4) ||
             (lpnp->iRibbon == CMDID_RIBBON_4COLOR_A4LONG) ) {
            if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[3], ch, len+3) ) {
                return E_FAIL;
            }
        }
        break;

    case BLACK:
        if(lpnp->bComBlackMode) {
            if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[0], ch, len+3) ) {
                return E_FAIL;
            }
            if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[1], ch, len+3) ) {
                return E_FAIL;
            }
            if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[2], ch, len+3)) {
                return E_FAIL;
            }
	} else
            return( DataSpool(pdevobj, lpnp->TempFile[3], ch, len+3) );
        break;

    case RGB_COLOR:
        if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[0], ch, len+3) ) {
            return E_FAIL;
        }
        if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[1], ch, len+3) ) {
            return E_FAIL;
        }
        if ( E_FAIL == DataSpool(pdevobj, lpnp->TempFile[2], ch, len+3) ) {
            return E_FAIL;
        }
        break;
    }

//    DbgPrint(DLLTEXT("SendABS(%d,%d,%d,%d)\r\n"), lpnp->wXpos, lpnp->wYpos, lpnp->wScanWidth, lpnp->wNumScans );

    return S_OK;

}

/*
  HRESULT SpoolOut

  When this function succeeds, it returns S_OK.
  When this function fails, it returns E_FAIL
*/

HRESULT SpoolOut(PDEVOBJ pdevobj, FILE* pFile)
{
    int   Size, Move, Move2;
#define	BUF_SIZE 1024
    BYTE  Tmp[BUF_SIZE];

	// spooled data output

	Size = SetFilePointer(pFile, 0L, NULL, FILE_CURRENT);
        if (INVALID_SET_FILE_POINTER == Size) {
            ERR((DLLTEXT("SetFilePointer failed %d\n"),
                GetLastError()));
            return E_FAIL;
        }

        if (0L != SetFilePointer(pFile, 0L, NULL, FILE_BEGIN)) {

            ERR((DLLTEXT("SetFilePointer failed %d\n"),
                GetLastError()));
            return E_FAIL;
        }

	while(Size){
	    Move = Size > BUF_SIZE ? BUF_SIZE : Size;
            if (0 == ReadFile(pFile, Tmp, Move, &Move2, NULL)) {
                ERR((DLLTEXT("ReadFile error in SendCachedData.\n")));
                return E_FAIL;
            }
	    if ( E_FAIL == WRITESPOOLBUF(pdevobj, Tmp, Move2)) {
                return E_FAIL;
            }
	    Size -= Move2;
	}
    return S_OK;
}

/*++

Routine Description:

  This function comes up with a name for a spool file that we should be
  able to write to.

  Note: The file name returned has already been created.

Arguments:

  hPrinter - handle to the printer that we want a spool file for.

  ppwchSpoolFileName: pointer that will receive an allocated buffer
                      containing the file name to spool to.  CALLER
                      MUST FREE.  Use LocalFree().


Return Value:

  TRUE if everything goes as expected.
  FALSE if anything goes wrong.

--*/

BOOL
GetSpoolFileName(
  IN HANDLE hPrinter,
  IN OUT PWCHAR pwchSpoolPath
)
{
  PBYTE         pBuffer = NULL;
  DWORD         dwAllocSize;
  DWORD         dwNeeded = 0;
  DWORD         dwRetval;
  HANDLE        hToken=NULL;

  //
  //  In order to find out where the spooler's directory is, we add
  //  call GetPrinterData with DefaultSpoolDirectory.
  //

  dwAllocSize = ( MAX_PATH + 1 ) * sizeof (WCHAR);

  for (;;)
  {
    pBuffer = LocalAlloc( LMEM_FIXED, dwAllocSize );

    if ( pBuffer == NULL )
    {
      ERR((DLLTEXT("LocalAlloc faild, %d\n"), GetLastError()));
      goto Failure;
    }

    if ( GetPrinterData( hPrinter,
                         SPLREG_DEFAULT_SPOOL_DIRECTORY,
                         NULL,
                         pBuffer,
                         dwAllocSize,
                         &dwNeeded ) == ERROR_SUCCESS )
    {
      break;
    }

    if ( ( dwNeeded < dwAllocSize ) ||( GetLastError() != ERROR_MORE_DATA ))
    {
      ERR((DLLTEXT("GetPrinterData failed in a non-understood way.\n")));
      goto Failure;
    }

    //
    // Free the current buffer and increase the size that we try to allocate
    // next time around.
    //

    LocalFree( pBuffer );

    dwAllocSize = dwNeeded;
  }

  hToken = RevertToPrinterSelf();

  if( !GetTempFileName( (LPWSTR)pBuffer, TEMP_NAME_PREFIX, 0, pwchSpoolPath ))
  {
      goto Failure;
  }

  //
  //  At this point, the spool file name should be done.  Free the structure
  //  we used to get the spooler temp dir and return.
  //

  LocalFree( pBuffer );

  if (NULL != hToken) {
    (VOID)ImpersonatePrinterClient(hToken);
  }

  return( TRUE );

Failure:

  //
  //  Clean up and fail.
  //
  if ( pBuffer != NULL )
  {
    LocalFree( pBuffer );
  }

  if (hToken != NULL)
  {
      (VOID)ImpersonatePrinterClient(hToken);
  }
  return( FALSE );
}

/*
  HRESULT MDP_CreateTempFile

  When this function succeeds, it returns S_OK.
  When this function fails, it returns E_FAIL
*/

HRESULT
MDP_CreateTempFile(
    PDEVOBJ pdevobj,
    LPPCPRDATASTRUCTURE pdevOEM,
    INT iPlane)
{
    HANDLE hToken = NULL;
    HANDLE hFile;

    if (!GetSpoolFileName(pdevobj->hPrinter, pdevOEM->TempName[iPlane])) {
        DBGPRINT(DBG_WARNING, ("GetSpoolFileName failed.\n"));
        return E_FAIL;
    }

    hToken = RevertToPrinterSelf();

    hFile = CreateFile(pdevOEM->TempName[iPlane],
            (GENERIC_READ | GENERIC_WRITE), 0, NULL,
            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hToken != NULL) {
        (VOID)ImpersonatePrinterClient(hToken);
    }

    if (hFile == INVALID_HANDLE_VALUE) {
        ERR((DLLTEXT("CreateFile failed.\n")))
        DeleteFile(pdevOEM->TempName[iPlane]);
        goto Error_Return;
    }

    pdevOEM->TempFile[iPlane] = hFile;

    // Normal return
    return S_OK;

Error_Return:
    pdevOEM->TempName[iPlane][0] = __TEXT('\0');
    pdevOEM->TempFile[iPlane] = INVALID_HANDLE_VALUE;

    return E_FAIL;
}


/*
  HRESULT DataSpool

  Sending data to a specified file or spooler.
  When this function succeeds, it returns S_OK.
  When this function fails, it returns E_FAIL
*/

HRESULT
DataSpool(
    PDEVOBJ pdevobj,
    HANDLE hFile,
    LPSTR lpBuf,
    DWORD dwLen)
{
    DWORD dwTemp, dwTemp2;
    BYTE *pTemp;

    if (hFile != INVALID_HANDLE_VALUE) {

        pTemp = lpBuf;
        dwTemp = dwLen;
        while (dwTemp > 0) {

            if (0 == WriteFile(hFile, pTemp, dwTemp, &dwTemp2, NULL)) {

                ERR((DLLTEXT("WriteFile error in CacheData %d.\n"),
                    GetLastError()));
                return E_FAIL;
            }
            pTemp += dwTemp2;
            dwTemp -= dwTemp2;
        }
        return S_OK;
    }
    else {
        if ( S_OK == WRITESPOOLBUF(pdevobj, lpBuf, dwLen) ) {
            return S_OK;
        }
    }

    return E_FAIL;
}



VOID
BPBCalc(
    PDEVOBJ pdevobj,
    PBYTE pDataBuf,
    DWORD dwLen,
    BYTE BPBCommand)
{
    DWORD i;
    LPPCPRDATASTRUCTURE lpnp;

    lpnp = (LPPCPRDATASTRUCTURE)(pdevobj->pdevOEM);

    if (sizeof(lpnp->BPBuf)/sizeof(*lpnp->BPBuf) < dwLen)
    {
        // Can only process upto the length of our temp. buffer.
        dwLen = sizeof(lpnp->BPBuf)/sizeof(*lpnp->BPBuf);
    }

    switch(BPBCommand)
    {
    case BPB_CLR:
        for( i = 0; i < dwLen; i++ )
            lpnp->BPBuf[i] = 0;
        break;

    case BPB_COPY:
        for( i = 0; i < dwLen; i++ )
            lpnp->BPBuf[i] = pDataBuf[i];
        break;

    case BPB_AND:
        for( i = 0; i < dwLen; i++ )
            lpnp->BPBuf[i] &= pDataBuf[i];
        break;

    case BPB_OR:
        for( i = 0; i < dwLen; i++ )
            lpnp->BPBuf[i] |= pDataBuf[i];
        break;

    }
}

/*++

Routine Name

    ImpersonationToken

Routine Description:

    This routine checks if a token is a primary token or an impersonation 
    token.    
    
Arguments:

    hToken - impersonation token or primary token of the process
    
Return Value:

    TRUE, if the token is an impersonation token
    FALSE, otherwise.
    
--*/
BOOL
ImpersonationToken(
    IN HANDLE hToken
    )
{
    BOOL       bRet = TRUE;
    TOKEN_TYPE eTokenType;
    DWORD      cbNeeded;
    DWORD      LastError;

    //
    // Preserve the last error. Some callers of ImpersonatePrinterClient (which
    // calls ImpersonationToken) rely on the fact that ImpersonatePrinterClient
    // does not alter the last error.
    //
    LastError = GetLastError();
        
    //
    // Get the token type from the thread token.  The token comes 
    // from RevertToPrinterSelf. An impersonation token cannot be 
    // queried, because RevertToPRinterSelf doesn't open it with 
    // TOKEN_QUERY access. That's why we assume that hToken is
    // an impersonation token by default
    //
    if (GetTokenInformation(hToken,
                            TokenType,
                            &eTokenType,
                            sizeof(eTokenType),
                            &cbNeeded))
    {
        bRet = eTokenType == TokenImpersonation;
    }        
    
    SetLastError(LastError);

    return bRet;
}

/*++

Routine Name

    RevertToPrinterSelf

Routine Description:

    This routine will revert to the local system. It returns the token that
    ImpersonatePrinterClient then uses to imersonate the client again. If the
    current thread doesn't impersonate, then the function merely returns the
    primary token of the process. (instead of returning NULL) Thus we honor
    a request for reverting to printer self, even if the thread is not impersonating.
    
Arguments:

    None.
    
Return Value:

    NULL, if the function failed
    HANDLE to token, otherwise.
    
--*/
HANDLE
RevertToPrinterSelf(
    VOID
    )
{
    HANDLE   NewToken, OldToken, cToken;
    BOOL	 Status;

    NewToken = NULL;

    Status = OpenThreadToken(GetCurrentThread(),
							 TOKEN_IMPERSONATE,
							 TRUE,
							 &OldToken);
    if (Status) 
    {
        //
        // We are currently impersonating
        //
		cToken = GetCurrentThread();
        Status = SetThreadToken(&cToken,
								NewToken);       
		if (!Status) {
			return NULL;
		}
    }
	else if (GetLastError() == ERROR_NO_TOKEN)
    {
        //
        // We are not impersonating
        //
        Status = OpenProcessToken(GetCurrentProcess(),
								  TOKEN_QUERY,
								  &OldToken);

		if (!Status) {
			return NULL;
		}
    }
    
    return OldToken;
}

/*++

Routine Name

    ImpersonatePrinterClient

Routine Description:

    This routine attempts to set the passed in hToken as the token for the
    current thread. If hToken is not an impersonation token, then the routine
    will simply close the token.
    
Arguments:

    hToken - impersonation token or primary token of the process
    
Return Value:

    TRUE, if the function succeeds in setting hToken
    FALSE, otherwise.
    
--*/
BOOL
ImpersonatePrinterClient(
    HANDLE  hToken)
{
    BOOL	Status;
	HANDLE	cToken;

    //
    // Check if we have an impersonation token
    //
    if (ImpersonationToken(hToken)) 
    {
		cToken = GetCurrentThread();
        Status = SetThreadToken(&cToken,
								hToken);       

        if (!Status) 
        {
            return FALSE;
        }
    }

    CloseHandle(hToken);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc82jres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc82jres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <winsplp.h> // RevertToPrinterSelf
#include <prcomoem.h>

//

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)

#define TESTSTRING      "This is a Unidrv KM test."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;


//
// OEM Signature and version.
//

#define OEM_SIGNATURE   'NC82'      // NEC PR820 printer driver
#define DLLTEXT(s)      "NC82:  " s
#define OEM_VERSION      0x00010000L

#endif  // _PDEV_H

/*************  Macro   **************/
// should create temp. file on spooler directory.
#define WRITESPOOLBUF(p, b, n) \
    ((((p)->pDrvProcs->DrvWriteSpoolBuf((p), (b), (n))) == (DWORD)(n)) ? S_OK : E_FAIL)

// DATASPOOL4FG extends DataSpool function for OEMFilterGraphics
// It returns with 0 if failed.
#define DATASPOOL4FG(p, h, b, l)  \
    if ( E_FAIL == (DataSpool((p), (h), (b), (l)) )) { \
        return 0; \
    }

// DATASPOOL4CCB extends DataSpool function for OEMCommandCallBack
// It returns with -1 if failed.
#define DATASPOOL4CCB(p, h, b, l) \
    if ( E_FAIL == (DataSpool((p), (h), (b), (l)) )){ \
        return -1; \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\nc82jres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\nec\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=nc82jres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),nc82jres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
    $(SRCDIR)\nc82jres.rc \
    $(SRCDIR)\common.c    \
    $(SRCDIR)\nc82jres.c

MISCFILES=\
    $(SRCDIR)\nc82jres.ini \
    $(GPDDIR)\nc82mj.gpd \
    $(GPDDIR)\nc823j.gpd \
    $(GPDDIR)\nc824j.gpd \
    $(GPDDIR)\nc82fj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#ifdef __cplusplus
extern "C" {
#endif // cplusplus

#include <minidrv.h>
#include <stdio.h>

#ifdef __cplusplus
}
#endif // cplusplus

#include <prcomoem.h>

//
// Misc definitions follows.
//

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
//#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'NCDL'      // NEC NPDL2 series dll
#define DLLTEXT(s)      "NCDL: " s
#define OEM_VERSION      0x00010000L

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\sources.inc ===
ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

GPDDIR=$(PRNROOT)\gpd\nec\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=ncb2jres
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLBASE=0x8000000

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\ncb2jres.rc \
    $(SRCDIR)\ncb2jres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\ncb2jres.ini \
    $(GPDDIR)\ncb168j.gpd \
    $(GPDDIR)\ncb160j.gpd \
    $(SRCDIR)\hlp\ncb2jres.hlp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\ncb2jres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "ncdlxxxx.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/


#include "pdev.h"
#include "strsafe.h"

#define WriteSpoolBuf(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

//
// For debugging.
//

//#define DBG_OUTPUTCHARSTR 1

//
// Files necessary for OEM plug-in.
//


//------------------------------------------------------------------
// define 
//------------------------------------------------------------------
#define N   4096
#define F     18
#define NIL    N

//-------------------------------------------------------------------
// OEMFilterGraphics
// Action : Compress Bitmap Data
//-------------------------------------------------------------------
BOOL
APIENTRY
OEMFilterGraphics(
PDEVOBJ lpdv,
PBYTE lpBuf,
DWORD wLen)
{
    DWORD v;//sorce buffer read pointer
    DWORD len2;//compress buffer length
    DWORD y,ku,ct;
    HANDLE hTemp;//get mem hundle
    LPSTR lpTemp;//write pointer
    LPSTR lpStart;//start pointer
    int  i, r, s, lastmatchlen, j,len;
     unsigned char code[17], mask,escJ[4],c;
    unsigned long int work;
    int  qq;
    unsigned char text[4113];             // text buffer
//    int dad[4097], lson[4097], rson[4353];      // tree
    int *dad, *lson, *rson;      // tree
    int matchpos, matchlen;

    int x, p, cmp,dummy;
    unsigned char *key;

    WORD length,outcount,codeptr;
    length = 0;
    outcount = 0;

    {
    char jj;
    BYTE d;
    for(v=0 ; v<wLen ; v++)
    {
        for(d=jj=0 ; jj<8 ; jj++)
        {
            d = ((*(lpBuf+v) << jj) & 0x80) | (d >> 1);
        }
        *(lpBuf+v) = d;
    }
    }

    lpStart = EngAllocMem(0,wLen+11,'cenD');
    lpTemp = lpStart;

    ct = 0;
    ku = 1000;
    len2 = wLen / 3;
    for( j=0;j<4;j++){
        for( y=1;y<11;y++){
            if( len2 < y*ku ){
                escJ[ct] =(unsigned char) (0x30 + (y-1));
                len2 -= (y-1)*ku;
                ct ++;
                ku = ku /10;
                break;
            }
        }
    }

	dad  = EngAllocMem(0,sizeof(int)*4097,'cenD');
	lson = EngAllocMem(0,sizeof(int)*4097,'cenD');
	rson = EngAllocMem(0,sizeof(int)*4353,'cenD');

	if( (dad == NULL) || (lson == NULL) || (rson == NULL) )
        goto no_comp;

    if(wLen < 200 ){                                    // no compress
no_comp:
        if( lpStart != NULL ){
            *lpStart = 0x4a;                                    // J
            for(i=0;i<4;i++){
                *(lpStart+(i+1)) = escJ[i];                    // Parameter
            }
            outcount = 5;
            WriteSpoolBuf(lpdv, lpStart, outcount);

            WriteSpoolBuf(lpdv, lpBuf, wLen);

//          EngFreeMem(lpStart);
        }
        EngFreeMem(lpStart);

		EngFreeMem(dad);
		EngFreeMem(lson);
		EngFreeMem(rson);

        return(wLen);
    }

    lpTemp += 11;                        // address update


    for (i = 4097; i <= 4352; i++) *(rson+i) = NIL;    // tree inital
    for (i = 0; i < 4096; i++) *(dad+i) = NIL;


    code[0] = 0;  codeptr = mask = 1;
    s = 0;  r = 4078;
    for (i = s; i < r; i++) text[i] = 0;      // buffer inital
    for (len = 0; len < 18 ; len++) {

        c = *(lpBuf + length);
        length ++;

        if (length > wLen ) break;
        text[r + len] = c;
    }

    for (i = 1; i <= 18; i++){
//--- insert_node(r - i);
        cmp = 1;  key = &text[r-i];  p = 4097 + key[0];
        *(rson+(r-i)) = *(lson+(r-i)) = NIL;  matchlen = 0;
        for ( ; ; ) {
            if (cmp >= 0) {
                if (*(rson+p) != NIL) p = *(rson+p);
                else {  *(rson+p) = (r-i);  *(dad+(r-i)) = p;  goto down1;  }
            } else {
                if (*(lson+p) != NIL) p = *(lson+p);
                else {  *(lson+p) = (r-i);  *(dad+(r-i)) = p;  goto down1;  }
            }
            for (x = 1; x < 18; x++)
                if ((cmp = key[x] - text[p + x]) != 0)  break;
            if (x > matchlen) {
                matchpos = p;
                if ((matchlen = x) >= 18)  break;
            }
        }
        *(dad+(r-i)) = *(dad+p);  *(lson+(r-i)) = *(lson+p);  *(rson+(r-i)) = *(rson+p);
        *(dad+*(lson+p)) = (r-i);  *(dad+*(rson+p)) = (r-i);
        if (*(rson+*(dad+p)) == p) *(rson+*(dad+p)) = (r-i);
        else                   *(lson+*(dad+p)) = (r-i);
        *(dad+p) = NIL;                  // p
down1:
        ; // dummy = dummy; // MSKK:10/10/2000
//--- insert_node end
    }
//--- insert_node(r);

    cmp = 1;  key = &text[r];  p = 4097 + key[0];
    *(rson+r) = *(lson+r) = NIL;  matchlen = 0;
    for ( ; ; ) {
        if (cmp >= 0) {
            if (*(rson+p) != NIL) p = *(rson+p);
            else {  *(rson+p) = r;  *(dad+r) = p;  goto down2;  }
        } else {
            if (*(lson+p) != NIL) p = *(lson+p);
            else {  *(lson+p) = r;  *(dad+r) = p;  goto down2;  }
        }
        for (x = 1; x < 18; x++)
            if ((cmp = key[x] - text[p + x]) != 0)  break;
        if (x > matchlen) {
            matchpos = p;
            if ((matchlen = x) >= 18)  break;
        }
    }
    *(dad+r) = *(dad+p);  *(lson+r) = *(lson+p);  *(rson+r) = *(rson+p);
    *(dad+*(lson+p)) = r;  *(dad+*(rson+p)) = r;
    if (*(rson+*(dad+p)) == p) *(rson+*(dad+p)) = r;
    else                   *(lson+*(dad+p)) = r;
    *(dad+p) = NIL;                  // p
down2:
//---insrt_node end

    do {
        if (matchlen > len) matchlen = len;
        if (matchlen < 3) {
            matchlen = 1;  code[0] |= mask;  code[codeptr++] = text[r];
        } else {
            code[codeptr++] = (unsigned char) matchpos;
            code[codeptr++] = (unsigned char)
                (((matchpos >> 4) & 0xf0) | (matchlen - 3));
        }
        if ((mask <<= 1) == 0) {
            outcount += codeptr;
            //compress data > original data
            if(outcount >= wLen)
                goto no_comp;
            for (i = 0; i < codeptr; i++){
                 *lpTemp = code[i];
                lpTemp++;
            }
            code[0] = 0;  codeptr = mask = 1;
        }
        lastmatchlen = matchlen;
        for (i = 0; i < lastmatchlen; i++) {
            c = *(lpBuf + length);
            length ++;
            if (length > wLen ) break;
//            delete_node(s);
//---------------
            if (*(dad+s) != NIL){
                if (*(rson+s) == NIL) qq = *(lson+s);
                else if (*(lson+s) == NIL) qq = *(rson+s);
                else {
                    qq = *(lson+s);
                    if (*(rson+qq) != NIL) {
                        do {  qq = *(rson+qq);  } while (*(rson+qq) != NIL);
                        *(rson+*(dad+qq)) = *(lson+qq);  *(dad+*(lson+qq)) = *(dad+qq);
                        *(lson+qq) = *(lson+s);  *(dad+*(lson+s)) = qq;
                    }
                    *(rson+qq) = *(rson+s);  *(dad+*(rson+s)) = qq;
                }
                *(dad+qq) = *(dad+s);
                if (*(rson+*(dad+s)) == s) *(rson+*(dad+s)) = qq;
                else                   *(lson+*(dad+s)) = qq;
                *(dad+s) = NIL;
            }
//-------------
            text[s] = c;
            if (s < 17) text[s + 4096] = c;
            s = (s + 1) & 4095;  r = (r + 1) & 4095;
//---        insert_node(r);
            cmp = 1;  key = &text[r];  p = 4097 + key[0];
            *(rson+r) = *(lson+r) = NIL;  matchlen = 0;
            for ( ; ; ) {
                if (cmp >= 0) {
                    if (*(rson+p) != NIL) p = *(rson+p);
                    else {  *(rson+p) = r;  *(dad+r) = p;  goto down3;  }
                } else {
                    if (*(lson+p) != NIL) p = *(lson+p);
                    else {  *(lson+p) = r;  *(dad+r) = p;  goto down3;  }
                }
                for (x = 1; x < 18; x++)
                    if ((cmp = key[x] - text[p + x]) != 0)  break;
                if (x > matchlen) {
                    matchpos = p;
                    if ((matchlen = x) >= 18)  break;
                }
            }
            *(dad+r) = *(dad+p);  *(lson+r) = *(lson+p);  *(rson+r) = *(rson+p);
            *(dad+*(lson+p)) = r;  *(dad+*(rson+p)) = r;
            if (*(rson+*(dad+p)) == p) *(rson+*(dad+p)) = r;
            else                   *(lson+*(dad+p)) = r;
            *(dad+p) = NIL;                  // p
down3:
//--- insert_node end
        dummy = dummy;
        }
        while (i++ < lastmatchlen) {
//            delete_node(s);
//---------------
            if (*(dad+s) != NIL){
                if (*(rson+s) == NIL) qq = *(lson+s);
                else if (*(lson+s) == NIL) qq = *(rson+s);
                else {
                    qq = *(lson+s);
                    if (*(rson+qq) != NIL) {
                        do {  qq = *(rson+qq);  } while (*(rson+qq) != NIL);
                        *(rson+*(dad+qq)) = *(lson+qq);  *(dad+*(lson+qq)) = *(dad+qq);
                        *(lson+qq) = *(lson+s);  *(dad+*(lson+s)) = qq;
                    }
                    *(rson+qq) = *(rson+s);  *(dad+*(rson+s)) = qq;
                }
                *(dad+qq) = *(dad+s);
                if (*(rson+*(dad+s)) == s) *(rson+*(dad+s)) = qq;
                else                   *(lson+*(dad+s)) = qq;
                *(dad+s) = NIL;
            }
//-------------

            s = (s + 1) & (4095);  r = (r + 1) & (4095);
            if (--len){
//--- insert_node(r);

                cmp = 1;  key = &text[r];  p = 4097 + key[0];
                *(rson+r) = *(lson+r) = NIL;  matchlen = 0;
                for ( ; ; ) {
                    if (cmp >= 0) {
                        if (*(rson+p) != NIL) p = *(rson+p);
                        else {  *(rson+p) = r;  *(dad+r) = p;  goto down4;  }
                    } else {
                        if (*(lson+p) != NIL) p = *(lson+p);
                        else {  *(lson+p) = r;  *(dad+r) = p;  goto down4;  }
                    }
                    for (x = 1; x < 18; x++)
                        if ((cmp = key[x] - text[p + x]) != 0)  break;
                    if (x > matchlen) {
                        matchpos = p;
                        if ((matchlen = x) >= 18)  break;
                    }
                }
                *(dad+r) = *(dad+p);  *(lson+r) = *(lson+p);  *(rson+r) = *(rson+p);
                *(dad+*(lson+p)) = r;  *(dad+*(rson+p)) = r;
                if (*(rson+*(dad+p)) == p) *(rson+*(dad+p)) = r;
                else                   *(lson+*(dad+p)) = r;
                *(dad+p) = NIL;                  // p
down4:
                dummy = dummy;
//--- insert_node end
            }
        }
    } while (len > 0);

    if (codeptr > 1) {
        outcount += codeptr;
        //compress data > orignal data 
        if(outcount >= wLen)
            goto no_comp;
        for (i = 0; i < codeptr; i++){
             *lpTemp = code[i];
            lpTemp++;
        }
    }
    //compress data sousin
        lpTemp = lpStart;
// 1999 04.22
    ct = 1;
    ku = 1000;
    work = outcount;
    for( j=0;j<4;j++){
        for( y=1;y<11;y++){                                    // 1000
            if( work < (unsigned long int)y*ku ){
                *(lpTemp + ct ) =(unsigned char) (0x30+(y-1));
                work -= (y-1)*ku;
                ct ++;
                ku = ku /10;
                break;
            }
        }
    }
    *lpTemp = 0x7a;
    *(lpTemp+5) =0x2c;
    for(i=6;i<10;i++){
        *(lpTemp+i) = escJ[i-6];
    }
    *(lpTemp+10) = 0x2e;

    outcount += 11;

// 1999.04.22

       WriteSpoolBuf(lpdv, lpTemp, outcount);
    //mem free
    EngFreeMem(lpTemp);

	EngFreeMem(dad);
	EngFreeMem(lson);
	EngFreeMem(rson);
    return(wLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
//     "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
//     "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
//     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
//     "EnablePDEV",
    "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/
// NTRAID#NTBUG9-588591-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        return E_NOTIMPL;
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

        if (OEMFilterGraphics(pdevobj, pBuf, dwLen) <= 0) {
            return E_FAIL;
        }
        else {
            return S_OK;
        }
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncb2jres\hlp\ncb2jres.h ===
/* KANJI CODE */
/*#define POP_75_PQUALITIESNEW         7560
#define POP_75_KANJICODE             7570
#define POP_75_PDENSITY              7571
*/
#define POP_70_YOUSIHOUKOU           7560
#define POP_70_YOUSIHOUKOU2          7590
#define POP_70_KANJICODE             7570


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncdljres\debug.c ===
#include <minidrv.h>
// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Use strsafe.h(pdev.h)
#include "pdev.h"
//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncdljres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:
// NOTICE-2002/3/18-v-sueyas-
//    04/07/97 -zhanw-
//        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.


DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING,("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        DBGPRINT(DBG_WARNING,("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING,("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING,("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING,("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING,("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING,("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING,("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING,("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncdljres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:
// NOTICE-2002/3/18-v-sueyas-
//        98/4/24 takashim:
//        Written the original sample so that it is more C++.

--*/
// NTRAID#NTBUG9-588592-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));

		// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
	    if (NULL == ppv)
	        return E_NOINTERFACE;

        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
// NTRAID#NTBUG9-741174-2002/11/20-yasuho-: Memory leak happened.
        if (NULL == pDevOem)
            return E_FAIL;

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,
            phsurfPatterns, cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
// NTRAID#NTBUG9-741174-2002/11/20-yasuho-: Memory leak happened.
        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

		// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
        return strcmp(
	        (NULL == p1 ? "" : *((char **)p1)),
	        (NULL == p2 ? "" : *((char **)p2)));

    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

		// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
		if (NULL == piResult)
			return E_FAIL;

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

        if (!OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
            return E_FAIL;
        }
        else {
            return S_OK;
        }
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

		// NTRAID#NTBUG9-580367-2002/03/18-v-sueyas-: Error handling
        if (bOEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph))
	        return S_OK;
		else
			return E_FAIL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

		// NTRAID#NTBUG9-580367-2002/03/18-v-sueyas-: Error handling
        if (bOEMSendFontCmd(pdevobj, pUFObj, pFInv))
	        return S_OK;
		else
			return E_FAIL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
		// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
	    if (NULL == ppv)
	        return E_NOINTERFACE;

        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncdljres\ncdljres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "ncdlxxxx.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

// NOTICE-2002/3/18-v-sueyas-
//    04/07/97 -zhanw-
//        Created it.

--*/

#include "pdev.h"

//
// Misc definitions and declarations.
//

#define ALLOCMEM EngAllocMem
#define FREEMEM EngFreeMem

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

//
// command callback ID's
//

#define CMD_MOVE_X                  23
#define CMD_MOVE_Y                  24
#define CMD_BEGIN_RASTER            26
#define CMD_RES_600                 27
#define CMD_RES_400                 28
#define CMD_RES_240                 29
#define CMD_SEND_BLOCK_DATA         30
#define CMD_BEGIN_RASTER_NO_COMP    31
#define CMD_INIT_COORDINATE         32
#define CMD_PC_PRN_DIRECTION        50
#define CMD_CR                      51
#define CMD_FF                      52

// #278517: RectFill
#define CMD_RECTWIDTH               60
#define CMD_RECTHEIGHT              61
#define CMD_RECTWHITE               62
#define CMD_RECTBLACK               63
#define CMD_RECTGRAY                64

// MW2250H, MW2300
#define CMD_RES_1200                70

// Text color
#define CMD_WHITE_ON                80
#define CMD_WHITE_OFF               81

// Font Attrib
#define CMD_BOLD_ON                 82
#define CMD_ITALIC_ON               83
#define CMD_CLEAR_ATTRIB            84
#define CMD_CLEAR_ATTRIB_P          85

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->wRes = 1;
    pOEMExtra->pCompBuf = NULL;
    pOEMExtra->dwCompBufLen = 0;
    pOEMExtra->dwScanLen = 0;
    pOEMExtra->dwDeviceDestX = 0;
    pOEMExtra->dwDeviceDestY = 0;
    pOEMExtra->dwDevicePrevX = 0;
    pOEMExtra->dwDevicePrevY = 0;
    pOEMExtra->iGray = 0;
    pOEMExtra->cSubPath = 0;
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
// NOTICE-2002/3/18-v-sueyas-
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->wRes    = pdmIn->wRes;
        pdmOut->wScale = pdmIn->wScale;
        pdmOut->lPointsx = pdmIn->lPointsx;
        pdmOut->lPointsy = pdmIn->lPointsy;
        pdmOut->dwSBCSX = pdmIn->dwSBCSX;
        pdmOut->dwDBCSX = pdmIn->dwDBCSX;
        pdmOut->lSBCSXMove = pdmIn->lSBCSXMove;
        pdmOut->lSBCSYMove = pdmIn->lSBCSYMove;
        pdmOut->lDBCSXMove = pdmIn->lDBCSXMove;
        pdmOut->lDBCSYMove = pdmIn->lDBCSYMove;
        pdmOut->lPrevXMove = pdmIn->lPrevXMove;
        pdmOut->lPrevYMove = pdmIn->lPrevYMove;
        pdmOut->fGeneral = pdmIn->fGeneral;
        pdmOut->wCurrentAddMode = pdmIn->wCurrentAddMode;
        pdmOut->dwDeviceDestX = pdmIn->dwDeviceDestX;
        pdmOut->dwDeviceDestY = pdmIn->dwDeviceDestY;
        pdmOut->dwDevicePrevX = pdmIn->dwDevicePrevX;
        pdmOut->dwDevicePrevY = pdmIn->dwDevicePrevY;
    }

    return TRUE;
}


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA
//
//  Description:  Convert from numeral into a character
//-----------------------------------------------------------------------------
static int
iDwtoA(LPSTR buf, DWORD n)
{
    int  i, j;

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA_FillZero
//
//  Description:  Convert from numeral into a character and
//                fill a field which was specified with 0
//-----------------------------------------------------------------------------
static int
iDwtoA_FillZero(LPSTR buf, DWORD n, int fw)
{
    int  i , j, k, l;

    l = n;  // for later

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    for( k = 0; l; k++ ) {
        l /= 10;
    }
    if( k < 1) k++;

    k = fw - k;
    if(k > 0){;
        for (j = i; 0 < j + 1; j--){
            buf[j + k] = buf[j];
        }
        for ( j = 0; j < k; j++){
            buf[j] = '0';
        }
        i = i + k;
    }

    return i;
}

//-----------------------------------------------------------------------------
//
//  Function:   memcopy
//
//  Description:  Copy the memory from Src to Dest
//-----------------------------------------------------------------------------
static int
memcopy(LPSTR lpDst, LPSTR lpSrc, WORD wLen)
{
    WORD rLen;

    rLen = wLen;

    while(wLen--) *lpDst++ = *lpSrc++;
    return rLen;
}

//------------------------------------------------------------------
// RLE1
// Action : compress image data with RLE1
//------------------------------------------------------------------
DWORD RLE1(
PBYTE pDst,
PBYTE pSrc,
DWORD   dwLen)
{
    PBYTE pTemp, pEnd, pDsto;
    DWORD   len, deflen;

    pDsto = pDst;
    pEnd = pSrc + dwLen;

    while(pSrc < pEnd)
    {
        pTemp = pSrc++;

        if(pSrc == pEnd)
        {
            *pDst++ = 0x41;
            *pDst++ = *pTemp;
            break;
        }

        if(*pTemp == *pSrc)
        {
            pSrc++;

            while(pSrc < pEnd && *pTemp == *pSrc) pSrc++;

            len = (DWORD)(pSrc - pTemp);

            if(len < 63)
            {
                *pDst++ = 0x80 + (BYTE)len;
                goto T1;
            }

            *pDst++ = 0xbf;
            len -= 63;

            while(len >= 255)
            {
                *pDst++ = 0xff;
                len -= 255;
            }

            *pDst++ = (BYTE)len;
T1:
            *pDst++ = *pTemp;
            continue;
        }

        pSrc++;

        while(pSrc < pEnd)
        {
            if(*pSrc == *(pSrc - 1))
            {
                pSrc--;
                break;
            }

            pSrc++;
        }

        deflen = len = (DWORD)(pSrc - pTemp);

        if(len < 63)
        {
            *pDst++ = 0x40 + (BYTE)len;
            goto T2;
        }

        *pDst++ = 0x7f;
        len -= 63;

        while(len >= 255)
        {
            *pDst++ = 0xff;
            len -= 255;
        }

        *pDst++ = (BYTE)len;
T2:
        memcpy(pDst, pTemp, deflen);
        pDst += deflen;
    }

    return (DWORD)(pDst - pDsto);
}


//------------------------------------------------------------------
// RLC2Comp
// Action : compress image data with RLE2
//------------------------------------------------------------------
DWORD
RLC2Comp(
    PBYTE pOutBuf,
    PBYTE pInBuf,
    DWORD dwInLen,
    DWORD dwScanLen
    )
{
    DWORD     dwlen, dwDatalen, dwCounter;
    PBYTE     pLBuff;
    PBYTE     pBuff, pTemp, pBuffo, pEnd;
    PBYTE     pBuff2, pBuff2o;

VERBOSE(("RLC2Comp() In +++\r\n"));

    dwCounter = dwInLen / dwScanLen;
    pLBuff = pBuffo = pBuff = pTemp = pInBuf;    // Copy Src first pointer
    pBuff2o = pBuff2 = pOutBuf;                  // Copy Dst first pointer

    /*
     * We compare contents of First line with 0x00
     */
    pEnd = pBuff + dwScanLen;

    while(pBuff < pEnd)
    {
        while(pBuff < pEnd && 0x00 != *pBuff)
        {
            pBuff++;
        }

        dwlen = (DWORD)(pBuff - pTemp);

        if(dwlen)
        {
            pBuff2 += RLE1(pBuff2, pTemp, dwlen);
            pTemp = pBuff;
        }

        if(pBuff == pEnd) break;

        while(pBuff < pEnd && 0x00 == *pBuff)
        {
            pBuff++;
        }

        dwlen = (DWORD)(pBuff - pTemp);

        if(dwlen < 63)
        {
            *pBuff2++ = (BYTE)dwlen;
            goto T1;
        }

        *pBuff2++ = 0x3f;
        dwlen -= 63;

        while(dwlen >= 255)
        {
            *pBuff2++ = (BYTE)0xff;
            dwlen -= 255;
        }

        *pBuff2++ = (BYTE)dwlen;
T1:
        pTemp = pBuff;
    }

    dwCounter--;

    *pBuff2++ = (BYTE)0x80;
    dwDatalen = (DWORD)(pBuff2 - pBuff2o);

    // If the compressed bitmap size is larger than nomal bitmap size,
    // we don't compress
    if(dwDatalen > dwInLen)
    {
VERBOSE(("goto NO_COMP\r\n"));
        goto NO_COMP;
    }

    if(!dwCounter)
        return dwDatalen;

    /*
     * We compare the 1 previous line with the present line
     */
    do
    {
        pEnd = pBuff + dwScanLen;

        while(pBuff < pEnd)
        {
            while(pBuff < pEnd && *pLBuff != *pBuff)
            {
                pLBuff++;
                pBuff++;
            }

            dwlen = (DWORD)(pBuff - pTemp);

            if(dwlen)
            {
                pBuff2 += RLE1(pBuff2, pTemp, dwlen);
                pTemp = pBuff;
            }

            if(pBuff == pEnd) break;

            while(pBuff < pEnd && *pLBuff == *pBuff)
            {
                pLBuff++;
                pBuff++;
            }

            dwlen = (DWORD)(pBuff - pTemp);

            if(dwlen < 63)
            {
                *pBuff2++ = (BYTE)dwlen;
                goto T2;
            }

            *pBuff2++ = 0x3f;
            dwlen -= 63;

            while(dwlen >= 255)
            {
                *pBuff2++ = (BYTE)0xff;
                dwlen -= 255;
            }

            *pBuff2++ = (BYTE)dwlen;
T2:
            pTemp = pBuff;
        }

        *pBuff2++ = (BYTE)0x80;
        dwDatalen = (DWORD)(pBuff2 - pBuff2o);

        // If the compressed bitmap size is larger than nomal bitmap size,
        // we don't compress
        if(dwDatalen > dwInLen)  // full buffer
        {
VERBOSE(("goto NO_COMP\r\n"));
            goto NO_COMP;
        }
    }
    while(--dwCounter);

VERBOSE(("RLC2Comp() COMP Out---\r\n\r\n"));
    return dwDatalen;

NO_COMP:

VERBOSE(("RLC2Comp() NO_COMP Out---\r\n\r\n"));
    return 0;
}

//-------------------------------------------------------------------
// OEMFilterGraphics
// Action : Compress Bitmap Data
//-------------------------------------------------------------------
BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE   pBuf,
    DWORD   dwLen
    )
{
    POEMUD_EXTRADATA    pOEM;
    INT         i;
    BYTE            Cmd[128];
    PBYTE pOutBuf;
    DWORD dwOutLen;
    BYTE jCompMethod;

VERBOSE(("OEMFilterGraphics() In +++++++++++++++++++++++++++++\r\n"));

	// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj || 0 == dwLen)
    {
        ERR(("OEMFilterGraphics: Invalid parameter(s).\n"));
        return FALSE;
    }

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

	// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pOEM)
    {
        ERR(("OEMFilterGraphics: Invalid parameter(s).\n"));
        return FALSE;
    }

    // Sanity check.

    if (!pBuf || pOEM->dwScanLen == 0) {
        ERR(("Invalid parameter.\r\n"));
        return FALSE;
    }

    // Prepare temp. buffer for compression.

#ifdef BYPASS
    if ((!pOEM->pCompBuf || pOEM->dwCompBufLen < dwLen) &&
        !(pOEM->fGeneral & FG_NO_COMP)){
#else
    if (!pOEM->pCompBuf || pOEM->dwCompBufLen < dwLen) {
#endif // BYPASS

        if (pOEM->pCompBuf) {
            FREEMEM(pOEM->pCompBuf);
        }

		// NTRAID#NTBUG9-580363-2002/03/18-v-sueyas-: Check for deviding by zero
	    if (0 == pOEM->dwScanLen)
	    {
	        ERR(("OEMFilterGraphics: pOEM->dwScanLen = 0.\n"));
	        return FALSE;
	    }

        pOEM->pCompBuf = ALLOCMEM(0,
                          (dwLen << 1) + (dwLen / pOEM->dwScanLen),
                          (ULONG)'NCDL');
        pOEM->dwCompBufLen = dwLen;
    }

    // Try compression methods.

    dwOutLen = 0;
    if (pOEM->pCompBuf != NULL) {

        pOutBuf = pOEM->pCompBuf;

        // Try RLC2 method;
        if (dwOutLen == 0) {
            if ((dwOutLen = RLC2Comp(pOutBuf, pBuf,
                                      dwLen, pOEM->dwScanLen)) > 0)
                jCompMethod = '5';
        }
    }

    if (dwOutLen == 0) {

        // Any of the Compression menthod faild.
        // We will send data to the printer withtout
        // compression.

        pOutBuf = pBuf;
        dwOutLen = dwLen;
        jCompMethod = '0';  // Without compression.
    }

    /* Send a draw coordinate command to the printer. */
    i = 0;
    i += memcopy(&Cmd[i], "\034e", 2);
    i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
    Cmd[i++] = '.';

    /* Save the present coordinate. */
    pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
    pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;

    /* Send an image data draw command. */
    i += memcopy(&Cmd[i], "\034i", 2);
    i += iDwtoA(&Cmd[i], (pOEM->dwScanLen << 3));
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], (dwLen / pOEM->dwScanLen));
    Cmd[i++] = ',';
    Cmd[i++] = jCompMethod;
    i += memcopy(&Cmd[i], ",1/1,1/1,", 9);
    i += iDwtoA(&Cmd[i], dwOutLen);
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], (MASTER_UNIT / pOEM->wRes));
    Cmd[i++] = '.';
    WRITESPOOLBUF(pdevobj, Cmd, i);

    /* Send an image data */
    WRITESPOOLBUF(pdevobj, pOutBuf, dwOutLen);
VERBOSE(("OEMFilterGraphics() Out-------------------------------\r\n\r\n"));

    return TRUE;

}


//-----------------------------------------------------------------------------
//
//  Function:   OEMCommandCallback
//
//-----------------------------------------------------------------------------
INT
APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT         i;
    BYTE            *bp;
    BYTE            Cmd[128];
    POEMUD_EXTRADATA    pOEM;
    INT iRet;
    DWORD dwDeviceDestX, dwDeviceDestY;
    UINT gray;

	// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("OEMCommandCallback: Invalid parameter(s).\n"));
        return 0;
    }

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    i = 0;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    iRet = 0;

	// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pOEM)
    {
        ERR(("OEMCommandCallback: pdevobj->pOEMDM = 0.\n"));
        return 0;
    }

    /*
     * There are four kinds of draw modes of this driver.When entering a
     * new draw mode, it send the commands which ends the previous draw mode
     * at the same time.
     * 1.FLAG_RASTER - raster image mode.The condition not to enter
     *                 a vector mode and a text mode.
     *                 Default condition is RASTER in this driver
     * 2.FLAG_SBCS   - single byte text mode. IN: FSa, OUT:FSR
     * 3.FLAG_DBCS   - double byte text mode. IN: FSa, OUT:FSR
     * 4.FLAG_VECTOR - vector mode.  IN: FSY, OUT:FSZ
     */
     switch (dwCmdCbID) {

    case CMD_CR:

        pOEM->dwDeviceDestX = 0;
        WRITESPOOLBUF(pdevobj, "\015", 1);
        break;

    case CMD_MOVE_X:
    case CMD_MOVE_Y:

		// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
        if (dwCount < 4 || !pdwParams)
            return 0;      // cannot do anything

        pOEM->dwDeviceDestX = PARAM(pdwParams, 0) /
                (MASTER_UNIT / PARAM(pdwParams, 2));
        pOEM->dwDeviceDestY = PARAM(pdwParams, 1) /
                (MASTER_UNIT / PARAM(pdwParams, 3));

        // Set return value

        switch (dwCmdCbID) {
        case CMD_MOVE_X:
            iRet = (INT)pOEM->dwDeviceDestX;
            break;
        case CMD_MOVE_Y:
            iRet = (INT)pOEM->dwDeviceDestY;
            break;
        }

        break;

// MW2250H, MW2300
    case CMD_RES_1200:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/1200,i.\x1CYSC;SU1,1200,0;PM1,1;SG0;\x1CZ", 39);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 1200;
        break;

    case CMD_RES_600:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/600,i.\x1CYSC;SU1,600,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 600;
        break;

    case CMD_RES_400:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/400,i.\x1CYSC;SU1,400,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 400;
        break;

    case CMD_RES_240:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/240,i.\x1CYSC;SU1,240,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 240;
        break;

    case CMD_BEGIN_RASTER:

        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i = 0;
            i += memcopy(&Cmd[i], "\034R", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        break;

    case CMD_SEND_BLOCK_DATA:

		// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
	    if (dwCount < 1 || !pdwParams)
	        return 0;

        // Rememter length of the scan line.

        pOEM->dwScanLen = PARAM(pdwParams, 0);
        break;

#ifdef BYPASS
    case CMD_BEGIN_RASTER_NO_COMP:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i = 0;
            i += memcopy(&Cmd[i], "\034R", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        pOEM->fGeneral |= FG_NO_COMP;
        break;

#endif // BYPASS

    case CMD_PC_PRN_DIRECTION:
// 02/04/09 NES Niigata : Check for illegal parameters
	if (dwCount < 1 || !pdwParams)
	    return 0;

        {
        LONG lEsc90;
        LONG ESin[] = {0, 1, 0, -1};
        LONG ECos[] = {1, 0, -1, 0};

        lEsc90 = (PARAM(pdwParams, 0) % 360) / 90;

        pOEM->lSBCSXMove = pOEM->dwSBCSX * ECos[lEsc90];
        pOEM->lSBCSYMove = -(LONG)pOEM->dwSBCSX * ESin[lEsc90];
        pOEM->lDBCSXMove = pOEM->dwDBCSX * ECos[lEsc90];
        pOEM->lDBCSYMove = -(LONG)pOEM->dwDBCSX * ESin[lEsc90];
        }
        break;

    case CMD_FF:

        i = 0;
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i += memcopy(&Cmd[i], "EP;FL;\x1CZ\x0D\x0C", 10);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i += memcopy(&Cmd[i], "\x1CR\x0D\x0C", 4);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else{
            i += memcopy(&Cmd[i], "\x0D\x0C", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        break;

    case CMD_INIT_COORDINATE:
        pOEM->dwDeviceDestX = 0;
        pOEM->dwDeviceDestY = 0;
        pOEM->wCurrentAddMode = FLAG_RASTER;
        pOEM->cSubPath = 0;

        break;

    case CMD_WHITE_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034\"R.\034$100.", 10);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_WHITE_OFF:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034\"O.\034$0.", 8);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_BOLD_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,1.", 6);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_ITALIC_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,2.", 6);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_CLEAR_ATTRIB:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,0.", 6);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_CLEAR_ATTRIB_P:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,0,80.", 9);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_RECTWIDTH:

		// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
	    if (dwCount < 1 || !pdwParams)
	        return 0;

		// NTRAID#NTBUG9-580363-2002/03/18-v-sueyas-: Check for deviding by zero
	    if (0 == pOEM->wRes)
	        return 0;

        pOEM->dwRectWidth = PARAM(pdwParams, 0) / pOEM->wRes;
        break;

    case CMD_RECTHEIGHT:

		// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
	    if (dwCount < 1 || !pdwParams)
	        return 0;

		// NTRAID#NTBUG9-580363-2002/03/18-v-sueyas-: Check for deviding by zero
	    if (0 == pOEM->wRes)
	        return 0;

        pOEM->dwRectHeight = PARAM(pdwParams, 0) / pOEM->wRes;
        break;

    case CMD_RECTWHITE:
        gray = 100;
        goto fill;
    case CMD_RECTBLACK:
        gray = 0;
        goto fill;
    case CMD_RECTGRAY:

		// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
	    if (dwCount < 1 || !pdwParams)
	        return 0;

        gray = 100 - PARAM(pdwParams, 0);
        goto fill;

    fill:
        {
        // if rectangle size is zeor,we do not draw.
        if(pOEM->dwRectWidth - 1 < 1 && pOEM->dwRectHeight - 1 < 1)
            break;

        i = 0;
        /* Raster mode -> Vector mode in */
        if (pOEM->wCurrentAddMode == FLAG_RASTER){
            i += memcopy(&Cmd[i], "\x1CY", 2);
            pOEM->wCurrentAddMode = FLAG_VECTOR;
            if(pOEM->iGray != gray){
                i += memcopy(&Cmd[i], "SG", 2);   // Send Gray Scale
                i += iDwtoA(&Cmd[i], gray);
                Cmd[i++] = ';';
                pOEM->iGray = gray;
            }
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
    }
        /* Text mode -> Vector mode in */
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i += memcopy(&Cmd[i], "\x1CR\x1CY", 4);
            pOEM->wCurrentAddMode = FLAG_VECTOR;
            if(pOEM->iGray != gray){
                i += memcopy(&Cmd[i], "SG", 2);   // Send Gray Scale
                i += iDwtoA(&Cmd[i], gray);
                Cmd[i++] = ';';
                pOEM->iGray = gray;
            }
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
        }

        /* Already Vector mode and gray scale changed  or
           sub path count is over 500 */
        if(pOEM->iGray != gray){
            i += memcopy(&Cmd[i], "EP;FL;SG", 8);
            i += iDwtoA(&Cmd[i], gray);
            i += memcopy(&Cmd[i], ";NP;", 4);
            pOEM->iGray = gray;
            pOEM->cSubPath = 0;
        }
        else if(pOEM->cSubPath >= MAX_SUBPATH){
            i += memcopy(&Cmd[i], "EP;FL;", 6);
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
        }

        i += memcopy(&Cmd[i], "MA", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
        i += memcopy(&Cmd[i], ";PR", 3);
        i += iDwtoA(&Cmd[i], pOEM->dwRectWidth - 1);
        i += memcopy(&Cmd[i], ",0,0,", 5);
        i += iDwtoA(&Cmd[i], pOEM->dwRectHeight - 1);
        i += memcopy(&Cmd[i], ",-", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwRectWidth - 1);
        i += memcopy(&Cmd[i], ",0;CP;", 6);
        pOEM->cSubPath+=4;   // rect is built by 4 line

        // some model have to close pass when rect width or height under 1

        pOEM->cSubPath = MAX_SUBPATH;

        /* send RectFill command */
        WRITESPOOLBUF(pdevobj, Cmd, i);
        }

        break;
    }
    return iRet;
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMSendFontCmd
//
//-----------------------------------------------------------------------------
// NTRAID#NTBUG9-580367-2002/03/18-v-sueyas-: Error handling
BOOL
APIENTRY
bOEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4]; // it means dwSize + dwNumOfVariable +
                                       // (dwStdVarID + lStdVariable) * n
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    POEMUD_EXTRADATA    pOEM;
    DWORD   tmpPointsx, tmpPointsy;
    PIFIMETRICS pIFI;
    DWORD       dwNeeded;
    DWORD       dwCount;
    BOOL        bFound = FALSE;

    VERBOSE(("OEMSendFontCmd() entry.\r\n"));
    VERBOSE((("CMD size:%ld\r\n"), pFInv->dwCount));

	// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj || NULL == pUFObj || NULL == pFInv)
    {
        ERR(("bOEMSendFontCmd: Invalid parameter(s).\n"));
        return FALSE;
    }

    if(!pFInv->dwCount){
        VERBOSE(("CMD size is Zero return\r\n"));
        return FALSE;
    }
    pubCmd = pFInv->pubCommand;
    dwCount = pFInv->dwCount;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

	// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pubCmd || NULL == pOEM)
    {
        ERR(("bOEMSendFontCmd: pFInv->pubCommand = 0 Or pdevobj->pOEMDM = 0.\n"));
        return FALSE;
    }

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;

// 02/04/09 NES Niigata : Check for illegal parameters
    if (NULL == pSV)
    {
        ERR(("OEMSendFontCmd: pSV = 0.\n"));
        return FALSE;
    }

    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
            pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return FALSE;
    }
    VERBOSE((("FONTHEIGHT=%d\r\n"), pSV->StdVar[0].lStdVariable));
    VERBOSE((("FONTWIDTH=%d\r\n"), pSV->StdVar[1].lStdVariable));

    tmpPointsy = pSV->StdVar[0].lStdVariable * 720 / pSV->StdVar[2].lStdVariable;
    dwIn = dwOut = 0;

    /* vector mode ends.*/
    if (pOEM->wCurrentAddMode == FLAG_VECTOR){
        dwOut += memcopy(&aubCmd[dwOut], "EP;FL;\034Z", 8);
    }

    /* make font select command */
    while(dwCount--)
    {
        if(pubCmd[dwIn] !='#'){
            aubCmd[dwOut] = pubCmd[dwIn];
            dwOut++;
            dwIn++;
        }
        else{
            bFound = TRUE;
            break;
        }
    }

    if(bFound == TRUE)
        dwIn++;
    else
        return FALSE;   // mismatch font command

    pOEM->fGeneral &= ~(FG_VERT | FG_PLUS | FG_DBCS);

    switch(pubCmd[dwIn])
    {
    case 'O':                 // for OCR-B Font support
        pOEM->fGeneral |= FG_PLUS;
        tmpPointsy = tmpPointsx = 120 * pOEM->wRes;  // Only 12pt
        break;

    case 'R':                 // NPDL2P SBCS
        pOEM->fGeneral |= FG_PLUS;
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1200 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'P':                // NPDL2 SBCS
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1200 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'W':                // NPDL2 DBCS and FontCard
        pOEM->fGeneral |= FG_VERT;

    case 'Q':
        pOEM->fGeneral |= FG_DBCS;
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1440 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'Y':                // NPDL2P DBCS and FontCard
        pOEM->fGeneral |= FG_VERT;

    case 'S':
        pOEM->fGeneral |= (FG_PLUS | FG_DBCS);
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1440 /
                     pSV->StdVar[2].lStdVariable;
        break;
    }

	// NTRAID#NTBUG9-580363-2002/03/18-v-sueyas-: Check for deviding by zero
    if (0 == pOEM->wRes)
		return FALSE;

    if(pOEM->fGeneral & FG_PLUS)
    {
        if(tmpPointsy > 9999)    tmpPointsy = 9999;
        else if(tmpPointsy < 10) tmpPointsy = 10;

        if(tmpPointsx > 9999)    tmpPointsx = 9999;
        else if(tmpPointsx < 10) tmpPointsx = 10;

        pOEM->wScale = tmpPointsx == tmpPointsy;
        pOEM->lPointsx = tmpPointsx;
        pOEM->lPointsy = tmpPointsy;

        if(pOEM->fGeneral & FG_VERT)
        {
            if(pOEM->wScale){
                aubCmd[dwOut++] = '\034';
                dwOut += memcopy(&aubCmd[dwOut], "12S2-", 5);
                dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                         tmpPointsy / pOEM->wRes, 4);
                aubCmd[dwOut++] = '-';
                dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                         tmpPointsx / pOEM->wRes, 4);
            }
        }
        else{
            dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                     tmpPointsx / pOEM->wRes, 4);
            aubCmd[dwOut++] = '-';
            dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                     tmpPointsy / pOEM->wRes, 4);
        }
        goto SEND_COM;
    }

    pOEM->wScale = 1;

    if(tmpPointsy > 9999)
    {
        tmpPointsy = 9999;
        goto MAKE_COM;
    }

    if(tmpPointsy < 10)
    {
        tmpPointsy = 10;
        goto MAKE_COM;
    }

    pOEM->wScale = (int)(((tmpPointsx * 10) / tmpPointsy + 5) / 10);

    if(pOEM->wScale > 8) pOEM->wScale = 8;

MAKE_COM:
    dwOut += iDwtoA_FillZero(&aubCmd[dwOut], tmpPointsy / pOEM->wRes, 4);

SEND_COM:

    if(!(pOEM->fGeneral & FG_PLUS))
    {
        char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                         "4/1", "4/1", "6/1", "6/1", "8/1"};

        if(pOEM->fGeneral & FG_VERT)
        {
            if(pOEM->wScale == 1)
            {
                dwOut += memcopy(&aubCmd[dwOut], "\034m1/1,1/1.", 10);
            }
        }
        else
        {
            aubCmd[dwOut++] = '\034';
            dwOut += memcopy(&aubCmd[dwOut], "m1/1,", 5);
            dwOut += memcopy(&aubCmd[dwOut], (LPSTR)bcom[pOEM->wScale], 3);
            aubCmd[dwOut++] = '.';
        }
    }
    // write spool builded command
    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

    /*
     * I expect the interval of the current letter and the next letter
     * from the letter size.
     */
    if(pOEM->fGeneral & FG_DBCS){

        pOEM->dwDBCSX =
        pOEM->lDBCSXMove =
                 (LONG)((pSV->StdVar[1].lStdVariable * 2.04) / pOEM->wRes);

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 (LONG)(pSV->StdVar[1].lStdVariable * 1.03 / pOEM->wRes);
    }
    else{

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 pSV->StdVar[1].lStdVariable / pOEM->wRes;

    }

    pOEM->lDBCSYMove = pOEM->lSBCSYMove = 0;
    pOEM->wCurrentAddMode = FLAG_RASTER;

    VERBOSE(("OEMSendFontCmd() end.\r\n"));

	return TRUE;
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMOutputCharStr
//
//-----------------------------------------------------------------------------
// NTRAID#NTBUG9-580367-2002/03/18-v-sueyas-: Error handling
BOOL APIENTRY
bOEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    WORD        wlen;
    WORD        j;
    PIFIMETRICS pIFI;
    POEMUD_EXTRADATA    pOEM;
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
// #333653: Change I/F for GETINFO_GLYPHSTRING
    // BYTE  aubBuff[256];
    PBYTE       aubBuff;
    DWORD  dwI;
    DWORD       dwNeeded;
    // Adjust baseline if font substituted from TrueType font.
    DWORD       dwYAdj;
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVar[2+2*2];
    BYTE  Cmd[256];
    int i;

    VERBOSE(("OEMOutputCharStr() entry.\r\n"));
    VERBOSE((("FONT Num=%d\r\n"), dwCount));

	// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
    if(NULL == pdevobj || NULL == pUFObj)
    {
        ERR(("bOEMOutputCharStr: Invalid parameter(s).\n"));
        return FALSE;
    }

    if(dwType != TYPE_GLYPHHANDLE){
        VERBOSE((("NOT TYPE_GLYPHHANDLE\r\n")));
        return FALSE;
    }

    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    pIFI = pUFObj->pIFIMetrics;

	// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
    if(NULL == pOEM || NULL == pIFI)
    {
        ERR(("bOEMOutputCharStr: pdevobj->pOEMDM = 0 Or pUFObj->pIFIMetrics = 0.\n"));
        return FALSE;
    }

	// NTRAID#NTBUG9-580363-2002/03/18-v-sueyas-: Check for deviding by zero
    if (0 == pOEM->wRes)
		return FALSE;

    //
    // Call the Unidriver service routine to convert
    // glyph-handles into the character code data.
    //

// #333653: Change I/F for GETINFO_GLYPHSTRING
    GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
    GStr.dwCount   = dwCount;
    GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
    GStr.pGlyphIn  = pGlyph;
    GStr.dwTypeOut = TYPE_TRANSDATA;
    GStr.pGlyphOut = NULL;
    GStr.dwGlyphOutSize = 0;

    if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded) || !GStr.dwGlyphOutSize)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        return FALSE;
    }

    if ((aubBuff = MemAlloc(GStr.dwGlyphOutSize)) == NULL)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:MemAlloc failed.\r\n"));
        return FALSE;
    }

    GStr.pGlyphOut = aubBuff;

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded))
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        MemFree(aubBuff);
        return FALSE;
    }

    // Adjust baseline if font substituted from TrueType font.
    if (pUFObj->dwFlags & UFOFLAG_TTSUBSTITUTED) {
        pSV = (PGETINFO_STDVAR)adwStdVar;
        pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
        pSV->dwNumOfVariable = 2;
        pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
        pSV->StdVar[1].dwStdVarID = FNT_INFO_TEXTYRES;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
                pSV->dwSize, &dwNeeded)) {
            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
            MemFree(aubBuff);
            return FALSE;
        }
        dwYAdj = (pSV->StdVar[0].lStdVariable * pIFI->fwdWinDescender /
            pIFI->fwdUnitsPerEm) / pOEM->wRes;
    } else
        dwYAdj = 0;

    /* Vector mode off */
    if (pOEM->wCurrentAddMode == FLAG_VECTOR){
        i = 0;
        i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
        WRITESPOOLBUF(pdevobj, Cmd, i);
        pOEM->wCurrentAddMode = FLAG_RASTER;
    }

    /*
     * Three kind of the character cords which is given by UNIDRV
     * 1.SBCS
     * 2.DBCS Kanji
     * 3.DBCS ANK
     */
    pTrans = (PTRANSDATA)aubBuff;

// 02/04/09 NES Niigata : Check for illegal parameters
    if(NULL == pTrans)
    {
        ERR(("OEMOutputCharStr: pTrans = 0.\n"));
        return FALSE;
    }

    for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
    {
        switch (pTrans->ubType & MTYPE_FORMAT_MASK)
        {
        case MTYPE_DIRECT:
        /*
         Pattern 1: SBCS
         */
        if(pOEM->wCurrentAddMode != FLAG_SBCS ||
           pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
           pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)
        {
            i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
            // Adjust baseline if font substituted from TrueType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

            i += memcopy(&Cmd[i], "\034a", 2);
            i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
            Cmd[i++] = ',';
            i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
            Cmd[i++] = '.';

            WRITESPOOLBUF(pdevobj, Cmd, i);

            pOEM->wCurrentAddMode = FLAG_SBCS;
            pOEM->lPrevXMove = pOEM->lSBCSXMove;
            pOEM->lPrevYMove = pOEM->lSBCSYMove;
        }
        WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubCode, 1);
        break;

        case MTYPE_PAIRED:
        /*
         Pattern 2: kanji
         */
        if(*pTrans->uCode.ubPairs)
        {
            if(pOEM->wCurrentAddMode != FLAG_DBCS ||
            pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
            pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)
            {
                i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
            // Adjust baseline if font substituted from TrueType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lDBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lDBCSYMove);
                Cmd[i++] = '.';

                if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033t", 2);

                    if(pOEM->wScale != 1)
                    {
                        if(!(pOEM->fGeneral & FG_PLUS))
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1",
                                             "8/1"};
                            Cmd[i++] = '\034';
                            Cmd[i++] = 'm';
                            i += memcopy(&Cmd[i], (LPSTR)bcom[pOEM->wScale], 3);
                            i += memcopy(&Cmd[i], ",1/1.", 5);
                        }
                        else{
                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "12S2-", 5);
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsy / pOEM->wRes, 4);
                            Cmd[i++] = '-';
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsx / pOEM->wRes, 4);
                        }
                    }
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_DBCS;
                pOEM->lPrevXMove = pOEM->lDBCSXMove;
                pOEM->lPrevYMove = pOEM->lDBCSYMove;
            }
        }
        /*
         Pattern 3: ANK
         */
        else
        {
            if(pOEM->wCurrentAddMode != FLAG_SBCS ||
            pOEM->dwDeviceDestX != pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
            pOEM->dwDeviceDestY != pOEM->dwDevicePrevY + pOEM->lPrevYMove)
            {
                i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
            // Adjust baseline if font substituted from TrueType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
                Cmd[i++] = '.';

                /*
                 * ANK can't do vertical writing. We have to do
                 * vertical writing for holizontal writing compulsorily
                 */
                 if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033K", 2);

                    if(pOEM->wScale != 1)
                    {
                        if(!(pOEM->fGeneral & FG_PLUS))
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1", "8/1"};                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "m1/1,", 5);
                            i += memcopy(&Cmd[i], (LPSTR)bcom[pOEM->wScale], 3);
                            Cmd[i++] = '.';
                        }
                        else{
                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "12S2-", 5);
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsx / pOEM->wRes, 4);
                            Cmd[i++] = '-';
                            i += iDwtoA_FillZero(&Cmd[i],
                                              pOEM->lPointsy / pOEM->wRes, 4);
                        }
                    }
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_SBCS;
                pOEM->lPrevXMove = pOEM->lSBCSXMove;
                pOEM->lPrevYMove = pOEM->lSBCSYMove;
                }
        }
        WRITESPOOLBUF(pdevobj, pTrans->uCode.ubPairs, 2);
        break;

        }
        pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
        pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;
        pOEM->dwDeviceDestX += pOEM->lPrevXMove;
        pOEM->dwDeviceDestY += pOEM->lPrevYMove;
    }
// #333653: Change I/F for GETINFO_GLYPHSTRING
    MemFree(aubBuff);
    VERBOSE(("OEMOutputCharStr() end.\r\n"));

	return TRUE;
}


// NTRAID#NTBUG9-741174-2002/11/20-yasuho-: Memory leak happened.
PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    if (NULL == pdevobj)
    {
        ERR(("OEMEnablePDEV: Invalid parameter(s).\n"));
        return NULL;
    }

    return pdevobj->pOEMDM;
}

VOID
APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj
    )

/*++

Routine Description:

    Implementation of DDI entry point OEMDisablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

Return Value:

    NONE

--*/

{
    POEMUD_EXTRADATA    pOEM;

    VERBOSE(("Entering OEMDisablePDEV...\n"));

	// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("Invalid parameter(s).\n"));
        return;
    }

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

	// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Check for illegal parameters
    if (NULL == pOEM)
    {
        ERR(("pdevobj->pOEMDM = NULL.\n"));
        return;
    }

    //
    // Free up memory allocated for the temp. buffer
    //

    if (pOEM->pCompBuf) {
        FREEMEM(pOEM->pCompBuf);
        pOEM->pCompBuf = NULL;
        pOEM->dwCompBufLen = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncdljres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
// NTRAID#NTBUG9-580353-2002/03/18-v-sueyas-: Use strsafe.h
#include <strsafe.h>

//
// Misc definitions follows.
//

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'NCDL'      // NEC NPDL2 series dll
#define DLLTEXT(s)      "NCDL: " s
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
    WORD   wRes;            // resolution / MasterUnit
    WORD   wScale;          // The magnification of the font
    LONG   lPointsx;        // font width
    LONG   lPointsy;        // font height
    DWORD  dwSBCSX;         // temp
    DWORD  dwDBCSX;         // temp
    LONG  lSBCSXMove;       // SBCS The expectation X movement quantity
    LONG  lSBCSYMove;       // SBCS The expectation Y movement quantity
    LONG  lDBCSXMove;       // DBCS The expectation X movement quantity
    LONG  lDBCSYMove;       // DBCS The expectation Y movement quantity
    LONG  lPrevXMove;       // The previous X movement quantity
    LONG  lPrevYMove;       // The previous Y movement quantity
    DWORD   fGeneral;       // general flag
    WORD   wCurrentAddMode; // draw mode
    PBYTE pCompBuf;         // buffer for compression
    DWORD dwCompBufLen;     // line buffer
    DWORD dwScanLen;        // bitmap width
    DWORD dwDeviceDestX;    // current X coordinate
    DWORD dwDeviceDestY;    // current Y coordinate
    DWORD dwDevicePrevX;    // previous X coordinate
    DWORD dwDevicePrevY;    // previous Y coordinate
// #278517: RectFill
    DWORD dwRectWidth;      // width for RectFill
    DWORD dwRectHeight;     // height for RectFill
    UINT  iGray;            // rect fill gray scale
    UINT  cSubPath;         // sub path counter max is 500
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

#define MAX_SUBPATH 500

// Flags for fGeneral
#define FG_DBCS     0x00000002
#define FG_VERT     0x00000004
#define FG_PLUS     0x00000010

#ifdef BYPASS
#define FG_NO_COMP  0x00000020
#endif // BYPASS

// #278517: RectFill
#define FG_GMINIT   0x00000040

// Flags for Draw Mode
#define FLAG_RASTER 0   //
#define FLAG_SBCS   1   // FSa SBCS - FSR
#define FLAG_DBCS   2   // FSa DBCS - FSR
#define FLAG_VECTOR 3   // FSY - FSZ

#define MASTER_UNIT 1200

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);


// NTRAID#NTBUG9-580367-2002/03/18-v-sueyas-: Error handling
// New interface functions with Unidrv callbacks.
#ifdef __cplusplus
extern "C" {
#endif
BOOL APIENTRY bOEMSendFontCmd(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, PFINVOCATION pFInv);
BOOL APIENTRY bOEMOutputCharStr(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph);
#ifdef __cplusplus
}
#endif





#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncdljres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
    "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncdljres\hlp\helpid.h ===
// HELP  Index

#define POP_DL_MARGIN                602
#define POP_DL_JOBSEPARATE           603
#define POP_DL_SET                   604
#define POP_DL_TONAR                 605
#define POP_DL_DENSITY               606
#define POP_DL_SORTER                607
#define POP_DL_OUTBIN                608
#define POP_DL_FACE                  609
#define POP_DL_KANJICODE             610

/* TextHalftoneThreshold */
#define POP_DL_TEXTHALFTONE          611
#define POP_DL_TEXTHALFTONE_S        612
#define POP_DL_TEXTHALFTONE_S2       613
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncdljres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\nec\$(ALT_PROJECT)
SRCDIR=..
HLPDIR=$(SRCDIR)\hlp

TARGETNAME=ncdljres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
COFFBASE=ncdljres
!ELSE
COFFBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\ncdljres.rc \
    $(SRCDIR)\ncdljres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\ncdljres.ini \
    $(GPDDIR)\ncdl104j.gpd \
    $(GPDDIR)\ncdl125j.gpd \
    $(GPDDIR)\ncdl14rj.gpd \
    $(GPDDIR)\ncdl14wj.gpd \
    $(GPDDIR)\ncdl14xj.gpd \
    $(GPDDIR)\ncdl1e4j.gpd \
    $(GPDDIR)\ncdl1ewj.gpd \
    $(GPDDIR)\ncdl1f4j.gpd \
    $(GPDDIR)\ncdl202j.gpd \
    $(GPDDIR)\ncdl204j.gpd \
    $(GPDDIR)\ncdl210j.gpd \
    $(GPDDIR)\ncdl21sj.gpd \
    $(GPDDIR)\ncdl222j.gpd \
    $(GPDDIR)\ncdl225j.gpd \
    $(GPDDIR)\ncdl22xj.gpd \
    $(GPDDIR)\ncdl230j.gpd \
    $(GPDDIR)\ncdl24j.gpd \
    $(GPDDIR)\ncdl24rj.gpd \
    $(GPDDIR)\ncdl24wj.gpd \
    $(GPDDIR)\ncdl24xj.gpd \
    $(GPDDIR)\ncdl25j.gpd \
    $(GPDDIR)\ncdl25hj.gpd \
    $(GPDDIR)\ncdl265j.gpd \
    $(GPDDIR)\ncdl26ej.gpd \
    $(GPDDIR)\ncdl26mj.gpd \
    $(GPDDIR)\ncdl26wj.gpd \
    $(GPDDIR)\ncdl2ej.gpd \
    $(GPDDIR)\ncdl2fj.gpd \
    $(GPDDIR)\ncdl2n2j.gpd \
    $(GPDDIR)\ncdl2nj.gpd \
    $(GPDDIR)\ncdl2x2j.gpd \
    $(GPDDIR)\ncdl2xej.gpd \
    $(GPDDIR)\ncdl2xj.gpd \
    $(GPDDIR)\ncdl404j.gpd \
    $(GPDDIR)\ncdl4e4j.gpd \
    $(HLPDIR)\ncdljres.hlp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\debug.c ===
#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING,("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}



//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//NOTICE-2002/03/28-hiroi-:
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//NOTICE-2002/03/28-hiroi-:
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        DBGPRINT(DBG_WARNING,("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING,("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING,("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING,("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING,("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING,("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING,("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING,("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/
// NTRAID#NTBUG9-588593-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
// NTRAID#NTBUG9-741174-2002/11/20-yasuho-: Memory leak happened.
        if (NULL == pDevOem)
            return E_FAIL;

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,
            phsurfPatterns, cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
// NTRAID#NTBUG9-741174-2002/11/20-yasuho-: Memory leak happened.
        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
			(NULL == p1 ? "" : *((char **)p1)),
			(NULL == p2 ? "" : *((char **)p2)));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

        if (!OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
            return E_FAIL;
        }
        else {
            return S_OK;
        }
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// Misc definitions follows.
//

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
//#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'NCDL'      // NEC NPDL2 series dll
#define DLLTEXT(s)      "NCDL: " s
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
    WORD   wRes;            // resolution / MasterUnit
    WORD   wScale;          // The magnification of the font
    LONG   lPointsx;        // font width
    LONG   lPointsy;        // font height
    DWORD  dwSBCSX;         // temp
    DWORD  dwDBCSX;         // temp
    LONG  lSBCSXMove;       // SBCS The expectation X movement quantity
    LONG  lSBCSYMove;       // SBCS The expectation Y movement quantity
    LONG  lDBCSXMove;       // DBCS The expectation X movement quantity
    LONG  lDBCSYMove;       // DBCS The expectation Y movement quantity
    LONG  lPrevXMove;       // The previous X movement quantity
    LONG  lPrevYMove;       // The previous Y movement quantity
    DWORD   fGeneral;       // general flag
    WORD   wCurrentAddMode; // draw mode
    PBYTE pCompBuf;         // buffer for compression
    DWORD dwCompBufLen;     // line buffer
    DWORD dwScanLen;        // bitmap width
    DWORD dwDeviceDestX;    // current X coordinate
    DWORD dwDeviceDestY;    // current Y coordinate
    DWORD dwDevicePrevX;    // previous X coordinate
    DWORD dwDevicePrevY;    // previous Y coordinate
// #278517: RectFill
    DWORD dwRectWidth;      // width for RectFill
    DWORD dwRectHeight;     // height for RectFill
    UINT  iGray;            // rect fill gray scale
    UINT  cSubPath;         // sub path counter max is 500
// 2001.3.16 add
	WORD Duplex_mode;
	WORD Duplex_OU;
	WORD Margin;
	WORD ESort_mode;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

#define MAX_SUBPATH 500

// Flags for fGeneral
#define FG_DBCS     0x00000002
#define FG_VERT     0x00000004
#define FG_PLUS     0x00000010

#ifdef BYPASS
#define FG_NO_COMP  0x00000020
#endif // BYPASS

// #278517: RectFill
#define FG_GMINIT   0x00000040

// Flags for Draw Mode
#define FLAG_RASTER 0   //
#define FLAG_SBCS   1   // FSa SBCS - FSR
#define FLAG_DBCS   2   // FSa DBCS - FSR
#define FLAG_VECTOR 3   // FSY - FSZ

#define MASTER_UNIT 1200

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
    "CommandCallback",
    "DevMode",
    "DisablePDEV",
    "EnablePDEV",
    "FilterGraphics",
    "GetImplementedMethod",
    "GetInfo",
    "OutputCharStr",
    "PublishDriverInterface",
    "SendFontCmd",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\hlp\helpid.h ===
// HELP  Index

#define POP_DL_MARGIN                602	//
#define POP_DL_JOBSEPARATE           603	//WuZp[g
#define POP_DL_SET                   604	//Zbg@\
#define POP_DL_TONAR                 605	//gi[Z[u
#define POP_DL_DENSITY               606	//Zx
#define POP_DL_SORTER                607	//\[^[
#define POP_DL_OUTBIN                608	//r
#define POP_DL_FACE                  609	//tF[XAbvgC
#define POP_DL_KANJICODE             610	//ihr

#define POP_DL_PAPERTYPE1			 611	//
#define POP_DL_ENVFEEDER			 612	//
#define POP_DL_SIWAKE1				 613	//
#define POP_DL_SIWAKE2				 614	//
#define POP_DL_PRINTAREA			 615	//
#define POP_DL_ERCSORT				 616	//
#define POP_DL_FINISHER1			 617	//
#define POP_DL_F_HOUKOU				 619	//
#define POP_DL_F_ITI				 620	//
#define POP_DL_DUPLX				 621	//
#define POP_DL_PAPERTYPE2			 622	//
#define POP_DL_FACE2                 623	//tF[XAbvgC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\ncmwjres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "ncdlxxxx.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"
#include <strsafe.h>

//
// Misc definitions and declarations.
//

#define ALLOCMEM EngAllocMem
#define FREEMEM EngFreeMem

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

//
// For debugging.
//

//#define DBG_OUTPUTCHARSTR 1

//
// command callback ID's
//

#define CMD_MOVE_X                  23
#define CMD_MOVE_Y                  24
#define CMD_BEGIN_RASTER            26
#define CMD_RES_600                 27
#define CMD_RES_400                 28
#define CMD_RES_240                 29
#define CMD_SEND_BLOCK_DATA         30
#define CMD_BEGIN_RASTER_NO_COMP    31
#define CMD_INIT_COORDINATE         32
#define CMD_PC_PRN_DIRECTION        50
#define CMD_CR                      51
#define CMD_FF                      52
#define CMD_RES_300		    65
#define CMD_RES_200		    66
// #278517: RectFill
#define CMD_RECTWIDTH               60
#define CMD_RECTHEIGHT              61
#define CMD_RECTWHITE               62
#define CMD_RECTBLACK               63
#define CMD_RECTGRAY                64

#define CMD_DUPLEX_NONE				67
#define CMD_DUPLEX_VERTICAL			68
#define CMD_DUPLEX_HORIZONTAL		69
#define CMD_MAIN_BACK1				70
#define CMD_MAIN_BACK2				71
#define CMD_MAIN_BACK3				72
#define CMD_MAIN_BACK4				73
#define CMD_0						74
#define CMD_1						75
#define CMD_2						76
#define CMD_3						77
#define CMD_4						78
#define CMD_5						79
#define CMD_6						80
#define CMD_7						81
#define CMD_8						82
#define CMD_9						83
#define CMD_10						84
#define CMD_11						85
#define CMD_12						86
#define CMD_13						87
#define CMD_14						88
#define CMD_15						89
#define CMD_16						90
#define CMD_17						91
#define CMD_18						92
#define CMD_19						93
#define CMD_20						94
#define CMD_MAIN_BACK0				95
#define CMD_MAIN_BACK11				96
#define CMD_MAIN_BACK12				97
#define CMD_MAIN_BACK13				98
#define CMD_MAIN_BACK14				99
#define CMD_DUPLEX_A1_600			100
#define CMD_DUPLEX_A1_400			101
#define CMD_DUPLEX_A1_300			102
#define CMD_DUPLEX_A1_240			103
#define CMD_DUPLEX_A1_200			104
#define CMD_DUPLEX_A2_600			105
#define CMD_DUPLEX_A2_400			106
#define CMD_DUPLEX_A2_300			107
#define CMD_DUPLEX_A2_240			108
#define CMD_DUPLEX_A2_200			109
#define CMD_DUPLEX_A3_600			110
#define CMD_DUPLEX_A3_400			111
#define CMD_DUPLEX_A3_300			112
#define CMD_DUPLEX_A3_240			113
#define CMD_DUPLEX_A3_200			114
#define CMD_SORT_NONE				115
#define CMD_SORT_COPY				116
#define CMD_SORT_SORT				117
#define CMD_SORT_BIN				118
#define CMD_SORT_STACK				119
#define CMD_JIS_90					120
#define CMD_JIS_78					121
// Text color add. 2000.12.28
#define	CMD_WHITE_ON				130
#define CMD_WHITE_OFF				131
// Under Line add 2001.2.2
#define CMD_BOLD_ON					132
#define CMD_ITALIC_ON				133
#define CMD_CLEAR_ATTRIB_P			134
#define	CMD_ESORT_OFF				135
#define	CMD_ESORT_ON				136

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//NOTICE-2002/03/28-hiroi-:
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->wRes = 1;
    pOEMExtra->pCompBuf = NULL;
    pOEMExtra->dwCompBufLen = 0;
    pOEMExtra->dwScanLen = 0;
    pOEMExtra->dwDeviceDestX = 0;
    pOEMExtra->dwDeviceDestY = 0;
    pOEMExtra->dwDevicePrevX = 0;
    pOEMExtra->dwDevicePrevY = 0;
    pOEMExtra->iGray = 0;
    pOEMExtra->cSubPath = 0;
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//NOTICE-2002/03/28-hiroi-:
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->wRes    = pdmIn->wRes;
        pdmOut->wScale = pdmIn->wScale;
        pdmOut->lPointsx = pdmIn->lPointsx;
        pdmOut->lPointsy = pdmIn->lPointsy;
        pdmOut->dwSBCSX = pdmIn->dwSBCSX;
        pdmOut->dwDBCSX = pdmIn->dwDBCSX;
        pdmOut->lSBCSXMove = pdmIn->lSBCSXMove;
        pdmOut->lSBCSYMove = pdmIn->lSBCSYMove;
        pdmOut->lDBCSXMove = pdmIn->lDBCSXMove;
        pdmOut->lDBCSYMove = pdmIn->lDBCSYMove;
        pdmOut->lPrevXMove = pdmIn->lPrevXMove;
        pdmOut->lPrevYMove = pdmIn->lPrevYMove;
        pdmOut->fGeneral = pdmIn->fGeneral;
        pdmOut->wCurrentAddMode = pdmIn->wCurrentAddMode;
        pdmOut->dwDeviceDestX = pdmIn->dwDeviceDestX;
        pdmOut->dwDeviceDestY = pdmIn->dwDeviceDestY;
        pdmOut->dwDevicePrevX = pdmIn->dwDevicePrevX;
        pdmOut->dwDevicePrevY = pdmIn->dwDevicePrevY;
    }

    return TRUE;
}


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA
//
//  Description:  Convert from numeral into a character
//-----------------------------------------------------------------------------
static int
iDwtoA(LPSTR buf, DWORD n)
{
    int  i, j;

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}


//-----------------------------------------------------------------------------
//
//  Function:   iDwtoA_FillZero
//
//  Description:  Convert from numeral into a character and
//                fill a field which was specified with 0
//-----------------------------------------------------------------------------
static int
iDwtoA_FillZero(LPSTR buf, DWORD n, int fw)
{
    int  i , j, k, l;

    l = n;  // for later

    for( i = 0; n; i++ ) {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ ) {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    for( k = 0; l; k++ ) {
        l /= 10;
    }
    if( k < 1) k++;

    k = fw - k;
    if(k > 0){;
        for (j = i; 0 < j + 1; j--){
            buf[j + k] = buf[j];
        }
        for ( j = 0; j < k; j++){
            buf[j] = '0';
        }
        i = i + k;
    }

    return i;
}

//-----------------------------------------------------------------------------
//
//  Function:   memcopy
//
//  Description:  Copy the memory from Src to Dest
//-----------------------------------------------------------------------------
static int
memcopy(LPSTR lpDst, LPSTR lpSrc, WORD wLen)
{
    WORD rLen;

    rLen = wLen;

    while(wLen--) *lpDst++ = *lpSrc++;
    return rLen;
}
//-----------------------------------------------------------------------------
//
//  Function:   copynumber
//
//  Description:  Copy the memory from Src to Dest
//-----------------------------------------------------------------------------
void
copynumber(LPSTR lpDst, LONG wLen)
{

	LONG rLen;
	BYTE i,j;

	j = 0;
	rLen = wLen;

	if( rLen > 9 ){
		for(i=0;i<rLen;i+=10)
		{
			j++;
		}
		*lpDst = (j-1) + 0x30;
		i -= 10;
		rLen -=i;
		lpDst++;
	}
	j = (BYTE)rLen;
	*lpDst = 0x30 + j;
	return;

}
//------------------------------------------------------------------
// RLE1
// Action : compress image data with RLE1
//------------------------------------------------------------------
DWORD RLE1(
PBYTE pDst,
PBYTE pSrc,
DWORD   dwLen)
{
    PBYTE pTemp, pEnd, pDsto;
    DWORD   len, deflen;

    pDsto = pDst;
    pEnd = pSrc + dwLen;

    while(pSrc < pEnd)
    {
        pTemp = pSrc++;

        if(pSrc == pEnd)
        {
            *pDst++ = 0x41;
            *pDst++ = *pTemp;
            break;
        }

        if(*pTemp == *pSrc)
        {
            pSrc++;

            while(pSrc < pEnd && *pTemp == *pSrc) pSrc++;

            len = (DWORD)(pSrc - pTemp);

            if(len < 63)
            {
                *pDst++ = 0x80 + (BYTE)len;
                goto T1;
            }

            *pDst++ = 0xbf;
            len -= 63;

            while(len >= 255)
            {
                *pDst++ = 0xff;
                len -= 255;
            }

            *pDst++ = (BYTE)len;
T1:
            *pDst++ = *pTemp;
            continue;
        }

        pSrc++;

        while(pSrc < pEnd)
        {
            if(*pSrc == *(pSrc - 1))
            {
                pSrc--;
                break;
            }

            pSrc++;
        }

        deflen = len = (DWORD)(pSrc - pTemp);

        if(len < 63)
        {
            *pDst++ = 0x40 + (BYTE)len;
            goto T2;
        }

        *pDst++ = 0x7f;
        len -= 63;

        while(len >= 255)
        {
            *pDst++ = 0xff;
            len -= 255;
        }

        *pDst++ = (BYTE)len;
T2:
        memcpy(pDst, pTemp, deflen);
        pDst += deflen;
    }

    return (DWORD)(pDst - pDsto);
}


//------------------------------------------------------------------
// RLC2Comp
// Action : compress image data with RLE2
//------------------------------------------------------------------
DWORD
RLC2Comp(
    PBYTE pOutBuf,
    PBYTE pInBuf,
    DWORD dwInLen,
    DWORD dwScanLen
    )
{
    DWORD     dwlen, dwDatalen, dwCounter;
    PBYTE     pLBuff;
    PBYTE     pBuff, pTemp, pBuffo, pEnd;
    PBYTE     pBuff2, pBuff2o;

VERBOSE(("RLC2Comp() In +++\r\n"));

    dwCounter = dwInLen / dwScanLen;
    pLBuff = pBuffo = pBuff = pTemp = pInBuf;    // Copy Src first pointer
    pBuff2o = pBuff2 = pOutBuf;                  // Copy Dst first pointer

    /*
     * We compare contents of First line with 0x00
     */
    pEnd = pBuff + dwScanLen;

    while(pBuff < pEnd)
    {
        while(pBuff < pEnd && 0x00 != *pBuff)
        {
            pBuff++;
        }

        dwlen = (DWORD)(pBuff - pTemp);

        if(dwlen)
        {
            pBuff2 += RLE1(pBuff2, pTemp, dwlen);
            pTemp = pBuff;
        }

        if(pBuff == pEnd) break;

        while(pBuff < pEnd && 0x00 == *pBuff)
        {
            pBuff++;
        }

        dwlen = (DWORD)(pBuff - pTemp);

        if(dwlen < 63)
        {
            *pBuff2++ = (BYTE)dwlen;
            goto T1;
        }

        *pBuff2++ = 0x3f;
        dwlen -= 63;

        while(dwlen >= 255)
        {
            *pBuff2++ = (BYTE)0xff;
            dwlen -= 255;
        }

        *pBuff2++ = (BYTE)dwlen;
T1:
        pTemp = pBuff;
    }

    dwCounter--;

    *pBuff2++ = (BYTE)0x80;
    dwDatalen = (DWORD)(pBuff2 - pBuff2o);

    // If the compressed bitmap size is larger than nomal bitmap size,
    // we don't compress
    if(dwDatalen > dwInLen)
    {
VERBOSE(("goto NO_COMP\r\n"));
        goto NO_COMP;
    }

    if(!dwCounter)
        return dwDatalen;

    /*
     * We compare the 1 previous line with the present line
     */
    do
    {
        pEnd = pBuff + dwScanLen;

        while(pBuff < pEnd)
        {
            while(pBuff < pEnd && *pLBuff != *pBuff)
            {
                pLBuff++;
                pBuff++;
            }

            dwlen = (DWORD)(pBuff - pTemp);

            if(dwlen)
            {
                pBuff2 += RLE1(pBuff2, pTemp, dwlen);
                pTemp = pBuff;
            }

            if(pBuff == pEnd) break;

            while(pBuff < pEnd && *pLBuff == *pBuff)
            {
                pLBuff++;
                pBuff++;
            }

            dwlen = (DWORD)(pBuff - pTemp);

            if(dwlen < 63)
            {
                *pBuff2++ = (BYTE)dwlen;
                goto T2;
            }

            *pBuff2++ = 0x3f;
            dwlen -= 63;

            while(dwlen >= 255)
            {
                *pBuff2++ = (BYTE)0xff;
                dwlen -= 255;
            }

            *pBuff2++ = (BYTE)dwlen;
T2:
            pTemp = pBuff;
        }

        *pBuff2++ = (BYTE)0x80;
        dwDatalen = (DWORD)(pBuff2 - pBuff2o);

        // If the compressed bitmap size is larger than nomal bitmap size,
        // we don't compress
        if(dwDatalen > dwInLen)  // full buffer
        {
VERBOSE(("goto NO_COMP\r\n"));
            goto NO_COMP;
        }
    }
    while(--dwCounter);

VERBOSE(("RLC2Comp() COMP Out---\r\n\r\n"));
    return dwDatalen;

NO_COMP:

VERBOSE(("RLC2Comp() NO_COMP Out---\r\n\r\n"));
    return 0;
}

//-------------------------------------------------------------------
// OEMFilterGraphics
// Action : Compress Bitmap Data
//-------------------------------------------------------------------
BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE   pBuf,
    DWORD   dwLen
    )
{
    POEMUD_EXTRADATA    pOEM;
    INT         i;
    BYTE            Cmd[128];
    PBYTE pOutBuf;
    DWORD dwOutLen;
    BYTE jCompMethod;

VERBOSE(("OEMFilterGraphics() In +++++++++++++++++++++++++++++\r\n"));

    //
    // verify pdevobj okay
    //
	if(!VALID_PDEVOBJ(pdevobj)) return FALSE;

    //
    // fill in printer commands
    //
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

    // Sanity check.

    if (!pBuf || pOEM->dwScanLen == 0 || pOEM->wRes == 0) {
        ERR(("Invalid parameter.\r\n"));
        return FALSE;
    }

    // Prepare temp. buffer for compression.

#ifdef BYPASS
    if ((!pOEM->pCompBuf || pOEM->dwCompBufLen < dwLen) &&
        !(pOEM->fGeneral & FG_NO_COMP)){
#else
    if (!pOEM->pCompBuf || pOEM->dwCompBufLen < dwLen) {
#endif // BYPASS

        if (pOEM->pCompBuf) {
            FREEMEM(pOEM->pCompBuf);
        }

        pOEM->pCompBuf = ALLOCMEM(0,
                          (dwLen << 1) + (dwLen / pOEM->dwScanLen),
                          (ULONG)'NCDL');
        pOEM->dwCompBufLen = dwLen;
    }

    // Try compression methods.

    dwOutLen = 0;
    if (pOEM->pCompBuf != NULL) {

        pOutBuf = pOEM->pCompBuf;

        // Try RLC2 method;
        if (dwOutLen == 0) {
            if ((dwOutLen = RLC2Comp(pOutBuf, pBuf,
                                      dwLen, pOEM->dwScanLen)) > 0)
                jCompMethod = '5';
        }
    }

    if (dwOutLen == 0) {

        // Any of the Compression menthod faild.
        // We will send data to the printer withtout
        // compression.

        pOutBuf = pBuf;
        dwOutLen = dwLen;
        jCompMethod = '0';  // Without compression.
    }

    /* Send a draw coordinate command to the printer. */
    i = 0;
    i += memcopy(&Cmd[i], "\034e", 2);
    i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
    Cmd[i++] = '.';

    /* Save the present coordinate. */
    pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
    pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;

    /* Send an image data draw command. */
    i += memcopy(&Cmd[i], "\034i", 2);
    i += iDwtoA(&Cmd[i], (pOEM->dwScanLen << 3));
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], (dwLen / pOEM->dwScanLen));
    Cmd[i++] = ',';
    Cmd[i++] = jCompMethod;
    i += memcopy(&Cmd[i], ",1/1,1/1,", 9);
    i += iDwtoA(&Cmd[i], dwOutLen);
    Cmd[i++] = ',';
    i += iDwtoA(&Cmd[i], (MASTER_UNIT / pOEM->wRes));
    Cmd[i++] = '.';
    WRITESPOOLBUF(pdevobj, Cmd, i);

    /* Send an image data */
    WRITESPOOLBUF(pdevobj, pOutBuf, dwOutLen);
VERBOSE(("OEMFilterGraphics() Out-------------------------------\r\n\r\n"));

    return TRUE;

}


//-----------------------------------------------------------------------------
//
//  Function:   OEMCommandCallback
//
//-----------------------------------------------------------------------------
INT
APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT         i;
    BYTE            *bp;
    BYTE            Cmd[128];
    POEMUD_EXTRADATA    pOEM;
    INT iRet;
    DWORD dwDeviceDestX, dwDeviceDestY;
    UINT gray;
	LONG	copynum;
	BYTE	CopyCmd[2];

    //
    // verify pdevobj okay
    //
	if(!VALID_PDEVOBJ(pdevobj)) return 0;

    //
    // fill in printer commands
    //
    i = 0;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    iRet = 0;

    /*
     * There are four kinds of draw modes of this driver.When entering a
     * new draw mode, it send the commands which ends the previous draw mode
     * at the same time.
     * 1.FLAG_RASTER - raster image mode.The condition not to enter
     *                 a vector mode and a text mode.
     *                 Default condition is RASTER in this driver
     * 2.FLAG_SBCS   - single byte text mode. IN: FSa, OUT:FSR
     * 3.FLAG_DBCS   - double byte text mode. IN: FSa, OUT:FSR
     * 4.FLAG_VECTOR - vector mode.  IN: FSY, OUT:FSZ
     */
     switch (dwCmdCbID) {

	case CMD_ESORT_OFF:
		i = 0;
        i += memcopy(&Cmd[i],"@PJL SET COLLATE=OFF\x0D\x0A",22);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->ESort_mode = 0;
		break;

	case CMD_ESORT_ON:
		i = 0;
        i += memcopy(&Cmd[i],"@PJL SET COLLATE=ON\x0D\x0A",21);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->ESort_mode = 1;
		break;

	case CMD_DUPLEX_NONE:
		i = 0;
        i += memcopy(&Cmd[i], "\x1C'S,,",5);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_mode = 0;
		break;

	case CMD_DUPLEX_VERTICAL:
		i = 0;
        i += memcopy(&Cmd[i], "\x1C'B",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_mode = 1;
		break;

	case CMD_DUPLEX_HORIZONTAL:
		i = 0;
        i += memcopy(&Cmd[i], "\x1C'B",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_mode = 2;
		break;

	case CMD_MAIN_BACK0:
		i = 0;
		pOEM->Duplex_OU = 0;
		break;

	case CMD_MAIN_BACK1:
		i = 0;
        i += memcopy(&Cmd[i], ",F,1",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 1;
		break;

	case CMD_MAIN_BACK2:
		i = 0;
        i += memcopy(&Cmd[i], ",F,2",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 2;
		break;

	case CMD_MAIN_BACK3:
		i = 0;
        i += memcopy(&Cmd[i], ",F,3",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 3;
		break;

	case CMD_MAIN_BACK4:
		i = 0;
        i += memcopy(&Cmd[i], ",F,4",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 4;
		break;

	case CMD_MAIN_BACK11:
		i = 0;
        i += memcopy(&Cmd[i], ",B,1",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 5;
		break;

	case CMD_MAIN_BACK12:
		i = 0;
        i += memcopy(&Cmd[i], ",B,2",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 6;
		break;

	case CMD_MAIN_BACK13:
		i = 0;
        i += memcopy(&Cmd[i], ",B,3",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 7;
		break;

	case CMD_MAIN_BACK14:
		i = 0;
        i += memcopy(&Cmd[i], ",B,4",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Duplex_OU = 8;
		break;

	case CMD_0:
		i = 0;
        i += memcopy(&Cmd[i], ",0.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 0;
		break;

	case CMD_1:
		i = 0;
        i += memcopy(&Cmd[i], ",1.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 1;
		break;

	case CMD_2:
		i = 0;
        i += memcopy(&Cmd[i], ",2.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 2;
		break;

	case CMD_3:
		i = 0;
        i += memcopy(&Cmd[i], ",3.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 3;
		break;

	case CMD_4:
		i = 0;
        i += memcopy(&Cmd[i], ",4.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 4;
		break;

	case CMD_5:
		i = 0;
        i += memcopy(&Cmd[i], ",5.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 4;
		break;

	case CMD_6:
		i = 0;
        i += memcopy(&Cmd[i], ",6.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 6;
		break;

	case CMD_7:
		i = 0;
        i += memcopy(&Cmd[i], ",7.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 7;
		break;

	case CMD_8:
		i = 0;
        i += memcopy(&Cmd[i], ",8.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 8;
		break;

	case CMD_9:
		i = 0;
        i += memcopy(&Cmd[i], ",9.",3);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 9;
		break;

	case CMD_10:
		i = 0;
        i += memcopy(&Cmd[i], ",10.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 10;
		break;

	case CMD_11:
		i = 0;
        i += memcopy(&Cmd[i], ",11.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 11;
		break;

	case CMD_12:
		i = 0;
        i += memcopy(&Cmd[i], ",12.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 12;
		break;

	case CMD_13:
		i = 0;
        i += memcopy(&Cmd[i], ",13.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 13;
		break;

	case CMD_14:
		i = 0;
        i += memcopy(&Cmd[i], ",14.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 14;
		break;

	case CMD_15:
		i = 0;
        i += memcopy(&Cmd[i], ",15.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 15;
		break;

	case CMD_16:
		i = 0;
        i += memcopy(&Cmd[i], ",16.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 16;
		break;

	case CMD_17:
		i = 0;
        i += memcopy(&Cmd[i], ",17.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 17;
		break;

	case CMD_18:
		i = 0;
        i += memcopy(&Cmd[i], ",18.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 18;
		break;

	case CMD_19:
		i = 0;
        i += memcopy(&Cmd[i], ",19.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 19;
		break;

	case CMD_20:
		i = 0;
        i += memcopy(&Cmd[i], ",20.",4);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		pOEM->Margin = 20;
		break;
	case CMD_SORT_NONE:
	case CMD_SORT_COPY:
	case CMD_SORT_SORT:
	case CMD_SORT_BIN:
	case CMD_SORT_STACK:
		i = 0;
		goto dup;

	case CMD_DUPLEX_A1_600:
	case CMD_DUPLEX_A2_600:
		i = 0;
		i += memcopy(&Cmd[i], "\x1B\x63\x31\x1C&600.\x1C\x64\x32\x34\x30.",15);
		if(!pdwParams) return 0;
		copynum = PARAM(pdwParams, 0);
		if( pOEM->ESort_mode == 1){
			copynumber(&CopyCmd[0],copynum);
		}
		else{
			copynum = 1;
			CopyCmd[0] = 0x31;
		}
		i += memcopy(&Cmd[i],"\x1C\x78",2);
		if(copynum < 10 ){
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
		}else{
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
			i += memcopy(&Cmd[i],&CopyCmd[1],1);
		}
		i += memcopy(&Cmd[i], ".\x1C&600.",7);
		goto dup;
	case CMD_DUPLEX_A1_400:
	case CMD_DUPLEX_A2_400:
		i = 0;
		i += memcopy(&Cmd[i], "\x1B\x63\x31\x1C&400.\x1C\x64\x32\x34\x30.",15);
		if(!pdwParams) return 0;
		copynum = PARAM(pdwParams, 0);
		if( pOEM->ESort_mode == 1 ){
			copynumber(&CopyCmd[0],copynum);
		}
		else{
			copynum = 1;
			CopyCmd[0] = 0x31;
		}
		i += memcopy(&Cmd[i],"\x1C\x78",2);
		if(copynum < 10 ){
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
		}else{
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
			i += memcopy(&Cmd[i],&CopyCmd[1],1);
		}
		i += memcopy(&Cmd[i], ".\x1C&400.",7);
		goto dup;

	case CMD_DUPLEX_A1_300:
	case CMD_DUPLEX_A2_300:
		i = 0;
		i += memcopy(&Cmd[i], "\x1B\x63\x31\x1C&300.\x1C\x64\x32\x34\x30.",15);
		if(!pdwParams) return 0;
		copynum = PARAM(pdwParams, 0);
		if( pOEM->ESort_mode == 1){
			copynumber(&CopyCmd[0],copynum);
		}
		else{
			copynum = 1;
			CopyCmd[0] = 0x31;
		}
		i += memcopy(&Cmd[i],"\x1C\x78",2);
		if(copynum < 10 ){
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
		}else{
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
			i += memcopy(&Cmd[i],&CopyCmd[1],1);
		}
		i += memcopy(&Cmd[i], ".\x1C&300.",7);
		goto dup;

	case CMD_DUPLEX_A1_240:
	case CMD_DUPLEX_A2_240:
		i = 0;
		i += memcopy(&Cmd[i], "\x1B\x63\x31\x1C&240.\x1C\x64\x32\x34\x30.",15);
		if(!pdwParams) return 0;
		copynum = PARAM(pdwParams, 0);
		if( pOEM->ESort_mode == 1){
			copynumber(&CopyCmd[0],copynum);
		}
		else{
			CopyCmd[0] = 0x31;
			copynum = 1;
		}
		i += memcopy(&Cmd[i],"\x1C\x78",2);
		if(copynum < 10 ){
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
		}else{
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
			i += memcopy(&Cmd[i],&CopyCmd[1],1);
		}
		i += memcopy(&Cmd[i], ".\x1C&240.",7);
		goto dup;

	case CMD_DUPLEX_A1_200:
	case CMD_DUPLEX_A2_200:
		i = 0;
		i += memcopy(&Cmd[i], "\x1B\x63\x31\x1C&200.\x1C\x64\x32\x34\x30.",15);
		if(!pdwParams) return 0;
		copynum = PARAM(pdwParams, 0);
		if( pOEM->ESort_mode == 1){
			copynumber(&CopyCmd[0],copynum);
		}
		else{
			copynum = 1;
			CopyCmd[0] = 0x31;
		}
		i += memcopy(&Cmd[i],"\x1C\x78",2);
		if(copynum < 10 ){
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
		}else{
			i += memcopy(&Cmd[i],&CopyCmd[0],1);
			i += memcopy(&Cmd[i],&CopyCmd[1],1);
		}
		i += memcopy(&Cmd[i], ".\x1C&200.",7);

		goto dup;

	case CMD_DUPLEX_A3_600:
	case CMD_DUPLEX_A3_400:
	case CMD_DUPLEX_A3_300:
	case CMD_DUPLEX_A3_240:
	case CMD_DUPLEX_A3_200:
		i = 0;
        i += memcopy(&Cmd[i], "\x1C&0.\x1B\x63\x31",7);
		goto dup;
	case CMD_JIS_90:
	case CMD_JIS_78:
		goto dup;

	dup:
	{
		if( pOEM->Duplex_mode == 0 ){
			i += memcopy(&Cmd[i], "\x1C'S,,",5);
		}else{
	        i += memcopy(&Cmd[i], "\x1C'B",3);
		}
		if( pOEM->Duplex_OU == 1 ){
	        i += memcopy(&Cmd[i], ",F,1",4);
		}
		if( pOEM->Duplex_OU == 2 ){
	        i += memcopy(&Cmd[i], ",F,2",4);
		}
		if( pOEM->Duplex_OU == 3 ){
	        i += memcopy(&Cmd[i], ",F,3",4);
		}
		if( pOEM->Duplex_OU == 4 ){
	        i += memcopy(&Cmd[i], ",F,4",4);
		}
		if( pOEM->Duplex_OU == 5 ){
	        i += memcopy(&Cmd[i], ",B,1",4);
		}
		if( pOEM->Duplex_OU == 6 ){
	        i += memcopy(&Cmd[i], ",B,2",4);
		}
		if( pOEM->Duplex_OU == 7 ){
	        i += memcopy(&Cmd[i], ",B,3",4);
		}
		if( pOEM->Duplex_OU == 8 ){
	        i += memcopy(&Cmd[i], ",B,4",4);
		}
		if( pOEM->Margin == 0 ){
	        i += memcopy(&Cmd[i], ",0.",3);
		}
		if( pOEM->Margin == 1 ){
	        i += memcopy(&Cmd[i], ",1.",3);
		}
		if( pOEM->Margin == 2 ){
	        i += memcopy(&Cmd[i], ",2.",3);
		}
		if( pOEM->Margin == 3 ){
	        i += memcopy(&Cmd[i], ",3.",3);
		}
		if( pOEM->Margin == 4 ){
	        i += memcopy(&Cmd[i], ",4.",3);
		}
		if( pOEM->Margin == 5 ){
	        i += memcopy(&Cmd[i], ",5.",3);
		}
		if( pOEM->Margin == 6 ){
	        i += memcopy(&Cmd[i], ",6.",3);
		}
		if( pOEM->Margin == 7 ){
	        i += memcopy(&Cmd[i], ",7.",3);
		}
		if( pOEM->Margin == 8 ){
	        i += memcopy(&Cmd[i], ",8.",3);
		}
		if( pOEM->Margin == 9 ){
	        i += memcopy(&Cmd[i], ",9.",3);
		}
		if( pOEM->Margin == 10 ){
	        i += memcopy(&Cmd[i], ",10.",4);
		}
		if( pOEM->Margin == 11 ){
	        i += memcopy(&Cmd[i], ",11.",4);
		}
		if( pOEM->Margin == 12 ){
	        i += memcopy(&Cmd[i], ",12.",4);
		}
		if( pOEM->Margin == 13 ){
	        i += memcopy(&Cmd[i], ",13.",4);
		}
		if( pOEM->Margin == 14 ){
	        i += memcopy(&Cmd[i], ",14.",4);
		}
		if( pOEM->Margin == 15 ){
	        i += memcopy(&Cmd[i], ",15.",4);
		}
		if( pOEM->Margin == 16 ){
	        i += memcopy(&Cmd[i], ",16.",4);
		}
		if( pOEM->Margin == 17 ){
	        i += memcopy(&Cmd[i], ",17.",4);
		}
		if( pOEM->Margin == 18 ){
	        i += memcopy(&Cmd[i], ",18.",4);
		}
		if( pOEM->Margin == 19 ){
	        i += memcopy(&Cmd[i], ",19.",4);
		}
		if( pOEM->Margin == 20 ){
	        i += memcopy(&Cmd[i], ",20.",4);
		}
	    switch (dwCmdCbID) {
			case CMD_DUPLEX_A2_600:
		        i += memcopy(&Cmd[i], "\x1C\x66PAI.\x0C\x0D\x0A\x1B\x63\x31\x1C&600.\x1C\x64\x32\x34\x30.",24);
				break;
			case CMD_DUPLEX_A2_400:
		        i += memcopy(&Cmd[i], "\x1C\x66PAI.\x0C\x0D\x0A\x1B\x63\x31\x1C&400.\x1C\x64\x32\x34\x30.",24);
				break;
			case CMD_DUPLEX_A2_300:
		        i += memcopy(&Cmd[i], "\x1C\x66PAI.\x0C\x0D\x0A\x1B\x63\x31\x1C&300.\x1C\x64\x32\x34\x30.",24);
				break;
			case CMD_DUPLEX_A2_240:
		        i += memcopy(&Cmd[i], "\x1C\x66PAI.\x0C\x0D\x0A\x1B\x63\x31\x1C&240.\x1C\x64\x32\x34\x30.",24);
				break;
			case CMD_DUPLEX_A2_200:
		        i += memcopy(&Cmd[i], "\x1C\x66PAI.\x0C\x0D\x0A\x1B\x63\x31\x1C&200.\x1C\x64\x32\x34\x30.",24);
				break;
			case CMD_DUPLEX_A3_600:
				if(!pdwParams) return 0;
		        copynum = PARAM(pdwParams, 0);
				if( pOEM->ESort_mode == 1){
					copynumber(&CopyCmd[0],copynum);
				}
				else{
					copynum = 1;
					CopyCmd[0] = 0x31;
				}
				i += memcopy(&Cmd[i],"\x1C\x78",2);
				if(copynum < 10 ){
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
				}else{
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
					i += memcopy(&Cmd[i],&CopyCmd[1],1);
				}
		        i += memcopy(&Cmd[i], ".\x1C&600.\x1C\x66PAI.\x0D\x0A",15);
				break;
			case CMD_DUPLEX_A3_400:
				if(!pdwParams) return 0;
		        copynum = PARAM(pdwParams, 0);
				if( pOEM->ESort_mode == 1){
					copynumber(&CopyCmd[0],copynum);
				}
				else{
					copynum = 1;
					CopyCmd[0] = 0x31;
				}
				i += memcopy(&Cmd[i],"\x1C\x78",2);
				if(copynum < 10 ){
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
				}else{
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
					i += memcopy(&Cmd[i],&CopyCmd[1],1);
				}
		        i += memcopy(&Cmd[i], ".\x1C&400.\x1C\x66PAI.\x0D\x0A",15);
				break;
			case CMD_DUPLEX_A3_300:
		        i += memcopy(&Cmd[i], "\x1C\x78\x31.\x1C&300.\x1C\x66PAI.\x0D\x0A",18);
				break;
			case CMD_DUPLEX_A3_240:
				if(!pdwParams) return 0;
		        copynum = PARAM(pdwParams, 0);
				if( pOEM->ESort_mode == 1){
					copynumber(&CopyCmd[0],copynum);
				}
				else{
					copynum = 1;
					CopyCmd[0] = 0x31;
				}
				i += memcopy(&Cmd[i],"\x1C\x78",2);
				if(copynum < 10 ){
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
				}else{
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
					i += memcopy(&Cmd[i],&CopyCmd[1],1);
				}
		        i += memcopy(&Cmd[i], ".\x1C&240.\x1C\x66PAI.\x0D\x0A",15);
				break;
			case CMD_DUPLEX_A3_200:
				if(!pdwParams) return 0;
		        copynum = PARAM(pdwParams, 0);
				if( pOEM->ESort_mode == 1){
					copynumber(&CopyCmd[0],copynum);
				}
				else{
					copynum = 1;
					CopyCmd[0] = 0x31;
				}
				i += memcopy(&Cmd[i],"\x1C\x78",2);
				if(copynum < 10 ){
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
				}else{
					i += memcopy(&Cmd[i],&CopyCmd[0],1);
					i += memcopy(&Cmd[i],&CopyCmd[1],1);
				}
		        i += memcopy(&Cmd[i], ".\x1C&200.\x1C\x66PAI.\x0D\x0A",15);
				break;
			case CMD_SORT_NONE:
		        i += memcopy(&Cmd[i], "\x1C\x25\x45,1",5);
				break;
			case CMD_SORT_COPY:
		        i += memcopy(&Cmd[i], "\x1C\x25\x43,1",5);
				break;
			case CMD_SORT_SORT:
		        i += memcopy(&Cmd[i], "\x1C\x25\x53,1",5);
				break;
			case CMD_SORT_BIN:
		        i += memcopy(&Cmd[i], "\x1C\x25\x42,1",5);
				break;
			case CMD_SORT_STACK:
		        i += memcopy(&Cmd[i], "\x1C\x25\x54,1",5);
				break;
			case CMD_JIS_90:
		        i += memcopy(&Cmd[i], "\x1C\x30\x35\x46\x32-\x30\x32",8);
				break;
			case CMD_JIS_78:
		        i += memcopy(&Cmd[i], "\x1C\x30\x35\x46\x32-\x30\x30",8);
				break;
		}
	    switch (dwCmdCbID) {
			case CMD_DUPLEX_A3_600:
			case CMD_DUPLEX_A3_400:
			case CMD_DUPLEX_A3_300:
			case CMD_DUPLEX_A3_240:
			case CMD_DUPLEX_A3_200:
				i += memcopy(&Cmd[i], "\x0C\x1B\x63\x31\x1B\x25-12345X@PJL EOJ\x0D\x0A@PJL ENTER LANGUAGE=DEFAULT\x0D\x0A",52);
				break;
		}
		WRITESPOOLBUF(pdevobj, Cmd, i);
		break;
	}

    case CMD_CR:

        pOEM->dwDeviceDestX = 0;
        WRITESPOOLBUF(pdevobj, "\015", 1);
        break;

    case CMD_MOVE_X:
    case CMD_MOVE_Y:

        if (dwCount < 4)
            return 0;      // cannot do anything

        if( pdwParams && PARAM(pdwParams, 2) && PARAM(pdwParams, 3) ) {
			pOEM->dwDeviceDestX = PARAM(pdwParams, 0) /
    	            (MASTER_UNIT / PARAM(pdwParams, 2));
        	pOEM->dwDeviceDestY = PARAM(pdwParams, 1) /
            	    (MASTER_UNIT / PARAM(pdwParams, 3));
		} else
			return 0;
        // Set return value

        switch (dwCmdCbID) {
        case CMD_MOVE_X:
            iRet = (INT)pOEM->dwDeviceDestX;
            break;
        case CMD_MOVE_Y:
            iRet = (INT)pOEM->dwDeviceDestY;
            break;
        }

        break;

    case CMD_RES_600:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/600,i.\x1CYSC;SU1,600,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 600;
        break;

    case CMD_RES_400:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/400,i.\x1CYSC;SU1,400,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 400;
        break;

    case CMD_RES_240:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/240,i.\x1CYSC;SU1,240,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 240;
        break;
    case CMD_RES_300:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/300,i.\x1CYSC;SU1,300,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 300;
        break;
    case CMD_RES_200:

        i = 0;
        i += memcopy(&Cmd[i], "\x1C<1/200,i.\x1CYSC;SU1,200,0;PM1,1;SG0;\x1CZ", 37);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        pOEM->wRes = MASTER_UNIT / 200;
        break;
    case CMD_BEGIN_RASTER:

        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i = 0;
            i += memcopy(&Cmd[i], "\034R", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        break;

    case CMD_SEND_BLOCK_DATA:

        // Rememter length of the scan line.

		if(!pdwParams) return 0;
        pOEM->dwScanLen = PARAM(pdwParams, 0);
        break;

#ifdef BYPASS
    case CMD_BEGIN_RASTER_NO_COMP:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i = 0;
            i += memcopy(&Cmd[i], "\034R", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        pOEM->fGeneral |= FG_NO_COMP;
        break;

#endif // BYPASS

    case CMD_PC_PRN_DIRECTION:
        {
        LONG lEsc90;
        LONG ESin[] = {0, 1, 0, -1};
        LONG ECos[] = {1, 0, -1, 0};

		if(!pdwParams) return 0;
        lEsc90 = (PARAM(pdwParams, 0) % 360) / 90;

        pOEM->lSBCSXMove = pOEM->dwSBCSX * ECos[lEsc90];
        pOEM->lSBCSYMove = -(LONG)pOEM->dwSBCSX * ESin[lEsc90];
        pOEM->lDBCSXMove = pOEM->dwDBCSX * ECos[lEsc90];
        pOEM->lDBCSYMove = -(LONG)pOEM->dwDBCSX * ESin[lEsc90];
        }
        break;

    case CMD_FF:

        i = 0;
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i += memcopy(&Cmd[i], "EP;FL;\x1CZ\x0D\x0C", 10);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i += memcopy(&Cmd[i], "\x1CR\x0D\x0C", 4);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        else{
            i += memcopy(&Cmd[i], "\x0D\x0C", 2);
            WRITESPOOLBUF(pdevobj, Cmd, i);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        break;

    case CMD_INIT_COORDINATE:
        pOEM->dwDeviceDestX = 0;
        pOEM->dwDeviceDestY = 0;
        pOEM->wCurrentAddMode = FLAG_RASTER;
        pOEM->cSubPath = 0;

        break;

    case CMD_WHITE_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034\"R.\034$100.", 10);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_WHITE_OFF:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034\"O.\034$0.", 8);
        WRITESPOOLBUF(pdevobj, Cmd, i);
		break;

    case CMD_BOLD_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,1.", 6);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_ITALIC_ON:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,2.", 6);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_CLEAR_ATTRIB_P:
        if (pOEM->wCurrentAddMode == FLAG_VECTOR){
            i = 0;
            i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
            pOEM->wCurrentAddMode = FLAG_RASTER;
        }
        i += memcopy(&Cmd[i], "\034c,,0,80.", 9);
        WRITESPOOLBUF(pdevobj, Cmd, i);

        break;

    case CMD_RECTWIDTH:
		if(!pdwParams || !pOEM->wRes ) return 0;
        pOEM->dwRectWidth = PARAM(pdwParams, 0) / pOEM->wRes;
        break;

    case CMD_RECTHEIGHT:
		if(!pdwParams || !pOEM->wRes ) return 0;
        pOEM->dwRectHeight = PARAM(pdwParams, 0) / pOEM->wRes;
        break;

    case CMD_RECTWHITE:
        gray = 100;
        goto fill;
    case CMD_RECTBLACK:
        gray = 0;
        goto fill;
    case CMD_RECTGRAY:
		if(!pdwParams) return 0;
        gray = 100 - PARAM(pdwParams, 0);
        goto fill;

    fill:
        {
// add 2000.12.28
        // if rectangle size is zeor,we do not draw.
        if(pOEM->dwRectWidth - 1 < 1 && pOEM->dwRectHeight - 1 < 1)
            break;

        i = 0;
        /* Raster mode -> Vector mode in */
        if (pOEM->wCurrentAddMode == FLAG_RASTER){
            i += memcopy(&Cmd[i], "\x1CY", 2);
            pOEM->wCurrentAddMode = FLAG_VECTOR;
            if(pOEM->iGray != gray){
                i += memcopy(&Cmd[i], "SG", 2);   // Send Gray Scale
                i += iDwtoA(&Cmd[i], gray);
                Cmd[i++] = ';';
                pOEM->iGray = gray;
            }
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
    }
        /* Text mode -> Vector mode in */
        else if (pOEM->wCurrentAddMode == FLAG_SBCS ||
                 pOEM->wCurrentAddMode == FLAG_DBCS){
            i += memcopy(&Cmd[i], "\x1CR\x1CY", 4);
            pOEM->wCurrentAddMode = FLAG_VECTOR;
            if(pOEM->iGray != gray){
                i += memcopy(&Cmd[i], "SG", 2);   // Send Gray Scale
                i += iDwtoA(&Cmd[i], gray);
                Cmd[i++] = ';';
                pOEM->iGray = gray;
            }
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
        }
/* add 2000.12.28 */
        /* Already Vector mode and gray scale changed  or
           sub path count is over 500 */
        if(pOEM->iGray != gray){
            i += memcopy(&Cmd[i], "EP;FL;SG", 8);
            i += iDwtoA(&Cmd[i], gray);
            i += memcopy(&Cmd[i], ";NP;", 4);
            pOEM->iGray = gray;
            pOEM->cSubPath = 0;
        }
        else if(pOEM->cSubPath >= MAX_SUBPATH){
            i += memcopy(&Cmd[i], "EP;FL;", 6);
            i += memcopy(&Cmd[i], "NP;", 3);
            pOEM->cSubPath = 0;
        }

        i += memcopy(&Cmd[i], "MA", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
        Cmd[i++] = ',';
        i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY);
        i += memcopy(&Cmd[i], ";PR", 3);
        i += iDwtoA(&Cmd[i], pOEM->dwRectWidth - 1);
        i += memcopy(&Cmd[i], ",0,0,", 5);
        i += iDwtoA(&Cmd[i], pOEM->dwRectHeight - 1);
        i += memcopy(&Cmd[i], ",-", 2);
        i += iDwtoA(&Cmd[i], pOEM->dwRectWidth - 1);
        i += memcopy(&Cmd[i], ",0;CP;", 6);
        pOEM->cSubPath+=4;   // rect is built by 4 line

        pOEM->cSubPath = MAX_SUBPATH;

        /* send RectFill command */
        WRITESPOOLBUF(pdevobj, Cmd, i);
        }

        break;
    }
    return iRet;
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMSendFontCmd
//
//-----------------------------------------------------------------------------
VOID
APIENTRY
OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4]; // it means dwSize + dwNumOfVariable +
                                       // (dwStdVarID + lStdVariable) * n
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    POEMUD_EXTRADATA    pOEM;
    DWORD   tmpPointsx, tmpPointsy;
    PIFIMETRICS pIFI;
    DWORD       dwNeeded;
    DWORD       dwCount;
    BOOL        bFound = FALSE;

    VERBOSE(("OEMSendFontCmd() entry.\r\n"));
    VERBOSE((("CMD size:%ld\r\n"), pFInv->dwCount));

    if(!pFInv->dwCount){
        VERBOSE(("CMD size is Zero return\r\n"));
        return;
    }
    pubCmd = pFInv->pubCommand;
    dwCount = pFInv->dwCount;
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    pIFI = pUFObj->pIFIMetrics;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
            pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return;
    }
    VERBOSE((("FONTHEIGHT=%d\r\n"), pSV->StdVar[0].lStdVariable));
    VERBOSE((("FONTWIDTH=%d\r\n"), pSV->StdVar[1].lStdVariable));

    if( !pSV->StdVar[2].lStdVariable ) return;
	tmpPointsy = pSV->StdVar[0].lStdVariable * 720 / pSV->StdVar[2].lStdVariable;
    dwIn = dwOut = 0;

    /* vector mode ends.*/
    if (pOEM->wCurrentAddMode == FLAG_VECTOR){
        dwOut += memcopy(&aubCmd[dwOut], "EP;FL;\034Z", 8);
    }

    /* make font select command */
    while(dwCount--)
    {
        if(pubCmd[dwIn] !='#'){
            aubCmd[dwOut] = pubCmd[dwIn];
            dwOut++;
            dwIn++;
        }
        else{
            bFound = TRUE;
            break;
        }
    }

    if(bFound == TRUE)
        dwIn++;
    else
        return;   // mismatch font command

    pOEM->fGeneral &= ~(FG_VERT | FG_PLUS | FG_DBCS);

    switch(pubCmd[dwIn])
    {
    case 'O':                 // for OCR-B Font support
        pOEM->fGeneral |= FG_PLUS;
        tmpPointsy = tmpPointsx = 120 * pOEM->wRes;  // Only 12pt
        break;

    case 'R':                 // NPDL2P SBCS
        pOEM->fGeneral |= FG_PLUS;
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1200 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'P':                // NPDL2 SBCS
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1200 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'W':                // NPDL2 DBCS and FontCard
        pOEM->fGeneral |= FG_VERT;

    case 'Q':
        pOEM->fGeneral |= FG_DBCS;
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1440 /
                     pSV->StdVar[2].lStdVariable;
        break;

    case 'Y':                // NPDL2P DBCS and FontCard
        pOEM->fGeneral |= FG_VERT;

    case 'S':
        pOEM->fGeneral |= (FG_PLUS | FG_DBCS);
        tmpPointsx = pSV->StdVar[1].lStdVariable * 1440 /
                     pSV->StdVar[2].lStdVariable;
        break;
    }

    if(pOEM->fGeneral & FG_PLUS)
    {
        if(tmpPointsy > 9999)    tmpPointsy = 9999;
        else if(tmpPointsy < 10) tmpPointsy = 10;

        if(tmpPointsx > 9999)    tmpPointsx = 9999;
        else if(tmpPointsx < 10) tmpPointsx = 10;

        pOEM->wScale = tmpPointsx == tmpPointsy;
        pOEM->lPointsx = tmpPointsx;
        pOEM->lPointsy = tmpPointsy;

		if( !pOEM->wRes ) return;
        if(pOEM->fGeneral & FG_VERT)
        {
            if(pOEM->wScale){
                aubCmd[dwOut++] = '\034';
                dwOut += memcopy(&aubCmd[dwOut], "12S2-", 5);
                dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                         tmpPointsy / pOEM->wRes, 4);
                aubCmd[dwOut++] = '-';
                dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                         tmpPointsx / pOEM->wRes, 4);
            }
        }
        else{
            dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                     tmpPointsx / pOEM->wRes, 4);
            aubCmd[dwOut++] = '-';
            dwOut += iDwtoA_FillZero(&aubCmd[dwOut],
                                     tmpPointsy / pOEM->wRes, 4);
        }
        goto SEND_COM;
    }

    pOEM->wScale = 1;

    if(tmpPointsy > 9999)
    {
        tmpPointsy = 9999;
        goto MAKE_COM;
    }

    if(tmpPointsy < 10)
    {
        tmpPointsy = 10;
        goto MAKE_COM;
    }

	pOEM->wScale = (int)(((tmpPointsx * 10) / tmpPointsy + 5) / 10);

    if(pOEM->wScale > 8) pOEM->wScale = 8;

MAKE_COM:
	if(!pOEM->wRes) return;
    dwOut += iDwtoA_FillZero(&aubCmd[dwOut], tmpPointsy / pOEM->wRes, 4);

SEND_COM:

    if(!(pOEM->fGeneral & FG_PLUS))
    {
        char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                         "4/1", "4/1", "6/1", "6/1", "8/1"};

        if(pOEM->fGeneral & FG_VERT)
        {
            if(pOEM->wScale == 1)
            {
                dwOut += memcopy(&aubCmd[dwOut], "\034m1/1,1/1.", 10);
            }
        }
        else
        {
            aubCmd[dwOut++] = '\034';
            dwOut += memcopy(&aubCmd[dwOut], "m1/1,", 5);
			if(pOEM->wScale>=(sizeof(bcom)/sizeof(bcom[0]))) return;
            dwOut += memcopy(&aubCmd[dwOut], (LPSTR)bcom[pOEM->wScale], 3);
            aubCmd[dwOut++] = '.';
        }
    }
    // write spool builded command
    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

    /*
     * I expect the interval of the current letter and the next letter
     * from the letter size.
     */
	if(!pOEM->wRes) return;
    if(pOEM->fGeneral & FG_DBCS){

        pOEM->dwDBCSX =
        pOEM->lDBCSXMove =
                 (LONG)((pSV->StdVar[1].lStdVariable * 2.04) / pOEM->wRes);

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 (LONG)(pSV->StdVar[1].lStdVariable * 1.03 / pOEM->wRes);
    }
    else{

        pOEM->dwSBCSX =
        pOEM->lSBCSXMove =
                 pSV->StdVar[1].lStdVariable / pOEM->wRes;

    }

    pOEM->lDBCSYMove = pOEM->lSBCSYMove = 0;
    pOEM->wCurrentAddMode = FLAG_RASTER;

    VERBOSE(("OEMSendFontCmd() end.\r\n"));
}


//-----------------------------------------------------------------------------
//
//  Function:   OEMOutputCharStr
//
//-----------------------------------------------------------------------------
VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    WORD        wlen;
    WORD        j;
    PIFIMETRICS pIFI;
    POEMUD_EXTRADATA    pOEM;
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
//NTRAID#NTBUG9-333653-2002/03/28-hiroi-#333653: Change I/F for GETINFO_GLYPHSTRING
// BYTE  aubBuff[256];
    PBYTE       aubBuff;
    DWORD  dwI;
    DWORD       dwNeeded;

// Adjust baseline if font substituted form TureType font.
	DWORD		dwYAdj;
	PGETINFO_STDVAR	pSV;
	DWORD 		adwStdVar[2+2*2];
    BYTE  Cmd[256];
    int i;

    VERBOSE(("OEMOutputCharStr() entry.\r\n"));
    VERBOSE((("FONT Num=%d\r\n"), dwCount));

    if(dwType != TYPE_GLYPHHANDLE){
        VERBOSE((("NOT TYPE_GLYPHHANDLE\r\n")));
        return;
    }

    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);
    pIFI = pUFObj->pIFIMetrics;


    //
    // Call the Unidriver service routine to convert
    // glyph-handles into the character code data.
    //

//NTRAID#NTBUG9-333653-2002/03/28-hiroi-: Change I/F for GETINFO_GLYPHSTRING
    GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
    GStr.dwCount   = dwCount;
    GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
    GStr.pGlyphIn  = pGlyph;
    GStr.dwTypeOut = TYPE_TRANSDATA;
    GStr.pGlyphOut = NULL;
    GStr.dwGlyphOutSize = 0;

    if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded) || !GStr.dwGlyphOutSize)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        return;
    }

    if ((aubBuff = MemAlloc(GStr.dwGlyphOutSize)) == NULL)
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:MemAlloc failed.\r\n"));
        return;
    }

    GStr.pGlyphOut = aubBuff;

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded))
    {
        VERBOSE(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        goto out;
    }

    // Adjust baseline if font substituted from TrueType font.
    if (pUFObj->dwFlags & UFOFLAG_TTSUBSTITUTED) {
        pSV = (PGETINFO_STDVAR)adwStdVar;
        pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
        pSV->dwNumOfVariable = 2;
        pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
        pSV->StdVar[1].dwStdVarID = FNT_INFO_TEXTYRES;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
                pSV->dwSize, &dwNeeded)) {
            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
            goto out;
        }
		if(!pOEM->wRes) goto out;
        dwYAdj = (pSV->StdVar[0].lStdVariable * pIFI->fwdWinDescender /
            pIFI->fwdUnitsPerEm) / pOEM->wRes;
    } else
        dwYAdj = 0;

    /* Vector mode off */
    if (pOEM->wCurrentAddMode == FLAG_VECTOR){
        i = 0;
        i += memcopy(&Cmd[i], "EP;FL;\034Z", 8);
        WRITESPOOLBUF(pdevobj, Cmd, i);
        pOEM->wCurrentAddMode = FLAG_RASTER;
    }

    /*
     * Three kind of the character cords which is given by UNIDRV
     * 1.SBCS
     * 2.DBCS Kanji
     * 3.DBCS ANK
     */
    pTrans = (PTRANSDATA)aubBuff;
    for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
    {
        switch (pTrans->ubType & MTYPE_FORMAT_MASK)
        {
        case MTYPE_DIRECT:
        /*
         Pattern 1: SBCS
         */
        if(pOEM->wCurrentAddMode != FLAG_SBCS ||
           pOEM->dwDeviceDestX + 1 < pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
           pOEM->dwDevicePrevX + pOEM->lPrevXMove < pOEM->dwDeviceDestX - 1 ||
           pOEM->dwDeviceDestY + 1 < pOEM->dwDevicePrevY + pOEM->lPrevYMove ||
           pOEM->dwDevicePrevY + pOEM->lPrevYMove < pOEM->dwDeviceDestY - 1)
        {
            i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
			// Adjust baseline if font substituted form TureType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

            i += memcopy(&Cmd[i], "\034a", 2);
            i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
            Cmd[i++] = ',';
            i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
            Cmd[i++] = '.';

            WRITESPOOLBUF(pdevobj, Cmd, i);

            pOEM->wCurrentAddMode = FLAG_SBCS;
            pOEM->lPrevXMove = pOEM->lSBCSXMove;
            pOEM->lPrevYMove = pOEM->lSBCSYMove;
        }
        WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubCode, 1);
        break;

        case MTYPE_PAIRED:
        /*
         Pattern 2: kanji
         */
        if(*pTrans->uCode.ubPairs)
        {
            if(pOEM->wCurrentAddMode != FLAG_DBCS ||
           pOEM->dwDeviceDestX + 1 < pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
           pOEM->dwDevicePrevX + pOEM->lPrevXMove < pOEM->dwDeviceDestX - 1 ||
           pOEM->dwDeviceDestY + 1 < pOEM->dwDevicePrevY + pOEM->lPrevYMove ||
           pOEM->dwDevicePrevY + pOEM->lPrevYMove < pOEM->dwDeviceDestY - 1)

            {
                i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
			// Adjust baseline if font substituted form TureType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lDBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lDBCSYMove);
                Cmd[i++] = '.';

                if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033t", 2);

                    if(pOEM->wScale != 1)
                    {
                        if(!(pOEM->fGeneral & FG_PLUS))
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1",
                                             "8/1"};
                            Cmd[i++] = '\034';
                            Cmd[i++] = 'm';
							if(pOEM->wScale >= (sizeof(bcom)/sizeof(bcom[0]))) goto out;
                            i += memcopy(&Cmd[i], (LPSTR)bcom[pOEM->wScale], 3);
                            i += memcopy(&Cmd[i], ",1/1.", 5);
                        }
                        else{
							if(!pOEM->wRes) goto out;
                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "12S2-", 5);
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsy / pOEM->wRes, 4);
                            Cmd[i++] = '-';
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsx / pOEM->wRes, 4);
                        }
                    }
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_DBCS;
                pOEM->lPrevXMove = pOEM->lDBCSXMove;
                pOEM->lPrevYMove = pOEM->lDBCSYMove;
            }
        }
        /*
         Pattern 3: ANK
         */
        else
        {
            if(pOEM->wCurrentAddMode != FLAG_SBCS ||
           pOEM->dwDeviceDestX + 1 < pOEM->dwDevicePrevX + pOEM->lPrevXMove ||
           pOEM->dwDevicePrevX + pOEM->lPrevXMove < pOEM->dwDeviceDestX - 1 ||
           pOEM->dwDeviceDestY + 1 < pOEM->dwDevicePrevY + pOEM->lPrevYMove ||
           pOEM->dwDevicePrevY + pOEM->lPrevYMove < pOEM->dwDeviceDestY - 1)
            {
                i = 0;

            i += memcopy(&Cmd[i], "\034e", 2);
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestX);
            Cmd[i++] = ',';
			// Adjust baseline if font substituted from TureType font.
            i += iDwtoA(&Cmd[i], pOEM->dwDeviceDestY + dwYAdj);
            Cmd[i++] = '.';

                i += memcopy(&Cmd[i], "\034a", 2);
                i += iDwtoA(&Cmd[i], pOEM->lSBCSXMove);
                Cmd[i++] = ',';
                i += iDwtoA(&Cmd[i], pOEM->lSBCSYMove);
                Cmd[i++] = '.';

                /*
                 * ANK can't do vertical writing. We have to do
                 * vertical writing for holizontal writing compulsorily
                 */
                 if(pOEM->fGeneral & FG_VERT)
                {
                    i += memcopy(&Cmd[i], "\033K", 2);

                    if(pOEM->wScale != 1)
                    {
                        if(!(pOEM->fGeneral & FG_PLUS))
                        {
                            char  *bcom[] = {"1/2", "1/1", "2/1", "3/1",
                                             "4/1", "4/1", "6/1", "6/1", "8/1"};                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "m1/1,", 5);
							if(pOEM->wScale >= (sizeof(bcom)/sizeof(bcom[0]))) goto out;
                            i += memcopy(&Cmd[i], (LPSTR)bcom[pOEM->wScale], 3);
                            Cmd[i++] = '.';
                        }
                        else{
							if(!pOEM->wRes) goto out;
                            Cmd[i++] = '\034';
                            i += memcopy(&Cmd[i], "12S2-", 5);
                            i += iDwtoA_FillZero(&Cmd[i],
                                               pOEM->lPointsx / pOEM->wRes, 4);
                            Cmd[i++] = '-';
                            i += iDwtoA_FillZero(&Cmd[i],
                                              pOEM->lPointsy / pOEM->wRes, 4);
                        }
                    }
                }
                WRITESPOOLBUF(pdevobj, Cmd, i);
                pOEM->wCurrentAddMode = FLAG_SBCS;
                pOEM->lPrevXMove = pOEM->lSBCSXMove;
                pOEM->lPrevYMove = pOEM->lSBCSYMove;
                }
        }
        WRITESPOOLBUF(pdevobj, pTrans->uCode.ubPairs, 2);
        break;

        }
        pOEM->dwDevicePrevX = pOEM->dwDeviceDestX;
        pOEM->dwDevicePrevY = pOEM->dwDeviceDestY;
        pOEM->dwDeviceDestX += pOEM->lPrevXMove;
        pOEM->dwDeviceDestY += pOEM->lPrevYMove;
    }

// NTRAID#NTBUG9-741174-2002/11/20-yasuho-: Memory leak happened.
out:

//NTRAID#NTBUG9-333653-2002/03/28-hiroi-: Change I/F for GETINFO_GLYPHSTRING
    MemFree(aubBuff);
    VERBOSE(("OEMOutputCharStr() end.\r\n"));

}


// NTRAID#NTBUG9-741174-2002/11/20-yasuho-: Memory leak happened.
PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    if (NULL == pdevobj)
    {
        ERR(("OEMEnablePDEV: Invalid parameter(s).\n"));
        return NULL;
    }

    return pdevobj->pOEMDM;
}

VOID
APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj
    )

/*++

Routine Description:

    Implementation of DDI entry point OEMDisablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

Return Value:

    NONE

--*/

{
    POEMUD_EXTRADATA    pOEM;

    VERBOSE(("Entering OEMDisablePDEV...\n"));

    //
    // verify pdevobj okay
    //
	if(!VALID_PDEVOBJ(pdevobj)) return;

    //
    // fill in printer commands
    //
    pOEM = (POEMUD_EXTRADATA)(pdevobj->pOEMDM);

    //
    // Free up memory allocated for the temp. buffer
    //

    if (pOEM->pCompBuf) {
        FREEMEM(pOEM->pCompBuf);
        pOEM->pCompBuf = NULL;
        pOEM->dwCompBufLen = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncmwjres\sources.inc ===
MAJORCOMP=windows
MINORCOMP=md_ncmwjres

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\nec\$(ALT_PROJECT)
SRCDIR=..
HLPDIR=$(SRCDIR)\hlp

TARGETNAME=ncmwjres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
COFFBASE=ncmwjres
!ELSE
COFFBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\ncmwjres.rc \
    $(SRCDIR)\ncmwjres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\ncmwjres.ini \
    $(GPDDIR)\nc45m2j.gpd \
    $(GPDDIR)\ncm45mj.gpd \
    $(GPDDIR)\ncm65aj.gpd \
    $(HLPDIR)\ncmwjres.hlp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsres\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT, Windows 2000
//
//

#include <strsafe.h>

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncnmjres\hlp\helpid.h ===
// HELP  Index


#define POP_NM_FEEDPOS_A3           701
#define POP_NM_FEEDPOS_B4           702
#define POP_NM_FEEDPOS_A4           703
#define POP_NM_QUARITY              704

/* TextHalftoneThreshold */
#define POP_NM_TEXTHALFTONE         705
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsres\command.cpp ===
/*=============================================================================
 * FILENAME: command.cpp
 * Copyright (C) 1996-1999 HDE, Inc.  All Rights Reserved. HDE Confidential.
 * Copyright (C) 1999 NEC Technologies, Inc. All Rights Reserved.
 *
 * DESCRIPTION: Support for OEMCommand function to interject additional
 *              postscript commands into the postscript stream.
 * NOTES:  
 *=============================================================================
*/

#include "precomp.h"

#include <windows.h>
#include <WINDDI.H>
#include <PRINTOEM.H>
#include <winspool.h>

#include <stdio.h>
#include <stdlib.h>

#include <strsafe.h>

#include "nc46nt.h"

#include "oemps.h"



/******************************************************************************
 * DESCRIPTION: Get *JUST* filename from Full path format data 
 *****************************************************************************/

extern "C"
void GetFileName(char *FULL)
{
	char	work[NEC_DOCNAME_BUF_LEN+2], *pwork, *plast;
	int		i, j;


	strncpy(work, FULL, NEC_DOCNAME_BUF_LEN+1); // #517724: PREFAST
	work[NEC_DOCNAME_BUF_LEN+1] = '\0'; // force terminate by '\0'

	j = strlen(work);



	for(plast = pwork = work; pwork < work + j; ++pwork)
	{


		if(*pwork == '\\')	plast = pwork+1;
	}

	// Destination buffer size is smaller than 'work' buffer.
	strncpy(FULL, plast, NEC_DOCNAME_BUF_LEN);
}

/******************************************************************************
 * DESCRIPTION: Exported function for OEM plug-in. Required name and parameters
 *              from the OEM plug-in spectification.
 *              file must be exported in .def file
 *****************************************************************************/
extern "C"
DWORD APIENTRY OEMCommand( PDEVOBJ pDevObj, DWORD dwIndex,
                           PVOID pData, DWORD cbSize )
{
	char *pMem;
	char szUserName[NEC_USERNAME_BUF_LEN+2];


	PDRVPROCS pProcs;
	DWORD dwRv = ERROR_NOT_SUPPORTED;
	DWORD dwNeeded = 0;
	DWORD dwCOptions = 0;
	DWORD dwCbRet;
	BOOL bRv = 0;
	
	int	NumCopies = 1;

	POEMPDEV    poempdev = (POEMPDEV) pDevObj->pdevOEM;

   if( pDevObj == NULL )
      return( dwRv );
   if( (pProcs = (PDRVPROCS)pDevObj->pDrvProcs) == NULL )
      return( dwRv );






   switch( dwIndex )
   {
      case PSINJECT_BEGINSTREAM:
         pMem = (char*)EngAllocMem(FL_ZERO_MEMORY, NEC_DOCNAME_BUF_LEN, OEM_SIGNATURE ); 
         if( pMem != NULL )
         {
            POEMDEV pOEMDM = (POEMDEV)pDevObj->pOEMDM;
            // convert username from unicode string to ascii char string
#ifdef USERMODE_DRIVER
			WideCharToMultiByte(CP_THREAD_ACP,
								WC_NO_BEST_FIT_CHARS,
								pOEMDM->szUserName,
								wcslen(pOEMDM->szUserName) * 2 + 2,
								szUserName,
								NEC_USERNAME_BUF_LEN,
								NULL,
								NULL);
#else // !USERMODE_DRIVER
            EngUnicodeToMultiByteN( szUserName, NEC_USERNAME_BUF_LEN, &dwCbRet,
                                    pOEMDM->szUserName,
//                                    NEC_USERNAME_BUF_LEN * sizeof( WCHAR ) );
                                    wcslen(pOEMDM->szUserName) * 2 + 2);
#endif // USERMODE_DRIVER
			cbSize = 50;
            if( pProcs->DrvGetDriverSetting != NULL )
            {
               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCSpooler", pMem, cbSize, &dwNeeded, &dwCOptions ); 
               if( strcmp( pMem, "True" ) == 0 )
			   {
					// output PS-like header
					StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, 
						"%!PS-Adobe-3.0\r\n% Spooled PostScript job\r\n{\r\n {\r\n  1183615869 internaldict begin\r\n  (Job ID is) print \r\n  <<\r\n"
					);
				    if( pProcs->DrvWriteSpoolBuf != NULL )
				       pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 

					// output JobName
					StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /JobName (");
				    if( pProcs->DrvWriteSpoolBuf != NULL )
				       pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					strncpy(pMem, poempdev->szDocName, NEC_DOCNAME_BUF_LEN);

					// strcpy(pMem, "c:\\test\\test\\test\\simulate.dat"); // for Full Path Simulation

					GetFileName(pMem);
					// check document name
					//if(strcmp(pMem, "") == 0)	strcpy(pMem, "No information");
		            if( pProcs->DrvWriteSpoolBuf != NULL )
			           pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, ")\r\n");
				    if( pProcs->DrvWriteSpoolBuf != NULL )
				       pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
		
					// output Owner
					//sprintf(pMem,"    /Owner (%s)\r\n",szUserName);
					StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Owner (");
		            if( pProcs->DrvWriteSpoolBuf != NULL )
		               pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					strncpy(pMem, szUserName, NEC_DOCNAME_BUF_LEN);
					// check szUserName
					// if(strcmp(pMem, "") == 0)	strcpy(pMem, "No information");
			        if( pProcs->DrvWriteSpoolBuf != NULL )
				       pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, ")\r\n");
					if( pProcs->DrvWriteSpoolBuf != NULL )
					   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
















			
					// Get and Modify NumCopies
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCCollate", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "True" ) == 0 )
					   {
						   NumCopies = pDevObj->pPublicDM->dmCopies;
						   pDevObj->pPublicDM->dmCopies = 1;
					   }
		            }

					// output NumCopies
					//sprintf(pMem,"    /NumCopies %d\r\n",NumCopies);
					StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /NumCopies ");
		            if( pProcs->DrvWriteSpoolBuf != NULL )
		               pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					_itoa(NumCopies, pMem, 10);
		            if( pProcs->DrvWriteSpoolBuf != NULL )
		               pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "\r\n");
		            if( pProcs->DrvWriteSpoolBuf != NULL )
		               pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 


					// Put /Collate
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCCollate", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "True" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Collate true\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   else
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Collate false\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					}

					// Put /Banner
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCBanner", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "True" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Banner true\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   else
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Banner false\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					}

					// Put /DeleteJob
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCJobpreview", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "True" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /DeleteJob false\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   else
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /DeleteJob true\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					}

					// Put /HoldJob
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCHoldjob", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "True" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /HoldJob true\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   else
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /HoldJob false\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					}

					// Put /Priority
					cbSize = 50;
		            if( pProcs->DrvGetDriverSetting != NULL )
		            {
		               dwRv = pProcs->DrvGetDriverSetting( pDevObj, "NCPriority", pMem, cbSize, &dwNeeded, &dwCOptions ); 
		               if( strcmp( pMem, "P1" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Priority 1\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
		               if( strcmp( pMem, "P2" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Priority 2\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P3" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Priority 3\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P4" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Priority 4\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P5" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Priority 5\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P6" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Priority 6\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P7" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Priority 7\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P8" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Priority 8\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P9" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Priority 9\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					   if( strcmp( pMem, "P10" ) == 0 )
					   {
						   StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, "    /Priority 10\r\n");
						   if( pProcs->DrvWriteSpoolBuf != NULL )
							   pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 
					   }
					}

					StringCbCopyA(pMem, NEC_DOCNAME_BUF_LEN, 
						"  >>\r\n  spoolgetjobid dup == flush\r\n  spooljobsubmit\r\n } stopped {end clear} if\r\n} exec\r\n");
					if( pProcs->DrvWriteSpoolBuf != NULL )
						pProcs->DrvWriteSpoolBuf( pDevObj, pMem, strlen(pMem) ); 

			   }
            }

            dwRv = ERROR_SUCCESS;
            EngFreeMem( pMem );
         }
		 break;















   }
   return( dwRv );
}


//
// OEMStartDoc
//

extern "C"
BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;
    HANDLE      hPrinter;




	DWORD dwCbRet;
	JOB_INFO_1 *pJob;
	DWORD cbNeeded;


    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;


	//
	// Add DocName copy command here ( copy from pwszDocName to poempdev->szDocName )
	// 

	if((NULL != pwszDocName) && (NULL != poempdev->szDocName))
	{
#ifdef USERMODE_DRIVER
		WideCharToMultiByte(CP_THREAD_ACP,
							WC_NO_BEST_FIT_CHARS,
							pwszDocName,
							wcslen(pwszDocName) * 2 + 2,
							poempdev->szDocName,
							NEC_DOCNAME_BUF_LEN,
							NULL,
							NULL);
		//
		// W2K/Whistler's user mode driver does not pass the correct job name in pwszDocName
		// in case that the printer is connected to network port.
		// So, I need to get the job name from JOB_INFO_1 structure.
		//
		if (OpenPrinter(poempdev->pPrinterName, &hPrinter, NULL) != 0) {
			GetJob(hPrinter, dwJobId, 1, NULL, 0, &cbNeeded);
			pJob = (JOB_INFO_1 *)EngAllocMem(FL_ZERO_MEMORY, cbNeeded, OEM_SIGNATURE);
			if (NULL != pJob) {
			 	if (GetJob(hPrinter, dwJobId, 1, (LPBYTE)pJob, cbNeeded, &cbNeeded) != 0) {

					WideCharToMultiByte(CP_THREAD_ACP,
										WC_NO_BEST_FIT_CHARS,
										pJob->pDocument,
										wcslen(pJob->pDocument) * 2 + 2,
										poempdev->szDocName,
										NEC_DOCNAME_BUF_LEN,
										NULL,
										NULL);
				}
				EngFreeMem(pJob);
			}
			ClosePrinter(hPrinter);
		}

#else // !USERMODE_DRIVER

		EngUnicodeToMultiByteN( poempdev->szDocName, NEC_DOCNAME_BUF_LEN, &dwCbRet,
                                   pwszDocName,
//                                 NEC_DOCNAME_BUF_LEN * sizeof( WCHAR ) );
                                   wcslen(pwszDocName) * 2 + 2);
#endif // USERMODE_DRIVER
	}
	

	//
    // turn around to call PS
    //


    return (((PFN_DrvStartDoc)(poempdev->pfnPS[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));
}

//
// OEMEndDoc
//

extern "C"
BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;



    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    
	return (((PFN_DrvEndDoc)(poempdev->pfnPS[UD_DrvEndDoc])) (
            pso,
            fl));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsres\exports.cpp ===
/*=============================================================================
 * FILENAME: exports.cpp
 * Copyright (C) 1996-1998 HDE, Inc.  All Rights Reserved. HDE Confidential.
 * Copyright (C) 1999 NEC Technologies, Inc. All Rights Reserved.
 *
 * DESCRIPTION: Contains exported functions required to get an OEM plug-in 
 *              to work.
 * NOTES:  
 *=============================================================================
 */

#include "precomp.h"

#include <windows.h>
#include <WINDDI.H>
#include <PRINTOEM.H>


#include <strsafe.h>

#include "nc46nt.h"

#include "oemps.h"


/*
	For OEMEnableDriver
*/

static const DRVFN OEMHookFuncs[] =
{
    { INDEX_DrvStartDoc,                    (PFN) OEMStartDoc                   },
    { INDEX_DrvEndDoc,                      (PFN) OEMEndDoc                     },
};



/******************************************************************************
 * DESCRIPTION: Called by the postscript driver after the dll is loaded 
 *              to get plug-in information
 *  
 *****************************************************************************/
extern "C" BOOL APIENTRY
OEMGetInfo( DWORD  dwMode,
            PVOID  pBuffer,
            DWORD  cbSize,
            PDWORD pcbNeeded )
{
   // Validate parameters.
   if( NULL == pcbNeeded )
   {
      EngSetLastError(ERROR_INVALID_PARAMETER);
      return FALSE;
   }

   // Set expected buffer size and number of bytes written.
   *pcbNeeded = sizeof(DWORD);

   // Check buffer size is sufficient.
   if((cbSize < *pcbNeeded) || (NULL == pBuffer))
   {
      EngSetLastError(ERROR_INSUFFICIENT_BUFFER);
      return FALSE;
   }

   switch(dwMode)
   {
      case OEMGI_GETSIGNATURE:     // OEM DLL Signature
         *(PDWORD)pBuffer = OEM_SIGNATURE;
         break;
      case OEMGI_GETVERSION:       // OEM DLL version
         *(PDWORD)pBuffer = OEM_VERSION;
         break;
      case OEMGI_GETINTERFACEVERSION: // version the Printer driver supports
         *(PDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
         break;
      case OEMGI_GETPUBLISHERINFO: // fill PUBLISHERINFO structure
      // fall through to not supported
      default: // dwMode not supported.
         // Set written bytes to zero since nothing was written.
         *pcbNeeded = 0;
         EngSetLastError(ERROR_NOT_SUPPORTED);
         return FALSE;
    }
    return TRUE;
}

/******************************************************************************
 * DESCRIPTION:  Exported function that allows setting of private and public
 *               devmode fields.
 * NOTE: This function must be in entered under EXPORTS in rntapsui.def to be called
 *****************************************************************************/
extern "C" BOOL APIENTRY
OEMDevMode( DWORD dwMode, POEMDMPARAM pOemDMParam )
{
POEMDEV pOEMDevIn;
POEMDEV pOEMDevOut;

   switch(dwMode) // kernel mode rendering dll
   {
      case OEMDM_SIZE: // size of oem devmode
         if( pOemDMParam )
            pOemDMParam->cbBufSize = sizeof( OEMDEV );
         break;

      case OEMDM_DEFAULT: // fill oem devmode with default data
         if( pOemDMParam && pOemDMParam->pOEMDMOut )
         {
            pOEMDevOut = (POEMDEV)pOemDMParam->pOEMDMOut;
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
         }
         break;
         
      case OEMDM_MERGE:  // set the public devmode fields
      case OEMDM_CONVERT:  // convert any old oem devmode to new version
         if( pOemDMParam && pOemDMParam->pOEMDMOut && pOemDMParam->pOEMDMIn )
         {
            pOEMDevIn  = (POEMDEV)pOemDMParam->pOEMDMIn;
            pOEMDevOut = (POEMDEV)pOemDMParam->pOEMDMOut;
            if( pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature )
            {
			  // wcscpy( pOEMDevOut->szUserName, pOEMDevIn->szUserName );
			  StringCbCopy( pOEMDevOut->szUserName, sizeof(pOEMDevOut->szUserName), pOEMDevIn->szUserName );
            }
         }
         break;
   }
   return( TRUE );
}

/******************************************************************************
 * DESCRIPTION: Windows dll required entry point function.
 *  
 *****************************************************************************/
extern "C"
BOOL WINAPI DllInitialize(ULONG ulReason)
{
	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_PROCESS_DETACH:
			break;

		case DLL_THREAD_DETACH:
			break;
	}

	return( TRUE );
}

extern "C"
VOID APIENTRY OEMDisableDriver()
{
    // DebugMsg(DLLTEXT("OEMDisableDriver() entry.\r\n"));
}

extern "C"
BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    // DebugMsg(DLLTEXT("OEMEnableDriver() entry.\r\n"));

    // List DDI functions that are hooked.
    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION;
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) OEMHookFuncs;

    return TRUE;
}


extern "C"
PDEVOEM APIENTRY OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;
    INT         i, j;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;






    //
    // Allocate the OEMDev
    //
    // poempdev = new OEMPDEV;
	poempdev = (POEMPDEV) EngAllocMem(FL_ZERO_MEMORY, sizeof(OEMPDEV), OEM_SIGNATURE);
    if (NULL == poempdev)
    {
        return NULL;
    }

	//
	// Allocate memory for poempdev->szDocName
	//
	poempdev->szDocName = (char *) EngAllocMem(FL_ZERO_MEMORY, NEC_DOCNAME_BUF_LEN+2, OEM_SIGNATURE);
	if (NULL == poempdev->szDocName)
	{
	    return NULL;
	}
	/* MMM */
	//
	// Allocate memory for poempdev->pPrinterName
	poempdev->pPrinterName = (PWSTR) EngAllocMem(FL_ZERO_MEMORY, (wcslen(pPrinterName)+1)*sizeof(WCHAR), OEM_SIGNATURE);
	if (NULL == poempdev->pPrinterName)
	{
	    return NULL;
	}
	/* MMM */

    //
    // Fill in OEMDEV as you need
    //

	// _tcscpy(poempdev->pPrinterName, pPrinterName);	/* MMM */
	StringCbCopy( poempdev->pPrinterName, sizeof(poempdev->pPrinterName), pPrinterName);

    //
    // Fill in OEMDEV
    //

    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        //
        // search through Unidrv's hooks and locate the function ptr
        //
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnPS[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            //
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            //
            poempdev->pfnPS[i] = NULL;
        }

    }

    return (POEMPDEV) poempdev;
}


extern "C"
VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj
    )
{
    // DebugMsg(DLLTEXT("OEMDisablePDEV() entry.\r\n"));
	POEMPDEV    poempdev = (POEMPDEV) pdevobj->pdevOEM;

    //
    // Free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    //


	
	if(NULL != poempdev->szDocName)
	{
		EngFreeMem(poempdev->szDocName);
		poempdev->szDocName = (char *)NULL;
	}
	/* MMM */
	if(NULL != poempdev->pPrinterName)
	{
		EngFreeMem(poempdev->pPrinterName);
		poempdev->pPrinterName = (PWSTR)NULL;
	}
	/* MMM */
    assert(NULL != pdevobj->pdevOEM);
    // delete pdevobj->pdevOEM;
	EngFreeMem(pdevobj->pdevOEM);
}


extern "C"
BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{


	POEMPDEV    poempdevOld = (POEMPDEV)pdevobjOld->pdevOEM;
	POEMPDEV    poempdevNew = (POEMPDEV)pdevobjNew->pdevOEM;






	if((NULL != poempdevNew->szDocName) && (NULL != poempdevOld->szDocName))
	{
		strncpy(poempdevNew->szDocName, poempdevOld->szDocName, NEC_DOCNAME_BUF_LEN);
	}



    //
    // If you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsres\kmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       KMode.h
//
//
//  PURPOSE:    Definitions and routines for compiling kernel mode instead of user mode.
//
//  PLATFORMS:
//    Windows NT
//
//

#ifndef _KMODE_H
#define _KMODE_H


// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif



#ifdef USERMODE_DRIVER

//
// User mode difinitions to get rid of defines for kernel mode.
//

// Don't need critical section in user mode.

#define DECLARE_CRITICAL_SECTION    ;
#define INIT_CRITICAL_SECTION()     NOP_FUNCTION
#define DELETE_CRITICAL_SECTION()   NOP_FUNCTION
#define IS_VALID_CRITICAL_SECTION() (TRUE)


#else // !USERMODE_DRIVER


////////////////////////////////////////////////////////
//      Kernel Mode Defines
////////////////////////////////////////////////////////

extern HSEMAPHORE ghOEMSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghOEMSemaphore = NULL;
#define INIT_CRITICAL_SECTION()     ghOEMSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghOEMSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghOEMSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghOEMSemaphore)
#define IS_VALID_CRITICAL_SECTION() (NULL != ghOEMSemaphore)
#define DebugBreak                  EngDebugBreak

// Pool tag marker for memory marking memory allocations.
#define DRV_MEM_POOL_TAG    'meoD'

// Debug prefix that is outputted in the debug messages.
#define DEBUG_PREFIX        "OEMDLL: "


// Remap user mode functions that don't have kernel mode
// equivalents to functions that we implement ourselves.

#define OutputDebugStringA(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%hs", pszMsg))
#define OutputDebugStringW(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%ls", pszMsg))

#if !defined(_M_ALPHA) && !defined(_M_IA64)
    #define InterlockedIncrement        DrvInterlockedIncrement
    #define InterlockedDecrement        DrvInterlockedDecrement
#endif


#define SetLastError                NOP_FUNCTION
#define GetLastError                NOP_FUNCTION



////////////////////////////////////////////////////////
//      Kernel Mode Functions
////////////////////////////////////////////////////////

//
// Implement inline functions to replace user mode 
// functions that don't have kernel mode equivalents.
//


inline int __cdecl _purecall (void)
{
#ifdef DEBUG
    EngDebugBreak();
#endif

    return E_FAIL;
}


inline LONG DrvInterlockedIncrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline LONG DrvInterlockedDecrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline void* __cdecl operator new(size_t nSize)
{
    // return pointer to allocated memory
    return  EngAllocMem(0, nSize, DRV_MEM_POOL_TAG);
}


inline void __cdecl operator delete(void *pMem)
{
    if(pMem)
        EngFreeMem(pMem);
}


inline VOID MyDebugPrint(PCHAR pszPrefix, PCHAR pszFormat, ...)
{
    va_list VAList;

    va_start(VAList, pszFormat);
    EngDebugPrint(DEBUG_PREFIX, pszFormat, VAList);
    va_end(VAList);

    return;
}



#endif // USERMODE_DRIVER


#endif // _KMODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsres\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows NT, Windows 2000
//
//
#ifndef _DEBUG_H
#define _DEBUG_H

#include "kmode.h"


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif

#define DLLTEXT(s)      __TEXT("OEMPS:  ") __TEXT(s)
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsres\nc46nt.h ===
/*=============================================================================
 * FILENAME: nc46ntui.h
 * Copyright (C) 1996-1998 HDE, Inc.  All Rights Reserved. HDE Confidential.
 * Copyright (C) 1999 NEC Technologies, Inc.  All Rights Reserved.
 *
 * DESCRIPTION: main header file for OEM User interface Dll.
 *  
 * NOTES:  
 *=============================================================================
*/


#ifndef NC46NT_H
#define NC46NT_H

// #define WINVER          0x0500
// #define _WIN32_WINNT    0x0500


// the signature and version of Adobe PostScript OEM dll
#define OEM_SIGNATURE   'NEC '
#define OEM_VERSION     0x00000001L

#define NEC_USERNAME_BUF_LEN 256
#define NEC_DOCNAME_BUF_LEN 256

// OEM devmode structure
typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    TCHAR               szUserName[NEC_USERNAME_BUF_LEN];
    // char                szDocName[NEC_DOCNAME_BUF_LEN];

}OEMDEV, *POEMDEV;

#endif // NC46NT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsres\oemps.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//  Copyright (C) 1999 NEC Technologies, Inc. All Rights Reserved.
//
//  FILE:	OEMPS.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEMPS_H
#define _OEMPS_H

//#include "OEM.H"
//#include "DEVMODE.H"

#define NEC_DOCNAME_BUF_LEN 256

////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

//#define DLLTEXT(s)      __TEXT("OEMPS:  ") __TEXT(s)
//#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


///////////////////////////////////////////////////////
// Warning: the following enum order must match the 
//          order in OEMHookFuncs[].
///////////////////////////////////////////////////////
typedef enum tag_Hooks {
    UD_DrvStartDoc,
    UD_DrvEndDoc,


    MAX_DDI_HOOKS,

} ENUMHOOKS;


typedef struct _OEMPDEV {
    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    // This test DLL hooks out every drawing DDI. So it needs to remember
    // PS's hook function pointer so it call back.
    //
    PFN     pfnPS[MAX_DDI_HOOKS];

    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    
	char	*szDocName;
	PWSTR	pPrinterName;	/* MMM */
	
	DWORD     dwReserved[1];

} OEMPDEV, *POEMPDEV;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsres\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.

#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
extern "C" 
{
    #include <WINDDI.H>
}
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRINTOEM.H>


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsres\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMPS.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUI.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDC_CALIBRATE                   1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsui\exports.cpp ===
/*=============================================================================
 * FILENAME: exports.cpp
 * Copyright (C) 1996-1998 HDE, Inc.  All Rights Reserved. HDE Confidential.
 *
 * DESCRIPTION: Contains exported functions required to get an OEM plug-in 
 *              to work.
 * NOTES:  
 *=============================================================================
*/

#include <windows.h>

#include <stdlib.h>
#include <WINDDIUI.H>
#include <PRINTOEM.H>

#include <strsafe.h>

#include "nc46nt.h"

HINSTANCE ghInstance;

/******************************************************************************
 * DESCRIPTION: Called by the postscript driver after the dll is loaded 
 *              to get plug-in information
 *  
 *****************************************************************************/
extern "C" BOOL APIENTRY
OEMGetInfo( DWORD  dwMode,
            PVOID  pBuffer,
            DWORD  cbSize,
            PDWORD pcbNeeded )
{
   // Validate parameters.
   if( NULL == pcbNeeded )
   {
      SetLastError(ERROR_INVALID_PARAMETER);
      return FALSE;
   }

   // Set expected buffer size and number of bytes written.
   *pcbNeeded = sizeof(DWORD);

   // Check buffer size is sufficient.
   if((cbSize < *pcbNeeded) || (NULL == pBuffer))
   {
      SetLastError(ERROR_INSUFFICIENT_BUFFER);
      return FALSE;
   }

   switch(dwMode)
   {
      case OEMGI_GETSIGNATURE:     // OEM DLL Signature
         *(PDWORD)pBuffer = OEM_SIGNATURE;
         break;
      case OEMGI_GETVERSION:       // OEM DLL version
         *(PDWORD)pBuffer = OEM_VERSION;
         break;
      case OEMGI_GETINTERFACEVERSION: // version the Printer driver supports
         *(PDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
         break;
      case OEMGI_GETPUBLISHERINFO: // fill PUBLISHERINFO structure
      // fall through to not supported
      default: // dwMode not supported.
         // Set written bytes to zero since nothing was written.
         *pcbNeeded = 0;
         SetLastError(ERROR_NOT_SUPPORTED);
         return FALSE;
    }
    return TRUE;
}

/******************************************************************************
 * DESCRIPTION:  Exported function that allows setting of private and public
 *               devmode fields.
 * NOTE: This function must be in entered under EXPORTS in rntapsui.def to be called
 *****************************************************************************/
extern "C" BOOL APIENTRY
OEMDevMode( DWORD dwMode, POEMDMPARAM pOemDMParam )
{
POEMDEV pOEMDevIn;
POEMDEV pOEMDevOut;

   switch(dwMode) // user mode dll
   {
      case OEMDM_SIZE: // size of oem devmode
         if( pOemDMParam )
            pOemDMParam->cbBufSize = sizeof( OEMDEV );
         break;

      case OEMDM_DEFAULT: // fill oem devmode with default data
         if( pOemDMParam && pOemDMParam->pOEMDMOut )
         {
            pOEMDevOut = (POEMDEV)pOemDMParam->pOEMDMOut;
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            // _tcscpy( pOEMDevOut->szUserName, TEXT("NO USER NAME") );
			StringCchCopy( pOEMDevOut->szUserName, NEC_USERNAME_BUF_LEN, TEXT("NO USER NAME") );
         }
         break;
      case OEMDM_MERGE:  // set the public devmode fields
      case OEMDM_CONVERT:  // convert any old oem devmode to new version
         if( pOemDMParam && pOemDMParam->pOEMDMOut && pOemDMParam->pOEMDMIn )
         {
            pOEMDevIn  = (POEMDEV)pOemDMParam->pOEMDMIn;
            pOEMDevOut = (POEMDEV)pOemDMParam->pOEMDMOut;
            if( pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature )
            {
            TCHAR szUserName[NEC_USERNAME_BUF_LEN+2];
            DWORD dwCb = NEC_USERNAME_BUF_LEN;
               if( GetUserName( szUserName, &dwCb ) )
				 StringCbCopy( pOEMDevOut->szUserName, sizeof(pOEMDevOut->szUserName), szUserName );
            }
         }
         break;

   }
   return( TRUE );
}

/******************************************************************************
 * DESCRIPTION: Windows dll required entry point function.
 *  
 *****************************************************************************/
extern "C" 
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
   switch(wReason)
   {
      case DLL_PROCESS_ATTACH:
         ghInstance = hInst;
         break;

      case DLL_THREAD_ATTACH:
         break;

      case DLL_PROCESS_DETACH:
         break;

      case DLL_THREAD_DETACH:
         ghInstance = NULL;
         break;
   }
   return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ncpsres\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.inc

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

SRCDIR=..

DLLBASE=0x70000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=$(SRCDIR)\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj


# To build version with debug output, add -D_DEBUG to C_DEFINES line below
#C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DOEMCOM -D_DEBUG -DDEBUG
C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DOEMCOM



TARGETLIBS=  $(SDK_LIB_PATH)\uuid.lib


INCLUDES=$(SDK_INC_PATH)\mfc42;$(SRCDIR)

SOURCES= $(SRCDIR)\exports.cpp \
         $(SRCDIR)\command.cpp \
         $(SRCDIR)\debug.cpp   \
         $(SRCDIR)\ncpsres.rc

MISCFILES=\
          $(SRCDIR)\icm\NC465006.icm \
          $(SRCDIR)\icm\NC465012.icm \
          $(SRCDIR)\icm\NC46NX06.icm \
          $(SRCDIR)\icm\NC46NX12.icm \
          $(SRCDIR)\icm\NC46N_06.icm \
          $(SRCDIR)\icm\NC46N_12.icm \
          $(SRCDIR)\icm\Ncss4206.icm \
          $(SRCDIR)\icm\Ncss4212.icm \
          $(SRCDIR)\icm\Ncss4406.icm \
          $(SRCDIR)\icm\Ncss4412.icm \
          $(SRCDIR)\icm\ncss4606.icm \
          $(SRCDIR)\icm\ncss4612.icm \
          $(SRCDIR)\ncpsres.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\okepjres\etc\okiescms.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------


char *rgchModuleName = "okiescms";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\oki9res\fliptab.h ===
0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\oki9res\code.c ===
/********************** Module Header **************************************
 * code.c
 *	Code required for OKI 9 pin printers.  The bit order needs
 *	swapping,  and any ETX char needs to be sent twice.
 *
 * HISTORY:
 *  15:26 on Fri 10 Jan 1992	-by-	Lindsay Harris   [lindsayh]
 *	Created it.
 * 
 *  Ported to NT5 on  Weds 29 Oct 1997 -by- Philip Lee [philipl]
 *
 *  Copyright (C) 1999  Microsoft Corporation.
 *
 **************************************************************************/

char *rgchModuleName = "OKI9RES";


/*
 *   This printer requires sending the ETX character (0x03) twice to send
 * just one - so we define the following to select that byte.
 */

#define	RPT_CHAR	0x03

#define	SZ_LBUF	128	/* Size of local copying buffer */

/*
 *   The bit flipping table is common to several drivers,  so it is
 *  included here.  It's definition is as a static.
 */

static const BYTE  FlipTable[ 256 ] =
{

#include	"fliptab.h"

};

#define _GET_FUNC_ADDR         1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\oki9res\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };


    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\oki9res\pdev.h ===
/*++

Copyright (C) 1997 - 1999 Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>

//
// Debug text.
//
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)
#define TESTSTRING      "Callback for Declasers."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'OKI9'      // LG GDI x00 series dll
#define DLLTEXT(s)      __TEXT("OKI9RES:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L

//
// Warning: the following enum order must match the order in OEMHookFuncs[].
//

//
// Memory allocation
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }

#ifdef DBG
#define DebugMsg
#else
#define DebugMsg
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\oki9res\name.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    name.h

Abstract:

    Interface Function name strings for PublishInterface

--*/
CONST CHAR pstrGetInfo[]                = "GetInfo";
CONST CHAR pstrFilterGraphics[]         = "FilterGraphics";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\oki9res\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    comoem.cpp

Abstract:

    Windows NT Universal Printer Driver OEM Plug-in Sample

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


#include "pdev.h"
#include "name.h"
#include <initguid.h>
#include <prcomoem.h>
#include <assert.h>
#include "comoem.h"


///////////////////////////////////////////////////////////
//
// Globals
//

static HANDLE ghInstance = NULL ;
static long g_cComponents = 0 ;
static long g_cServerLocks = 0 ;

///////////////////////////////////////////////////////////

#include "code.c"

//
// Export functions
//

BOOL APIENTRY
DllMain(
    HANDLE hInst,
    DWORD dwReason,
    void* lpReserved)
/*++

Routine Description:

    Dll entry point for initializatoin.

Arguments:

    hInst      - Dll instance handle
    wReason    - The reason DllMain was called.
                 Initialization or termination, for a process or a thread.
    lpreserved - Reserved for the system's use

Return Value:

    TRUE if successful, FALSE if there is an error

Note:


--*/
{

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Process attach.\r\n"));

            //
            // Save DLL instance for use later.
            //
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Thread attach.\r\n"));
            break;

        case DLL_PROCESS_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Process detach.\r\n"));
            break;

        case DLL_THREAD_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Thread detach.\r\n"));
            break;
    }

    return TRUE;
}


STDAPI
DllCanUnloadNow()
/*++

Routine Description:

    Function to return the status that this dll can be unloaded.

Arguments:


Return Value:

    S_OK if it's ok to unload it, S_FALSE if it is used.

Note:


--*/
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

STDAPI
DllGetClassObject(
    const CLSID& clsid,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Function to return class factory object

Arguments:

    clsid - CLSID for the class object
    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:

--*/
{
    DebugMsg(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    //
    // Can we create this component?
    //
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    //
    // Create class factory.
    //
    IOemCF* pClassFactory = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pClassFactory == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get requested interface.
    //
    HRESULT hr = pClassFactory->QueryInterface(iid, ppv) ;
    pClassFactory->Release() ;

    return hr ;
}


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack (IPrintOemUNI) body
//

STDMETHODIMP
IOemCB::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IUnknow QueryInterface

Arguments:

    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB: QueryInterface entry\n"));

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ;
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ;
    }
    else
    {
        *ppv = NULL ;
        DebugMsg(DLLTEXT("IOemCB:Return NULL.\n")) ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
IOemCB::AddRef()
/*++

Routine Description:

    IUnknow AddRef interface

Arguments:

    Increment a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCB::Release()
/*++

Routine Description:

    IUnknown Release interface

Arguments:

    Decrement a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCB::EnableDriver(
    DWORD          dwDriverVersion,
    DWORD          cbSize,
    PDRVENABLEDATA pded)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisableDriver(VOID)
/*++

Routine Description:

    IPrintOemUni DisableDriver interface
    Free all resources, and get prepared to be unloaded.

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
/*++

Routine Description:

    IPrintOemUni PublishDriverInterface interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

// Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
    return S_OK;
}

STDMETHODIMP
IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
/*++

Routine Description:

    IPrintOemUni EnablePDEV interface
    Construct its own PDEV. At this time, the driver also passes a function
    table which contains its own implementation of DDI entrypoints

Arguments:

    pdevobj        - pointer to a DEVOBJ structure. pdevobj->pdevOEM is undefined.
    pPrinterName   - name of the current printer.
    Cpatterns      -
    phsurfPatterns -
    cjGdiInfo      - size of GDIINFO
    pGdiInfo       - a pointer to GDIINFO
    cjDevInfo      - size of DEVINFO
    pDevInfo       - These parameters are identical to what39s passed into DrvEnablePDEV.
    pded: points to a function table which contains the system driver39s
    implementation of DDI entrypoints.


Return Value:


--*/
{


    DebugMsg(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
/*++

Routine Description:

    IPrintOemUni ResetPDEV interface
    OEMResetPDEV transfers the state of the driver from the old PDEVOBJ to the
    new PDEVOBJ when an application calls ResetDC.

Arguments:

pdevobjOld - pdevobj containing Old PDEV
pdevobjNew - pdevobj containing New PDEV

Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ResetPDEV entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
/*++

Routine Description:

    IPrintOemUni DisablePDEV interface
    Free resources allocated for the PDEV.

Arguments:

    pdevobj -

Return Value:


Note:


--*/
{

    DebugMsg(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    return E_NOTIMPL;
};

STDMETHODIMP
IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni GetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    DebugMsg(DLLTEXT("IOemCB::GetInfo(%s) entry.\r\n"), OEM_INFO[dwMode]);

    //
    // Validate parameters.
    //
    if( ( (OEMGI_GETSIGNATURE != dwMode) &&
          (OEMGI_GETINTERFACEVERSION != dwMode) &&
          (OEMGI_GETVERSION != dwMode) ) ||
        (NULL == pcbNeeded)
      )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        //
        // Did not write any bytes.
        //
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return E_FAIL;
    }

    //
    // Need/wrote 4 bytes.
    //
    *pcbNeeded = 4;

    //
    // Validate buffer size.  Minimum size is four bytes.
    //
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return E_FAIL;
    }

    //
    // Write information to buffer.
    //
    switch(dwMode)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return S_OK;
}


STDMETHODIMP
IOemCB::GetImplementedMethod(
    PSTR pMethodName)
/*++

Routine Description:

    IPrintOemUni GetImplementedMethod interface

Arguments:


Return Value:


Note:


--*/
{

    LONG lReturn;
    DebugMsg(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    DebugMsg(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName != NULL)
    {
        switch (*pMethodName)
        {

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        DebugMsg(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        DebugMsg(__TEXT("NOT supported\r\n"));
        return E_FAIL;
    }
}

STDMETHODIMP
IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam)
/*++

Routine Description:

    IPrintOemUni DevMode interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni CommandCallback interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    DebugMsg(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    DebugMsg(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
/*++

Routine Description:

    IPrintOemUni ImageProcessing interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    return E_NOTIMPL;
}

/********************** Module Header **************************************
 * code.c
 *	Code required for OKI 9 pin printers.  The bit order needs
 *	swapping,  and any ETX char needs to be sent twice.
 *
 * HISTORY:
 *  15:26 on Fri 10 Jan 1992	-by-	Lindsay Harris   [lindsayh]
 *	Created it.
 *
 *  Ported to NT5 on  Weds 29 Oct 1997 -by- Philip Lee [philipl]
 *
 *  Copyright (C) 1999  Microsoft Corporation.
 *
 **************************************************************************/

STDMETHODIMP
IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
/*++

Routine Description:

    IPrintOemUni FilterGraphics interface

Arguments:


Return Value:


Note:


--*/

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    citohres.c

Abstract:

    Implementation of OEMFilterGraphics callback


Environment:

    Windows NT Unidrv driver

Revision History:

    10/09/97 -patryan-
        Port code to NT5.0

--*/

{
	
    /*
     *    Easy to do - translate the input using FlipTable,  then call the
     *  RasDD function WriteSpoolBuf.  Also must follow any \003 with
     *  another one.
     */

    DWORD dwResult, dwBufLen;

    register int    iLoop;		/* Inner loop counter */
    register BYTE  *pbOut;		/* Destination address */
    int    iLeft;			/* Outer loop counter */
    BYTE   bLocal[ SZ_LBUF ];		/* For local manipulations */
    HRESULT hr;

    DebugMsg(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    iLeft = dwLen;

    while( iLeft > 0 )
    {

	    iLoop = iLeft > (SZ_LBUF / 2) ? SZ_LBUF / 2 : iLeft;
	    iLeft -= iLoop;
	    pbOut = bLocal;

	    while( --iLoop >= 0 )
	    {

	        if( (*pbOut++ = FlipTable[ *pBuf++ ]) == RPT_CHAR )
		    *pbOut++ = RPT_CHAR;
	    }
        dwBufLen = (DWORD)(pbOut - bLocal);

        hr = pOEMHelp->DrvWriteSpoolBuf( pdevobj, bLocal, dwBufLen,  &dwResult );

        if ( !SUCCEEDED(hr) || (dwResult != dwBufLen) )
            return E_FAIL;

    }
    return S_OK;
}


STDMETHODIMP
IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni Compression interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
/*++

Routine Description:

    IPrintOemUni HalftonePattern interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,
    POEMMEMORYUSAGE pMemoryUsage)
/*++

Routine Description:

    IPrintOemUni MemoryUsage interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadFontHeader interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadCharGlyph interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni TTDownloadMethod interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
/*++

Routine Description:

    IPrintOemUni OutputCharStr interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
/*++

Routine Description:

    IPrintOemUni SendFontCmd interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni DriverDMS interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
/*++

Routine Description:

    IPrintOemUni TextOutAsBitmap interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
/*++

Routine Description:

    IPrintOemUni TTYGetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Interface Oem Class factory body
//
STDMETHODIMP
IOemCF::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Class Factory QueryInterface interface

Arguments:


Return Value:


Note:


--*/
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
    IOemCF::AddRef()
/*++

Routine Description:

    IPrintOemUni AddRef interface

Arguments:


Return Value:


Note:


--*/
{
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCF::Release()
/*++

Routine Description:

    IPrintOemUni Release interface

Arguments:


Return Value:


Note:


--*/
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCF::CreateInstance(
    IUnknown* pUnknownOuter,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IPrintOemUni CreateInstance interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("Class factory:\t\tCreate component.")) ;

    //
    // Cannot aggregate.
    //
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    //
    // Create component.
    //
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get the requested interface.
    //
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    //
    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    //
    pOemCB->Release() ;
    return hr ;
}

STDMETHODIMP
IOemCF::LockServer(
    BOOL bLock)
/*++

Routine Description:

    Class Factory LockServer interface

Arguments:


Return Value:


Note:


--*/
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

IOemCB::~IOemCB()
{
    // Make sure that driver's helper function interface is released.
    if(NULL != pOEMHelp)
    {
        pOEMHelp->Release();
        pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference
    // count should be zero.
    assert(0 == m_cRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pa24tres\etc\pansn24c.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
char *rgchModuleName = "PANSN24C";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\oki9res\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns E_FAIL if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB();

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Use strsafe.h(pdev.h)
#include "pdev.h"

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:
// NOTICE-2002/03/19-v-sueyas-
//    04/07/97 -zhanw-
//        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

extern BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
extern BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n")));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEM_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING, ("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}



//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//  // NOTICE-2002/03/19-v-sueyas-
//  //            02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING, ("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DBGPRINT(DBG_WARNING, ("\tcbSize = %d.\r\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING, ("\thPrinter = %#lx.\r\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING, ("\thModule = %#lx.\r\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING, ("\tpPublicDMIn = %#lx.\r\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING, ("\tpPublicDMOut = %#lx.\r\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING, ("\tpOEMDMIn = %#lx.\r\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING, ("\tpOEMDMOut = %#lx.\r\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING, ("\tcbBufSize = %d.\r\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\compress.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/




#define RL4_MAXISIZE  0xFFFE
#define RL4_MAXHEIGHT 0xFFFE
#define RL4_MAXWIDTH  4096
#define VALID     0x00
#define INVALID   0x01

typedef struct tag_COMP_DATA {
	PBYTE	RL_ImagePtr;
	PBYTE	RL_CodePtr;
	PBYTE	RL_BufEnd;
	DWORD	RL_ImageSize;
	DWORD	RL_CodeSize;
	BYTE	BUF_OVERFLOW;
} COMP_DATA, *PCOMP_DATA;

// #291170: Image data is not printed partly
DWORD RL_ECmd(PBYTE, PBYTE, DWORD, DWORD);
BYTE RL_Init(PBYTE, PBYTE, DWORD, DWORD, PCOMP_DATA);
char RL_Enc( PCOMP_DATA );

#define RL4_BLACK     0x00
#define RL4_WHITE     0x01
#define RL4_BYTE      0x00
#define RL4_NONBYTE   0x01
#define RL4_CLEAN     0x00
#define RL4_DIRTY     0x01
#define RL4_FIRST     0x00
#define RL4_SECOND    0x01

#define COMP_FAIL     0x00
#define COMP_SUCC     0x01

#define CODBUFSZ      0x7FED     /* NOTE : THIS SHOULD MATCH THE SPACE GIVEN */
                                 /*        TO COMPRESSED DATA BY THE DEVICE  */
                                 /*        DRIVER. CHANGE THIS BASED ON YOUR */
                                 /*        OWN DISCRETION.   C.Chi           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\pagesres.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:
// NOTICE-2002/03/19-v-sueyas-
//    04/07/97 -zhanw-
//        Created it.

--*/

#include <windows.h>
#include "pdev.h"
#include "compress.h"

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//	// NOTICE-2002/03/19-v-sueyas-
//  //            02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->fCallback = FALSE;
    pOEMExtra->wCurrentRes = 0;
    pOEMExtra->lWidthBytes = 0;
    pOEMExtra->lHeightPixels = 0;

#ifdef FONTPOS
    pOEMExtra->wFontHeight = 0;
    pOEMExtra->wYPos = 0;
#endif
// #278517: RectFill
    pOEMExtra->wRectWidth = 0;
    pOEMExtra->wRectHeight = 0;
    pOEMExtra->wUnit = 1;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//  //NOTICE-2002/03/19-v-sueyas-
//  //History:
//  //        02/11/97        APresley Created.
//  //        04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->fCallback = pdmIn->fCallback;

        pdmOut->wCurrentRes = pdmIn->wCurrentRes;
        pdmOut->lWidthBytes = pdmIn->lWidthBytes;
        pdmOut->lHeightPixels = pdmIn->lHeightPixels;

#ifdef FONTPOS
        pdmOut->wFontHeight = pdmIn->wFontHeight;
        pdmOut->wYPos = pdmIn->wYPos;
#endif
// #278517: RectFill
        pdmOut->wRectWidth = pdmIn->wRectWidth;
        pdmOut->wRectHeight = pdmIn->wRectHeight;
        pdmOut->wUnit = pdmIn->wUnit;

    }
    return TRUE;
}

// #######

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

/*********************************************************/
/*  RL_ECmd  : main function                             */
/*  ARGS     : LPBYTE - pointer to image                 */
/*             LPBYTE - pointer to BRL code              */
/*             WORD   - size of image                    */
/*  RET      : WORD   - size of BRL Code                 */
/*             0      - COMPRESSION FAILED               */
/*********************************************************/
DWORD RL_ECmd(PBYTE iptr, PBYTE cptr, DWORD isize, DWORD osize)
{
    COMP_DATA   CompData;
    
    if (VALID == RL_Init(iptr, cptr, isize, osize, &CompData))
        RL_Enc( &CompData );

    if (CompData.BUF_OVERFLOW)
        return 0;
    else
        return CompData.RL_CodeSize;
}

/*********************************************************/
/*  RL_Init  : Initializer                               */
/*  ARGS     : BYTE * - pointer to image                 */
/*             BYTE * - pointer to BRL code              */
/*             WORD   - size of image                    */
/*  RET      : BYTE   - VALID or INVALID                 */
/*********************************************************/

BYTE RL_Init(PBYTE iptr, PBYTE cptr, DWORD isize, DWORD osize,
    PCOMP_DATA pCompData)
{
    pCompData->RL_ImagePtr  = iptr;
    pCompData->RL_CodePtr   = cptr;
    pCompData->RL_ImageSize = isize;
    pCompData->BUF_OVERFLOW = 0;
    pCompData->RL_BufEnd    = cptr + osize;

    return VALID;
}

/*********************************************************/
/*  RL_Enc   : Encoder                                   */
/*  ARGS     : void                                      */
/*  RET      : char   COMP_SUCC or COMP_FAIL             */
/*********************************************************/
char RL_Enc(PCOMP_DATA pCompData)
{
// #313252: RLE compressed data doesn't match with length.
// Rewrite RLE compression algorithm.

    int     count;
    BYTE    rdata;
    PBYTE   pdata, pcomp, pend;
    DWORD   i;

    pdata = pCompData->RL_ImagePtr;
    pcomp = pCompData->RL_CodePtr;
    pend = pCompData->RL_BufEnd;
    count = 0;

    for (i = 0; i < pCompData->RL_ImageSize; i++, pdata++) {
        if (count == 0) {
            rdata = *pdata;
            count = 1;
        } else if (*pdata != rdata) {
            if (pcomp + 2 >= pend)
                goto overflow;
            *pcomp++ = count - 1;
            *pcomp++ = rdata;
            rdata = *pdata;
            count = 1;
        } else if (++count >= 256) {
            if (pcomp + 2 >= pend)
                goto overflow;
            *pcomp++ = count - 1;
            *pcomp++ = rdata;
            count = 0;
        }
    }
    if (count) {
        if (pcomp + 2 >= pend)
            goto overflow;
        *pcomp++ = count - 1;
        *pcomp++ = rdata;
    }

    pCompData->RL_CodeSize = (DWORD)(pcomp - pCompData->RL_CodePtr);
    pCompData->RL_CodePtr = pcomp;

    return COMP_SUCC;

overflow:
    pCompData->BUF_OVERFLOW = 1; 
    return COMP_FAIL;
}


//---------------------------*OEMSendFontCmd*----------------------------------
// Action:  send Pages-style font selection command.
//-----------------------------------------------------------------------------
// NTRAID#NTBUG9-581704-2002/03/19-v-sueyas-: Error handling
BOOL APIENTRY bOEMSendFontCmd(pdevobj, pUFObj, pFInv)
PDEVOBJ      pdevobj;
PUNIFONTOBJ  pUFObj;
PFINVOCATION pFInv;
{
    DWORD               i, ocmd;
    BYTE                rgcmd[CCHMAXCMDLEN];
    PGETINFO_STDVAR     pSV;

//#287800 ->
    DWORD               dwStdVariable[2 + 2 * 3];
    DWORD   dwTxtRes ;
//#287800 <-

//#319705 
    WORD wAscend, wDescend ;

    POEM_EXTRADATA      pOEM;

    VERBOSE(("OEMSendFontCmd entry.\n"));

	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("bOEMSendFontCmd: Invalid parameter(s).\n"));
        return FALSE;
    }

    pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);

	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for null pointers
    if (NULL == pOEM)
    {
        ERR(("bOEMSendFontCmd: pdevobj->pOEMDM = 0.\n"));
        return FALSE;
    }

    ASSERT(VALID_PDEVOBJ(pdevobj));

    if(!pUFObj || !pFInv)
    {
        ERR(("OEMSendFontCmd: pUFObj or pFInv is NULL."));
        return FALSE;
    }

//#287800 ->
    pSV = (PGETINFO_STDVAR)dwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (3 - 1);
    pSV->dwNumOfVariable = 3;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
//#287800 <-

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, NULL)) 
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return FALSE;
    }

#ifdef FONTPOS
    pOEM->wFontHeight = (WORD)pSV->StdVar[0].lStdVariable;

//#287800 ->
    dwTxtRes = pSV->StdVar[2].lStdVariable ;

	// NTRAID#NTBUG9-581703-2002/03/19-v-sueyas-: Check for deviding by zero
	if (0 == dwTxtRes)
	{
        ERR(("dwTxtRes = 0.\n"));
		return FALSE;
	}

    pOEM->wFontHeight = (WORD)((pOEM->wFontHeight * pOEM->wCurrentRes
                                 + dwTxtRes / 2) / dwTxtRes) ;
//#287800 <-

//#319705 For TTFS positioning ->

	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for null pointers
	if (NULL == pUFObj->pIFIMetrics)
	{
        ERR(("pUFObj->pIFIMetrics = NULL.\n"));
		return FALSE;
	}
    wAscend = pUFObj->pIFIMetrics->fwdWinAscender ;
    wDescend = pUFObj->pIFIMetrics->fwdWinDescender ;

	// NTRAID#NTBUG9-581703-2002/03/19-v-sueyas-: Check for deviding by zero
	if (0 == (wAscend + wDescend))
	{
        ERR(("pUFObj->pIFIMetrics = NULL.\n"));
		return FALSE;
	}
    wDescend = pOEM->wFontHeight * wDescend / (wAscend + wDescend) ;
    pOEM->wFontHeight -= wDescend ;

#endif

#define SV_HEIGHT   (pSV->StdVar[0].lStdVariable)
#define SV_WIDTH    (pSV->StdVar[1].lStdVariable)

    ocmd = 0;
    for (i = 0; i < pFInv->dwCount && ocmd < CCHMAXCMDLEN; )
    {
        WORD wTemp;

        if (pFInv->pubCommand[i] == '#')
        {
            if (pFInv->pubCommand[i+1] == 'V')
            {
                // character height setting
                wTemp = (WORD)SV_HEIGHT;
    
                if (pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                    wTemp = wTemp * 1440 / 600;
    
                rgcmd[ocmd++] = HIBYTE(wTemp);
                rgcmd[ocmd++] = LOBYTE(wTemp);
                i += 2;
            }
            else if (pFInv->pubCommand[i+1] == 'H')
            {
                // (DBCS) character width setting
                wTemp = (WORD)(SV_WIDTH * 2);
    
                if (pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                    wTemp = wTemp * 1440 / 600;
    
                rgcmd[ocmd++] = HIBYTE(wTemp);
                rgcmd[ocmd++] = LOBYTE(wTemp);
                i += 2;
            }
            else if (pFInv->pubCommand[i+1] == 'P')
            {
                // (DBCS) character pitch setting
                wTemp = (WORD)(SV_WIDTH * 2);
    
                if (pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                    wTemp = wTemp * 1440 / 600;
    
                rgcmd[ocmd++] = HIBYTE(wTemp);
                rgcmd[ocmd++] = LOBYTE(wTemp);
                i += 2;
            }
            else if (pFInv->pubCommand[i+1] == 'L')
            {
                // Line pitch (spacing) setting
                wTemp = (WORD)SV_HEIGHT;
    
                if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                    wTemp = wTemp * 1440 / 600;
    
                rgcmd[ocmd++] = HIBYTE(wTemp);
                rgcmd[ocmd++] = LOBYTE(wTemp);
                i += 2;
            }
            else {
                rgcmd[ocmd++] = pFInv->pubCommand[i++];
            }

            continue;
        }

        // just copy others
        rgcmd[ocmd++] = pFInv->pubCommand[i++];
    }

    WRITESPOOLBUF(pdevobj, rgcmd, ocmd);
    return TRUE;
}

// NTRAID#NTBUG9-581704-2002/03/19-v-sueyas-: Error handling
BOOL APIENTRY bOEMOutputCharStr( 
PDEVOBJ     pdevobj,
PUNIFONTOBJ pUFObj,
DWORD       dwType,
DWORD       dwCount,
PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PBYTE               tempBuf;
    PTRANSDATA          pTrans;
    DWORD               i, j;
    DWORD               rSize = 0;
    BOOL                fLeadByteFlag;
    BYTE                fDBCS[256];
    BYTE                ESC_VERT_ON[]  = "\x1B\x7E\x0E\x00\x01\x0B";
    BYTE                ESC_VERT_OFF[] = "\x1B\x7E\x0E\x00\x01\x0C";

#ifdef FONTPOS
    POEM_EXTRADATA      pOEM;
    BYTE                ESC_Y_ABS[] = "\x1b\x7e\x1d\x00\x03\x05\x00\x00";
#endif

    BOOL bVFont, bDBChar;
    BYTE *pTemp;
    WORD wLen;

    VERBOSE(("OEMOutputCharStr() entry.\n"));

	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for illegal parameters
    if(NULL == pdevobj || NULL == pUFObj)
    {
        ERR(("bOEMOutputCharStr: Invalid parameter(s).\n"));
        return FALSE;
    }

#ifdef FONTPOS
    pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);
#endif

	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for null pointers
    if(NULL == pOEM)
    {
        ERR(("bOEMOutputCharStr: pdevobj->pOEMDM = 0.\n"));
        return FALSE;
    }

    ASSERT(VALID_PDEVOBJ(pdevobj));

// NTRAID#NTBUG9-751233-2002/12/05-yasuho-: Memory leak in pagesres.dll
// Delete the redundant memory allocation.

    GStr.dwSize     = sizeof(GETINFO_GLYPHSTRING);
    GStr.dwCount    = dwCount;
    GStr.dwTypeIn   = TYPE_GLYPHHANDLE;
    GStr.pGlyphIn   = pGlyph;
    GStr.dwTypeOut  = TYPE_TRANSDATA;
    GStr.pGlyphOut  = NULL;
    GStr.dwGlyphOutSize = 0;

     /* Get TRANSDATA buffer size */
    if (FALSE != pUFObj->pfnGetInfo(pUFObj,
            UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)
        || 0 == GStr.dwGlyphOutSize )
    {
        ERR(("Get Glyph String error\n"));
        return FALSE;
    }

    /* Alloc TRANSDATA buffer */
    if(!(tempBuf = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize) ))
    {
        ERR(("Mem alloc failed.\n"));
        return FALSE;
    }

    /* Get actual TRANSDATA */
    GStr.pGlyphOut = tempBuf;
    if (!pUFObj->pfnGetInfo(pUFObj,
            UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
    {
        ERR(("GetInfo failed.\n"));
// NTRAID#NTBUG9-751233-2002/12/05-yasuho-: Memory leak in pagesres.dll
        MemFree(tempBuf);
    }

    pTrans = (PTRANSDATA)GStr.pGlyphOut;

#ifdef FONTPOS
    if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600 )
        ESC_Y_ABS[5] = 0x25;

    // ntbug9#406475: Font printed the different position.
    if((pOEM->wYPos - pOEM->wFontHeight) >= 0)
    {
        ESC_Y_ABS[6] = HIBYTE((pOEM->wYPos - pOEM->wFontHeight));
        ESC_Y_ABS[7] = LOBYTE((pOEM->wYPos - pOEM->wFontHeight));
        WRITESPOOLBUF(pdevobj, ESC_Y_ABS, 8);
    }
#endif  //FONTPOS

    bVFont = BVERTFONT(pUFObj);
    bDBChar = FALSE;

    for(i = 0; i < dwCount; i++, pTrans++)
    {
        switch((pTrans->ubType & MTYPE_FORMAT_MASK))
        {
        case MTYPE_DIRECT:      // SBCS character
            if (bVFont && bDBChar)
            {
                WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF));
                bDBChar = FALSE;
            }
            WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubCode, 1);
            break;

        case MTYPE_PAIRED:      // DBCS character
            if (bVFont && !bDBChar)
            {
                WRITESPOOLBUF(pdevobj, ESC_VERT_ON, sizeof(ESC_VERT_ON));
                bDBChar = TRUE;
            }
            WRITESPOOLBUF(pdevobj, pTrans->uCode.ubPairs, 2);
            break;

        case MTYPE_COMPOSE:
            if (bVFont && bDBChar)
            {
                WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF));
                bDBChar = FALSE;
            }

            pTemp = (BYTE *)(GStr.pGlyphOut) + pTrans->uCode.sCode;

            // first two bytes are the length of the string
            wLen = *pTemp + (*(pTemp + 1) << 8);
            pTemp += 2;

            WRITESPOOLBUF(pdevobj, pTemp, wLen);
        }
    }

    if (bDBChar)
    {
        WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF));
    }
 
    MemFree(tempBuf);
    return TRUE;
}

BOOL APIENTRY OEMFilterGraphics(
PDEVOBJ    pdevobj,  // Points to private data required by the Unidriver.dll
PBYTE      pBuf,     // points to buffer of graphics data
DWORD      dwLen)    // length of buffer in bytes
{  
    DWORD           dwCompLen;
    LONG            lHorzPixel;
    DWORD           dwLength;      // Let's use a temporary LEN
    PBYTE           pCompImage;
    POEM_EXTRADATA  pOEM;
    BYTE            ESC_ESX86[] = "\x1B\x7E\x86\x00\x00\x01\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01";
// #291170: Image data is not printed partly
    LONG            li, lHeightPixel, lPixels, lBytes, lRemain, lSize;
    PBYTE           pTemp;
    BYTE            ESC_Y_REL[] = "\x1b\x7e\x1d\x00\x03\x06\x00\x00";

	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj || NULL == pBuf || 0 == dwLen)
    {
        ERR(("OEMFilterGraphics: Invalid parameter(s).\n"));
        return FALSE;
    }

    pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);

	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for null pointers
    if (NULL == pOEM)
    {
        ERR(("OEMFilterGraphics: pdevobj->pOEMDM = 0.\n"));
        return FALSE;
    }

    if(!pOEM->fCallback)
    {
        WRITESPOOLBUF(pdevobj, pBuf, dwLen);
        return TRUE;
    }

    if(!(pCompImage = (BYTE *)MemAllocZ(MAXIMGSIZE)))
    {
        ERR(("Memory alloc error\n"));
        return FALSE;
    }

// #291170: Image data is not printed partly
// Sent 'SendBlock' command separately if necessary.

#define RLE_THRESH (MAXIMGSIZE / 2 - 2)    // threshold for RLE should success

    /*_ Calculate i-axis direction size of the iage ISIZ */
    lBytes = pOEM->lWidthBytes;
    lHorzPixel = lBytes * 8;
    lHeightPixel = pOEM->lHeightPixels;

    if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
        ESC_ESX86[5] = (pOEM->wCurrentRes == 300 ? 0x10 : 0x40);

    pTemp = pBuf;
    lRemain = lBytes * lHeightPixel;
    li = 0;
    while (li < lHeightPixel) {

		// NTRAID#NTBUG9-581703-2002/03/19-v-sueyas-: Check for deviding by zero
	    if (0 == lBytes)
	    {
	        ERR(("OEMFilterGraphics: pOEM->lWidthBytes = 0.\n"));
// NTRAID#NTBUG9-751233-2002/12/05-yasuho-: Memory leak in pagesres.dll
                MemFree(pCompImage);
	        return FALSE;
	    }

        /*_ Compress image data using Byte Run Length Algorithm  */
        lPixels = min(lRemain, RLE_THRESH) / lBytes;
        lSize = lBytes * lPixels;
        dwCompLen = RL_ECmd(pTemp, pCompImage, lSize, MAXIMGSIZE);
        pTemp += lSize;
        lRemain -= lSize;
        li += lPixels;

        /*_ Set ISIZ of ESX86 command */
        ESC_ESX86[17] = HIBYTE(lHorzPixel);
        ESC_ESX86[18] = LOBYTE(lHorzPixel);
        ESC_ESX86[21] = HIBYTE(lPixels);
        ESC_ESX86[22] = LOBYTE(lPixels);

        /*_ Add parameter length to the data length after compression */
        dwLength = dwCompLen + 18;

        /*_ Set LEN of ESX86 command */
        ESC_ESX86[3] = HIBYTE(dwLength);
        ESC_ESX86[4] = LOBYTE(dwLength);

        /*_ Output ESX86 command */
        WRITESPOOLBUF(pdevobj, (PBYTE)ESC_ESX86, 23);

        /*_ Output compressed data */
        WRITESPOOLBUF(pdevobj, pCompImage, dwCompLen);

        /* Move Y position to the next graphics portion */
        if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
            ESC_Y_REL[5] = 0x26;

        dwLength = lPixels * pOEM->wUnit;       // Convert to MasterUnit
        ESC_Y_REL[6] = HIBYTE(dwLength);
        ESC_Y_REL[7] = LOBYTE(dwLength);
        WRITESPOOLBUF(pdevobj, ESC_Y_REL, 8);
    }

    MemFree(pCompImage);

    return TRUE;
}

/*****************************************************************************/
/*                                                                           */
/*   INT APIENTRY OEMCommandCallback(                                        */
/*                PDEVOBJ pdevobj                                            */
/*                DWORD   dwCmdCbId                                          */
/*                DWORD   dwCount                                            */
/*                PDWORD  pdwParams                                          */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbId,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams)  // points to values of command params
{
    POEM_EXTRADATA      pOEM;
    WORD                wTemp =0;
// #278517: Support RectFill
    WORD                wUnit;
    BYTE                ESC_X_ABS_NP[] = "\x1b\x7e\x1c\x00\x03\x25\x00\x00";
    BYTE                ESC_X_REL_NP[] = "\x1b\x7e\x1c\x00\x03\x26\x00\x00";
    BYTE                ESC_Y_ABS[] = "\x1b\x7e\x1d\x00\x03\x05\x00\x00";
    BYTE                ESC_Y_REL[] = "\x1b\x7e\x1d\x00\x03\x06\x00\x00";
// #278517: RectFill
    BYTE                ESC_RECT_FILL[] =
                        "\x1b\x7e\x32\x00\x08\x80\x40\x00\x02\x00\x00\x00\x00";
    BYTE                ESC_BEGIN_RECT[] =
                        "\x1b\x7e\x52\x00\x06\x00\x00\x17\x70\x17\x70";
    BYTE                ESC_END_RECT[] =
                        "\x1b\x7e\x52\x00\x06\x00\x00\x38\x40\x38\x40";

	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("OEMCommandCallback: Invalid parameter(s).\n"));
        return 0;
    }

    pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);

	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for null pointers
    if (NULL == pOEM)
    {
        ERR(("OEMCommandCallback: pdevobj->pOEMDM = 0.\n"));
        return 0;
    }

    switch(dwCmdCbId)
    {
        case GRXFILTER_ON:
            pOEM->fCallback = TRUE;
            break;

        case CMD_SELECT_RES_300:
            pOEM->wCurrentRes = 300;
            pOEM->wUnit = 2;
            break;

        case CMD_SELECT_RES_600:
            pOEM->wCurrentRes = 600;
            pOEM->wUnit = 1;
            break;

// #278517: Support RectFill
        case CMD_SELECT_RES_240:
            pOEM->wCurrentRes = 240;
            pOEM->wUnit = 6;
            break;

        case CMD_SELECT_RES_360:
            pOEM->wCurrentRes = 360;
            pOEM->wUnit = 4;
            break;

        case CMD_SEND_BLOCKDATA:
            if( !pdwParams || dwCount != 2)
                break;

            pOEM->fCallback = TRUE;
            pOEM->lHeightPixels = (LONG)PARAM(pdwParams, 0);
            pOEM->lWidthBytes = (LONG)PARAM(pdwParams, 1);
            break;

        case CURSOR_Y_ABS_MOVE:
			// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for illegal parameters
		    if (dwCount < 1 || !pdwParams)
                break;

            wTemp = (WORD)*pdwParams;

#ifdef FONTPOS
            pOEM->wYPos = wTemp;
#endif

            if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                ESC_Y_ABS[5] = 0x25;

            ESC_Y_ABS[6] = HIBYTE(wTemp);
            ESC_Y_ABS[7] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, ESC_Y_ABS, 8);
            return (INT)wTemp;

        case CURSOR_Y_REL_DOWN:
			// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for illegal parameters
		    if (dwCount < 1 || !pdwParams)
                break;

            wTemp = (WORD)*pdwParams;

#ifdef FONTPOS
            pOEM->wYPos += wTemp;
#endif

            if(pOEM->wCurrentRes == 300 || pOEM->wCurrentRes == 600)
                ESC_Y_REL[5] = 0x26;

            ESC_Y_REL[6] = HIBYTE(wTemp);
            ESC_Y_REL[7] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, ESC_Y_REL, 8);
            return (INT)wTemp;

        case CURSOR_X_ABS_MOVE:
			// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for illegal parameters
		    if (dwCount < 1 || !pdwParams)
                break;

            wTemp = (WORD)*pdwParams;
            ESC_X_ABS_NP[6] = HIBYTE(wTemp);
            ESC_X_ABS_NP[7] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, ESC_X_ABS_NP, 8);
            return (INT)wTemp;

        case CURSOR_X_REL_RIGHT:
			// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for illegal parameters
		    if (dwCount < 1 || !pdwParams)
                break;

            wTemp = (WORD)*pdwParams;
            ESC_X_REL_NP[6] = HIBYTE(wTemp);
            ESC_X_REL_NP[7] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, ESC_X_REL_NP, 8);
            return (INT)wTemp;
            
// #278517: RectFill
        case CMD_RECT_WIDTH:
            pOEM->wRectWidth = (WORD)*pdwParams;
            break;

        case CMD_RECT_HEIGHT:
            pOEM->wRectHeight = (WORD)*pdwParams;
            break;

        case CMD_RECT_BLACK:
        case CMD_RECT_BLACK_2:
//#292316
//            ESC_RECT_FILL[6] = 0x60;
            ESC_RECT_FILL[7] = 0x00;    // Black
            goto fill;

        case CMD_RECT_WHITE:
        case CMD_RECT_WHITE_2:
//#292316
//            ESC_RECT_FILL[6] = 0x40;
            ESC_RECT_FILL[7] = 0x0F;    // White
            goto fill;

        case CMD_RECT_GRAY:
        case CMD_RECT_GRAY_2:
//#292316
//            ESC_RECT_FILL[6] = 0x60;
            ESC_RECT_FILL[7] = (BYTE)((100 - *pdwParams) * 100 / 1111); // Gray
            goto fill;

        fill:
            if (dwCmdCbId >= CMD_RECT_BLACK_2)
                WRITESPOOLBUF(pdevobj, ESC_BEGIN_RECT, 11);
            wUnit = pOEM->wUnit ? pOEM->wUnit : 1;  // for our safety

//#292316
//            wTemp = pOEM->wRectWidth - 1;
            wTemp = pOEM->wRectWidth;

            wTemp = (WORD)(((LONG)wTemp + wUnit - 1) / wUnit * wUnit);
            ESC_RECT_FILL[9] = HIBYTE(wTemp);
            ESC_RECT_FILL[10] = LOBYTE(wTemp);

//#292316
//            wTemp = pOEM->wRectHeight - 1;
            wTemp = pOEM->wRectHeight;

            wTemp = (WORD)(((LONG)wTemp + wUnit - 1) / wUnit * wUnit);
            ESC_RECT_FILL[11] = HIBYTE(wTemp);
            ESC_RECT_FILL[12] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, ESC_RECT_FILL, 13);
            if (dwCmdCbId >= CMD_RECT_BLACK_2)
                WRITESPOOLBUF(pdevobj, ESC_END_RECT, 11);
            break;

        default:
            break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\name.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DisableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

// NTRAID#NTBUG9-588581-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods


#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));

	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for illegal parameters
    if (NULL == ppv)
        return E_NOINTERFACE;

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));
    VERBOSE((DLLTEXT("        Function:%s:"),pMethodName));

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;

                if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'I':
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'M':
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        VERBOSE(("Supported\n"));
        return S_OK;
    }
    else
    {
        VERBOSE(("NOT supported\n"));
        return E_FAIL;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for illegal parameters
	if (NULL == piResult)
		return E_FAIL;

    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if(OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

	// NTRAID#NTBUG9-581704-2002/03/19-v-sueyas-: Error handling
    if (bOEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph))
	    return S_OK;
	else
		return E_FAIL;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

	// NTRAID#NTBUG9-581704-2002/03/19-v-sueyas-: Error handling
    if (bOEMSendFontCmd(pdevobj, pUFObj, pFInv))
	    return S_OK;
	else
		return E_FAIL;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
	// NTRAID#NTBUG9-581700-2002/03/19-v-sueyas-: Check for illegal parameters
    if (NULL == ppv)
        return E_NOINTERFACE;

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE((DLLTEXT("Class factory:\t\tCreate component.")));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//


//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
#include <strsafe.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'PAGS'
#define DLLTEXT(s)      "PAGS: " s
#define OEM_VERSION      0x00010000L

#define CCHMAXCMDLEN    128
// Though the data GDI sends to CBFilerGraphics
// is only one line, we allocate maximum image data
// length ESX86 command can handle.
// 0x7fff - 18 = 0x7fed bytes

#define MAXIMGSIZE (0x7fff - 18)

// Use for whether it calls OEMFilterGraphics
#define GRXFILTER_ON        1

#define CURSOR_Y_ABS_MOVE   2
#define CURSOR_Y_REL_DOWN   3
#define CURSOR_X_ABS_MOVE   4
#define CURSOR_X_REL_RIGHT  5

// It's only NetworkPrinter12/17/24 using these definitions
#define CMD_SELECT_RES_300  10
#define CMD_SELECT_RES_600  11
// #278517: Support RectFill
#define CMD_SELECT_RES_240  12
#define CMD_SELECT_RES_360  13
#define CMD_SEND_BLOCKDATA  20

// #278517: RectFill
#define CMD_RECT_WIDTH      30
#define CMD_RECT_HEIGHT     31
#define CMD_RECT_BLACK      32
#define CMD_RECT_WHITE      33
#define CMD_RECT_GRAY       34  // Not used
#define CMD_RECT_BLACK_2    35
#define CMD_RECT_WHITE_2    36
#define CMD_RECT_GRAY_2     37

#define BVERTFONT(p) \
    ((p)->ulFontID == 6 || (p)->ulFontID == 8)

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEM_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
    // Private extention
    BOOL                fCallback;

    // Using build ESX86 command
    WORD                wCurrentRes;
    LONG                lWidthBytes;
    LONG                lHeightPixels;

#ifdef FONTPOS
// UNIDRV send incorrect Y position when set UPPERLEFT
// We should adjust manually.
    WORD                wFontHeight;    // DevFont height
    WORD                wYPos;          // DevFont Y position
#endif  //FONTPOS
// #278517: RectFill
    WORD                wRectWidth;     // Width of Rectangle
    WORD                wRectHeight;    // Height of Rectangle
    WORD                wUnit;          // Resolution in MasterUnit
} OEM_EXTRADATA, *POEM_EXTRADATA;


// NTRAID#NTBUG9-581704-2002/03/19-v-sueyas-: Error handling
// New interface functions with Unidrv callbacks.
#ifdef __cplusplus
extern "C" {
#endif
BOOL APIENTRY bOEMSendFontCmd(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, PFINVOCATION pFInv);
BOOL APIENTRY bOEMOutputCharStr(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph);
#ifdef __cplusplus
}
#endif



#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\etc\compress.h ===
//typedef unsigned char BYTE;

const BYTE terminator[5] = {0x1B, 0x7E, 0x01, 0x00, 0x00};


#define RL4_MAXISIZE  0xFFFE
#define RL4_MAXHEIGHT 0xFFFE
#define RL4_MAXWIDTH  4096
#define VALID     0x00
#define INVALID   0x01


LPBYTE  RL_ImagePtr;
LPBYTE  RL_CodePtr;
LPBYTE  RL_BufEnd;
WORD    RL_ImageSize;
WORD    RL_CodeSize;


WORD FAR PASCAL RL_ECmd(LPBYTE, LPBYTE, WORD);
BYTE FAR PASCAL RL_Init(LPBYTE, LPBYTE, WORD);
char FAR PASCAL RL_Enc( void );

#define RL4_BLACK     0x00
#define RL4_WHITE     0x01
#define RL4_BYTE      0x00
#define RL4_NONBYTE   0x01
#define RL4_CLEAN     0x00
#define RL4_DIRTY     0x01
#define RL4_FIRST     0x00
#define RL4_SECOND    0x01

#define COMP_FAIL     0x00
#define COMP_SUCC     0x01

#define CODBUFSZ      0x7FED     /* NOTE : THIS SHOULD MATCH THE SPACE GIVEN */
                                 /*        TO COMPRESSED DATA BY THE DEVICE  */
                                 /*        DRIVER. CHANGE THIS BASED ON YOUR */
                                 /*        OWN DISCRETION.   C.Chi           */


/* Variables */


LPBYTE  RL4_CodePtr;
LPBYTE  RL4_ImagePtr;
WORD    RL4_IWidth;
WORD    RL4_IHeight;
WORD    RL4_CurrRL;
WORD    RL4_NblCnt;
BYTE    RL4_RowAttrib;
BYTE    RL4_CurrColor;
BYTE    RL4_Status;
BYTE    RL4_Nibble;
WORD    RL4_ISize;
WORD    RL4_CodeSize;

LPBYTE  RL4_BufEnd;

BYTE    BUF_OVERFLOW;

/* macros */

#define PUTNBL(lval, nblcnt)  {                                      \
      short i;                                                       \
      for (i=nblcnt ; i>0; i--)                                      \
      {     if (RL4_Nibble==RL4_FIRST)                               \
        {   RL4_Nibble = RL4_SECOND;                                 \
                 *RL4_CodePtr = (BYTE) (lval >> ((i-1)*4)) << 4 ;    \
            } else                                                   \
        {   RL4_Nibble = RL4_FIRST;                                  \
                 *RL4_CodePtr |= (BYTE) (lval >> ((i-1)*4)) ;        \
                RL4_CodePtr++;                                       \
            if (RL4_CodePtr>RL4_BufEnd)                              \
               {  BUF_OVERFLOW = 1; return;                          \
               }                                                     \
            }                                                        \
      }                                                              \
}

/* Function Prototypes */

WORD FAR PASCAL RL4_ECmd (LPBYTE, LPBYTE, WORD, WORD, WORD);
BYTE FAR PASCAL RL4_ChkParms (LPBYTE, LPBYTE, WORD , WORD, WORD );
char FAR PASCAL RL4_Enc (void);
char FAR PASCAL RL4_ConvRow(LPBYTE);
char FAR PASCAL RL4_ConvLast(LPBYTE, WORD);
char FAR PASCAL RL4_ByteProc (BYTE);
char FAR PASCAL RL4_EncRow(LPBYTE, WORD);
WORD FAR PASCAL RL4_TransRun(WORD);
char RL4_PutNbl(long , short );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\etc\compress.c ===
#include <windows.h>
#include "compress.h"


/*********************************************************/
/*  RL_ECmd  : main function                             */
/*  ARGS     : LPBYTE - pointer to image                 */
/*             LPBYTE - pointer to BRL code              */
/*             WORD   - size of image                    */
/*  RET      : WORD   - size of BRL Code                 */
/*             0      - COMPRESSION FAILED               */
/*********************************************************/
WORD FAR PASCAL RL_ECmd(LPBYTE iptr, LPBYTE cptr, WORD isize)
{
   if (RL_Init(iptr, cptr, isize)==VALID)
      RL_Enc();
   if (BUF_OVERFLOW)
      return 0;
   else
      return RL_CodeSize;
}

/*********************************************************/
/*  RL_Init  : Initializer                               */
/*  ARGS     : BYTE * - pointer to image                 */
/*             BYTE * - pointer to BRL code              */
/*             WORD   - size of image                    */
/*  RET      : BYTE   - VALID or INVALID                 */
/*********************************************************/

BYTE FAR PASCAL RL_Init(LPBYTE iptr, LPBYTE cptr, WORD isize)
{
   RL_ImagePtr = iptr;
   RL_CodePtr = cptr;
   RL_ImageSize = isize;
   BUF_OVERFLOW = 0;
   RL_BufEnd = cptr + CODBUFSZ;
   return VALID;
}

/*********************************************************/
/*  RL_Enc   : Encoder                                   */
/*  ARGS     : void                                      */
/*  RET      : char   COMP_SUCC or COMP_FAIL             */
/*********************************************************/
char FAR PASCAL RL_Enc(void)
{
int     repcnt;
BYTE   refbyt;
WORD    i;

   i = 0;
   repcnt = 0;
   RL_CodeSize = 0;
   refbyt = RL_ImagePtr[0];
   //@CC 12.22.94 for (i=1;i<=RL_ImageSize; i++)
   //@TO 12/01/1995   for (i=1;i<RL_ImageSize;i++)
   for (i=1;i<=RL_ImageSize;i++)
   {
       if ((RL_ImagePtr[i] == refbyt)&&(repcnt<255)&&(i!=RL_ImageSize-1))
          repcnt++;
       else
       {
          //-> @CC 12.22.94
          if ((RL_ImagePtr[i] == refbyt)&&(repcnt<255))
             repcnt++;
          //<- @CC 12.22.94
          if (RL_CodePtr > RL_BufEnd)
             {BUF_OVERFLOW = 1; return COMP_FAIL;}
          RL_CodePtr[0] = repcnt;
          RL_CodePtr[1] = refbyt;
          RL_CodePtr += 2;
          RL_CodeSize += 2;
          refbyt = RL_ImagePtr[i];
          repcnt = 0;
       }
   }
   return COMP_SUCC;
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_ECmd                                               */
/*      @\@: main entry point                                       */
/*      @: code size = RL4_ECmd(iptr, cptr, isz, iwd, iht)        */
/*      @: LPBYTE      -    pointer to image                      */
/*              LPBYTE      -    pointer to code                       */
/*              WORD        -    size of image IN BYTES !!!            */
/*              WORD        -    image width                           */
/*              WORD        -    height of image                       */
/*      o@: WORD        -    size of RL4 code                      */
/*              0           -    COMPRESSION FAILED                    */
/*      L@:                                                        */
/*      @:  1993. 1.27 initial                                    */
/***********************************************************************/
WORD FAR PASCAL RL4_ECmd(LPBYTE iptr, LPBYTE cptr, WORD sz, WORD wd, WORD ht)
{
char status;

if (RL4_ChkParms( iptr, cptr, sz, wd, ht ) == VALID)
if ((status=RL4_Enc())==COMP_FAIL)
   return 0;
else
   return RL4_CodeSize;
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_ChkParms                                           */
/*      @\@: checks input parameters if valid and sets internal     */
/*              variables if they are                                  */
/*      @: ret val = RL4_ChkParms(iptr, cptr, isz, iwd, iht)      */
/*      @: LPBYTE     -    pointer to image                       */
/*              LPBYTE     -    pointer to code                        */
/*              WORD    -    size of image                             */
/*              WORD    -    image width IN BYTES !!!                  */
/*              WORD    -    height of image                           */
/*      o@: BYTE       -    VALID or INVALID                       */
/*      L@:                                                        */
/*      @:  1994. 1.25 initial                                    */
/*               1994. 2.12 clean up                                   */
/***********************************************************************/
BYTE FAR PASCAL RL4_ChkParms(LPBYTE iptr, LPBYTE cptr, WORD isz, WORD iwd, WORD iht)
{
    if ((isz > RL4_MAXISIZE)||
       ((iht != isz/iwd+1)&&(iht != isz/iwd))||
       (iht <= 0)||
       (iht > RL4_MAXHEIGHT)||
       (iwd <= 0)||
       (iwd > RL4_MAXWIDTH))
    return INVALID;
    else
       {
          RL4_ImagePtr = iptr;
          RL4_CodePtr = cptr;
          RL4_IHeight = iht;
          RL4_IWidth = iwd;
          RL4_ISize = isz;

          RL4_BufEnd = cptr + CODBUFSZ;  /* please define CODBUFSZ in header */
                                         /* file COMPRESS.H                  */
          BUF_OVERFLOW = 0;
          return VALID;
       }
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_Enc                                                */
/*      @\@: encodes image to RL4 code                              */
/*      @: RL4_Enc()                                              */
/*      @: void                                                   */
/*      o@: void                                                   */
/*      L@:                                                        */
/*      @:  1993. 1.25 initial                                    */
/*               1994. 2.12 added RL4_ConvLast                         */
/***********************************************************************/
char FAR PASCAL RL4_Enc(void) {

LPBYTE rowptr, codeptr;
WORD rownum, lrlen;
long isize,  diff;

    RL4_Nibble = RL4_FIRST;
    rowptr = RL4_ImagePtr;
    RL4_CodeSize = 0;
    isize = 0;
    lrlen = RL4_ISize%RL4_IWidth;
    if (lrlen == 0)
       lrlen = RL4_IWidth;
    diff = RL4_ISize-RL4_IWidth;
    for ( rownum = 0; rownum < RL4_IHeight; rownum++ )
    {
       codeptr = RL4_CodePtr;
       if (isize < diff)
        {
          RL4_ConvRow(rowptr);
          if (BUF_OVERFLOW) return COMP_FAIL;
        }
       else
       {
       RL4_ConvLast(rowptr,lrlen);
       if (BUF_OVERFLOW) return COMP_FAIL;
       }
       if (RL4_RowAttrib == RL4_DIRTY) /* Encode only rows with '1' bits */
          RL4_EncRow(codeptr, rownum);
       else
       RL4_CodePtr -= 4;
       rowptr += RL4_IWidth;
       isize += RL4_IWidth;
     }
     return COMP_SUCC;
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_ConvRow                                            */
/*      @\@: translates runs in a row to RL4 code                   */
/*      @: RL4_ConvRow(rowptr)                                    */
/*      @: LPBYTE       -   pointer to a row of image            */
/*      o@: void                                                   */
/*      L@: excluding last row                                     */
/*      @: 1993. 1.25 initial                                     */
/***********************************************************************/
char FAR PASCAL RL4_ConvRow(LPBYTE rowptr){

WORD bytenum;
        RL4_CurrRL = 0;
        RL4_CurrColor = RL4_WHITE;
        RL4_Status = RL4_BYTE;
        RL4_CodePtr += 4;
        RL4_NblCnt = 0;
        for( bytenum = 0; bytenum < RL4_IWidth; bytenum++ )
        {
           RL4_ByteProc(rowptr[bytenum]);
           if (BUF_OVERFLOW) return COMP_FAIL;
        }
        if ((RL4_CurrColor == RL4_WHITE)&&(RL4_CurrRL==RL4_IWidth*8)) /* all '0' bits */
           RL4_RowAttrib = RL4_CLEAN;
        else
           RL4_RowAttrib = RL4_DIRTY;
        return COMP_SUCC;
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_ConvLast                                           */
/*      @\@: translates runs in a row to RL4 code                   */
/*      @: RL4_ConvLast(rowptr, lrlen)                            */
/*      @: LPBYTE       -   pointer to a row of image             */
/*              WORD      -   length of last row                       */
/*      o@: void                                                   */
/*      L@: for image data whose last row is not exactly           */
/*              RL4_Width bytes wide                                   */
/*      @: 1993. 2.12 added to eliminate extra bytes in code      */
/*              1994. 6.08 made attrib always dirty so that last row   */
/*                         is always encoded                           */
/***********************************************************************/
char FAR PASCAL RL4_ConvLast(LPBYTE rowptr, WORD lrlen){

WORD bytenum;

 RL4_CurrRL = 0;
 RL4_CurrColor = RL4_WHITE;
 RL4_Status = RL4_BYTE;
 RL4_CodePtr += 4;
 RL4_NblCnt = 0;
 RL4_RowAttrib = RL4_DIRTY;
 for( bytenum = 0; bytenum < lrlen; bytenum++ )
 {
   RL4_ByteProc(rowptr[bytenum]);
   if (BUF_OVERFLOW) return COMP_FAIL;
  }
 return COMP_SUCC;
}
/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_ByteProc                                           */
/*      @\@: processes one byte of image data                       */
/*      @: RL4_ByteProc(ibyte)                                    */
/*      @: BYTE       -   one byte of image data                  */
/*      o@: void                                                   */
/*      L@:                                                        */
/*      @:  1993. 1.25 initial                                    */
/***********************************************************************/
char FAR PASCAL RL4_ByteProc (BYTE ibyte)
{
BYTE mask;     /* mask bits from '1000 0000' to '0000 0001' */
int i;

      mask = 0x80;
      for ( i = 0; i < 8; i++ )
      { if (ibyte & mask)    /* Next bit is black */
           { if (RL4_CurrColor==RL4_WHITE)
                { RL4_CurrColor = RL4_BLACK;
                  RL4_NblCnt += RL4_TransRun(RL4_CurrRL);
                  if (BUF_OVERFLOW) return COMP_FAIL;
                  if (RL4_NblCnt & 1)           /* Check if even or odd # of nibbles */
                     RL4_Status = RL4_NONBYTE;
                  else
                     RL4_Status = RL4_BYTE;
                  RL4_CurrRL = 1;
                }
             else if (RL4_CurrColor==RL4_BLACK)
                     RL4_CurrRL++;
           }
      else  /* Next bit is white */
         { if (RL4_CurrColor==RL4_BLACK)
             { RL4_CurrColor = RL4_WHITE;
               RL4_NblCnt += RL4_TransRun (RL4_CurrRL);
               if (BUF_OVERFLOW) return COMP_FAIL;
               if (RL4_NblCnt & 1)           /* Check if even or odd # of nibbles */
                  RL4_Status = RL4_NONBYTE;
               else
                  RL4_Status = RL4_BYTE;
               RL4_CurrRL = 1;
             }
           else if (RL4_CurrColor==RL4_WHITE)
                   RL4_CurrRL++;
         }
        mask >>= 1;
       }
       return COMP_SUCC;
}

/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_EncRow                                             */
/*      @\@: encodes row number, code length, and End-of-Row code   */
/*      @: RL4_EncRow(codeptr, rownum)                            */
/*      @: LPBYTE        - pointer to RL4 code                   */
/*              WORD  - no. of row being encoded              */
/*      o@: void                                                   */
/*      L@:                                                        */
/*      @:  1993. 1.25 initial                                    */
/***********************************************************************/
char FAR PASCAL RL4_EncRow(LPBYTE codeptr, WORD rownum){
short codelen;

        codelen = 0;
        *codeptr = (BYTE) (rownum >>8);
        codeptr[1] = (BYTE) rownum;
        if(RL4_Status==RL4_BYTE){
           RL4_NblCnt += 2;
           RL4_PutNbl(0xFFl,2);        /* Append 0xFF to code */
           if (BUF_OVERFLOW) return COMP_FAIL;
        } else {
        RL4_NblCnt += 3;
        RL4_PutNbl(0xFFFl,3); /* Append 0xFFF to code */
        if (BUF_OVERFLOW) return COMP_FAIL;
        }
        codelen = RL4_NblCnt/2;
        codeptr[2] = (BYTE) (codelen >>8);
        codeptr[3] = (BYTE) codelen;
        RL4_CodeSize += codelen + 4;
        return COMP_SUCC;
}


/***********************************************************************/
/* APTi-Philippines, Inc. RL4 Compression Routine                      */
/*    @@: RL4_TransRun                                           */
/*      @\@: translates run length value to RL4 code                */
/*      @: nibble count = RL4_TransRun(rlval)                     */
/*      @: short         -   run length value to be encoded       */
/*      o@: short         -   no. of nibbles appended              */
/*      L@:                                                        */
/*      @:  1993. 1.25 initial                                    */
/***********************************************************************/
WORD FAR PASCAL RL4_TransRun(WORD rlval){
WORD nblcnt;
long lval;
     if (rlval == 0) { lval = 0xFEl;
                       nblcnt = 2; }

     else if (rlval<=8) { lval = (long) (rlval)-1l;
                                        nblcnt = 1; }
     else if (rlval<=72) {lval = (long) (rlval)+119l;
                                        nblcnt = 2; }
     else if (rlval<=584) { lval = (long) (rlval)+2999l;
                                           nblcnt = 3; }
     else if (rlval<=4680) { lval = (long) (rlval)+56759l;
                                             nblcnt = 4; }
     else if (rlval<=32767) { lval = (long) (rlval)+978359l;
                                               nblcnt = 5; }
/*     PUTNBL(lval, nblcnt)*/
     RL4_PutNbl(lval, nblcnt);
     if (BUF_OVERFLOW) return COMP_FAIL;
     return nblcnt;
}

char RL4_PutNbl(long lval2, short nblcnt2)  {
{
      short i;
      for (i=nblcnt2 ; i>0; i--)
      {     if (RL4_Nibble==RL4_FIRST)
        {   RL4_Nibble = RL4_SECOND;
                 *RL4_CodePtr = (BYTE) (lval2 >> ((i-1)*4)) << 4 ;
            } else
        {   RL4_Nibble = RL4_FIRST;
                 *RL4_CodePtr |= (BYTE) (lval2 >> ((i-1)*4)) ;
                RL4_CodePtr++;
                if (RL4_CodePtr>RL4_BufEnd)
                   {BUF_OVERFLOW = 1; return COMP_FAIL;}
            }
      }
      return COMP_SUCC;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\etc\pagesms.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// 
// Copyright (C) 1994-1995 Microsoft Corporation
// Copyright (C) 1995      Advanced Peripherals Technologies, Inc.
//-----------------------------------------------------------------------------

char *rgchModuleName = "PAGESMS";

#define PRINTDRIVER
#include <print.h>
#include "mdevice.h"
#include "gdidefs.inc"
#include "unidrv.h"
#include <memory.h>

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#define CCHMAXCMDLEN    128
#define MAXIMGSIZE      0x7FED   /* GDICBFilterGraphics    */
                                 /* 1AESX86M  */
                                 /* \IMAGEpB      */
                                 /* 0x7FFF - 18 =  7FED byte                 */

/*_  k */
extern WORD FAR PASCAL RL_ECmd(LPBYTE, LPBYTE, WORD);
/*_ 4 k */
extern WORD FAR PASCAL RL4_ECmd (LPBYTE, LPBYTE, WORD, WORD, WORD);

typedef struct
{
    BYTE  fGeneral;       // General purpose bitfield
    BYTE  bCmdCbId;       // Callback ID; 0 iff no callback
    WORD  wCount;         // # of EXTCD structures following
    WORD  wLength;        // length of the command
} CD, *PCD, FAR * LPCD;

typedef struct tagPAGES {
    short sHorzRes;
    short sVertRes;
    LPSTR  lpCompBuf;     // k
} PAGES, FAR * LPPAGES;

static BYTE ShiftJisPAGES[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};

static BYTE ESC_VERT_ON[]  = "\x1B\x7E\x0E\x00\x01\x0B";
static BYTE ESC_VERT_OFF[] = "\x1B\x7E\x0E\x00\x01\x0C";

short usHorzRes;
short usVertRes;

#ifndef WINNT
BYTE NEAR __loadds IsDBCSLeadBytePAGES(BYTE Ch)
#else
BYTE NEAR IsDBCSLeadBytePAGES(BYTE Ch)
#endif
{
return ShiftJisPAGES[Ch];
}

#ifdef WINNT
LPWRITESPOOLBUF WriteSpoolBuf;
LPALLOCMEM UniDrvAllocMem;
LPFREEMEM UniDrvFreeMem;
#endif // WINNT

//---------------------------*OEMSendScalableFontCmd*--------------------------
// Action:  send Pages-style font selection command.
//-----------------------------------------------------------------------------
VOID FAR PASCAL OEMSendScalableFontCmd(lpdv, lpcd, lpFont)
LPDV    lpdv;
LPCD    lpcd;     // offset to the command heap
LPFONTINFO lpFont;
{
    LPSTR   lpcmd;
    short   ocmd;
    WORD    i;
    BYTE    rgcmd[CCHMAXCMDLEN];    // build command here
    LPPAGES lpPages = lpdv->lpMdv;

    if (!lpcd || !lpFont)
        return;

    // be careful about integer overflow.
    lpcmd = (LPSTR)(lpcd+1);
    ocmd = 0;

    for (i = 0; i < lpcd->wLength && ocmd < CCHMAXCMDLEN; )
        if (lpcmd[i] == '#' && lpcmd[i+1] == 'V')      // height
        {
            WORD    height;

            height = (lpFont->dfPixHeight - lpFont->dfInternalLeading)
                    * (1440 / lpFont->dfVertRes);
            rgcmd[ocmd++] = HIBYTE(height);
            rgcmd[ocmd++] = LOBYTE(height);
            i += 2;
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'L')     // pitch
        {
            WORD    height;

            height = lpFont->dfPixHeight * (1440 / lpFont->dfVertRes);
            rgcmd[ocmd++] = HIBYTE(height);
            rgcmd[ocmd++] = LOBYTE(height);
            i += 2;
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'H')     // width
        {
            if (lpFont->dfPixWidth > 0)
            {
                short tmpWidth;

                tmpWidth = lpFont->dfMaxWidth * (1440 / lpFont->dfVertRes);

                rgcmd[ocmd++] = HIBYTE(tmpWidth);
                rgcmd[ocmd++] = LOBYTE(tmpWidth);
            }
            i += 2;
            
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'P')     // pitch
        {
            if (lpFont->dfPixWidth > 0)
            {
                short sWidth = (lpFont->dfMaxWidth * (1440/lpPages->sHorzRes));

                rgcmd[ocmd++] = HIBYTE(sWidth);
                rgcmd[ocmd++] = LOBYTE(sWidth);
            }
            i += 2;
        }
        else
            rgcmd[ocmd++] = lpcmd[i++];

    WriteSpoolBuf(lpdv, (LPSTR) rgcmd, ocmd);
}

//----------------------------*OEMScaleWidth*--------------------------------
// Action: return the scaled width which is calcualted based on the
//      assumption that ESC\Page assumes 72 points in one 1 inch.
//
// Formulas:
//  <extent> : <font units> = <base Width> : <hRes>
//  <base width> : <etmMasterHeight> = <newWidth> : <newHeight>
//  <etmMasterUnits> : <etmMasterHeight> = <font units> : <vRes>
// therefore,
//   <newWidth> = (<extent> * <hRes> * <newHeight>) / 
//                  (<etmMasterUnits> * <vRes>)
//---------------------------------------------------------------------------
short FAR PASCAL OEMScaleWidth(width, masterUnits, newHeight, vRes, hRes)
short width;        // in units specified by 'masterUnits'.
short masterUnits;
short newHeight;    // in units specified by 'vRes'.
short vRes, hRes;   // height and width device units.
{
    DWORD newWidth10;
    short newWidth;

    // assert that hRes == vRes to avoid overflow problem.
    if (vRes != hRes)
        return 0;

    newWidth10 = (DWORD)width * (DWORD)newHeight * 10;
    newWidth10 /= (DWORD)masterUnits;

    // we multiplied 10 first in order to maintain the precision of
    // the width calcution. Now convert it back and round to the
    // nearest integer.
    newWidth = (short)((newWidth10 + 5) / 10);

    return newWidth;
}

#ifndef WINNT
short FAR PASCAL __loadds OEMOutputChar( lpdv, lpstr, len, rcID)
#else
short FAR PASCAL OEMOutputChar( lpdv, lpstr, len, rcID)
#endif
LPDV	lpdv;
LPSTR	lpstr;
short	len;
short	rcID;
{

    short rSize = 0;

    if (rcID == 6 || rcID == 8)
    {
        LPSTR lpChar = lpstr, 
              lpStrTmp = lpstr;
        WORD  fLeadByteFlag = TRUE;
        int   i, j;

        for (i = 0,j = 0; i < len; j ++, i++, lpChar++)
        { 
            if (!IsDBCSLeadBytePAGES((BYTE)*lpChar)) // SBCS
            {
                if (fLeadByteFlag)
                    {
                    WriteSpoolBuf(lpdv, lpStrTmp, j);
                    WriteSpoolBuf(lpdv, ESC_VERT_OFF, sizeof(ESC_VERT_OFF));
                    lpStrTmp += j;
                    j = 0;
                    fLeadByteFlag = FALSE;
                    rSize += sizeof(ESC_VERT_OFF);
                    }
            }
            else                                 // DBCS
            {
                if (!fLeadByteFlag)
                    {
                    WriteSpoolBuf(lpdv,  lpStrTmp, j);
                    WriteSpoolBuf(lpdv, ESC_VERT_ON, sizeof(ESC_VERT_ON));
                    lpStrTmp += j;
                    j = 0;
                    fLeadByteFlag = TRUE;
                    rSize += sizeof(ESC_VERT_ON);
                    }
                j ++; i++; lpChar++;
            }
        } 
        WriteSpoolBuf(lpdv, lpStrTmp, j);
    }
    else
        WriteSpoolBuf(lpdv, lpstr, len);

    return len+rSize;

}

#ifndef WINNT
short FAR PASCAL Enable( lpdv, style, lpModel, lpPort, lpStuff)
LPDV    lpdv;
WORD    style;
LPSTR   lpModel;
LPSTR   lpPort;
LPDM    lpStuff;
{
    CUSTOMDATA      cd;
    short           sRet;
    LPPAGES         lpPages;


    cd.cbSize               = sizeof( CUSTOMDATA );
    cd.hMd                  = GetModuleHandle( (LPSTR)rgchModuleName );
    cd.fnOEMDump            = NULL;
    cd.fnOEMOutputChar      = (LPFNOEMOUTPUTCHAR)OEMOutputChar;

    // In order to the Style vlalue, following process is performed.
    //      0x0000 Initialize device block.
    //      0x0001 Inquire Device GDIINFO.
    //      0x8000 Initialize device block without output. CreateIC()
    //      0x8001 Inquire Device GDIINFO without output.  CreateIC()

    sRet = UniEnable( lpdv, style, lpModel, lpPort, lpStuff, &cd );

    if (style == 0x0000)
    {
        lpdv->fMdv = FALSE;
        if (!(lpPages = lpdv->lpMdv = GlobalAllocPtr(GHND,sizeof(PAGES))))
        {
            UniDisable( lpdv );
            return FALSE;
        }
        lpdv->fMdv = TRUE;

        lpPages->sHorzRes = usHorzRes;
        lpPages->sVertRes = usVertRes;
        
    } else 
    if( style == 0x0001)
    {
        //INQUIREINFO
        usHorzRes = ((LPGDIINFO)lpdv)->dpAspectX;
        usVertRes = ((LPGDIINFO)lpdv)->dpAspectY;

    }

   return sRet;
}

//-------------------------------------------------------------------
// Function: Disable()
// Action  : free Mdv and call Mdv
//-------------------------------------------------------------------
void FAR PASCAL Disable(lpdv)
LPDV lpdv;
{
    if (lpdv->fMdv)
    {
        GlobalFreePtr (lpdv->lpMdv);
        lpdv->fMdv = FALSE;
    }

    UniDisable(lpdv);
}
#else //WINNT
/*************************** Function Header *******************************
 *  MiniDrvEnablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
BOOL
MiniDrvEnablePDEV(
LPDV      lpdv,
ULONG    *pdevcaps)
{
    LPPAGES   lpPages;


        usHorzRes = (short)((PGDIINFO)pdevcaps)->ulAspectX;
        usVertRes = (short)((PGDIINFO)pdevcaps)->ulAspectY;

        lpdv->fMdv = FALSE;
        if (!(lpPages = lpdv->lpMdv = UniDrvAllocMem(sizeof(PAGES))))
        {
            return FALSE;
        }
        if (!(lpPages->lpCompBuf = UniDrvAllocMem(MAXIMGSIZE)))
        {
            return FALSE;
        }
        lpdv->fMdv = TRUE;

        lpPages->sHorzRes = usHorzRes;
        lpPages->sVertRes = usVertRes;


    return TRUE;


}
/*************************** Function Header *******************************
 *  MiniDrvDisablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
VOID
MiniDrvDisablePDEV(
LPDV lpdv)
{

    if (lpdv->fMdv)
    {
        UniDrvFreeMem(((LPPAGES)(lpdv->lpMdv))->lpCompBuf);
        UniDrvFreeMem(lpdv->lpMdv);
        lpdv->fMdv = FALSE;
    }

}

#endif //WINNT


/*f***************************************************************************/
/*  PAGES PRINTER DRIVER for MS-Windows95                                    */
/*                                                                           */
/*  F  CBFilterGraphics                                                 */
/*                                                                           */
/*  @\F  ESX86gpoB                        */
/*                                                                           */
/*  F  WORD FAR PASCAL CBFilterGraphics(lpdv, lpBuf, wLen)              */
/*                                                                           */
/*  F  LPDV     lpdv      UNIDRV.DLLgpPDEVICE\             */
/*          LPSTR    lpBuf                     */
/*          WORD     wLen      lpBuf()                           */
/*                                                                           */
/*                                                                           */
/*  oF  return             o  @                            */
/*                                                                           */
/*  LF                                                                   */
/*                                                                           */
/*  F  1995.11.xx  Ver 1.00                                             */
/*****************************************************************************/
WORD FAR PASCAL CBFilterGraphics (lpdv, lpBuf, wLen)
LPDV      lpdv;     // Points to private data required by the Unidriver.dll
LPSTR     lpBuf;    // points to buffer of graphics data
WORD      wLen;     // length of buffer in bytes

{  
    LPSTR   lpCompImage;
    WORD    wCompLen;
    LONG    lHorzPixel;
    WORD    wLength;      // Let's use a temporary LEN
    LPPAGES lpPages = lpdv->lpMdv;

//#define MAXIMGSIZE  0x7FED          // 32K-18 bytes
static BYTE params[] = {(0x1B), (0x7E), (0x86), 00,00, 01, 00, 00,00,00,00, 00,00,00,00, 00,00,00,00, 00,00,00,01};


    /*_ LPDV */
    lpCompImage = lpPages->lpCompBuf;

    /*_ iISIZvZB */
    lHorzPixel = (LONG)(wLen * 8);

    /*_ C[Wf[^Btye Run Length AlgorithmkB */
    wCompLen = RL_ECmd((LPBYTE)lpBuf, (LPBYTE)lpCompImage, wLen);

    /*_ kESX86LENOB */
    wLength = wCompLen + 18;

    /*_ ESX86R}hLENZbgB */
    params[3] = (BYTE) (wLength >>8 & 0x00ff);    // get higher byte
    params[4] = (BYTE) (wLength & 0x00ff);        // get lower byte

    /*_ k@p[^Byte Run LengthZbgB */
    params[6] = 0x02;

    /*_ ESX86R}hISIZZbgB */
    params[17] = (BYTE) (lHorzPixel >> 8 & 0x000000ffL);   // get ISZ higher byte
    params[18] = (BYTE) (lHorzPixel & 0x000000ffL);        // get ISZ lower byte

    /*_ ESX86R}hXv[oB */
    WriteSpoolBuf((LPDV)lpdv, (LPSTR)params, 23);

    /*_ kf[^Xv[oB */
    WriteSpoolBuf((LPDV)lpdv, lpCompImage, wCompLen);

    return wLen;
}

// The following is implemented in MiniDrvEnablePDEV/DisablePDEV
// on NT-J.  We do not simulate Control DDI call, and it is not
// guranteed that STARTOC, etc. always corresponds to minidriver
// enable/disable.

#ifndef WINNT

/*f***************************************************************************/
/*  PAGES PRINTER DRIVER for MS-Windows95                                    */
/*                                                                           */
/*  F  Control                                                          */
/*                                                                           */
/*  @\F  Calls Escape function from applications		                     */
/*                                                                           */
/*  F  short FAR PASCAL Control(lpdv, nFunction,                        */
/*                                             lpInData, lpOutData)          */
/*                                                                           */
/*  F  LPDV        lpdv        PDEVICE structure                        */
/*          WORD        function    Subfunction ID                           */
/*          LPSTR       lpInData    Input data                               */
/*          LPSTR       lpOutData   Output data                              */
/*                                                                           */
/*  oF  short ret   Positive :    Normal exit                            */
/*                      Negative :    Error exit                             */
/*                      FALSE  :      No escape subfunction                  */
/*                                                                           */
/*  LF  nFunction and Escape numbers are the same                        */
/*                                                                           */
/*  F  1995.12.xx  Ver 1.00                                             */
/*                                                                           */
/*****************************************************************************/
short FAR PASCAL Control(LPDV  lpdv,
                         WORD  function,
                         LPSTR lpInData,
                         LPSTR lpOutData)
{
    LPPAGES lpPages = lpdv->lpMdv;

    switch (function)
    {
        /*_ STARTDOCAkpmB */
        case STARTDOC :
            lpPages->lpCompBuf = GlobalAllocPtr(GHND,MAXIMGSIZE);
            break;

        /*_ ABORTDOC,ENDDOCAkpB */
        case ABORTDOC :
        case ENDDOC :
            GlobalFreePtr (lpPages->lpCompBuf);
            break;
    }

    /*_ UNIDRVControl DDI */
    return UniControl(lpdv, function, lpInData, lpOutData);
}
#endif //!WINNT


#ifdef WINNT
DRVFN  MiniDrvFnTab[] =
{
    {  INDEX_MiniDrvEnablePDEV,       (PFN)MiniDrvEnablePDEV  },
    {  INDEX_MiniDrvDisablePDEV,      (PFN)MiniDrvDisablePDEV  },
    {  INDEX_OEMWriteSpoolBuf,        (PFN)CBFilterGraphics  },
    {  INDEX_OEMSendScalableFontCmd,  (PFN)OEMSendScalableFontCmd  },
    {  INDEX_OEMScaleWidth1,          (PFN)OEMScaleWidth  },
    {  INDEX_OEMOutputChar,           (PFN)OEMOutputChar  }
};

BOOL
MiniDrvEnableDriver(
    MINIDRVENABLEDATA  *pEnableData
    )
{
    if (pEnableData == NULL)
        return FALSE;

    if (pEnableData->cbSize == 0)
    {
        pEnableData->cbSize = sizeof (MINIDRVENABLEDATA);
        return TRUE;
    }

    if (pEnableData->cbSize < sizeof (MINIDRVENABLEDATA)
            || HIBYTE(pEnableData->DriverVersion)
            < HIBYTE(MDI_DRIVER_VERSION))
    {
        // Wrong size and/or mismatched version
        return FALSE;
    }

    // Load callbacks provided by the Unidriver

    if (!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvWriteSpoolBuf, (PFN *) &WriteSpoolBuf)
        ||!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvAllocMem, (PFN *) &UniDrvAllocMem)
        ||!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvFreeMem, (PFN *) &UniDrvFreeMem))
    {
        return FALSE;
    }

    pEnableData->cMiniDrvFn
        = sizeof (MiniDrvFnTab) / sizeof(MiniDrvFnTab[0]);
    pEnableData->pMiniDrvFn = MiniDrvFnTab;

    return TRUE;
}

#endif //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pagesres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR_IBM=$(PRNROOT)\gpd\ibm\$(ALT_PROJECT)
GPDDIR_CAN=$(PRNROOT)\gpd\canon\$(ALT_PROJECT)
GPDDIR_APT=$(PRNROOT)\gpd\apti\$(ALT_PROJECT)
GPDDIR_TEC=$(PRNROOT)\gpd\tec\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=pagesres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),pagesres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\pagesres.rc \
    $(SRCDIR)\pagesres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\pagesres.ini \
    $(GPDDIR_APT)\ate740j.gpd \
    $(GPDDIR_APT)\ate74hj.gpd \
    $(GPDDIR_CAN)\cn5585ij.gpd \
    $(GPDDIR_IBM)\ib5584gj.gpd \
    $(GPDDIR_IBM)\ib5584kj.gpd \
    $(GPDDIR_IBM)\ib5585hj.gpd \
    $(GPDDIR_IBM)\ib5586hj.gpd \
    $(GPDDIR_IBM)\ib5587hj.gpd \
    $(GPDDIR_IBM)\ib5587kj.gpd \
    $(GPDDIR_IBM)\ib5588hj.gpd \
    $(GPDDIR_IBM)\ib5589hj.gpd \
    $(GPDDIR_IBM)\ib5589kj.gpd \
    $(GPDDIR_IBM)\ibipp20j.gpd \
    $(GPDDIR_IBM)\ibnpp12j.gpd \
    $(GPDDIR_IBM)\ibnpp17j.gpd \
    $(GPDDIR_IBM)\ibnpp24j.gpd \
    $(GPDDIR_TEC)\telbp35j.gpd \
    $(GPDDIR_TEC)\telb450j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pcl4kres\etc\strings.h ===
// STRINGS.H
//
// IDs for string contants used within the minidriver. Start these nice
// and high, so avoid conflicts with strings from within the minidriver

#define IDS_SOFTFONTWARNING   4890
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pcl4jres\etc\pcl4msj.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//
//-----------------------------------------------------------------------------

#include "strings.h"


// #define CONVERT_FROM_WIN30

char *rgchModuleName   = "PCL4MSJ";
char szSoftFonts[]     = "SoftFonts";

#ifdef CONVERT_FROM_WIN30
char szPrtIndex[]      = "prtindex";
char szWinVer[]        = "winver";
char sz310[]           = "310";
char sz150[]           = "150";
char sz75[]            = "75";
char szNull[]          = "";
char szOrient[]        = "orient";
char szOrientation[]   = "Orientation";
char szPaper[]         = "paper";
char szPaperSize[]     = "Paper Size";
char szPrtResFac[]     = "prtresfac";
char szPrintQuality[]  = "Print Quality";
char szTray[]          = "tray";
char szDefaultSource[] = "Default Source";
char szNumCart[]       = "numcart";
char szCartIndex[]     = "cartindex";
char szCartridge[]     = "Cartridge ";
char szNumberCart[]    = "Number of Cartridges";
char szFsVers[]        = "fsvers";
char szFontSummary[]   = "Font Summary";

// map old HPPCL's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL .rc file.
int rgNewCartMap[9] = {8, 7, 2, 3, 5, 6, 1, 4, 0};

#endif


#define PRINTDRIVER
#include "print.h"
#include "gdidefs.inc"
#include "mdevice.h"



#define DELETE_OLD

#ifndef WINNT
HDC   FAR PASCAL CreateIC(LPCSTR, LPCSTR, LPCSTR, const VOID FAR*);
BOOL  FAR PASCAL DeleteDC(HDC);
#endif // !WINNT

#include "unidrv.h"


#ifndef WINNT
extern char *rgchModuleName;	// global module name

// typedef for soft font installer
typedef int (FAR PASCAL *SFPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

#define SOFT_FONT_THRES 25	    // build font summary, if over this limit
#define MAX_CART_INDEX	33
#define MAX_OLD_CART	24
#define TMPSIZE         256

HINSTANCE hInst;

#ifdef PRTCAPSTUFF

char szPrtCaps[]       = "prtcaps";

#define MAX_NUM_MODELS	24
#define MAX_MODEL_NAME	29
typedef struct
    {
    char szModel[MAX_MODEL_NAME];
    int  rgIndexLimit[2];
    char szPrtCaps[7];	    // keep as a string instead of integer to avoid
			    // conversion because itoa doesn't work here.
    } MODELMAP, FAR * LPMODELMAP;



//-------------------------------------------------------------------
// Function: DoPrtCapsStuff(lpDevName,lpPort)
//
// Action: Write out PRTCAPS under [<model>,<port>] section
//         in order to be backward-compatible with existing font
//         packages. Note that this code can fail
//         under extremely low memory conditions, so be sure and check
//         the return values from the resource calls.
//-------------------------------------------------------------------
void NEAR PASCAL DoPrtCapsStuff(LPSTR lpDevName,
                                LPSTR lpPort)
{
  char szOldSec[64];
  int  i;
  HANDLE  hMd;
  HANDLE  hResMap;
  LPMODELMAP	lpModelMap;


  lstrcpy(szOldSec,lpDevName);
  MakeAppName((LPSTR)szOldSec,lpPort,sizeof(szOldSec));

  hMd=GetModuleHandle((LPSTR)rgchModuleName);
  hResMap=LoadResource(hMd,FindResource(hMd,MAKEINTRESOURCE(1),RT_RCDATA));
  if(hResMap)
  {
    if(lpModelMap=(LPMODELMAP)LockResource(hResMap))
    {
      for (i=0;i<MAX_NUM_MODELS;i++)
      {
        if (!lstrcmp(lpDevName,(LPSTR)(lpModelMap[i].szModel)))
        {
          WriteProfileString((LPSTR)szOldSec,szPrtCaps,
                            (LPSTR)lpModelMap[i].szPrtCaps);
          break;
        }
      }
      UnlockResource(hResMap);
    }
    FreeResource(hResMap);
  }
}


#endif

//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
		    WORD   wDataSeg,
		    WORD   cbHeapSize,
		    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}




//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
  short   length, count;
  LPCSTR  lpTmp;
  LPCSTR  lpLastColon = NULL;

  length = lstrlen(lpAppName);

  if (!lpPortName)
    return length;

  if (length == 0 || length > max - lstrlen(lpPortName))
    return -1;

  // insert the comma
  lpAppName[length++] = ',';

  // append the port name but do not want the last ':', if any.
  for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
    if (*lpTmp == ':')
      lpLastColon = lpTmp;
    if (lpLastColon && lpLastColon == lpTmp - 1)
      count = lpLastColon - lpPortName;
    else
      count = lpTmp - lpPortName;

  lstrcpy((LPSTR)&lpAppName[length], lpPortName);

  length += count;
  lpAppName[length]='\0';

  return length;
}

#ifdef CONVERT_FROM_WIN30

//------------------------------------------------------------------------------
// Function: itoa
//
// Action:  This function converts the given integer into an ASCII string.
//
// return:  The length of the string.
//-----------------------------------------------------------------------------

short NEAR PASCAL itoa(buf, n)
LPSTR buf;
short n;
{
    short   fNeg;
    short   i, j;

    if (fNeg = (n < 0))
	n = -n;

    for (i = 0; n; i++)
	{
	buf[i] = (char)(n % 10 + '0');
	n /= 10;
	}

    // n was zero
    if (i == 0)
	buf[i++] = '0';

    if (fNeg)
	buf[i++] = '-';

    for (j = 0; j < i / 2; j++)
	{
	short tmp;

	tmp = buf[j];
	buf[j] = buf[i - j - 1];
	buf[i - j - 1] = (char)tmp;
	}

    buf[i] = 0;

    return i;
}

#endif


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------

int FAR PASCAL DevInstall(hWnd, lpDevName, lpOldPort, lpNewPort)
HWND	hWnd;
LPSTR	lpDevName;
LPSTR	lpOldPort, lpNewPort;
{
    char szOldSec[64];
    int  nReturn=1;

    if (!lpDevName)
	    return -1;

    if (!lpOldPort)
	{
#ifdef CONVERT_FROM_WIN30
        char szNewSec[64];
	    char szBuf[32];
	    int  tmp;
	    int  i, index;
	    HANDLE	hMd;
	    HANDLE	hResMap;
	    LPMODELMAP  lpModelMap;
#endif

	    if (!lpNewPort)
	        return 0;

#ifdef CONVERT_FROM_WIN30
	    // install a device for the first time. Convert old HPPCL settings,
	    // which are still under [<driver>,<port>], into equivalent new
	    // UNIDRV settings under [<device>,<port>], if applicable.
	    // All soft fonts are left under the section [<driver>,<port>].
	    lstrcpy(szOldSec,rgchModuleName);
	    MakeAppName((LPSTR)szOldSec, lpNewPort, sizeof(szOldSec));

	    // if old section exists at all
	    if (!GetProfileString(szOldSec, NULL, NULL, szBuf, sizeof(szBuf)))
	        goto DI_exit;

	    // make sure the old device settings are for this device.
	    // If not, there is nothing to do here. Simply return 1.
	    tmp = GetProfileInt(szOldSec, szPrtIndex, 0);
	    hMd = GetModuleHandle((LPSTR)rgchModuleName);
	    hResMap = LoadResource(hMd,
			    FindResource(hMd, MAKEINTRESOURCE(1), RT_RCDATA));
	    lpModelMap = (LPMODELMAP)LockResource(hResMap);
	    for (i = 0; i < MAX_NUM_MODELS; i++)
        {
	        if (!lstrcmp(lpDevName, (LPSTR)lpModelMap[i].szModel))
		    {
		        if ((tmp < lpModelMap[i].rgIndexLimit[0]) ||
		            (tmp > lpModelMap[i].rgIndexLimit[1]) )
		            i = MAX_NUM_MODELS;        // not this model. No conversion.
		        break;
		    }
        }

	    UnlockResource(hResMap);
	    FreeResource(hResMap);

	    if (i >= MAX_NUM_MODELS)
	        // this model is not even listed in the old HPPCL driver.
	        goto DI_exit;

	    if (GetProfileInt(szOldSec, szWinVer, 0) == 310)
	        goto DI_exit;

	    WriteProfileString(szOldSec, szWinVer, sz310);
#ifdef DELETE_OLD
	    WriteProfileString(szOldSec, szPrtIndex, NULL);
#endif

	    lstrcpy(szNewSec, lpDevName);
	    MakeAppName((LPSTR)szNewSec, lpNewPort, sizeof(szNewSec));

	    // convertable device settings include: copies, duplex, orient,
	    // paper, prtresfac, tray, and cartidges.

	    if (GetProfileString(szOldSec, szOrient, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szOrientation, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szOrient, NULL);
#endif
        }
	    if (GetProfileString(szOldSec, szPaper, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szPaperSize, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szPaper, NULL);
#endif
        }

	    // default to 2 if cannot find it
	    tmp = GetProfileInt(szOldSec, szPrtResFac, 2);

	    if (tmp == 1)
	        WriteProfileString(szNewSec, szPrintQuality, sz150);
	    else if (tmp == 2)
	        WriteProfileString(szNewSec, szPrintQuality, sz75);

#ifdef DELETE_OLD
	    WriteProfileString(szOldSec, szPrtResFac, NULL);
#endif

	    if (GetProfileString(szOldSec, szTray, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szDefaultSource, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szTray, NULL);
#endif
        }

	    // try to convert the cartridge information.

	    if ((tmp = GetProfileInt(szOldSec, szNumCart, 0)) == 0)
	        tmp = 1;

	    // this is executed at least once
	    {
	        char szOldCartKey[16];
	        char szNewCartKey[16];
	        char nCart = 0;

	        lstrcpy(szOldCartKey, szCartIndex);

	        for (i = 0; i < tmp; i++)
	        {
	            if (i > 0)
                    itoa((LPSTR)&szOldCartKey[9], i);
	            // compose cartridge keyname under UNIDRV.
	            lstrcpy(szNewCartKey, szCartridge);
	            itoa((LPSTR)&szNewCartKey[10], i + 1);

	            if ((index = GetProfileInt(szOldSec, szOldCartKey, 0)) > 0)
		        {
		            WriteProfileString(szOldSec, szOldCartKey, NULL);
		            nCart++;
		            if (index <= MAX_OLD_CART)
		            {
		                itoa((LPSTR)szBuf, index + 8);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		            else if (index <= MAX_CART_INDEX)
		            {
		                itoa((LPSTR)szBuf, rgNewCartMap[index - MAX_OLD_CART - 1]);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		            else
		            {
		                // external cartridges. Simply copy the id over.
		                itoa((LPSTR)szBuf, index);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		        }
	        }

	        // integer to ASCII string conversion.
	        itoa((LPSTR)szBuf, nCart);
	        WriteProfileString(szNewSec, szNumberCart, szBuf);
	    }

	    // delete the old font summary file
	    WriteProfileString(szOldSec, szFsVers, NULL);
	    if (GetProfileString(szOldSec, szFontSummary, szNull, szBuf, sizeof(szBuf)) > 0)
	    {
	        int hFS;

	        // truncate the old font summary file to zero size.
	        if ((hFS = _lcreat(szBuf, 0)) >= 0)
		        _lclose(hFS);
	        WriteProfileString(szOldSec, szFontSummary, NULL);
	    }

            // create UNIDRV's font summary file, if there are many soft fonts.
	    if (GetProfileInt(szOldSec, szSoftFonts, 0) > SOFT_FONT_THRES)
	    {
	        HDC hIC;

	        if (hIC = CreateIC("PCL4MSJ", lpDevName, lpNewPort, NULL))
		        DeleteDC(hIC);
	    }
#endif
	}
    else

    {

	// move device settings from the old port to the new port, or
	// de-install a device, i.e. remove its device setttings in order
	// to compress the profile.

	// First, check if there is any  soft font installed under the
	// old port. If so, warn the user to copy them over.

	lstrcpy(szOldSec, rgchModuleName);
	MakeAppName((LPSTR)szOldSec, lpOldPort, sizeof(szOldSec));
	if (GetProfileInt(szOldSec, szSoftFonts, 0) > 0 && lpNewPort)
	{
            LPBYTE lpTemp;

            if(lpTemp=GlobalAllocPtr(GMEM_MOVEABLE,TMPSIZE))
	    {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,lpTemp,TMPSIZE))
		{
		    // Use this API so that the M Box is set to the Foreground
		    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
		    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = lpTemp;
		    mbp.lpszCaption = lpOldPort;
		    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
		    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
		GlobalFreePtr (lpTemp);
	    }
	}
    nReturn=UniDevInstall(hWnd, lpDevName, lpOldPort, lpNewPort);
    }


#ifdef CONVERT_FROM_WIN30
DI_exit:
#endif

#ifdef PRTCAPSTUFF

    DoPrtCapsStuff(lpDevName,lpNewPort);

#endif

    return nReturn;
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(hWnd, lpDeviceName, lpPortName, bSoftFonts)
HWND	hWnd;
LPSTR	lpDeviceName;
LPSTR	lpPortName;
BOOL	bSoftFonts;
{
    int     fsVers;
    HANDLE  hFIlib;
    SFPROC  lpFIns;

    if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    	!(lpFIns = (SFPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
	{
	    if (hFIlib >= 32)
	        FreeLibrary(hFIlib);
#ifdef DEBUG
	    MessageBox(0,
	        "Can't load FINSTALL.DLL or can't get InstallSoftFont",
	        NULL, MB_OK);
#endif
	    return TRUE;
	}

    // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
    // We choose to ignore the returned fvers. No use of it.
    fsVers = (*lpFIns)(hWnd, rgchModuleName, lpPortName,
		(GetKeyState(VK_SHIFT) < 0 && GetKeyState(VK_CONTROL) < 0),
		1,	  // dummy value for fvers.
		bSoftFonts ? CLASS_LASERJET : 256
		);
    FreeLibrary(hFIlib);
    return fsVers;
}


#endif // !WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pcl4kres\etc\jp3500p.c ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//-----------------------------------------------------------------------------


#include "strings.h"

char *rgchModuleName = "JP3500P";
char szNone[]="";

// The following are defined to ensure that we upgrade correctly from the
// HPPCL5a, HPPCL5e and Win 3.11 HPPCL5MS drivers

#define MAX_LJ4_MBMEMSETTING    68    // from HP tech specification
#define KB_THRESHOLD            200   // kb range check,needed for conversion


#define PRINTDRIVER
#include <print.h>
#include "gdidefs.inc"
#include "mdevice.h"
#include "unidrv.h"
#include "minidriv.h"

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#define MB_SETFOREGROUND    0x00010000
#if (WINVER >= 0x0400)
typedef void (CALLBACK *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

typedef struct tagMSGBOXPARAMS
{
    DWORD           cbSize;
#ifdef tagWND
    HWND_16         hwndOwner;
#else
    HWND            hwndOwner;
#endif
    HINSTANCE       hInstance;
    LPCSTR          lpszText;
    LPCSTR          lpszCaption;
    DWORD           dwStyle;
    LPCSTR          lpszIcon;
    DWORD           dwContextHelpId;
    MSGBOXCALLBACK  lpfnMsgBoxCallback;
    DWORD           dwLanguageId;
}   MSGBOXPARAMS, FAR *LPMSGBOXPARAMS;

int     WINAPI MessageBoxIndirect(LPMSGBOXPARAMS);
#endif /* WINVER >=0x0400 */

short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

// typedef for atom stuff--what a nuisance!
typedef struct tagSFNODE
{
    WORD wIndex;
    ATOM atom;
} SFNODE, FAR *LPSFNODE;

// Typedef for Font Installer procedure
typedef int (FAR * PASCAL SOFTFONTPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

HINSTANCE hInst;

#define DEFAULT_INT      32767

#define SOFT_FONT_THRES  25  // build font summary, if over this limit

#define MAX_CART_INDEX	 12

#define TMPSIZE         256

// Define these so they happily use the same values as the HPPCL5E driver.
#define GS_PHOTO     0
#define GS_LINEART   1
#define GS_SCANJET   2


// map old HPPCL5a's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL5a .rc file.
// Note that we do not have "International Collection" cartridge and we
// map it to index 0 (arbitrarily).
int rgNewCartMap[12] = {0, 8, 7, 2, 3, 0, 5, 6, 1, 4, 9, 10};

// String to determine if we have a member of the LaserJet 4 family
char szLJ4[]="HP LaserJet 4";

// Stuff needed for mapping old facenames to new versions
#ifndef NOFONTMAP

typedef struct tagFACEMAP
{
    char szOldFace[LF_FACESIZE];
    char szNewFace[LF_FACESIZE];
} FACEMAP, NEAR * NPFACEMAP;

typedef struct tagFACEINDEX
{
    BYTE cFirstChar;
    BYTE bIndex;
} FACEINDEX, NEAR * NPFACEINDEX;

FACEMAP FaceMap[]={{"Albertus (W\x01)",         "Albertus Medium"},
                   {"Albertus Xb (W\x01)",      "Albertus Extra Bold"},
                   {"Antique Olv (W\x01)",      "Antique Olive"},
                   {"Antique Olv Cmpct (W\x01)","Antique Olive Compact"},
                   {"CG Bodoni (W\x01)",        "CG Bodoni"},
                   {"CG Cent Schl (W\x01)",     "CG Century Schoolbook"},
                   {"CG Omega (W\x01)",         "CG Omega"},
                   {"CG Palacio (W\x01)",       "CG Palacio"},
                   {"CG Times (W\x01)",         "CG Times"},
                   {"Clarendon Cd (W\x01)",     "Clarendon Condensed"},
                   {"Cooper Blk (W\x01)",       "Cooper Black"},
                   {"Coronet (W\x01)",          "Coronet"},
                   {"Courier (W\x01)",          "Courier"},
                   {"Garmond (W\x01)",          "Garamond"},
                   {"ITC Benguat (W\x01)",      "ITC Benguiat"},
                   {"ITC Bookman Db (W\x01)",   "ITC Bookman Demi"},
                   {"ITC Bookman Lt (W\x01)",   "ITC Bookman Light"},
                   {"ITC Souvenir Db (W\x01)",  "ITC Souvenir Demi"},
                   {"ITC Souvenir Lt (W\x01)",  "ITC Souvenir Light"},
                   {"Letter Gothic (W\x01)",    "Letter Gothic"},
                   {"Marigold (W\x01)",         "Marigold"},
                   {"Revue Lt (W\x01)",         "Revue Light"},
                   {"Shannon (W\x01)",          "Shannon"},
                   {"Shannon Xb (W\x01)",       "Shannon Extra Bold"},
                   {"Stymie (W\x01)",           "Stymie"},
                   {"Univers (W\x01)",          "Univers"},
                   {"Univers Cd (W\x01)",       "Univers Condensed"}};


FACEINDEX FaceIndex[]={{'A',0},
                       {'C',4},
                       {'G',13},
                       {'I',14},
                       {'L',19},
                       {'M',20},
                       {'R',21},
                       {'S',22},
                       {'U',25},
                       {(BYTE)'\xFF',27}};  // Provide an upper limit
                                            // to the search for 'U'.

#endif


//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
                    WORD   wDataSeg,
                    WORD   cbHeapSize,
                    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}


//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
    short   length, count;
    LPCSTR  lpTmp;
    LPCSTR  lpLastColon = NULL;

    length = lstrlen(lpAppName);

    if (!lpPortName)
        return length;

    if (length == 0 || length > max - lstrlen(lpPortName))
        return -1;

    // insert the comma
    lpAppName[length++] = ',';

    // append the port name but do not want the last ':', if any.
    for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
        if (*lpTmp == ':')
            lpLastColon = lpTmp;
        if (lpLastColon && lpLastColon == lpTmp - 1)
            count = lpLastColon - lpPortName;
        else
            count = lpTmp - lpPortName;

    lstrcpy((LPSTR)&lpAppName[length], lpPortName);

    length += count;
    lpAppName[length]='\0';

    return length;
}

#define KEY_BUF_SIZE  256


//---------------------------------------------------------------------------
// Function: GetInt(lpSection,lpKey,lpnValue,nDefault,bRemove)
//
// Action: Load the appropriate string from the resources, then get the
//         specified integer from the section. Remove the old entry if
//         it exists and it bRemove is TRUE.
//
// Return: TRUE if we actually found a value, FALSE if not.
//---------------------------------------------------------------------------
BOOL NEAR PASCAL GetInt(LPSTR  lpSection,
                        LPCSTR lpKey,
                        LPINT  lpnValue,
                        int    nDefault,
                        BOOL   bRemove)
{
    char szKeyName[60];
    int  nTest;

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    nTest=GetProfileInt(lpSection,szKeyName,DEFAULT_INT);

    if(DEFAULT_INT != nTest)
    {
        *lpnValue=nTest;

        if(bRemove)
            WriteProfileString(lpSection,szKeyName,NULL);

        return TRUE;
    }

    // Section doesn't exist--use default
    *lpnValue=nDefault;
    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteInt(lpSection,lpKey,nValue)
//
// Action: Write an integer value to the specified section of win.ini.
//
// Return: TRUE if successful, FALSE if not.
//-------------------------------------------------------------------------
BOOL NEAR PASCAL WriteInt(LPSTR  lpSection,
                          LPCSTR lpKey,
                          int    nValue)
{
    char szKeyName[60];
    char szValue[10];

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    wsprintf(szValue,"%u",nValue);

    return WriteProfileString(lpSection,szKeyName,szValue);
}


//---------------------------*MergeFontLists*-----------------------------
// Action: Merge the old and new soft fonts. In most cases when we get
//         called, we really don't do much of anything, because the
//         font lists are identical. However, we have to do some fun
//         stuff to merge the lists if they're different.
//         We know how many soft font entries exist in each section,
//         via the "SoftFonts" int, but the entries may be non-consecutive.
//
// Note:   This stomps all over the passed in buffer
//
// Return: TRUE if successfully conpleted, FALSE if not
//------------------------------------------------------------------------
BOOL NEAR PASCAL MergeFontLists(LPSTR lpOldSec,
                                LPSTR lpNewSec,
                                LPSTR lpTmp)
{
    WORD     wOldFonts;
    WORD     wNewFonts;
    LPSFNODE lpFonts;
    WORD     wMergedFonts=0;
    WORD     wLoop;
    WORD     wFound;
    WORD     wNewIndex;
    BYTE     szKey[20];

    // Get these values outside of the if statement, otherwise the compiler
    // may optimize out the assignment of wNewFonts
    GetInt(lpOldSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wOldFonts,0,FALSE);
    GetInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wNewFonts,0,FALSE);

    if(wOldFonts || wNewFonts)
    {
        char szFormat[30];

        // Get a block big enough for the worst case--no common fonts
        if(!(lpFonts=(LPSFNODE)GlobalAllocPtr(GHND,
            (DWORD)(wOldFonts+wNewFonts)*sizeof(SFNODE))))
        {
            return FALSE;
        }

        // We need a formatting string
        LoadString(hInst,IDS_SOFTFONTFORMAT,szFormat,sizeof(szFormat));

        // Put fonts from lpNew Sec first in the list. This way, if we have
        // already updated at least one driver from 5A to 5MS and the soft
        // fonts haven't changed, our old font summary file is still valid.
        // Unidrv will automatically recreate the font summary file if it
        // sees that the number of soft fonts has changed. Even though we
        // know how many soft font entries exist, we don't know that they
        // will be sequential. (They may not be if one was added, then
        // deleted). Keep track of the original offset. Even though the
        // font installer seems to be 1-based, start looking at 0, just
        // to be safe.
        for(wLoop=0,wFound=0;wFound<wNewFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpNewSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                lpFonts[wMergedFonts].wIndex=wLoop;
                lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                wFound++;
            }
        }
    
        // Remember where we left off in numbering the entries
        wNewIndex=wLoop;

        // Read fonts from lpOldSec--create atoms for new entries
        for(wLoop=0,wFound=0;wFound<wOldFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpOldSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                wFound++;
                if(!GlobalFindAtom(lpTmp))
                {
                    lpFonts[wMergedFonts].wIndex=wLoop;
                    lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                }
            }
        }

        // Write out the list of atoms--do the entries from lpNewSec first
        WriteInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),wMergedFonts);
        for(wLoop=0;wLoop<wNewFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,lpFonts[wLoop].wIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
        }

        // Now write out the entries that were in lpOldSec but not in lpNewSec.
        // Since the actual numbering of these entries is arbitrary, just
        // start numbering them at wNewIndex and increment each time.
        for(wLoop=wNewFonts;wLoop<wMergedFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,wNewIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
            wNewIndex++;
        }

        GlobalFreePtr(lpFonts);
    }

    return TRUE;
}


//----------------------*AddMissingEntries*-----------------------------
// Action: Copy any entries that appear in lpOldSec but not lpNewSec to
//         lpNewSec, but don't copy any entries relevant to soft fonts
//         (These entries will be copied in MergeFontSections).
//
// Return: TRUE if successful, FALSE if not
//----------------------------------------------------------------------
BOOL NEAR PASCAL AddMissingEntries(LPSTR lpOldSec,
                                   LPSTR lpNewSec,
                                   LPSTR lpTmp)
{
    WORD  wSize;
    LPSTR lpBuf;
    LPSTR lpWork;
    char  szTest2[30];
    char  szTest1[30];
    int   nLength;

    // Get the key names into buffers
    wSize=KEY_BUF_SIZE;

    if(!(lpBuf=GlobalAllocPtr(GHND,(DWORD)wSize)))
        return FALSE;
    while((WORD)GetProfileString(lpOldSec,NULL,szNone,lpBuf,wSize)==wSize-2)
    {
        wSize*=2;
        if(lpWork=GlobalReAllocPtr(lpBuf,(DWORD)wSize,GHND))
            lpBuf=lpWork;
        else
        {
            GlobalFreePtr(lpBuf);
            return FALSE;
        }
    }

    // Load some strings
    LoadString(hInst,IDS_FONTSUMMARY,szTest1,sizeof(szTest1));
    nLength=LoadString(hInst,IDS_SOFTFONTTEST,szTest2,sizeof(szTest2));

    // Now examine each entry, copy it if we want to keep it, and return TRUE
    // There are two cases where we don't want to copy the file--the key
    // named FontSummary and all keys that begin with "SoftFont"
    lpWork=lpBuf;
    while(wSize=(WORD)lstrlen(lpWork))
    {
        // Font Summary?
        if(lstrcmpi(lpWork,szTest1))
        {
            // Soft Font Entry?
            lstrcpy(lpTmp,lpWork);
            lpTmp[nLength]='\0';
            if(lstrcmpi(lpTmp,szTest2))
            {
                // Add this entry if it doesn't already exist in the new section
                if(!GetProfileString(lpNewSec,lpWork,szNone,lpTmp,TMPSIZE))
                {
                    GetProfileString(lpOldSec,lpWork,szNone,lpTmp,TMPSIZE);
                    WriteProfileString(lpNewSec,lpWork,lpTmp);
                }
            }
        }
        lpWork+=(wSize+1);
    }

    GlobalFreePtr(lpBuf);
    return TRUE;
}


//---------------------------*HandleSoftFonts*---------------------------
// Action: Transfer the soft fonts between old and new entries. First we
//         copy any entries that don't already exist in the new section,
//         with the exception of soft font information. Then we go ahead
//         and merge the soft fonts, so the end result in the new section
//         is the union of the old and new soft fonts.
//
// Return: TRUE if success, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL HandleSoftFonts(LPSTR lpszOldSec,
                                 LPSTR lpszNewSec)
{
    char szTmp[TMPSIZE];

    if(AddMissingEntries(lpszOldSec,lpszNewSec,szTmp))
        return MergeFontLists(lpszOldSec,lpszNewSec,szTmp);

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertStraight(lpSection,nOldID,nNewID)
//
// Action: Convert a section setting without translation
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertStraight(LPSTR lpSection,
                                 int   nOldID,
                                 int   nNewID)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nValue);
        return TRUE;
    }

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertBool(lpSection,nOldID,nNewID,nNewValue)
//
// Action: Convert a section with minimal translation. If the old section
//         existed and was non-zero, write nNewValue to the new section.
//         If the old section existed and was 0, write 0 to the new section.
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertBool(LPSTR lpSection,
                             int   nOldID,
                             int   nNewID,
                             int   nNewValue)
{
    int nOldValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nOldValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nOldValue?nNewValue:0);
        return TRUE;
    }

    return FALSE;
}

//------------------------------------------------------------------------
// Function: ConvertVectorMode(lpSection)
//
// Action: Convert the graphics mode setting
//         Cannot do straight conversion as defaults dont match
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertVectorMode(LPSTR lpSection)
{
    int nValue;

    GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDVECTORMODE),&nValue,1,TRUE);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWVECTORMODE),nValue);
    return TRUE;

}



//------------------------------------------------------------------------
// Function: ConvertResolution(lpSection,lpModel)
//
// Action: Convert the old resolution section to the new one
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertResolution(LPSTR lpSection,
                                   LPSTR lpModel)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5A_RESOLUTION),&nValue,0,TRUE))
    {
        LPSTR lpLJ4=szLJ4;
        LPSTR lpCheck=lpModel;
        BOOL  bLJ4=TRUE;

        nValue=300/(1<<nValue);

        // Compare the passed-in model to szLJ4. If lpModel begins with the
        // substring "HP LaserJet 4", then lpLJ4 will point to NULL when we
        // exit the loop.
        while(*lpLJ4 == *lpCheck)
        {
            lpLJ4++;
            lpCheck++;
        }

        if(!*lpLJ4)
        {
            // This is in the LJ4 family--check if it's a 4L or 4ML
            if(lstrcmp(lpCheck,"L") && lstrcmp(lpCheck,"ML"))
            {
                int nTest;

                // Device is capable of 600 dpi--check the value for
                // "printerres".

                GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_RESOLUTION),
                    &nTest,600,TRUE);

                if(600==nTest)
                    nValue<<=1;
            }
        }

        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWRESOLUTION),nValue);
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWYRESOLUTION),nValue);

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteHalfTone(lpSection,nIndex)
//
// Action: Write the halftoning data to win.ini
//
// Return: VOID
//-------------------------------------------------------------------------
VOID NEAR PASCAL WriteHalfTone(LPSTR lpSection,
                               int   nIndex)
{
    int nBrush;
    int nIntensity;

    switch(nIndex)
    {
        case GS_LINEART:
            nBrush=RES_DB_LINEART;
            nIntensity=100;
            break;

        case GS_SCANJET:
            nBrush=RES_DB_COARSE;
            nIntensity=150;
            break;

        case GS_PHOTO:
        default:
            nBrush=RES_DB_COARSE;
            nIntensity=100;
            break;
    }

    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWBRUSH),nBrush);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWINTENSITY),nIntensity);
}


//-------------------------------------------------------------------------
// Function: Convert5aHalfTone(lpSection)
//
// Action: Convert the 5A halftoning settings
//
// Return: TRUE if the old section existed, FALSE if not
//-------------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aHalfTone(LPSTR lpSection)
{
    int nIndex;
    int  nGray;
    int  nBright;
    BOOL bGrayScale;
    BOOL bBrightness;

    // See if either setting exists...
    bGrayScale=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDGRAYSCALE),&nGray,
        1,TRUE);
    bBrightness=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDBRIGHTNESS),&nBright,
        0,TRUE);

    if(bGrayScale || bBrightness)
    {
        if(1==nBright)
            nIndex=GS_SCANJET;
        else if(0==nGray)
            nIndex=GS_LINEART;
        else
            nIndex=GS_PHOTO;

        WriteHalfTone(lpSection,nIndex);
        return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5eHalfTone(LPSTR lpSection)
//
// Action: Convert the 5E halftoning settings
//
// Return: TRUE if successful, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eHalfTone(LPSTR lpSection)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_HALFTONE),&nValue,
        0,TRUE))
    {
        WriteHalfTone(lpSection,nValue);
        return TRUE;
    }
    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5aMemory(lpSection)
//
// Action: Convert the memory settings from the old to the new values
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aMemory(LPSTR lpSection)
{
    int nValue;
    int nPrinterMB;

    // Get memory settings--extract from prtindex.
    // Values range from 0 to 28, where 0-4 are the LaserJet III,
    // 5-9 are the LaserJet IIID, 10-14 are the LaserJet IIIP, and
    // 15-28 are the LaserJet IIISi. For indices less than 20, the
    // total MB is the index mod 5, + 1. For indices 20 and above, the
    // total MB is the index - 14, except for 26, 27, and 28, which
    // require special handling because of the increments that memory
    // can be added to the IIISi.
    // The formula used to calculate the settings is derived directly
    // from the values used in the hppcl5a driver. Specifically,
    // AM = 945 * TM - 245, where TM is the total memory in MB, and
    // AM is the available printer memory.

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDMEMORY),&nValue,1,TRUE))
    {
        if(nValue<20)
            nPrinterMB=nValue%5 + 1;
        else
        {
            nPrinterMB=nValue-14;
            if(nValue>25)
            {
                nPrinterMB++;        // 25=11MB, 26=13MB, so add an extra MB.
                if(nValue==28)
                    nPrinterMB+=2;   // 27=14MB, 28=17MB, so add 2 extra MB.
            }
        }

        nValue=945*nPrinterMB-245;
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5eMemory(lpSection)
//
// Action: Convert the HPPCL5E memory settings from the old to the new values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,FALSE))
    {
	if (nValue <= KB_THRESHOLD )
	    {
	    if (nValue > MAX_LJ4_MBMEMSETTING)
		nValue = MAX_LJ4_MBMEMSETTING;  // force it to max value
	    nValue=900*nValue - 450;  // convert to KB, using HP formula
	    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	    return TRUE;
	    }
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5MSMemory(lpSection)
//
// Action: Convert the WFW HPPCL5MS memory settings from the old to the new
//         values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Added for backward compatability
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5MSMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,TRUE))
	{
	nValue = nValue / 900;  // convert to MB value
	nValue = 945*nValue - 245; // formula used in hppcl5a driver
	// used to convert to available mem
	WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	return TRUE;
	}
    return FALSE;
}



//------------------------------------------------------------------------
// Function: HandleFontCartridges(lpSection,lpOldDrvSec,lpNewDrvSec)
//
// Action: Handle font cartridge data
//
// Return: VOID
//------------------------------------------------------------------------
VOID NEAR PASCAL HandleFontCartridges(LPSTR lpSection,
                                      LPSTR lpOldDrvSec,
                                      LPSTR lpNewDrvSec)
{
    int nCount;

    // Get the count of cartridges--if there are no cartridges, do nothing.
    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),&nCount,0,TRUE))
    {
        char  szOldCartKey[16];
        char  szNewCartKey[16];
        short nCart = 0;
        short i;
        short index;
        int   nLength1;
        int   nLength2;

        nLength1=LoadString(hInst,IDS_CARTINDEX,szOldCartKey,
            sizeof(szOldCartKey));
        nLength2=LoadString(hInst,IDS_CARTRIDGE,szNewCartKey,
            sizeof(szNewCartKey));

        for (i = 0; i < nCount; i++)
        {
            if (i > 0)
                wsprintf(szOldCartKey+nLength1,"%d",i);

            // compose cartridge keyname for current driver
            wsprintf(szNewCartKey+nLength2,"%d",i+1);

            if ((index = GetProfileInt(lpNewDrvSec, szOldCartKey, 0)) > 0)
            {
                WriteProfileString(lpNewDrvSec, szOldCartKey, NULL);
                nCart++;
                if (index <= MAX_CART_INDEX)
                    WriteInt(lpSection,szNewCartKey,rgNewCartMap[index-1]);
                else
                    // external cartridges. Simply copy the id over.
                    WriteInt(lpSection,szNewCartKey,index);
            }
        }

        // Save the # of cartridges
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),nCart);
    }
}


//--------------------------------------------------------------------------
// Function: HandleFonts(lpSection,lpDevName,lpPort)
//
// Action: Deal with soft fonts & font cartridges
//
// Return: VOID
//--------------------------------------------------------------------------
VOID NEAR PASCAL HandleFonts(LPSTR lpSection,
                             LPSTR lpDevName,
                             LPSTR lpPort)
{
    char szOldDrvSec[64];   // HPPCL5A,<port> or HPPCL5E,<port>
    char szNewDrvSec[64];   // HPPCL5MS,<port>
    int  nCount;
    BOOL bOldExists=FALSE;  // Does old section exist?

    LoadString(hInst,IDS_OLD_5E_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
    MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

    // See if the old section exists at all. Temporarily borrow szNewDrvSec.

    if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
        sizeof(szNewDrvSec)))
    {
        bOldExists=TRUE;
    }
    else
    {
        // Try the HPPCL5E driver...

	LoadString(hInst,IDS_OLD_5A_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
        MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

        if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
            sizeof(szNewDrvSec)))
        {
            bOldExists=TRUE;
        }
    }


    lstrcpy(szNewDrvSec,rgchModuleName);
    MakeAppName((LPSTR)szNewDrvSec,lpPort,sizeof(szNewDrvSec));

    if(bOldExists)
    {
        HandleSoftFonts(szOldDrvSec,szNewDrvSec);
        HandleFontCartridges(lpSection,szOldDrvSec,szNewDrvSec);
    }

    // create UNIDRV's font summary file, if there are many soft fonts.
    GetInt(szNewDrvSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE);
    if(nCount>SOFT_FONT_THRES)
    {
        HDC hIC;

        if(hIC=CreateIC(rgchModuleName,lpDevName,lpPort,NULL))
            DeleteDC(hIC);
    }
}


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------
int FAR PASCAL DevInstall(HWND  hWnd,
                          LPSTR lpDevName,
                          LPSTR lpOldPort,
                          LPSTR lpNewPort)
{
    char szDevSec[64];       // [<device>,<port>] section name

    if (!lpDevName)
        return -1;

    if (!lpOldPort)
    {
        char szBuf[10];

        if (!lpNewPort)
            return 0;

        // install a device for the first time. Convert old HPPCL5a settings,
        // which are still under [<device>,<port>], into equivalent new
        // UNIDRV settings under [<device>,<port>], if applicable.
        // Delete old settings that are linked to the device name, but don't
        // delete old settings that are liked to the driver and port (softfonts)

        lstrcpy(szDevSec,lpDevName);
        MakeAppName((LPSTR)szDevSec,lpNewPort,sizeof(szDevSec));

        // check if old settings exist at all
        if(GetProfileString(szDevSec,NULL,NULL,szBuf,sizeof(szBuf)))
        {
            // Do the straight conversions
            ConvertStraight(szDevSec,IDS_OLDPAPERSIZE,IDS_NEWPAPERSIZE);
            ConvertStraight(szDevSec,IDS_OLDPAPERSOURCE,IDS_NEWPAPERSOURCE);
            ConvertStraight(szDevSec,IDS_OLDORIENTATION,IDS_NEWORIENTATION);
            ConvertStraight(szDevSec,IDS_OLDTRUETYPE,IDS_NEWTRUETYPE);
            ConvertStraight(szDevSec,IDS_OLDSEPARATION,IDS_NEWSEPARATION);

            // Convert the simple translations
            ConvertBool(szDevSec,IDS_OLDPAGEPROTECT,IDS_NEWPAGEPROTECT,1);
            ConvertBool(szDevSec,IDS_OLDOUTPUT,IDS_NEWOUTPUT,259);

            // Do the stuff that requires more complicated conversion
            ConvertResolution(szDevSec,lpDevName);
            if(!Convert5eHalfTone(szDevSec))
                Convert5aHalfTone(szDevSec);

	        if(!Convert5eMemory(szDevSec))
		    {
		        if(!Convert5MSMemory(szDevSec))
		            Convert5aMemory(szDevSec);
		    }
	        ConvertVectorMode(szDevSec);

            // Handle soft fonts & cartridges
            HandleFonts(szDevSec,lpDevName,lpNewPort);
        }

        // Flush the cached settings from win.ini
        WriteProfileString(NULL,NULL,NULL);
    }
    else
    {
        int  nCount;

        // move device settings from the old port to the new port, or
        // de-install a device, i.e. remove its device setttings in order
        // to compress the profile.

        // First, check if there is any  soft font installed under the
        // old port. If so, warn the user to copy them over.
        lstrcpy(szDevSec,rgchModuleName);
        MakeAppName((LPSTR)szDevSec,lpOldPort,sizeof(szDevSec));

        if(GetInt(szDevSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE)
            && nCount && lpNewPort)
        {
            NPSTR npTemp;

            if(npTemp=(NPSTR)LocalAlloc(LPTR,TMPSIZE))
            {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,npTemp,TMPSIZE))
                {
                    // Use this API so that the M Box is set to the Foreground
                    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
                    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = npTemp;
		    mbp.lpszCaption = lpOldPort;
                    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
                    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
                LocalFree((HLOCAL)npTemp);
            }
        }
    }

    return UniDevInstall(hWnd,lpDevName,lpOldPort,lpNewPort);
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(HWND  hWnd,
                               LPSTR lpDeviceName,
                               LPSTR lpPortName,
                               BOOL  bSoftFonts)
{
  int          fsVers;
  HANDLE       hFIlib;
  SOFTFONTPROC lpFIns;

  if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    !(lpFIns = (SOFTFONTPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
  {
    if (hFIlib >= 32)
      FreeLibrary(hFIlib);
#ifdef DEBUG
    MessageBox(0,
      "Can't load FINSTAL.DLL or can't get InstallSoftFont",
      NULL, MB_OK);
#endif
    return TRUE;
  }

  // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
  // We choose to ignore the returned "fvers". No use of it.
  fsVers = (*lpFIns)(hWnd,rgchModuleName,lpPortName,
                    (GetKeyState(VK_SHIFT)<0 && GetKeyState(VK_CONTROL)<0),
                    1,	  // dummy value for "fvers".
                    bSoftFonts?CLASS_LASERJET:256);
  FreeLibrary(hFIlib);
  return fsVers;
}



// -------------------------------------------------------------------
//
// Special case control functions wrt SETCHARSET escape. This is necessary
// to avoid breaking Winword and Pagemaker. (note that we don't actually
// do anything with SETCHARSET, but apps break unless we say that we do)
//
// --------------------------------------------------------------------
int FAR PASCAL Control(LPDV  lpdv,
                       short function,
                       LPSTR lpInData,
                       LPSTR lpOutData)
{
    // Tell app that SETCHARSET is supported
    if(QUERYESCSUPPORT == function && *((LPWORD)lpInData) == SETCHARSET)
        return 1;

    // Special case SETCHARSET
    if(SETCHARSET == function)
        return 1;

    // General case
    return UniControl(lpdv, function, lpInData, lpOutData);
}



#ifndef NOFONTMAP

//----------------------------------------------------------------------
// Function: MapFaceName(lplfOld,lplfNew)
//
// Action: Map old face names to their new counterparts. Do as little
//         work as we possibly can, since this function gets called
//         often & we don't want to impact performance. Optimize
//         the whole search to the case where we don't find a match,
//         as this will be the most common scenario.
//
// Return: A pointer to the LOGFONT to actually hand to Unidrv. Cast
//         the return to a LPSTR, just so the compiler is happy.
//----------------------------------------------------------------------
LPSTR NEAR PASCAL MapFaceName(LPLOGFONT lplfOld,
                              LPLOGFONT lplfNew)
{
    LPLOGFONT   lpReturn=lplfOld;   // By default
    NPFACEINDEX pIndex;
    LPSTR       lpFace=lplfOld->lfFaceName;
    BYTE        cTest=*lpFace++;

    // Determine range of possible matches in the table. Since the
    // table is sorted alphabetically, we may be able to bail out
    // before we reach the end of the table.
    for(pIndex=FaceIndex;cTest > pIndex->cFirstChar;pIndex++)
        ;

    // Only proceed if the first character matches and this isn't the
    // firewall (cTest = \xFF).
    if(cTest==pIndex->cFirstChar && ('\xFF' != cTest))
    {
        WORD  wStartIndex=(WORD)(pIndex->bIndex);
        WORD  wStopIndex=(WORD)((pIndex+1)->bIndex);
        WORD  wLoop=wStartIndex;
        NPSTR npMapFace=&(FaceMap[wStartIndex].szOldFace[1]);
        BYTE  cMapFace;

        // Check the rest of the string against the table entries.
        // This search routine takes advantage of the fact that
        // the old face names in the table are fully sorted alphabetically.
        // This search routine takes advantage of the fact that our table
        // is fully sorted, and doesn't do a full string comparison until
        // we actually think we have a match. Once we think there's a match,
        // we'll double-check the entire string to prevent false triggering.

        while(wLoop < wStopIndex)
        {
            // Look for a match. At this point, match a wildcard to
            // anything--we'll do a more stringent check later on, if we
            // think we have a match. Stop if cTest is NULL.
            while((((cTest=*lpFace)==(cMapFace=*npMapFace)) ||
                ('\x01'==cMapFace)) && cTest)
            {
                npMapFace++;
                lpFace++;
            }

            // We arrive here via two conditions: (1) we've reached the
            // end of lpFace and cTest is NULL, or (2) cMapFace and cTest
            // failed to compare. We should only continue searching if
            // cMapFace is non-NULL and cTest is larger than cMapFace (take
            // advantage of the fact that FaceMap is sorted alphabetically).
            // For overall performance, check for the no match case first.

            // Move to the next table entry as long as there's still a
            // chance to find a match.
            if(cTest > cMapFace)
            {
                npMapFace+=sizeof(FACEMAP);
                wLoop++;
                continue;     // Go to the next iteration
            }

            // if cTest is non-NULL, then the sorting of the table guarantees
            // that there are no matches. Bail out now.
            if(cTest)
                goto MFN_exit;

            // cTest is NULL, so we will not make another iteration. The
            // only thing left to decide is whether or not we have a match
            // with the current string.
            if(cMapFace)
                goto MFN_exit;

            // The guards above ensure that we only arrive here if both
            // cTest and cMapFace are NULL, which means that if we're
            // going to find a match, this string is it. We took shortcuts
            // in the comparisons above, so do a stringent comparison now
            // to be sure that this is really a match. The only characters
            // to match wildcards are '1' and 'N', since these are the only
            // ones used in previous versions of the driver.

            for(lpFace=lplfOld->lfFaceName,npMapFace=FaceMap[wLoop].szOldFace;
                (cMapFace=*npMapFace) && (cTest=*lpFace);
                npMapFace++,lpFace++)
            {
                if(!((cTest==cMapFace) ||
                    (('\x01'==cMapFace)&&(('1'==cTest)||('N'==cTest)))))
                {
                    // False trigger--bail out without changing facename
                    goto MFN_exit;
                }
            }

            // We now know that this really is a match--keep the requested
            // attributes & change just the face name.

            *lplfNew=*lplfOld;
            lstrcpy(lplfNew->lfFaceName,FaceMap[wLoop].szNewFace);
            lpReturn=lplfNew;
            goto MFN_exit;
        }
    }

MFN_exit:

    return (LPSTR)lpReturn;
}


#endif

//----------------------------------------------------------------------
// Function: RealizeObject(lpdv,sStyle,lpInObj,lpOutObj,lpTextXForm)
//
// Action: Hook this out to enable font substitution. If the object isn't
//         a font, do absolutely nothing.
//
// Return: Save as UniRealizeObject().
//----------------------------------------------------------------------
DWORD FAR PASCAL RealizeObject(LPDV        lpdv,
                               short       sStyle,
                               LPSTR       lpInObj,
                               LPSTR       lpOutObj,
                               LPTEXTXFORM lpTextXForm)
{
#ifndef NOFONTMAP

    LOGFONT   lfNew;

    if(OBJ_FONT==sStyle)
        lpInObj=MapFaceName((LPLOGFONT)lpInObj,&lfNew);

#endif

    return UniRealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pcl4kres\etc\pcl4ch.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//
//-----------------------------------------------------------------------------

#include "strings.h"


// #define CONVERT_FROM_WIN30

char *rgchModuleName   = "PCL4CH";
char szSoftFonts[]     = "SoftFonts";

#ifdef CONVERT_FROM_WIN30
char szPrtIndex[]      = "prtindex";
char szWinVer[]        = "winver";
char sz310[]           = "310";
char sz150[]           = "150";
char sz75[]            = "75";
char szNull[]          = "";
char szOrient[]        = "orient";
char szOrientation[]   = "Orientation";
char szPaper[]         = "paper";
char szPaperSize[]     = "Paper Size";
char szPrtResFac[]     = "prtresfac";
char szPrintQuality[]  = "Print Quality";
char szTray[]          = "tray";
char szDefaultSource[] = "Default Source";
char szNumCart[]       = "numcart";
char szCartIndex[]     = "cartindex";
char szCartridge[]     = "Cartridge ";
char szNumberCart[]    = "Number of Cartridges";
char szFsVers[]        = "fsvers";
char szFontSummary[]   = "Font Summary";

// map old HPPCL's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL .rc file.
int rgNewCartMap[9] = {8, 7, 2, 3, 5, 6, 1, 4, 0};

#endif


#define PRINTDRIVER
#include "print.h"
#include "gdidefs.inc"
#include "mdevice.h"



#define DELETE_OLD

#ifndef WINNT
HDC   FAR PASCAL CreateIC(LPCSTR, LPCSTR, LPCSTR, const VOID FAR*);
BOOL  FAR PASCAL DeleteDC(HDC);
#endif  // WINNT

#include "unidrv.h"


#ifndef WINNT
extern char *rgchModuleName;	// global module name

// typedef for soft font installer
typedef int (FAR PASCAL *SFPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

#define SOFT_FONT_THRES 25	    // build font summary, if over this limit
#define MAX_CART_INDEX	33
#define MAX_OLD_CART	24
#define TMPSIZE         256

HINSTANCE hInst;

#ifdef PRTCAPSTUFF

char szPrtCaps[]       = "prtcaps";

#define MAX_NUM_MODELS	24
#define MAX_MODEL_NAME	29
typedef struct
    {
    char szModel[MAX_MODEL_NAME];
    int  rgIndexLimit[2];
    char szPrtCaps[7];	    // keep as a string instead of integer to avoid
			    // conversion because itoa doesn't work here.
    } MODELMAP, FAR * LPMODELMAP;



//-------------------------------------------------------------------
// Function: DoPrtCapsStuff(lpDevName,lpPort)
//
// Action: Write out PRTCAPS under [<model>,<port>] section
//         in order to be backward-compatible with existing font
//         packages. Note that this code can fail
//         under extremely low memory conditions, so be sure and check
//         the return values from the resource calls.
//-------------------------------------------------------------------
void NEAR PASCAL DoPrtCapsStuff(LPSTR lpDevName,
                                LPSTR lpPort)
{
  char szOldSec[64];
  int  i;
  HANDLE  hMd;
  HANDLE  hResMap;
  LPMODELMAP	lpModelMap;


  lstrcpy(szOldSec,lpDevName);
  MakeAppName((LPSTR)szOldSec,lpPort,sizeof(szOldSec));

  hMd=GetModuleHandle((LPSTR)rgchModuleName);
  hResMap=LoadResource(hMd,FindResource(hMd,MAKEINTRESOURCE(1),RT_RCDATA));
  if(hResMap)
  {
    if(lpModelMap=(LPMODELMAP)LockResource(hResMap))
    {
      for (i=0;i<MAX_NUM_MODELS;i++)
      {
        if (!lstrcmp(lpDevName,(LPSTR)(lpModelMap[i].szModel)))
        {
          WriteProfileString((LPSTR)szOldSec,szPrtCaps,
                            (LPSTR)lpModelMap[i].szPrtCaps);
          break;
        }
      }
      UnlockResource(hResMap);
    }
    FreeResource(hResMap);
  }
}


#endif

//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
		    WORD   wDataSeg,
		    WORD   cbHeapSize,
		    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}




//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
  short   length, count;
  LPCSTR  lpTmp;
  LPCSTR  lpLastColon = NULL;

  length = lstrlen(lpAppName);

  if (!lpPortName)
    return length;

  if (length == 0 || length > max - lstrlen(lpPortName))
    return -1;

  // insert the comma
  lpAppName[length++] = ',';

  // append the port name but do not want the last ':', if any.
  for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
    if (*lpTmp == ':')
      lpLastColon = lpTmp;
    if (lpLastColon && lpLastColon == lpTmp - 1)
      count = lpLastColon - lpPortName;
    else
      count = lpTmp - lpPortName;

  lstrcpy((LPSTR)&lpAppName[length], lpPortName);

  length += count;
  lpAppName[length]='\0';

  return length;
}

#ifdef CONVERT_FROM_WIN30

//------------------------------------------------------------------------------
// Function: itoa
//
// Action:  This function converts the given integer into an ASCII string.
//
// return:  The length of the string.
//-----------------------------------------------------------------------------

short NEAR PASCAL itoa(buf, n)
LPSTR buf;
short n;
{
    short   fNeg;
    short   i, j;

    if (fNeg = (n < 0))
	n = -n;

    for (i = 0; n; i++)
	{
	buf[i] = (char)(n % 10 + '0');
	n /= 10;
	}

    // n was zero
    if (i == 0)
	buf[i++] = '0';

    if (fNeg)
	buf[i++] = '-';

    for (j = 0; j < i / 2; j++)
	{
	short tmp;

	tmp = buf[j];
	buf[j] = buf[i - j - 1];
	buf[i - j - 1] = (char)tmp;
	}

    buf[i] = 0;

    return i;
}

#endif


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------

int FAR PASCAL DevInstall(hWnd, lpDevName, lpOldPort, lpNewPort)
HWND	hWnd;
LPSTR	lpDevName;
LPSTR	lpOldPort, lpNewPort;
{
    char szOldSec[64];
    int  nReturn=1;

    if (!lpDevName)
	    return -1;

    if (!lpOldPort)
	{
#ifdef CONVERT_FROM_WIN30
        char szNewSec[64];
	    char szBuf[32];
	    int  tmp;
	    int  i, index;
	    HANDLE	hMd;
	    HANDLE	hResMap;
	    LPMODELMAP  lpModelMap;
#endif

	    if (!lpNewPort)
	        return 0;

#ifdef CONVERT_FROM_WIN30
	    // install a device for the first time. Convert old HPPCL settings,
	    // which are still under [<driver>,<port>], into equivalent new
	    // UNIDRV settings under [<device>,<port>], if applicable.
	    // All soft fonts are left under the section [<driver>,<port>].
	    lstrcpy(szOldSec,rgchModuleName);
	    MakeAppName((LPSTR)szOldSec, lpNewPort, sizeof(szOldSec));

	    // if old section exists at all
	    if (!GetProfileString(szOldSec, NULL, NULL, szBuf, sizeof(szBuf)))
	        goto DI_exit;

	    // make sure the old device settings are for this device.
	    // If not, there is nothing to do here. Simply return 1.
	    tmp = GetProfileInt(szOldSec, szPrtIndex, 0);
	    hMd = GetModuleHandle((LPSTR)rgchModuleName);
	    hResMap = LoadResource(hMd,
			    FindResource(hMd, MAKEINTRESOURCE(1), RT_RCDATA));
	    lpModelMap = (LPMODELMAP)LockResource(hResMap);
	    for (i = 0; i < MAX_NUM_MODELS; i++)
        {
	        if (!lstrcmp(lpDevName, (LPSTR)lpModelMap[i].szModel))
		    {
		        if ((tmp < lpModelMap[i].rgIndexLimit[0]) ||
		            (tmp > lpModelMap[i].rgIndexLimit[1]) )
		            i = MAX_NUM_MODELS;        // not this model. No conversion.
		        break;
		    }
        }

	    UnlockResource(hResMap);
	    FreeResource(hResMap);

	    if (i >= MAX_NUM_MODELS)
	        // this model is not even listed in the old HPPCL driver.
	        goto DI_exit;

	    if (GetProfileInt(szOldSec, szWinVer, 0) == 310)
	        goto DI_exit;

	    WriteProfileString(szOldSec, szWinVer, sz310);
#ifdef DELETE_OLD
	    WriteProfileString(szOldSec, szPrtIndex, NULL);
#endif

	    lstrcpy(szNewSec, lpDevName);
	    MakeAppName((LPSTR)szNewSec, lpNewPort, sizeof(szNewSec));

	    // convertable device settings include: copies, duplex, orient,
	    // paper, prtresfac, tray, and cartidges.

	    if (GetProfileString(szOldSec, szOrient, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szOrientation, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szOrient, NULL);
#endif
        }
	    if (GetProfileString(szOldSec, szPaper, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szPaperSize, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szPaper, NULL);
#endif
        }

	    // default to 2 if cannot find it
	    tmp = GetProfileInt(szOldSec, szPrtResFac, 2);

	    if (tmp == 1)
	        WriteProfileString(szNewSec, szPrintQuality, sz150);
	    else if (tmp == 2)
	        WriteProfileString(szNewSec, szPrintQuality, sz75);

#ifdef DELETE_OLD
	    WriteProfileString(szOldSec, szPrtResFac, NULL);
#endif

	    if (GetProfileString(szOldSec, szTray, szNull, szBuf, sizeof(szBuf)) > 0)
        {
	        WriteProfileString(szNewSec, szDefaultSource, szBuf);
#ifdef DELETE_OLD
	        WriteProfileString(szOldSec, szTray, NULL);
#endif
        }

	    // try to convert the cartridge information.

	    if ((tmp = GetProfileInt(szOldSec, szNumCart, 0)) == 0)
	        tmp = 1;

	    // this is executed at least once
	    {
	        char szOldCartKey[16];
	        char szNewCartKey[16];
	        char nCart = 0;

	        lstrcpy(szOldCartKey, szCartIndex);

	        for (i = 0; i < tmp; i++)
	        {
	            if (i > 0)
                    itoa((LPSTR)&szOldCartKey[9], i);
	            // compose cartridge keyname under UNIDRV.
	            lstrcpy(szNewCartKey, szCartridge);
	            itoa((LPSTR)&szNewCartKey[10], i + 1);

	            if ((index = GetProfileInt(szOldSec, szOldCartKey, 0)) > 0)
		        {
		            WriteProfileString(szOldSec, szOldCartKey, NULL);
		            nCart++;
		            if (index <= MAX_OLD_CART)
		            {
		                itoa((LPSTR)szBuf, index + 8);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		            else if (index <= MAX_CART_INDEX)
		            {
		                itoa((LPSTR)szBuf, rgNewCartMap[index - MAX_OLD_CART - 1]);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		            else
		            {
		                // external cartridges. Simply copy the id over.
		                itoa((LPSTR)szBuf, index);
		                WriteProfileString(szNewSec, szNewCartKey, szBuf);
		            }
		        }
	        }

	        // integer to ASCII string conversion.
	        itoa((LPSTR)szBuf, nCart);
	        WriteProfileString(szNewSec, szNumberCart, szBuf);
	    }

	    // delete the old font summary file
	    WriteProfileString(szOldSec, szFsVers, NULL);
	    if (GetProfileString(szOldSec, szFontSummary, szNull, szBuf, sizeof(szBuf)) > 0)
	    {
	        int hFS;

	        // truncate the old font summary file to zero size.
	        if ((hFS = _lcreat(szBuf, 0)) >= 0)
		        _lclose(hFS);
	        WriteProfileString(szOldSec, szFontSummary, NULL);
	    }

            // create UNIDRV's font summary file, if there are many soft fonts.
	    if (GetProfileInt(szOldSec, szSoftFonts, 0) > SOFT_FONT_THRES)
	    {
	        HDC hIC;

	        if (hIC = CreateIC("PCL4CH", lpDevName, lpNewPort, NULL))
		        DeleteDC(hIC);
	    }
#endif
	}
    else

    {

	// move device settings from the old port to the new port, or
	// de-install a device, i.e. remove its device setttings in order
	// to compress the profile.

	// First, check if there is any  soft font installed under the
	// old port. If so, warn the user to copy them over.

	lstrcpy(szOldSec, rgchModuleName);
	MakeAppName((LPSTR)szOldSec, lpOldPort, sizeof(szOldSec));
	if (GetProfileInt(szOldSec, szSoftFonts, 0) > 0 && lpNewPort)
	{
            LPBYTE lpTemp;

            if(lpTemp=GlobalAllocPtr(GMEM_MOVEABLE,TMPSIZE))
	    {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,lpTemp,TMPSIZE))
		{
		    // Use this API so that the M Box is set to the Foreground
		    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
		    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = lpTemp;
		    mbp.lpszCaption = lpOldPort;
		    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
		    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
		GlobalFreePtr (lpTemp);
	    }
	}
    nReturn=UniDevInstall(hWnd, lpDevName, lpOldPort, lpNewPort);
    }


#ifdef CONVERT_FROM_WIN30
DI_exit:
#endif

#ifdef PRTCAPSTUFF

    DoPrtCapsStuff(lpDevName,lpNewPort);

#endif

    return nReturn;
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(hWnd, lpDeviceName, lpPortName, bSoftFonts)
HWND	hWnd;
LPSTR	lpDeviceName;
LPSTR	lpPortName;
BOOL	bSoftFonts;
{
    int     fsVers;
    HANDLE  hFIlib;
    SFPROC  lpFIns;

    if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    	!(lpFIns = (SFPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
	{
	    if (hFIlib >= 32)
	        FreeLibrary(hFIlib);
#ifdef DEBUG
	    MessageBox(0,
	        "Can't load FINSTALL.DLL or can't get InstallSoftFont",
	        NULL, MB_OK);
#endif
	    return TRUE;
	}

    // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
    // We choose to ignore the returned fvers. No use of it.
    fsVers = (*lpFIns)(hWnd, rgchModuleName, lpPortName,
		(GetKeyState(VK_SHIFT) < 0 && GetKeyState(VK_CONTROL) < 0),
		1,	  // dummy value for fvers.
		bSoftFonts ? CLASS_LASERJET : 256
		);
    FreeLibrary(hFIlib);
    return fsVers;
}

#endif  //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pcl5kres\etc\strings.h ===
// STRINGS.H
//
// IDs for string contants used within the minidriver. Start these nice
// and high, so avoid conflicts with strings from within the minidriver

#define IDS_OLD_5E_DRIVERNAME 4800
#define IDS_OLD_5A_DRIVERNAME 4801
#define IDS_OLDMEMORY         4802
#define IDS_OLDPAPERSIZE      4803
#define IDS_OLDPAPERSOURCE    4804
#define IDS_OLD_5A_RESOLUTION 4805
#define IDS_OLD_5E_RESOLUTION 4806
#define IDS_OLDORIENTATION    4807
#define IDS_OLDPAGEPROTECT    4808
#define IDS_OLDGRAYSCALE      4809
#define IDS_OLDBRIGHTNESS     4810
#define IDS_OLD_5E_HALFTONE   4811
#define IDS_OLDTRUETYPE       4812
#define IDS_OLDOUTPUT         4813
#define IDS_OLDSEPARATION     4814
#define IDS_NEWMEMORY         4815
#define IDS_NEWPAPERSIZE      4816
#define IDS_NEWPAPERSOURCE    4817
#define IDS_NEWRESOLUTION     4818
#define IDS_NEWYRESOLUTION    4819
#define IDS_NEWORIENTATION    4820
#define IDS_NEWPAGEPROTECT    4821
#define IDS_NEWBRUSH          4822
#define IDS_NEWINTENSITY      4823
#define IDS_NEWTRUETYPE       4824
#define IDS_NEWOUTPUT         4825
#define IDS_NEWSEPARATION     4826
#define IDS_CARTRIDGES        4827
#define IDS_OLDVECTORMODE     4828
#define IDS_NEWVECTORMODE     4829
#define IDS_CARTINDEX         4830
#define IDS_CARTRIDGE         4831
#define IDS_CARTRIDGECOUNT    4832
#define IDS_FONTSUMMARY       4833
#define IDS_SOFTFONTS         4834
#define IDS_SOFTFONTFORMAT    4835
#define IDS_SOFTFONTTEST      4836
#define IDS_SOFTFONTWARNING   4837
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pcl5kres\etc\pcl5ch.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//-----------------------------------------------------------------------------


#include "strings.h"

char *rgchModuleName = "PCL5CH";
char szNone[]="";

// The following are defined to ensure that we upgrade correctly from the
// HPPCL5a, HPPCL5e and Win 3.11 HPPCL5MS drivers

#define MAX_LJ4_MBMEMSETTING    68    // from HP tech specification
#define KB_THRESHOLD            200   // kb range check,needed for conversion


#define PRINTDRIVER
#include <print.h>
#include "gdidefs.inc"
#include "mdevice.h"
#include "unidrv.h"
#include "minidriv.h"

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#ifndef WINNT
//swpark
//#define DEBUG 1
#ifdef DEBUG
#include "stdarg.h"
void NEAR CDECL  DBMSG(LPSTR, ...);
#endif
#endif  //WINNT

#ifndef WINNT
short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

// typedef for atom stuff--what a nuisance!
typedef struct tagSFNODE
{
    WORD wIndex;
    ATOM atom;
} SFNODE, FAR *LPSFNODE;

// Typedef for Font Installer procedure
typedef int (FAR * PASCAL SOFTFONTPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

HINSTANCE hInst;

#define DEFAULT_INT      32767

#define SOFT_FONT_THRES  25  // build font summary, if over this limit

#define MAX_CART_INDEX	 12

#define TMPSIZE         256

// Define these so they happily use the same values as the HPPCL5E driver.
#define GS_PHOTO     0
#define GS_LINEART   1
#define GS_SCANJET   2


// map old HPPCL5a's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL5a .rc file.
// Note that we do not have "International Collection" cartridge and we
// map it to index 0 (arbitrarily).
int rgNewCartMap[12] = {0, 8, 7, 2, 3, 0, 5, 6, 1, 4, 9, 10};

// String to determine if we have a member of the LaserJet 4 family
char szLJ4[]="HP LaserJet 4";

// Stuff needed for mapping old facenames to new versions
#ifndef NOFONTMAP

typedef struct tagFACEMAP
{
    char szOldFace[LF_FACESIZE];
    char szNewFace[LF_FACESIZE];
} FACEMAP, NEAR * NPFACEMAP;

typedef struct tagFACEINDEX
{
    BYTE cFirstChar;
    BYTE bIndex;
} FACEINDEX, NEAR * NPFACEINDEX;

FACEMAP FaceMap[]={{"Albertus (W\x01)",         "Albertus Medium"},
                   {"Albertus Xb (W\x01)",      "Albertus Extra Bold"},
                   {"Antique Olv (W\x01)",      "Antique Olive"},
                   {"Antique Olv Cmpct (W\x01)","Antique Olive Compact"},
                   {"CG Bodoni (W\x01)",        "CG Bodoni"},
                   {"CG Cent Schl (W\x01)",     "CG Century Schoolbook"},
                   {"CG Omega (W\x01)",         "CG Omega"},
                   {"CG Palacio (W\x01)",       "CG Palacio"},
                   {"CG Times (W\x01)",         "CG Times"},
                   {"Clarendon Cd (W\x01)",     "Clarendon Condensed"},
                   {"Cooper Blk (W\x01)",       "Cooper Black"},
                   {"Coronet (W\x01)",          "Coronet"},
                   {"Courier (W\x01)",          "Courier"},
                   {"Garmond (W\x01)",          "Garamond"},
                   {"ITC Benguat (W\x01)",      "ITC Benguiat"},
                   {"ITC Bookman Db (W\x01)",   "ITC Bookman Demi"},
                   {"ITC Bookman Lt (W\x01)",   "ITC Bookman Light"},
                   {"ITC Souvenir Db (W\x01)",  "ITC Souvenir Demi"},
                   {"ITC Souvenir Lt (W\x01)",  "ITC Souvenir Light"},
                   {"Letter Gothic (W\x01)",    "Letter Gothic"},
                   {"Marigold (W\x01)",         "Marigold"},
                   {"Revue Lt (W\x01)",         "Revue Light"},
                   {"Shannon (W\x01)",          "Shannon"},
                   {"Shannon Xb (W\x01)",       "Shannon Extra Bold"},
                   {"Stymie (W\x01)",           "Stymie"},
                   {"Univers (W\x01)",          "Univers"},
                   {"Univers Cd (W\x01)",       "Univers Condensed"}};


FACEINDEX FaceIndex[]={{'A',0},
                       {'C',4},
                       {'G',13},
                       {'I',14},
                       {'L',19},
                       {'M',20},
                       {'R',21},
                       {'S',22},
                       {'U',25},
                       {(BYTE)'\xFF',27}};  // Provide an upper limit
                                            // to the search for 'U'.

#endif


//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
                    WORD   wDataSeg,
                    WORD   cbHeapSize,
                    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}


//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
    short   length, count;
    LPCSTR  lpTmp;
    LPCSTR  lpLastColon = NULL;

    length = lstrlen(lpAppName);

    if (!lpPortName)
        return length;

    if (length == 0 || length > max - lstrlen(lpPortName))
        return -1;

    // insert the comma
    lpAppName[length++] = ',';

    // append the port name but do not want the last ':', if any.
    for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
        if (*lpTmp == ':')
            lpLastColon = lpTmp;
        if (lpLastColon && lpLastColon == lpTmp - 1)
            count = lpLastColon - lpPortName;
        else
            count = lpTmp - lpPortName;

    lstrcpy((LPSTR)&lpAppName[length], lpPortName);

    length += count;
    lpAppName[length]='\0';

    return length;
}

#define KEY_BUF_SIZE  256


//---------------------------------------------------------------------------
// Function: GetInt(lpSection,lpKey,lpnValue,nDefault,bRemove)
//
// Action: Load the appropriate string from the resources, then get the
//         specified integer from the section. Remove the old entry if
//         it exists and it bRemove is TRUE.
//
// Return: TRUE if we actually found a value, FALSE if not.
//---------------------------------------------------------------------------
BOOL NEAR PASCAL GetInt(LPSTR  lpSection,
                        LPCSTR lpKey,
                        LPINT  lpnValue,
                        int    nDefault,
                        BOOL   bRemove)
{
    char szKeyName[60];
    int  nTest;

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    nTest=GetProfileInt(lpSection,szKeyName,DEFAULT_INT);

    if(DEFAULT_INT != nTest)
    {
        *lpnValue=nTest;

        if(bRemove)
            WriteProfileString(lpSection,szKeyName,NULL);

        return TRUE;
    }

    // Section doesn't exist--use default
    *lpnValue=nDefault;
    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteInt(lpSection,lpKey,nValue)
//
// Action: Write an integer value to the specified section of win.ini.
//
// Return: TRUE if successful, FALSE if not.
//-------------------------------------------------------------------------
BOOL NEAR PASCAL WriteInt(LPSTR  lpSection,
                          LPCSTR lpKey,
                          int    nValue)
{
    char szKeyName[60];
    char szValue[10];

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    wsprintf(szValue,"%u",nValue);

    return WriteProfileString(lpSection,szKeyName,szValue);
}


//---------------------------*MergeFontLists*-----------------------------
// Action: Merge the old and new soft fonts. In most cases when we get
//         called, we really don't do much of anything, because the
//         font lists are identical. However, we have to do some fun
//         stuff to merge the lists if they're different.
//         We know how many soft font entries exist in each section,
//         via the "SoftFonts" int, but the entries may be non-consecutive.
//
// Note:   This stomps all over the passed in buffer
//
// Return: TRUE if successfully conpleted, FALSE if not
//------------------------------------------------------------------------
BOOL NEAR PASCAL MergeFontLists(LPSTR lpOldSec,
                                LPSTR lpNewSec,
                                LPSTR lpTmp)
{
    WORD     wOldFonts;
    WORD     wNewFonts;
    LPSFNODE lpFonts;
    WORD     wMergedFonts=0;
    WORD     wLoop;
    WORD     wFound;
    WORD     wNewIndex;
    BYTE     szKey[20];

    // Get these values outside of the if statement, otherwise the compiler
    // may optimize out the assignment of wNewFonts
    GetInt(lpOldSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wOldFonts,0,FALSE);
    GetInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wNewFonts,0,FALSE);

    if(wOldFonts || wNewFonts)
    {
        char szFormat[30];

        // Get a block big enough for the worst case--no common fonts
        if(!(lpFonts=(LPSFNODE)GlobalAllocPtr(GHND,
            (DWORD)(wOldFonts+wNewFonts)*sizeof(SFNODE))))
        {
            return FALSE;
        }

        // We need a formatting string
        LoadString(hInst,IDS_SOFTFONTFORMAT,szFormat,sizeof(szFormat));

        // Put fonts from lpNew Sec first in the list. This way, if we have
        // already updated at least one driver from 5A to 5MS and the soft
        // fonts haven't changed, our old font summary file is still valid.
        // Unidrv will automatically recreate the font summary file if it
        // sees that the number of soft fonts has changed. Even though we
        // know how many soft font entries exist, we don't know that they
        // will be sequential. (They may not be if one was added, then
        // deleted). Keep track of the original offset. Even though the
        // font installer seems to be 1-based, start looking at 0, just
        // to be safe.
        for(wLoop=0,wFound=0;wFound<wNewFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpNewSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                lpFonts[wMergedFonts].wIndex=wLoop;
                lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                wFound++;
            }
        }
    
        // Remember where we left off in numbering the entries
        wNewIndex=wLoop;

        // Read fonts from lpOldSec--create atoms for new entries
        for(wLoop=0,wFound=0;wFound<wOldFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpOldSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                wFound++;
                if(!GlobalFindAtom(lpTmp))
                {
                    lpFonts[wMergedFonts].wIndex=wLoop;
                    lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                }
            }
        }

        // Write out the list of atoms--do the entries from lpNewSec first
        WriteInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),wMergedFonts);
        for(wLoop=0;wLoop<wNewFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,lpFonts[wLoop].wIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
        }

        // Now write out the entries that were in lpOldSec but not in lpNewSec.
        // Since the actual numbering of these entries is arbitrary, just
        // start numbering them at wNewIndex and increment each time.
        for(wLoop=wNewFonts;wLoop<wMergedFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,wNewIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
            wNewIndex++;
        }

        GlobalFreePtr(lpFonts);
    }

    return TRUE;
}


//----------------------*AddMissingEntries*-----------------------------
// Action: Copy any entries that appear in lpOldSec but not lpNewSec to
//         lpNewSec, but don't copy any entries relevant to soft fonts
//         (These entries will be copied in MergeFontSections).
//
// Return: TRUE if successful, FALSE if not
//----------------------------------------------------------------------
BOOL NEAR PASCAL AddMissingEntries(LPSTR lpOldSec,
                                   LPSTR lpNewSec,
                                   LPSTR lpTmp)
{
    WORD  wSize;
    LPSTR lpBuf;
    LPSTR lpWork;
    char  szTest2[30];
    char  szTest1[30];
    int   nLength;

    // Get the key names into buffers
    wSize=KEY_BUF_SIZE;

    if(!(lpBuf=GlobalAllocPtr(GHND,(DWORD)wSize)))
        return FALSE;
    while((WORD)GetProfileString(lpOldSec,NULL,szNone,lpBuf,wSize)==wSize-2)
    {
        wSize*=2;
        if(lpWork=GlobalReAllocPtr(lpBuf,(DWORD)wSize,GHND))
            lpBuf=lpWork;
        else
        {
            GlobalFreePtr(lpBuf);
            return FALSE;
        }
    }

    // Load some strings
    LoadString(hInst,IDS_FONTSUMMARY,szTest1,sizeof(szTest1));
    nLength=LoadString(hInst,IDS_SOFTFONTTEST,szTest2,sizeof(szTest2));

    // Now examine each entry, copy it if we want to keep it, and return TRUE
    // There are two cases where we don't want to copy the file--the key
    // named FontSummary and all keys that begin with "SoftFont"
    lpWork=lpBuf;
    while(wSize=(WORD)lstrlen(lpWork))
    {
        // Font Summary?
        if(lstrcmpi(lpWork,szTest1))
        {
            // Soft Font Entry?
            lstrcpy(lpTmp,lpWork);
            lpTmp[nLength]='\0';
            if(lstrcmpi(lpTmp,szTest2))
            {
                // Add this entry if it doesn't already exist in the new section
                if(!GetProfileString(lpNewSec,lpWork,szNone,lpTmp,TMPSIZE))
                {
                    GetProfileString(lpOldSec,lpWork,szNone,lpTmp,TMPSIZE);
                    WriteProfileString(lpNewSec,lpWork,lpTmp);
                }
            }
        }
        lpWork+=(wSize+1);
    }

    GlobalFreePtr(lpBuf);
    return TRUE;
}


//---------------------------*HandleSoftFonts*---------------------------
// Action: Transfer the soft fonts between old and new entries. First we
//         copy any entries that don't already exist in the new section,
//         with the exception of soft font information. Then we go ahead
//         and merge the soft fonts, so the end result in the new section
//         is the union of the old and new soft fonts.
//
// Return: TRUE if success, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL HandleSoftFonts(LPSTR lpszOldSec,
                                 LPSTR lpszNewSec)
{
    char szTmp[TMPSIZE];

    if(AddMissingEntries(lpszOldSec,lpszNewSec,szTmp))
        return MergeFontLists(lpszOldSec,lpszNewSec,szTmp);

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertStraight(lpSection,nOldID,nNewID)
//
// Action: Convert a section setting without translation
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertStraight(LPSTR lpSection,
                                 int   nOldID,
                                 int   nNewID)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nValue);
        return TRUE;
    }

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertBool(lpSection,nOldID,nNewID,nNewValue)
//
// Action: Convert a section with minimal translation. If the old section
//         existed and was non-zero, write nNewValue to the new section.
//         If the old section existed and was 0, write 0 to the new section.
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertBool(LPSTR lpSection,
                             int   nOldID,
                             int   nNewID,
                             int   nNewValue)
{
    int nOldValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nOldValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nOldValue?nNewValue:0);
        return TRUE;
    }

    return FALSE;
}

//------------------------------------------------------------------------
// Function: ConvertVectorMode(lpSection)
//
// Action: Convert the graphics mode setting
//         Cannot do straight conversion as defaults dont match
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertVectorMode(LPSTR lpSection)
{
    int nValue;

    GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDVECTORMODE),&nValue,1,TRUE);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWVECTORMODE),nValue);
    return TRUE;

}



//------------------------------------------------------------------------
// Function: ConvertResolution(lpSection,lpModel)
//
// Action: Convert the old resolution section to the new one
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertResolution(LPSTR lpSection,
                                   LPSTR lpModel)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5A_RESOLUTION),&nValue,0,TRUE))
    {
        LPSTR lpLJ4=szLJ4;
        LPSTR lpCheck=lpModel;
        BOOL  bLJ4=TRUE;

        nValue=300/(1<<nValue);

        // Compare the passed-in model to szLJ4. If lpModel begins with the
        // substring "HP LaserJet 4", then lpLJ4 will point to NULL when we
        // exit the loop.
        while(*lpLJ4 == *lpCheck)
        {
            lpLJ4++;
            lpCheck++;
        }

        if(!*lpLJ4)
        {
            // This is in the LJ4 family--check if it's a 4L or 4ML
            if(lstrcmp(lpCheck,"L") && lstrcmp(lpCheck,"ML"))
            {
                int nTest;

                // Device is capable of 600 dpi--check the value for
                // "printerres".

                GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_RESOLUTION),
                    &nTest,600,TRUE);

                if(600==nTest)
                    nValue<<=1;
            }
        }

        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWRESOLUTION),nValue);
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWYRESOLUTION),nValue);

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteHalfTone(lpSection,nIndex)
//
// Action: Write the halftoning data to win.ini
//
// Return: VOID
//-------------------------------------------------------------------------
VOID NEAR PASCAL WriteHalfTone(LPSTR lpSection,
                               int   nIndex)
{
    int nBrush;
    int nIntensity;

    switch(nIndex)
    {
        case GS_LINEART:
            nBrush=RES_DB_LINEART;
            nIntensity=100;
            break;

        case GS_SCANJET:
            nBrush=RES_DB_COARSE;
            nIntensity=150;
            break;

        case GS_PHOTO:
        default:
            nBrush=RES_DB_COARSE;
            nIntensity=100;
            break;
    }

    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWBRUSH),nBrush);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWINTENSITY),nIntensity);
}


//-------------------------------------------------------------------------
// Function: Convert5aHalfTone(lpSection)
//
// Action: Convert the 5A halftoning settings
//
// Return: TRUE if the old section existed, FALSE if not
//-------------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aHalfTone(LPSTR lpSection)
{
    int nIndex;
    int  nGray;
    int  nBright;
    BOOL bGrayScale;
    BOOL bBrightness;

    // See if either setting exists...
    bGrayScale=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDGRAYSCALE),&nGray,
        1,TRUE);
    bBrightness=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDBRIGHTNESS),&nBright,
        0,TRUE);

    if(bGrayScale || bBrightness)
    {
        if(1==nBright)
            nIndex=GS_SCANJET;
        else if(0==nGray)
            nIndex=GS_LINEART;
        else
            nIndex=GS_PHOTO;

        WriteHalfTone(lpSection,nIndex);
        return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5eHalfTone(LPSTR lpSection)
//
// Action: Convert the 5E halftoning settings
//
// Return: TRUE if successful, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eHalfTone(LPSTR lpSection)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_HALFTONE),&nValue,
        0,TRUE))
    {
        WriteHalfTone(lpSection,nValue);
        return TRUE;
    }
    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5aMemory(lpSection)
//
// Action: Convert the memory settings from the old to the new values
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aMemory(LPSTR lpSection)
{
    int nValue;
    int nPrinterMB;

    // Get memory settings--extract from prtindex.
    // Values range from 0 to 28, where 0-4 are the LaserJet III,
    // 5-9 are the LaserJet IIID, 10-14 are the LaserJet IIIP, and
    // 15-28 are the LaserJet IIISi. For indices less than 20, the
    // total MB is the index mod 5, + 1. For indices 20 and above, the
    // total MB is the index - 14, except for 26, 27, and 28, which
    // require special handling because of the increments that memory
    // can be added to the IIISi.
    // The formula used to calculate the settings is derived directly
    // from the values used in the hppcl5a driver. Specifically,
    // AM = 945 * TM - 245, where TM is the total memory in MB, and
    // AM is the available printer memory.

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDMEMORY),&nValue,1,TRUE))
    {
        if(nValue<20)
            nPrinterMB=nValue%5 + 1;
        else
        {
            nPrinterMB=nValue-14;
            if(nValue>25)
            {
                nPrinterMB++;        // 25=11MB, 26=13MB, so add an extra MB.
                if(nValue==28)
                    nPrinterMB+=2;   // 27=14MB, 28=17MB, so add 2 extra MB.
            }
        }

        nValue=945*nPrinterMB-245;
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5eMemory(lpSection)
//
// Action: Convert the HPPCL5E memory settings from the old to the new values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,FALSE))
    {
	if (nValue <= KB_THRESHOLD )
	    {
	    if (nValue > MAX_LJ4_MBMEMSETTING)
		nValue = MAX_LJ4_MBMEMSETTING;  // force it to max value
	    nValue=900*nValue - 450;  // convert to KB, using HP formula
	    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	    return TRUE;
	    }
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5MSMemory(lpSection)
//
// Action: Convert the WFW HPPCL5MS memory settings from the old to the new
//         values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Added for backward compatability
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5MSMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,TRUE))
	{
	nValue = nValue / 900;  // convert to MB value
	nValue = 945*nValue - 245; // formula used in hppcl5a driver
	// used to convert to available mem
	WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	return TRUE;
	}
    return FALSE;
}



//------------------------------------------------------------------------
// Function: HandleFontCartridges(lpSection,lpOldDrvSec,lpNewDrvSec)
//
// Action: Handle font cartridge data
//
// Return: VOID
//------------------------------------------------------------------------
VOID NEAR PASCAL HandleFontCartridges(LPSTR lpSection,
                                      LPSTR lpOldDrvSec,
                                      LPSTR lpNewDrvSec)
{
    int nCount;

    // Get the count of cartridges--if there are no cartridges, do nothing.
    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),&nCount,0,TRUE))
    {
        char  szOldCartKey[16];
        char  szNewCartKey[16];
        short nCart = 0;
        short i;
        short index;
        int   nLength1;
        int   nLength2;

        nLength1=LoadString(hInst,IDS_CARTINDEX,szOldCartKey,
            sizeof(szOldCartKey));
        nLength2=LoadString(hInst,IDS_CARTRIDGE,szNewCartKey,
            sizeof(szNewCartKey));

        for (i = 0; i < nCount; i++)
        {
            if (i > 0)
                wsprintf(szOldCartKey+nLength1,"%d",i);

            // compose cartridge keyname for current driver
            wsprintf(szNewCartKey+nLength2,"%d",i+1);

            if ((index = GetProfileInt(lpNewDrvSec, szOldCartKey, 0)) > 0)
            {
                WriteProfileString(lpNewDrvSec, szOldCartKey, NULL);
                nCart++;
                if (index <= MAX_CART_INDEX)
                    WriteInt(lpSection,szNewCartKey,rgNewCartMap[index-1]);
                else
                    // external cartridges. Simply copy the id over.
                    WriteInt(lpSection,szNewCartKey,index);
            }
        }

        // Save the # of cartridges
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),nCart);
    }
}


//--------------------------------------------------------------------------
// Function: HandleFonts(lpSection,lpDevName,lpPort)
//
// Action: Deal with soft fonts & font cartridges
//
// Return: VOID
//--------------------------------------------------------------------------
VOID NEAR PASCAL HandleFonts(LPSTR lpSection,
                             LPSTR lpDevName,
                             LPSTR lpPort)
{
    char szOldDrvSec[64];   // HPPCL5A,<port> or HPPCL5E,<port>
    char szNewDrvSec[64];   // HPPCL5MS,<port>
    int  nCount;
    BOOL bOldExists=FALSE;  // Does old section exist?

    LoadString(hInst,IDS_OLD_5E_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
    MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

    // See if the old section exists at all. Temporarily borrow szNewDrvSec.

    if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
        sizeof(szNewDrvSec)))
    {
        bOldExists=TRUE;
    }
    else
    {
        // Try the HPPCL5E driver...

	LoadString(hInst,IDS_OLD_5A_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
        MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

        if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
            sizeof(szNewDrvSec)))
        {
            bOldExists=TRUE;
        }
    }


    lstrcpy(szNewDrvSec,rgchModuleName);
    MakeAppName((LPSTR)szNewDrvSec,lpPort,sizeof(szNewDrvSec));

    if(bOldExists)
    {
        HandleSoftFonts(szOldDrvSec,szNewDrvSec);
        HandleFontCartridges(lpSection,szOldDrvSec,szNewDrvSec);
    }

    // create UNIDRV's font summary file, if there are many soft fonts.
    GetInt(szNewDrvSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE);
    if(nCount>SOFT_FONT_THRES)
    {
        HDC hIC;

        if(hIC=CreateIC(rgchModuleName,lpDevName,lpPort,NULL))
            DeleteDC(hIC);
    }
}


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------
int FAR PASCAL DevInstall(HWND  hWnd,
                          LPSTR lpDevName,
                          LPSTR lpOldPort,
                          LPSTR lpNewPort)
{
    char szDevSec[64];       // [<device>,<port>] section name

    if (!lpDevName)
        return -1;

    if (!lpOldPort)
    {
        char szBuf[10];

        if (!lpNewPort)
            return 0;

        // install a device for the first time. Convert old HPPCL5a settings,
        // which are still under [<device>,<port>], into equivalent new
        // UNIDRV settings under [<device>,<port>], if applicable.
        // Delete old settings that are linked to the device name, but don't
        // delete old settings that are liked to the driver and port (softfonts)

        lstrcpy(szDevSec,lpDevName);
        MakeAppName((LPSTR)szDevSec,lpNewPort,sizeof(szDevSec));

        // check if old settings exist at all
        if(GetProfileString(szDevSec,NULL,NULL,szBuf,sizeof(szBuf)))
        {
            // Do the straight conversions
            ConvertStraight(szDevSec,IDS_OLDPAPERSIZE,IDS_NEWPAPERSIZE);
            ConvertStraight(szDevSec,IDS_OLDPAPERSOURCE,IDS_NEWPAPERSOURCE);
            ConvertStraight(szDevSec,IDS_OLDORIENTATION,IDS_NEWORIENTATION);
            ConvertStraight(szDevSec,IDS_OLDTRUETYPE,IDS_NEWTRUETYPE);
            ConvertStraight(szDevSec,IDS_OLDSEPARATION,IDS_NEWSEPARATION);

            // Convert the simple translations
            ConvertBool(szDevSec,IDS_OLDPAGEPROTECT,IDS_NEWPAGEPROTECT,1);
            ConvertBool(szDevSec,IDS_OLDOUTPUT,IDS_NEWOUTPUT,259);

            // Do the stuff that requires more complicated conversion
            ConvertResolution(szDevSec,lpDevName);
            if(!Convert5eHalfTone(szDevSec))
                Convert5aHalfTone(szDevSec);

	        if(!Convert5eMemory(szDevSec))
		    {
		        if(!Convert5MSMemory(szDevSec))
		            Convert5aMemory(szDevSec);
		    }
	        ConvertVectorMode(szDevSec);

            // Handle soft fonts & cartridges
            HandleFonts(szDevSec,lpDevName,lpNewPort);
        }

        // Flush the cached settings from win.ini
        WriteProfileString(NULL,NULL,NULL);
    }
    else
    {
        int  nCount;

        // move device settings from the old port to the new port, or
        // de-install a device, i.e. remove its device setttings in order
        // to compress the profile.

        // First, check if there is any  soft font installed under the
        // old port. If so, warn the user to copy them over.
        lstrcpy(szDevSec,rgchModuleName);
        MakeAppName((LPSTR)szDevSec,lpOldPort,sizeof(szDevSec));

        if(GetInt(szDevSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE)
            && nCount && lpNewPort)
        {
            NPSTR npTemp;

            if(npTemp=(NPSTR)LocalAlloc(LPTR,TMPSIZE))
            {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,npTemp,TMPSIZE))
                {
                    // Use this API so that the M Box is set to the Foreground
                    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
                    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = npTemp;
		    mbp.lpszCaption = lpOldPort;
                    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
                    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
                LocalFree((HLOCAL)npTemp);
            }
        }
    }

    return UniDevInstall(hWnd,lpDevName,lpOldPort,lpNewPort);
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(HWND  hWnd,
                               LPSTR lpDeviceName,
                               LPSTR lpPortName,
                               BOOL  bSoftFonts)
{
  int          fsVers;
  HANDLE       hFIlib;
  SOFTFONTPROC lpFIns;

  if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    !(lpFIns = (SOFTFONTPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
  {
    if (hFIlib >= 32)
      FreeLibrary(hFIlib);
#ifdef DEBUG
    MessageBox(0,
      "Can't load FINSTAL.DLL or can't get InstallSoftFont",
      NULL, MB_OK);
#endif
    return TRUE;
  }

  // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
  // We choose to ignore the returned "fvers". No use of it.
  fsVers = (*lpFIns)(hWnd,rgchModuleName,lpPortName,
                    (GetKeyState(VK_SHIFT)<0 && GetKeyState(VK_CONTROL)<0),
                    1,	  // dummy value for "fvers".
                    bSoftFonts?CLASS_LASERJET:256);
  FreeLibrary(hFIlib);
  return fsVers;
}



// -------------------------------------------------------------------
//
// Special case control functions wrt SETCHARSET escape. This is necessary
// to avoid breaking Winword and Pagemaker. (note that we don't actually
// do anything with SETCHARSET, but apps break unless we say that we do)
//
// --------------------------------------------------------------------
int FAR PASCAL Control(LPDV  lpdv,
                       short function,
                       LPSTR lpInData,
                       LPSTR lpOutData)
{
    // Tell app that SETCHARSET is supported
    if(QUERYESCSUPPORT == function && *((LPWORD)lpInData) == SETCHARSET)
        return 1;

    // Special case SETCHARSET
    if(SETCHARSET == function)
        return 1;

    // General case
    return UniControl(lpdv, function, lpInData, lpOutData);
}



#ifndef NOFONTMAP

//----------------------------------------------------------------------
// Function: MapFaceName(lplfOld,lplfNew)
//
// Action: Map old face names to their new counterparts. Do as little
//         work as we possibly can, since this function gets called
//         often & we don't want to impact performance. Optimize
//         the whole search to the case where we don't find a match,
//         as this will be the most common scenario.
//
// Return: A pointer to the LOGFONT to actually hand to Unidrv. Cast
//         the return to a LPSTR, just so the compiler is happy.
//----------------------------------------------------------------------
LPSTR NEAR PASCAL MapFaceName(LPLOGFONT lplfOld,
                              LPLOGFONT lplfNew)
{
    LPLOGFONT   lpReturn=lplfOld;   // By default
    NPFACEINDEX pIndex;
    LPSTR       lpFace=lplfOld->lfFaceName;
    BYTE        cTest=*lpFace++;

    // Determine range of possible matches in the table. Since the
    // table is sorted alphabetically, we may be able to bail out
    // before we reach the end of the table.
    for(pIndex=FaceIndex;cTest > pIndex->cFirstChar;pIndex++)
        ;

    // Only proceed if the first character matches and this isn't the
    // firewall (cTest = \xFF).
    if(cTest==pIndex->cFirstChar && ('\xFF' != cTest))
    {
        WORD  wStartIndex=(WORD)(pIndex->bIndex);
        WORD  wStopIndex=(WORD)((pIndex+1)->bIndex);
        WORD  wLoop=wStartIndex;
        NPSTR npMapFace=&(FaceMap[wStartIndex].szOldFace[1]);
        BYTE  cMapFace;

        // Check the rest of the string against the table entries.
        // This search routine takes advantage of the fact that
        // the old face names in the table are fully sorted alphabetically.
        // This search routine takes advantage of the fact that our table
        // is fully sorted, and doesn't do a full string comparison until
        // we actually think we have a match. Once we think there's a match,
        // we'll double-check the entire string to prevent false triggering.

        while(wLoop < wStopIndex)
        {
            // Look for a match. At this point, match a wildcard to
            // anything--we'll do a more stringent check later on, if we
            // think we have a match. Stop if cTest is NULL.
            while((((cTest=*lpFace)==(cMapFace=*npMapFace)) ||
                ('\x01'==cMapFace)) && cTest)
            {
                npMapFace++;
                lpFace++;
            }

            // We arrive here via two conditions: (1) we've reached the
            // end of lpFace and cTest is NULL, or (2) cMapFace and cTest
            // failed to compare. We should only continue searching if
            // cMapFace is non-NULL and cTest is larger than cMapFace (take
            // advantage of the fact that FaceMap is sorted alphabetically).
            // For overall performance, check for the no match case first.

            // Move to the next table entry as long as there's still a
            // chance to find a match.
            if(cTest > cMapFace)
            {
                npMapFace+=sizeof(FACEMAP);
                wLoop++;
                continue;     // Go to the next iteration
            }

            // if cTest is non-NULL, then the sorting of the table guarantees
            // that there are no matches. Bail out now.
            if(cTest)
                goto MFN_exit;

            // cTest is NULL, so we will not make another iteration. The
            // only thing left to decide is whether or not we have a match
            // with the current string.
            if(cMapFace)
                goto MFN_exit;

            // The guards above ensure that we only arrive here if both
            // cTest and cMapFace are NULL, which means that if we're
            // going to find a match, this string is it. We took shortcuts
            // in the comparisons above, so do a stringent comparison now
            // to be sure that this is really a match. The only characters
            // to match wildcards are '1' and 'N', since these are the only
            // ones used in previous versions of the driver.

            for(lpFace=lplfOld->lfFaceName,npMapFace=FaceMap[wLoop].szOldFace;
                (cMapFace=*npMapFace) && (cTest=*lpFace);
                npMapFace++,lpFace++)
            {
                if(!((cTest==cMapFace) ||
                    (('\x01'==cMapFace)&&(('1'==cTest)||('N'==cTest)))))
                {
                    // False trigger--bail out without changing facename
                    goto MFN_exit;
                }
            }

            // We now know that this really is a match--keep the requested
            // attributes & change just the face name.

            *lplfNew=*lplfOld;
            lstrcpy(lplfNew->lfFaceName,FaceMap[wLoop].szNewFace);
            lpReturn=lplfNew;
            goto MFN_exit;
        }
    }

MFN_exit:

    return (LPSTR)lpReturn;
}


#endif

//----------------------------------------------------------------------
// Function: RealizeObject(lpdv,sStyle,lpInObj,lpOutObj,lpTextXForm)
//
// Action: Hook this out to enable font substitution. If the object isn't
//         a font, do absolutely nothing.
//
// Return: Save as UniRealizeObject().
//----------------------------------------------------------------------
DWORD FAR PASCAL RealizeObject(LPDV        lpdv,
                               short       sStyle,
                               LPSTR       lpInObj,
                               LPSTR       lpOutObj,
                               LPTEXTXFORM lpTextXForm)
{
#ifndef NOFONTMAP

    LOGFONT   lfNew;

    if(OBJ_FONT==sStyle)
        lpInObj=MapFaceName((LPLOGFONT)lpInObj,&lfNew);

#endif

    return UniRealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm);
}

#endif // WINNT


#ifndef  WINNT
//swpark
//--------------------------**fnOEMOutputChar*---------------------------------//
// Function:    fnOEMOutputChar()
// 
// Action:      Output n characters pointed to by lpStr. Translation happens
//              on any extended characters in lpStr before printing.
//
// Notes:       We go through lpStr printing each character until we need to
//              translate for an extended character. 
//              We call SubstituteExtendedChar() which will read the device
//              data for this model if it has not already been retrieved.
//              We  get an offset into the translation table and print
//              those characters which represent that extended character.
//
//              We then return from SubstituteExtendedChar() and continue
//              printing the contents of lpStr.
//              We currently do not call Unidrv to handle this if no change             
//              has been made to the default translation set via the TTY UI.

#define OFFSET_HCURRENTCTT 258
static LPWORD lpwTailFirst;
static LPWORD lpwTailFirstX;
static LPBYTE lpbLeadMap;
static LPBYTE lpbLeadMapX;
static LPBYTE lpbTailOff;
static LPBYTE lpbTailOffX;
static LPBYTE lpbTailTable;
void near pascal OutputMachine (LPDV lpdv, LPSTR lpStr, WORD n);
// VOID _loadds far pascal fnOEMOutputChar(LPDV lpdv, LPSTR lpStr, WORD n, short rcID)
VOID   FAR PASCAL fnOEMOutputChar(LPDV lpdv, LPSTR lpStr, WORD n, short rcID)
{
    #define OFFSET_1  4
    #define OFFSET_2  158
    #define OFFSET_3  312
    #define OFFSET_4  337
    #define OFFSET_5  407
    #define OFFSET_6  432
    #define OFFSET_7  502
    HANDLE hCTT;
    LPSTR lpCtt;

    hCTT = *(LPHANDLE)((LPSTR)lpdv+OFFSET_HCURRENTCTT);
#ifdef DEBUG
    DBMSG ("hCTT = %d\n", hCTT);
#endif
    if (hCTT &&
        (lpCtt = (LPSTR)LockResource(hCTT))) {
        lpwTailFirst = (LPWORD)((LPSTR)lpCtt + OFFSET_1);
        lpwTailFirstX= (LPWORD)((LPSTR)lpCtt + OFFSET_2);
        lpbLeadMap   = (LPBYTE)lpCtt + OFFSET_3;
        lpbLeadMapX  = (LPBYTE)lpCtt + OFFSET_4;
        lpbTailOff   = (LPBYTE)lpCtt + OFFSET_5;
        lpbTailOffX  = (LPBYTE)lpCtt + OFFSET_6;
        lpbTailTable = (LPBYTE)lpCtt + OFFSET_7;
        #ifdef DEBUG
        DBMSG("   lpwTailFirst[0] = %d\n", lpwTailFirst[0]);
        DBMSG("   lpwTailFirst[1] = %d\n", lpwTailFirst[1]);
        DBMSG("   lpwTailFirstX[0]= %d\n", lpwTailFirstX[0]);
        DBMSG("   lpwTailFirstX[1]= %d\n", lpwTailFirstX[1]);
        DBMSG("   lpbLeadMap[0]   = %d\n", lpbLeadMap[0]);
        DBMSG("   lpbLeadMap[1]   = %d\n", lpbLeadMap[1]);
        DBMSG("   lpbLeadMapX[0]  = %d\n", lpbLeadMapX[0]);
        DBMSG("   lpbLeadMapX[1]  = %d\n", lpbLeadMapX[1]);
        DBMSG("   lpbTailOff[0]   = %d\n", lpbTailOff[0]);
        DBMSG("   lpbTailOff[1]   = %d\n", lpbTailOff[1]);
        DBMSG("   lpbTailOffX[0]  = %d\n", lpbTailOffX[0]);
        DBMSG("   lpbTailOffX[1]  = %d\n", lpbTailOffX[1]);
        DBMSG("   lpbTailTable[0] = %d\n", lpbTailTable[0]);
        DBMSG("   lpbTailTable[1] = %d\n", lpbTailTable[1]);
        #endif
        #ifdef DEBUG
        DBMSG ("Sucess Lock CTT\n");
        #endif
	OutputMachine (lpdv, lpStr, n);
        UnlockResource(hCTT);
    }else{
#ifdef DEBUG
        DBMSG ("Fail Lock CTT\n");
#endif
      WriteSpoolBuf(lpdv, lpStr, n);
    }
}

int near  pascal IsHangeul( WORD wXW );
WORD near pascal ConvertToChoHap (WORD wCh);
void near pascal OutputMachine (LPDV lpdv, LPSTR lpStr, WORD n)
{
    #define S_HANGEUL 1
    #define S_REMAINS 2
    #define SET_CHOHAP  "\033(18H",5
    #define SET_WANSUNG "\033(19H",5
    int state;
    short i;
    WORD  wCh;
    LPSTR lpT = lpStr;

    state = S_HANGEUL;
    for (i=n; i > 0;) {
        if (IsDBCSLeadByte(*lpT) && i>1) {
#ifdef DEBUG
            DBMSG ("   IsHangeul() = %d\n", IsHangeul( *(LPWORD)lpT) );
#endif
            if ( IsHangeul(*(LPWORD)lpT)) {
                if (state==S_REMAINS) {
                    WriteSpoolBuf(lpdv, SET_CHOHAP); 
                    state = S_HANGEUL;
                }
                wCh = ConvertToChoHap (*(LPWORD)lpT);
                WriteSpoolBuf(lpdv, (LPSTR)&wCh, 2);
            }else{
                if (state==S_HANGEUL) {
                    WriteSpoolBuf(lpdv, SET_WANSUNG); 
                    state = S_REMAINS;
                }
                WriteSpoolBuf(lpdv, lpT, 2);
            }
            lpT+=2; i-=2;
        }else{
            if (state==S_HANGEUL) {
                WriteSpoolBuf(lpdv, SET_WANSUNG); 
               state = S_REMAINS;
            }
            WriteSpoolBuf(lpdv, lpT, 1);
            lpT++; i--;
        }
    }
    if (state==S_REMAINS) WriteSpoolBuf(lpdv, SET_CHOHAP); 
}


int near  pascal IsHangeul( WORD wXW )
{
    #define  XWT_INVALID    0xFF
    #define  XWT_EXTENDED   0x01
    #define  XWT_WANSUNG    0x02
    #define  XWT_JUNJA      0x03
    #define  XWT_HANJA      0x04
    #define  XWT_UDC        0x05
    static BYTE  iXWType[8][3] =
    {
      XWT_EXTENDED, XWT_EXTENDED, XWT_EXTENDED,    // Lead = 0x81-0xA0
      XWT_EXTENDED, XWT_EXTENDED, XWT_JUNJA,       // Lead = 0xA1-0xAC
      XWT_EXTENDED, XWT_EXTENDED, XWT_INVALID,     // Lead = 0xAD-0xAF
      XWT_EXTENDED, XWT_EXTENDED, XWT_WANSUNG,     // Lead = 0xB0-0xC5
      XWT_EXTENDED, XWT_INVALID,  XWT_WANSUNG,     // Lead = 0xC6
      XWT_INVALID,  XWT_INVALID,  XWT_WANSUNG,     // Lead = 0xC7-0xC8
      XWT_INVALID,  XWT_INVALID,  XWT_UDC,         // Lead = 0xC9, 0xFE
      XWT_INVALID,  XWT_INVALID,  XWT_HANJA        // Lead = 0xCA-0xFD
   };
   BYTE  bT = (BYTE) (( wXW >> 8 ) & 0xFF);
   BYTE  bL = (BYTE) (wXW & 0xFF);
   int   iLType = -1, iTType = -1;
   WORD wRet;

#ifdef DEBUG
DBMSG ("   In GetXWType, bL =%d\n", bL);
DBMSG ("   In GetXWType, bT =%d\n", bT);
#endif

   if ( ( bT >= 0x41 ) && ( bT <= 0xFE ) )
   {
      if ( bT <= 0x52 )
         iTType = 0;       // Tail Range 0x41-0x52
      else
      {
         if ( bT >= 0xA1 )
            iTType = 2;    // Tail Range 0xA1-0xFE
         else if ( ( bT <= 0x5A ) || ( bT >= 0x81 ) ||
                   ( ( bT >= 0x61 ) && ( bT <= 0x7A ) ) )
            iTType = 1;    // Tail Range 0x53-0x5A, 0x61-0x7A, 0x81-0xA0
      }
   }
   if ( iTType < 0 )  return( 0 );

   if ( ( bL >= 0x81 ) && ( bL <= 0xFE ) )
   {
      if ( bL < 0xB0 )
      {
         if ( bL <= 0xA0 )
            iLType = 0;       // Lead Range 0x81-0xA0
         else if ( bL <= 0xAC )
            iLType = 1;       // Lead Range 0xA1-0xAC
         else
            iLType = 2;       // Lead Range 0xAD-0xAF
      }
      else
      {
         if ( bL <= 0xC8 )
         {
            if ( bL < 0xC6 )
               iLType = 3;    // Lead Range 0xB0-0xC5
            else if ( bL == 0xC6 )
               iLType = 4;    // Lead Range 0xC6
            else
               iLType = 5;    // Lead Range 0xC7-0xC8
         }
         else
         {
            if ( ( bL == 0xC9 ) || ( bL == 0xFE ) )
               iLType = 6;    // Lead Range 0xC9, 0xFE
            else
               iLType = 7;    // Lead Range 0xCA-0xFD
         }
      }
   }

   wRet = ( iLType < 0 ) ? -1 : iXWType[iLType][iTType];
   if (wRet == XWT_WANSUNG || wRet == XWT_EXTENDED)
       return wRet;
   else return 0;
}

WORD near pascal ConvertToChoHap (WORD wCh)
{
   LPWORD  lpTF;
   int   iTO;
   BYTE  bL, bT, bJS;
   WORD wCh1;

   wCh1 = wCh<<8;
   wCh1 |= wCh>>8;

   switch ( IsHangeul(wCh) )
   {
      case  XWT_EXTENDED :
         bL = (BYTE) (( ( wCh1 >> 8 ) & 0xFF ) - 0x81);
         bT = (BYTE) (wCh1 & 0xFF);
         if ( ( bT -= 0x41 ) > 0x19 )
            if ( ( bT -= 6 ) > 0x33 )
               bT -= 6;
         iTO = bT + lpbTailOffX[bL];
         lpTF = lpwTailFirstX + ( bL = lpbLeadMapX[bL] );
         goto FindHangeul;
      case  XWT_WANSUNG :
#ifdef DEBUG
DBMSG("   case XWT_WANSUGN\n");
#endif
         bL = (BYTE) (( ( wCh1 >> 8 ) & 0xFF ) - 0xB0);
         iTO = ( wCh1 & 0xFF ) - 0xA1 + lpbTailOff[bL];
         lpTF = lpwTailFirst + ( bL = lpbLeadMap[bL] );
         goto FindHangeul;
      default :
         return (0x6188);
   }

FindHangeul:
   iTO += *lpTF++;
   while ( iTO >= *lpTF++ )  bL++;
   //return ( (WORD)(bL+0x88) * 256 + lpbTailTable[iTO] );
   return ( (WORD)lpbTailTable[iTO]  * 256 + (bL+0x88) );

FindSymbol:
   bL = (BYTE) (( wCh1 >> 8 ) & 0xFF);
   bT = (BYTE) (wCh1 & 0xFF);
   if ( ( bL & 1 ) == 0 )
      bT -= ( ( bT <= 0xEE ) ? 0x70 : 0x5E );
   bJS += ( bL / 2 );
   //return ((WORD) bJS * 256 + bT );
   return ( (WORD)bT * 256 + bJS );
}

//-----------------------------**Enable**-----------------------------------//
// Function: Enable()
// Action:   We setup the callback to fnOEMOutPutChar and call UniEnable.
// ------------------------------------------------------------------------

short CALLBACK Enable(
LPDV lpdv,
WORD style,
LPSTR lpModel,
LPSTR lpPort,
LPDM lpStuff)
{
  CUSTOMDATA cd;
  
  cd.cbSize = sizeof(CUSTOMDATA);
  cd.hMd = GetModuleHandle((LPSTR)rgchModuleName);
  cd.fnOEMDump = NULL;
  cd.fnOEMOutputChar = (LPFNOEMOUTPUTCHAR)fnOEMOutputChar;
  return  UniEnable(lpdv, style, lpModel, lpPort, lpStuff, &cd);
}


#ifdef DEBUG
static char logbuf[100];
void NEAR CDECL  DBMSG(LPSTR lpFmt, BYTE arg)
{

    if (lpFmt) {
        wvsprintf(logbuf, lpFmt, (LPSTR)&arg);
        OutputDebugString(logbuf);
     }
}
#endif  // DEBUG

#endif  //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pcl5zres\etc\strings.h ===
// STRINGS.H
//
// IDs for string contants used within the minidriver. Start these nice
// and high, so avoid conflicts with strings from within the minidriver

#define IDS_OLD_5E_DRIVERNAME 4800
#define IDS_OLD_5A_DRIVERNAME 4801
#define IDS_OLDMEMORY         4802
#define IDS_OLDPAPERSIZE      4803
#define IDS_OLDPAPERSOURCE    4804
#define IDS_OLD_5A_RESOLUTION 4805
#define IDS_OLD_5E_RESOLUTION 4806
#define IDS_OLDORIENTATION    4807
#define IDS_OLDPAGEPROTECT    4808
#define IDS_OLDGRAYSCALE      4809
#define IDS_OLDBRIGHTNESS     4810
#define IDS_OLD_5E_HALFTONE   4811
#define IDS_OLDTRUETYPE       4812
#define IDS_OLDOUTPUT         4813
#define IDS_OLDSEPARATION     4814
#define IDS_NEWMEMORY         4815
#define IDS_NEWPAPERSIZE      4816
#define IDS_NEWPAPERSOURCE    4817
#define IDS_NEWRESOLUTION     4818
#define IDS_NEWYRESOLUTION    4819
#define IDS_NEWORIENTATION    4820
#define IDS_NEWPAGEPROTECT    4821
#define IDS_NEWBRUSH          4822
#define IDS_NEWINTENSITY      4823
#define IDS_NEWTRUETYPE       4824
#define IDS_NEWOUTPUT         4825
#define IDS_NEWSEPARATION     4826
#define IDS_CARTRIDGES        4827
#define IDS_OLDVECTORMODE     4828
#define IDS_NEWVECTORMODE     4829
#define IDS_CARTINDEX         4830
#define IDS_CARTRIDGE         4831
#define IDS_CARTRIDGECOUNT    4832
#define IDS_FONTSUMMARY       4833
#define IDS_SOFTFONTS         4834
#define IDS_SOFTFONTFORMAT    4835
#define IDS_SOFTFONTTEST      4836
#define IDS_SOFTFONTWARNING   4837
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pcl5tres\etc\strings.h ===
// STRINGS.H
//
// IDs for string contants used within the minidriver. Start these nice
// and high, so avoid conflicts with strings from within the minidriver

#define IDS_OLD_5E_DRIVERNAME 4800
#define IDS_OLD_5A_DRIVERNAME 4801
#define IDS_OLDMEMORY         4802
#define IDS_OLDPAPERSIZE      4803
#define IDS_OLDPAPERSOURCE    4804
#define IDS_OLD_5A_RESOLUTION 4805
#define IDS_OLD_5E_RESOLUTION 4806
#define IDS_OLDORIENTATION    4807
#define IDS_OLDPAGEPROTECT    4808
#define IDS_OLDGRAYSCALE      4809
#define IDS_OLDBRIGHTNESS     4810
#define IDS_OLDTRUETYPE       4811
#define IDS_OLDOUTPUT         4812
#define IDS_OLDSEPARATION     4813
#define IDS_NEWMEMORY         4814
#define IDS_NEWPAPERSIZE      4815
#define IDS_NEWPAPERSOURCE    4816
#define IDS_NEWRESOLUTION     4817
#define IDS_NEWYRESOLUTION    4818
#define IDS_NEWORIENTATION    4819
#define IDS_NEWPAGEPROTECT    4820
#define IDS_NEWBRUSH          4821
#define IDS_NEWINTENSITY      4822
#define IDS_NEWTRUETYPE       4823
#define IDS_NEWOUTPUT         4824
#define IDS_NEWSEPARATION     4825
#define IDS_CARTRIDGES        4826
#define IDS_OLDVECTORMODE     4827
#define IDS_NEWVECTORMODE     4828
#define IDS_CARTINDEX         4829
#define IDS_CARTRIDGE         4830
#define IDS_CARTRIDGECOUNT    4831
#define IDS_FONTSUMMARY       4832
#define IDS_SOFTFONTS         4833
#define IDS_SOFTFONTFORMAT    4834
#define IDS_SOFTFONTTEST      4835
#define IDS_SOFTFONTWARNING   4836
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pcl5tres\etc\pcl5msc.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//-----------------------------------------------------------------------------


#include "strings.h"

char *rgchModuleName = "PCL5MSC";
char szNone[]="";

// The following are defined to ensure that we upgrade correctly from the
// HPPCL5a, HPPCL5e and Win 3.11 HPPCL5MS drivers

#define MAX_LJ4_MBMEMSETTING    68    // from HP tech specification
#define KB_THRESHOLD            200   // kb range check,needed for conversion


#define PRINTDRIVER
#include <print.h>
#include "gdidefs.inc"
#include "mdevice.h"
#include "unidrv.h"
#include "minidriv.h"

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#ifndef WINNT
short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

// typedef for atom stuff--what a nuisance!
typedef struct tagSFNODE
{
    WORD wIndex;
    ATOM atom;
} SFNODE, FAR *LPSFNODE;

// Typedef for Font Installer procedure
typedef int (FAR * PASCAL SOFTFONTPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

HINSTANCE hInst;

#define DEFAULT_INT      32767

#define SOFT_FONT_THRES  25  // build font summary, if over this limit

#define MAX_CART_INDEX	 12

#define TMPSIZE         256

// Define these so they happily use the same values as the HPPCL5E driver.
#define GS_PHOTO     0
#define GS_LINEART   1
#define GS_SCANJET   2


// map old HPPCL5a's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL5a .rc file.
// Note that we do not have "International Collection" cartridge and we
// map it to index 0 (arbitrarily).
int rgNewCartMap[12] = {0, 8, 7, 2, 3, 0, 5, 6, 1, 4, 9, 10};

// String to determine if we have a member of the LaserJet 4 family
char szLJ4[]="HP LaserJet 4";

// Stuff needed for mapping old facenames to new versions
#ifndef NOFONTMAP

typedef struct tagFACEMAP
{
    char szOldFace[LF_FACESIZE];
    char szNewFace[LF_FACESIZE];
} FACEMAP, NEAR * NPFACEMAP;

typedef struct tagFACEINDEX
{
    BYTE cFirstChar;
    BYTE bIndex;
} FACEINDEX, NEAR * NPFACEINDEX;

FACEMAP FaceMap[]={{"Albertus (W\x01)",         "Albertus Medium"},
                   {"Albertus Xb (W\x01)",      "Albertus Extra Bold"},
                   {"Antique Olv (W\x01)",      "Antique Olive"},
                   {"Antique Olv Cmpct (W\x01)","Antique Olive Compact"},
                   {"CG Bodoni (W\x01)",        "CG Bodoni"},
                   {"CG Cent Schl (W\x01)",     "CG Century Schoolbook"},
                   {"CG Omega (W\x01)",         "CG Omega"},
                   {"CG Palacio (W\x01)",       "CG Palacio"},
                   {"CG Times (W\x01)",         "CG Times"},
                   {"Clarendon Cd (W\x01)",     "Clarendon Condensed"},
                   {"Cooper Blk (W\x01)",       "Cooper Black"},
                   {"Coronet (W\x01)",          "Coronet"},
                   {"Courier (W\x01)",          "Courier"},
                   {"Garmond (W\x01)",          "Garamond"},
                   {"ITC Benguat (W\x01)",      "ITC Benguiat"},
                   {"ITC Bookman Db (W\x01)",   "ITC Bookman Demi"},
                   {"ITC Bookman Lt (W\x01)",   "ITC Bookman Light"},
                   {"ITC Souvenir Db (W\x01)",  "ITC Souvenir Demi"},
                   {"ITC Souvenir Lt (W\x01)",  "ITC Souvenir Light"},
                   {"Letter Gothic (W\x01)",    "Letter Gothic"},
                   {"Marigold (W\x01)",         "Marigold"},
                   {"Revue Lt (W\x01)",         "Revue Light"},
                   {"Shannon (W\x01)",          "Shannon"},
                   {"Shannon Xb (W\x01)",       "Shannon Extra Bold"},
                   {"Stymie (W\x01)",           "Stymie"},
                   {"Univers (W\x01)",          "Univers"},
                   {"Univers Cd (W\x01)",       "Univers Condensed"}};


FACEINDEX FaceIndex[]={{'A',0},
                       {'C',4},
                       {'G',13},
                       {'I',14},
                       {'L',19},
                       {'M',20},
                       {'R',21},
                       {'S',22},
                       {'U',25},
                       {(BYTE)'\xFF',27}};  // Provide an upper limit
                                            // to the search for 'U'.

#endif


//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
                    WORD   wDataSeg,
                    WORD   cbHeapSize,
                    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}


//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
    short   length, count;
    LPCSTR  lpTmp;
    LPCSTR  lpLastColon = NULL;

    length = lstrlen(lpAppName);

    if (!lpPortName)
        return length;

    if (length == 0 || length > max - lstrlen(lpPortName))
        return -1;

    // insert the comma
    lpAppName[length++] = ',';

    // append the port name but do not want the last ':', if any.
    for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
        if (*lpTmp == ':')
            lpLastColon = lpTmp;
        if (lpLastColon && lpLastColon == lpTmp - 1)
            count = lpLastColon - lpPortName;
        else
            count = lpTmp - lpPortName;

    lstrcpy((LPSTR)&lpAppName[length], lpPortName);

    length += count;
    lpAppName[length]='\0';

    return length;
}

#define KEY_BUF_SIZE  256


//---------------------------------------------------------------------------
// Function: GetInt(lpSection,lpKey,lpnValue,nDefault,bRemove)
//
// Action: Load the appropriate string from the resources, then get the
//         specified integer from the section. Remove the old entry if
//         it exists and it bRemove is TRUE.
//
// Return: TRUE if we actually found a value, FALSE if not.
//---------------------------------------------------------------------------
BOOL NEAR PASCAL GetInt(LPSTR  lpSection,
                        LPCSTR lpKey,
                        LPINT  lpnValue,
                        int    nDefault,
                        BOOL   bRemove)
{
    char szKeyName[60];
    int  nTest;

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    nTest=GetProfileInt(lpSection,szKeyName,DEFAULT_INT);

    if(DEFAULT_INT != nTest)
    {
        *lpnValue=nTest;

        if(bRemove)
            WriteProfileString(lpSection,szKeyName,NULL);

        return TRUE;
    }

    // Section doesn't exist--use default
    *lpnValue=nDefault;
    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteInt(lpSection,lpKey,nValue)
//
// Action: Write an integer value to the specified section of win.ini.
//
// Return: TRUE if successful, FALSE if not.
//-------------------------------------------------------------------------
BOOL NEAR PASCAL WriteInt(LPSTR  lpSection,
                          LPCSTR lpKey,
                          int    nValue)
{
    char szKeyName[60];
    char szValue[10];

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    wsprintf(szValue,"%u",nValue);

    return WriteProfileString(lpSection,szKeyName,szValue);
}


//---------------------------*MergeFontLists*-----------------------------
// Action: Merge the old and new soft fonts. In most cases when we get
//         called, we really don't do much of anything, because the
//         font lists are identical. However, we have to do some fun
//         stuff to merge the lists if they're different.
//         We know how many soft font entries exist in each section,
//         via the "SoftFonts" int, but the entries may be non-consecutive.
//
// Note:   This stomps all over the passed in buffer
//
// Return: TRUE if successfully conpleted, FALSE if not
//------------------------------------------------------------------------
BOOL NEAR PASCAL MergeFontLists(LPSTR lpOldSec,
                                LPSTR lpNewSec,
                                LPSTR lpTmp)
{
    WORD     wOldFonts;
    WORD     wNewFonts;
    LPSFNODE lpFonts;
    WORD     wMergedFonts=0;
    WORD     wLoop;
    WORD     wFound;
    WORD     wNewIndex;
    BYTE     szKey[20];

    // Get these values outside of the if statement, otherwise the compiler
    // may optimize out the assignment of wNewFonts
    GetInt(lpOldSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wOldFonts,0,FALSE);
    GetInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wNewFonts,0,FALSE);

    if(wOldFonts || wNewFonts)
    {
        char szFormat[30];

        // Get a block big enough for the worst case--no common fonts
        if(!(lpFonts=(LPSFNODE)GlobalAllocPtr(GHND,
            (DWORD)(wOldFonts+wNewFonts)*sizeof(SFNODE))))
        {
            return FALSE;
        }

        // We need a formatting string
        LoadString(hInst,IDS_SOFTFONTFORMAT,szFormat,sizeof(szFormat));

        // Put fonts from lpNew Sec first in the list. This way, if we have
        // already updated at least one driver from 5A to 5MS and the soft
        // fonts haven't changed, our old font summary file is still valid.
        // Unidrv will automatically recreate the font summary file if it
        // sees that the number of soft fonts has changed. Even though we
        // know how many soft font entries exist, we don't know that they
        // will be sequential. (They may not be if one was added, then
        // deleted). Keep track of the original offset. Even though the
        // font installer seems to be 1-based, start looking at 0, just
        // to be safe.
        for(wLoop=0,wFound=0;wFound<wNewFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpNewSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                lpFonts[wMergedFonts].wIndex=wLoop;
                lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                wFound++;
            }
        }
    
        // Remember where we left off in numbering the entries
        wNewIndex=wLoop;

        // Read fonts from lpOldSec--create atoms for new entries
        for(wLoop=0,wFound=0;wFound<wOldFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpOldSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                wFound++;
                if(!GlobalFindAtom(lpTmp))
                {
                    lpFonts[wMergedFonts].wIndex=wLoop;
                    lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                }
            }
        }

        // Write out the list of atoms--do the entries from lpNewSec first
        WriteInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),wMergedFonts);
        for(wLoop=0;wLoop<wNewFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,lpFonts[wLoop].wIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
        }

        // Now write out the entries that were in lpOldSec but not in lpNewSec.
        // Since the actual numbering of these entries is arbitrary, just
        // start numbering them at wNewIndex and increment each time.
        for(wLoop=wNewFonts;wLoop<wMergedFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,wNewIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
            wNewIndex++;
        }

        GlobalFreePtr(lpFonts);
    }

    return TRUE;
}


//----------------------*AddMissingEntries*-----------------------------
// Action: Copy any entries that appear in lpOldSec but not lpNewSec to
//         lpNewSec, but don't copy any entries relevant to soft fonts
//         (These entries will be copied in MergeFontSections).
//
// Return: TRUE if successful, FALSE if not
//----------------------------------------------------------------------
BOOL NEAR PASCAL AddMissingEntries(LPSTR lpOldSec,
                                   LPSTR lpNewSec,
                                   LPSTR lpTmp)
{
    WORD  wSize;
    LPSTR lpBuf;
    LPSTR lpWork;
    char  szTest2[30];
    char  szTest1[30];
    int   nLength;

    // Get the key names into buffers
    wSize=KEY_BUF_SIZE;

    if(!(lpBuf=GlobalAllocPtr(GHND,(DWORD)wSize)))
        return FALSE;
    while((WORD)GetProfileString(lpOldSec,NULL,szNone,lpBuf,wSize)==wSize-2)
    {
        wSize*=2;
        if(lpWork=GlobalReAllocPtr(lpBuf,(DWORD)wSize,GHND))
            lpBuf=lpWork;
        else
        {
            GlobalFreePtr(lpBuf);
            return FALSE;
        }
    }

    // Load some strings
    LoadString(hInst,IDS_FONTSUMMARY,szTest1,sizeof(szTest1));
    nLength=LoadString(hInst,IDS_SOFTFONTTEST,szTest2,sizeof(szTest2));

    // Now examine each entry, copy it if we want to keep it, and return TRUE
    // There are two cases where we don't want to copy the file--the key
    // named FontSummary and all keys that begin with "SoftFont"
    lpWork=lpBuf;
    while(wSize=(WORD)lstrlen(lpWork))
    {
        // Font Summary?
        if(lstrcmpi(lpWork,szTest1))
        {
            // Soft Font Entry?
            lstrcpy(lpTmp,lpWork);
            lpTmp[nLength]='\0';
            if(lstrcmpi(lpTmp,szTest2))
            {
                // Add this entry if it doesn't already exist in the new section
                if(!GetProfileString(lpNewSec,lpWork,szNone,lpTmp,TMPSIZE))
                {
                    GetProfileString(lpOldSec,lpWork,szNone,lpTmp,TMPSIZE);
                    WriteProfileString(lpNewSec,lpWork,lpTmp);
                }
            }
        }
        lpWork+=(wSize+1);
    }

    GlobalFreePtr(lpBuf);
    return TRUE;
}


//---------------------------*HandleSoftFonts*---------------------------
// Action: Transfer the soft fonts between old and new entries. First we
//         copy any entries that don't already exist in the new section,
//         with the exception of soft font information. Then we go ahead
//         and merge the soft fonts, so the end result in the new section
//         is the union of the old and new soft fonts.
//
// Return: TRUE if success, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL HandleSoftFonts(LPSTR lpszOldSec,
                                 LPSTR lpszNewSec)
{
    char szTmp[TMPSIZE];

    if(AddMissingEntries(lpszOldSec,lpszNewSec,szTmp))
        return MergeFontLists(lpszOldSec,lpszNewSec,szTmp);

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertStraight(lpSection,nOldID,nNewID)
//
// Action: Convert a section setting without translation
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertStraight(LPSTR lpSection,
                                 int   nOldID,
                                 int   nNewID)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nValue);
        return TRUE;
    }

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertBool(lpSection,nOldID,nNewID,nNewValue)
//
// Action: Convert a section with minimal translation. If the old section
//         existed and was non-zero, write nNewValue to the new section.
//         If the old section existed and was 0, write 0 to the new section.
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertBool(LPSTR lpSection,
                             int   nOldID,
                             int   nNewID,
                             int   nNewValue)
{
    int nOldValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nOldValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nOldValue?nNewValue:0);
        return TRUE;
    }

    return FALSE;
}

//------------------------------------------------------------------------
// Function: ConvertVectorMode(lpSection)
//
// Action: Convert the graphics mode setting
//         Cannot do straight conversion as defaults dont match
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertVectorMode(LPSTR lpSection)
{
    int nValue;

    GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDVECTORMODE),&nValue,1,TRUE);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWVECTORMODE),nValue);
    return TRUE;

}



//------------------------------------------------------------------------
// Function: ConvertResolution(lpSection,lpModel)
//
// Action: Convert the old resolution section to the new one
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertResolution(LPSTR lpSection,
                                   LPSTR lpModel)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5A_RESOLUTION),&nValue,0,TRUE))
    {
        LPSTR lpLJ4=szLJ4;
        LPSTR lpCheck=lpModel;
        BOOL  bLJ4=TRUE;

        nValue=300/(1<<nValue);

        // Compare the passed-in model to szLJ4. If lpModel begins with the
        // substring "HP LaserJet 4", then lpLJ4 will point to NULL when we
        // exit the loop.
        while(*lpLJ4 == *lpCheck)
        {
            lpLJ4++;
            lpCheck++;
        }

        if(!*lpLJ4)
        {
            // This is in the LJ4 family--check if it's a 4L or 4ML
            if(lstrcmp(lpCheck,"L") && lstrcmp(lpCheck,"ML"))
            {
                int nTest;

                // Device is capable of 600 dpi--check the value for
                // "printerres".

                GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_RESOLUTION),
                    &nTest,600,TRUE);

                if(600==nTest)
                    nValue<<=1;
            }
        }

        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWRESOLUTION),nValue);
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWYRESOLUTION),nValue);

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteHalfTone(lpSection,nIndex)
//
// Action: Write the halftoning data to win.ini
//
// Return: VOID
//-------------------------------------------------------------------------
VOID NEAR PASCAL WriteHalfTone(LPSTR lpSection,
                               int   nIndex)
{
    int nBrush;
    int nIntensity;

    switch(nIndex)
    {
        case GS_LINEART:
            nBrush=RES_DB_LINEART;
            nIntensity=100;
            break;

        case GS_SCANJET:
            nBrush=RES_DB_COARSE;
            nIntensity=150;
            break;

        case GS_PHOTO:
        default:
            nBrush=RES_DB_COARSE;
            nIntensity=100;
            break;
    }

    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWBRUSH),nBrush);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWINTENSITY),nIntensity);
}


//-------------------------------------------------------------------------
// Function: Convert5aHalfTone(lpSection)
//
// Action: Convert the 5A halftoning settings
//
// Return: TRUE if the old section existed, FALSE if not
//-------------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aHalfTone(LPSTR lpSection)
{
    int nIndex;
    int  nGray;
    int  nBright;
    BOOL bGrayScale;
    BOOL bBrightness;

    // See if either setting exists...
    bGrayScale=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDGRAYSCALE),&nGray,
        1,TRUE);
    bBrightness=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDBRIGHTNESS),&nBright,
        0,TRUE);

    if(bGrayScale || bBrightness)
    {
        if(1==nBright)
            nIndex=GS_SCANJET;
        else if(0==nGray)
            nIndex=GS_LINEART;
        else
            nIndex=GS_PHOTO;

        WriteHalfTone(lpSection,nIndex);
        return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5eHalfTone(LPSTR lpSection)
//
// Action: Convert the 5E halftoning settings
//
// Return: TRUE if successful, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eHalfTone(LPSTR lpSection)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_HALFTONE),&nValue,
        0,TRUE))
    {
        WriteHalfTone(lpSection,nValue);
        return TRUE;
    }
    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5aMemory(lpSection)
//
// Action: Convert the memory settings from the old to the new values
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aMemory(LPSTR lpSection)
{
    int nValue;
    int nPrinterMB;

    // Get memory settings--extract from prtindex.
    // Values range from 0 to 28, where 0-4 are the LaserJet III,
    // 5-9 are the LaserJet IIID, 10-14 are the LaserJet IIIP, and
    // 15-28 are the LaserJet IIISi. For indices less than 20, the
    // total MB is the index mod 5, + 1. For indices 20 and above, the
    // total MB is the index - 14, except for 26, 27, and 28, which
    // require special handling because of the increments that memory
    // can be added to the IIISi.
    // The formula used to calculate the settings is derived directly
    // from the values used in the hppcl5a driver. Specifically,
    // AM = 945 * TM - 245, where TM is the total memory in MB, and
    // AM is the available printer memory.

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDMEMORY),&nValue,1,TRUE))
    {
        if(nValue<20)
            nPrinterMB=nValue%5 + 1;
        else
        {
            nPrinterMB=nValue-14;
            if(nValue>25)
            {
                nPrinterMB++;        // 25=11MB, 26=13MB, so add an extra MB.
                if(nValue==28)
                    nPrinterMB+=2;   // 27=14MB, 28=17MB, so add 2 extra MB.
            }
        }

        nValue=945*nPrinterMB-245;
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5eMemory(lpSection)
//
// Action: Convert the HPPCL5E memory settings from the old to the new values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,FALSE))
    {
	if (nValue <= KB_THRESHOLD )
	    {
	    if (nValue > MAX_LJ4_MBMEMSETTING)
		nValue = MAX_LJ4_MBMEMSETTING;  // force it to max value
	    nValue=900*nValue - 450;  // convert to KB, using HP formula
	    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	    return TRUE;
	    }
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5MSMemory(lpSection)
//
// Action: Convert the WFW HPPCL5MS memory settings from the old to the new
//         values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Added for backward compatability
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5MSMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,TRUE))
	{
	nValue = nValue / 900;  // convert to MB value
	nValue = 945*nValue - 245; // formula used in hppcl5a driver
	// used to convert to available mem
	WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	return TRUE;
	}
    return FALSE;
}



//------------------------------------------------------------------------
// Function: HandleFontCartridges(lpSection,lpOldDrvSec,lpNewDrvSec)
//
// Action: Handle font cartridge data
//
// Return: VOID
//------------------------------------------------------------------------
VOID NEAR PASCAL HandleFontCartridges(LPSTR lpSection,
                                      LPSTR lpOldDrvSec,
                                      LPSTR lpNewDrvSec)
{
    int nCount;

    // Get the count of cartridges--if there are no cartridges, do nothing.
    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),&nCount,0,TRUE))
    {
        char  szOldCartKey[16];
        char  szNewCartKey[16];
        short nCart = 0;
        short i;
        short index;
        int   nLength1;
        int   nLength2;

        nLength1=LoadString(hInst,IDS_CARTINDEX,szOldCartKey,
            sizeof(szOldCartKey));
        nLength2=LoadString(hInst,IDS_CARTRIDGE,szNewCartKey,
            sizeof(szNewCartKey));

        for (i = 0; i < nCount; i++)
        {
            if (i > 0)
                wsprintf(szOldCartKey+nLength1,"%d",i);

            // compose cartridge keyname for current driver
            wsprintf(szNewCartKey+nLength2,"%d",i+1);

            if ((index = GetProfileInt(lpNewDrvSec, szOldCartKey, 0)) > 0)
            {
                WriteProfileString(lpNewDrvSec, szOldCartKey, NULL);
                nCart++;
                if (index <= MAX_CART_INDEX)
                    WriteInt(lpSection,szNewCartKey,rgNewCartMap[index-1]);
                else
                    // external cartridges. Simply copy the id over.
                    WriteInt(lpSection,szNewCartKey,index);
            }
        }

        // Save the # of cartridges
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),nCart);
    }
}


//--------------------------------------------------------------------------
// Function: HandleFonts(lpSection,lpDevName,lpPort)
//
// Action: Deal with soft fonts & font cartridges
//
// Return: VOID
//--------------------------------------------------------------------------
VOID NEAR PASCAL HandleFonts(LPSTR lpSection,
                             LPSTR lpDevName,
                             LPSTR lpPort)
{
    char szOldDrvSec[64];   // HPPCL5A,<port> or HPPCL5E,<port>
    char szNewDrvSec[64];   // HPPCL5MS,<port>
    int  nCount;
    BOOL bOldExists=FALSE;  // Does old section exist?

    LoadString(hInst,IDS_OLD_5E_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
    MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

    // See if the old section exists at all. Temporarily borrow szNewDrvSec.

    if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
        sizeof(szNewDrvSec)))
    {
        bOldExists=TRUE;
    }
    else
    {
        // Try the HPPCL5E driver...

	LoadString(hInst,IDS_OLD_5A_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
        MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

        if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
            sizeof(szNewDrvSec)))
        {
            bOldExists=TRUE;
        }
    }


    lstrcpy(szNewDrvSec,rgchModuleName);
    MakeAppName((LPSTR)szNewDrvSec,lpPort,sizeof(szNewDrvSec));

    if(bOldExists)
    {
        HandleSoftFonts(szOldDrvSec,szNewDrvSec);
        HandleFontCartridges(lpSection,szOldDrvSec,szNewDrvSec);
    }

    // create UNIDRV's font summary file, if there are many soft fonts.
    GetInt(szNewDrvSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE);
    if(nCount>SOFT_FONT_THRES)
    {
        HDC hIC;

        if(hIC=CreateIC(rgchModuleName,lpDevName,lpPort,NULL))
            DeleteDC(hIC);
    }
}


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------
int FAR PASCAL DevInstall(HWND  hWnd,
                          LPSTR lpDevName,
                          LPSTR lpOldPort,
                          LPSTR lpNewPort)
{
    char szDevSec[64];       // [<device>,<port>] section name

    if (!lpDevName)
        return -1;

    if (!lpOldPort)
    {
        char szBuf[10];

        if (!lpNewPort)
            return 0;

        // install a device for the first time. Convert old HPPCL5a settings,
        // which are still under [<device>,<port>], into equivalent new
        // UNIDRV settings under [<device>,<port>], if applicable.
        // Delete old settings that are linked to the device name, but don't
        // delete old settings that are liked to the driver and port (softfonts)

        lstrcpy(szDevSec,lpDevName);
        MakeAppName((LPSTR)szDevSec,lpNewPort,sizeof(szDevSec));

        // check if old settings exist at all
        if(GetProfileString(szDevSec,NULL,NULL,szBuf,sizeof(szBuf)))
        {
            // Do the straight conversions
            ConvertStraight(szDevSec,IDS_OLDPAPERSIZE,IDS_NEWPAPERSIZE);
            ConvertStraight(szDevSec,IDS_OLDPAPERSOURCE,IDS_NEWPAPERSOURCE);
            ConvertStraight(szDevSec,IDS_OLDORIENTATION,IDS_NEWORIENTATION);
            ConvertStraight(szDevSec,IDS_OLDTRUETYPE,IDS_NEWTRUETYPE);
            ConvertStraight(szDevSec,IDS_OLDSEPARATION,IDS_NEWSEPARATION);

            // Convert the simple translations
            ConvertBool(szDevSec,IDS_OLDPAGEPROTECT,IDS_NEWPAGEPROTECT,1);
            ConvertBool(szDevSec,IDS_OLDOUTPUT,IDS_NEWOUTPUT,259);

            // Do the stuff that requires more complicated conversion
            ConvertResolution(szDevSec,lpDevName);
            if(!Convert5eHalfTone(szDevSec))
                Convert5aHalfTone(szDevSec);

	        if(!Convert5eMemory(szDevSec))
		    {
		        if(!Convert5MSMemory(szDevSec))
		            Convert5aMemory(szDevSec);
		    }
	        ConvertVectorMode(szDevSec);

            // Handle soft fonts & cartridges
            HandleFonts(szDevSec,lpDevName,lpNewPort);
        }

        // Flush the cached settings from win.ini
        WriteProfileString(NULL,NULL,NULL);
    }
    else
    {
        int  nCount;

        // move device settings from the old port to the new port, or
        // de-install a device, i.e. remove its device setttings in order
        // to compress the profile.

        // First, check if there is any  soft font installed under the
        // old port. If so, warn the user to copy them over.
        lstrcpy(szDevSec,rgchModuleName);
        MakeAppName((LPSTR)szDevSec,lpOldPort,sizeof(szDevSec));

        if(GetInt(szDevSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE)
            && nCount && lpNewPort)
        {
            NPSTR npTemp;

            if(npTemp=(NPSTR)LocalAlloc(LPTR,TMPSIZE))
            {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,npTemp,TMPSIZE))
                {
                    // Use this API so that the M Box is set to the Foreground
                    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
                    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = npTemp;
		    mbp.lpszCaption = lpOldPort;
                    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
                    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
                LocalFree((HLOCAL)npTemp);
            }
        }
    }

    return UniDevInstall(hWnd,lpDevName,lpOldPort,lpNewPort);
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(HWND  hWnd,
                               LPSTR lpDeviceName,
                               LPSTR lpPortName,
                               BOOL  bSoftFonts)
{
  int          fsVers;
  HANDLE       hFIlib;
  SOFTFONTPROC lpFIns;

  if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    !(lpFIns = (SOFTFONTPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
  {
    if (hFIlib >= 32)
      FreeLibrary(hFIlib);
#ifdef DEBUG
    MessageBox(0,
      "Can't load FINSTAL.DLL or can't get InstallSoftFont",
      NULL, MB_OK);
#endif
    return TRUE;
  }

  // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
  // We choose to ignore the returned "fvers". No use of it.
  fsVers = (*lpFIns)(hWnd,rgchModuleName,lpPortName,
                    (GetKeyState(VK_SHIFT)<0 && GetKeyState(VK_CONTROL)<0),
                    1,	  // dummy value for "fvers".
                    bSoftFonts?CLASS_LASERJET:256);
  FreeLibrary(hFIlib);
  return fsVers;
}



// -------------------------------------------------------------------
//
// Special case control functions wrt SETCHARSET escape. This is necessary
// to avoid breaking Winword and Pagemaker. (note that we don't actually
// do anything with SETCHARSET, but apps break unless we say that we do)
//
// --------------------------------------------------------------------
int FAR PASCAL Control(LPDV  lpdv,
                       short function,
                       LPSTR lpInData,
                       LPSTR lpOutData)
{
    // Tell app that SETCHARSET is supported
    if(QUERYESCSUPPORT == function && *((LPWORD)lpInData) == SETCHARSET)
        return 1;

    // Special case SETCHARSET
    if(SETCHARSET == function)
        return 1;

    // General case
    return UniControl(lpdv, function, lpInData, lpOutData);
}



#ifndef NOFONTMAP

//----------------------------------------------------------------------
// Function: MapFaceName(lplfOld,lplfNew)
//
// Action: Map old face names to their new counterparts. Do as little
//         work as we possibly can, since this function gets called
//         often & we don't want to impact performance. Optimize
//         the whole search to the case where we don't find a match,
//         as this will be the most common scenario.
//
// Return: A pointer to the LOGFONT to actually hand to Unidrv. Cast
//         the return to a LPSTR, just so the compiler is happy.
//----------------------------------------------------------------------
LPSTR NEAR PASCAL MapFaceName(LPLOGFONT lplfOld,
                              LPLOGFONT lplfNew)
{
    LPLOGFONT   lpReturn=lplfOld;   // By default
    NPFACEINDEX pIndex;
    LPSTR       lpFace=lplfOld->lfFaceName;
    BYTE        cTest=*lpFace++;

    // Determine range of possible matches in the table. Since the
    // table is sorted alphabetically, we may be able to bail out
    // before we reach the end of the table.
    for(pIndex=FaceIndex;cTest > pIndex->cFirstChar;pIndex++)
        ;

    // Only proceed if the first character matches and this isn't the
    // firewall (cTest = \xFF).
    if(cTest==pIndex->cFirstChar && ('\xFF' != cTest))
    {
        WORD  wStartIndex=(WORD)(pIndex->bIndex);
        WORD  wStopIndex=(WORD)((pIndex+1)->bIndex);
        WORD  wLoop=wStartIndex;
        NPSTR npMapFace=&(FaceMap[wStartIndex].szOldFace[1]);
        BYTE  cMapFace;

        // Check the rest of the string against the table entries.
        // This search routine takes advantage of the fact that
        // the old face names in the table are fully sorted alphabetically.
        // This search routine takes advantage of the fact that our table
        // is fully sorted, and doesn't do a full string comparison until
        // we actually think we have a match. Once we think there's a match,
        // we'll double-check the entire string to prevent false triggering.

        while(wLoop < wStopIndex)
        {
            // Look for a match. At this point, match a wildcard to
            // anything--we'll do a more stringent check later on, if we
            // think we have a match. Stop if cTest is NULL.
            while((((cTest=*lpFace)==(cMapFace=*npMapFace)) ||
                ('\x01'==cMapFace)) && cTest)
            {
                npMapFace++;
                lpFace++;
            }

            // We arrive here via two conditions: (1) we've reached the
            // end of lpFace and cTest is NULL, or (2) cMapFace and cTest
            // failed to compare. We should only continue searching if
            // cMapFace is non-NULL and cTest is larger than cMapFace (take
            // advantage of the fact that FaceMap is sorted alphabetically).
            // For overall performance, check for the no match case first.

            // Move to the next table entry as long as there's still a
            // chance to find a match.
            if(cTest > cMapFace)
            {
                npMapFace+=sizeof(FACEMAP);
                wLoop++;
                continue;     // Go to the next iteration
            }

            // if cTest is non-NULL, then the sorting of the table guarantees
            // that there are no matches. Bail out now.
            if(cTest)
                goto MFN_exit;

            // cTest is NULL, so we will not make another iteration. The
            // only thing left to decide is whether or not we have a match
            // with the current string.
            if(cMapFace)
                goto MFN_exit;

            // The guards above ensure that we only arrive here if both
            // cTest and cMapFace are NULL, which means that if we're
            // going to find a match, this string is it. We took shortcuts
            // in the comparisons above, so do a stringent comparison now
            // to be sure that this is really a match. The only characters
            // to match wildcards are '1' and 'N', since these are the only
            // ones used in previous versions of the driver.

            for(lpFace=lplfOld->lfFaceName,npMapFace=FaceMap[wLoop].szOldFace;
                (cMapFace=*npMapFace) && (cTest=*lpFace);
                npMapFace++,lpFace++)
            {
                if(!((cTest==cMapFace) ||
                    (('\x01'==cMapFace)&&(('1'==cTest)||('N'==cTest)))))
                {
                    // False trigger--bail out without changing facename
                    goto MFN_exit;
                }
            }

            // We now know that this really is a match--keep the requested
            // attributes & change just the face name.

            *lplfNew=*lplfOld;
            lstrcpy(lplfNew->lfFaceName,FaceMap[wLoop].szNewFace);
            lpReturn=lplfNew;
            goto MFN_exit;
        }
    }

MFN_exit:

    return (LPSTR)lpReturn;
}


#endif

//----------------------------------------------------------------------
// Function: RealizeObject(lpdv,sStyle,lpInObj,lpOutObj,lpTextXForm)
//
// Action: Hook this out to enable font substitution. If the object isn't
//         a font, do absolutely nothing.
//
// Return: Save as UniRealizeObject().
//----------------------------------------------------------------------
DWORD FAR PASCAL RealizeObject(LPDV        lpdv,
                               short       sStyle,
                               LPSTR       lpInObj,
                               LPSTR       lpOutObj,
                               LPTEXTXFORM lpTextXForm)
{
#ifndef NOFONTMAP

    LOGFONT   lfNew;

    if(OBJ_FONT==sStyle)
        lpInObj=MapFaceName((LPLOGFONT)lpInObj,&lfNew);

#endif

    return UniRealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm);
}
#endif //!WINNT

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\pcl5zres\etc\pcl5sc.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// It also contains Install() for upgrading 3.0 driver to 3.1.
//
//-----------------------------------------------------------------------------


#include "strings.h"

char *rgchModuleName = "PCL5SC";
char szNone[]="";

// The following are defined to ensure that we upgrade correctly from the
// HPPCL5a, HPPCL5e and Win 3.11 HPPCL5MS drivers

#define MAX_LJ4_MBMEMSETTING    68    // from HP tech specification
#define KB_THRESHOLD            200   // kb range check,needed for conversion


#define PRINTDRIVER
#include <print.h>
#include "gdidefs.inc"
#include "mdevice.h"
#include "unidrv.h"
#include "minidriv.h"

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#ifndef WINNT
short NEAR PASCAL MakeAppName(LPSTR,LPCSTR,short);

// typedef for atom stuff--what a nuisance!
typedef struct tagSFNODE
{
    WORD wIndex;
    ATOM atom;
} SFNODE, FAR *LPSFNODE;

// Typedef for Font Installer procedure
typedef int (FAR * PASCAL SOFTFONTPROC)(HWND,LPSTR,LPSTR,BOOL,int,int);

HINSTANCE hInst;

#define DEFAULT_INT      32767

#define SOFT_FONT_THRES  25  // build font summary, if over this limit

#define MAX_CART_INDEX	 12

#define TMPSIZE         256

// Define these so they happily use the same values as the HPPCL5E driver.
#define GS_PHOTO     0
#define GS_LINEART   1
#define GS_SCANJET   2


// map old HPPCL5a's cartindex to unidrv's FONTCART index for newer cartridges.
// This mapping table is created based on the old HPPCL5a .rc file.
// Note that we do not have "International Collection" cartridge and we
// map it to index 0 (arbitrarily).
int rgNewCartMap[12] = {0, 8, 7, 2, 3, 0, 5, 6, 1, 4, 9, 10};

// String to determine if we have a member of the LaserJet 4 family
char szLJ4[]="HP LaserJet 4";

// Stuff needed for mapping old facenames to new versions
#ifndef NOFONTMAP

typedef struct tagFACEMAP
{
    char szOldFace[LF_FACESIZE];
    char szNewFace[LF_FACESIZE];
} FACEMAP, NEAR * NPFACEMAP;

typedef struct tagFACEINDEX
{
    BYTE cFirstChar;
    BYTE bIndex;
} FACEINDEX, NEAR * NPFACEINDEX;

FACEMAP FaceMap[]={{"Albertus (W\x01)",         "Albertus Medium"},
                   {"Albertus Xb (W\x01)",      "Albertus Extra Bold"},
                   {"Antique Olv (W\x01)",      "Antique Olive"},
                   {"Antique Olv Cmpct (W\x01)","Antique Olive Compact"},
                   {"CG Bodoni (W\x01)",        "CG Bodoni"},
                   {"CG Cent Schl (W\x01)",     "CG Century Schoolbook"},
                   {"CG Omega (W\x01)",         "CG Omega"},
                   {"CG Palacio (W\x01)",       "CG Palacio"},
                   {"CG Times (W\x01)",         "CG Times"},
                   {"Clarendon Cd (W\x01)",     "Clarendon Condensed"},
                   {"Cooper Blk (W\x01)",       "Cooper Black"},
                   {"Coronet (W\x01)",          "Coronet"},
                   {"Courier (W\x01)",          "Courier"},
                   {"Garmond (W\x01)",          "Garamond"},
                   {"ITC Benguat (W\x01)",      "ITC Benguiat"},
                   {"ITC Bookman Db (W\x01)",   "ITC Bookman Demi"},
                   {"ITC Bookman Lt (W\x01)",   "ITC Bookman Light"},
                   {"ITC Souvenir Db (W\x01)",  "ITC Souvenir Demi"},
                   {"ITC Souvenir Lt (W\x01)",  "ITC Souvenir Light"},
                   {"Letter Gothic (W\x01)",    "Letter Gothic"},
                   {"Marigold (W\x01)",         "Marigold"},
                   {"Revue Lt (W\x01)",         "Revue Light"},
                   {"Shannon (W\x01)",          "Shannon"},
                   {"Shannon Xb (W\x01)",       "Shannon Extra Bold"},
                   {"Stymie (W\x01)",           "Stymie"},
                   {"Univers (W\x01)",          "Univers"},
                   {"Univers Cd (W\x01)",       "Univers Condensed"}};


FACEINDEX FaceIndex[]={{'A',0},
                       {'C',4},
                       {'G',13},
                       {'I',14},
                       {'L',19},
                       {'M',20},
                       {'R',21},
                       {'S',22},
                       {'U',25},
                       {(BYTE)'\xFF',27}};  // Provide an upper limit
                                            // to the search for 'U'.

#endif


//------------------------------------------------------------------------
// Function: LibMain(hInstance,wDataSeg,cbHeapSize,lpszCmdLine)
//
// Action: Save the hInstance for this DLL
//
// Return: 1
//------------------------------------------------------------------------
int WINAPI LibMain (HANDLE hInstance,
                    WORD   wDataSeg,
                    WORD   cbHeapSize,
                    LPSTR  lpszCmdLine)
{
    hInst=hInstance;

    return 1;
}


//--------------------------*MakeAppName*---------------------------------------
// Action:  compose the <printer,port> name for reading the profile data
//	Return the length of the actual application name. Return -1 if fails.
//
//------------------------------------------------------------------------------
short NEAR PASCAL MakeAppName(LPSTR  lpAppName,
                              LPCSTR lpPortName,
                              short  max)
{
    short   length, count;
    LPCSTR  lpTmp;
    LPCSTR  lpLastColon = NULL;

    length = lstrlen(lpAppName);

    if (!lpPortName)
        return length;

    if (length == 0 || length > max - lstrlen(lpPortName))
        return -1;

    // insert the comma
    lpAppName[length++] = ',';

    // append the port name but do not want the last ':', if any.
    for (lpTmp = lpPortName ; *lpTmp; lpTmp++)
        if (*lpTmp == ':')
            lpLastColon = lpTmp;
        if (lpLastColon && lpLastColon == lpTmp - 1)
            count = lpLastColon - lpPortName;
        else
            count = lpTmp - lpPortName;

    lstrcpy((LPSTR)&lpAppName[length], lpPortName);

    length += count;
    lpAppName[length]='\0';

    return length;
}

#define KEY_BUF_SIZE  256


//---------------------------------------------------------------------------
// Function: GetInt(lpSection,lpKey,lpnValue,nDefault,bRemove)
//
// Action: Load the appropriate string from the resources, then get the
//         specified integer from the section. Remove the old entry if
//         it exists and it bRemove is TRUE.
//
// Return: TRUE if we actually found a value, FALSE if not.
//---------------------------------------------------------------------------
BOOL NEAR PASCAL GetInt(LPSTR  lpSection,
                        LPCSTR lpKey,
                        LPINT  lpnValue,
                        int    nDefault,
                        BOOL   bRemove)
{
    char szKeyName[60];
    int  nTest;

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    nTest=GetProfileInt(lpSection,szKeyName,DEFAULT_INT);

    if(DEFAULT_INT != nTest)
    {
        *lpnValue=nTest;

        if(bRemove)
            WriteProfileString(lpSection,szKeyName,NULL);

        return TRUE;
    }

    // Section doesn't exist--use default
    *lpnValue=nDefault;
    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteInt(lpSection,lpKey,nValue)
//
// Action: Write an integer value to the specified section of win.ini.
//
// Return: TRUE if successful, FALSE if not.
//-------------------------------------------------------------------------
BOOL NEAR PASCAL WriteInt(LPSTR  lpSection,
                          LPCSTR lpKey,
                          int    nValue)
{
    char szKeyName[60];
    char szValue[10];

    if(!HIWORD(lpKey))
    {
        if(LoadString(hInst,LOWORD(lpKey),szKeyName,sizeof(szKeyName)))
            lpKey=szKeyName;
        else
            return FALSE;
    }

    wsprintf(szValue,"%u",nValue);

    return WriteProfileString(lpSection,szKeyName,szValue);
}


//---------------------------*MergeFontLists*-----------------------------
// Action: Merge the old and new soft fonts. In most cases when we get
//         called, we really don't do much of anything, because the
//         font lists are identical. However, we have to do some fun
//         stuff to merge the lists if they're different.
//         We know how many soft font entries exist in each section,
//         via the "SoftFonts" int, but the entries may be non-consecutive.
//
// Note:   This stomps all over the passed in buffer
//
// Return: TRUE if successfully conpleted, FALSE if not
//------------------------------------------------------------------------
BOOL NEAR PASCAL MergeFontLists(LPSTR lpOldSec,
                                LPSTR lpNewSec,
                                LPSTR lpTmp)
{
    WORD     wOldFonts;
    WORD     wNewFonts;
    LPSFNODE lpFonts;
    WORD     wMergedFonts=0;
    WORD     wLoop;
    WORD     wFound;
    WORD     wNewIndex;
    BYTE     szKey[20];

    // Get these values outside of the if statement, otherwise the compiler
    // may optimize out the assignment of wNewFonts
    GetInt(lpOldSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wOldFonts,0,FALSE);
    GetInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&wNewFonts,0,FALSE);

    if(wOldFonts || wNewFonts)
    {
        char szFormat[30];

        // Get a block big enough for the worst case--no common fonts
        if(!(lpFonts=(LPSFNODE)GlobalAllocPtr(GHND,
            (DWORD)(wOldFonts+wNewFonts)*sizeof(SFNODE))))
        {
            return FALSE;
        }

        // We need a formatting string
        LoadString(hInst,IDS_SOFTFONTFORMAT,szFormat,sizeof(szFormat));

        // Put fonts from lpNew Sec first in the list. This way, if we have
        // already updated at least one driver from 5A to 5MS and the soft
        // fonts haven't changed, our old font summary file is still valid.
        // Unidrv will automatically recreate the font summary file if it
        // sees that the number of soft fonts has changed. Even though we
        // know how many soft font entries exist, we don't know that they
        // will be sequential. (They may not be if one was added, then
        // deleted). Keep track of the original offset. Even though the
        // font installer seems to be 1-based, start looking at 0, just
        // to be safe.
        for(wLoop=0,wFound=0;wFound<wNewFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpNewSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                lpFonts[wMergedFonts].wIndex=wLoop;
                lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                wFound++;
            }
        }
    
        // Remember where we left off in numbering the entries
        wNewIndex=wLoop;

        // Read fonts from lpOldSec--create atoms for new entries
        for(wLoop=0,wFound=0;wFound<wOldFonts;wLoop++)
        {
            wsprintf(lpTmp,szFormat,wLoop);
            if(GetProfileString(lpOldSec,lpTmp,szNone,lpTmp,TMPSIZE))
            {
                wFound++;
                if(!GlobalFindAtom(lpTmp))
                {
                    lpFonts[wMergedFonts].wIndex=wLoop;
                    lpFonts[wMergedFonts++].atom=GlobalAddAtom(lpTmp);
                }
            }
        }

        // Write out the list of atoms--do the entries from lpNewSec first
        WriteInt(lpNewSec,MAKEINTRESOURCE(IDS_SOFTFONTS),wMergedFonts);
        for(wLoop=0;wLoop<wNewFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,lpFonts[wLoop].wIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
        }

        // Now write out the entries that were in lpOldSec but not in lpNewSec.
        // Since the actual numbering of these entries is arbitrary, just
        // start numbering them at wNewIndex and increment each time.
        for(wLoop=wNewFonts;wLoop<wMergedFonts;wLoop++)
        {
            GlobalGetAtomName(lpFonts[wLoop].atom,lpTmp,TMPSIZE);
            wsprintf(szKey,szFormat,wNewIndex);
            WriteProfileString(lpNewSec,szKey,lpTmp);
            GlobalDeleteAtom(lpFonts[wLoop].atom);
            wNewIndex++;
        }

        GlobalFreePtr(lpFonts);
    }

    return TRUE;
}


//----------------------*AddMissingEntries*-----------------------------
// Action: Copy any entries that appear in lpOldSec but not lpNewSec to
//         lpNewSec, but don't copy any entries relevant to soft fonts
//         (These entries will be copied in MergeFontSections).
//
// Return: TRUE if successful, FALSE if not
//----------------------------------------------------------------------
BOOL NEAR PASCAL AddMissingEntries(LPSTR lpOldSec,
                                   LPSTR lpNewSec,
                                   LPSTR lpTmp)
{
    WORD  wSize;
    LPSTR lpBuf;
    LPSTR lpWork;
    char  szTest2[30];
    char  szTest1[30];
    int   nLength;

    // Get the key names into buffers
    wSize=KEY_BUF_SIZE;

    if(!(lpBuf=GlobalAllocPtr(GHND,(DWORD)wSize)))
        return FALSE;
    while((WORD)GetProfileString(lpOldSec,NULL,szNone,lpBuf,wSize)==wSize-2)
    {
        wSize*=2;
        if(lpWork=GlobalReAllocPtr(lpBuf,(DWORD)wSize,GHND))
            lpBuf=lpWork;
        else
        {
            GlobalFreePtr(lpBuf);
            return FALSE;
        }
    }

    // Load some strings
    LoadString(hInst,IDS_FONTSUMMARY,szTest1,sizeof(szTest1));
    nLength=LoadString(hInst,IDS_SOFTFONTTEST,szTest2,sizeof(szTest2));

    // Now examine each entry, copy it if we want to keep it, and return TRUE
    // There are two cases where we don't want to copy the file--the key
    // named FontSummary and all keys that begin with "SoftFont"
    lpWork=lpBuf;
    while(wSize=(WORD)lstrlen(lpWork))
    {
        // Font Summary?
        if(lstrcmpi(lpWork,szTest1))
        {
            // Soft Font Entry?
            lstrcpy(lpTmp,lpWork);
            lpTmp[nLength]='\0';
            if(lstrcmpi(lpTmp,szTest2))
            {
                // Add this entry if it doesn't already exist in the new section
                if(!GetProfileString(lpNewSec,lpWork,szNone,lpTmp,TMPSIZE))
                {
                    GetProfileString(lpOldSec,lpWork,szNone,lpTmp,TMPSIZE);
                    WriteProfileString(lpNewSec,lpWork,lpTmp);
                }
            }
        }
        lpWork+=(wSize+1);
    }

    GlobalFreePtr(lpBuf);
    return TRUE;
}


//---------------------------*HandleSoftFonts*---------------------------
// Action: Transfer the soft fonts between old and new entries. First we
//         copy any entries that don't already exist in the new section,
//         with the exception of soft font information. Then we go ahead
//         and merge the soft fonts, so the end result in the new section
//         is the union of the old and new soft fonts.
//
// Return: TRUE if success, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL HandleSoftFonts(LPSTR lpszOldSec,
                                 LPSTR lpszNewSec)
{
    char szTmp[TMPSIZE];

    if(AddMissingEntries(lpszOldSec,lpszNewSec,szTmp))
        return MergeFontLists(lpszOldSec,lpszNewSec,szTmp);

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertStraight(lpSection,nOldID,nNewID)
//
// Action: Convert a section setting without translation
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertStraight(LPSTR lpSection,
                                 int   nOldID,
                                 int   nNewID)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nValue);
        return TRUE;
    }

    return FALSE;
}


//------------------------------------------------------------------------
// Function: ConvertBool(lpSection,nOldID,nNewID,nNewValue)
//
// Action: Convert a section with minimal translation. If the old section
//         existed and was non-zero, write nNewValue to the new section.
//         If the old section existed and was 0, write 0 to the new section.
//
// Return: TRUE if the old setting existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertBool(LPSTR lpSection,
                             int   nOldID,
                             int   nNewID,
                             int   nNewValue)
{
    int nOldValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(nOldID),&nOldValue,0,TRUE))
    {
        WriteInt(lpSection,MAKEINTRESOURCE(nNewID),nOldValue?nNewValue:0);
        return TRUE;
    }

    return FALSE;
}

//------------------------------------------------------------------------
// Function: ConvertVectorMode(lpSection)
//
// Action: Convert the graphics mode setting
//         Cannot do straight conversion as defaults dont match
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertVectorMode(LPSTR lpSection)
{
    int nValue;

    GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDVECTORMODE),&nValue,1,TRUE);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWVECTORMODE),nValue);
    return TRUE;

}



//------------------------------------------------------------------------
// Function: ConvertResolution(lpSection,lpModel)
//
// Action: Convert the old resolution section to the new one
//
// Return: TRUE if the old section existed
//------------------------------------------------------------------------
BOOL NEAR PASCAL ConvertResolution(LPSTR lpSection,
                                   LPSTR lpModel)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5A_RESOLUTION),&nValue,0,TRUE))
    {
        LPSTR lpLJ4=szLJ4;
        LPSTR lpCheck=lpModel;
        BOOL  bLJ4=TRUE;

        nValue=300/(1<<nValue);

        // Compare the passed-in model to szLJ4. If lpModel begins with the
        // substring "HP LaserJet 4", then lpLJ4 will point to NULL when we
        // exit the loop.
        while(*lpLJ4 == *lpCheck)
        {
            lpLJ4++;
            lpCheck++;
        }

        if(!*lpLJ4)
        {
            // This is in the LJ4 family--check if it's a 4L or 4ML
            if(lstrcmp(lpCheck,"L") && lstrcmp(lpCheck,"ML"))
            {
                int nTest;

                // Device is capable of 600 dpi--check the value for
                // "printerres".

                GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_RESOLUTION),
                    &nTest,600,TRUE);

                if(600==nTest)
                    nValue<<=1;
            }
        }

        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWRESOLUTION),nValue);
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWYRESOLUTION),nValue);

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WriteHalfTone(lpSection,nIndex)
//
// Action: Write the halftoning data to win.ini
//
// Return: VOID
//-------------------------------------------------------------------------
VOID NEAR PASCAL WriteHalfTone(LPSTR lpSection,
                               int   nIndex)
{
    int nBrush;
    int nIntensity;

    switch(nIndex)
    {
        case GS_LINEART:
            nBrush=RES_DB_LINEART;
            nIntensity=100;
            break;

        case GS_SCANJET:
            nBrush=RES_DB_COARSE;
            nIntensity=150;
            break;

        case GS_PHOTO:
        default:
            nBrush=RES_DB_COARSE;
            nIntensity=100;
            break;
    }

    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWBRUSH),nBrush);
    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWINTENSITY),nIntensity);
}


//-------------------------------------------------------------------------
// Function: Convert5aHalfTone(lpSection)
//
// Action: Convert the 5A halftoning settings
//
// Return: TRUE if the old section existed, FALSE if not
//-------------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aHalfTone(LPSTR lpSection)
{
    int nIndex;
    int  nGray;
    int  nBright;
    BOOL bGrayScale;
    BOOL bBrightness;

    // See if either setting exists...
    bGrayScale=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDGRAYSCALE),&nGray,
        1,TRUE);
    bBrightness=GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDBRIGHTNESS),&nBright,
        0,TRUE);

    if(bGrayScale || bBrightness)
    {
        if(1==nBright)
            nIndex=GS_SCANJET;
        else if(0==nGray)
            nIndex=GS_LINEART;
        else
            nIndex=GS_PHOTO;

        WriteHalfTone(lpSection,nIndex);
        return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5eHalfTone(LPSTR lpSection)
//
// Action: Convert the 5E halftoning settings
//
// Return: TRUE if successful, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eHalfTone(LPSTR lpSection)
{
    int nValue;

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLD_5E_HALFTONE),&nValue,
        0,TRUE))
    {
        WriteHalfTone(lpSection,nValue);
        return TRUE;
    }
    return FALSE;
}


//-----------------------------------------------------------------------
// Function: Convert5aMemory(lpSection)
//
// Action: Convert the memory settings from the old to the new values
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5aMemory(LPSTR lpSection)
{
    int nValue;
    int nPrinterMB;

    // Get memory settings--extract from prtindex.
    // Values range from 0 to 28, where 0-4 are the LaserJet III,
    // 5-9 are the LaserJet IIID, 10-14 are the LaserJet IIIP, and
    // 15-28 are the LaserJet IIISi. For indices less than 20, the
    // total MB is the index mod 5, + 1. For indices 20 and above, the
    // total MB is the index - 14, except for 26, 27, and 28, which
    // require special handling because of the increments that memory
    // can be added to the IIISi.
    // The formula used to calculate the settings is derived directly
    // from the values used in the hppcl5a driver. Specifically,
    // AM = 945 * TM - 245, where TM is the total memory in MB, and
    // AM is the available printer memory.

    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_OLDMEMORY),&nValue,1,TRUE))
    {
        if(nValue<20)
            nPrinterMB=nValue%5 + 1;
        else
        {
            nPrinterMB=nValue-14;
            if(nValue>25)
            {
                nPrinterMB++;        // 25=11MB, 26=13MB, so add an extra MB.
                if(nValue==28)
                    nPrinterMB+=2;   // 27=14MB, 28=17MB, so add 2 extra MB.
            }
        }

        nValue=945*nPrinterMB-245;
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5eMemory(lpSection)
//
// Action: Convert the HPPCL5E memory settings from the old to the new values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5eMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,FALSE))
    {
	if (nValue <= KB_THRESHOLD )
	    {
	    if (nValue > MAX_LJ4_MBMEMSETTING)
		nValue = MAX_LJ4_MBMEMSETTING;  // force it to max value
	    nValue=900*nValue - 450;  // convert to KB, using HP formula
	    WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	    return TRUE;
	    }
    }

    return FALSE;
}

//-----------------------------------------------------------------------
// Function: Convert5MSMemory(lpSection)
//
// Action: Convert the WFW HPPCL5MS memory settings from the old to the new
//         values
//
// Conversion code has to check the win.ini mem setting so that we upgrade
// mem setting correctly
//
// Added for backward compatability
//
// Return: TRUE if the old section existed, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL Convert5MSMemory(LPSTR lpSection)
{
    unsigned nValue;


    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),&nValue,1,TRUE))
	{
	nValue = nValue / 900;  // convert to MB value
	nValue = 945*nValue - 245; // formula used in hppcl5a driver
	// used to convert to available mem
	WriteInt(lpSection,MAKEINTRESOURCE(IDS_NEWMEMORY),nValue);
	return TRUE;
	}
    return FALSE;
}



//------------------------------------------------------------------------
// Function: HandleFontCartridges(lpSection,lpOldDrvSec,lpNewDrvSec)
//
// Action: Handle font cartridge data
//
// Return: VOID
//------------------------------------------------------------------------
VOID NEAR PASCAL HandleFontCartridges(LPSTR lpSection,
                                      LPSTR lpOldDrvSec,
                                      LPSTR lpNewDrvSec)
{
    int nCount;

    // Get the count of cartridges--if there are no cartridges, do nothing.
    if(GetInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),&nCount,0,TRUE))
    {
        char  szOldCartKey[16];
        char  szNewCartKey[16];
        short nCart = 0;
        short i;
        short index;
        int   nLength1;
        int   nLength2;

        nLength1=LoadString(hInst,IDS_CARTINDEX,szOldCartKey,
            sizeof(szOldCartKey));
        nLength2=LoadString(hInst,IDS_CARTRIDGE,szNewCartKey,
            sizeof(szNewCartKey));

        for (i = 0; i < nCount; i++)
        {
            if (i > 0)
                wsprintf(szOldCartKey+nLength1,"%d",i);

            // compose cartridge keyname for current driver
            wsprintf(szNewCartKey+nLength2,"%d",i+1);

            if ((index = GetProfileInt(lpNewDrvSec, szOldCartKey, 0)) > 0)
            {
                WriteProfileString(lpNewDrvSec, szOldCartKey, NULL);
                nCart++;
                if (index <= MAX_CART_INDEX)
                    WriteInt(lpSection,szNewCartKey,rgNewCartMap[index-1]);
                else
                    // external cartridges. Simply copy the id over.
                    WriteInt(lpSection,szNewCartKey,index);
            }
        }

        // Save the # of cartridges
        WriteInt(lpSection,MAKEINTRESOURCE(IDS_CARTRIDGECOUNT),nCart);
    }
}


//--------------------------------------------------------------------------
// Function: HandleFonts(lpSection,lpDevName,lpPort)
//
// Action: Deal with soft fonts & font cartridges
//
// Return: VOID
//--------------------------------------------------------------------------
VOID NEAR PASCAL HandleFonts(LPSTR lpSection,
                             LPSTR lpDevName,
                             LPSTR lpPort)
{
    char szOldDrvSec[64];   // HPPCL5A,<port> or HPPCL5E,<port>
    char szNewDrvSec[64];   // HPPCL5MS,<port>
    int  nCount;
    BOOL bOldExists=FALSE;  // Does old section exist?

    LoadString(hInst,IDS_OLD_5E_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
    MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

    // See if the old section exists at all. Temporarily borrow szNewDrvSec.

    if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
        sizeof(szNewDrvSec)))
    {
        bOldExists=TRUE;
    }
    else
    {
        // Try the HPPCL5E driver...

	LoadString(hInst,IDS_OLD_5A_DRIVERNAME,szOldDrvSec,sizeof(szOldDrvSec));
        MakeAppName((LPSTR)szOldDrvSec,lpPort,sizeof(szOldDrvSec));

        if(GetProfileString(szOldDrvSec,NULL,szNone,szNewDrvSec,
            sizeof(szNewDrvSec)))
        {
            bOldExists=TRUE;
        }
    }


    lstrcpy(szNewDrvSec,rgchModuleName);
    MakeAppName((LPSTR)szNewDrvSec,lpPort,sizeof(szNewDrvSec));

    if(bOldExists)
    {
        HandleSoftFonts(szOldDrvSec,szNewDrvSec);
        HandleFontCartridges(lpSection,szOldDrvSec,szNewDrvSec);
    }

    // create UNIDRV's font summary file, if there are many soft fonts.
    GetInt(szNewDrvSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE);
    if(nCount>SOFT_FONT_THRES)
    {
        HDC hIC;

        if(hIC=CreateIC(rgchModuleName,lpDevName,lpPort,NULL))
            DeleteDC(hIC);
    }
}


//-------------------------*DevInstall*---------------------------------------
// Action: De-install, upgrade or install a device.
//
//----------------------------------------------------------------------------
int FAR PASCAL DevInstall(HWND  hWnd,
                          LPSTR lpDevName,
                          LPSTR lpOldPort,
                          LPSTR lpNewPort)
{
    char szDevSec[64];       // [<device>,<port>] section name

    if (!lpDevName)
        return -1;

    if (!lpOldPort)
    {
        char szBuf[10];

        if (!lpNewPort)
            return 0;

        // install a device for the first time. Convert old HPPCL5a settings,
        // which are still under [<device>,<port>], into equivalent new
        // UNIDRV settings under [<device>,<port>], if applicable.
        // Delete old settings that are linked to the device name, but don't
        // delete old settings that are liked to the driver and port (softfonts)

        lstrcpy(szDevSec,lpDevName);
        MakeAppName((LPSTR)szDevSec,lpNewPort,sizeof(szDevSec));

        // check if old settings exist at all
        if(GetProfileString(szDevSec,NULL,NULL,szBuf,sizeof(szBuf)))
        {
            // Do the straight conversions
            ConvertStraight(szDevSec,IDS_OLDPAPERSIZE,IDS_NEWPAPERSIZE);
            ConvertStraight(szDevSec,IDS_OLDPAPERSOURCE,IDS_NEWPAPERSOURCE);
            ConvertStraight(szDevSec,IDS_OLDORIENTATION,IDS_NEWORIENTATION);
            ConvertStraight(szDevSec,IDS_OLDTRUETYPE,IDS_NEWTRUETYPE);
            ConvertStraight(szDevSec,IDS_OLDSEPARATION,IDS_NEWSEPARATION);

            // Convert the simple translations
            ConvertBool(szDevSec,IDS_OLDPAGEPROTECT,IDS_NEWPAGEPROTECT,1);
            ConvertBool(szDevSec,IDS_OLDOUTPUT,IDS_NEWOUTPUT,259);

            // Do the stuff that requires more complicated conversion
            ConvertResolution(szDevSec,lpDevName);
            if(!Convert5eHalfTone(szDevSec))
                Convert5aHalfTone(szDevSec);

	        if(!Convert5eMemory(szDevSec))
		    {
		        if(!Convert5MSMemory(szDevSec))
		            Convert5aMemory(szDevSec);
		    }
	        ConvertVectorMode(szDevSec);

            // Handle soft fonts & cartridges
            HandleFonts(szDevSec,lpDevName,lpNewPort);
        }

        // Flush the cached settings from win.ini
        WriteProfileString(NULL,NULL,NULL);
    }
    else
    {
        int  nCount;

        // move device settings from the old port to the new port, or
        // de-install a device, i.e. remove its device setttings in order
        // to compress the profile.

        // First, check if there is any  soft font installed under the
        // old port. If so, warn the user to copy them over.
        lstrcpy(szDevSec,rgchModuleName);
        MakeAppName((LPSTR)szDevSec,lpOldPort,sizeof(szDevSec));

        if(GetInt(szDevSec,MAKEINTRESOURCE(IDS_SOFTFONTS),&nCount,0,FALSE)
            && nCount && lpNewPort)
        {
            NPSTR npTemp;

            if(npTemp=(NPSTR)LocalAlloc(LPTR,TMPSIZE))
            {
                if(LoadString(hInst,IDS_SOFTFONTWARNING,npTemp,TMPSIZE))
                {
                    // Use this API so that the M Box is set to the Foreground
                    MSGBOXPARAMS     mbp;

		    mbp.cbSize = sizeof(mbp);
                    mbp.hwndOwner = hWnd;
		    mbp.hInstance = hInst;
		    mbp.lpszText = npTemp;
		    mbp.lpszCaption = lpOldPort;
                    mbp.dwStyle = MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION;
		    mbp.lpszIcon = NULL;
                    mbp.dwContextHelpId = 0L;
		    mbp.lpfnMsgBoxCallback = NULL;
		    MessageBoxIndirect(&mbp);
		}
                LocalFree((HLOCAL)npTemp);
            }
        }
    }

    return UniDevInstall(hWnd,lpDevName,lpOldPort,lpNewPort);
}


// the following 3 definitions MUST be compatible with the
// HPPCL font installer
#define CLASS_LASERJET	    0
#define CLASS_DESKJET	    1
#define CLASS_DESKJET_PLUS  2

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//	    and/or external cartridges.
//
// Parameters:
//	HWND	hWnd;		handle to the parent windows.
//	LPSTR	lpDeviceName;	long pointer to the printer name.
//	LPSTR	lpPortName;	long pointer to the associated port name.
//	BOOL	bSoftFonts;	flag if supporting soft fonts or not.
//
//  Return Value:
//	> 0   :  if the font information has changed;
//	== 0  :  if nothing has changed;
//	== -1 :  if intending to use the universal font installer
//		 (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(HWND  hWnd,
                               LPSTR lpDeviceName,
                               LPSTR lpPortName,
                               BOOL  bSoftFonts)
{
  int          fsVers;
  HANDLE       hFIlib;
  SOFTFONTPROC lpFIns;

  if ((hFIlib = LoadLibrary((LPSTR)"FINSTALL.DLL")) < 32 ||
    !(lpFIns = (SOFTFONTPROC)GetProcAddress(hFIlib,"InstallSoftFont")))
  {
    if (hFIlib >= 32)
      FreeLibrary(hFIlib);
#ifdef DEBUG
    MessageBox(0,
      "Can't load FINSTAL.DLL or can't get InstallSoftFont",
      NULL, MB_OK);
#endif
    return TRUE;
  }

  // FINSTALL.DLL was loaded properly. Now call InstallSoftFont().
  // We choose to ignore the returned "fvers". No use of it.
  fsVers = (*lpFIns)(hWnd,rgchModuleName,lpPortName,
                    (GetKeyState(VK_SHIFT)<0 && GetKeyState(VK_CONTROL)<0),
                    1,	  // dummy value for "fvers".
                    bSoftFonts?CLASS_LASERJET:256);
  FreeLibrary(hFIlib);
  return fsVers;
}



// -------------------------------------------------------------------
//
// Special case control functions wrt SETCHARSET escape. This is necessary
// to avoid breaking Winword and Pagemaker. (note that we don't actually
// do anything with SETCHARSET, but apps break unless we say that we do)
//
// --------------------------------------------------------------------
int FAR PASCAL Control(LPDV  lpdv,
                       short function,
                       LPSTR lpInData,
                       LPSTR lpOutData)
{
    // Tell app that SETCHARSET is supported
    if(QUERYESCSUPPORT == function && *((LPWORD)lpInData) == SETCHARSET)
        return 1;

    // Special case SETCHARSET
    if(SETCHARSET == function)
        return 1;

    // General case
    return UniControl(lpdv, function, lpInData, lpOutData);
}



#ifndef NOFONTMAP

//----------------------------------------------------------------------
// Function: MapFaceName(lplfOld,lplfNew)
//
// Action: Map old face names to their new counterparts. Do as little
//         work as we possibly can, since this function gets called
//         often & we don't want to impact performance. Optimize
//         the whole search to the case where we don't find a match,
//         as this will be the most common scenario.
//
// Return: A pointer to the LOGFONT to actually hand to Unidrv. Cast
//         the return to a LPSTR, just so the compiler is happy.
//----------------------------------------------------------------------
LPSTR NEAR PASCAL MapFaceName(LPLOGFONT lplfOld,
                              LPLOGFONT lplfNew)
{
    LPLOGFONT   lpReturn=lplfOld;   // By default
    NPFACEINDEX pIndex;
    LPSTR       lpFace=lplfOld->lfFaceName;
    BYTE        cTest=*lpFace++;

    // Determine range of possible matches in the table. Since the
    // table is sorted alphabetically, we may be able to bail out
    // before we reach the end of the table.
    for(pIndex=FaceIndex;cTest > pIndex->cFirstChar;pIndex++)
        ;

    // Only proceed if the first character matches and this isn't the
    // firewall (cTest = \xFF).
    if(cTest==pIndex->cFirstChar && ('\xFF' != cTest))
    {
        WORD  wStartIndex=(WORD)(pIndex->bIndex);
        WORD  wStopIndex=(WORD)((pIndex+1)->bIndex);
        WORD  wLoop=wStartIndex;
        NPSTR npMapFace=&(FaceMap[wStartIndex].szOldFace[1]);
        BYTE  cMapFace;

        // Check the rest of the string against the table entries.
        // This search routine takes advantage of the fact that
        // the old face names in the table are fully sorted alphabetically.
        // This search routine takes advantage of the fact that our table
        // is fully sorted, and doesn't do a full string comparison until
        // we actually think we have a match. Once we think there's a match,
        // we'll double-check the entire string to prevent false triggering.

        while(wLoop < wStopIndex)
        {
            // Look for a match. At this point, match a wildcard to
            // anything--we'll do a more stringent check later on, if we
            // think we have a match. Stop if cTest is NULL.
            while((((cTest=*lpFace)==(cMapFace=*npMapFace)) ||
                ('\x01'==cMapFace)) && cTest)
            {
                npMapFace++;
                lpFace++;
            }

            // We arrive here via two conditions: (1) we've reached the
            // end of lpFace and cTest is NULL, or (2) cMapFace and cTest
            // failed to compare. We should only continue searching if
            // cMapFace is non-NULL and cTest is larger than cMapFace (take
            // advantage of the fact that FaceMap is sorted alphabetically).
            // For overall performance, check for the no match case first.

            // Move to the next table entry as long as there's still a
            // chance to find a match.
            if(cTest > cMapFace)
            {
                npMapFace+=sizeof(FACEMAP);
                wLoop++;
                continue;     // Go to the next iteration
            }

            // if cTest is non-NULL, then the sorting of the table guarantees
            // that there are no matches. Bail out now.
            if(cTest)
                goto MFN_exit;

            // cTest is NULL, so we will not make another iteration. The
            // only thing left to decide is whether or not we have a match
            // with the current string.
            if(cMapFace)
                goto MFN_exit;

            // The guards above ensure that we only arrive here if both
            // cTest and cMapFace are NULL, which means that if we're
            // going to find a match, this string is it. We took shortcuts
            // in the comparisons above, so do a stringent comparison now
            // to be sure that this is really a match. The only characters
            // to match wildcards are '1' and 'N', since these are the only
            // ones used in previous versions of the driver.

            for(lpFace=lplfOld->lfFaceName,npMapFace=FaceMap[wLoop].szOldFace;
                (cMapFace=*npMapFace) && (cTest=*lpFace);
                npMapFace++,lpFace++)
            {
                if(!((cTest==cMapFace) ||
                    (('\x01'==cMapFace)&&(('1'==cTest)||('N'==cTest)))))
                {
                    // False trigger--bail out without changing facename
                    goto MFN_exit;
                }
            }

            // We now know that this really is a match--keep the requested
            // attributes & change just the face name.

            *lplfNew=*lplfOld;
            lstrcpy(lplfNew->lfFaceName,FaceMap[wLoop].szNewFace);
            lpReturn=lplfNew;
            goto MFN_exit;
        }
    }

MFN_exit:

    return (LPSTR)lpReturn;
}


#endif

//----------------------------------------------------------------------
// Function: RealizeObject(lpdv,sStyle,lpInObj,lpOutObj,lpTextXForm)
//
// Action: Hook this out to enable font substitution. If the object isn't
//         a font, do absolutely nothing.
//
// Return: Save as UniRealizeObject().
//----------------------------------------------------------------------
DWORD FAR PASCAL RealizeObject(LPDV        lpdv,
                               short       sStyle,
                               LPSTR       lpInObj,
                               LPSTR       lpOutObj,
                               LPTEXTXFORM lpTextXForm)
{
#ifndef NOFONTMAP

    LOGFONT   lfNew;

    if(OBJ_FONT==sStyle)
        lpInObj=MapFaceName((LPLOGFONT)lpInObj,&lfNew);

#endif

    return UniRealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm);
}

#endif  //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\ppdskres\etc\ppdsch.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

#define PRINTDRIVER
#include "print.h"
#include "gdidefs.inc"
#include "windows.h"
#include "string.h"

// the following 3 definitions MUST be compatible with the
// HPPCL font installer

//Is this needed for IBMPPDS ?????
#define CLASS_LASERJET      0
#define CLASS_DESKJET       1
#define CLASS_DESKJET_PLUS  2

#define MAXBLOCK                400

char *rgchModuleName = "PPDSCH";

#ifndef	WINNT
// typedef for font installer
typedef int (FAR PASCAL *SFPROC)(HANDLE,HWND,LPSTR,LPSTR,LPSTR,int,
                                 BOOL,short);

// Local routines
int FAR PASCAL lstrcopyn(LPSTR, LPSTR, int);

//---------------------------*InstallExtFonts*---------------------------------
// Action: call the specific font installer to add/delete/modify soft fonts
//          and/or external cartridges.
//
// Parameters:
//      HWND    hWnd;           handle to the parent windows.
//      LPSTR   lpDeviceName;   long pointer to the printer name.
//      LPSTR   lpPortName;     long pointer to the associated port name.
//      BOOL    bSoftFonts;     flag if supporting soft fonts or not.
//
//  Return Value:
//      > 0   :  if the font information has changed;
//      == 0  :  if nothing has changed;
//      == -1 :  if intending to use the universal font installer
//               (not available now).
//-------------------------------------------------------------------------

int FAR PASCAL InstallExtFonts(hWnd, lpDeviceName, lpPortName, bSoftFonts)
HWND    hWnd;
LPSTR   lpDeviceName;
LPSTR   lpPortName;
BOOL    bSoftFonts;
{
    int     fsVers, fonttypes;
    HANDLE  hFIlib, hModule;
    SFPROC  lpFIns;
    static char    LocalDeviceName[80];

    /*************************************************************/
    /* If device is 4019 then font type support is bitmap.       */
    /* For any other printer (4029, 4037, ...(?)) font type      */
    /* support is outline.  Because of current Unidrv limitation */
    /* both bitmap and outline support (value = 3) cannot be     */
    /* supported by the same printer model.                      */
    /* MFC - 9/8/94                                              */
    /*************************************************************/
    LocalDeviceName[0] = '\0';
    lstrcopyn((LPSTR)LocalDeviceName, lpDeviceName, 79);
    LocalDeviceName[79] = '\0';
    if (strstr(LocalDeviceName, "4019") != NULL)
       fonttypes = 1;            // Bitmap
    else
       fonttypes = 2;            // Outline

    if ((hFIlib = LoadLibrary((LPSTR)"SF4029.EXE")) < 32 ||
	!(lpFIns = (SFPROC)GetProcAddress(hFIlib,"SoftFontInstall")))
	{
	if (hFIlib >= 32)
	    FreeLibrary(hFIlib);

	MessageBox(0,
	           "Can't load SF4029.EXE or can't get SoftFontInstall",
		        NULL, MB_OK);

   return TRUE;
	}

   hModule = GetModuleHandle((LPSTR)"PPDSCH.DRV");

    // FINSTALL.DLL was loaded properly. Now call SoftFontInstall().
    // We choose to ignore the returned "fvers". No use of it.
    fsVers = (*lpFIns)(hModule, hWnd, lpDeviceName, lpPortName,
                       (LPSTR)rgchModuleName, fonttypes, (BOOL)0,
                       (short)0);
    FreeLibrary(hFIlib);
    return fsVers;
}


//---------------------------*lstrcopyn*---------------------------------
// Action: Copies n characters from one string to another.  If the end of
//         the source string has been reached before n characters have
//         been copied, the the destination string is padded with nulls.
//         Returns the number of characters used from the source string.
//
// Parameters:
//      LPSTR   string1;    Destination string;
//      LPSTR   string2;    Source string;
//      int     n;          Number of characters to copy.
//
//  Return Value:
//      int   :  Number of characters copied from source string
//-------------------------------------------------------------------------

int FAR PASCAL lstrcopyn(string1, string2, n)
LPSTR   string1;
LPSTR   string2;
int     n;
{
    int     i = 0;
    LPSTR   s1, s2;

    s1 = string1;
    s2 = string2;

    while ((*s2) && (n > 0))
    {
       *s1++ = *s2++;
       i++;
       n--;
    }

    while (n > 0)
    {
       *s1++ = '\0';
       n--;
    }

    return i;
}

#endif  // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\qbjres\etc\qbj.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
char *rgchModuleName = "QBJ";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\qplkres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

// NOTICE-2002/03/20-v-sueyas-
//    04/07/97 -zhanw-
//        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

// #289908: pOEMDM -> pdevOEM
static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE((DLLTEXT("OEMDevMode(%s) entry.\n"), OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEM_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR( ("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//  // NOTICE-2002/03/20-v-sueyas-
//  //History:
//  //            02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//  // NOTICE-2002/03/20-v-sueyas-
//  //History:
//  //        02/11/97        APresley Created.
//  //        04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//  // NOTICE-2002/03/20-v-sueyas-
//  //History:
//  //            02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR( ("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR( ("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//  // NOTICE-2002/03/20-v-sueyas-
//  //History:
//  //            02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\qplkres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <minidrv.h>
// NTRAID#NTBUG9-581725-2002/03/20-v-sueyas-: Use strsafe.h(pdev.h)
#include "pdev.h"

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\qplkres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\qplkres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

// NTRAID#NTBUG9-588582-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));

	// NTRAID#NTBUG9-581725-2002/03/25-v-sueyas-: Check for illegal parameters
    if (NULL == ppv)
        return E_NOINTERFACE;

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// ######################

// Function Name: GetInfo
// Plug-in: Any
// Driver: Any
// Type: Mandatory
//

LONG __stdcall
IOemCB::GetInfo(
    DWORD dwMode,
    PVOID pBuffer,
    DWORD cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}

// ######################

//
// Function Name: PublishDriverInterface
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

LONG __stdcall
IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

//
// Function Name: GetImplementationMethod
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

int __cdecl
iCompNames(
    void *p1,
    void *p2) {

	// NTRAID#NTBUG9-581725-2002/03/25-v-sueyas-: Check for illegal parameters
       return strcmp(
        (NULL == p1 ? "" : *((char **)p1)),
        (NULL == p2 ? "" : *((char **)p2)));

}

LONG __stdcall
IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    LONG lRet = E_NOTIMPL;
    PSTR pTemp;

    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

    if (NULL != pMethodName) {

        pTemp = (PSTR)bsearch(
            &pMethodName,
            gMethodsSupported,
            (sizeof (gMethodsSupported) / sizeof (PSTR)),
            sizeof (PSTR),
            (int (__cdecl *)(const void *, const void *))iCompNames);

        if (NULL != pTemp)
            lRet = S_OK;
    }

    VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

    return lRet;
}

// #######################

//
// Function Name: EnableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::EnableDriver(
    DWORD dwDriverVersion,
    DWORD cbSize,
    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: DisableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: EnablePDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

	// NTRAID#NTBUG9-581725-2002/03/25-v-sueyas-: Check for illegal parameters
	if (NULL == pDevOem)
		return E_FAIL;

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return E_FAIL;
}

//
// Function Name: DisablePDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DisablePDEV(
    PDEVOBJ pdevobj)
{
    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

    OEMDisablePDEV(pdevobj);
    return S_OK;
}

//
// Function Name: ResetPDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));

    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return E_FAIL;
}

//
// Function Name: DevMode
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

LONG __stdcall
IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

// ################


//
// Function Name: CommandCallback
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::CommandCallback(
    PDEVOBJ pdevobj,
    DWORD dwCallbackID,
    DWORD dwCount,
    PDWORD pdwParams,
    OUT INT *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

	// NTRAID#NTBUG9-581725-2002/03/25-v-sueyas-: Check for illegal parameters
	if (NULL == piResult)
		return E_FAIL;

    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

//
// Function Name: ImageProcessing
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: FilterGraphics
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::FilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if (OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

//
// Function Name: Compression
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: HalftonePattern
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: MemoryUsge
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadFontHeader
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadCharGlyph
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTDonwloadMethod
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: OutputCharStr
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: SendFontCmd
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DriverDMS
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TextOutputAsBitmap
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTYGetInfo
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

LONG __stdcall
IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
	// NTRAID#NTBUG9-581725-2002/03/25-v-sueyas-: Check for illegal parameters
    if (NULL == ppv)
        return E_NOINTERFACE;

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation

HRESULT __stdcall
IOemCF::CreateInstance(
    IUnknown *pUnknownOuter,
    const IID &iid,
    void **ppv)
{

    // Cannot aggregate.
    if (NULL != pUnknownOuter) {

        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB;
    if (NULL == pOemCB) {

        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\qplkres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
#include <strsafe.h>

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'QPLK'      // QPL resource DLL
#define DLLTEXT(s)      "QPLK: " s
#define OEM_VERSION      0x00010000L

#define SCANLINE_BUFFER_SIZE	1280    // A3 landscape scanline length + extra

// Worst case is like "ABB". It is compressed to 
// "[non-continuous count]A[continuous count]B".
// So, we need RLE buffer whose size is 4/3 times as large as scanline buffer. 
// But just to make sure, 2x size of buffer is prepared.
#define COMPRESS_BUFFER_SIZE	SCANLINE_BUFFER_SIZE*2

// Color support
#define CC_CYAN		5	//current plain is cyan
#define CC_MAGENTA	6	//current plain is magenta
#define CC_YELLOW	7	//current plain is yellow
#define CC_BLACK	4	//current plain is black

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

// #289908: pOEMDM -> pdevOEM
typedef struct tag_OEM_EXTRADATA {
    OEM_DMEXTRAHEADER	dmExtraHdr;
} OEM_EXTRADATA, *POEM_EXTRADATA;

typedef struct tag_QPLKPDEV {
    // Private extention
	BOOL		bFirst;
	DWORD		dwCompType;
// Color support
	DWORD		dwCyanLastScanLineLen;
	DWORD		dwMagentaLastScanLineLen;
	DWORD		dwYellowLastScanLineLen;
	DWORD		dwBlackLastScanLineLen;
	BYTE		lpCyanLastScanLine[SCANLINE_BUFFER_SIZE];
	BYTE		lpMagentaLastScanLine[SCANLINE_BUFFER_SIZE];
	BYTE		lpYellowLastScanLine[SCANLINE_BUFFER_SIZE];
	BYTE		lpBlackLastScanLine[SCANLINE_BUFFER_SIZE];
	BOOL		bColor;
	UINT		fColor;
} QPLKPDEV, *PQPLKPDEV;

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\qplkres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
//     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
//     "EnablePDEV",
    "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//    "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\qplkres\qplkres.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

// NOTICE-2002/03/20-v-sueyas-
//    04/07/97 -zhanw-
//        Created it.

--*/

#include "pdev.h"

// #289908: pOEMDM -> pdevOEM
PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
	// NTRAID#NTBUG9-581725-2002/03/20-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("OEMEnablePDEV: Invalid parameter(s).\n"));
        return NULL;
    }

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(QPLKPDEV))))
        {
            return NULL;
        }
    }

    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
	// NTRAID#NTBUG9-581725-2002/03/20-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("OEMDisablePDEV: Invalid parameter(s).\n"));
        return;
    }

    if(pdevobj->pdevOEM)
    {
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PQPLKPDEV pOEMOld, pOEMNew;

	// NTRAID#NTBUG9-581725-2002/03/20-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobjOld || NULL == pdevobjNew)
    {
        ERR(("OEMResetPDEV: Invalid parameter(s).\n"));
        return FALSE;
    }

    pOEMOld = (PQPLKPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PQPLKPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL)
        *pOEMNew = *pOEMOld;

    return TRUE;
}

//  BInitOEMExtraData() and BMergeOEMExtraData() has moved to common.c

// #######

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

// Private Definition
// Command callback
#define CMD_BEGINPAGE_DELTAROW		1
#define CMD_SENDBLOCKDATA_DELTAROW	2
#define CMD_SENDBLOCKDATA_B2		3
#define CMD_BEGINPAGE_B2			4
// Color support
#define CMD_BEGINPAGE_C1            5
#define CMD_BEGINPAGE_DEFAULT       6
#define CMD_BEGINPAGE_B2_LAND       7

// Special fix for Qnix Picasso 300
#define CMD_BEGINPAGE_B2_PICA       8

#define CMD_CR						10
#define CMD_LF						11
#define CMD_FF						12

// Color support
#define CMD_SELECT_CYAN			100
#define CMD_SELECT_MAGENTA		101
#define CMD_SELECT_YELLOW		102
#define CMD_SELECT_BLACK		103

#define CMD_YMOVE_REL_COLOR		150

// #299937: Incorrect value for Y Move
#define COLOR_MASTERUNIT                600

// Compression Type
#define COMP_DELTARAW				1
#define COMP_B2						2
#define COMP_NOCOMP					3

// Compression routine
WORD DeltaRawCompress(PBYTE, PBYTE, PBYTE, DWORD, DWORD);
WORD B2Compress(PBYTE, PBYTE, PBYTE, DWORD);
PBYTE RLE_comp(PBYTE);
WORD RLEencoding(PBYTE, PBYTE, DWORD);

/*****************************************************************************/
/*                                                                           */
/*   BOOL APIENTRY OEMFilterGraphics(                                        */
/*                PDEVOBJ pdevobj                                            */
/*                PBYTE   pBuf                                               */
/*                DWORD   dwLen )                                            */
/*                                                                           */
/*****************************************************************************/
BOOL APIENTRY 
OEMFilterGraphics(
	PDEVOBJ    pdevobj, // Points to private data required by the Unidriver.dll
	PBYTE      pBuf,    // points to buffer of graphics data
	DWORD      dwLen)   // length of buffer in bytes
{
	BYTE			CompressedScanLine[COMPRESS_BUFFER_SIZE];
	BYTE			HeaderScanLine[4];
	WORD			nCompBufLen;
	PQPLKPDEV               pOEM;
	// Color support
	PDWORD			pdwLastScanLineLen;
	LPSTR			lpLastScanLine;
	BYTE			HeaderColorPlane;

	// NTRAID#NTBUG9-581725-2002/03/20-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj || NULL == pBuf || 0 == dwLen)
    {
        ERR(("OEMFilterGraphics: Invalid parameter(s).\n"));
        return FALSE;
    }

	pOEM = (PQPLKPDEV)pdevobj->pdevOEM;

	// NTRAID#NTBUG9-581725-2002/03/20-v-sueyas-: Check for null pointers
    if (NULL == pOEM)
    {
        ERR(("OEMFilterGraphics: pdevobj->pdevOEM = 0.\n"));
        return FALSE;
    }

	if (pOEM->bFirst)
	{
		// Color support
		ZeroMemory(pOEM->lpCyanLastScanLine, sizeof pOEM->lpCyanLastScanLine );
		ZeroMemory(pOEM->lpMagentaLastScanLine, sizeof pOEM->lpMagentaLastScanLine );
		ZeroMemory(pOEM->lpYellowLastScanLine, sizeof pOEM->lpYellowLastScanLine );
		ZeroMemory(pOEM->lpBlackLastScanLine, sizeof pOEM->lpBlackLastScanLine );
		pOEM->bFirst = FALSE;
	}
	// Color support
	switch (pOEM->fColor) {
	case CC_CYAN:
		HeaderColorPlane = 0x05;
		pdwLastScanLineLen = &(pOEM->dwCyanLastScanLineLen);
		lpLastScanLine = pOEM->lpCyanLastScanLine;
		break;
	case CC_MAGENTA:
		HeaderColorPlane = 0x06;
		pdwLastScanLineLen = &(pOEM->dwMagentaLastScanLineLen);
		lpLastScanLine = pOEM->lpMagentaLastScanLine;
		break;
	case CC_YELLOW:
		HeaderColorPlane = 0x07;
		pdwLastScanLineLen = &(pOEM->dwYellowLastScanLineLen);
		lpLastScanLine = pOEM->lpYellowLastScanLine;
		break;
	case CC_BLACK:
	default:	// Black&White
		HeaderColorPlane = 0x04;
		pdwLastScanLineLen = &(pOEM->dwBlackLastScanLineLen);
		lpLastScanLine = pOEM->lpBlackLastScanLine;
		break;
	}
	if(pOEM->dwCompType == COMP_DELTARAW)
	{
		nCompBufLen = (WORD)DeltaRawCompress(pBuf, lpLastScanLine,
			CompressedScanLine, (*pdwLastScanLineLen > dwLen) ?
			*pdwLastScanLineLen : dwLen, (DWORD)0);

		HeaderScanLine[0] = 0;
		HeaderScanLine[1] = 0;
		HeaderScanLine[2] = HIBYTE(nCompBufLen);
		HeaderScanLine[3] = LOBYTE(nCompBufLen);

		WRITESPOOLBUF(pdevobj, (PBYTE) HeaderScanLine, 4);
		WRITESPOOLBUF(pdevobj, (PBYTE) CompressedScanLine, nCompBufLen);
		if( dwLen > SCANLINE_BUFFER_SIZE ) return FALSE;
		CopyMemory(lpLastScanLine, pBuf, dwLen);
		if (*pdwLastScanLineLen > dwLen) {
			if(*pdwLastScanLineLen > SCANLINE_BUFFER_SIZE ) return FALSE;
			ZeroMemory(lpLastScanLine + dwLen,
			*pdwLastScanLineLen - dwLen);
		}

		*pdwLastScanLineLen = dwLen;
	} else if(pOEM->dwCompType == COMP_B2) {
		nCompBufLen = B2Compress(lpLastScanLine, pBuf,
			CompressedScanLine, (*pdwLastScanLineLen > dwLen) ?
			*pdwLastScanLineLen : dwLen);

		// send color plane command
		if (pOEM->bColor)
			WRITESPOOLBUF(pdevobj, &HeaderColorPlane, 1);

		HeaderScanLine[0] = 0x02;
		HeaderScanLine[1] = (BYTE) (nCompBufLen >> 8);
		HeaderScanLine[2] = (BYTE) nCompBufLen;
		WRITESPOOLBUF(pdevobj, (PBYTE) HeaderScanLine, 3);
                // #297256: Line is cut and increase
                // Do not send if no compressed data.
		if (nCompBufLen) {
		    WRITESPOOLBUF(pdevobj, (PBYTE) CompressedScanLine,
                        nCompBufLen);
		    *pdwLastScanLineLen = dwLen;
                }

	}

	return TRUE;
}

/*****************************************************************************/
/*                                                                           */
/*   INT APIENTRY OEMCommandCallback(                                        */
/*                PDEVOBJ pdevobj                                            */
/*                DWORD   dwCmdCbId                                          */
/*                DWORD   dwCount                                            */
/*                PDWORD  pdwParams                                          */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbId,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams)  // points to values of command params
{
    PQPLKPDEV      pOEM;
	INT					iRet = 0;
// Color support
	DWORD	count, n, unit;
	BYTE	aCmd[32];

	// NTRAID#NTBUG9-581725-2002/03/20-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("OEMCommandCallback: Invalid parameter(s).\n"));
        return 0;
    }

    pOEM = (PQPLKPDEV)(pdevobj->pdevOEM);

	// NTRAID#NTBUG9-581725-2002/03/20-v-sueyas-: Check for null pointers
    if (NULL == pOEM)
    {
        ERR(("OEMCommandCallback: pdevobj->pdevOEM = 0.\n"));
        return 0;
    }

    switch(dwCmdCbId)
    {
        case CMD_BEGINPAGE_DEFAULT:
			WRITESPOOLBUF(pdevobj, "\033}0;0;5B", 8);
			pOEM->bFirst = TRUE;
            break;

        case CMD_BEGINPAGE_DELTAROW:
			WRITESPOOLBUF(pdevobj, "\033}0;0;3B", 8);
			pOEM->bFirst = TRUE;
            break;

        case CMD_BEGINPAGE_B2:
        case CMD_BEGINPAGE_B2_PICA:
			WRITESPOOLBUF(pdevobj, "\033}0;0;4B", 8);
			pOEM->bFirst = TRUE;
            if (dwCmdCbId == CMD_BEGINPAGE_B2_PICA )
            {
                if (pdwParams[0] == 300 )
                    WRITESPOOLBUF(pdevobj, "\x00\x1C", 2);
                else
                    WRITESPOOLBUF(pdevobj, "\x00\x38", 2);
            }
            break;

        case CMD_BEGINPAGE_B2_LAND:
			WRITESPOOLBUF(pdevobj, "\033}0;0;7B", 8);
			pOEM->bFirst = TRUE;
            break;

	// Color support
        case CMD_BEGINPAGE_C1:
			WRITESPOOLBUF(pdevobj, "\033}0;0;6B", 8);
// #315089: some lines isn't printed on printable area test.
// move cursor to printable origin.
                        WRITESPOOLBUF(pdevobj,
                            "\x05\x00\x03\x06\x00\x03\x07\x00\x03\x04\x00\x03",
                            12);
			pOEM->bFirst = TRUE;
			pOEM->dwCompType = COMP_B2;
			pOEM->bColor = TRUE;
            break;

		case CMD_SENDBLOCKDATA_DELTAROW:
			pOEM->dwCompType = COMP_DELTARAW;
			break;

		case CMD_SENDBLOCKDATA_B2:
			pOEM->dwCompType = COMP_B2;
			break;

		case CMD_CR:
		case CMD_LF:
		case CMD_FF:
			// Dummy support
			break;

// Color support
	case CMD_SELECT_CYAN:
		pOEM->fColor = CC_CYAN;
		break;

	case CMD_SELECT_MAGENTA:
		pOEM->fColor = CC_MAGENTA;
		break;

	case CMD_SELECT_YELLOW:
		pOEM->fColor = CC_YELLOW;
		break;

	case CMD_SELECT_BLACK:
		pOEM->fColor = CC_BLACK;
		break;

	case CMD_YMOVE_REL_COLOR:
// #299937: Incorrect value for Y Move
// YMove value is always in MasterUnit even YMoveUnit was specified.
		if (dwCount < 2 || !pdwParams)
			break;

		// NTRAID#NTBUG9-581725-2002/03/20-v-sueyas-: Check for deviding by zero
	    if (0 == pdwParams[1])
	        return 0;

		unit = COLOR_MASTERUNIT / pdwParams[1];
		if (unit == 0)
			unit = 1;	// for our safety
		count = pdwParams[0] / unit;
		while (count > 0) {
			n = min(count, 255);
			aCmd[0] = 0x04;
			aCmd[1] = 0x00;
			aCmd[2] = (BYTE)n;
			aCmd[3] = 0x05;
			aCmd[4] = 0x00;
			aCmd[5] = (BYTE)n;
			aCmd[6] = 0x06;
			aCmd[7] = 0x00;
			aCmd[8] = (BYTE)n;
			aCmd[9] = 0x07;
			aCmd[10] = 0x00;
			aCmd[11] = (BYTE)n;
			WRITESPOOLBUF(pdevobj, aCmd, 12);
			count -= n;
		}
		iRet = pdwParams[0];
		break;

        default:
            break;
    }

    return iRet;
}

/*************************************************
 *
 * Image Delta Compression Routine
 *
 *===================================================
 * Input:
 *	 nbyte		 : # of byte, raw data
 *	 Image_string: pointer of raw data
 *	 Prn_string  : pointer of compress data
 * Output:
 *	 Ret_count	 : # of byte, compress data
**************************************************/
WORD DeltaRawCompress(
	PBYTE	Image_string,	/* pointer to original string */
	PBYTE	ORG_image,		/* pointer to previous scanline's string */
	PBYTE	Prn_string,		/* pointer to return string */
	DWORD	nbyte,			/* original number of bytes */
	DWORD	nMagics)		//Magic number
{
	DWORD		c, Ret_count, Skip_flag, Skip_count;
	DWORD		i, j, k, outcount;
	PBYTE		Diff_ptr;
	PBYTE		ORG_ptr;
	PBYTE		Skip_ptr;
	BYTE		Diff_byte;
	BYTE		Diff_mask[8]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
	BOOL		bstart = TRUE;

	outcount = 0;
	Ret_count = 0;
	ORG_ptr = ORG_image;
	Skip_flag = TRUE;

	Skip_ptr = Prn_string++;
	Skip_count = (nMagics / 8) / 8;
	*Skip_ptr = (BYTE)Skip_count;

	k = (nbyte + 7) / 8;
	for(i = 0; i < k; i++)
	{
		Diff_byte = 0;
		Diff_ptr = Prn_string++;

		for(j = 0; j < 8; j++)
		{
			if ( (i * 8 + j) >= nbyte )
			{
				*Prn_string++= 0;
				Diff_byte |= Diff_mask[j];
				outcount++;
			} else {
				c = *Image_string++;
				if(c != *ORG_ptr)
				{
					*ORG_ptr++ = (BYTE)c;
					*Prn_string++= (BYTE)c;
					Diff_byte |= Diff_mask[j];
					outcount++;
				} else {
					ORG_ptr++;
				}
			}
		}

		if(Diff_byte == 0)
		{
			if(Skip_flag == TRUE)
			{
				Skip_count++;
				Prn_string--;
			}else{
				*Diff_ptr = Diff_byte;
				outcount++;
			}
		}else{
			if(Skip_flag == TRUE)
			{
				Skip_flag = FALSE;
				*Skip_ptr = (BYTE)Skip_count;
				outcount++;
				*Diff_ptr = Diff_byte;
				outcount++;
			}else{
				*Diff_ptr = Diff_byte;
				outcount++;
			}
			Ret_count = outcount;
		}
	}
	return (WORD)Ret_count;
}

/*****************************************************************************/
/*                                                                           */
/*         WORD B2Compress(                                                  */
/*                PBYTE   pLastScanLine                                      */
/*                PBYTE   pCurrentScanLine                                   */
/*                PBYTE   pPrnBuf                                            */
/*                DWORD   nImageWidth                                        */
/*                                                                           */
/*****************************************************************************/
WORD B2Compress(
	PBYTE	pLastScanLine, 
	PBYTE	pCurrentScanLine, 
	PBYTE	pPrnBuf, 
	DWORD	nImageWidth)
{
	PBYTE	pLast, pCurrent, pComp;
	PBYTE	pByteNum, pCountByte;
	WORD	i;
	BYTE	nSameCount, nDiffCount;

        // #297256: Line is cut and increase
        // Indicate to zero if this place doesn't have any data.
        if (nImageWidth == 0)
            return 0;

	pLast = pLastScanLine;
	pCurrent = pCurrentScanLine;
	pComp = pPrnBuf;

	pByteNum = pComp;
	nSameCount = 0;
	nDiffCount = 0;
	pCountByte = pComp++;

	for(i = 0; i < nImageWidth; i++)
	{
		if(*pCurrent != *pLast)
		{
			nDiffCount++;
			if(nSameCount)      // if continuous data remain...
			{
				*pCountByte = nSameCount;
				pCountByte = pComp++;
				nSameCount = 0;
			}
			if(nDiffCount > 127)
			{
				*pCountByte = 127 + 128;
				pComp = RLE_comp(pCountByte);
				pCountByte = pComp++;
				nDiffCount -= 127;
			}
			*pLast = *pCurrent;
			*pComp++ = *pCurrent;
		} else {
			nSameCount++;
			if(nDiffCount)      // if non-continuous data remain...
			{
				*pCountByte = nDiffCount + 128;
				pComp = RLE_comp(pCountByte);
				pCountByte = pComp++;
				nDiffCount = 0;
			}
			if(nSameCount > 127)
			{
				*pCountByte = 127;
				pCountByte = pComp++;
				nSameCount -= 127;
			}
		}
		pCurrent++;
		pLast++;
	}  // end of for loop
	
	if(nSameCount)
		*pCountByte = nSameCount;

	if(nDiffCount)
	{
		*pCountByte = nDiffCount+128;
		pComp = RLE_comp(pCountByte);
	}
	
	return((WORD) (pComp - pByteNum));
}

/*****************************************************************************/
/*                                                                           */
/*         PBYTE RLE_comp(LPBYTE p)                                          */
/*                                                                           */
/*****************************************************************************/
PBYTE RLE_comp(PBYTE p)
{
	WORD	i, count, RLEEncodedCount;
	PBYTE	p1;
	BYTE	RLEBuffer[COMPRESS_BUFFER_SIZE];

	count = (WORD) (*p - 128);
	if(count > 4)
	{
		RLEEncodedCount = RLEencoding(p + 1, (PBYTE) RLEBuffer, count);

		if(RLEEncodedCount < count)
		{
			*p++ = 0;	// RLE encode indicator
			*p++ = (BYTE) RLEEncodedCount;
			p1 = RLEBuffer;

			for(i = 0; i < RLEEncodedCount; i++)
				*p++ = *p1++;

			return(p);
		}
	}
	return(p + 1 + count);
}

/*****************************************************************************/
/*                                                                           */
/*         WORD RLEencoding(                                                 */
/*                PBYTE   pCurrent                                           */
/*                PBYTE   pComp                                              */
/*                DWORD   count                                              */
/*                                                                           */
/*****************************************************************************/
WORD RLEencoding(
	PBYTE	pCurrent,
	PBYTE	pComp,
	DWORD	count)
{
	WORD	i, nByteNum;
    BYTE	curr, next, RLEcount;

	nByteNum = 0;
	RLEcount = 1;

	// NTRAID#NTBUG9-581725-2002/03/20-v-sueyas-: Initialize un-initialized variable
	next = 0;

	for(i = 0; i < count - 1; i++)
	{
		curr = *pCurrent++;
		next = *pCurrent;

		if(curr == next)
		{
			if(RLEcount == 255)
			{
				*pComp++ = RLEcount;
                *pComp++ = curr;
				nByteNum += 2;
				RLEcount = 1;
			} else {
				RLEcount++;
			} 
		} else {
			*pComp++ = RLEcount;
            *pComp++ = curr;
			nByteNum += 2;
			RLEcount = 1;
		}
	}
	*pComp++ = RLEcount;
    *pComp++ = next;
	nByteNum += 2;

	return(nByteNum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\qplkres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=KOR
ALT_PROJECT_TARGET=$(ALT_PROJECT)

VRTK_DIR=$(PRNROOT)\gpd\vrtk\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=qplkres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),qplkres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=949

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\qplkres.rc \
    $(SRCDIR)\qplkres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\qplkres.ini \
    $(VRTK_DIR)\vtlc2kk.gpd \
    $(VRTK_DIR)\vtlc4kk.gpd \
    $(VRTK_DIR)\vtlc6kk.gpd \
    $(VRTK_DIR)\vtls425k.gpd \
    $(VRTK_DIR)\vtls450k.gpd \
    $(VRTK_DIR)\vtls750k.gpd \
    $(VRTK_DIR)\vtls850k.gpd \
    $(VRTK_DIR)\vtls7ek.gpd \
    $(VRTK_DIR)\vtlsf35k.gpd \
    $(VRTK_DIR)\vtlsf41k.gpd \
    $(VRTK_DIR)\vtlsf42k.gpd \
    $(VRTK_DIR)\vtlsf43k.gpd \
    $(VRTK_DIR)\vtlsf44k.gpd \
    $(VRTK_DIR)\vtlsf45k.gpd \
    $(VRTK_DIR)\vtlsf50k.gpd \
    $(VRTK_DIR)\vtlsf55k.gpd \
    $(VRTK_DIR)\vtlsf65k.gpd \
    $(VRTK_DIR)\vtlsf70k.gpd \
    $(VRTK_DIR)\vtlsf75k.gpd \
    $(VRTK_DIR)\vtlsf78k.gpd \
    $(VRTK_DIR)\vtlsf80k.gpd \
    $(VRTK_DIR)\vtlsf85k.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\qplkres\etc\qlaserb1.c ===
#include	<windef.h>
#include	<wingdi.h>
#include	<unidrv.h>

#include	"../modinit.c"

#define SCANLINE_BUFFER_SIZE	1280	// A3 landscape scanline length + extra

// Delta Raw Compression routine
int DeltaRawCompress(LPBYTE, LPBYTE, LPBYTE, WORD, WORD);

LPWRITESPOOLBUF WriteSpoolBuf;
LPALLOCMEM UniDrvAllocMem;
LPFREEMEM UniDrvFreeMem;

typedef struct tagQLASERDV 
{
  BOOL  bFirst;
  WORD  wLastScanLineLen;
  BYTE  lpLastScanLine[SCANLINE_BUFFER_SIZE];
} QLASERDV, FAR *LPQLASERDV;


BOOL MiniDrvEnablePDEV(LPDV lpdv, ULONG *pdevcaps)
{
    lpdv->fMdv = FALSE;
    if (!(lpdv->lpMdv = UniDrvAllocMem(sizeof(QLASERDV))))
         return FALSE;

    lpdv->fMdv = TRUE;
	((LPQLASERDV)lpdv->lpMdv)->bFirst = FALSE;
	((LPQLASERDV)lpdv->lpMdv)->wLastScanLineLen = 0;

    return TRUE;
}


VOID MiniDrvDisablePDEV(LPDV lpdv)
{
    if (lpdv->fMdv)
    {
        UniDrvFreeMem(lpdv->lpMdv);
        lpdv->fMdv = FALSE;
    }
}


VOID FAR PASCAL fnOEMOutputCmd(LPDV lpdv, WORD wCmdCbId, PDWORD lpdwParams)
{
	if (wCmdCbId == 1) // StartPage
	{
        WriteSpoolBuf(lpdv, "\033}0;0;3B", 8);
		((LPQLASERDV)lpdv->lpMdv)->bFirst = TRUE;
	}
}


WORD FAR PASCAL CBFilterGraphics(LPDV lpdv, LPBYTE lpBuf, WORD wLen)
{
	BYTE  CompressedScanLine[SCANLINE_BUFFER_SIZE];
    BYTE  HeaderScanLine[4];
	WORD  nCompBufLen;
	LPQLASERDV  lpQDV = lpdv->lpMdv;

	if (lpQDV->bFirst)
	{
		ZeroMemory(lpQDV->lpLastScanLine, (WORD)SCANLINE_BUFFER_SIZE);
		lpQDV->bFirst = FALSE;
	}
	nCompBufLen = (WORD) DeltaRawCompress(lpBuf, lpQDV->lpLastScanLine,
					CompressedScanLine, (lpQDV->wLastScanLineLen > wLen)
					? lpQDV->wLastScanLineLen : wLen, 0);

    HeaderScanLine[0] = 0;
    HeaderScanLine[1] = 0;
    HeaderScanLine[2] = (BYTE) (nCompBufLen >> 8);
    HeaderScanLine[3] = (BYTE) nCompBufLen;
    WriteSpoolBuf(lpdv, (LPBYTE) HeaderScanLine, 4);
    WriteSpoolBuf(lpdv, (LPBYTE) CompressedScanLine, nCompBufLen);

	CopyMemory(lpQDV->lpLastScanLine, lpBuf, wLen);
	if (lpQDV->wLastScanLineLen > wLen)
		ZeroMemory(lpQDV->lpLastScanLine + wLen, lpQDV->wLastScanLineLen - wLen);
    lpQDV->wLastScanLineLen = wLen;

    return nCompBufLen;
}


DRVFN  MiniDrvFnTab[] =
{
    {  INDEX_MiniDrvEnablePDEV,    (PFN)MiniDrvEnablePDEV  },
    {  INDEX_MiniDrvDisablePDEV,   (PFN)MiniDrvDisablePDEV  },
    {  INDEX_OEMOutputCmd,         (PFN)fnOEMOutputCmd  },
    {  INDEX_OEMWriteSpoolBuf,     (PFN)CBFilterGraphics  },
};


BOOL MiniDrvEnableDriver(MINIDRVENABLEDATA *pEnableData)
{
    if (pEnableData == NULL)
        return FALSE;

    if (pEnableData->cbSize == 0)
    {
        pEnableData->cbSize = sizeof (MINIDRVENABLEDATA);
        return TRUE;
    }

    if (pEnableData->cbSize < sizeof (MINIDRVENABLEDATA)
            || HIBYTE(pEnableData->DriverVersion)
            < HIBYTE(MDI_DRIVER_VERSION))
    {
        // Wrong size and/or mismatched version
        return FALSE;
    }

    // Load callbacks provided by the Unidriver
    if (!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvWriteSpoolBuf, (PFN *) &WriteSpoolBuf)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvAllocMem, (PFN *) &UniDrvAllocMem)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvFreeMem, (PFN *) &UniDrvFreeMem))
    {
        return FALSE;
    }

    pEnableData->cMiniDrvFn
        = sizeof (MiniDrvFnTab) / sizeof(MiniDrvFnTab[0]);
    pEnableData->pMiniDrvFn = MiniDrvFnTab;

    return TRUE;
}


/*************************************************
 *
 * Image Delta Compression Routine
 *
 *===================================================
 * Input:
 *   nbyte       : # of byte, raw data
 *   Image_string: pointer of raw data
 *   Prn_string  : pointer of compress data
 * Output:
 *   Ret_count   : # of byte, compress data
**************************************************/
int DeltaRawCompress( Image_string, //pbData,
                 ORG_image,    //pbSeedRow,
                 Prn_string,   //pbReturn,
                 nbyte,        //usTotalBytes
                 nMagics)      //Magic number
LPBYTE Image_string;  /* pointer to original string */
LPBYTE ORG_image;     /* pointer to previous scanline's string */
LPBYTE Prn_string;    /* pointer to return string */
WORD  nbyte;         /* original number of bytes */
WORD  nMagics;       //Magic number
{
        int     c, Ret_count, Skip_flag, Skip_count;
        unsigned int     i, j, k, outcount;
        LPBYTE   Diff_ptr;
        LPBYTE   ORG_ptr;
        LPBYTE   Skip_ptr;
        BYTE    Diff_byte;
        BYTE    Diff_mask[8]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};

        BOOL bstart = TRUE;

        outcount = 0;
        Ret_count = 0;
        ORG_ptr = ORG_image;
        Skip_flag = TRUE;

        Skip_ptr = Prn_string++;
        *Skip_ptr = Skip_count = (nMagics/8)/8;

        k = (nbyte+7)/8;
        for(i=0;i<k;i++)
        {
           Diff_byte = 0;
           Diff_ptr = Prn_string++;

           for(j=0;j<8;j++)
           {
              if ( (i*8+j) >= nbyte ){
                  *Prn_string++= 0;
                  Diff_byte |= Diff_mask[j];
                  outcount++;
              } else {
                  c = *Image_string++;
                  if(c != *ORG_ptr){
                    *ORG_ptr++ = c;
                    *Prn_string++= c;
                    Diff_byte |= Diff_mask[j];
                    outcount++;
                  } else {
                    ORG_ptr++;
                  }
              }
           }
           if(Diff_byte == 0){
                if(Skip_flag == TRUE){
                        Skip_count++;
                        Prn_string--;
                }else{
                       *Diff_ptr = Diff_byte;
                       outcount++;
                }
           }else{
                if(Skip_flag == TRUE){
                        Skip_flag = FALSE;
                        *Skip_ptr = Skip_count;
                        outcount++;
                        *Diff_ptr = Diff_byte;
                        outcount++;
                }else{
                       *Diff_ptr = Diff_byte;
                       outcount++;
                }
                Ret_count = outcount;
           }
        }
        return(Ret_count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\qplkres\etc\vlaserc1.c ===
#include	<windef.h>
#include	<wingdi.h>
#include	<unidrv.h>

#include	"../modinit.c"

#define SCANLINE_BUFFER_SIZE		1280	// A3 landscape scanline length + extra
#define ALL_COLOR_Y_MOVE_CMD_LEN	12		// length of Y move command for all colors
#define CC_CYAN		5	//current plain is cyan
#define CC_MAGENTA	6	//current plain is magenta
#define CC_YELLOW	7	//current plain is yellow
#define CC_BLACK	4	//current plain is black

// Block Image 2 Compression routines
WORD B2Compress(LPBYTE, LPBYTE, LPBYTE, WORD);
LPBYTE RLE_comp(LPBYTE);
WORD RLEencoding(LPBYTE, LPBYTE, WORD);

LPWRITESPOOLBUF WriteSpoolBuf;
LPALLOCMEM UniDrvAllocMem;
LPFREEMEM UniDrvFreeMem;

typedef struct tagVLASERDV 
{
  BOOL  bFirst;
  WORD  wCyanLastScanLineLen;
  WORD  wMagentaLastScanLineLen;
  WORD  wYellowLastScanLineLen;
  WORD  wBlackLastScanLineLen;
  BYTE  lpCyanLastScanLine[SCANLINE_BUFFER_SIZE];
  BYTE  lpMagentaLastScanLine[SCANLINE_BUFFER_SIZE];
  BYTE  lpYellowLastScanLine[SCANLINE_BUFFER_SIZE];
  BYTE  lpBlackLastScanLine[SCANLINE_BUFFER_SIZE];
  UINT	fColor;
} VLASERDV, FAR *LPVLASERDV;


BOOL MiniDrvEnablePDEV(LPDV lpdv, ULONG *pdevcaps)
{
    lpdv->fMdv = FALSE;
    if (!(lpdv->lpMdv = UniDrvAllocMem(sizeof(VLASERDV))))
         return FALSE;

    lpdv->fMdv = TRUE;
	((LPVLASERDV)lpdv->lpMdv)->bFirst = FALSE;
	((LPVLASERDV)lpdv->lpMdv)->wCyanLastScanLineLen = 0;
	((LPVLASERDV)lpdv->lpMdv)->wMagentaLastScanLineLen = 0;
	((LPVLASERDV)lpdv->lpMdv)->wYellowLastScanLineLen = 0;
	((LPVLASERDV)lpdv->lpMdv)->wBlackLastScanLineLen = 0;

    return TRUE;
}


VOID MiniDrvDisablePDEV(LPDV lpdv)
{
    if (lpdv->fMdv)
    {
        UniDrvFreeMem(lpdv->lpMdv);
        lpdv->fMdv = FALSE;
    }
}


VOID FAR PASCAL fnOEMOutputCmd(LPDV lpdv, WORD wCmdCbId, PDWORD lpdwParams)
{
	DWORD  i, nYMove;
	BYTE  cYMoveCommand[ALL_COLOR_Y_MOVE_CMD_LEN];
	LPBYTE lpBuf;
	
	switch (wCmdCbId) // StartPage
	{
		case 1:	// StartPage
				WriteSpoolBuf(lpdv, "\x1B}0;0;6B", 8);
				((LPVLASERDV)lpdv->lpMdv)->bFirst = TRUE;
				break;
		case 2: // AbortDoc
				lpBuf = UniDrvAllocMem(256);
				ZeroMemory(lpBuf, 256);
				WriteSpoolBuf(lpdv, lpBuf, 256);
				WriteSpoolBuf(lpdv, "\001\001\003\014\033}0D\0331S", 10);
				UniDrvFreeMem(lpBuf);
				break;
		case 100: ((LPVLASERDV)lpdv->lpMdv)->fColor = CC_CYAN; break;
		case 101: ((LPVLASERDV)lpdv->lpMdv)->fColor = CC_MAGENTA; break;
		case 102: ((LPVLASERDV)lpdv->lpMdv)->fColor = CC_YELLOW; break;
		case 103: ((LPVLASERDV)lpdv->lpMdv)->fColor = CC_BLACK; break;
		case 150:	for (nYMove = *lpdwParams; nYMove > 255; nYMove -= 255) // 0xFF
					{
						WriteSpoolBuf(lpdv, (LPBYTE)
							"\x04\x00\xFF\x05\x00\xFF\x06\x00\xFF\x07\x00\xFF",
							ALL_COLOR_Y_MOVE_CMD_LEN);
					}
					if (nYMove > 0)
					{
						cYMoveCommand[0] = 0x04;
						cYMoveCommand[1] = 0;
						cYMoveCommand[2] = (BYTE) nYMove;
						cYMoveCommand[3] = 0x05;
						cYMoveCommand[4] = 0;
						cYMoveCommand[5] = (BYTE) nYMove;
						cYMoveCommand[6] = 0x06;
						cYMoveCommand[7] = 0;
						cYMoveCommand[8] = (BYTE) nYMove;
						cYMoveCommand[9] = 0x07;
						cYMoveCommand[10] = 0;
						cYMoveCommand[11] = (BYTE) nYMove;
						WriteSpoolBuf(lpdv, (LPBYTE) cYMoveCommand,
										ALL_COLOR_Y_MOVE_CMD_LEN);
					}
    				break;
		default: ;
	}
}


WORD FAR PASCAL CBFilterGraphics(LPDV lpdv, LPBYTE lpBuf, WORD wLen)
{
	WORD  wLastScanLineLen;
	LPBYTE  lpLastScanLine;
	BYTE  CompressedScanLine[SCANLINE_BUFFER_SIZE];
	BYTE  HeaderColorPlain;
	BYTE  HeaderScanLine[3];
	WORD  nCompBufLen;
	LPVLASERDV  lpQDV = lpdv->lpMdv;

	if (lpQDV->bFirst)
	{
		ZeroMemory(lpQDV->lpCyanLastScanLine, (WORD)SCANLINE_BUFFER_SIZE);
		ZeroMemory(lpQDV->lpMagentaLastScanLine, (WORD)SCANLINE_BUFFER_SIZE);
		ZeroMemory(lpQDV->lpYellowLastScanLine, (WORD)SCANLINE_BUFFER_SIZE);
		ZeroMemory(lpQDV->lpBlackLastScanLine, (WORD)SCANLINE_BUFFER_SIZE);
		lpQDV->bFirst = FALSE;
	}
	
	switch (lpQDV->fColor)
	{
		case CC_CYAN:
			HeaderColorPlain = 0x05;
			wLastScanLineLen = lpQDV->wCyanLastScanLineLen;
			lpLastScanLine = (LPBYTE) lpQDV->lpCyanLastScanLine;
			break;
		case CC_MAGENTA:
			HeaderColorPlain = 0x06;
			wLastScanLineLen = lpQDV->wMagentaLastScanLineLen;
			lpLastScanLine = (LPBYTE) lpQDV->lpMagentaLastScanLine;
			break;
		case CC_YELLOW:
			HeaderColorPlain = 0x07;
			wLastScanLineLen = lpQDV->wYellowLastScanLineLen;
			lpLastScanLine = (LPBYTE) lpQDV->lpYellowLastScanLine;
			break;
		case CC_BLACK:
			HeaderColorPlain = 0x04;
			wLastScanLineLen = lpQDV->wBlackLastScanLineLen;
			lpLastScanLine = (LPBYTE) lpQDV->lpBlackLastScanLine;
			break;
		default:	// Black&White mode
			HeaderColorPlain = 0x04;
			wLastScanLineLen = lpQDV->wBlackLastScanLineLen;
			lpLastScanLine = (LPBYTE) lpQDV->lpBlackLastScanLine;
	}
	
	nCompBufLen = B2Compress(lpLastScanLine, lpBuf,
					CompressedScanLine, (wLastScanLineLen > wLen)
					? wLastScanLineLen : wLen);
	
	// send color plain command				
	WriteSpoolBuf(lpdv, (LPBYTE) &HeaderColorPlain, 1);
	
	if (nCompBufLen == 0)  // same two line
	{
		WriteSpoolBuf(lpdv, (LPBYTE) "\x01", 1);
	}
	else
	{
		HeaderScanLine[0] = 0x02;
		HeaderScanLine[1] = (BYTE) (nCompBufLen >> 8);
		HeaderScanLine[2] = (BYTE) nCompBufLen;
		WriteSpoolBuf(lpdv, (LPBYTE) HeaderScanLine, 3);
		WriteSpoolBuf(lpdv, (LPBYTE) CompressedScanLine, nCompBufLen);
		switch (((LPVLASERDV)lpdv->lpMdv)->fColor)
		{
			case CC_CYAN:	 lpQDV->wCyanLastScanLineLen = wLen;  break;
			case CC_MAGENTA: lpQDV->wMagentaLastScanLineLen = wLen;  break;
			case CC_YELLOW:	 lpQDV->wYellowLastScanLineLen = wLen;  break;
			case CC_BLACK:	 lpQDV->wBlackLastScanLineLen = wLen;  break;
			default:  lpQDV->wBlackLastScanLineLen = wLen; // Black&White mode
		}
	}
	
    return nCompBufLen;
}


DRVFN  MiniDrvFnTab[] =
{
    {  INDEX_MiniDrvEnablePDEV,    (PFN)MiniDrvEnablePDEV  },
    {  INDEX_MiniDrvDisablePDEV,   (PFN)MiniDrvDisablePDEV  },
    {  INDEX_OEMOutputCmd,         (PFN)fnOEMOutputCmd  },
    {  INDEX_OEMWriteSpoolBuf,     (PFN)CBFilterGraphics  },
};


BOOL MiniDrvEnableDriver(MINIDRVENABLEDATA *pEnableData)
{
    if (pEnableData == NULL)
        return FALSE;

    if (pEnableData->cbSize == 0)
    {
        pEnableData->cbSize = sizeof (MINIDRVENABLEDATA);
        return TRUE;
    }

    if (pEnableData->cbSize < sizeof (MINIDRVENABLEDATA)
            || HIBYTE(pEnableData->DriverVersion)
            < HIBYTE(MDI_DRIVER_VERSION))
    {
        // Wrong size and/or mismatched version
        return FALSE;
    }

    // Load callbacks provided by the Unidriver
    if (!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvWriteSpoolBuf, (PFN *) &WriteSpoolBuf)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvAllocMem, (PFN *) &UniDrvAllocMem)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvFreeMem, (PFN *) &UniDrvFreeMem))
    {
        return FALSE;
    }

    pEnableData->cMiniDrvFn
        = sizeof (MiniDrvFnTab) / sizeof(MiniDrvFnTab[0]);
    pEnableData->pMiniDrvFn = MiniDrvFnTab;

    return TRUE;
}

//
//  Block Image 2 Compression
//
WORD B2Compress(LPBYTE pLastScanLine, LPBYTE pCurrentScanLine, LPBYTE pPrnBuf, WORD nImageWidth)
{
    LPBYTE  pLast, pCurrent, pComp;
    LPBYTE  pByteNum, pCountByte;
	WORD  i;
	BYTE  nSameCount, nDiffCount;
	BOOL  bSame = TRUE;

    pLast = pLastScanLine;
    pCurrent = pCurrentScanLine;
    pComp = pPrnBuf;

    pByteNum = pComp;
    nSameCount = 0;
    nDiffCount = 0;
    pCountByte = pComp++;

    for(i=0; i < nImageWidth; i++) {
        if(*pCurrent != *pLast) {
        	bSame = FALSE;
            nDiffCount++;
            if(nSameCount) {
                *pCountByte = nSameCount;
                pCountByte = pComp++;
                nSameCount = 0;
            }
            if(nDiffCount > 127) {
                *pCountByte = 127 + 128;
                pComp = RLE_comp(pCountByte);
                pCountByte = pComp++;
                nDiffCount -= 127;
            }
            *pLast = *pCurrent;
            *pComp++ = *pCurrent;
        } else {
            nSameCount++;
            if(nDiffCount) {
                *pCountByte = nDiffCount + 128;
                pComp = RLE_comp(pCountByte);
                pCountByte = pComp++;
                nDiffCount = 0;
            }
            if(nSameCount > 127) {
                *pCountByte = 127;
                pCountByte = pComp++;
                nSameCount -= 127;
            }
        }
        pCurrent++;
        pLast++;
    }  // end of for loop
    
    if(nSameCount) *pCountByte = nSameCount;
    if(nDiffCount) {
        *pCountByte = nDiffCount+128;
        pComp = RLE_comp(pCountByte);
    }
    
//    if (bSame)
//    	return((WORD) 0);
//    else
	    return((WORD) (pComp - pByteNum));
}

LPBYTE RLE_comp(LPBYTE p)
{
	WORD  i, count, RLEEncodedCount;
    LPBYTE  p1;
	BYTE  RLEBuffer[SCANLINE_BUFFER_SIZE];
            
    count = (WORD) (*p - 128);
	if(count > 4) {
		RLEEncodedCount = RLEencoding(p+1, (LPBYTE) RLEBuffer, count);
		if(RLEEncodedCount < count) {
			*p++ = 0;	// RLE encode indicator
			*p++ = (BYTE) RLEEncodedCount;
			p1 = RLEBuffer;
			for(i=0; i<RLEEncodedCount; i++) {
				*p++ = *p1++;
			}
			return(p);
		}
	}
	return(p+1+count);
}

WORD RLEencoding(LPBYTE pCurrent, LPBYTE pComp, WORD count)
{
	WORD	i, nByteNum;
    BYTE	curr, next, RLEcount;

	nByteNum = 0;
	RLEcount = 1;
	for(i=0; i<count-1; i++) {
		curr = *pCurrent++;
		next = *pCurrent;
		if(curr == next) {
			if(RLEcount == 255) {
				*pComp++ = RLEcount;
                *pComp++ = curr;
				nByteNum += 2;
				RLEcount = 1;
			} else {
				RLEcount++;
			} 
		} else {
			*pComp++ = RLEcount;
            *pComp++ = curr;
			nByteNum += 2;
			RLEcount = 1;
		}
	}
	*pComp++ = RLEcount;
    *pComp++ = next;
	nByteNum += 2;

	return(nByteNum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafres\fcommon.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           FCOMMON.C

Abstract:       This includes the common functions file for rendering & UI plugin module.

Environment:    Windows NT Unidrv5 driver

Revision History:
    02/29/2000 -Masatoshi Kubokura-
        Created it.
    05/31/2000 -Masatoshi Kubokura-
        V.1.11

--*/

#include "COMMON.C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafres\comoem.cpp ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           COMOEM.CPP

Abstract:       Necessary COM class definition to Unidrv OEM rendering plugin module.

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/24/1998 -takashim-
        Written the original sample so that it is more C++.
    02/29/2000 -Masatoshi Kubokura-
        Modified for PCL5e plugin from RPDL code.
    11/13/2001 -Masatoshi Kubokura-
        Last Modified for XP inbox.
    02/26/2002 -Masatoshi Kubokura-
        Include strsafe.h.
    03/29/2002 -Masatoshi Kubokura-
        Check NULL pointer at QueryInterface(), EnablePDEV(), and CommandCallback().

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"
#ifndef WINNT_40
#include "strsafe.h"        // @Feb/26/2002
#endif // !WINNT_40

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
// @Mar/29/2002 ->
        if (NULL == ppv)
            return E_FAIL;
// @Mar/29/2002 <-
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
//      return E_NOTIMPL;

        OEMEnableDriver(dwDriverVersion, cbSize, pded);

        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
//      return E_NOTIMPL;
        OEMDisableDriver();
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
//      return E_NOTIMPL;
        PDEVOEM pTemp;

// @Mar/29/2002 ->
        if (NULL == pDevOem)
            return E_FAIL;
// @Mar/29/2002 <-

        pTemp = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,  phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

        if (NULL == pTemp)
            return E_FAIL;

        //
        // Save necessary helpder function addresses.
        //
//        ((MINIDEV *)pTemp)->pIntf = this->pOEMHelp;

        *pDevOem = pTemp;
        return S_OK;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
//      return E_NOTIMPL;
        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
// @Mar/26/2002 (MS) ->
//         else
//             return S_FALSE;
        else
            return E_FAIL;
// @Mar/26/2002 <-
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));

        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
//          pIUnknown->AddRef();
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void**)&(this->pOEMHelp));
            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;
                return E_FAIL;
            }
        }
//      this->pOEMHelp = reinterpret_cast<IPrintOemDriverUni*>(pIUnknown);
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
// @Mar/29/2002 ->
        if (NULL == piResult)
            return E_FAIL;
// @Mar/29/2002 <-
        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);
        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
#ifdef WINNT_40     // @Nov/13/2001
        return E_NOTIMPL;
#else  // !WINNT_40
// @Sep/28/2001 ->
        if (OEMHalftonePattern(pdevobj, pHTPattern, dwHTPatternX, dwHTPatternY,
                               dwHTNumPatterns, dwCallbackID, pResource, dwResourceSize))
            return S_OK;
        else
            return E_FAIL;
// @Sep/28/2001 <-
#endif // !WINNT_40
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
// @Mar/26/2002 (MS) ->
//         return E_FAIL;
        return S_FALSE;
// @Mar/26/2002 <-
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

/*++

Copyright (c) 1996-2001  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           PDEV.H

Abstract:       Header file for OEM rendering plugin.

Environment:    Windows NT Unidrv5 driver

Revision History:
    02/25/2000 -Masatoshi Kubokura-
        Created it.
    10/11/2000 -Masatoshi Kubokura-
        Last modified for Whistler.

--*/


//
// Files necessary for OEM plugin.
//

#include <minidrv.h>
#include <stdio.h>
#include "devmode.h"
#include "oem.h"
#include "resource.h"

//
// Misc definitions follows.
//

#ifdef DLLTEXT
#undef DLLTEXT
#endif // ifdef DLLTEXT
#define DLLTEXT(s)      "RENDER: " s

// ASSERT(VALID_PDEVOBJ) can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

////////////////////////////////////////////////////////
// DDI hooks
// Warning: the following enum order must match the
//          order in OEMHookFuncs[] in DDI.C.
////////////////////////////////////////////////////////
#ifdef DDIHOOK
enum {
//  UD_DrvRealizeBrush,
//  UD_DrvDitherColor,
//  UD_DrvCopyBits,
//  UD_DrvBitBlt,
//  UD_DrvStretchBlt,
//  UD_DrvStretchBltROP,
//  UD_DrvPlgBlt,
//  UD_DrvTransparentBlt,
//  UD_DrvAlphaBlend,
//  UD_DrvGradientFill,
//  UD_DrvTextOut,
//  UD_DrvStrokePath,
//  UD_DrvFillPath,
//  UD_DrvStrokeAndFillPath,
//  UD_DrvPaint,
//  UD_DrvLineTo,
//  UD_DrvStartPage,
//  UD_DrvSendPage,
//  UD_DrvEscape,
    UD_DrvStartDoc,
//  UD_DrvEndDoc,
//  UD_DrvNextBand,
//  UD_DrvStartBanding,
//  UD_DrvQueryFont,
//  UD_DrvQueryFontTree,
//  UD_DrvQueryFontData,
//  UD_DrvQueryAdvanceWidths,
//  UD_DrvFontManagement,
//  UD_DrvGetGlyphMode,

    MAX_DDI_HOOKS,
};
#endif // DDIHOOK

#define JOBNAMESIZE         224

// rendering plugin device data
typedef struct _OEMPDEV {
    DWORD   fGeneral;                   // bit flags for general status
    BYTE    JobName[(JOBNAMESIZE*2)];   // for CharToOemBuff().
#ifdef DDIHOOK
    PFN     pfnUnidrv[MAX_DDI_HOOKS];   // Unidrv's hook function pointer
#endif // DDIHOOK
} OEMPDEV, *POEMPDEV;

// PCL Command callback IDs
#define CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF    1
#define CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON     2
#define CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF    3
#define CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON     4
#define CMD_ENDJOB_P5                           5
#define CMD_ENDJOB_P6                           6
#define CMD_STARTJOB_AUTOTRAYCHANGE_OFF         7
#define CMD_STARTJOB_AUTOTRAYCHANGE_ON          8
#define CMD_COLLATE_JOBOFFSET_OFF               9
#define CMD_COLLATE_JOBOFFSET_ROTATE            10
#define CMD_COLLATE_JOBOFFSET_SHIFT             11
#define CMD_COPIES_P5                           12
#define CMD_ENDPAGE_P6                          13
#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafres\ddi.c ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           DDI.C

Abstract:       Implementation of OEM DDI exports & OEM DDI hooks.

Functions:      OEMEnablePDEV
                OEMDisablePDEV
                OEMResetPDEV
                OEMEnableDriver
                OEMDisableDriver
                OEMxxx (DDI hooks)

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/1997 -zhanw-
        Created it.
    02/29/2000 -Masatoshi Kubokura-
        Modified for PCL5e/PScript plugin from RPDL code.
    03/15/2000 -Masatoshi Kubokura-
        V.1.11
    08/01/2000 -Masatoshi Kubokura-
        Modified for NT4
    09/07/2000 -Masatoshi Kubokura-
        Last Modified for XP inbox.
    02/26/2002 -Masatoshi Kubokura-
        Include strsafe.h.

--*/

#include <ctype.h>
#include "pdev.h"
#ifndef WINNT_40
#include "strsafe.h"        // @Feb/26/2002
#endif // !WINNT_40

#ifdef DDIHOOK
static const DRVFN OEMHookFuncs[] =
{
//  { INDEX_DrvRealizeBrush,        (PFN) OEMRealizeBrush        },
//  { INDEX_DrvDitherColor,         (PFN) OEMDitherColor         },
//  { INDEX_DrvCopyBits,            (PFN) OEMCopyBits            },
//  { INDEX_DrvBitBlt,              (PFN) OEMBitBlt              },
//  { INDEX_DrvStretchBlt,          (PFN) OEMStretchBlt          },
//  { INDEX_DrvStretchBltROP,       (PFN) OEMStretchBltROP       },
//  { INDEX_DrvPlgBlt,              (PFN) OEMPlgBlt              },
//  { INDEX_DrvTransparentBlt,      (PFN) OEMTransparentBlt      },
//  { INDEX_DrvAlphaBlend,          (PFN) OEMAlphaBlend          },
//  { INDEX_DrvGradientFill,        (PFN) OEMGradientFill        },
//  { INDEX_DrvTextOut,             (PFN) OEMTextOut             },
//  { INDEX_DrvStrokePath,          (PFN) OEMStrokePath          },
//  { INDEX_DrvFillPath,            (PFN) OEMFillPath            },
//  { INDEX_DrvStrokeAndFillPath,   (PFN) OEMStrokeAndFillPath   },
//  { INDEX_DrvPaint,               (PFN) OEMPaint               },
//  { INDEX_DrvLineTo,              (PFN) OEMLineTo              },
//  { INDEX_DrvStartPage,           (PFN) OEMStartPage           },
//  { INDEX_DrvSendPage,            (PFN) OEMSendPage            },
//  { INDEX_DrvEscape,              (PFN) OEMEscape              },
    { INDEX_DrvStartDoc,            (PFN) OEMStartDoc            }
//, { INDEX_DrvEndDoc,              (PFN) OEMEndDoc              },
//  { INDEX_DrvNextBand,            (PFN) OEMNextBand            },
//  { INDEX_DrvStartBanding,        (PFN) OEMStartBanding        },
//  { INDEX_DrvQueryFont,           (PFN) OEMQueryFont           },
//  { INDEX_DrvQueryFontTree,       (PFN) OEMQueryFontTree       },
//  { INDEX_DrvQueryFontData,       (PFN) OEMQueryFontData       },
//  { INDEX_DrvQueryAdvanceWidths,  (PFN) OEMQueryAdvanceWidths  },
//  { INDEX_DrvFontManagement,      (PFN) OEMFontManagement      },
//  { INDEX_DrvGetGlyphMode,        (PFN) OEMGetGlyphMode        }
};
#endif // DDIHOOK


PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)       // Unidrv's hook table
{
    POEMPDEV    poempdev;
    INT         i, j;
    PFN         pfn;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    VERBOSE(("OEMEnablePDEV() entry.\n"));

    // Allocate the OEMPDEV
    if (!(poempdev = MemAlloc(sizeof(OEMPDEV))))
        return NULL;

    // Initialize OEMPDEV
//  poempdev->fGeneral = 0;

#ifdef DDIHOOK
    // Fill Unidrv's hooks in OEMPDEV
    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        // search through Unidrv's hooks and locate the function ptr
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnUnidrv[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            poempdev->pfnUnidrv[i] = NULL;
        }
    }
#endif // DDIHOOK
    return (POEMPDEV) poempdev;
} //*** OEMEnablePDEV


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    VERBOSE(("OEMDisablePDEV() entry.\n"));

    // free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    MemFree(MINIDEV_DATA(pdevobj));
} //*** OEMDisablePDEV


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    POEMPDEV    poempdevOld = MINIDEV_DATA(pdevobjOld);
    POEMPDEV    poempdevNew = MINIDEV_DATA(pdevobjNew);

    VERBOSE(("OEMResetPDEV() entry.\n"));

    if (poempdevOld && poempdevNew)
    {
        LPBYTE      pSrc = (LPBYTE)poempdevOld;
        LPBYTE      pDst = (LPBYTE)poempdevNew;
        DWORD       dwCount = sizeof(OEMPDEV);

        // carry over from old OEMPDEV to new OEMPDEV
        while (dwCount-- > 0)
            *pDst++ = *pSrc++;

        // set pointers of old OEMPDEV to NULL not to free memory
//        poempdevOld->pRPDLHeap2K = NULL;
    }
    return TRUE;
} //*** OEMResetPDEV


VOID APIENTRY OEMDisableDriver()
{
        VERBOSE(("OEMDisableDriver() entry.\n"));
} //*** OEMDisableDriver


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    // VERBOSE(("OEMEnableDriver() entry.\n"));

    // Validate paramters.
    if( (PRINTER_OEMINTF_VERSION != dwOEMintfVersion)
        ||
        (sizeof(DRVENABLEDATA) > dwSize)
        ||
        (NULL == pded)
      )
    {
        //  DbgPrint(ERRORTEXT("OEMEnableDriver() ERROR_INVALID_PARAMETER.\n"));

        return FALSE;
    }

    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION ; //   not  DDI_DRIVER_VERSION;
#ifdef DDIHOOK
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) OEMHookFuncs;
#else
    pded->c = 0;
    pded->pdrvfn = NULL;
#endif // DDIHOOK


    return TRUE;
} //*** OEMEnableDriver


#ifdef DDIHOOK
//
// DDI hooks
//
BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);
    INT         iLen;

#if DBG
    // You can see debug messages on debugger terminal. (debug mode boot)
    giDebugLevel = DBG_VERBOSE;

    // You can debug with MS Visual Studio. (normal mode boot)
//    DebugBreak();
#endif // DBG

    VERBOSE(("OEMStartDoc() entry.\n"));
    VERBOSE(("  DocName=%ls\n", pwszDocName));

#ifdef WINNT_40     // @Aug/01/2000
    if (pwszDocName)
    {
        USHORT OemCodePage, AnsiCodePage;

        EngGetCurrentCodePage(&OemCodePage, &AnsiCodePage);
        EngWideCharToMultiByte((UINT)AnsiCodePage, (LPWSTR)pwszDocName,
                               (INT)(JOBNAMESIZE * sizeof(WCHAR)),
                               (LPSTR)poempdev->JobName, (INT)JOBNAMESIZE);
    }
#else  // !WINNT_40
    if (pwszDocName)
        CharToOemBuff((LPWSTR)pwszDocName, (LPSTR)poempdev->JobName, JOBNAMESIZE);
#endif // !WINNT_40
#if DBG
    giDebugLevel = DBG_ERROR;
#endif // DBG

    return (((PFN_DrvStartDoc)(poempdev->pfnUnidrv[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));
} //*** OEMStartDoc

#if 0
BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoTrg->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMBitBlt() entry.\n"));

    //
    // turn around to call Unidrv
    //
    return (((PFN_DrvBitBlt)(poempdev->pfnUnidrv[UD_DrvBitBlt])) (
           psoTrg,
           psoSrc,
           psoMask,
           pco,
           pxlo,
           prclTrg,
           pptlSrc,
           pptlMask,
           pbo,
           pptlBrush,
           rop4));
} //*** OEMBitBlt


BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStretchBlt() entry.\n"));

    return (((PFN_DrvStretchBlt)(poempdev->pfnUnidrv[UD_DrvStretchBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDst,
            prclSrc,
            pptlMask,
            iMode));
} //*** OEMStretchBlt


BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStretchBltROP() entry.\n"));

    return (((PFN_DrvStretchBltROP)(poempdev->pfnUnidrv[UD_DrvStretchBltROP])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDst,
            prclSrc,
            pptlMask,
            iMode,
            pbo,
            rop4
            ));
} //*** OEMStretchBltROP


BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDst,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDst,
    POINTL         *pptlSrc)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMCopyBits() entry.\n"));

    return (((PFN_DrvCopyBits)(poempdev->pfnUnidrv[UD_DrvCopyBits])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            pptlSrc));
} //*** OEMCopyBits


BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMPlgBlt() entry.\n"));

    return (((PFN_DrvPlgBlt)(poempdev->pfnUnidrv[UD_DrvPlgBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlBrushOrg,
            pptfixDst,
            prclSrc,
            pptlMask,
            iMode));
} //*** OEMPlgBlt


BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMAlphaBlend() entry.\n"));

    return (((PFN_DrvAlphaBlend)(poempdev->pfnUnidrv[UD_DrvAlphaBlend])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            pBlendObj
            ));
} //*** OEMAlphaBlend


BOOL APIENTRY
OEMGradientFill(
    SURFOBJ    *psoDst,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMGradientFill() entry.\n"));

    return (((PFN_DrvGradientFill)(poempdev->pfnUnidrv[UD_DrvGradientFill])) (
            psoDst,
            pco,
            pxlo,
            pVertex,
            nVertex,
            pMesh,
            nMesh,
            prclExtents,
            pptlDitherOrg,
            ulMode
            ));
} //*** OEMGradientFill


BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMTextOut() entry.\n"));

    return (((PFN_DrvTextOut)(poempdev->pfnUnidrv[UD_DrvTextOut])) (
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix));
} //*** OEMTextOut


BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStokePath() entry.\n"));

    return (((PFN_DrvStrokePath)(poempdev->pfnUnidrv[UD_DrvStrokePath])) (
            pso,
            ppo,
            pco,
            pxo,
            pbo,
            pptlBrushOrg,
            plineattrs,
            mix));
} //*** OEMStrokePath


BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMFillPath() entry.\n"));

    return (((PFN_DrvFillPath)(poempdev->pfnUnidrv[UD_DrvFillPath])) (
            pso,
            ppo,
            pco,
            pbo,
            pptlBrushOrg,
            mix,
            flOptions));
} //*** OEMFillPath


BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStrokeAndFillPath() entry.\n"));

    return (((PFN_DrvStrokeAndFillPath)(poempdev->pfnUnidrv[UD_DrvStrokeAndFillPath])) (
            pso,
            ppo,
            pco,
            pxo,
            pboStroke,
            plineattrs,
            pboFill,
            pptlBrushOrg,
            mixFill,
            flOptions));
} //*** OEMStrokeAndFillPath


BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoTarget->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStrokeAndFillPath() entry.\n"));

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into Unidrv since Unidrv doesn't hook it.
    //

    //
    // In this test DLL, the drawing hooks does not call EngRealizeBrush. So this
    // this function will never be called. Do nothing.
    //

    return TRUE;
} //*** OEMRealizeBrush


BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStartPage() entry.\n"));

    return (((PFN_DrvStartPage)(poempdev->pfnUnidrv[UD_DrvStartPage]))(pso));
} //*** OEMStartPage


#define OEM_TESTSTRING  "The DDICMDCB DLL adds this line of text."

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEndPage() entry.\n"));

#if 0
    //
    // print a line of text, just for testing
    //
    if (pso->iType == STYPE_BITMAP)
    {
        pdevobj->pDrvProcs->DrvXMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvYMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, OEM_TESTSTRING,
                                             sizeof(OEM_TESTSTRING));
    }
#endif

    return (((PFN_DrvSendPage)(poempdev->pfnUnidrv[UD_DrvSendPage]))(pso));
} //*** OEMSendPage


ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEscape() entry.\n"));

    return (((PFN_DrvEscape)(poempdev->pfnUnidrv[UD_DrvEscape])) (
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut));
} //*** OEMEscape


BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEndDoc() entry.\n"));

    return (((PFN_DrvEndDoc)(poempdev->pfnUnidrv[UD_DrvEndDoc])) (
            pso,
            fl));
} //*** OEMEndDoc


////////
// NOTE:
// OEM DLL needs to hook out the following six font related DDI calls only
// if it enumerates additional fonts beyond what's in the GPD file.
// And if it does, it needs to take care of its own fonts for all font DDI
// calls and DrvTextOut call.
///////

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG_PTR  *pid)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFont() entry.\n"));

    return (((PFN_DrvQueryFont)(poempdev->pfnUnidrv[UD_DrvQueryFont])) (
            dhpdev,
            iFile,
            iFace,
            pid));
} //*** OEMQueryFont


PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR  *pid)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFontTree() entry.\n"));

    return (((PFN_DrvQueryFontTree)(poempdev->pfnUnidrv[UD_DrvQueryFontTree])) (
            dhpdev,
            iFile,
            iFace,
            iMode,
            pid));
} //*** OEMQueryFontTree


LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFontData() entry.\n"));

    return (((PFN_DrvQueryFontData)(poempdev->pfnUnidrv[UD_DrvQueryFontData])) (
            dhpdev,
            pfo,
            iMode,
            hg,
            pgd,
            pv,
            cjSize));
} //*** OEMQueryFontData


BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryAdvanceWidths() entry.\n"));

    return (((PFN_DrvQueryAdvanceWidths)
             (poempdev->pfnUnidrv[UD_DrvQueryAdvanceWidths])) (
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs));
} //*** OEMQueryAdvanceWidths


ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut)
{
    //
    // Note that Unidrv will not call OEM DLL for iMode==QUERYESCSUPPORT.
    // So pso is not NULL for sure.
    //
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMFontManagement() entry.\n"));

    return (((PFN_DrvFontManagement)(poempdev->pfnUnidrv[UD_DrvFontManagement])) (
            pso,
            pfo,
            iMode,
            cjIn,
            pvIn,
            cjOut,
            pvOut));
} //*** OEMFontManagement

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMGetGlyphMode() entry.\n"));

    return (((PFN_DrvGetGlyphMode)(poempdev->pfnUnidrv[UD_DrvGetGlyphMode])) (
            dhpdev,
            pfo));
} //*** OEMGetGlyphMode

/////// <- six font related DDI calls


BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMNextBand() entry.\n"));

    return (((PFN_DrvNextBand)(poempdev->pfnUnidrv[UD_DrvNextBand])) (
            pso,
            pptl));
} //*** OEMNextBand


BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStartBanding() entry.\n"));

    return (((PFN_DrvStartBanding)(poempdev->pfnUnidrv[UD_DrvStartBanding])) (
            pso,
            pptl));
} //*** OEMStartBanding


ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMDitherColor() entry.\n"));

    return (((PFN_DrvDitherColor)(poempdev->pfnUnidrv[UD_DrvDitherColor])) (
            dhpdev,
            iMode,
            rgbColor,
            pulDither));
} //*** OEMDitherColor


BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMPaint() entry.\n"));

    return (((PFN_DrvPaint)(poempdev->pfnUnidrv[UD_DrvPaint])) (
            pso,
            pco,
            pbo,
            pptlBrushOrg,
            mix));
} //*** OEMPaint


BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMLineTo() entry.\n"));

    return (((PFN_DrvLineTo)(poempdev->pfnUnidrv[UD_DrvLineTo])) (
            pso,
            pco,
            pbo,
            x1,
            y1,
            x2,
            y2,
            prclBounds,
            mix));
} //*** OEMLineTo


BOOL APIENTRY
OEMTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMTransparentBlt() entry.\n"));

    return (((PFN_DrvTransparentBlt)(poempdev->pfnUnidrv[UD_DrvTransparentBlt])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            iTransColor,
            ulReserved
            ));
} //*** OEMTransparentBlt
#endif // if 0
#endif // DDIHOOK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",        // This disables other compression.
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
    "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafres\riafres.c ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           RIAFRES.C

Abstract:       Main file for OEM rendering plugin module.

Functions:      OEMCommandCallback
                OEMHalftonePattern

Environment:    Windows NT Unidrv5 driver

Revision History:
    02/25/2000 -Masatoshi Kubokura-
        Created it.
    06/07/2000 -Masatoshi Kubokura-
        V.1.11
    08/02/2000 -Masatoshi Kubokura-
        V.1.11 for NT4
    10/17/2000 -Masatoshi Kubokura-
        Last modified for XP inbox.
    09/28/2001 -Masatoshi Kubokura-
        Implement OEMHalftonePattern
    03/01/2002 -Masatoshi Kubokura-
        Include strsafe.h.
        Add FileNameBufSize as arg3 at RWFileData().
        Use safe_sprintfA() instead of sprintf().
    03/29/2002 -Masatoshi Kubokura-
        Check pdevobj NULL pointer before using at OEMCommandCallback().
    04/02/2002 -Masatoshi Kubokura-
        Use safe_strlenA() instead of strlen().

--*/

#include "pdev.h"
#ifndef WINNT_40
#include "strsafe.h"        // @Feb/26/2002
#endif // !WINNT_40

//
// Misc definitions and declarations.
//
#ifndef WINNT_40
#define strcmp      lstrcmpA
//#define sprintf     wsprintfA
//#define strlen      lstrlenA    // @Aug/01/2000
#endif // !WINNT_40

// external prototypes
// @Feb/26/2002 ->
//extern BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG type);
extern BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG FileNameBufSize, LONG type);
// @Feb/26/2002 <-

// command definition
static BYTE PJL_PROOFJOB[]       = "@PJL PROOFJOB\n";
static BYTE PJL_SECUREJOB[]      = "@PJL SECUREJOB\n";  // Aficio AP3200 and later (GW model)
static BYTE PJL_DISKIMAGE_OFF[]  = "@PJL SET DISKIMAGE=OFF\n";
static BYTE PJL_DISKIMAGE_PORT[] = "@PJL SET DISKIMAGE=PORTRAIT\n";
static BYTE PJL_DISKIMAGE_LAND[] = "@PJL SET DISKIMAGE=LANDSCAPE\n";
static BYTE PJL_ORIENT_PORT[]    = "@PJL SET ORIENTATION=PORTRAIT\n";
static BYTE PJL_ORIENT_LAND[]    = "@PJL SET ORIENTATION=LANDSCAPE\n";
static BYTE PJL_JOBPASSWORD[]    = "@PJL SET JOBPASSWORD=%s\n";
static BYTE PJL_USERID[]         = "@PJL SET USERID=\x22%s\x22\n";
static BYTE PJL_USERCODE[]       = "@PJL SET USERCODE=\x22%s\x22\n";
static BYTE PJL_TIME_DATE[]      = "@PJL SET TIME=\x22%02d:%02d:%02d\x22\n@PJL SET DATE=\x22%04d/%02d/%02d\x22\n";
static BYTE PJL_STARTJOB_AUTOTRAYCHANGE_OFF[] = "\x1B%%-12345X@PJL JOB NAME=\x22%s\x22\n@PJL SET AUTOTRAYCHANGE=OFF\n";
static BYTE PJL_STARTJOB_AUTOTRAYCHANGE_ON[]  = "\x1B%%-12345X@PJL JOB NAME=\x22%s\x22\n@PJL SET AUTOTRAYCHANGE=ON\n";
static BYTE PJL_ENDJOB[]         = "\x1B%%-12345X@PJL EOJ NAME=\x22%s\x22\n\x1B%%-12345X";
static BYTE PJL_QTY_JOBOFFSET_OFF[]    = "@PJL SET QTY=%d\n@PJL SET JOBOFFSET=OFF\n";
static BYTE PJL_QTY_JOBOFFSET_ROTATE[] = "@PJL SET QTY=%d\n@PJL SET JOBOFFSET=ROTATE\n";
static BYTE PJL_QTY_JOBOFFSET_SHIFT[]  = "@PJL SET QTY=%d\n@PJL SET JOBOFFSET=SHIFT\n";

static BYTE P5_COPIES[]          = "\x1B&l%dX";
static BYTE P6_ENDPAGE[]         = "\xc1%c%c\xf8\x31\x44";
static BYTE P6_ENDSESSION[]      = "\x49\x42";

static BYTE HTPattern_AdonisP3[256] = {
    109,  55,  62, 115, 134, 217, 208, 154, 111,  58,  64, 117, 135, 220, 211, 155,
    103,   2,  22,  69, 160, 226, 248, 199, 104,  10,  26,  72, 163, 228, 251, 201,
     97,  49,  38,  77, 168, 233, 241, 191,  98,  50,  44,  79, 169, 236, 242, 193,
    128,  90,  84, 122, 141, 175, 183, 147, 129,  92,  86, 123, 142, 177, 185, 148,
    139, 224, 215, 158, 112,  59,  66, 119, 137, 222, 213, 157, 114,  60,  67, 120,
    166, 231, 255, 206, 106,  14,  32,  74, 164, 230, 252, 204, 108,  18,  35,  75,
    173, 239, 246, 197, 100,  51,  47,  80, 171, 237, 244, 195, 101,  53,  48,  82,
    145, 181, 189, 152, 131,  93,  87, 124, 144, 179, 186, 150, 132,  95,  89, 126,
    111,  58,  65, 118, 136, 221, 212, 156, 110,  56,  63, 116, 135, 218, 209, 154,
    105,  10,  26,  73, 163, 228, 251, 202, 104,   6,  22,  70, 161, 227, 250, 200,
     99,  50,  44,  79, 170, 236, 243, 194,  98,  49,  41,  78, 168, 234, 242, 192,
    130,  92,  86, 124, 143, 178, 185, 149, 129,  91,  85, 122, 141, 176, 184, 147,
    138, 223, 214, 158, 114,  61,  68, 121, 140, 225, 216, 159, 113,  59,  67, 119,
    165, 230, 253, 205, 109,  18,  35,  76, 167, 232, 255, 207, 107,  14,  32,  74,
    172, 238, 245, 196, 102,  54,  48,  83, 174, 240, 247, 198, 101,  51,  47,  81,
    144, 180, 187, 151, 133,  96,  89, 127, 146, 182, 190, 153, 132,  94,  88, 125
};


INT safe_sprintfA(
    char*   pszDest,
    size_t  cchDest,
    const   char* pszFormat,
    ...)
{
#ifndef WINNT_40
    HRESULT hr;
    char*   pszDestEnd;
    size_t  cchRemaining;
#endif // !WINNT_40
    va_list argList;
    INT     retSize = 0;

    va_start(argList, pszFormat);
#ifndef WINNT_40
    hr = StringCchVPrintfExA(pszDest, cchDest, &pszDestEnd, &cchRemaining,
                             STRSAFE_NO_TRUNCATION, pszFormat, argList);
    if (SUCCEEDED(hr))
        retSize = cchDest - cchRemaining;
#else  // WINNT_40
    if ((retSize = vsprintf(pszDest, pszFormat, argList)) < 0)
        retSize = 0;
#endif // WINNT_40
    va_end(argList);
    return retSize;
} //*** safe_sprintfA


INT safe_strlenA(
    char* psz,
    size_t cchMax)
{
#ifndef WINNT_40
    HRESULT hr;
    size_t  cch = 0;

    hr = StringCchLengthA(psz, cchMax, &cch);
    VERBOSE(("** safe_strlenA: size(lstrlen)=%d **\n", lstrlenA(psz)));
    VERBOSE(("** safe_strlenA: size(StringCchLength)=%d **\n", cch));
    if (SUCCEEDED(hr))
        return cch;
    else
        return 0;
#else  // WINNT_40
    return strlen(psz);
#endif // WINNT_40
} //*** safe_strlenA


INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams)
{
    INT     ocmd;
    BYTE    Cmd[256];
#ifdef WINNT_40     // @Aug/01/2000
    ENG_TIME_FIELDS st;
#else  // !WINNT_40
    SYSTEMTIME  st;
#endif // !WINNT_40
    FILEDATA    FileData;
// @Mar/29/2002 ->
//    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);
//    POEMPDEV         pOEM = MINIDEV_DATA(pdevobj);
    POEMUD_EXTRADATA pOEMExtra;
    POEMPDEV         pOEM;
// @Mar/29/2002 <-
    DWORD       dwCopy;

#if DBG
    // You can see debug messages on debugger terminal. (debug mode boot)
    giDebugLevel = DBG_VERBOSE;

    // You can debug with MS Visual Studio. (normal mode boot)
//    DebugBreak();
#endif // DBG

    VERBOSE(("OEMCommandCallback() entry (%ld).\n", dwCmdCbID));

    // verify pdevobj okay
    ASSERT(VALID_PDEVOBJ(pdevobj));

// @Mar/29/2002 ->
    pOEMExtra = MINIPRIVATE_DM(pdevobj);
    pOEM = MINIDEV_DATA(pdevobj);
// @Mar/29/2002 <-

    // Check whether copy# is in the range.  @Sep/07/2000
    switch (dwCmdCbID)
    {
      case CMD_COLLATE_JOBOFFSET_OFF:
      case CMD_COLLATE_JOBOFFSET_ROTATE:
      case CMD_COLLATE_JOBOFFSET_SHIFT:
      case CMD_COPIES_P5:
      case CMD_ENDPAGE_P6:
        if((dwCopy = *pdwParams) > 999L)        // *pdwParams: NumOfCopies
            dwCopy = 999L;
        else if(dwCopy < 1L)
            dwCopy = 1L;
        break;
    }

    // Emit commands.
    ocmd = 0;
    switch (dwCmdCbID)
    {
      case CMD_STARTJOB_AUTOTRAYCHANGE_OFF:         // Aficio AP3200 and later (GW model)
      case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF:    // Aficio 551,700,850,1050
      case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF:    // Aficio 551,700,850,1050
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_STARTJOB_AUTOTRAYCHANGE_OFF, pOEM->JobName);
        goto _EMIT_JOB_NAME;

      case CMD_STARTJOB_AUTOTRAYCHANGE_ON:          // Aficio AP3200 and later (GW model)
      case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON:     // Aficio 551,700,850,1050
      case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON:     // Aficio 551,700,850,1050
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_STARTJOB_AUTOTRAYCHANGE_ON, pOEM->JobName);

      _EMIT_JOB_NAME:
        // Emit job name
        VERBOSE(("  Start Job=%s\n", Cmd));
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        ocmd = 0;
        switch (pOEMExtra->JobType)
        {
          default:
          case IDC_RADIO_JOB_NORMAL:
            if (CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF == dwCmdCbID ||
                CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON  == dwCmdCbID ||
                CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF == dwCmdCbID ||
                CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON  == dwCmdCbID)
            {
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_DISKIMAGE_OFF);
            }
            if (IDC_RADIO_LOG_ENABLED == pOEMExtra->LogDisabled)
                goto _EMIT_USERID_USERCODE;
            break;

          case IDC_RADIO_JOB_SAMPLE:
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_PROOFJOB);
            if (CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF == dwCmdCbID ||
                CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON  == dwCmdCbID ||
                CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF == dwCmdCbID ||
                CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON  == dwCmdCbID)
            {
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, PJL_DISKIMAGE_OFF);
            }
            goto _CHECK_PRINT_DONE;

          case IDC_RADIO_JOB_SECURE:
            switch (dwCmdCbID)
            {
              case CMD_STARTJOB_AUTOTRAYCHANGE_OFF:         // Aficio AP3200 and later (GW model)
              case CMD_STARTJOB_AUTOTRAYCHANGE_ON:
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_SECUREJOB);
                break;
              case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF:    // Aficio 551,700,850,1050
              case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON:
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_DISKIMAGE_PORT);
                break;
              case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF:    // Aficio 551,700,850,1050
              case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON:
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_DISKIMAGE_LAND);
                break;
            }
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, PJL_JOBPASSWORD, pOEMExtra->PasswordBuf);
          _CHECK_PRINT_DONE:
            // If previous print is finished and hold-options flag isn't valid,
            // do not emit sample-print/secure-print command.
            // This prevents unexpected job until user pushes Apply button on the
            // Job/Log property sheet.
            FileData.fUiOption = 0;
// @Feb/26/2002 ->
//            RWFileData(&FileData, pOEMExtra->SharedFileName, GENERIC_READ);
            RWFileData(&FileData, pOEMExtra->SharedFileName, sizeof(pOEMExtra->SharedFileName), GENERIC_READ);
// @Feb/26/2002 <-
            if (BITTEST32(FileData.fUiOption, PRINT_DONE) &&
                !BITTEST32(pOEMExtra->fUiOption, HOLD_OPTIONS))
            {
                VERBOSE(("** Emit Nothing. **\n"));
                ocmd = 0;
            }
          _EMIT_USERID_USERCODE:
            if (1 <= safe_strlenA(pOEMExtra->UserIdBuf, sizeof(pOEMExtra->UserIdBuf)))
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, PJL_USERID, pOEMExtra->UserIdBuf);
            else
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, PJL_USERID, "?");

            if (1 <= safe_strlenA(pOEMExtra->UserCodeBuf, sizeof(pOEMExtra->UserCodeBuf)))
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, PJL_USERCODE, pOEMExtra->UserCodeBuf);

#ifdef WINNT_40     // @Aug/01/2000
            EngQueryLocalTime(&st); 
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, PJL_TIME_DATE,
                                  st.usHour, st.usMinute, st.usSecond,
                                  st.usYear, st.usMonth, st.usDay);
#else  // !WINNT_40
            GetLocalTime(&st);
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, PJL_TIME_DATE,
                                  st.wHour, st.wMinute, st.wSecond,
                                  st.wYear, st.wMonth, st.wDay);
#endif // !WINNT_40
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            break;
        }
        // Emit orientation (Aficio 551,700,850,1050)
        switch (dwCmdCbID)
        {
          case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_OFF:
          case CMD_STARTJOB_PORT_AUTOTRAYCHANGE_ON:
            WRITESPOOLBUF(pdevobj, PJL_ORIENT_PORT, sizeof(PJL_ORIENT_PORT)-1);
            break;
          case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_OFF:
          case CMD_STARTJOB_LAND_AUTOTRAYCHANGE_ON:
            WRITESPOOLBUF(pdevobj, PJL_ORIENT_LAND, sizeof(PJL_ORIENT_LAND)-1);
            break;
        }
        break;


      case CMD_COLLATE_JOBOFFSET_OFF:           // @Sep/08/2000
        if (IDC_RADIO_JOB_SAMPLE != pOEMExtra->JobType)     // if NOT Sample Print, QTY=1 is emitted here.
            dwCopy = 1L;
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_QTY_JOBOFFSET_OFF, dwCopy);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_COLLATE_JOBOFFSET_ROTATE:        // @Sep/07/2000
        if (IDC_RADIO_JOB_SAMPLE == pOEMExtra->JobType)     // if Sample Print
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_QTY_JOBOFFSET_ROTATE, dwCopy);  // QTY=n is emitted here.
        else
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_QTY_JOBOFFSET_OFF, 1);          // QTY=1 is emitted here.
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_COLLATE_JOBOFFSET_SHIFT:         // @Sep/07/2000
        if (IDC_RADIO_JOB_SAMPLE == pOEMExtra->JobType)     // if Sample Print
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_QTY_JOBOFFSET_SHIFT, dwCopy);   // QTY=n is emitted here.
        else
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_QTY_JOBOFFSET_OFF, 1);          // QTY=1 is emitted here.
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_COPIES_P5:                       // @Sep/07/2000
        if (IDC_RADIO_JOB_SAMPLE == pOEMExtra->JobType)     // if Sample Print (QTY=n was emitted before.)
            dwCopy = 1L;
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), P5_COPIES, dwCopy);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_ENDPAGE_P6:                      // @Sep/07/2000
        if (IDC_RADIO_JOB_SAMPLE == pOEMExtra->JobType)     // if Sample Print (QTY=n was emitted before.)
            dwCopy = 1L;
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), P6_ENDPAGE, (BYTE)dwCopy, (BYTE)(dwCopy >> 8));
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_ENDJOB_P6:                       // @Aug/23/2000
        WRITESPOOLBUF(pdevobj, P6_ENDSESSION, sizeof(P6_ENDSESSION)-1);
        // go through
      case CMD_ENDJOB_P5:
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), PJL_ENDJOB, pOEM->JobName);
        VERBOSE(("  End Job=%s\n", Cmd));
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        switch (pOEMExtra->JobType)
        {
          case IDC_RADIO_JOB_SAMPLE:
          case IDC_RADIO_JOB_SECURE:
            // Set PRINT_DONE flag in the file 
            FileData.fUiOption = pOEMExtra->fUiOption;
            BITSET32(FileData.fUiOption, PRINT_DONE);
// @Feb/26/2002 ->
//            RWFileData(&FileData, pOEMExtra->SharedFileName, GENERIC_WRITE);
            RWFileData(&FileData, pOEMExtra->SharedFileName, sizeof(pOEMExtra->SharedFileName), GENERIC_WRITE);
// @Feb/26/2002 <-
            break;

          default:
            break;
        }
        break;

      default:
        ERR((("Unknown callback ID = %d.\n"), dwCmdCbID));
        break;
    }

#if DBG
    giDebugLevel = DBG_ERROR;
#endif // DBG
    return 0;
} //*** OEMCommandCallback


BOOL APIENTRY OEMHalftonePattern(
    PDEVOBJ pdevobj,
    PBYTE   pHTPattern,
    DWORD   dwHTPatternX,
    DWORD   dwHTPatternY,
    DWORD   dwHTNumPatterns,
    DWORD   dwCallbackID,
    PBYTE   pResource,
    DWORD   dwResourceSize)
{
    PBYTE  pSrc;
    DWORD  dwLen = sizeof(HTPattern_AdonisP3);

#if DBG
    giDebugLevel = DBG_VERBOSE;
#endif // DBG
    VERBOSE(("OEMHalftonePattern() entry (CallbackID:%ld, PatX=%ld).\n", dwCallbackID, dwHTPatternX));

    if (dwLen != (((dwHTPatternX * dwHTPatternY) + 3) / 4) * 4 * dwHTNumPatterns)
        return FALSE;

    pSrc = HTPattern_AdonisP3;
    while (dwLen-- > 0)
        *pHTPattern++ = *pSrc++;

    VERBOSE(("OEMHalftonePattern() exit\n"));
#if DBG
    giDebugLevel = DBG_ERROR;
#endif // DBG
    return TRUE;
} //*** OEMHalftonePattern
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafres\hlp\riafui.hh ===
IDH_Paper_Source=1
IDH_Media_Type=2
IDH_Halftoning=3
IDH_OutputBin=4
IDH_Staple=5
IDH_Punch=6
IDH_Edge_To_Edge_Print=7
IDH_Text_Quality=8
IDH_PrintDensity=9
IDH_SlipSheet=10
IDH_SlipSheet_Paper_Source=11
IDH_Color_Map=12
IDH_Gradation=13
IDH_TextHalftone=14
IDH_GraphicsHalftone=15
IDH_PhotoHalftone=16
IDH_GraphicsMode=17
IDH_Page_Protection=18
IDH_Print_Text_As_Black=19
IDH_Dither=20
IDH_TrueType_Format=21
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

GPDDIR_GS=$(PRNROOT)\gpd\geste\usa
GPDDIR_IF=$(PRNROOT)\gpd\intec\usa
GPDDIR_LR=$(PRNROOT)\gpd\lanie\usa
GPDDIR_NR=$(PRNROOT)\gpd\nrg\usa
GPDDIR_RI=$(PRNROOT)\gpd\ricoh\usa
GPDDIR_SV=$(PRNROOT)\gpd\savin\usa
SRCDIR=..

TARGETNAME=riafres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),riafres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(SRCDIR)\..\riafui;$(PRNROOT)\inc

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\riafres.rc \
    $(SRCDIR)\riafres.c \
    $(SRCDIR)\fcommon.c \
    $(SRCDIR)\ddi.c

MISCFILES=\
    $(GPDDIR_GS)\GS32105.GPD \
    $(GPDDIR_GS)\GS3215S.GPD \
    $(GPDDIR_GS)\GS3218.GPD \
    $(GPDDIR_GS)\GS3222.GPD \
    $(GPDDIR_GS)\GS3227.GPD \
    $(GPDDIR_GS)\GS3235.GPD \
    $(GPDDIR_GS)\GS3235E.GPD \
    $(GPDDIR_GS)\GS3235S.GPD \
    $(GPDDIR_GS)\GS3245.GPD \
    $(GPDDIR_GS)\GS3245E.GPD \
    $(GPDDIR_GS)\GS3255.GPD \
    $(GPDDIR_GS)\GS3265.GPD \
    $(GPDDIR_GS)\GS3285.GPD \
    $(GPDDIR_GS)\GS3355.GPD \
    $(GPDDIR_GS)\GS3370.GPD \
    $(GPDDIR_GS)\GSP7014.GPD \
    $(GPDDIR_GS)\GSP7016.GPD \
    $(GPDDIR_GS)\GSP7020.GPD \
    $(GPDDIR_GS)\GSP7021.GPD \
    $(GPDDIR_GS)\GSP7026.GPD \
    $(GPDDIR_GS)\GSP7026N.GPD \
    $(GPDDIR_GS)\GSP7027.GPD \
    $(GPDDIR_GS)\GSP7032.GPD \
    $(GPDDIR_GS)\GSP7045.GPD \
    $(GPDDIR_IF)\IF4105MF.GPD \
    $(GPDDIR_IF)\IF4150MF.GPD \
    $(GPDDIR_IF)\IF4180MF.GPD \
    $(GPDDIR_IF)\IF4220MF.GPD \
    $(GPDDIR_IF)\IF4270MF.GPD \
    $(GPDDIR_IF)\IF4351MF.GPD \
    $(GPDDIR_IF)\IF4352MF.GPD \
    $(GPDDIR_IF)\IF4451MF.GPD \
    $(GPDDIR_IF)\IF4550MF.GPD \
    $(GPDDIR_IF)\IF4551MF.GPD \
    $(GPDDIR_IF)\IF4651MF.GPD \
    $(GPDDIR_IF)\IF4700MF.GPD \
    $(GPDDIR_IF)\IF4850MF.GPD \
    $(GPDDIR_IF)\IFP320.GPD \
    $(GPDDIR_IF)\IFP450.GPD \
    $(GPDDIR_LR)\LR5218.GPD \
    $(GPDDIR_LR)\LR5222.GPD \
    $(GPDDIR_LR)\LR5227.GPD \
    $(GPDDIR_LR)\LR5235.GPD \
    $(GPDDIR_LR)\LR5245.GPD \
    $(GPDDIR_LR)\LR5255.GPD \
    $(GPDDIR_LR)\LR5265.GPD \
    $(GPDDIR_LR)\LR5435.GPD \
    $(GPDDIR_LR)\LR5445.GPD \
    $(GPDDIR_LR)\LR5455.GPD \
    $(GPDDIR_LR)\LR5470.GPD \
    $(GPDDIR_LR)\LR5485.GPD \
    $(GPDDIR_LR)\LR5505.GPD \
    $(GPDDIR_NR)\NRD4105.GPD \
    $(GPDDIR_NR)\NRD415S.GPD \
    $(GPDDIR_NR)\NRD418.GPD \
    $(GPDDIR_NR)\NRD422.GPD \
    $(GPDDIR_NR)\NRD427.GPD \
    $(GPDDIR_NR)\NRD435.GPD \
    $(GPDDIR_NR)\NRD435S.GPD \
    $(GPDDIR_NR)\NRD445.GPD \
    $(GPDDIR_NR)\NRD455.GPD \
    $(GPDDIR_NR)\NRD465.GPD \
    $(GPDDIR_NR)\NRD485.GPD \
    $(GPDDIR_NR)\NRD555.GPD \
    $(GPDDIR_NR)\NRD570.GPD \
    $(GPDDIR_NR)\NRP7014.GPD \
    $(GPDDIR_NR)\NRP7016.GPD \
    $(GPDDIR_NR)\NRP7020.GPD \
    $(GPDDIR_NR)\NRP7021.GPD \
    $(GPDDIR_NR)\NRP7026.GPD \
    $(GPDDIR_NR)\NRP7026N.GPD \
    $(GPDDIR_NR)\NRP7027.GPD \
    $(GPDDIR_NR)\NRP7032.GPD \
    $(GPDDIR_NR)\NRP7045.GPD \
    $(GPDDIR_RI)\RIAF1050.GPD \
    $(GPDDIR_RI)\RIAF150.GPD \
    $(GPDDIR_RI)\RIAF180.GPD \
    $(GPDDIR_RI)\RIAF18X.GPD \
    $(GPDDIR_RI)\RIAF220.GPD \
    $(GPDDIR_RI)\RIAF270.GPD \
    $(GPDDIR_RI)\RIAF27X.GPD \
    $(GPDDIR_RI)\RIAF340.GPD \
    $(GPDDIR_RI)\RIAF34X.GPD \
    $(GPDDIR_RI)\RIAF350.GPD \
    $(GPDDIR_RI)\RIAF350E.GPD \
    $(GPDDIR_RI)\RIAF35EX.GPD \
    $(GPDDIR_RI)\RIAF35X.GPD \
    $(GPDDIR_RI)\RIAF450.GPD \
    $(GPDDIR_RI)\RIAF450E.GPD \
    $(GPDDIR_RI)\RIAF45EX.GPD \
    $(GPDDIR_RI)\RIAF45X.GPD \
    $(GPDDIR_RI)\RIAF550.GPD \
    $(GPDDIR_RI)\RIAF551.GPD \
    $(GPDDIR_RI)\RIAF5MAC.GPD \
    $(GPDDIR_RI)\RIAF650.GPD \
    $(GPDDIR_RI)\RIAF65X.GPD \
    $(GPDDIR_RI)\RIAF6MAC.GPD \
    $(GPDDIR_RI)\RIAF700.GPD \
    $(GPDDIR_RI)\RIAF70X.GPD \
    $(GPDDIR_RI)\RIAF850.GPD \
    $(GPDDIR_RI)\RIAF85X.GPD \
    $(GPDDIR_RI)\RIAP1400.GPD \
    $(GPDDIR_RI)\RIAP140X.GPD \
    $(GPDDIR_RI)\RIAP1600.GPD \
    $(GPDDIR_RI)\RIAP2000.GPD \
    $(GPDDIR_RI)\RIAP200X.GPD \
    $(GPDDIR_RI)\RIAP2100.GPD \
    $(GPDDIR_RI)\RIAP2600.GPD \
    $(GPDDIR_RI)\RIAP260E.GPD \
    $(GPDDIR_RI)\RIAP260N.GPD \
    $(GPDDIR_RI)\RIAP260X.GPD \
    $(GPDDIR_RI)\RIAP26NE.GPD \
    $(GPDDIR_RI)\RIAP2700.GPD \
    $(GPDDIR_RI)\RIAP270X.GPD \
    $(GPDDIR_RI)\RIAP3200.GPD \
    $(GPDDIR_RI)\RIAP320X.GPD \
    $(GPDDIR_RI)\RIAP4500.GPD \
    $(GPDDIR_RI)\RIAP450X.GPD \
    $(GPDDIR_SV)\SV2015DP.GPD \
    $(GPDDIR_SV)\SV2055DP.GPD \
    $(GPDDIR_SV)\SV2070DP.GPD \
    $(GPDDIR_SV)\SV2085DP.GPD \
    $(GPDDIR_SV)\SV2105DP.GPD \
    $(GPDDIR_SV)\SV9918DP.GPD \
    $(GPDDIR_SV)\SV9922DP.GPD \
    $(GPDDIR_SV)\SV9927DP.GPD \
    $(GPDDIR_SV)\SV9935D.GPD \
    $(GPDDIR_SV)\SV9935DE.GPD \
    $(GPDDIR_SV)\SV9935DP.GPD \
    $(GPDDIR_SV)\SV9945DE.GPD \
    $(GPDDIR_SV)\SV9945DP.GPD \
    $(GPDDIR_SV)\SV9955DP.GPD \
    $(GPDDIR_SV)\SV9965DP.GPD \
    $(GPDDIR_SV)\SVSLP14.GPD \
    $(GPDDIR_SV)\SVSLP16.GPD \
    $(GPDDIR_SV)\SVSLP20.GPD \
    $(GPDDIR_SV)\SVSLP21.GPD \
    $(GPDDIR_SV)\SVSLP26.GPD \
    $(GPDDIR_SV)\SVSLP26N.GPD \
    $(GPDDIR_SV)\SVSLP27.GPD \
    $(GPDDIR_SV)\SVSLP32.GPD \
    $(GPDDIR_SV)\SVSLP45.GPD \
    $(SRCDIR)\riafres1.ini \
    $(SRCDIR)\riafres2.ini \
    $(GPDDIR_GS)\GS6002.GPD \
    $(GPDDIR_GS)\GS60026.GPD \
    $(GPDDIR_GS)\GS7126.GPD \
    $(GPDDIR_GS)\GS71266.GPD \
    $(GPDDIR_GS)\GS7126N.GPD \
    $(GPDDIR_GS)\GS7126N6.GPD \
    $(GPDDIR_GS)\GS7502.GPD \
    $(GPDDIR_GS)\GS75026.GPD \
    $(GPDDIR_GS)\GSC38.GPD \
    $(GPDDIR_IF)\IF2060.GPD \
    $(GPDDIR_IF)\IF20606.GPD \
    $(GPDDIR_IF)\IF2075.GPD \
    $(GPDDIR_IF)\IF20756.GPD \
    $(GPDDIR_IF)\IFC280.GPD \
    $(GPDDIR_LR)\LR060.GPD \
    $(GPDDIR_LR)\LR0606.GPD \
    $(GPDDIR_LR)\LR075.GPD \
    $(GPDDIR_LR)\LR0756.GPD \
    $(GPDDIR_LR)\LR2132.GPD \
    $(GPDDIR_LR)\LRC2138.GPD \
    $(GPDDIR_NR)\NR6002.GPD \
    $(GPDDIR_NR)\NR60026.GPD \
    $(GPDDIR_NR)\NR7126.GPD \
    $(GPDDIR_NR)\NR71266.GPD \
    $(GPDDIR_NR)\NR7126N.GPD \
    $(GPDDIR_NR)\NR7126N6.GPD \
    $(GPDDIR_NR)\NR7502.GPD \
    $(GPDDIR_NR)\NR75026.GPD \
    $(GPDDIR_NR)\NRC38.GPD \
    $(GPDDIR_RI)\RIA1060.GPD \
    $(GPDDIR_RI)\RIA10606.GPD \
    $(GPDDIR_RI)\RIA1075.GPD \
    $(GPDDIR_RI)\RIA10756.GPD \
    $(GPDDIR_RI)\RIA1075X.GPD \
    $(GPDDIR_RI)\RIA2611.GPD \
    $(GPDDIR_RI)\RIA26116.GPD \
    $(GPDDIR_RI)\RIA2612.GPD \
    $(GPDDIR_RI)\RIA26126.GPD \
    $(GPDDIR_RI)\RIA2613.GPD \
    $(GPDDIR_RI)\RIA26136.GPD \
    $(GPDDIR_RI)\RIA2614.GPD \
    $(GPDDIR_RI)\RIA26146.GPD \
    $(GPDDIR_RI)\RIAFCMAC.GPD \
    $(GPDDIR_RI)\RIC3800.GPD \
    $(GPDDIR_RI)\RIC3800X.GPD \
    $(GPDDIR_SV)\SV2560.GPD \
    $(GPDDIR_SV)\SV25606.GPD \
    $(GPDDIR_SV)\SV2575.GPD \
    $(GPDDIR_SV)\SV25756.GPD \
    $(GPDDIR_SV)\SVC38.GPD \
    $(GPDDIR_SV)\SVML26.GPD \
    $(GPDDIR_SV)\SVML266.GPD \
    $(GPDDIR_SV)\SVML26N.GPD \
    $(GPDDIR_SV)\SVML26N6.GPD \
    $(SRCDIR)\hlp\riafui.hlp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafui\common.c ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           COMMON.C

Abstract:       Implementation of common functions for rendering & UI
                plugin module.

Functions:      OEMGetInfo
                OEMDevMode
                RWFileData

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/1997 -zhanw-
        Created it.
    02/29/2000 -Masatoshi Kubokura-
        Modified for PCL5e/PScript plugin from RPDL code.
    05/31/2000 -Masatoshi Kubokura-
        V.1.11
    08/02/2000 -Masatoshi Kubokura-
        V.1.11 for NT4
    09/22/2000 -Masatoshi Kubokura-
        Last modified for XP inbox.
    02/26/2002 -Masatoshi Kubokura-
        Include strsafe.h
        Add FileNameBufSize as arg3 at RWFileData().

--*/

#include <minidrv.h>
#include "devmode.h"
#include "oem.h"
#include "resource.h"
#ifndef WINNT_40
#include "strsafe.h"        // @Feb/26/2002
#endif // !WINNT_40

// shared data file between rendering and UI plugin
#ifndef WINNT_40
#define SHAREDFILENAME          L"RIAF5.BIN"
#else  // WINNT_40
#define SHAREDFILENAME          L"\\2\\RIA%.3ls%02x.BIN"
DWORD gdwDrvMemPoolTag = 'meoD';    // minidrv.h requires this global var
#endif // WINNT_40

#if DBG && !defined(KM_DRIVER)
INT giDebugLevel = DBG_ERROR;
#endif

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
#if DBG
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMGetInfo
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
#if DBG
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));
#endif // DBG

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
} //*** OEMGetInfo


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDevMode
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMDevMode(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
#if DBG
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE((DLLTEXT("OEMDevMode(%s) entry.\n"), OEMDevMode_fMode[dwMode]));
#endif // DBG

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
#if DBG
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
#endif // DBG
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
#if defined(WINNT_40) && defined(DISKLESSMODEL)     // @Aug/02/2000
        // Because NT4 spooler doesn't support collate, we clear dmCollate.
        // Later at OEMUICallBack, if printer collate is available, we set
        // dmCollate.
        pOEMDevModeParam->pPublicDMIn->dmCollate = DMCOLLATE_FALSE;
        pOEMDevModeParam->pPublicDMIn->dmFields &= ~DM_COLLATE;
#endif
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
} //*** OEMDevMode


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//  Parameters:
//      pOEMExtra    Pointer to a OEM Extra data.
//      dwSize       Size of OEM extra data.
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/1997      APresley Created.
//          02/28/2000      Masatoshi Kubokura Modified for PCL5e/PScript
//
//////////////////////////////////////////////////////////////////////////
BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    INT num;

    // Initialize OEM Extra data.
    pOEMExtra->dmOEMExtra.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmOEMExtra.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmOEMExtra.dwVersion = OEM_VERSION;

    pOEMExtra->fUiOption = 0;
    pOEMExtra->JobType = IDC_RADIO_JOB_NORMAL;
    pOEMExtra->LogDisabled = IDC_RADIO_LOG_DISABLED;

    return TRUE;
} //*** BInitOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//  Parameters:
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/1997      APresley Created.
//          04/08/1997      ZhanW    Modified the interface
//          08/11/1997      Masatoshi Kubokura Modified for RPDL
//
//////////////////////////////////////////////////////////////////////////
BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut)
{
    if(pdmIn) {
        LPBYTE pDst = (LPBYTE)&(pdmOut->fUiOption);
        LPBYTE pSrc = (LPBYTE)&(pdmIn->fUiOption);
        DWORD  dwCount = sizeof(OEMUD_EXTRADATA) - sizeof(OEM_DMEXTRAHEADER);

        //
        // copy over the private fields, if they are valid
        //
        while (dwCount-- > 0)
            *pDst++ = *pSrc++;
    }

    return TRUE;
} //*** BMergeOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//              02/11/1997      APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
} //*** BIsValidOEMDevModeParam


#if DBG
//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//  Returns:  N/A.
//
//  Comments:
//
//  History:
//              02/18/1997      APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
} //*** VDumpOEMDevModeParam
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   RWFileData
//
//  Description:  Read/Write common file between UI plugin and rendering
//                plugin
//
//  Parameters:
//      pFileData           pointer to file data structure
//      pwszFileName        pointer to file name of private devmode
//      FileNameBufSize     file name buffer size (add 02/26/2002)
//      type                GENERIC_READ/GENERIC_WRITE
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:  Rendering plugin records printing-done flag to the file.
//             Both rendering plugin and UI plugin can know that status.
//
//  History:
//              09/30/1998      Masatoshi Kubokura Created.
//              08/16/1999      takashim modified for Unidrv5.4 on NT4.
//              09/01/1999      Kubokura modified for Unidrv5.4 on NT4.
//              02/26/2002      Kubokura added FileNameBufSize param.
//
//////////////////////////////////////////////////////////////////////////
BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG FileNameBufSize, LONG type)
{
    HANDLE  hFile;
    DWORD   dwSize;
    BOOL    bRet = FALSE;
#ifndef KM_DRIVER
    WCHAR   szFileName[MY_MAX_PATH];    // MY_MAX_PATH=80
#endif // KM_DRIVER

#if DBG
giDebugLevel = DBG_VERBOSE;
#endif

    VERBOSE(("** Filename[0]=%d (%ls) **\n", pwszFileName[0], pwszFileName));

#ifndef KM_DRIVER
#ifndef WINNT_40
    //
    // CAUTION:
    //   TempPath is different whether EMF spool is enable(system) or not(user).
    //   We need to store the file name to private devmode.
    //

    // Set data data file name to private devmode at first time
    if (0 == pwszFileName[0])
    {
        if (0 == (dwSize = GetTempPath(MY_MAX_PATH, szFileName)))
        {
            ERR(("Could not get temp directory."));
            return bRet;
        }
// @Feb/26/2002 ->
//      wcscpy(&szFileName[dwSize], SHAREDFILENAME);
        StringCbCopyW(&szFileName[dwSize], sizeof(szFileName) - dwSize, SHAREDFILENAME);
// @Feb/26/2002 <-
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
// @Feb/26/2002 ->
//      wcscpy(pwszFileName, szFileName);
        StringCbCopyW(pwszFileName, FileNameBufSize, szFileName);
// @Feb/26/2002 <-
    }
#else  // WINNT_40
    //
    // CAUTION:
    //   The file path differs on each PC in printer sharing.
    //   We always update the file name (with path) of private devmode.
    //   (@Sep/03/99)
    //

    // Kernel-mode driver (NT4 RPDLRES.DLL) can access files under
    // %systemroot%\system32. Driver directory will be OK.
    if (GetPrinterDriverDirectory(NULL, NULL, 1, (PBYTE)szFileName,
                                  sizeof(szFileName), &dwSize))
    {
        WCHAR   szValue[MY_MAX_PATH] = L"XXXX";
        DWORD   dwSize2;
        DWORD   dwNum = 0;      // @Sep/21/99
        PWCHAR  pwszTmp;        // @Sep/21/99

        // Make unique filename "RIAXXXNN.BIN". "XXX" is filled with top 3char of username.
        dwSize2 = GetEnvironmentVariable(L"USERNAME", szValue, MY_MAX_PATH);
// @Sep/21/99 ->
//        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], SHAREDFILENAME, szValue, dwSize2);
        pwszTmp = szValue;
        while (dwSize2-- > 0)
            dwNum += (DWORD)*pwszTmp++;
        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], SHAREDFILENAME, szValue, (BYTE)dwNum);
// @Sep/21/99 <-
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
        wcscpy(pwszFileName, szFileName);
    }
    else
    {
        ERR(("Could not get printer driver directory.(dwSize=%d)", dwSize));
        return bRet;
    }
#endif // WINNT_40

    hFile = CreateFile((LPTSTR) pwszFileName,   // filename
                       type,                    // open for read/write
                       FILE_SHARE_READ,         // share to read
                       NULL,                    // no security
                       OPEN_ALWAYS,             // open existing file,or open new if not exist
                       FILE_ATTRIBUTE_NORMAL,   // normal file
                       NULL);                   // no attr. template

    if (INVALID_HANDLE_VALUE == hFile)
    {
        ERR(("Could not create data file."));
        return bRet;
    }

    if (GENERIC_WRITE == type)
        bRet = WriteFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);
    else if (GENERIC_READ == type)
        bRet = ReadFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);

    VERBOSE(("** RWFileData: bRet=%d, dwSize=%d**\n", bRet, dwSize));

    // Close files.
    CloseHandle(hFile);

#else  // KM_DRIVER
    if (0 != pwszFileName[0])
    {
        PBYTE   pTemp;

        if (GENERIC_WRITE == type)
        {
            hFile = DrvMapFileForWrite(pwszFileName, sizeof (FILEDATA),
                                       &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pTemp, pFileData, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
        else
        {
            hFile = DrvMapFileForRead(pwszFileName, &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pFileData, pTemp, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
    }
#endif // KM_DRIVER
#if DBG
giDebugLevel = DBG_ERROR;
#endif
    return bRet;
} //*** RWFileData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafui\comoem.cpp ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           COMOEM.CPP

Abstract:       Necessary COM class definition to Unidrv OEM UI plugin module.

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/24/1998 -takashim-
        Written the original sample so that it is more C++.
    02/29/2000 -Masatoshi Kubokura-
        Modified for PCL5e/PScript plugin from RPDL code.
    03/17/2000 -Masatoshi Kubokura-
        V.1.11
    08/02/2000 -Masatoshi Kubokura-
        V.1.11 for NT4
    08/29/2000 -Masatoshi Kubokura-
        Last modified for XP inbox.
    02/26/2002 -Masatoshi Kubokura-
        Include strsafe.h
    03/26/2002 -MS-
        Change return value from E_FAIL to S_FALSE at DllCanUnloadNow().
    03/29/2002 -Masatoshi Kubokura-
        Eliminate "#if 0".

--*/

#define INITGUID // for GUID one-time initialization

#include <minidrv.h>
#include "devmode.h"
#include "oem.h"
#ifndef WINNT_40
#include "strsafe.h"        // @Feb/26/2002
#endif // !WINNT_40

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUI
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
// @Mar/29/2002 ->
        if (NULL == ppv)
            return E_FAIL;
// @Mar/29/2002 <-
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n")));
        }
        else if (iid == IID_IPrintOemUI)
        {
            *ppv = static_cast<IPrintOemUI*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUI.\n")));
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n")));
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam)
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //


    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
        return S_OK;
    }

    //
    // CommonUIProp
    //

    STDMETHODIMP
    CommonUIProp(
        DWORD  dwMode,
        POEMCUIPPARAM   pOemCUIPParam)
    {
#ifdef DISKLESSMODEL        // @Aug/29/2000
        if (OEMCommonUIProp(dwMode, pOemCUIPParam))
            return S_OK;
        else
            return E_FAIL;
#else  // !DISKLESSMODEL
        return E_NOTIMPL;
#endif // !DISKLESSMODEL
    }

    //
    // DocumentPropertySheets
    //

    STDMETHODIMP
    DocumentPropertySheets(
        PPROPSHEETUI_INFO   pPSUIInfo,
        LPARAM              lParam)
    {

#if defined(WINNT_40) && defined(NOPROOFPRINT)      // @Aug/02/2000
        return E_NOTIMPL;
#else
        if (OEMDocumentPropertySheets(pPSUIInfo, lParam))
            return S_OK;
        else
            return E_FAIL;
#endif
    }

    //
    // DevicePropertySheets
    //

    STDMETHODIMP
    DevicePropertySheets(
        PPROPSHEETUI_INFO   pPSUIInfo,
        LPARAM              lParam)
    {
        return E_NOTIMPL;
    }

    //
    // DevQueryPrintEx
    //

    STDMETHODIMP
    DevQueryPrintEx(
        POEMUIOBJ               poemuiobj,
        PDEVQUERYPRINT_INFO     pDQPInfo,
        PDEVMODE                pPublicDM,
        PVOID                   pOEMDM)
    {
        return E_NOTIMPL;
    }

    //
    // DeviceCapabilities
    //

    STDMETHODIMP
    DeviceCapabilities(
        POEMUIOBJ   poemuiobj,
        HANDLE      hPrinter,
        PWSTR       pDeviceName,
        WORD        wCapability,
        PVOID       pOutput,
        PDEVMODE    pPublicDM,
        PVOID       pOEMDM,
        DWORD       dwOld,
        DWORD       *dwResult)
    {
        return E_NOTIMPL;
    }

    //
    // UpgradePrinter
    //

    STDMETHODIMP
    UpgradePrinter(
        DWORD   dwLevel,
        PBYTE   pDriverUpgradeInfo)
    {
        return E_NOTIMPL;
    }

    //
    // PrinterEvent
    //

    STDMETHODIMP
    PrinterEvent(
        PWSTR   pPrinterName,
        INT     iDriverEvent,
        DWORD   dwFlags,
        LPARAM  lParam)
    {
        return E_NOTIMPL;
    }

    //
    // DriverEvent
    //

    STDMETHODIMP
    DriverEvent(
        DWORD   dwDriverEvent,
        DWORD   dwLevel,
        LPBYTE  pDriverInfo,
        LPARAM  lParam)
    {
        return E_NOTIMPL;
    }

    //
    // QueryColorProfile
    //

    STDMETHODIMP
    QueryColorProfile(
        HANDLE      hPrinter,
        POEMUIOBJ   poemuiobj,
        PDEVMODE    pPublicDM,
        PVOID       pOEMDM,
        ULONG       ulReserved,
        VOID       *pvProfileData,
        ULONG      *pcbProfileData,
        FLONG      *pflProfileData)
    {
        return E_NOTIMPL;
    }

    //
    // FontInstallerDlgProc
    //

    STDMETHODIMP
    FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam)
    {
        return E_NOTIMPL;
    }

    //
    // UpdateExternalFonts
    //

    STDMETHODIMP
    UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
    {
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUI* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
            InterlockedIncrement(&g_cServerLocks);
        else
            InterlockedDecrement(&g_cServerLocks);
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
        return S_OK;
// @Mar/26/2002 (MS)
//     else
//         return E_FAIL;
    else
        return S_FALSE;
// @Mar/26/2002
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RIAFMSVS.RC
//
#define IDS_ERR_USERID_TITLE            200
#define IDS_ERR_USERID_MSG              201
#define IDS_ERR_PASSWORD_TITLE          202
#define IDS_ERR_PASSWORD_MSG            203
#define IDS_ERR_USERCODE_TITLE          204
#define IDS_ERR_USERCODE_MSG            205
#define IDS_ITEM_HARDDISK               206
#define IDS_ITEM_MEMORY_HARDDISK        207
#define ITEM_HARDDISK_NAMES             (IDS_ITEM_MEMORY_HARDDISK-IDS_ITEM_HARDDISK+1)
#define IDD_JOBMAIN                     500
#define IDC_LABEL_JOBMAIN_USERID        1000
#define IDC_LABEL_JOBMAIN_USERID2       1001
#define IDC_LABEL_JOBMAIN_USERID3       1002
#define IDC_LABEL_JOBMAIN_JOB           1003
#define IDC_LABEL_JOBMAIN_PASSWORD      1004
#define IDC_LABEL_JOBMAIN_PASSWORD2     1005
#define IDC_LABEL_JOBMAIN_LOG           1006
#define IDC_LABEL_JOBMAIN_USERCODE      1007
#define IDC_LABEL_JOBMAIN_USERCODE2     1008
#define IDC_EDIT_JOBMAIN_USERID         1009
#define IDC_EDIT_JOBMAIN_PASSWORD       1010
#define IDC_EDIT_JOBMAIN_USERCODE       1011
#define IDC_RADIO_JOB_NORMAL            1012
#define IDC_RADIO_JOB_SAMPLE            1013
#define IDC_RADIO_JOB_SECURE            1014
#define IDC_RADIO_LOG_DISABLED          1015
#define IDC_RADIO_LOG_ENABLED           1016
#define IDC_CHECK_JOB_DEFAULT           1017

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        501
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           208
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafui\devmode.h ===
//
//  Copyright (c) 1998-2001  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.
//
//  FILE:       Devmode.h
//
//  PURPOSE:    Define common data types, and external function prototypes
//              for devmode functions.
//
//  PLATFORMS:  Windows NT
//
//  Revision History:
//      03/02/2000 -Masatoshi Kubokura-
//          Modified DDK sample code.
//      09/22/2000 -Masatoshi Kubokura-
//          Last modified for Whistler.
//

#ifndef _DEVMODE_H
#define _DEVMODE_H

#include <windows.h>   // for UI
#include <compstui.h>  // for UI
#include <winddiui.h>  // for UI
#include <prcomoem.h>

////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

// buffer size
#define USERID_LEN                  8
#define PASSWORD_LEN                4
#define USERCODE_LEN                8
#define MY_MAX_PATH                 80

// private devmode
typedef struct _OEMUD_EXTRADATA{
    OEM_DMEXTRAHEADER   dmOEMExtra;
// common data between UI & rendering plugin ->
    DWORD   fUiOption;      // bit flags for UI option  (This must be after dmOEMExtra)
    WORD    JobType;
    WORD    LogDisabled;
    BYTE    UserIdBuf[USERID_LEN+1];
    BYTE    PasswordBuf[PASSWORD_LEN+1];
    BYTE    UserCodeBuf[USERCODE_LEN+1];
    WCHAR   SharedFileName[MY_MAX_PATH+16];
// <-
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

typedef const OEMUD_EXTRADATA *PCOEMUD_EXTRADATA;

// options for UI plugin
typedef struct _UIDATA{
    DWORD   fUiOption;
    HANDLE  hPropPage;
    HANDLE  hComPropSheet;
    PFNCOMPROPSHEET   pfnComPropSheet;
    POEMUD_EXTRADATA pOEMExtra;
    WORD    JobType;
    WORD    LogDisabled;
    WCHAR   UserIdBuf[USERID_LEN+1];
    WCHAR   PasswordBuf[PASSWORD_LEN+1];
    WCHAR   UserCodeBuf[USERCODE_LEN+1];
} UIDATA, *PUIDATA;

// file data for UI & rendering plugin
typedef struct _FILEDATA{
    DWORD   fUiOption;      // UI option flag
} FILEDATA, *PFILEDATA;

// bit definitions of fUiOption
#define HOLD_OPTIONS            0   // 1:hold options after printing
#define PRINT_DONE              1   // 1:printing done (rendering plugin sets this)
//   UI plugin local ->
#define UIPLUGIN_NOPERMISSION   16  // same as DM_NOPERMISSION
#define JOBLOGDLG_UPDATED       17  // 1:Job/Log dialog updated
//   <-

// registry value name
#define REG_HARDDISK_INSTALLED  L"HardDiskInstalled"

// flag bit operation
#define BIT(num)                ((DWORD)1<<(num))
#define BITCLR32(flag,num)      ((flag) &= ~BIT(num))
#define BITSET32(flag,num)      ((flag) |= BIT(num))
#define BITTEST32(flag,num)     ((flag) & BIT(num))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafui\oem.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           OEM.H

Abstract:       Header file for OEM UI/rendering plugin.

Environment:    Windows NT Unidrv5 driver

Revision History:
    03/02/2000 -Masatoshi Kubokura-
        Created it.
    09/22/2000 -Masatoshi Kubokura-
        Last modified for Whistler.

--*/


////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_VERSION      0x00010000L
#define WRITESPOOLBUF(p, s, n) ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))
#define MINIDEV_DATA(p)     ((POEMPDEV)((p)->pdevOEM))         // device data during job
#define MINIPRIVATE_DM(p)   ((POEMUD_EXTRADATA)((p)->pOEMDM))  // private devmode

#define OEM_SIGNATURE   'RIAF'      // RICOH Aficio printers
#define DLLTEXT(s)      "UI: " s
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafui\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

MAJORCOMP=windows
MINORCOMP=md_riafres

!include $(PRNROOT)\print.inc

TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS=\
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\winspool.lib \
    $(SDK_LIB_PATH)\uuid.lib

C_DEFINES=$(C_DEFINES) -DUNICODE -DOEMCOM

DLLENTRY=_DllMainCRTStartup
DLLBASE=0x50000000
USE_MSVCRT=1
USE_CTRLDLL=1

WIN32_WINNT_VERSION=0x0500
WIN32_IE_VERSION=0x0500

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=1252

UMTYPE=windows

SOURCES=\
    riafui.rc \
    riafui.cpp \
    common.c \
    comoem.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\riafui\riafui.cpp ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           RIAFUI.CPP

Abstract:       Main file for OEM UI plugin module.

Functions:      OEMDocumentPropertySheets
                OEMCommonUIProp

Environment:    Windows NT Unidrv5 driver

Revision History:
    02/25/2000 -Masatoshi Kubokura-
        Began to modify for PCL5e/PScript plugin from RPDL code.
    03/31/2000 -Masatoshi Kubokura-
        SetWindowLong -> SetWindowLongPtr for 64bit build.
    06/07/2000 -Masatoshi Kubokura-
        V.1.11
    08/02/2000 -Masatoshi Kubokura-
        V.1.11 for NT4
    11/29/2000 -Masatoshi Kubokura-
        Last modified for XP inbox.
    02/26/2002 -Masatoshi Kubokura-
        Include strsafe.h.
        Add FileNameBufSize as arg3 at RWFileData().
        Use OemToCharBuff() instead of OemToChar().
    03/29/2002 -Masatoshi Kubokura-
        Eliminate "#if 0".
        Use SecureZeroMemory() instead of memset(,0,)
    04/03/2002 -Masatoshi Kubokura-
        Use safe_strlenW() instead of lstrlen().

--*/


#include <minidrv.h>
#include "devmode.h"
#include "oem.h"
#include "resource.h"
#include <prsht.h>
#include <mbstring.h>   // _ismbcdigit, _ismbcalnum
#ifndef WINNT_40
#include "strsafe.h"        // @Feb/26/2002
#endif // !WINNT_40

////////////////////////////////////////////////////////
//      GLOBALS
////////////////////////////////////////////////////////
HINSTANCE ghInstance = NULL;

////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////
// @Apr/04/2002 ->
#define RES_ID_MASK     0xffff
#define is_valid_ptr(p) (~RES_ID_MASK & (UINT_PTR)(p))
// @Apr/04/2002 <-

extern "C" {
////////////////////////////////////////////////////////
//      EXTERNAL PROTOTYPES
////////////////////////////////////////////////////////
extern BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG FileNameBufSize, LONG type);

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////
INT_PTR CALLBACK JobPageProc(HWND, UINT, WPARAM, LPARAM);


//////////////////////////////////////////////////////////////////////////
//  Function:   safe_strlenW
//////////////////////////////////////////////////////////////////////////
INT safe_strlenW(wchar_t* psz, size_t cchMax)
{
#ifndef WINNT_40
    HRESULT hr;
    size_t  cch = 0;

    hr = StringCchLengthW(psz, cchMax, &cch);
    VERBOSE(("** safe_strlenW: size(lstrlen)=%d **\n", lstrlen(psz)));
    VERBOSE(("** safe_strlenW: size(StringCchLength)=%d **\n", cch));
    if (SUCCEEDED(hr))
        return cch;
    else
        return 0;
#else  // WINNT_40
    return lstrlenW(psz);
#endif // WINNT_40
} //*** safe_strlenW


//////////////////////////////////////////////////////////////////////////
//  Function:   DllMain
//////////////////////////////////////////////////////////////////////////
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
#if DBG
//giDebugLevel = DBG_VERBOSE;
////#define giDebugLevel DBG_VERBOSE    // enable VERBOSE() in each file
#endif // DBG
    VERBOSE((DLLTEXT("** enter DllMain **\n")));
    switch(wReason)
    {
        case DLL_PROCESS_ATTACH:
            VERBOSE((DLLTEXT("** Process attach. **\n")));

            // Save DLL instance for use later.
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            VERBOSE((DLLTEXT("Thread attach.\n")));
            break;

        case DLL_PROCESS_DETACH:
            VERBOSE((DLLTEXT("Process detach.\n")));
            break;

        case DLL_THREAD_DETACH:
            VERBOSE((DLLTEXT("Thread detach.\n")));
            break;
    }

    return TRUE;
} //*** DllMain


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDocumentPropertySheets
//////////////////////////////////////////////////////////////////////////
LRESULT APIENTRY OEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LRESULT lResult = FALSE;

#if DBG
    giDebugLevel = DBG_VERBOSE;
#endif // DBG

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        IsBadWritePtr(pPSUIInfo, pPSUIInfo->cbSize)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
        ||
        ( (PROPSHEETUI_REASON_INIT != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_GET_INFO_HEADER != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_GET_ICON != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_SET_RESULT != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_DESTROY != pPSUIInfo->Reason)
        )
      )
    {
        ERR((DLLTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\n")));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    VERBOSE(("\n"));
    VERBOSE((DLLTEXT("OEMDocumentPropertySheets() entry. Reason=%d\n"), pPSUIInfo->Reason));

// @Aug/29/2000 ->
#ifdef DISKLESSMODEL
    {
        DWORD   dwError, dwType, dwNeeded;
        BYTE    ValueData;
        POEMUIPSPARAM    pOEMUIPSParam = (POEMUIPSPARAM)pPSUIInfo->lParamInit;

        dwError = GetPrinterData(pOEMUIPSParam->hPrinter, REG_HARDDISK_INSTALLED, &dwType,
                                 (PBYTE)&ValueData, sizeof(BYTE), &dwNeeded);
        if (ERROR_SUCCESS != dwError)
        {
            VERBOSE((DLLTEXT("  CAN'T READ REGISTRY (%d).\n"), dwError));
            return FALSE;
        }
        else if (!ValueData)
        {
            VERBOSE((DLLTEXT("  HARD DISK ISN'T INSTALLED.\n")));
            return FALSE;
        }
    }
#endif // DISKLESSMODEL
// @Aug/29/2000 <-

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                POEMUIPSPARAM    pOEMUIPSParam = (POEMUIPSPARAM)pPSUIInfo->lParamInit;
                POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pOEMUIPSParam);
#ifdef WINNT_40
                VERBOSE((DLLTEXT("** dwFlags=%lx **\n"), pOEMUIPSParam->dwFlags));
                if (pOEMUIPSParam->dwFlags & DM_NOPERMISSION)
                    BITSET32(pOEMExtra->fUiOption, UIPLUGIN_NOPERMISSION);
#endif // WINNT_40

                pPSUIInfo->UserData = NULL;

                if ((pPSUIInfo->UserData = (LPARAM)HeapAlloc(pOEMUIPSParam->hOEMHeap,
                                                             HEAP_ZERO_MEMORY,
                                                             sizeof(UIDATA))))
                {
                    PROPSHEETPAGE   Page;
                    PUIDATA         pUiData = (PUIDATA)pPSUIInfo->UserData;
                    FILEDATA        FileData;   // <- pFileData (formerly use MemAllocZ) @2000/03/15

                    // read PRINT_DONE flag from data file
                    FileData.fUiOption = 0;
                    RWFileData(&FileData, pOEMExtra->SharedFileName, sizeof(pOEMExtra->SharedFileName), GENERIC_READ);
                    // set PRINT_DONE flag
                    if (BITTEST32(FileData.fUiOption, PRINT_DONE))
                        BITSET32(pOEMExtra->fUiOption, PRINT_DONE);
                    VERBOSE((DLLTEXT("** Flag=%lx,File Name=%ls **\n"),
                            pOEMExtra->fUiOption, pOEMExtra->SharedFileName));

                    pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;
                    pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
                    pUiData->pOEMExtra = pOEMExtra;

                    // Init property page.
// Use SecureZeroMemory  @Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
                    memset(&Page, 0, sizeof(PROPSHEETPAGE));
#else
                    SecureZeroMemory(&Page, sizeof(PROPSHEETPAGE));
#endif
// Mar/29/2002 <-
                    Page.dwSize = sizeof(PROPSHEETPAGE);
                    Page.dwFlags = PSP_DEFAULT;
                    Page.hInstance = ghInstance;
                    Page.pszTemplate = MAKEINTRESOURCE(IDD_JOBMAIN);
                    Page.pfnDlgProc = JobPageProc;
                    Page.lParam = (LPARAM)pUiData;

                    // Add property sheets.
                    lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                                                         CPSFUNC_ADD_PROPSHEETPAGE,
                                                         (LPARAM)&Page, 0);
                    pUiData->hPropPage = (HANDLE)lResult;
                    VERBOSE((DLLTEXT("** INIT: lResult=%x **\n"), lResult));
                    lResult = (lResult > 0)? TRUE : FALSE;
                }
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            lResult = TRUE;
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            if (pPSUIInfo->UserData)
            {
                POEMUIPSPARAM   pOEMUIPSParam = (POEMUIPSPARAM)pPSUIInfo->lParamInit;

                HeapFree(pOEMUIPSParam->hOEMHeap, 0, (void*)pPSUIInfo->UserData);
            }
            break;
    }

    pPSUIInfo->Result = lResult;
    return lResult;
} //*** OEMDocumentPropertySheets


/***************************************************************************
    Function Name : InitMainDlg
***************************************************************************/
VOID InitMainDlg(
HWND hDlg,
PUIDATA pUiData)
{
    // initialize edit box
    SetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERID, pUiData->UserIdBuf);
    SendDlgItemMessage(hDlg, IDC_EDIT_JOBMAIN_USERID, EM_LIMITTEXT, USERID_LEN, 0);
    SetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_PASSWORD, pUiData->PasswordBuf);
    SendDlgItemMessage(hDlg, IDC_EDIT_JOBMAIN_PASSWORD, EM_LIMITTEXT, PASSWORD_LEN, 0);
    SetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERCODE, pUiData->UserCodeBuf);
    SendDlgItemMessage(hDlg, IDC_EDIT_JOBMAIN_USERCODE, EM_LIMITTEXT, USERCODE_LEN, 0);

    // initialize radio button
    CheckRadioButton(hDlg, IDC_RADIO_JOB_NORMAL, IDC_RADIO_JOB_SECURE, pUiData->JobType);
    CheckRadioButton(hDlg, IDC_RADIO_LOG_DISABLED, IDC_RADIO_LOG_ENABLED, pUiData->LogDisabled);

    // initialize check box
    SendDlgItemMessage(hDlg, IDC_CHECK_JOB_DEFAULT, BM_SETCHECK,
                       (BITTEST32(pUiData->fUiOption, HOLD_OPTIONS)? 0 : 1), 0);

    if (1 <= safe_strlenW(pUiData->UserIdBuf, sizeof(pUiData->UserIdBuf)))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), FALSE);
    }
    if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
    }
    if (IDC_RADIO_LOG_ENABLED == pUiData->LogDisabled)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), FALSE);
    }

#ifdef WINNT_40
    // Disable tab options when user has no permission.
    if (BITTEST32(pUiData->fUiOption, UIPLUGIN_NOPERMISSION))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERID), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERID2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERID3), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_JOB), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_LOG), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERID), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_NORMAL), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_LOG_DISABLED), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_LOG_ENABLED), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), FALSE);
    }
#endif // WINNT_40
} //*** InitMainDlg


/***************************************************************************
    Function Name : GetInfoFromOEMPdev
                    get data from private devmode
***************************************************************************/
VOID GetInfoFromOEMPdev(PUIDATA pUiData)
{
    POEMUD_EXTRADATA pOEMExtra = pUiData->pOEMExtra;

    VERBOSE((DLLTEXT("GetInfoFromOEMPdev: print done?(%d)\n"),
            BITTEST32(pOEMExtra->fUiOption, PRINT_DONE)));
    // if previous printing is finished and hold-options flag isn't valid,
    // reset job setting.
    if (BITTEST32(pOEMExtra->fUiOption, PRINT_DONE) &&
        !BITTEST32(pOEMExtra->fUiOption, HOLD_OPTIONS))
    {
        pUiData->JobType = IDC_RADIO_JOB_NORMAL;
// Use SecureZeroMemory  @Mar/26/2002 (MS), Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
        memset(pUiData->PasswordBuf, 0, sizeof(pUiData->PasswordBuf));
#else
        SecureZeroMemory(pUiData->PasswordBuf, sizeof(pUiData->PasswordBuf));
#endif
// @Mar/26/2002, Mar/29/2002 <-
        // do not clear PRINT_DONE flag here
    }
    else
    {
        pUiData->JobType = pOEMExtra->JobType;
        // ascii to unicode
// @Feb/27/2002 ->
//        OemToChar((LPSTR)pOEMExtra->PasswordBuf, pUiData->PasswordBuf);
        OemToCharBuff((LPSTR)pOEMExtra->PasswordBuf, pUiData->PasswordBuf, PASSWORD_LEN);
// @Feb/27/2002 <-
    }

    pUiData->fUiOption = pOEMExtra->fUiOption;
    pUiData->LogDisabled = pOEMExtra->LogDisabled;
    // ascii to unicode
// @Feb/27/2002 ->
//    OemToChar((LPSTR)pOEMExtra->UserIdBuf, pUiData->UserIdBuf);
//    OemToChar((LPSTR)pOEMExtra->UserCodeBuf, pUiData->UserCodeBuf);
    OemToCharBuff((LPSTR)pOEMExtra->UserIdBuf, pUiData->UserIdBuf, USERID_LEN);
    OemToCharBuff((LPSTR)pOEMExtra->UserCodeBuf, pUiData->UserCodeBuf, USERCODE_LEN);
// @Feb/27/2002 <-
} //*** GetInfoFromOEMPdev


/***************************************************************************
    Function Name : SetInfoToOEMPdev
                    set data to private devmode
***************************************************************************/
VOID SetInfoToOEMPdev(PUIDATA pUiData)
{
    POEMUD_EXTRADATA pOEMExtra = pUiData->pOEMExtra;

    // if only main dialog is changed
    if (!BITTEST32(pUiData->fUiOption, JOBLOGDLG_UPDATED))
        return;

    // unicode to ascii
    CharToOem(pUiData->UserIdBuf, (LPSTR)pOEMExtra->UserIdBuf);
    CharToOem(pUiData->PasswordBuf, (LPSTR)pOEMExtra->PasswordBuf);
    CharToOem(pUiData->UserCodeBuf, (LPSTR)pOEMExtra->UserCodeBuf);

    pOEMExtra->fUiOption = pUiData->fUiOption & 0x00FF; // clear local bit
    pOEMExtra->JobType = pUiData->JobType;
    pOEMExtra->LogDisabled = pUiData->LogDisabled;
#if DBG
//DebugBreak();
#endif // DBG
    return;
} //*** SetInfoToOEMPdev


/***************************************************************************
    Function Name : JobPageProc

    Parameters    : HWND    hDlg            Handle of this Dialog
                    UINT    uMessage
                    WPARAM  wParam
                    LPARAM  lParam

    Modify Note   : Modify.                 03/01/2000 Masatoshi Kubokura
***************************************************************************/
INT_PTR CALLBACK JobPageProc(
HWND hDlg,
UINT uMessage,
WPARAM wParam,
LPARAM lParam)
{
    PUIDATA pUiData;
    WORD    wOldVal, fModified = FALSE, fError = FALSE;
    INT     iOldLen, iNewLen, iCnt;

#if DBG
giDebugLevel = DBG_VERBOSE;
#endif // DBG

    switch (uMessage)
    {
      case WM_INITDIALOG:
        pUiData = (PUIDATA)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pUiData);

        // get data from private devmode
        GetInfoFromOEMPdev(pUiData);

        InitMainDlg(hDlg, pUiData);
        BITCLR32(pUiData->fUiOption, JOBLOGDLG_UPDATED);
        break;

      case WM_COMMAND:
        pUiData = (PUIDATA)GetWindowLongPtr(hDlg, DWLP_USER);
        switch(LOWORD(wParam))
        {
          case IDC_EDIT_JOBMAIN_USERID:
            iOldLen = safe_strlenW(pUiData->UserIdBuf, sizeof(pUiData->UserIdBuf));
            GetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERID, pUiData->UserIdBuf,
                           sizeof(pUiData->UserIdBuf) / sizeof(WCHAR));
            iNewLen = safe_strlenW(pUiData->UserIdBuf, sizeof(pUiData->UserIdBuf));
            if (1 <= iNewLen)
            {
                if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), TRUE);
                }
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), TRUE);
            }
            // if UserID isn't set, disable Print Job setting.
            else
            {
                CheckRadioButton(hDlg, IDC_RADIO_JOB_NORMAL, IDC_RADIO_JOB_SECURE,
                                 (pUiData->JobType = IDC_RADIO_JOB_NORMAL));
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
            }
            if (iOldLen != iNewLen)
                fModified = TRUE;
            break;

          case IDC_EDIT_JOBMAIN_PASSWORD:
            iOldLen = safe_strlenW(pUiData->PasswordBuf, sizeof(pUiData->PasswordBuf));
            GetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_PASSWORD, pUiData->PasswordBuf,
                           sizeof(pUiData->PasswordBuf) / sizeof(WCHAR));
            if (iOldLen != safe_strlenW(pUiData->PasswordBuf, sizeof(pUiData->PasswordBuf)))
                fModified = TRUE;
            break;

          case IDC_EDIT_JOBMAIN_USERCODE:
            iOldLen = safe_strlenW(pUiData->UserCodeBuf, sizeof(pUiData->UserCodeBuf));
            GetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERCODE, pUiData->UserCodeBuf,
                           sizeof(pUiData->UserCodeBuf) / sizeof(WCHAR));
            if (iOldLen != safe_strlenW(pUiData->UserCodeBuf, sizeof(pUiData->UserCodeBuf)))
                fModified = TRUE;
            break;

          case IDC_RADIO_JOB_NORMAL:
          case IDC_RADIO_JOB_SAMPLE:
          case IDC_RADIO_JOB_SECURE:
            wOldVal = pUiData->JobType;
            CheckRadioButton(hDlg, IDC_RADIO_JOB_NORMAL, IDC_RADIO_JOB_SECURE,
                             (pUiData->JobType = LOWORD(wParam)));
            if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
            }
            if (wOldVal != pUiData->JobType)
                fModified = TRUE;
            break;

          case IDC_RADIO_LOG_DISABLED:
          case IDC_RADIO_LOG_ENABLED:
            wOldVal = pUiData->LogDisabled;
            CheckRadioButton(hDlg, IDC_RADIO_LOG_DISABLED, IDC_RADIO_LOG_ENABLED,
                             (pUiData->LogDisabled = LOWORD(wParam)));
            if (IDC_RADIO_LOG_ENABLED == pUiData->LogDisabled)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), FALSE);
            }
            if (wOldVal != pUiData->LogDisabled)
                fModified = TRUE;
            break;

          case IDC_CHECK_JOB_DEFAULT:
            if (BITTEST32(pUiData->fUiOption, HOLD_OPTIONS))
                BITCLR32(pUiData->fUiOption, HOLD_OPTIONS);
            else
                BITSET32(pUiData->fUiOption, HOLD_OPTIONS);
            SendDlgItemMessage(hDlg, IDC_CHECK_JOB_DEFAULT, BM_SETCHECK,
                               (BITTEST32(pUiData->fUiOption, HOLD_OPTIONS)? 0 : 1), 0);
            fModified = TRUE;
            break;

          default:
            return FALSE;
        }
        break;

      case WM_NOTIFY:
        pUiData = (PUIDATA)GetWindowLongPtr(hDlg, DWLP_USER);
        {
            NMHDR FAR *lpnmhdr = (NMHDR FAR *)lParam;

            switch (lpnmhdr->code)
            {
              case PSN_SETACTIVE:
                break;

              // In case of PSN_KILLACTIVE, return FALSE to get PSN_APPLY.
              case PSN_KILLACTIVE:  // this is when user pushs OK/APPLY button.(1)
                VERBOSE((DLLTEXT("** JobPageProc: PSN_KILLACTIVE **\n")));
                BITSET32(pUiData->fUiOption, JOBLOGDLG_UPDATED);

                // Check User ID (Up to 8 alphanumeric characters)
                iNewLen = safe_strlenW(pUiData->UserIdBuf, sizeof(pUiData->UserIdBuf));
                for (iCnt = 0; iCnt < iNewLen; iCnt++)
                {
                    // SBCS alphanumeric?
                    if (!_ismbcalnum(pUiData->UserIdBuf[iCnt]))
                    {
                        fError = TRUE;
                        break;
                    }
                }
                if (fError)
                {
                    WCHAR   wcTmp1[64], wcTmp2[64];

                    // set cursor to User ID edit box
                    SetFocus(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERID));

                    // Display warning dialog
// yasho's point-out  @Nov/29/2000 ->
//                    LoadString(ghInstance, IDS_ERR_USERID_MSG, wcTmp1, sizeof(wcTmp1));
//                    LoadString(ghInstance, IDS_ERR_USERID_TITLE, wcTmp2, sizeof(wcTmp1));
                    LoadString(ghInstance, IDS_ERR_USERID_MSG, wcTmp1, sizeof(wcTmp1) / sizeof(*wcTmp1));
                    LoadString(ghInstance, IDS_ERR_USERID_TITLE, wcTmp2, sizeof(wcTmp2) / sizeof(*wcTmp2));
// @Nov/29/2000 <-
                    MessageBox(hDlg, wcTmp1, wcTmp2, MB_ICONEXCLAMATION|MB_OK);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

                    // Do not close property sheets
                    return TRUE;
                }

                // Check Password (4 digits)
                iNewLen = safe_strlenW(pUiData->PasswordBuf, sizeof(pUiData->PasswordBuf));
                if (PASSWORD_LEN != iNewLen)    // Password must be exactly 4 digits.
                {
                    fError = TRUE;
                }
                else
                {
                    for (iCnt = 0; iCnt < iNewLen; iCnt++)
                    {
                        // SBCS digit?
                        if (!_ismbcdigit(pUiData->PasswordBuf[iCnt]))
                        {
                            fError = TRUE;
                            break;
                        }
                    }
                }
                if (fError)
                {
                    // if Secure Print is enabled
                    if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
                    {
                        WCHAR   wcTmp1[64], wcTmp2[64];

                        // set cursor to Password edit box
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD));

                        // Display warning dialog
                        LoadString(ghInstance, IDS_ERR_PASSWORD_MSG, wcTmp1, sizeof(wcTmp1) / sizeof(*wcTmp1));
                        LoadString(ghInstance, IDS_ERR_PASSWORD_TITLE, wcTmp2, sizeof(wcTmp2) / sizeof(*wcTmp2));
                        MessageBox(hDlg, wcTmp1, wcTmp2, MB_ICONEXCLAMATION|MB_OK);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

                        // Do not close property sheets
                        return TRUE;
                    }
                    else
                    {
                        // Clear invalid Password
// Use SecureZeroMemory  @Mar/26/2002 (MS), Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
                        memset(pUiData->PasswordBuf, 0, sizeof(pUiData->PasswordBuf));
#else
                        SecureZeroMemory(pUiData->PasswordBuf, sizeof(pUiData->PasswordBuf));
#endif
// @Mar/26/2002, Mar/29/2002 <-
                    }
                    fError = FALSE;
                }

                // Check User Code (Up to 8 characters)
                iNewLen = safe_strlenW(pUiData->UserCodeBuf, sizeof(pUiData->UserCodeBuf));
                for (iCnt = 0; iCnt < iNewLen; iCnt++)
                {
                    // SBCS digit?
                    if (!_ismbcdigit(pUiData->UserCodeBuf[iCnt]))
                    {
                        fError = TRUE;
                        break;
                    }
                }
                if (fError)
                {
                    // if Log is enabled
                    if (IDC_RADIO_LOG_ENABLED == pUiData->LogDisabled)
                    {
                        WCHAR   wcTmp1[64], wcTmp2[64];

                        // set cursor to User Code edit box
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE));

                        // Display warning dialog
                        LoadString(ghInstance, IDS_ERR_USERCODE_MSG, wcTmp1, sizeof(wcTmp1) / sizeof(*wcTmp1));
                        LoadString(ghInstance, IDS_ERR_USERCODE_TITLE, wcTmp2, sizeof(wcTmp2) / sizeof(*wcTmp2));
                        MessageBox(hDlg, wcTmp1, wcTmp2, MB_ICONEXCLAMATION|MB_OK);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

                        // Do not close property sheets
                        return TRUE;
                    }
                    else
                    {
                        // Clear invalid User Code
// Use SecureZeroMemory  @Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
                        memset(pUiData->UserCodeBuf, 0, sizeof(pUiData->UserCodeBuf));
#else
                        SecureZeroMemory(pUiData->UserCodeBuf, sizeof(pUiData->UserCodeBuf));
#endif
// Mar/29/2002 <-
                    }
                    fError = FALSE;
                }
                return FALSE;

              case PSN_APPLY:       // this is when user pushs OK/APPLY button.(2)
                VERBOSE((DLLTEXT("** JobPageProc: PSN_APPLY **\n")));

                // clear PRINT_DONE flag and delete file.
// BUGBUG: When printing document twice, printing job settings are cleared on app's print dialog
// in 2nd printing.  @Sep/05/2000 ->
//              if (BITTEST32(pUiData->pOEMExtra->fUiOption, PRINT_DONE))
//              {
//                  BITCLR32(pUiData->pOEMExtra->fUiOption, PRINT_DONE);
//                  VERBOSE(("** Delete file: %ls **\n", pUiData->pOEMExtra->SharedFileName));
//                  DeleteFile(pUiData->pOEMExtra->SharedFileName);
//              }
                if (BITTEST32(pUiData->fUiOption, PRINT_DONE))
                {
                    BITCLR32(pUiData->fUiOption, PRINT_DONE);
                    VERBOSE(("** Delete file: %ls **\n", pUiData->pOEMExtra->SharedFileName));
                    DeleteFile(pUiData->pOEMExtra->SharedFileName);
                }
// @Sep/05/2000 <-

                // set data to private devmode
                SetInfoToOEMPdev(pUiData);

                // update private devmode
                pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                         CPSFUNC_SET_RESULT,
                                         (LPARAM)pUiData->hPropPage,
                                         (LPARAM)CPSUI_OK);
                VERBOSE((DLLTEXT("** PSN_APPLY fUiOption=%x **\n"), pUiData->fUiOption));
                break;

              case PSN_RESET:       // this is when user pushs CANCEL button
                VERBOSE((DLLTEXT("** JobPageProc: PSN_RESET **\n")));
                break;
            }
        }
        break;

      default:
        return FALSE;
    }

    // activate APPLY button
    if (fModified)
        PropSheet_Changed(GetParent(hDlg), hDlg);
    return TRUE;
} //*** JobPageProc

} // End of extern "C"


// @Aug/29/2000 ->
#ifdef DISKLESSMODEL
LONG APIENTRY OEMUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    Action = CPSUICB_ACTION_NONE;

#if DBG
    giDebugLevel = DBG_VERBOSE;
    VERBOSE((DLLTEXT("OEMUICallBack() entry.\n")));
#endif // DBG

    switch (pCallbackParam->Reason)
    {
      case CPSUICB_REASON_APPLYNOW:
        Action = CPSUICB_ACTION_ITEMS_APPLIED;
        {
            POPTITEM    pOptItem;
            WCHAR       wcHDName[128];
            INT         iCnt2;
            INT         iCnt = ITEM_HARDDISK_NAMES;
            INT         cOptItem = (INT)pOEMUIParam->cDrvOptItems;
            UINT        uID = IDS_ITEM_HARDDISK;
            BYTE        ValueData = 0;  // We suppose Hard Disk isn't installed as default.

            // Check item name with several candidate ("Hard Disk", "Memory / Hard Disk",...).
            while (iCnt-- > 0)
            {
                LoadString(ghInstance, uID, wcHDName, sizeof(wcHDName) / sizeof(*wcHDName));
                uID++; 

                pOptItem = pOEMUIParam->pDrvOptItems;
                for (iCnt2 = 0; iCnt2 < cOptItem; iCnt2++, pOptItem++)
                {
// @Apr/04/2002 ->
//                    if (lstrlen(pOptItem->pName))
                    if (is_valid_ptr(pOptItem->pName) && safe_strlenW(pOptItem->pName, 128))
// @Apr/04/2002 <-
                    {
                        VERBOSE((DLLTEXT("%d: %ls\n"), iCnt2, pOptItem->pName));
                        // Is item name same as "Hard Disk" or something like?
                        if (!lstrcmp(pOptItem->pName, wcHDName))
                        {
                            // if Hard Disk is installed, value will be 1
                            ValueData = (BYTE)(pOptItem->Sel % 2);
                            goto _CHECKNAME_FINISH;
                        }
                    }
                }
            }
_CHECKNAME_FINISH:
            // Because pOEMUIParam->pOEMDM (pointer to private devmode) is NULL when
            // DrvDevicePropertySheets calls this callback, we use registry.
            SetPrinterData(pOEMUIParam->hPrinter, REG_HARDDISK_INSTALLED, REG_BINARY,
                           (PBYTE)&ValueData, sizeof(BYTE));
        }
        break;
    }
    return Action;
} //*** OEMUICallBack

extern "C" {
//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommonUIProp
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMCommonUIProp(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
#if DBG
    LPCSTR OEMCommonUIProp_Mode[] = {
        "Bad Index",
        "OEMCUIP_DOCPROP",
        "OEMCUIP_PRNPROP",
    };

    giDebugLevel = DBG_VERBOSE;
#endif // DBG
    if(NULL == pOEMUIParam->pOEMOptItems)   // The first call
    {
        VERBOSE((DLLTEXT("OEMCommonUI(%s) entry 1st.\n"), OEMCommonUIProp_Mode[dwMode]));
        if (OEMCUIP_PRNPROP == dwMode)
            pOEMUIParam->cOEMOptItems = 1;  // dummy item
        else
            pOEMUIParam->cOEMOptItems = 0;
    }
    else                                    // The second call
    {
        VERBOSE((DLLTEXT("OEMCommonUI(%s) entry 2nd.\n"), OEMCommonUIProp_Mode[dwMode]));

        if (OEMCUIP_PRNPROP == dwMode)          // called from DrvDevicePropertySheets
        {
            POPTITEM    pOptItem = pOEMUIParam->pOEMOptItems;
            // fill out data for dummy item
            pOptItem->cbSize   = sizeof(OPTITEM);
            pOptItem->Level    = 2;             // Level 2
            pOptItem->pName    = NULL;
            pOptItem->pOptType = NULL;
            pOptItem->DMPubID  = DMPUB_NONE;
            pOptItem->Flags    = OPTIF_HIDE | OPTIF_CALLBACK;   // invisible and with callback
            pOEMUIParam->OEMCUIPCallback = OEMUICallBack;
        }
#ifdef WINNT_40
        else                                    // called from DrvDocumentPropertySheets
        {
            INT         iCnt;
            INT         cOptItem = (INT)pOEMUIParam->cDrvOptItems;
            POPTITEM    pOptItem = pOEMUIParam->pDrvOptItems;

            // If collate check box exists (i.e. printer collate is available),
            // set dmCollate.
            // -- Search Copies&Collate item --
            for (iCnt = 0; iCnt < cOptItem; iCnt++, pOptItem++)
            {
                if (DMPUB_COPIES_COLLATE == pOptItem->DMPubID)
                {
                    if (pOptItem->pExtChkBox && pOEMUIParam->pPublicDM)
                    {
                        pOEMUIParam->pPublicDM->dmCollate = DMCOLLATE_TRUE;
                        pOEMUIParam->pPublicDM->dmFields |= DM_COLLATE;
                    }
                    break;
                }
            }
        }
#endif // WINNT_40
    }
    return TRUE;
} //*** OEMCommonUIProp

} // End of extern "C"
#endif // DISKLESSMODEL
// @Aug/29/2000 <-
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\common.c ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           COMMON.C

Abstract:       Implementation of common functions for rendering & UI
                plugin module.

Functions:      OEMGetInfo
                OEMDevMode
                RWFileData
                safe_sprintfA
                safe_sprintfW

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/97 -zhanw-
        Created it.
    02/11/99 -Masatoshi Kubokura-
        Last modified for Windows2000.
    08/30/99 -Masatoshi Kubokura-
        Began to modify for NT4SP6(Unidrv5.4).
    09/27/99 -Masatoshi Kubokura-
        Last modified for NT4SP6.
    03/17/2000 -Masatoshi Kubokura-
        Eliminate "\\" from temp file name.
    05/22/2000 -Masatoshi Kubokura-
        V.1.03 for NT4
    09/22/2000 -Masatoshi Kubokura-
        Last modified for XP inbox.
    03/01/2002 -Masatoshi Kubokura-
        Include strsafe.h.
        Add FileNameBufSize as arg3 at RWFileData().
        Inplement safe_sprintfA/W().
    04/01/2002 -Masatoshi Kubokura-
        Use SecureZeroMemory() instead of memset(,0,)

--*/

#include "pdev.h"
#include "resource.h"
#ifndef WINNT_40
#include "strsafe.h"        // @Mar/01/2002
#endif // !WINNT_40

// shared data file between rendering and UI plugin
#ifndef WINNT_40
#define SHAREDFILENAME          L"RIMD5.BIN"        // eliminate "\\"  @Mar/15/2000
#else  // WINNT_40
#define SHAREDFILENAME          L"\\2\\RI%.4ls%02x.BIN" // %02x<-%02d  @Sep/21/99
DWORD gdwDrvMemPoolTag = 'meoD';    // minidrv.h requires this global var
#endif // WINNT_40

#if DBG && !defined(KM_DRIVER)
INT giDebugLevel = DBG_ERROR;
#endif

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
#if DBG
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMGetInfo
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
#if DBG
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));
#endif // DBG

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
} //*** OEMGetInfo


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDevMode
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMDevMode(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
#if DBG
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE((DLLTEXT("OEMDevMode(%s) entry.\n"), OEMDevMode_fMode[dwMode]));
#endif // DBG

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
#if DBG
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
#endif // DBG
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
#ifdef WINNT_40     // @Sep/20/99
        // Because NT4 spooler doesn't support collate, we clear dmCollate.
        // Later at OEMUICallBack, if printer collate is available, we set
        // dmCollate.
        pOEMDevModeParam->pPublicDMIn->dmCollate = DMCOLLATE_FALSE;
        pOEMDevModeParam->pPublicDMIn->dmFields &= ~DM_COLLATE;
#endif // WINNT_40
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
// @Jul/08/98 ->
//        // nothing to convert for this private devmode. So just initialize it.
//        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
// @Jul/08/98 <-
    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
} //*** OEMDevMode


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//  Parameters:
//      pOEMExtra    Pointer to a OEM Extra data.
//      dwSize       Size of OEM extra data.
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/97        APresley Created.
//          08/11/97        Masatoshi Kubokura Modified for RPDL
//
//////////////////////////////////////////////////////////////////////////
BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    INT num;

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->fUiOption = 0;
    pOEMExtra->UiScale = VAR_SCALING_DEFAULT;
    pOEMExtra->UiBarHeight = BAR_H_DEFAULT;
    pOEMExtra->UiBindMargin = DEFAULT_0;
    pOEMExtra->nUiTomboAdjX = pOEMExtra->nUiTomboAdjY = DEFAULT_0;  // add @Sep/14/98
// Use SecureZeroMemory  @Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
    memset(pOEMExtra->SharedFileName, 0, sizeof(pOEMExtra->SharedFileName));    // @Aug/31/99
#else
    SecureZeroMemory(pOEMExtra->SharedFileName, sizeof(pOEMExtra->SharedFileName));
#endif
// Mar/29/2002 <-
#ifdef JOBLOGSUPPORT_DM     // @Oct/05/2000
    pOEMExtra->JobType = IDC_RADIO_JOB_NORMAL;
    pOEMExtra->LogDisabled = IDC_RADIO_LOG_DISABLED;
#endif // JOBLOGSUPPORT_DM

    return TRUE;
} //*** BInitOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//  Parameters:
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//          08/11/97        Masatoshi Kubokura Modified for RPDL
//
//////////////////////////////////////////////////////////////////////////
BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut)
{
    if(pdmIn) {
        LPBYTE pDst = (LPBYTE)&(pdmOut->fUiOption);
        LPBYTE pSrc = (LPBYTE)&(pdmIn->fUiOption);
        DWORD  dwCount = sizeof(OEMUD_EXTRADATA) - sizeof(OEM_DMEXTRAHEADER);

        //
        // copy over the private fields, if they are valid
        //
        while (dwCount-- > 0)
            *pDst++ = *pSrc++;
    }

    return TRUE;
} //*** BMergeOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
} //*** BIsValidOEMDevModeParam


#if DBG
//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//  Returns:  N/A.
//
//  Comments:
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
} //*** VDumpOEMDevModeParam
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   RWFileData
//
//  Description:  Read/Write common file between UI plugin and rendering
//                plugin
//
//  Parameters:
//      pFileData           pointer to file data structure
//      pwszFileName        pointer to file name of private devmode
//      FileNameBufSize     file name buffer size (add 02/26/2002)
//      type                GENERIC_READ/GENERIC_WRITE
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:  Rendering plugin records printing-done flag to the file.
//             Both rendering plugin and UI plugin can know that status.
//
//  History:
//              09/30/1998      Masatoshi Kubokura Created.
//              08/16/1999      takashim modified for Unidrv5.4 on NT4.
//              09/01/1999      Kubokura modified for Unidrv5.4 on NT4.
//              02/26/2002      Kubokura added FileNameBufSize param.
//
//////////////////////////////////////////////////////////////////////////
BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG FileNameBufSize, LONG type)
{
    HANDLE  hFile;
    DWORD   dwSize;
    BOOL    bRet = FALSE;
#ifndef KM_DRIVER
    WCHAR   szFileName[MY_MAX_PATH];    // MY_MAX_PATH=80
#endif // KM_DRIVER

    VERBOSE(("** Filename[0]=%d (%ls) **\n", pwszFileName[0], pwszFileName));

#ifndef KM_DRIVER
#ifndef WINNT_40
    //
    // CAUTION:
    //   TempPath is different whether EMF spool is enable(system) or not(user).
    //   We need to store the file name to private devmode.
    //

    // Set shared file name to private devmode at first time
    if (0 == pwszFileName[0])
    {
        if (0 == (dwSize = GetTempPath(MY_MAX_PATH, szFileName)))
        {
            ERR(("Could not get temp directory."));
            return bRet;
        }
// @Feb/26/2002 ->
//      wcscpy(&szFileName[dwSize], SHAREDFILENAME);
        StringCbCopyW(&szFileName[dwSize], sizeof(szFileName) - dwSize, SHAREDFILENAME);
// @Feb/26/2002 <-
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
// @Feb/26/2002 ->
//      wcscpy(pwszFileName, szFileName);
        StringCbCopyW(pwszFileName, FileNameBufSize, szFileName);
// @Feb/26/2002 <-
    }
#else  // WINNT_40
    //
    // CAUTION:
    //   The file path differs on each PC in printer sharing.
    //   We always update the file name (with path) of private devmode.
    //   (@Sep/03/99)
    //

    // Kernel-mode driver (NT4 RPDLRES.DLL) can access files under
    // %systemroot%\system32. Driver directory will be OK.
    if (GetPrinterDriverDirectory(NULL, NULL, 1, (PBYTE)szFileName,
                                  sizeof(szFileName), &dwSize))
    {
        WCHAR   szValue[MY_MAX_PATH] = L"XXXX";
        DWORD   dwSize2;
        DWORD   dwNum = 0;      // @Sep/21/99
        PWCHAR  pwszTmp;        // @Sep/21/99

        // Make unique filename "RIXXXXNN.BIN". "XXXX" is filled with top 4char of username.
        dwSize2 = GetEnvironmentVariable(L"USERNAME", szValue, MY_MAX_PATH);
// @Sep/21/99 ->
//        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], SHAREDFILENAME, szValue, dwSize2);
        pwszTmp = szValue;
        while (dwSize2-- > 0)
            dwNum += (DWORD)*pwszTmp++;
        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], SHAREDFILENAME, szValue, (BYTE)dwNum);
// @Sep/21/99 <-
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
        wcscpy(pwszFileName, szFileName);
    }
    else
    {
        ERR(("Could not get printer driver directory.(dwSize=%d)", dwSize));
        return bRet;
    }
#endif // WINNT_40

    hFile = CreateFile((LPTSTR) pwszFileName,   // filename
                       type,                    // open for read/write
                       FILE_SHARE_READ,         // share to read
                       NULL,                    // no security
                       OPEN_ALWAYS,             // open existing file,or open new if not exist
                       FILE_ATTRIBUTE_NORMAL,   // normal file
                       NULL);                   // no attr. template

    if (INVALID_HANDLE_VALUE == hFile)
    {
        ERR(("Could not create shared file."));
        return bRet;
    }

    if (GENERIC_WRITE == type)
        bRet = WriteFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);
    else if (GENERIC_READ == type)
        bRet = ReadFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);

    VERBOSE(("** RWFileData: bRet=%d, dwSize=%d**\n", bRet, dwSize));

    // Close files.
    CloseHandle(hFile);

#else  // KM_DRIVER
    if (0 != pwszFileName[0])
    {
        PBYTE   pTemp;

        if (GENERIC_WRITE == type)
        {
            hFile = DrvMapFileForWrite(pwszFileName, sizeof (FILEDATA),
                                       &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pTemp, pFileData, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
        else
        {
            hFile = DrvMapFileForRead(pwszFileName, &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pFileData, pTemp, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
    }
#endif // KM_DRIVER
    return bRet;
} //*** RWFileData


//////////////////////////////////////////////////////////////////////////
//  Function:   safe_sprintfA / safe_sprintfW
//
//  Description:  safer sprintf replacement.
//
//  History:
//              03/01/2002      Masatoshi Kubokura Created.
//
//////////////////////////////////////////////////////////////////////////
INT safe_sprintfA(char* pszDest, size_t cchDest, const char* pszFormat, ...)
{
#ifndef WINNT_40
    HRESULT hr;
    char*   pszDestEnd;
    size_t  cchRemaining;
#endif // !WINNT_40
    va_list argList;
    INT     retSize = 0;

    va_start(argList, pszFormat);
#ifndef WINNT_40
    hr = StringCchVPrintfExA(pszDest, cchDest, &pszDestEnd, &cchRemaining,
                             STRSAFE_NO_TRUNCATION, pszFormat, argList);
    if (SUCCEEDED(hr))
        retSize = cchDest - cchRemaining;
#else  // WINNT_40
    if ((retSize = vsprintf(pszDest, pszFormat, argList)) < 0)
        retSize = 0;
#endif // WINNT_40
    va_end(argList);
    return retSize;
} //*** safe_sprintfA


INT safe_sprintfW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszFormat, ...)
{
#ifndef WINNT_40
    HRESULT hr;
    wchar_t*   pszDestEnd;
    size_t  cchRemaining;
#endif // !WINNT_40
    va_list argList;
    INT     retSize = 0;

    va_start(argList, pszFormat);
#ifndef WINNT_40
    hr = StringCchVPrintfExW(pszDest, cchDest, &pszDestEnd, &cchRemaining,
                             STRSAFE_NO_TRUNCATION, pszFormat, argList);
    if (SUCCEEDED(hr))
        retSize = cchDest - cchRemaining;
#else  // WINNT_40
    if ((retSize = vswprintf(pszDest, pszFormat, argList)) < 0)
        retSize = 0;
#endif // WINNT_40
    va_end(argList);
    return retSize;
} //*** safe_sprintfW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\comoem.cpp ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           COMOEM.CPP

Abstract:       Necessary COM class definition to Unidrv
                OEM rendering plugin module.

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/24/1998 -takashim-
        Written the original sample so that it is more C++.
    02/16/1999 -Masatoshi Kubokura-
        Last modified for Windows2000.
    03/01/2002 -Masatoshi Kubokura-
        Include strsafe.h.
    03/29/2002 -Masatoshi Kubokura-
        Eliminate "#if 0".
        Check return value at OutputCharStr() and SendFontCmd().
        Check NULL pointer at QueryInterface(), EnablePDEV(), and CommandCallback().

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"
#ifndef WINNT_40
#include "strsafe.h"        // @Mar/01/2002
#endif // !WINNT_40

// External Functions' prototype
extern "C" {
extern BOOL APIENTRY bOEMSendFontCmd(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, PFINVOCATION pFInv);
extern BOOL APIENTRY bOEMOutputCharStr(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph);
} // End of extern "C"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
// @Mar/29/2002 ->
        if (NULL == ppv)
            return E_FAIL;
// @Mar/29/2002 <-
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// @Sep/17/98 ->
//      return E_NOTIMPL;

        OEMEnableDriver(dwDriverVersion, cbSize, pded); // @Oct/05/98

        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// @Sep/17/98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// @Sep/17/98 ->
//      return E_NOTIMPL;

        OEMDisableDriver(); // @Oct/05/98
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// @Sep/17/98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
// @Oct/06/98 ->
//      return E_NOTIMPL;
        PDEVOEM pTemp;

// @Mar/29/2002 ->
        if (NULL == pDevOem)
            return E_FAIL;
// @Mar/29/2002 <-

        pTemp = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,  phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

        if (NULL == pTemp)
            return E_FAIL;

        //
        // Save necessary helpder function addresses.
        //
//        ((MINIDEV *)pTemp)->pIntf = this->pOEMHelp;

        *pDevOem = pTemp;
        return S_OK;
// @Oct/06/98 <-
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
// @Oct/05/98 ->
//      return E_NOTIMPL;
        OEMDisablePDEV(pdevobj);
        return S_OK;
// @Oct/05/98 <-
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
// @Mar/29/2002  ->
//         else
//             return S_FALSE;
        else
            return E_FAIL;
// @Mar/29/2002 <-
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));

        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
// @Sep/10/98 ->
//          pIUnknown->AddRef();
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void**)&(this->pOEMHelp));
            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;
                return E_FAIL;
            }
        }
//      this->pOEMHelp = reinterpret_cast<IPrintOemDriverUni*>(pIUnknown);
// @Sep/10/98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
// @Mar/29/2002 ->
        if (NULL == piResult)
            return E_FAIL;
// @Mar/29/2002 <-
        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);
        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        // FilterGraphics disables other compression!
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
// @Jul/29/98 ->
//      return E_NOTIMPL;
        if (0 < (*piResult = OEMCompression(pdevobj, pInBuf, pOutBuf, dwInLen, dwOutLen))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
// @Jul/29/98 <-
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

// @Mar/29/2002 ->
//        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
//        return S_OK;
        if (bOEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph))
            return S_OK;
        else
            return E_FAIL;
// @Mar/29/2002 <-
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
// @Mar/29/2002 ->
//        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
//        return S_OK;
        if (bOEMSendFontCmd(pdevobj, pUFObj, pFInv))
            return S_OK;
        else
            return E_FAIL;
// @Mar/29/2002 <-
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
// @Mar/29/2002 ->
//         return E_FAIL;
        return S_FALSE;
// @Mar/29/2002 <-
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\ddi.c ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           DDI.C

Abstract:       Implementation of OEM DDI exports & OEM DDI hooks.

Functions:      OEMEnablePDEV
                OEMDisablePDEV
                OEMResetPDEV
                OEMEnableDriver
                OEMDisableDriver
                OEMxxx (DDI hooks)

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/97 -zhanw-
        Created it.
    10/05/98 -Masatoshi Kubokura-
        Began to modify for RPDL.
    03/03/99 -Masatoshi Kubokura-
        Last modified for Windows2000.
    03/01/2002 -Masatoshi Kubokura-
        Include strsafe.h.
    03/27/2002 -Masatoshi Kubokura-
        Eliminate "#if 0" if possible.

--*/

#include "pdev.h"
#ifndef WINNT_40
#include "strsafe.h"        // @Mar/01/2002
#endif // !WINNT_40

#if 0 //DBG
#undef VERBOSE
#define VERBOSE WARNING
#endif // if DBG

#ifdef DDIHOOK
static const DRVFN OEMHookFuncs[] =
{
    { INDEX_DrvRealizeBrush,        (PFN) OEMRealizeBrush        },
    { INDEX_DrvDitherColor,         (PFN) OEMDitherColor         },
    { INDEX_DrvCopyBits,            (PFN) OEMCopyBits            },
    { INDEX_DrvBitBlt,              (PFN) OEMBitBlt              },
    { INDEX_DrvStretchBlt,          (PFN) OEMStretchBlt          },
    { INDEX_DrvStretchBltROP,       (PFN) OEMStretchBltROP       },
    { INDEX_DrvPlgBlt,              (PFN) OEMPlgBlt              },
    { INDEX_DrvTransparentBlt,      (PFN) OEMTransparentBlt      },
    { INDEX_DrvAlphaBlend,          (PFN) OEMAlphaBlend          },
    { INDEX_DrvGradientFill,        (PFN) OEMGradientFill        },
    { INDEX_DrvTextOut,             (PFN) OEMTextOut             },
    { INDEX_DrvStrokePath,          (PFN) OEMStrokePath          },
    { INDEX_DrvFillPath,            (PFN) OEMFillPath            },
    { INDEX_DrvStrokeAndFillPath,   (PFN) OEMStrokeAndFillPath   },
    { INDEX_DrvPaint,               (PFN) OEMPaint               },
    { INDEX_DrvLineTo,              (PFN) OEMLineTo              },
    { INDEX_DrvStartPage,           (PFN) OEMStartPage           },
    { INDEX_DrvSendPage,            (PFN) OEMSendPage            },
    { INDEX_DrvEscape,              (PFN) OEMEscape              },
    { INDEX_DrvStartDoc,            (PFN) OEMStartDoc            },
    { INDEX_DrvEndDoc,              (PFN) OEMEndDoc              },
    { INDEX_DrvNextBand,            (PFN) OEMNextBand            },
    { INDEX_DrvStartBanding,        (PFN) OEMStartBanding        },
    { INDEX_DrvQueryFont,           (PFN) OEMQueryFont           },
    { INDEX_DrvQueryFontTree,       (PFN) OEMQueryFontTree       },
    { INDEX_DrvQueryFontData,       (PFN) OEMQueryFontData       },
    { INDEX_DrvQueryAdvanceWidths,  (PFN) OEMQueryAdvanceWidths  },
    { INDEX_DrvFontManagement,      (PFN) OEMFontManagement      },
    { INDEX_DrvGetGlyphMode,        (PFN) OEMGetGlyphMode        }
};
#endif // DDIHOOK


PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)       // Unidrv's hook table
{
    POEMPDEV    poempdev;
    INT         i, j;
    PFN         pfn;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    VERBOSE(("OEMEnablePDEV() entry.\n"));

    // Allocate the OEMPDEV
    if (!(poempdev = MemAlloc(sizeof(OEMPDEV))))
        return NULL;

    // Initialize OEMPDEV
    poempdev->fGeneral1 = poempdev->fGeneral2 = poempdev->fModel = 0;
    poempdev->Scale = VAR_SCALING_DEFAULT;
    poempdev->BaseOffset.x = poempdev->BaseOffset.y = 0;
    poempdev->Offset.x = poempdev->Offset.y = 0;
    poempdev->nResoRatio = MASTERUNIT/240;
    poempdev->TextCurPos.x = poempdev->TextCurPos.y = 0;
    poempdev->TextCurPosRealY = 0;
    poempdev->FontH_DOT = 0;
    poempdev->StapleType = poempdev->PunchType = 0;
    poempdev->CollateType = COLLATE_OFF;
    poempdev->MediaType = MEDIATYPE_STD;        // @Mar/03/99
    poempdev->BindPoint = BIND_ANY;
    poempdev->Nin1RemainPage = 0;
    poempdev->PageMax.x = poempdev->PageMax.y = poempdev->PageMaxMoveY = 32767;
    poempdev->FinisherTrayNum = 1;              // @Jun/25/2001
    poempdev->pRPDLHeap2K = NULL;
#ifdef DOWNLOADFONT
    poempdev->nCharPosMoveX  = 0;
    poempdev->DLFontMaxMemKB = 0;
    poempdev->DLFontMaxID    = DLFONT_ID_4;
    poempdev->DLFontMaxGlyph = DLFONT_GLYPH_TOTAL;
    poempdev->pDLFontGlyphInfo = NULL;
#endif // DOWNLOADFONT

#ifdef DDIHOOK
    // Fill Unidrv's hooks in OEMPDEV
    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        // search through Unidrv's hooks and locate the function ptr
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnUnidrv[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            poempdev->pfnUnidrv[i] = NULL;
        }
    }
#endif // DDIHOOK

    return (POEMPDEV) poempdev;
} //*** OEMEnablePDEV


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    VERBOSE(("OEMDisablePDEV() entry.\n"));

    // free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    MemFree(MINIDEV_DATA(pdevobj));
} //*** OEMDisablePDEV


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
// @Feb/11/99 ->
    POEMPDEV    poempdevOld = MINIDEV_DATA(pdevobjOld);
    POEMPDEV    poempdevNew = MINIDEV_DATA(pdevobjNew);

    VERBOSE(("OEMResetPDEV() entry.\n"));

    if (poempdevOld && poempdevNew)
    {
        LPBYTE      pSrc = (LPBYTE)poempdevOld;
        LPBYTE      pDst = (LPBYTE)poempdevNew;
        DWORD       dwCount = sizeof(OEMPDEV);

        // carry over from old OEMPDEV to new OEMPDEV
        while (dwCount-- > 0)
            *pDst++ = *pSrc++;

        // set pointers of old OEMPDEV to NULL not to free memory
        poempdevOld->pRPDLHeap2K = NULL;
#ifdef DOWNLOADFONT
        poempdevOld->pDLFontGlyphInfo = NULL;
#endif // DOWNLOADFONT
// @Feb/11/99 <-
    }
    return TRUE;
} //*** OEMResetPDEV


VOID APIENTRY OEMDisableDriver()
{
        VERBOSE(("OEMDisableDriver() entry.\n"));
} //*** OEMDisableDriver


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    // VERBOSE(("OEMEnableDriver() entry.\n"));

    // Validate paramters.
    if( (PRINTER_OEMINTF_VERSION != dwOEMintfVersion)
        ||
        (sizeof(DRVENABLEDATA) > dwSize)
        ||
        (NULL == pded)
      )
    {
        //  DbgPrint(ERRORTEXT("OEMEnableDriver() ERROR_INVALID_PARAMETER.\n"));

        return FALSE;
    }

    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION ; //   not  DDI_DRIVER_VERSION;
#ifdef DDIHOOK
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) OEMHookFuncs;
#else
    pded->c = 0;
    pded->pdrvfn = NULL;
#endif // DDIHOOK


    return TRUE;
} //*** OEMEnableDriver


#ifdef DDIHOOK
//
// DDI hooks
//
BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoTrg->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMBitBlt() entry.\n"));

    //
    // turn around to call Unidrv
    //
    return (((PFN_DrvBitBlt)(poempdev->pfnUnidrv[UD_DrvBitBlt])) (
           psoTrg,
           psoSrc,
           psoMask,
           pco,
           pxlo,
           prclTrg,
           pptlSrc,
           pptlMask,
           pbo,
           pptlBrush,
           rop4));
} //*** OEMBitBlt


BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStretchBlt() entry.\n"));

    return (((PFN_DrvStretchBlt)(poempdev->pfnUnidrv[UD_DrvStretchBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDst,
            prclSrc,
            pptlMask,
            iMode));
} //*** OEMStretchBlt


BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStretchBltROP() entry.\n"));

    return (((PFN_DrvStretchBltROP)(poempdev->pfnUnidrv[UD_DrvStretchBltROP])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDst,
            prclSrc,
            pptlMask,
            iMode,
            pbo,
            rop4
            ));
} //*** OEMStretchBltROP


BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDst,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDst,
    POINTL         *pptlSrc)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMCopyBits() entry.\n"));

    return (((PFN_DrvCopyBits)(poempdev->pfnUnidrv[UD_DrvCopyBits])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            pptlSrc));
} //*** OEMCopyBits


BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMPlgBlt() entry.\n"));

    return (((PFN_DrvPlgBlt)(poempdev->pfnUnidrv[UD_DrvPlgBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlBrushOrg,
            pptfixDst,
            prclSrc,
            pptlMask,
            iMode));
} //*** OEMPlgBlt


BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMAlphaBlend() entry.\n"));

    return (((PFN_DrvAlphaBlend)(poempdev->pfnUnidrv[UD_DrvAlphaBlend])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            pBlendObj
            ));
} //*** OEMAlphaBlend


BOOL APIENTRY
OEMGradientFill(
    SURFOBJ    *psoDst,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMGradientFill() entry.\n"));

    return (((PFN_DrvGradientFill)(poempdev->pfnUnidrv[UD_DrvGradientFill])) (
            psoDst,
            pco,
            pxlo,
            pVertex,
            nVertex,
            pMesh,
            nMesh,
            prclExtents,
            pptlDitherOrg,
            ulMode
            ));
} //*** OEMGradientFill


BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMTextOut() entry.\n"));

    return (((PFN_DrvTextOut)(poempdev->pfnUnidrv[UD_DrvTextOut])) (
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix));
} //*** OEMTextOut


BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStokePath() entry.\n"));

    return (((PFN_DrvStrokePath)(poempdev->pfnUnidrv[UD_DrvStrokePath])) (
            pso,
            ppo,
            pco,
            pxo,
            pbo,
            pptlBrushOrg,
            plineattrs,
            mix));
} //*** OEMStrokePath


BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMFillPath() entry.\n"));

    return (((PFN_DrvFillPath)(poempdev->pfnUnidrv[UD_DrvFillPath])) (
            pso,
            ppo,
            pco,
            pbo,
            pptlBrushOrg,
            mix,
            flOptions));
} //*** OEMFillPath


BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStrokeAndFillPath() entry.\n"));

    return (((PFN_DrvStrokeAndFillPath)(poempdev->pfnUnidrv[UD_DrvStrokeAndFillPath])) (
            pso,
            ppo,
            pco,
            pxo,
            pboStroke,
            plineattrs,
            pboFill,
            pptlBrushOrg,
            mixFill,
            flOptions));
} //*** OEMStrokeAndFillPath


BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoTarget->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStrokeAndFillPath() entry.\n"));

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into Unidrv since Unidrv doesn't hook it.
    //

    //
    // In this test DLL, the drawing hooks does not call EngRealizeBrush. So this
    // this function will never be called. Do nothing.
    //

    return TRUE;
} //*** OEMRealizeBrush


BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStartPage() entry.\n"));

    return (((PFN_DrvStartPage)(poempdev->pfnUnidrv[UD_DrvStartPage]))(pso));
} //*** OEMStartPage


#define OEM_TESTSTRING  "The DDICMDCB DLL adds this line of text."

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEndPage() entry.\n"));

#if 0
    //
    // print a line of text, just for testing
    //
    if (pso->iType == STYPE_BITMAP)
    {
        pdevobj->pDrvProcs->DrvXMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvYMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, OEM_TESTSTRING,
                                             sizeof(OEM_TESTSTRING));
    }
#endif

    return (((PFN_DrvSendPage)(poempdev->pfnUnidrv[UD_DrvSendPage]))(pso));
} //*** OEMSendPage


ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEscape() entry.\n"));

    return (((PFN_DrvEscape)(poempdev->pfnUnidrv[UD_DrvEscape])) (
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut));
} //*** OEMEscape


BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStartDoc() entry.\n"));

    return (((PFN_DrvStartDoc)(poempdev->pfnUnidrv[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));
} //*** OEMStartDoc


BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMEndDoc() entry.\n"));

    return (((PFN_DrvEndDoc)(poempdev->pfnUnidrv[UD_DrvEndDoc])) (
            pso,
            fl));
} //*** OEMEndDoc


////////
// NOTE:
// OEM DLL needs to hook out the following six font related DDI calls only
// if it enumerates additional fonts beyond what's in the GPD file.
// And if it does, it needs to take care of its own fonts for all font DDI
// calls and DrvTextOut call.
///////

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG_PTR  *pid)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFont() entry.\n"));

    return (((PFN_DrvQueryFont)(poempdev->pfnUnidrv[UD_DrvQueryFont])) (
            dhpdev,
            iFile,
            iFace,
            pid));
} //*** OEMQueryFont


PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR  *pid)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFontTree() entry.\n"));

    return (((PFN_DrvQueryFontTree)(poempdev->pfnUnidrv[UD_DrvQueryFontTree])) (
            dhpdev,
            iFile,
            iFace,
            iMode,
            pid));
} //*** OEMQueryFontTree


LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryFontData() entry.\n"));

    return (((PFN_DrvQueryFontData)(poempdev->pfnUnidrv[UD_DrvQueryFontData])) (
            dhpdev,
            pfo,
            iMode,
            hg,
            pgd,
            pv,
            cjSize));
} //*** OEMQueryFontData


BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMQueryAdvanceWidths() entry.\n"));

    return (((PFN_DrvQueryAdvanceWidths)
             (poempdev->pfnUnidrv[UD_DrvQueryAdvanceWidths])) (
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs));
} //*** OEMQueryAdvanceWidths


ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut)
{
    //
    // Note that Unidrv will not call OEM DLL for iMode==QUERYESCSUPPORT.
    // So pso is not NULL for sure.
    //
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMFontManagement() entry.\n"));

    return (((PFN_DrvFontManagement)(poempdev->pfnUnidrv[UD_DrvFontManagement])) (
            pso,
            pfo,
            iMode,
            cjIn,
            pvIn,
            cjOut,
            pvOut));
} //*** OEMFontManagement

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMGetGlyphMode() entry.\n"));

    return (((PFN_DrvGetGlyphMode)(poempdev->pfnUnidrv[UD_DrvGetGlyphMode])) (
            dhpdev,
            pfo));
} //*** OEMGetGlyphMode

/////// <- six font related DDI calls


BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMNextBand() entry.\n"));

    return (((PFN_DrvNextBand)(poempdev->pfnUnidrv[UD_DrvNextBand])) (
            pso,
            pptl));
} //*** OEMNextBand


BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMStartBanding() entry.\n"));

    return (((PFN_DrvStartBanding)(poempdev->pfnUnidrv[UD_DrvStartBanding])) (
            pso,
            pptl));
} //*** OEMStartBanding


ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMDitherColor() entry.\n"));

    return (((PFN_DrvDitherColor)(poempdev->pfnUnidrv[UD_DrvDitherColor])) (
            dhpdev,
            iMode,
            rgbColor,
            pulDither));
} //*** OEMDitherColor


BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMPaint() entry.\n"));

    return (((PFN_DrvPaint)(poempdev->pfnUnidrv[UD_DrvPaint])) (
            pso,
            pco,
            pbo,
            pptlBrushOrg,
            mix));
} //*** OEMPaint


BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)pso->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMLineTo() entry.\n"));

    return (((PFN_DrvLineTo)(poempdev->pfnUnidrv[UD_DrvLineTo])) (
            pso,
            pco,
            pbo,
            x1,
            y1,
            x2,
            y2,
            prclBounds,
            mix));
} //*** OEMLineTo


BOOL APIENTRY
OEMTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved)
{
    PDEVOBJ     pdevobj  = (PDEVOBJ)psoDst->dhpdev;
    POEMPDEV    poempdev = MINIDEV_DATA(pdevobj);

    VERBOSE(("OEMTransparentBlt() entry.\n"));

    return (((PFN_DrvTransparentBlt)(poempdev->pfnUnidrv[UD_DrvTransparentBlt])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            iTransColor,
            ulReserved
            ));
} //*** OEMTransparentBlt
#endif // DDIHOOK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\debug.c ===
#include <minidrv.h>

VOID DbgPrint(LPCSTR lpszMessage,  ...)
{
    char    szMsgBuf[1024];
    va_list VAList;

    if(NULL != lpszMessage)
    {
        // Dump string to debug output.
        va_start(VAList, lpszMessage);
        wvsprintfA(szMsgBuf, lpszMessage, VAList);
        OutputDebugStringA(szMsgBuf);
        va_end(VAList);
    }
    return;
} //*** DbgPrint


//////////////////////////////////////////////////////////////////////////
//  Function:   DebugMsgA
//
//  Description:  Outputs variable argument ANSI debug string.
//    
//
//  Parameters:
//
//      lpszMessage     Format string.
//
//
//  Returns:  TRUE on success and FALSE on failure.
//    
//
//  Comments:
//     
//
//  History:
//      12/18/96    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMsgA(LPCSTR lpszMessage, ...)
{
#if DBG || defined(_DEBUG)
    BOOL    bResult = FALSE;
    char    szMsgBuf[1024];
    va_list VAList;


    if(NULL != lpszMessage)
    {
        // Dump string to debug output.
        va_start(VAList, lpszMessage);
        wvsprintfA(szMsgBuf, lpszMessage, VAList);
        OutputDebugStringA(szMsgBuf);
        va_end(VAList);
        bResult = FALSE;
    }

    return bResult;
#else
    return TRUE;
#endif
} //*** DebugMsgA


//////////////////////////////////////////////////////////////////////////
//  Function:   DebugMsgW
//
//  Description:  Outputs variable argument UNICODE debug string.
//    
//
//  Parameters:
//
//      lpszMessage     Format string.
//
//
//  Returns:  TRUE on success and FALSE on failure.
//    
//
//  Comments:
//     
//
//  History:
//      12/18/96    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMsgW(LPCWSTR lpszMessage, ...)
{
#if DBG || defined(_DEBUG)
    BOOL    bResult = FALSE;
    WCHAR   szMsgBuf[1024];
    va_list VAList;


    if(NULL != lpszMessage)
    {
        // Dump string to debug output.
        va_start(VAList, lpszMessage);
        wvsprintfW(szMsgBuf, lpszMessage, VAList);
        OutputDebugStringW(szMsgBuf);
        va_end(VAList);
        bResult = FALSE;
    }

    return bResult;
#else
    return TRUE;
#endif
} //*** DebugMsgW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
    "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",        // This disables other compression.
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

/*++

Copyright (c) 1996-2001  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           PDEV.H

Abstract:       Header file for OEM UI & rendering plugin.

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/15/1999 -Masatoshi Kubokura-
        Last modified for Windows2000.
    02/05/2001 -Masatoshi Kubokura-
        Add "Thick Paper"
        Last modified for Whistler.
    06/29/2001 -Masatoshi Kubokura-
        V.1.07
        Add FinisherTrayNum

--*/


//
// Files necessary for OEM plug-in.
//

#include <windows.h>   // for UI
#include <compstui.h>  // for UI
#include <winddiui.h>  // for UI
#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define MASTERUNIT          1200
#define DEVICE_MASTER_UNIT  7200
#define DRIVER_MASTER_UNIT  MASTERUNIT

//
// Compile options
//
#define DOWNLOADFONT        // support TrueType download
//#define JISGTT            // Current GTT is JIS code set
//#define DDIHOOK           // ddi hook is available
//#define JOBLOGSUPPORT_DM  // Job/Log is supported (about devmode)
//#define JOBLOGSUPPORT_DLG // Job/Log is supported (about dialog)

//
// Misc definitions follows.
//
#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))
#define MINIDEV_DATA(p) \
    ((POEMPDEV)((p)->pdevOEM))          // device data during job
#define MINIPRIVATE_DM(p) \
    ((POEMUD_EXTRADATA)((p)->pOEMDM))   // private devmode
// OBSOLETE  @Sep/27/99 ->
//#define UI_GETDRIVERSETTING(p1, p2, p3, p4, p5, p6) \
//    ((p1)->pOemUIProcs->DrvGetDriverSetting(p1, p2, p3, p4, p5, p6))
// @Sep/27/99 <-

// ASSERT(VALID_PDEVOBJ) can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

// Debug text.
#if DBG
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)
#ifdef UIMODULE
#define DLLTEXT(s)      "RPDLUI: " s
#else  // !UIMODULE
#define DLLTEXT(s)      "RPDLRES: " s
#endif // !UIMODULE
#endif // DBG

////////////////////////////////////////////////////////
// OEM Signature and version.
////////////////////////////////////////////////////////
#define OEM_SIGNATURE   'RPDL'      // RICOH RPDL printers
#define OEM_VERSION      0x00010000L

////////////////////////////////////////////////////////
// DDI hooks
// Warning: the following enum order must match the
//           order in OEMHookFuncs[].
////////////////////////////////////////////////////////
#ifdef DDIHOOK
enum {
    UD_DrvRealizeBrush,
    UD_DrvDitherColor,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvPaint,
    UD_DrvLineTo,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvNextBand,
    UD_DrvStartBanding,
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,

    MAX_DDI_HOOKS,
};
#endif // DDIHOOK


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////
#define ABS(x) ((x > 0)? (x):-(x))

// heap memory size
#define HEAPSIZE64                  64    // this must be bigger than 32
#define HEAPSIZE2K                  2048  // @Sep/09/98

#ifdef DOWNLOADFONT
// definitions for download font
#define MEM128KB                    128 // Kbyte
#define MEM256KB                    256
#define MEM512KB                    512
#define DLFONT_ID_4                 4   // 4 IDs
#define DLFONT_ID_8                 8   // 8 IDs
#define DLFONT_ID_16                16  // 16 IDs  @Oct/20/98
#define DLFONT_ID_MIN_GPD           0   // *MinFontID in GPD
#define DLFONT_ID_MAX_GPD           15  // *MaxFontID in GPD (6->3 @May/07/98,->7 @Jun/17/98,->15 @Oct/20/98)
#define DLFONT_ID_TOTAL             (DLFONT_ID_MAX_GPD - DLFONT_ID_MIN_GPD + 1)
#define DLFONT_GLYPH_MIN_GPD        0   // *MinGlyphID in GPD
#define DLFONT_GLYPH_MAX_GPD        69  // *MaxGlyphID in GPD (103->115 @May/07/98,->69 @Oct/20/98)
#define DLFONT_GLYPH_TOTAL          (DLFONT_GLYPH_MAX_GPD - DLFONT_GLYPH_MIN_GPD + 1)
#define DLFONT_SIZE_DBCS11PT_MU     216 // actual value(MSMincho 400dpi)    @Nov/18/98
#define DLFONT_SIZE_DBCS9PT_MU      160 // actual value(MSMincho 600dpi)    @Nov/18/98
#define DLFONT_SIZE_SBCS11PT_MU     512 // actual value(Arial&Times 600dpi) @Nov/18/98
#define DLFONT_SIZE_SBCS9PT_MU      192 // actual value(Century 400&600dpi) @Nov/18/98
#define DLFONT_HEADER_SIZE          16  // RPDL header size of each download character
#define DLFONT_MIN_BLOCK            32  // RPDL min block size: 32bytes
#define DLFONT_MIN_BLOCK_ID         5   // RPDL min block size ID of 32bytes

typedef struct
{
    SHORT   nPitch;
    SHORT   nOffsetX;
    SHORT   nOffsetY;
} FONTPOS, FAR *LPFONTPOS;
#endif // DOWNLOADFONT


// buffer size
#define FAXBUFSIZE256               256
#define FAXEXTNUMBUFSIZE            8
#define FAXTIMEBUFSIZE              6
#define MY_MAX_PATH                 80  // 100->80 @Sep/02/99
#define USERID_LEN                  8
#define PASSWORD_LEN                4
#define USERCODE_LEN                8

// private devmode
typedef struct _OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
// common data between UI & rendering plugin ->
    DWORD   fUiOption;          // bit flags for UI option  (This must be after dmExtraHdr)
    WORD    UiScale;            // variable scaling value (%)
    WORD    UiBarHeight;        // barcode height (mm)
    WORD    UiBindMargin;       // left or upper binding margin at duplex printing (mm)
    SHORT   nUiTomboAdjX;       // horizontal distance adjustment at TOMBO (0.1mm unit)
    SHORT   nUiTomboAdjY;       // vertical distance adjustment at TOMBO (0.1mm unit)
    // We use private devmode, not use file, because EMF disables reading/writing the file.
    BYTE    FaxNumBuf[FAXBUFSIZE256];       // fax number
    BYTE    FaxExtNumBuf[FAXEXTNUMBUFSIZE]; // extra number (external)
    BYTE    FaxSendTime[FAXTIMEBUFSIZE];    // reservation time
    WORD    FaxReso;            // fax send resolution (0:400,1:200,2:100dpi)
    WORD    FaxCh;              // fax send channel (0:G3,1:G4,2:G3-1ch,3:G3-2ch)
#ifdef JOBLOGSUPPORT_DM
    WORD    JobType;
    WORD    LogDisabled;
    BYTE    UserIdBuf[USERID_LEN+1];
    BYTE    PasswordBuf[PASSWORD_LEN+1];
    BYTE    UserCodeBuf[USERCODE_LEN+1];
#endif // JOBLOGSUPPORT_DM
    WCHAR   SharedFileName[MY_MAX_PATH+16]; // shared data file name  @Aug/31/99 (+16 @Sep/02/99)
// <-
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;


#ifndef GWMODEL
// Fax options for UI plugin
typedef struct _UIDATA{
    DWORD   fUiOption;
    HANDLE  hPropPage;
    HANDLE  hComPropSheet;
    PFNCOMPROPSHEET   pfnComPropSheet;
    POEMUD_EXTRADATA  pOEMExtra;
    WCHAR   FaxNumBuf[FAXBUFSIZE256];
    WCHAR   FaxExtNumBuf[FAXEXTNUMBUFSIZE];
    WCHAR   FaxSendTime[FAXTIMEBUFSIZE];
    WORD    FaxReso;
    WORD    FaxCh;
// temporary save buffer ->
    DWORD   fUiOptionTmp;
    WCHAR   FaxSendTimeTmp[FAXTIMEBUFSIZE];
    WORD    FaxResoTmp;
    WORD    FaxChTmp;
// <-
} UIDATA, *PUIDATA;

#else  // GWMODEL
// Job/Log options for UI plugin
typedef struct _UIDATA{
    DWORD   fUiOption;
    HANDLE  hPropPage;
    HANDLE  hComPropSheet;
    PFNCOMPROPSHEET   pfnComPropSheet;
    POEMUD_EXTRADATA  pOEMExtra;
    WORD    JobType;
    WORD    LogDisabled;
    WCHAR   UserIdBuf[USERID_LEN+1];
    WCHAR   PasswordBuf[PASSWORD_LEN+1];
    WCHAR   UserCodeBuf[USERCODE_LEN+1];
} UIDATA, *PUIDATA;
#endif // GWMODEL


// shared file data for UI & rendering plugin
typedef struct _FILEDATA{
    DWORD   fUiOption;          // UI option flag
} FILEDATA, *PFILEDATA;


// rendering plugin device data (separate OEMUD_EXTRADATA @Oct/05/98)
typedef struct _OEMPDEV {
    DWORD   fGeneral1;          // bit flags for RPDL general status(1)
    DWORD   fGeneral2;          // bit flags for RPDL general status(2)
    DWORD   fModel;             // bit flags for printer models
    DWORD   dwFontH_CPT;        // font height(cpt) for AssignIBMfont()  (1cpt=1/7200inch)
    DWORD   dwFontW_CPT;        // font width (cpt) for AssignIBMfont()
    WORD    FontH_DOT;          // font height(dot) for TextMode clipping
    WORD    DocPaperID;         // document papersize ID
    SHORT   nResoRatio;         // MASTERUNIT divided by resolution (short->SHORT @Sep/14/98)
    WORD    Scale;              // scaling value for offset calculation
    POINT   TextCurPos;         // TextMode current position
    POINT   PageMax;            // x:page_width, y:page_length
    POINT   Offset;             // total offset
    POINT   BaseOffset;         // offset by PrinterProperty or offset for MF530,150(e),160
    LONG    PageMaxMoveY;       // RPDL max y_position  int->LONG @Aug/28/98
    LONG    TextCurPosRealY;    // TextMode current position y without page_length adjustment
    DWORD   dwBarRatioW;        // barcode width ratio (ratio_1.0=1000)
    SHORT   nBarType;           // barcode type
    SHORT   nBarMaxLen;         // barcode character max length
    WORD    StapleType;         // staple  (0:disable,1:1staple,2:2staples)
    WORD    PunchType;          // punch   (0:disable,1:enable)
    WORD    CollateType;        // collate (0:disable,1:enable,2:uni-dir,3:rotated,4:shifted)
    WORD    MediaType;          // media type (0:standard,1:OHP,2:thick,3:special)
    WORD    BindPoint;          // staple/punch point
    WORD    Nin1RemainPage;     // remain pages in Nin1 (2in1:0-1,4in1:0-3)
    WORD    TextRectGray;       // gray percentage(1-100) of TextMode Rectangle
    POINT   TextRect;           // height & width of TextMode Rectangle
    POINT   TextRectPrevPos;    // previous position of TextMode Rectangle
    DWORD   PhysPaperWidth;     // paper width for CustomSize
    DWORD   PhysPaperLength;    // paper length for CustomSize
    DWORD   dwSrcBmpWidthByte;  // for raster data emission (width in byte)
    DWORD   dwSrcBmpHeight;     // for raster data emission (height in dot)
    PBYTE   pRPDLHeap2K;        // heap memory for OEMOutputCharStr&OEMDownloadCharGlyph @Sep/09/98
    BYTE    RPDLHeap64[HEAPSIZE64]; // 64byte heap memory
    WORD    RPDLHeapCount;      // current heap usage
    WORD    FinisherTrayNum;    // finisher shift tray# @Jun/25/2001
#ifdef DOWNLOADFONT
    DWORD   dwDLFontUsedMem;    // used memory size for Download font
    WORD    DLFontCurGlyph;
    WORD    DLFontMaxMemKB;
    WORD    DLFontMaxID;
    WORD    DLFontMaxGlyph;
    SHORT   nCharPosMoveX;
    FONTPOS* pDLFontGlyphInfo;  // download glyph info (array->pointer @Sep/08/98)
#endif // DOWNLOADFONT
#ifdef DDIHOOK
    PFN     pfnUnidrv[MAX_DDI_HOOKS];   // Unidrv's hook function pointer
#endif // DDIHOOK
} OEMPDEV, *POEMPDEV;


// bit definitions of fGeneral1
#define RLE_COMPRESS_ON          0  // Raster image compression is on (<-IMAGE_NOCOMPRESS  MSKK)
#define TEXT_CLIP_VALID          1  // TextMode(font/image) clipping is valid
#define TEXT_CLIP_SET_GONNAOUT   2  // TextMode clipping-set command is going to be outputed
#define TEXT_CLIP_CLR_GONNAOUT   3  // TextMode clipping-clear command is going to be outputed
#define FONT_VERTICAL_ON         4  // vertical font mode on
#define FONT_BOLD_ON             5  // bold on
#define FONT_ITALIC_ON           6  // italic on
#define FONT_WHITETEXT_ON        7  // white text on
#define ORIENT_LANDSCAPE         8  // orientation is landscape
#define SWITCH_PORT_LAND         9  // switching portrait/landscape is needed
#define DUPLEX_LEFTMARGIN_VALID  10 // left margin at duplex printing is set
#define DUPLEX_UPPERMARGIN_VALID 11 // upper margin at duplex printing is set
#define PAPER_CUSTOMSIZE         12 // Paper is CustomSize
#define PAPER_DOUBLEPOSTCARD     13 // Paper is DoublePostcard
#define IMGCTRL_2IN1_67          14 // ImageControl:2in1(Scale 67%)
#define IMGCTRL_2IN1_100         15 // ImageControl:2in1(Scale 100%)
#define IMGCTRL_4IN1_50          16 // ImageControl:4in1(Scale 50%)
#define IMGCTRL_AA67             17 // ImageControl:A->A(Scale 67%)
#define IMGCTRL_BA80             18 // ImageControl:B->A(Scale 80%)
#define IMGCTRL_BA115            19 // ImageControl:B->A(Scale 115%)
#define DUPLEX_VALID             20 // duplex is valid
#define XM_ABS_GONNAOUT          21 // Move_X command is going to be outputed
#define YM_ABS_GONNAOUT          22 // Move_Y command is going to be outputed
#define CUSTOMSIZE_USE_LAND       23 // orientation adjustment in CustomSize
#define CUSTOMSIZE_MAKE_LAND_PORT 24 // orientation adjustment in CustomSize
#define IMGCTRL_AA141            25 // ImageControl:A->A(Scale 141%)
#define IMGCTRL_AA200            26 // ImageControl:A->A(Scale 200%)
#define IMGCTRL_AA283            27 // ImageControl:A->A(Scale 283%)
#define IMGCTRL_A1_400           28 // ImageControl:A1(Scale 400%)
//#define MEDIATYPE_OHP            29 // MediaType:Transparency(OHP)
//#define MEDIATYPE_THICK          30 // MediaType:Thick Paper
//#define MEDIATYPE_CHANGED        31 // MediaType is changed
#define VARIABLE_SCALING_VALID   29 // variable scaling command emitted  @Jan/27/2000

// bit definitions of fGeneral2
//   if you modify them, don't forget to update BITCLR_BARCODE below
#define BARCODE_MODE_IN          0  // enter barcode mode
#define BARCODE_DATA_VALID       1  // barcode data is valid
#define BARCODE_FINISH           2  // barcode data is finished
#define BARCODE_CHECKDIGIT_ON    3  // add checkdigit in barcode
#define BARCODE_ROT90            4  // vartical(rotation90) barcode
#define BARCODE_ROT270           5  // vartical(rotation270) barcode
#define TEXTRECT_CONTINUE        6  // TextMode Rectangle drawing continues
#define EDGE2EDGE_PRINT          7  // Edge to Edge printing
#define LONG_EDGE_FEED           8  // Long Edge Feed at Multi Tray
#define OEM_COMPRESS_ON          9  // OEM Compress is available
#define DIVIDE_DATABLOCK         10 // Divide raster data block for SP4mkII,5,7,8

// bit definitions of fModel
//   if you modify this, don't forget to update PRODUCTS_SINCExx or follows.
#define GRP_MF530                0  // model=MF530
#define GRP_MF150                1  // model=MF150
#define GRP_MF150E               2  // model=MF150e,160
#define GRP_MFP250               3  // model=MF-P250,355,250(FAX),355(FAX),MF-FD355
#define GRP_SP4II                4  // model=SP4mkII,5
#define GRP_SP8                  5  // model=SP7,8,7mkII,8mkII,80
#define GRP_SP10                 6  // model=SP-10,10mkII
#define GRP_SP9                  7  // model=SP9,10Pro
#define GRP_SP9II                8  // model=SP9II,10ProII,90
#define GRP_NX100                9  // model=NX-100
#define GRP_NX500                10 // model=NX-500,1000,110,210,510,1100
//#define GRP_MFP250E              11 // model=MF-P250e,355e
#define GRP_MF250M               11 // model=MF250M
#define GRP_MF3300               13 // model=MF3300W,3350W,3540W,3580W
#define GRP_IP1                  14 // model=IP-1
#define GRP_NX70                 15 // model=NX70,71
#define GRP_NX700                16 // model=NX700,600,FAX Printer,MF700
#define GRP_MF200                17 // model=MF200,MF-p150,MF2200  (separate GRP_SP9II @Sep/01/98)
#define GRP_NX900                18 // model=NX900
#define GRP_NX710                20 // model=710,610 (separate GRP_MF1530 @Jun/23/2000)
#define GRP_NX720                21 // model=NX620,620N,720N,Neo350,350D,450,220,270
// @Jun/25/2001 ->
//#define GRP_MF3550               12 // model=MF2700,3500,3550,4550,5550,6550,3530,3570,4570,
//                                    // 5550EX,6550EX,3530e,3570e,4570e,5570,7070,8570,105Pro
//#define GRP_MF1530               19 // model=MF1530,2230,2730,NX800,910,810
#define GRP_MF3550               12 // model=MF2700,3500,3550,4550,5550,6550,3530,3570,4570,5550EX,6550EX,1530
#define GRP_NX800                19 // model=NX800,810,910,MF2230,2730  (remove MF1530, and rename GRP_MF1530)
#define GRP_MF3530E              22 // model=MF3530e,3570e,4570e,5570,7070,8570,105Pro
// @Jun/25/2001 ->

/// bit definitions of fUiOption
#define FAX_SEND                 0  // 1=send fax at imagio FAX
#define FAX_USEADDRESSBOOK       1  // 1=use addressbook
#define HOLD_OPTIONS             2  // 1=hold options after sending
#define FAX_SETTIME              3  // 1=reservation time available
#define FAX_SIMULPRINT           4  // 1=send fax and print simultaneously
#define FAX_RPDLCMD              5  // 1=send RPDL command
#define FAX_MH                   6  // 0=use MMR, 1=use MH
#define PRINT_DONE               7  // 1=print done (rendering plugin set this)
#define DISABLE_BAR_SUBFONT      8  // disable printing readable font under barcode
#define ENABLE_BIND_RIGHT        9  // enable stapling right side
#define ENABLE_TOMBO             10 // print TOMBO  @Sep/14/98
//   UI plugin local ->
#define OPT_NODUPLEX             16
#define OPT_VARIABLE_SCALING     17
#define FAX_MODEL                18
#define FAXMAINDLG_UPDATED       19 // 1=fax main dialog updated
#define FAXSUBDLG_UPDATED        20 // 1=fax sub dialog updated
#define FAXSUBDLG_UPDATE_APPLIED 21 // 1=fax sub dialog update applied
#define FAXSUBDLG_INITDONE       22
#define UIPLUGIN_NOPERMISSION    23 // same as DM_NOPERMISSION
#define JOBLOGDLG_UPDATED        24 // 1=Job/Log dialog updated
// <-

// staple/punch point in duplex printing(BindPoint)
#define BIND_ANY                 0
#define BIND_LEFT                1
#define BIND_RIGHT               2
#define BIND_UPPER               3

// flag bit operation
#define BIT(num)                ((DWORD)1<<(num))
#define BITCLR32(flag,num)      ((flag) &= ~BIT(num))
#define BITSET32(flag,num)      ((flag) |= BIT(num))
#define BITTEST32(flag,num)     ((flag) & BIT(num))
#define TO1BIT(flag,num)        (((flag)>>(num)) & (DWORD)1)
#define BITCPY32(dst,src,num)   ((dst) = ((DWORD)(src) & BIT(num))? \
                                (DWORD)(dst) | BIT(num) : (DWORD)(dst) & ~BIT(num))
#define BITNCPY32(dst,src,num)  ((dst) = ((DWORD)(src) & BIT(num))? \
                                (DWORD)(dst) & ~BIT(num) : (DWORD)(dst) | BIT(num))
#define TEST_OBJ_CHANGE(flag)   ((flag) & (BIT(BRUSH_CHANGE)|BIT(PEN_CHANGE)| \
                                           BIT(SCAN_PEN_WIDTH_1)|BIT(SCAN_PEN_WIDTH_ORG)))
#define TEST_2IN1_MODE(flag)    ((flag) & (BIT(IMGCTRL_2IN1_100)|BIT(IMGCTRL_2IN1_67)))
#define TEST_4IN1_MODE(flag)    ((flag) & (BIT(IMGCTRL_4IN1_50)))
#define TEST_NIN1_MODE(flag)    ((flag) & (BIT(IMGCTRL_2IN1_100)|BIT(IMGCTRL_2IN1_67)|BIT(IMGCTRL_4IN1_50)))
#define BITCLR_NIN1_MODE(flag)  ((flag) &= ~(BIT(IMGCTRL_2IN1_100)|BIT(IMGCTRL_2IN1_67)|BIT(IMGCTRL_4IN1_50)))
#define TEST_SCALING_SEL_TRAY(flag)   ((flag) & (BIT(IMGCTRL_AA67)|BIT(IMGCTRL_BA80)|BIT(IMGCTRL_BA115)|BIT(IMGCTRL_AA141)|BIT(IMGCTRL_AA200)|BIT(IMGCTRL_AA283)|BIT(IMGCTRL_A1_400)))
#define BITCLR_SCALING_SEL_TRAY(flag) ((flag) &= ~(BIT(IMGCTRL_AA67)|BIT(IMGCTRL_BA80)|BIT(IMGCTRL_BA115)|BIT(IMGCTRL_AA141)|BIT(IMGCTRL_AA200)|BIT(IMGCTRL_AA283)|BIT(IMGCTRL_A1_400)))
#define BITCLR_BARCODE(flag)    ((flag) &= ~(BIT(BARCODE_MODE_IN)|BIT(BARCODE_DATA_VALID)| \
                                             BIT(BARCODE_FINISH)|BIT(BARCODE_CHECKDIGIT_ON)| \
                                             BIT(BARCODE_ROT90)|BIT(BARCODE_ROT270)))
#define BITCLR_UPPER_FLAG(flag) ((flag) &= 0x0000FFFF)

// models since 2000
#define PRODUCTS_SINCE2000      (BIT(GRP_NX720))
// models since '99
#define PRODUCTS_SINCE99        (BIT(GRP_NX900)|BIT(GRP_NX800)|BIT(GRP_NX710)|PRODUCTS_SINCE2000)
// models since '98
#define PRODUCTS_SINCE98        (BIT(GRP_MF3550)|BIT(GRP_MF3530E)|BIT(GRP_MF3300)|BIT(GRP_NX70)|BIT(GRP_NX700)|PRODUCTS_SINCE99)
// models since '97 (delete GRP_MFP250E  @Apr/15/99)
#define PRODUCTS_SINCE97        (BIT(GRP_NX500)|BIT(GRP_MF250M)|PRODUCTS_SINCE98)
// models since '96 (add GPR_MF200 @Sep/01/98)
#define PRODUCTS_SINCE96        (BIT(GRP_SP9II)|BIT(GRP_MF200)|BIT(GRP_NX100)|PRODUCTS_SINCE97)

// capabilty of media type option(Standard, OHP, Thick)
#define TEST_CAPABLE_MEDIATYPE(flag)  ((flag) & (BIT(GRP_MF3550)|BIT(GRP_MF3530E)|BIT(GRP_NX800)|BIT(GRP_NX710)|BIT(GRP_NX720)))

// A2 printer
#define TEST_CAPABLE_PAPER_A2(flag)   ((flag) & (BIT(GRP_MF3300)))

// scailing over 141% of A2 printer/A1 plotter
#define TEST_PLOTTERMODEL_SCALING(flag)    ((flag) & (BIT(GRP_MF3300)|BIT(GRP_IP1)))

// A3 printer && CustomSize width == 297
#define TEST_CAPABLE_PAPER_A3_W297(flag)   ((flag) & (PRODUCTS_SINCE97 & ~BIT(GRP_MF3300)))

//// dual RPGL(RPGL&RPGL2) in memory card
//#define TEST_CAPABLE_DUALRPGL(flag)   ((flag) & (PRODUCTS_SINCE97 & ~BIT(GRP_MF250M)))

// A4 printer
#define TEST_CAPABLE_PAPER_A4MAX(flag)  ((flag) & (BIT(GRP_NX70)))

// capability of Select_Tray_by_Papersize("papername+X")
#define TEST_CAPABLE_PAPERX(flag)       ((flag) & (BIT(GRP_MF150E)|BIT(GRP_MFP250)|BIT(GRP_IP1)|PRODUCTS_SINCE96))

// fixed bug about reset smoothing/tonner_save_mode at ENDDOC (We must not reset SP8 series.)
#define TEST_BUGFIX_RESET_SMOOTH(flag)  ((flag) & (BIT(GRP_SP10)|BIT(GRP_SP9)|PRODUCTS_SINCE96))

// fixed bug about formfeed around ymax-coordinate.
#define TEST_BUGFIX_FORMFEED(flag)      ((flag) & PRODUCTS_SINCE98)

// DeltaRow Compression while TrueType font downloading
#define TEST_CAPABLE_DOWNLOADFONT_DRC(flag)  ((flag) & (BIT(GRP_NX70)|BIT(GRP_NX700)|PRODUCTS_SINCE99))

// GW architecture model
#define TEST_GWMODEL(flag)              ((flag) & (BIT(GRP_NX720)))

// RPDL(NX800 etc) bug: Job define command is needed for shifted collate or staple  @Jun/29/2001
#define TEST_NEED_JOBDEF_CMD(flag)      ((flag) & (BIT(GRP_MF3530E)|BIT(GRP_NX800)|BIT(GRP_NX720)))

#define TEST_AFTER_SP9II(flag)  ((flag) & PRODUCTS_SINCE96)
#define TEST_AFTER_SP10(flag)   ((flag) & (BIT(GRP_SP10)|BIT(GRP_SP9)|BIT(GRP_MFP250)|BIT(GRP_IP1)|PRODUCTS_SINCE96))
#define TEST_AFTER_SP8(flag)    ((flag) & (BIT(GRP_SP8)|BIT(GRP_SP10)|BIT(GRP_SP9)|BIT(GRP_MFP250)|BIT(GRP_IP1)|PRODUCTS_SINCE96))
#define TEST_GRP_240DPI(flag)   ((flag) & (BIT(GRP_SP4II)|BIT(GRP_SP8)))
#define TEST_GRP_OLDMF(flag)    ((flag) & (BIT(GRP_MF530)|BIT(GRP_MF150)|BIT(GRP_MF150E)))
#define TEST_MAXCOPIES_99(flag) ((flag) & (BIT(GRP_SP4II)|BIT(GRP_SP8)|BIT(GRP_SP10)|BIT(GRP_SP9)|BIT(GRP_MF150)|BIT(GRP_MF150E)|BIT(GRP_MF200)|BIT(GRP_MF250M)|BIT(GRP_IP1)))  // @Sep/01/98


// approximate value for using 10pt raster font (240dpi model) & standard width of
// barcode.
// if you make NEAR10PT_MIN less, see font-clipping at OEMOutputChar() of rpdlms.c
#define NEAR10PT_MIN                900     // 9pt
#define NEAR10PT_MAX                1110    // 11pt

// RPDL characters assigned block for AssignIBMfont()
#define IBMFONT_ENABLE_ALL          1       // <-JIS1_BLOCK @Sep/14/98
#define IBMFONT_RESUME              4       // <-INSUFFICIENT_BLOCK @Sep/14/98

// DrawTOMBO() action item  @Sep/14/98
#define INIT_TOMBO                  0
#define DRAW_TOMBO                  1

// RPDL GrayFill
#define RPDLGRAYMAX                 64
#define RPDLGRAYMIN                 2  // @Aug/15/98

// RPDL staple position
#define STAPLE_UPPERLEFT            0   // upper left
#define STAPLE_LEFT2                2   // left 2 position
#define STAPLE_RIGHT2               10  // right 2 position
#define STAPLE_UPPERRIGHT           12  // upper right
#define STAPLE_UPPER2               14  // upper 2 position
#define STAPLE_UPPERLEFT_CORNER     0   // upper left  (corner mode)
#define STAPLE_UPPERRIGHT_CORNER    3   // upper right (corner mode)

// RPDL punch position
#define PUNCH_LEFT                  0
#define PUNCH_RIGHT                 2
#define PUNCH_UPPER                 3

// collate type
#define COLLATE_OFF                 0
#define COLLATE_ON                  1
#define COLLATE_UNIDIR              2
#define COLLATE_ROTATED             3
#define COLLATE_SHIFTED             4

// media type
#define MEDIATYPE_STD               0   // Standard
#define MEDIATYPE_OHP               1   // Transparency(OHP)
#define MEDIATYPE_THICK             2   // Thick Paper
#define MEDIATYPE_SPL               3   // Special
#define MEDIATYPE_TRACE             4   // Tracing Paper
#define MEDIATYPE_LABEL             12  // Labels
#define MEDIATYPE_THIN              20  // Thin Paper

// definition for barcode
#define BARCODE_MAX                 HEAPSIZE64  // max# of barcode character
#define BAR_UNIT_JAN                330 // 0.33mm:default module unit of JAN
#define BAR_UNIT1_2OF5              300 // 0.3mm: default module unit1 of 2of5,CODE39
#define BAR_UNIT2_2OF5              750 // 0.75mm:default module unit2 of 2of5,CODE39
#define BAR_UNIT1_NW7               210 // 0.21mm:default module unit1 of NW-7
#define BAR_UNIT2_NW7               462 // 0.462mm:default module unit2 of NW-7
#define BAR_W_MIN_5PT               504 // scaling minimum limit of 5pt
#define BAR_H_DEFAULT               10  // 10mm:default bar height
#define BAR_H_MAX                   999 // 999mm:max bar height
#define BAR_H_MIN                   1   // 1mm:min bar height
// @Feb/08/2000 ->
#define BAR_TYPE_JAN_STD            0   // JAN(STANDARD)
#define BAR_TYPE_JAN_SHORT          1   // JAN(SHORT)
#define BAR_TYPE_2OF5IND            2   // 2of5(INDUSTRIAL)
#define BAR_TYPE_2OF5MTX            3   // 2of5(MATRIX)
#define BAR_TYPE_2OF5ITF            4   // 2of5(ITF)
#define BAR_TYPE_CODE39             5   // CODE39
#define BAR_TYPE_NW7                6   // NW-7
#define BAR_TYPE_CUSTOMER           7   // CUSTOMER
#define BAR_TYPE_CODE128            8   // CODE128
#define BAR_TYPE_UPC_A              9   // UPC(A)
#define BAR_TYPE_UPC_E              10  // UPC(E)
#define BAR_H_CUSTOMER              36  // 3.6mm:default bar height
#define BAR_CODE128_START           104 // CODE128-B start character
// @Feb/08/2000 <-

// max/min binding margin in RPDL
#define BIND_MARGIN_MAX             50
#define BIND_MARGIN_MIN             0

// variable scaling
#define VAR_SCALING_DEFAULT         100
#define VAR_SCALING_MAX             200
#ifndef GWMODEL     // @Sep/21/2000
#define VAR_SCALING_MIN             50
#else  // GWMODEL
#define VAR_SCALING_MIN             40
#endif // GWMODEL

// adjust distance of TOMBO
#define DEFAULT_0                   0
#define TOMBO_ADJ_MAX               50
#define TOMBO_ADJ_MIN               (-50)

// margin to disable FF by RPDL
#define DISABLE_FF_MARGIN_STD       48  // unit:masterunit
#define DISABLE_FF_MARGIN_E2E       72  // unit:masterunit  at Edge to Edge Print

// for clipping of font at paper bottom
#define CLIPHEIGHT_12PT             100 // (dot) 12pt at 600dpi

// clear clipping
#define CLIP_IFNEED                 0
#define CLIP_MUST                   1

// user defined papersize
#define USRD_W_A3_OLD               296
#define USRD_W_A3                   297
#define USRD_W_A2                   432
#define USRD_W_A4                   216
#define USRD_H_MIN148               148


// font resource # in GPD (if you reorder of PFM files at GPD, check here.)
#define EURO_FNT_FIRST              1
#define BOLDFACEPS                  2
#define EURO_MSFNT_FIRST            5
#define SYMBOL                      18
#define EURO_FNT_LAST               19      // if you change this, watch TEST_VERTICALFONT below.
#define JPN_FNT_FIRST               (EURO_FNT_LAST+1)
#define MINCHO_1                    JPN_FNT_FIRST
#define MINCHO_B1                   (JPN_FNT_FIRST+2)
#define MINCHO_E1                   (JPN_FNT_FIRST+4)
#define GOTHIC_B1                   (JPN_FNT_FIRST+6)
#define GOTHIC_M1                   (JPN_FNT_FIRST+8)
#define GOTHIC_E1                   (JPN_FNT_FIRST+10)
#define MARUGOTHIC_B1               (JPN_FNT_FIRST+12)
#define MARUGOTHIC_M1               (JPN_FNT_FIRST+14)
#define MARUGOTHIC_L1               (JPN_FNT_FIRST+16)
#define GYOSHO_1                    (JPN_FNT_FIRST+18)
#define KAISHO_1                    (JPN_FNT_FIRST+20)
#define KYOKASHO_1                  (JPN_FNT_FIRST+22)
#define MINCHO10_RAS                (JPN_FNT_FIRST+24) // for 240dpi model
#define MINCHO_3                    (JPN_FNT_FIRST+26) // for NX-100 only
#define GOTHIC_B3                   (JPN_FNT_FIRST+28) // for NX-100 only
#define AFTER_SP9II_FNT_FIRST       (JPN_FNT_FIRST+30) // MINCHO_2
#define JPN_MSPFNT_FIRST            (JPN_FNT_FIRST+54) // PMINCHO
#define JPN_FNT_LAST                (JPN_FNT_FIRST+56) // PGOTHIC

#define TEST_VERTICALFONT(id)       ((id)%2)


// Command callback IDs (Almost all IDs come from Win95/NT4 GPC.)
#define CMD_SEND_BLOCK              24  // <- CMD_SEND_BLOCK_COMPRESS  MSKK
//#define CMD_SET_CLIPRECT            25
//#define CMD_CLEAR_CLIPRECT          26
#define CMD_ENDDOC_SP4II            27
#define CMD_ENDDOC_SP8              28
#define CMD_ENDDOC_SP9              29
#define CMD_ENDDOC_400DPI_MODEL     30
#define CMD_MULTI_COPIES            31
//#define CMD_BEGIN_POLYGON           32
//#define CMD_CONTINUE_POLYLINE       33
//#define CMD_CONTINUE_POLYGON        34
//#define CMD_RECTANGLE               35
//#define CMD_CIRCLE                  36
#define CMD_FF                      37
#define CMD_FONT_BOLD_ON            38
#define CMD_FONT_BOLD_OFF           39
#define CMD_FONT_ITALIC_ON          40
#define CMD_FONT_ITALIC_OFF         41
#define CMD_FONT_WHITETEXT_ON       42
#define CMD_FONT_WHITETEXT_OFF      43
#define CMD_XM_ABS                  44  // These 6 IDs must be in this order.
#define CMD_XM_REL                  45  //
#define CMD_XM_RELLEFT              46  //
#define CMD_YM_ABS                  47  //
#define CMD_YM_REL                  48  //
#define CMD_YM_RELUP                49  //
#define CMD_BEGINDOC_SP9            50
#define CMD_BEGINDOC_MF150E         51
#define CMD_RES240                  52
#define CMD_RES400                  53
#define CMD_RES600                  54
#define CMD_SELECT_PAPER_CUSTOM     55
#define CMD_SET_PORTRAIT            56
#define CMD_SET_LANDSCAPE           57
//#define CMD_SELECT_SOLID            58
//#define CMD_SELECT_HS_HORZ          59
//#define CMD_SELECT_HS_VERT          60
//#define CMD_SELECT_HS_FDIAG         61
//#define CMD_SELECT_HS_BDIAG         62
//#define CMD_SELECT_HS_CROSS         63
//#define CMD_SELECT_HS_DIAGCROSS     64
//#define CMD_DELETE_BRUSHSTYLE       65
//#define CMD_EXIT_VECT               66
#define CMD_BEGINDOC_SP4II          67
#define CMD_BEGINDOC_SP8            68
#define CMD_BEGINDOC_MF530          69
//#define CMD_DUPLEX_ON               70
#define CMD_DUPLEX_VERT             71
#define CMD_DUPLEX_HORZ             72
#define CMD_SELECT_AUTOFEED         73
#define CMD_SELECT_MANUALFEED       74
#define CMD_SELECT_MULTIFEEDER      75
#define CMD_SELECT_PAPER_A6         76
#define CMD_BEGINDOC_SP9II          77
#define CMD_BEGINDOC_MF150          78
#define CMD_BEGINDOC_SP10           79
#define CMD_RLE_COMPRESS_ON         80  // <- CMD_SEND_BLOCK_NOCOMPRESS  MSKK
//#define CMD_CIRCLE_PIE              81  // These 6 IDs must be in this order.
//#define CMD_CIRCLE_ARC              82  //
//#define CMD_CIRCLE_CHORD            83  //
//#define CMD_ELLIPSE_PIE             84  //
//#define CMD_ELLIPSE_ARC             85  //
//#define CMD_ELLIPSE_CHORD           86  // 
#define CMD_BEGINDOC_MFP250         87
#define CMD_END_POLYGON             88
#define CMD_SELECT_PAPER_A3         89
#define CMD_SELECT_PAPER_A4         90
#define CMD_SELECT_PAPER_A5         91
#define CMD_SELECT_PAPER_B4         92
#define CMD_SELECT_PAPER_B5         93
#define CMD_SELECT_PAPER_B6         94
#define CMD_SELECT_PAPER_TABLOID    95
#define CMD_SELECT_PAPER_LEGAL      96
#define CMD_SELECT_PAPER_LETTER     97
#define CMD_SELECT_PAPER_STATEMENT  98
#define CMD_IMGCTRL_AA67            99
#define CMD_IMGCTRL_BA80            100
#define CMD_SELECT_PAPER_A2TOA3     101
#define CMD_SET_TEXTRECT_W          102
#define CMD_SET_TEXTRECT_H          103
#define CMD_DRAW_TEXTRECT           104
#define CMD_CR                      105
#define CMD_LF                      106
#define CMD_BS                      107
#define CMD_DRV_2IN1_67             108
#define CMD_DRV_2IN1_100            109
#define CMD_BEGINDOC_NX100          110
#define CMD_IMGCTRL_BA115           111
#define CMD_BEGINDOC_NX500          112
#define CMD_DL_SET_FONT_ID          113
#define CMD_DL_SELECT_FONT_ID       114
#define CMD_SELECT_PAPER_DOUBLEPOSTCARD 115
//#define CMD_BEGINDOC_MFP250E        116
#define CMD_BEGINDOC_MF250M         117
#define CMD_BEGINDOC_MF3550         118
#define CMD_SELECT_MULTITRAY        119
#define CMD_IMGCTRL_100             120 // These 11 IDs must be in this order.
#define CMD_IMGCTRL_88              121 //
#define CMD_IMGCTRL_80              122 //
#define CMD_IMGCTRL_75              123 //
#define CMD_IMGCTRL_70              124 //
#define CMD_IMGCTRL_67              125 //
#define CMD_IMGCTRL_115             126 //
#define CMD_IMGCTRL_122             127 //
#define CMD_IMGCTRL_141             128 //
#define CMD_IMGCTRL_200             129 //
#define CMD_IMGCTRL_50              130 //
#define CMD_DRV_4IN1_50             131
#define CMD_BEGINDOC_MF200          132 // @Sep/01/98
#define CMD_SELECT_PAPER_A2         133
#define CMD_SELECT_PAPER_C          134
#define CMD_BEGINDOC_MF3300         135
#define CMD_COMPRESS_OFF            136 // MSKK
#define CMD_BEGINDOC_IP1            137
#define CMD_SELECT_ROLL1            138
#define CMD_SELECT_ROLL2            139
#define CMD_IMGCTRL_AA141           140
#define CMD_IMGCTRL_AA200           141
#define CMD_IMGCTRL_AA283           142
#define CMD_IMGCTRL_A1_400          143
#define CMD_IMGCTRL_283             144
#define CMD_IMGCTRL_400             145
#define CMD_MEDIATYPE_STANDARD      146
#define CMD_MEDIATYPE_OHP           147
#define CMD_MEDIATYPE_THICK         148
#define CMD_REGION_STANDARD         149
#define CMD_REGION_EDGE2EDGE        150
#define CMD_SELECT_STAPLE_NONE      151
#define CMD_SELECT_STAPLE_1         152
#define CMD_SELECT_STAPLE_2         153
#define CMD_SELECT_PUNCH_NONE       154
#define CMD_SELECT_PUNCH_1          155
#define CMD_DRAW_TEXTRECT_REL       156
#define CMD_DL_SET_FONT_GLYPH       157
#define CMD_SET_MEM0KB              158
#define CMD_SET_MEM128KB            159
#define CMD_SET_MEM256KB            160
#define CMD_SET_MEM512KB            161
#define CMD_BEGINDOC_NX70           164
#define CMD_SELECT_PAPER_B3         165
#define CMD_SELECT_PAPER_A3TOA4     166
#define CMD_SELECT_PAPER_B4TOA4     167
#define CMD_SELECT_PAPER_POSTCARD   168
#define CMD_SET_BASEOFFSETX_0       169
#define CMD_SET_BASEOFFSETX_1       170
#define CMD_SET_BASEOFFSETX_2       171
#define CMD_SET_BASEOFFSETX_3       172
#define CMD_SET_BASEOFFSETX_4       173
#define CMD_SET_BASEOFFSETX_5       174
#define CMD_SET_BASEOFFSETY_0       175
#define CMD_SET_BASEOFFSETY_1       176
#define CMD_SET_BASEOFFSETY_2       177
#define CMD_SET_BASEOFFSETY_3       178
#define CMD_SET_BASEOFFSETY_4       179
#define CMD_SET_BASEOFFSETY_5       180
#define CMD_SET_LONG_EDGE_FEED      181
#define CMD_SET_SHORT_EDGE_FEED     182
#define CMD_OEM_COMPRESS_ON         183
#define CMD_SET_SRCBMP_W            184
#define CMD_SET_SRCBMP_H            185
#define CMD_BEGINDOC_NX700          186
#define CMD_SET_COLLATE_OFF         187
#define CMD_SET_COLLATE_ON          188
#define CMD_SELECT_COLLATE_UNIDIR   189
#define CMD_SELECT_COLLATE_ROTATED  190
#define CMD_DRAW_TEXTRECT_WHITE     191 // MSKK  Aug/14/98
#define CMD_DRAW_TEXTRECT_WHITE_REL 192
#define CMD_SELECT_COLLATE_SHIFTED  193
#define CMD_BEGINDOC_NX900          194
#define CMD_BEGINDOC_NX800          195 // <- CMD_BEGINDOC_MF1530 @Jun/25/2001
#define CMD_MEDIATYPE_SPL           196
#define CMD_RES1200                 197
#define CMD_SELECT_STAPLE_MAX1      198
#define CMD_SELECT_PAPER_11x15TOA4  199 // @Jan/27/2000
#define CMD_SELECT_TRAY1            200 // These 5 IDs must be in this order.
#define CMD_SELECT_TRAY2            201 //
#define CMD_SELECT_TRAY3            202 //
#define CMD_SELECT_TRAY4            203 //
#define CMD_SELECT_TRAY5            204 //
#define CMD_MEDIATYPE_TRACE         205 // @Feb/15/2000
#define CMD_BEGINDOC_NX710          206 // @Jun/23/2000
#define CMD_BEGINDOC_NX720          207 // @Sep/26/2000
#define CMD_MEDIATYPE_LABEL         208 // @Oct/12/2000
#define CMD_MEDIATYPE_THIN          209 // @Feb/05/2001
// v1.07 ->
#define CMD_SELECT_FINISHER_TRAY2   210 // @Jun/25/2001
#define CMD_BEGINDOC_MF3530E        211
#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\hlp\rpdlcfg.hh ===
;IDH_Orientation=
;IDH_InputBin=
;IDH_Resolution=
;IDH_PaperSize=
;IDH_Collate=
;IDH_Duplex=
IDH_EdgeToEdgePrint=1
IDH_LeftMarginInPrinting=2
IDH_TopMarginInPrinting=3
IDH_EmulationMode=4
IDH_MediaType=5
IDH_OutputBin=6
IDH_Sorting=7
IDH_Stapling=8
IDH_Punching=9
IDH_ScanForRules=10
IDH_PrintQuality=11
IDH_PrintDensity=12
IDH_ImageControl=13
IDH_Halftone=14
IDH_Memory=15
IDH_LongEdgeFeed=16
IDH_CollateType=17
IDH_PrintTextAsBlack=18
;IDH_HardDisk=
;IDH_Finisher=
;IDH_PrintPost=
IDH_UI_VariableScaling=50
IDH_UI_BarHeight=51
IDH_UI_BarSubFont=52
IDH_UI_DuplexMargin=53
IDH_UI_BindRight=54
IDH_UI_TomboAdd=55
IDH_UI_TomboAdjX=56
IDH_UI_TomboAdjY=57
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\ricoh\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=rpdlres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),rpdlres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc;..\..\rpdlui

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\rpdlres.rc \
    $(SRCDIR)\rpdlres.c \
    $(SRCDIR)\common.c \
    $(SRCDIR)\ddi.c

MISCFILES=\
    $(SRCDIR)\rpdlres.ini \
    $(SRCDIR)\rpdlres2.ini \
    $(SRCDIR)\hlp\rpdlcfg.hlp \
    $(SRCDIR)\hlp\rpdlcfg2.hlp \
    $(GPDDIR)\riip1j.gpd \
    $(GPDDIR)\rim105pj.gpd \
    $(GPDDIR)\rim353ej.gpd \
    $(GPDDIR)\rim354j.gpd \
    $(GPDDIR)\rim357ej.gpd \
    $(GPDDIR)\rim358j.gpd \
    $(GPDDIR)\rim457ej.gpd \
    $(GPDDIR)\rim555ej.gpd \
    $(GPDDIR)\rim557j.gpd \
    $(GPDDIR)\rim557xj.gpd \
    $(GPDDIR)\rim655ej.gpd \
    $(GPDDIR)\rim707j.gpd \
    $(GPDDIR)\rim857j.gpd \
    $(GPDDIR)\rim857xj.gpd \
    $(GPDDIR)\rimd35j.gpd \
    $(GPDDIR)\rimf153j.gpd \
    $(GPDDIR)\rimf15ej.gpd \
    $(GPDDIR)\rimf15j.gpd \
    $(GPDDIR)\rimf16j.gpd \
    $(GPDDIR)\rimf20j.gpd \
    $(GPDDIR)\rimf220j.gpd \
    $(GPDDIR)\rimf223j.gpd \
    $(GPDDIR)\rimf25j.gpd \
    $(GPDDIR)\rimf270j.gpd \
    $(GPDDIR)\rimf273j.gpd \
    $(GPDDIR)\rimf330j.gpd \
    $(GPDDIR)\rimf335j.gpd \
    $(GPDDIR)\rimf350j.gpd \
    $(GPDDIR)\rimf353j.gpd \
    $(GPDDIR)\rimf355j.gpd \
    $(GPDDIR)\rimf357j.gpd \
    $(GPDDIR)\rimf455j.gpd \
    $(GPDDIR)\rimf457j.gpd \
    $(GPDDIR)\rimf53j.gpd \
    $(GPDDIR)\rimf555j.gpd \
    $(GPDDIR)\rimf655j.gpd \
    $(GPDDIR)\rimf70j.gpd \
    $(GPDDIR)\rimp15j.gpd \
    $(GPDDIR)\rimp25ej.gpd \
    $(GPDDIR)\rimp25j.gpd \
    $(GPDDIR)\rimp35ej.gpd \
    $(GPDDIR)\rimp35j.gpd \
    $(GPDDIR)\rine22j.gpd \
    $(GPDDIR)\rine27j.gpd \
    $(GPDDIR)\rine35dj.gpd \
    $(GPDDIR)\rine35j.gpd \
    $(GPDDIR)\rine45j.gpd \
    $(GPDDIR)\rinx100j.gpd \
    $(GPDDIR)\rinx10j.gpd \
    $(GPDDIR)\rinx110j.gpd \
    $(GPDDIR)\rinx11j.gpd \
    $(GPDDIR)\rinx21j.gpd \
    $(GPDDIR)\rinx41j.gpd \
    $(GPDDIR)\rinx62j.gpd \
    $(GPDDIR)\rinx62nj.gpd \
    $(GPDDIR)\rinx72nj.gpd \
    $(GPDDIR)\rinx72xj.gpd \
    $(GPDDIR)\rinx81j.gpd \
    $(GPDDIR)\rinx50j.gpd \
    $(GPDDIR)\rinx51j.gpd \
    $(GPDDIR)\rinx60j.gpd \
    $(GPDDIR)\rinx61j.gpd \
    $(GPDDIR)\rinx70j.gpd \
    $(GPDDIR)\rinx71j.gpd \
    $(GPDDIR)\rinx7j.gpd \
    $(GPDDIR)\rinx7_1j.gpd \
    $(GPDDIR)\rinx80j.gpd \
    $(GPDDIR)\rinx90j.gpd \
    $(GPDDIR)\rinx91j.gpd \
    $(GPDDIR)\risp101j.gpd \
    $(GPDDIR)\risp102j.gpd \
    $(GPDDIR)\risp103j.gpd \
    $(GPDDIR)\risp104j.gpd \
    $(GPDDIR)\risp105j.gpd \
    $(GPDDIR)\risp106j.gpd \
    $(GPDDIR)\risp107j.gpd \
    $(GPDDIR)\risp4_2j.gpd \
    $(GPDDIR)\risp5j.gpd \
    $(GPDDIR)\risp7_2j.gpd \
    $(GPDDIR)\risp7j.gpd \
    $(GPDDIR)\risp8_2j.gpd \
    $(GPDDIR)\risp80j.gpd \
    $(GPDDIR)\risp8j.gpd \
    $(GPDDIR)\risp9_2j.gpd \
    $(GPDDIR)\risp90j.gpd \
    $(GPDDIR)\risp9j.gpd \
    $(GPDDIR)\rix153j.gpd \
    $(GPDDIR)\rix223j.gpd \
    $(GPDDIR)\rix25j.gpd \
    $(GPDDIR)\rix270j.gpd \
    $(GPDDIR)\rix273j.gpd \
    $(GPDDIR)\rix350j.gpd \
    $(GPDDIR)\rix353ej.gpd \
    $(GPDDIR)\rix353j.gpd \
    $(GPDDIR)\rix354j.gpd \
    $(GPDDIR)\rix355j.gpd \
    $(GPDDIR)\rix357ej.gpd \
    $(GPDDIR)\rix357j.gpd \
    $(GPDDIR)\rix358j.gpd \
    $(GPDDIR)\rix35j.gpd \
    $(GPDDIR)\rix455j.gpd \
    $(GPDDIR)\rix457ej.gpd \
    $(GPDDIR)\rix457j.gpd \
    $(GPDDIR)\rixprnj.gpd \
    $(GPDDIR)\rpdlmac.gpd \
    $(GPDDIR)\rim134j.gpd \
    $(GPDDIR)\rim154j.gpd \
    $(GPDDIR)\rine60j.gpd \
    $(GPDDIR)\rine75j.gpd \
    $(GPDDIR)\rine75tj.gpd \
    $(GPDDIR)\rine75xj.gpd \
    $(GPDDIR)\rinx63j.gpd \
    $(GPDDIR)\rinx63nj.gpd \
    $(GPDDIR)\rinx73nj.gpd \
    $(GPDDIR)\rinx92j.gpd \
    $(GPDDIR)\rix134j.gpd \
    $(GPDDIR)\rix154j.gpd \
    $(GPDDIR)\rix460j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\rpdlres.c ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           RPDLRES.C

Abstract:       Main file for OEM rendering plugin module.

Functions:      OEMCommandCallback
                bOEMSendFontCmd
                bOEMOutputCharStr
                OEMDownloadFontHeader
                OEMDownloadCharGlyph
                OEMTTDownloadMethod
                OEMCompression

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/1997 -zhanw-
        Created it.
    08/11/1997 -Masatoshi Kubokura-
        Began to modify for RPDL.
    04/22/1999 -Masatoshi Kubokura-
        Last modified for Windows2000.
    08/30/1999 -Masatoshi Kubokura-
        Began to modify for NT4SP6(Unidrv5.4).
    09/27/1999 -Masatoshi Kubokura-
        Last modified for NT4SP6.
    02/17/2000 -Masatoshi Kubokura-
        V.1.02 release
    04/07/2000 -Masatoshi Kubokura-
        Fix bug of SET_IBM_EXT_BLOCK with 1200dpi printer (RPDL bug)
    05/22/2000 -Masatoshi Kubokura-
        V.1.03 for NT4  release
    06/30/2000 -Masatoshi Kubokura-
        V.1.04 release
    01/22/2001 -Masatoshi Kubokura-
        V.1.05 release
    02/05/2001 -Masatoshi Kubokura-
        Add "Thick Paper"
    03/15/2001 -Masatoshi Kubokura-
        Fix RectangleFill bug
        Last modified for XP(Whistler).
    06/29/2001 -Masatoshi Kubokura-
        V.1.07
        Fix RPDL staple bug.(NX800,810,910,MF2230,2730,3530e,3570e,4570e).
        Enable SET_PAPERDEST_FINISHER at GW model.
    03/04/2002 -Masatoshi Kubokura-
        Include strsafe.h.
        Add FileNameBufSize as arg3 at RWFileData().
        Use safe_sprintfA() instead of sprintf().
    03/27/2002 -Masatoshi Kubokura-
        Eliminate "#if 0".
    04/02/2002 -Masatoshi Kubokura-
        Check pdevobj NULL pointer before using at OEMCommandCallback().
    11/20-22/2002 -yasuho & Kubokura-
        Fix memory leak.
        Last modified for .NET Server.

--*/

#include <stdio.h>
#include "pdev.h"
#ifndef WINNT_40
#include "strsafe.h"        // @Mar/01/2002
#endif // !WINNT_40

#if DBG
//#define DBG_OUTPUTCHARSTR 1
//#define giDebugLevel DBG_VERBOSE    // enable VERBOSE() in each file
#endif

//
// Misc definitions and declarations.
//
#define STDVAR_BUFSIZE(n) \
    (sizeof (GETINFO_STDVAR) + sizeof(DWORD) * 2 * ((n) - 1))  // MSKK 1/24/98
#define MASTER_TO_SPACING_UNIT(p, n) \
    ((n) / (p)->nResoRatio)
#ifndef WINNT_40
//#define sprintf     wsprintfA   // @Sep/30/98
#define strcmp      lstrcmpA    // @Sep/30/98
#endif // WINNT_40

// External Functions' prototype
// @Mar/01/2002 ->
//extern BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG type); // add pwszFileName @Aug/31/99
extern BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG FileNameBufSize, LONG type);
extern INT safe_sprintfA(char* pszDest, size_t cchDest, const char* pszFormat, ...);
// @Mar/01/2002 <-

// Local Functions' prototype
static BYTE IsDBCSLeadByteRPDL(BYTE Ch);
static BYTE IsDifferentPRNFONT(BYTE Ch);
static VOID DrawTOMBO(PDEVOBJ pdevobj, SHORT action);
static VOID AssignIBMfont(PDEVOBJ pdevobj, SHORT rcID, SHORT action);
static VOID SendFaxNum(PDEVOBJ pdevobj);
#ifdef JISGTT
static VOID jis2sjis(BYTE jis[], BYTE sjis[]);
#endif // JISGTT
static INT DRCompression(PBYTE pInBuf, PBYTE pOutBuf, DWORD dwInLen, DWORD dwOutLen,
                         DWORD dwWidthByte, DWORD dwHeight);

//
// Static data to be used by this minidriver.
//

static BYTE ShiftJisRPDL[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //70
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //80
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //D0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  //E0
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0   //F0
};

// Some vertical device font differ from TrueType font
static BYTE VerticalFontCheck[256] = {
//     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //30
        0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0,  //40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //50
        0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  //60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,  //70
        1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0,  //80
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //A0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //B0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //C0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,  //D0
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //E0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   //F0
};

static BYTE UpdateDate[] = "04/04/2002";

// OBSOLETE (described in GPD) @Feb/15/98 ->
// Emulation Mode after printing
//static BYTE *RPDLProgName[] = {
//    "1@R98", "1@R16", "1@RPS", "1@R55",                         //  0- 3
//    "1@RGL", "1@GL2", "1@R52", "1@R73",                         //  4- 7
//    "1@R35", "1@R01",                                           //  8- 9
//    "0@P1",  "0@P2",  "0@P3",  "0@P4",                          // 10-13
//    "0@P5",  "0@P6",  "0@P7",  "0@P8",                          // 14-17
//    "0@P9",  "0@P10", "0@P11", "0@P12",                         // 18-21
//    "0@P13", "0@P14", "0@P15", "0@P16"                          // 22-25
//};
//static BYTE *RPDLProgName2[] = {
//    "-1,1,1@R98", "-1,1,1@R16", "-1,1,1@RPS", "-1,1,1@R55",     //  0- 3
//    "-1,1,1@RGL", "-1,1,1@GL2", "-1,1,1@R52", "-1,1,1@R73",     //  4- 7
//    "-1,1,1@R35", "-1,1,1@R01",                                 //  8- 9
//    "0,1,2@P1",   "0,1,2@P2",   "0,1,2@P3",   "0,1,2@P4",       // 10-13
//    "0,1,2@P5",   "0,1,2@P6",   "0,1,2@P7",   "0,1,2@P8",       // 14-17
//    "0,1,2@P9",   "0,1,2@P10",  "0,1,2@P11",  "0,1,2@P12",      // 18-21
//    "0,1,2@P13",  "0,1,2@P14",  "0,1,2@P15",  "0,1,2@P16"       // 22-25
//};
//#define PRG_RPGL    4
// @Feb/15/98 <-

// RPDL pagesize (unit:masterunit)
static POINT RPDLPageSize[] = {
    {2688L*MASTERUNIT/240L, 3888L*MASTERUNIT/240L},  // A3
    {1872L*MASTERUNIT/240L, 2720L*MASTERUNIT/240L},  // A4
    {1280L*MASTERUNIT/240L, 1904L*MASTERUNIT/240L},  // A5
    { 880L*MASTERUNIT/240L, 1312L*MASTERUNIT/240L},  // A6
    {2336L*MASTERUNIT/240L, 3352L*MASTERUNIT/240L},  // B4
    {1600L*MASTERUNIT/240L, 2352L*MASTERUNIT/240L},  // B5
    {1104L*MASTERUNIT/240L, 1640L*MASTERUNIT/240L},  // B6
    {2528L*MASTERUNIT/240L, 4000L*MASTERUNIT/240L},  // Tabloid
    {1920L*MASTERUNIT/240L, 3280L*MASTERUNIT/240L},  // Legal
    {1920L*MASTERUNIT/240L, 2528L*MASTERUNIT/240L},  // Letter
    {1200L*MASTERUNIT/240L, 1968L*MASTERUNIT/240L},  // Statement
    {3969L*MASTERUNIT/240L, 5613L*MASTERUNIT/240L},  // A2->A3
    {6480L*MASTERUNIT/400L, 8960L*MASTERUNIT/400L},  // A2
    {6667L*MASTERUNIT/400L, 8448L*MASTERUNIT/400L},  // C
    {5587L*MASTERUNIT/400L, 7792L*MASTERUNIT/400L},  // B3      @Jan/07/98
    {2688L*MASTERUNIT/240L, 3888L*MASTERUNIT/240L},  // A3->A4  @Feb/04/98
    {2336L*MASTERUNIT/240L, 3352L*MASTERUNIT/240L},  // B4->A4  @Feb/04/98
    {6600L*MASTERUNIT/600L, 8160L*MASTERUNIT/600L},  // 11x15->A4  @Jan/27/2000
    { 880L*MASTERUNIT/240L, 1312L*MASTERUNIT/240L}   // Postcard since NX700 @Feb/13/98
};
#define PAGESPACE_2IN1_100  12      // mm
static WORD PageSpace_2IN1_67[] = {
    30, 23, 22, 18,     // A3,A4,A5,A6
    25, 23, 19, 56,     // B4,B5,B6,Tabloid
     6,  6, 35,  6,     // Legal(disable),Letter,Statement,A2->A3(disable)
     6,  6,  6,  6,     // A2(disable),C(disable),B3(disable),A3->A4(disable)
     6,  6,  6          // B4->A4(disable),11x15->A4(disable),Postcard(disable)
};

static POINT RPDLPageSizeE2E[] = {
    {(2970000L/254L+5L)/10L*MASTERUNIT/100L, (4200000L/254L+5L)/10L*MASTERUNIT/100L},  // A3
    {(2100000L/254L+5L)/10L*MASTERUNIT/100L, (2970000L/254L+5L)/10L*MASTERUNIT/100L},  // A4
    {(1480000L/254L+5L)/10L*MASTERUNIT/100L, (2100000L/254L+5L)/10L*MASTERUNIT/100L},  // A5
    {(1050000L/254L+5L)/10L*MASTERUNIT/100L, (1480000L/254L+5L)/10L*MASTERUNIT/100L},  // A6
    {(2570000L/254L+5L)/10L*MASTERUNIT/100L, (3640000L/254L+5L)/10L*MASTERUNIT/100L},  // B4
    {(1820000L/254L+5L)/10L*MASTERUNIT/100L, (2570000L/254L+5L)/10L*MASTERUNIT/100L},  // B5
    {(1280000L/254L+5L)/10L*MASTERUNIT/100L, (1820000L/254L+5L)/10L*MASTERUNIT/100L},  // B6
    {110L*MASTERUNIT/10L, 170L*MASTERUNIT/10L},                                        // Tabloid
    { 85L*MASTERUNIT/10L, 140L*MASTERUNIT/10L},                                        // Legal
    { 85L*MASTERUNIT/10L, 110L*MASTERUNIT/10L},                                        // Letter
    { 55L*MASTERUNIT/10L,  85L*MASTERUNIT/10L},                                        // Statement
    {(4200000L/254L+5L)/10L*MASTERUNIT/100L, (5940000L/254L+5L)/10L*MASTERUNIT/100L},  // A2->A3
    {(4200000L/254L+5L)/10L*MASTERUNIT/100L, (5940000L/254L+5L)/10L*MASTERUNIT/100L},  // A2
    {170L*MASTERUNIT/10L, 220L*MASTERUNIT/10L},                                        // C
    {(3640000L/254L+5L)/10L*MASTERUNIT/100L, (5140000L/254L+5L)/10L*MASTERUNIT/100L},  // B3
    {(2970000L/254L+5L)/10L*MASTERUNIT/100L, (4200000L/254L+5L)/10L*MASTERUNIT/100L},  // A3->A4
    {(2570000L/254L+5L)/10L*MASTERUNIT/100L, (3640000L/254L+5L)/10L*MASTERUNIT/100L},  // B4->A4
    {110L*MASTERUNIT/10L, 150L*MASTERUNIT/10L},                                        // 11x15 -> A4  @Jan/27/2000
    {(1000000L/254L+5L)/10L*MASTERUNIT/100L, (1480000L/254L+5L)/10L*MASTERUNIT/100L}   // Postcard since NX700
};
#define PAGESPACE_2IN1_100E2E  0    // mm
static WORD PageSpace_2IN1_67E2E[] = {
    18, 11, 10,  6,     // A3,A4,A5,A6
    15, 11,  9, 43,     // B4,B5,B6,Tabloid
     0,  0, 23,  0,     // Legal(disable),Letter,Statement,A2->A3(disable)
     0,  0,  0,  0,     // A2(disable),C(disable),B3(disable),A3->A4(disable)
     0,  0,  0          // B4->A4(disable),11x15->A4(disable),Postcard(disable)
};

#define RPDL_A3     0
#define RPDL_A4     1
#define RPDL_A5     2
#define RPDL_A6     3   // A6/Postcard
#define RPDL_B4     4
#define RPDL_B5     5
#define RPDL_B6     6
#define RPDL_TABD   7
#define RPDL_LEGL   8
#define RPDL_LETR   9
#define RPDL_STAT   10
#define RPDL_A2A3   11
#define RPDL_A2     12
#define RPDL_C      13
#define RPDL_B3     14
#define RPDL_A3A4   15
#define RPDL_B4A4   16
#define RPDL_11x15A4    17  // @Jan/27/2000
#define RPDL_POSTCARD   18  // Postcard since NX700
#define RPDL_CUSTOMSIZE 99

// RPDL command definition
static BYTE BS[]                  = "\x08";
static BYTE FF[]                  = "\x0C";
static BYTE CR[]                  = "\x0D";
static BYTE LF[]                  = "\x0A";
static BYTE DOUBLE_BS[]           = "\x08\x08";
static BYTE DOUBLE_SPACE[]        = "\x20\x20";
static BYTE BEGIN_SEND_BLOCK_C[]  = "\x1B\x12G3,%d,%d,,2,,,%u@";
static BYTE BEGIN_SEND_BLOCK_NC[] = "\x1B\x12G3,%d,%d,,,@";
static BYTE BEGIN_SEND_BLOCK_DRC[] = "\x1B\x12G3,%d,%d,,5,,@";
static BYTE ESC_ROT0[]            = "\x1B\x12\x46\x30\x20";
static BYTE ESC_ROT90[]           = "\x1B\x12\x46\x39\x30\x20";
static BYTE ESC_VERT_ON[]         = "\x1B\x12&2\x20";
static BYTE ESC_VERT_OFF[]        = "\x1B\x12&1\x20";
static BYTE ESC_SHIFT_IN[]        = "\x1B\x0F";
static BYTE ESC_SHIFT_OUT[]       = "\x1B\x0E";
static BYTE ESC_CTRLCODE[]        = "\x1B\x12K1\x20";
static BYTE ESC_HALFDOWN[]        = "\x1B\x55";
static BYTE ESC_HALFUP[]          = "\x1B\x44";
static BYTE ESC_DOWN[]            = "\x1B\x55\x1B\x55";
static BYTE ESC_UP[]              = "\x1B\x44\x1B\x44";
static BYTE ESC_BOLD_ON[]         = "\x1BO";
static BYTE ESC_BOLD_OFF[]        = "\x1B&";
static BYTE ESC_ITALIC_ON[]       = "\x1B\x12I-16\x20";
static BYTE ESC_ITALIC_OFF[]      = "\x1B\x12I0\x20";
static BYTE ESC_WHITETEXT_ON[]    = "\x1B\x12W5,0\x20";
static BYTE ESC_WHITETEXT_OFF[]   = "\x1B\x12W0,0\x20";
static BYTE ESC_XM_ABS[]          = "\x1B\x12H%d\x20";
static BYTE ESC_XM_REL[]          = "\x1B\x12\x20+%d\x20";
static BYTE ESC_XM_RELLEFT[]      = "\x1B\x12\x20-%d\x20";
static BYTE ESC_YM_ABS[]          = "\x1B\x12V%d\x20";
static BYTE ESC_YM_REL[]          = "\x1B\x12\x0A+%d\x20";
static BYTE ESC_YM_RELUP[]        = "\x1B\x12\x0A-%d\x20";
static BYTE ESC_CLIPPING[]        = "\x1B\x12*%d,%d,%d,%d\x20";
static BYTE SELECT_PAPER_CUSTOM[] = "\x1B\x12\x3F\x35%ld,%ld\x1B\x20";
static BYTE SELECT_PAPER_CUSTOM2[]= "\x1B\x12\x3F\x35%ld,%ld,%d\x1B\x20";   // %ld<-%d @Sep/27/2000, %d<-%c @Oct/13/2000
static BYTE SELECT_TRAY_N[]       = "\x1B\x19%d";                           // %d<-%c  @Oct/13/2000
static BYTE SELECT_PAPER_HEAD[]   = "\x1B\x12\x35\x32@";
static BYTE SEL_TRAY_PAPER_HEAD[] = "\x1B\x12\x35@";
static BYTE SELECT_PAPER_HEAD_IP1[] = "\x1B\x12\x35\x33@";
static BYTE SELECT_PAPER_A1[]     = "A1\x1B\x20";
static BYTE SELECT_PAPER_A2[]     = "A2\x1B\x20";
static BYTE SELECT_PAPER_A3[]     = "A3\x1B\x20";
static BYTE SELECT_PAPER_A4[]     = "A4\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_A4R[]    = "A4R\x1B\x20";
static BYTE SELECT_PAPER_A4X[]    = "A4X\x1B\x20";
static BYTE SELECT_PAPER_A4W[]    = "A4R\x1B\x20\x1B\x12\x35@A4\x1B\x20";
static BYTE SELECT_PAPER_A5[]     = "A5\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_A5R[]    = "A5R\x1B\x20";
static BYTE SELECT_PAPER_A5X[]    = "A5X\x1B\x20";
static BYTE SELECT_PAPER_A5W[]    = "A5R\x1B\x20\x1B\x12\x35@A5\x1B\x20";
static BYTE SELECT_PAPER_A6[]     = "A6\x1B\x20";
static BYTE SELECT_PAPER_PC[]     = "PC\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_PCR[]    = "PCR\x1B\x20";  // @Feb/13/98
static BYTE SELECT_PAPER_PCX[]    = "PCX\x1B\x20";  // @Feb/13/98
static BYTE SELECT_PAPER_B3[]     = "B3\x1B\x20";   // @Jan/07/98
static BYTE SELECT_PAPER_B4[]     = "B4\x1B\x20";
static BYTE SELECT_PAPER_B5[]     = "B5\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_B5R[]    = "B5R\x1B\x20";
static BYTE SELECT_PAPER_B5X[]    = "B5X\x1B\x20";
static BYTE SELECT_PAPER_B5W[]    = "B5R\x1B\x20\x1B\x12\x35@B5\x1B\x20";
static BYTE SELECT_PAPER_B6[]     = "B6\x1B\x20";
static BYTE SELECT_PAPER_C[]      = "FLT\x1B\x20";
static BYTE SELECT_PAPER_TABD[]   = "DLT\x1B\x20";
static BYTE SELECT_PAPER_LEGL[]   = "LG\x1B\x20";
static BYTE SELECT_PAPER_LETR[]   = "LT\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_LETRR[]  = "LTR\x1B\x20";
static BYTE SELECT_PAPER_LETRX[]  = "LTX\x1B\x20";
static BYTE SELECT_PAPER_LETRW[]  = "LTR\x1B\x20\x1B\x12\x35@LT\x1B\x20";
static BYTE SELECT_PAPER_STAT[]   = "HL\x1B\x20";   // @May/25/98
static BYTE SELECT_PAPER_STATR[]  = "HLR\x1B\x20";
static BYTE SELECT_PAPER_STATX[]  = "HLX\x1B\x20";
static BYTE SELECT_PAPER_STATW[]  = "HLR\x1B\x20\x1B\x12\x35@HLT\x1B\x20";
static BYTE SET_LIMITLESS_SUPPLY[]= "\x1B\x12Z2\x20";
static BYTE RESET_LIMITLESS_SUPPLY[]= "\x1B\x12Z1\x20"; // @Sep/27/2000
static BYTE SELECT_MANUALFEED[]   = "\x1B\x19T";
static BYTE SELECT_MULTIFEEDER[]  = "\x1B\x19M";
static BYTE SELECT_ROLL1[]        = "\x1B\x12Y1,2\x20";
static BYTE SELECT_ROLL2[]        = "\x1B\x12Y1,4\x20";
//static BYTE SET_EMULATION[]       = "\x1B\x12!%s\x1B\x20";
//static BYTE SET_EMULATION_GL_EX[] = "MS-1,6,11;";
static BYTE SET_PORTRAIT[]        = "\x1B\x12\x44\x31\x20";
static BYTE SET_LANDSCAPE[]       = "\x1B\x12\x44\x32\x20";
static BYTE SET_LEFTMARGIN[]      = "\x1B\x12YK,%d\x20";
static BYTE SET_UPPERMARGIN[]     = "\x1B\x12YL,%d\x20";
static BYTE SET_LEFTMARGIN_9II[]  = "\x1B\x12?Y,K:%d\x1B\x20";
static BYTE SET_UPPERMARGIN_9II[] = "\x1B\x12?Y,L:%d\x1B\x20";
static BYTE SET_MULTI_COPY[]      = "\x1B\x12N%d\x20";
// PRINTER SIDE ISSUE: MF3550 RPDL  @Feb/22/99 ->
// Since 'backslash' can't be printed in Japanese region ('KUNIBETSU'),
// set 1st param to 1 for USA region.
//static BYTE SET_IBM_EXT_BLOCK[]   = "\x1B\x12?@,,1\x1B\x20";
static BYTE SET_IBM_EXT_BLOCK[]   = "\x1B\x12?@1,,1\x1B\x20";
// @Feb/22/99 <-
static BYTE SET_PAGEMAX_VALID[]   = "\x1B\x12?+1\x1B\x20";
static BYTE DUPLEX_ON[]           = "\x1B\x12\x36\x31,1\x20";
static BYTE DUPLEX_HORZ[]         = "\x1B\x12YA3,1\x20";
static BYTE DUPLEX_VERT[]         = "\x1B\x12YA3,2\x20";
static BYTE DUPLEX_VERT_R[]       = "\x1B\x12YA3,3\x20";
//static BYTE IMAGE_2IN1[]          = "\x1B\x12\x36\x32,\x20";
static BYTE IMAGE_OPT_OFF[]       = "\x1B\x12\x36\x30,1,0\x20";
static BYTE IMAGE_SCALING_100[]   = "\x1B\x12YM,1\x20";
static BYTE IMAGE_SCALING_88[]    = "\x1B\x12YM,2\x20";
static BYTE IMAGE_SCALING_80[]    = "\x1B\x12YM,3\x20";
static BYTE IMAGE_SCALING_75[]    = "\x1B\x12YM,4\x20";
static BYTE IMAGE_SCALING_70[]    = "\x1B\x12YM,5\x20";
static BYTE IMAGE_SCALING_67[]    = "\x1B\x12YM,6\x20";
static BYTE IMAGE_SCALING_115[]   = "\x1B\x12YM,7\x20";
static BYTE IMAGE_SCALING_122[]   = "\x1B\x12YM,8\x20";
static BYTE IMAGE_SCALING_141[]   = "\x1B\x12YM,9\x20";
static BYTE IMAGE_SCALING_200[]   = "\x1B\x12YM,10\x20";
static BYTE IMAGE_SCALING_283[]   = "\x1B\x12YM,11\x20";
static BYTE IMAGE_SCALING_400[]   = "\x1B\x12YM,12\x20";
static BYTE IMAGE_SCALING_122V[]  = "\x1B\x12?M122,1\x1B\x20";      // variable ratio
static BYTE IMAGE_SCALING_141V[]  = "\x1B\x12?M141,1\x1B\x20";
static BYTE IMAGE_SCALING_200V[]  = "\x1B\x12?M200,1\x1B\x20";
static BYTE IMAGE_SCALING_50V[]   = "\x1B\x12?M50,1\x1B\x20";
static BYTE IMAGE_SCALING_VAR[]   = "\x1B\x12?M%d,1\x1B\x20";

static BYTE SET_PAPERDEST_OUTTRAY[]  = "\x1B\x12\x38\x33,2\x20";
static BYTE SET_PAPERDEST_FINISHER[]    = "\x1B\x12\x38\x46,2,%d\x20";  // %d<-1  @Jun/25/2001
static BYTE SET_PAPERDEST_FINISHER_GW[] = "\x1B\x12\x38\x46,,%d\x20";   // @Jun/25/2001
static BYTE SET_PAPERDEST_1BINSHIFT[] = "\x1B\x12\x38\x49,,1\x20";  // @Oct/10/2000
// RPDL SPEC changed at NX900. @Jan/08/99 ->
//static BYTE SET_SORT_ON[]            = "\x1B\x12\x36,,1\x20";
static BYTE SET_SORT_ON[]            = "\x1B\x12\x36%d,,1\x20";
// @Jan/08/99 <-
static BYTE SET_STAPLE_ON[]          = "\x1B\x12?O22,0,%d\x1B\x20";
static BYTE SET_STAPLE_CORNER_ON[]   = "\x1B\x12?O22,1,%d\x1B\x20";
static BYTE SET_PUNCH_ON[]           = "\x1B\x12?O32,%d\x1B\x20";
static BYTE SELECT_MEDIATYPE[]       = "\x1B\x12?6%c,%d\x1B\x20";   // %d<-%c @Oct/13/2000
static BYTE COLLATE_DISABLE_ROT[]    = "\x1B\x12?O11\x1B\x20";      // @May/27/98
static BYTE COLLATE_ENABLE_ROT[]     = "\x1B\x12?O12\x1B\x20";      // @Jul/31/98

static BYTE SET_TEXTRECT_BLACK[]  = "\x1B\x12P3,64\x20";
static BYTE SET_TEXTRECT_WHITE[]  = "\x1B\x12W0,3\x20\x1B\x12P3,1\x20"; // @Aug/15/98
static BYTE SET_TEXTRECT_GRAY[]   = "\x1B\x12P3,%d,1\x20";          // add ",1" @Aug/15/98
static BYTE DRAW_TEXTRECT[]       = "\x1B\x12R%d,%d,%d,%d\x20";
static BYTE DRAW_TEXTRECT_R_P3[]  = "\x1B\x12r%d,%d,%d\x20";
static BYTE DRAW_TEXTRECT_R_P4[]  = "\x1B\x12r%d,%d,%d,%d\x20";

// @Jun/25/2001 ->
static BYTE BEGINDOC_TOP[]        = "\x1B\x12!1@R00\x1B\x20";
static BYTE BEGINDOC_TOP_JOBDEF[] = "\x1B\x12!1@R00\x1B\x20\x1B\x12?JS@\x1B@\x1B@\x1B@\x1B@\x1B\x20";
static BYTE BEGINDOC1_2[]         = "\x1B\x34\x1B\x12YJ,3\x20";
// @Jun/25/2001 <-

static BYTE BEGINDOC1[]           = "\x1B\x12!1@R00\x1B\x20\x1B\x34\x1B\x12YJ,3\x20";
static BYTE BEGINDOC2_1[]         = "\x1B\x12YP,1\x20\x1B\x12YQ,2\x20";
static BYTE BEGINDOC2_2[]         = "\x1B\x12YQ,2\x20";
static BYTE BEGINDOC3[]           = "\x1B\x12YA6,1\x20";
static BYTE SELECT_RES240_1[]     = "\x1B\x12YI,6\x20";
static BYTE SELECT_RES240_2[]     = "\x1B\x12YW,2\x20\x1B\x12YA4,2\x20\x1B\x12#3\x20";
static BYTE SELECT_RES400_1[]     = "\x1B\x12\x36\x30,1,0\x20\x1B\x12YI,7\x20\x1B\x12YW,1\x20";
static BYTE SELECT_RES400_2[]     = "\x1B\x12YA4,1\x20";
static BYTE SELECT_RES400_3[]     = "\x1B\x12#2\x20";
static BYTE SELECT_RES600[]       = "\x1B\x12\x36\x30,1,0\x20\x1B\x12YI,8\x20\x1B\x12YW,3\x20\x1B\x12YA4,3\x20\x1B\x12#4\x20";
static BYTE SELECT_RES1200[]      = "\x1B\x12\x36\x30,1,0\x20\x1B\x12YI,9\x20\x1B\x12YW,4\x20\x1B\x12YA4,4\x20\x1B\x12#5\x20";  // @Mar/02/99
static BYTE SELECT_REGION_STD[]   = "\x1B\x12YB,1\x20";
static BYTE SELECT_REGION_E2E[]   = "\x1B\x12YB,2\x20";
static BYTE ENDDOC1[]             = "\x1B\x12YB,1\x20\x1B\x12YI,1\x20\x1B\x12YJ,1\x20\x1B\x12YM,1\x20";
static BYTE ENDDOC2_240DPI[]      = "\x1B\x12YW,2\x20\x1B\x12YA4,2\x20";
static BYTE ENDDOC2_SP9[]         = "\x1B\x12YW,2\x20\x1B\x12YA4,1\x20";
static BYTE ENDDOC2_400DPI[]      = "\x1B\x12YW,1\x20\x1B\x12YA4,1\x20";
static BYTE ENDDOC3[]             = "\x1B\x12#0\x20";
static BYTE ENDDOC4[]             = "\x1B\x12\x36\x30,0,0\x20";
static BYTE ENDDOC4_FINISHER[]    = "\x1B\x12\x36\x30,0\x20";
static BYTE ENDDOC_JOBDEF_END[]   = "\x1B\x12?JE@\x1B@\x1B@\x1B@\x1B@\x1B\x20"; // @Jan/08/99
static BYTE ENDDOC5[]             = "\x1B\x1AI";
static BYTE SELECT_SMOOTHING2[]   = "\x1B\x12YA2,2\x20";
// If you change FONT_NAME, see AssignIBMfont().
static BYTE SET_IBM_FONT_SCALE[]  = "\x1B\x12\x43%d,M,%ld,%ld,4@I55\x20";
static BYTE SET_IBM_FONT_SCALE_H_ONLY[] = "\x1B\x12\x43%d,M,,%ld,4@I55\x20";    // @Jan/29/99
static BYTE *SET_IBM_FONT_NAME[]  = {"CHUMINCYO\x1B\x20",
                                     "MINCYO-BOLD\x1B\x20",
                                     "MINCYO-E B\x1B\x20",
                                     "GOTHIC\x1B\x20",
                                     "GOTHIC-M\x1B\x20",
                                     "GOTHIC-E B\x1B\x20",
                                     "MARUGOTHIC\x1B\x20",
                                     "MARUGOTHIC-M\x1B\x20",
                                     "MARUGOTHIC-L\x1B\x20",
                                     "GYOUSHO\x1B\x20",
                                     "KAISHO\x1B\x20",
                                     "KYOUKASHO\x1B\x20"};
static BYTE SET_JIS_FONT_SCALE[]  = "\x1B\x12\x43\x5A,M,%ld,%ld@";
static BYTE SET_JIS_FONT_SCALE_H_ONLY[] = "\x1B\x12\x43\x5A,M,,%ld@";           // @Jan/29/99
static BYTE *SET_JIS_FONT_NAME[]  = {"CHUMINCYO\x1B\x20",
                                     "MINCYO-BOLD\x1B\x20",
                                     "MINCYO-EXTRA BOLD\x1B\x20",
                                     "GOTHIC\x1B\x20",
                                     "GOTHIC-MEDIUM\x1B\x20",
                                     "GOTHIC-EXTRA BOLD\x1B\x20",
                                     "MARUGOTHIC\x1B\x20",
                                     "MARUGOTHIC-MEDIUM\x1B\x20",
                                     "MARUGOTHIC-LIGHT\x1B\x20",
                                     "GYOUSHO\x1B\x20",
                                     "KAISHO\x1B\x20",
                                     "KYOUKASHO\x1B\x20"};
#ifdef DOWNLOADFONT
//static BYTE DLFONT_MALLOC[]       = "\x1B\x12/128,8\x20";
static BYTE DLFONT_MALLOC[]       = "\x1B\x12/%d,%d\x20";
static BYTE DLFONT_SEND_BLOCK[]   = "\x1B\x12G7,%d,%d,%d,@";
static BYTE DLFONT_SEND_BLOCK_DRC[] = "\x1B\x12G7,%d,%d,%d,5,,,%d@";
static BYTE DLFONT_PRINT[]        = "\x1B\x12g%d,,%d\x20";
#endif // DOWNLOADFONT

static BYTE ENTER_VECTOR[]       = "\x1B\x33";
static BYTE EXIT_VECTOR[]        = "\x1B\x34";
static BYTE TERMINATOR[]         = ";";
static BYTE MOVE_ABSOLUTE[]      = "MA%d,%d";
static BYTE BAR_CHECKDIGIT[]     = "BC1";
static BYTE BAR_H_SET[]          = "BH%d";
static BYTE BAR_W_SET_JAN[]      = "JW%d";
static BYTE BAR_W_SET_2OF5[]     = "TW";
static BYTE BAR_W_SET_C39[]      = "CW";
static BYTE BAR_W_SET_NW7[]      = "NW";
static BYTE BAR_W_PARAMS[]       = "%d,%d,%d,%d,%d";
static BYTE BAR_ROT90[ ]         = "RO90";
static BYTE BAR_ROT270[]         = "RO270";
// @Dec/07/99 FK#50 ->
static BYTE BAR_W_SET_CUST[]     = "CS";
// @Dec/07/99 FK#50 <-
static BYTE *BAR_TYPE[]          = {"JL",               // JAN(STANDARD)
                                    "JS",               // JAN(SHORT)
                                    "TI%d,",            // 2of5(INDUSTRIAL)
                                    "TX%d,",            // 2of5(MATRIX)
                                    "TL%d,",            // 2of5(ITF)
                                    "CD%d,",            // CODE39
                                    "NB%d,",            // NW-7
// @Dec/07/99 FK#50 ->
                                    "CU%d,",            // CUSTOMER
                                    "CE%d",             // CODE128(B)
                                    "JU",               // UPC(A)
                                    "JE"                // UPC(W)
// @Dec/07/99 FK#50 <-
                                   };
static BYTE *BAR_NOFONT[]        = {"FJ1,-1",           // JAN(STANDARD)
                                    "FJ1,-1",           // JAN(SHORT)
                                    "FT2,-1",           // 2of5(INDUSTRIAL)
                                    "FT2,-1",           // 2of5(MATRIX)
                                    "FT2,-1",           // 2of5(ITF)
                                    "FC2,-1",           // CODE39
                                    "FN2,-1",           // NW-7
// @Dec/07/99 FK#50 ->
                                    "",                 // CUSTOMER
                                    "FC2,-1",           // CODE128
                                    "FJ1,-1",           // UPC(A)
                                    "FJ1,-1"            // UPC(W)
// @Dec/07/99 FK#50 <-
                                   };

static BYTE PEN_WIDTH[]           = "LW%d";                     // @Sep/14/98
static BYTE DRAW_TOMBO_POLYLINE[] = "MA%d,%dMRPD%d,%d,%d,%d";   // @Sep/14/98
// @Jun/25/2001 ->
//static BYTE BEGINFAX_HEAD[]       = "\x1B\x12!1@R00\x1B\x20\x1B\x12?F1,%d,%d,%d,180,1,";
static BYTE BEGINFAX_HEAD[]       = "\x1B\x12?F1,%d,%d,%d,180,1,";
// @Jun/25/2001 <-
static BYTE BEGINFAX_CH[]         = "@%d:";
static BYTE BEGINFAX_EXTNUM[]     = "%s-";
static BYTE BEGINFAX_TAIL[]       = ",%08d,RPDLMINI,%d,1,2,1,1,,1,%d,%s,1,,1,,,1,\x1B\x20";
static BYTE ENDFAX[]              = "\x1B\x12?F2,1\x1B\x20";


INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams)
{
    INT     ocmd, iRet;
    BYTE    Cmd[256];
    SHORT   nTmp;
    LPSTR   lpcmd;
    WORD    fLandscape, fFinisherSR30Active, fDoFormFeed, fPaperX;
// @Apr/02/2002 ->
//    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);   // @Oct/06/98
//    POEMPDEV         pOEM = MINIDEV_DATA(pdevobj);          // @Oct/06/98
    POEMUD_EXTRADATA pOEMExtra;
    POEMPDEV         pOEM;
// @Apr/02/2002 <-

//  VERBOSE(("OEMCommandCallback() entry.\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

// @Apr/02/2002 ->
    pOEMExtra = MINIPRIVATE_DM(pdevobj);
    pOEM = MINIDEV_DATA(pdevobj);
// @Apr/02/2002 <-

    //
    // fill in printer commands
    //
    ocmd = 0;
    iRet = 0;

    // If TextMode RectangleFill or Move_X,Y are not called now &&
    // Move_X,Y command is saved, then flush the command here.
    if (dwCmdCbID != CMD_SET_TEXTRECT_W && dwCmdCbID != CMD_SET_TEXTRECT_H &&
        dwCmdCbID != CMD_DRAW_TEXTRECT &&
        dwCmdCbID != CMD_DRAW_TEXTRECT_REL &&                       // @Dec/11/97
        dwCmdCbID != CMD_DRAW_TEXTRECT_WHITE &&                     // @Aug/14/98
        dwCmdCbID != CMD_DRAW_TEXTRECT_WHITE_REL &&                 // @Aug/14/98
        !(dwCmdCbID >= CMD_XM_ABS && dwCmdCbID <= CMD_YM_RELUP))    // @Aug/28/98
    {
        if (BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))          // @Dec/11/97
        {
            BITCLR32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
            // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
            if (!pOEM->TextRectGray)
            {
                if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                    WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
                else
                    WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
            }
        }

        if (dwCmdCbID == CMD_FF)
        {
            BITCLR32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
            BITCLR32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        }
        if (BITTEST32(pOEM->fGeneral1, YM_ABS_GONNAOUT))
        {
            BITCLR32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
            // Output Move_Y command here.
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ESC_YM_ABS, pOEM->TextCurPos.y);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
        if (BITTEST32(pOEM->fGeneral1, XM_ABS_GONNAOUT))
        {
            BITCLR32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
            // Output Move_X command here.
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ESC_XM_ABS, pOEM->TextCurPos.x);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
    }

    switch (dwCmdCbID) {
      case CMD_SET_TEXTRECT_W:          // pdwParams:RectXSize
        pOEM->TextRect.x = *pdwParams / pOEM->nResoRatio;
        break;

      case CMD_SET_TEXTRECT_H:          // pdwParams:RectYSize
        pOEM->TextRect.y = *pdwParams / pOEM->nResoRatio;
        break;

      case CMD_DRAW_TEXTRECT_WHITE:     // @Aug/14/98, pdwParams:DestX,DestY @Aug/28/98
        if (pOEM->TextRectGray || !BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
        {
            pOEM->TextRectGray = 0;
            WRITESPOOLBUF(pdevobj, SET_TEXTRECT_WHITE, sizeof(SET_TEXTRECT_WHITE)-1);
        }
        goto _DRAW_RECT;

      case CMD_DRAW_TEXTRECT:           // pdwParams:DestX,DestY,GrayPercentage
        // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
        if (!pOEM->TextRectGray)
        {
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
            else
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        }
        if ((WORD)*(pdwParams+2) >= 1 && (WORD)*(pdwParams+2) <= 100 &&
            (WORD)*(pdwParams+2) != pOEM->TextRectGray)  // @Jan/08/98, 3rd param @Aug/28/98
        {
            if ((pOEM->TextRectGray = (WORD)*(pdwParams+2)) == 100)  // @Aug/26/98
            {
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_TEXTRECT_BLACK);
            }
            else
            {
                WORD gray;
                if ((gray = pOEM->TextRectGray * RPDLGRAYMAX / 100) < RPDLGRAYMIN)
                    gray = RPDLGRAYMIN;             // use RPDLGRAYMIN  @Aug/15/98
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_TEXTRECT_GRAY, gray);
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }

      _DRAW_RECT:       // @Aug/14/98
// @Jan/13/99 ->
        if (!BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
            BITSET32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
// @Jan/13/99 <-
        {
            LONG x = pOEM->TextCurPos.x;
            LONG y = pOEM->TextCurPosRealY;     // y without page_length adjustment
            LONG w = pOEM->TextRect.x;
            LONG h = pOEM->TextRect.y;
            LONG dest_x = *pdwParams / pOEM->nResoRatio + pOEM->Offset.x;

            // UNIDRV5 SIDE ISSUE
            // We can rely on DestX, except when CmdCR is emitted.
            // Following bugs are concerned.
            // - RPDL117&124: Current x isn't updated by CMD_XM_ABS while device font
            //   direct(not-substituted) printing. -> DestX is reliable.
            // - #236215: DestX doesn't become 0 after CmdCR when current y is 0.
            //   (SP8 WINPARTy printarea.exe)      -> TextCurPos.x is reliable.
            // - DestX doesn't become 0 after CmdCR, even though current y isn't 0.
            //   (NX720N WINPARTy printarea.exe at 1200dpi) -> TextCurPos.x is reliable.
// @Mar/15/2001 ->
//          if (!(x != dest_x && x == pOEM->Offset.x && y == pOEM->Offset.y))
            if (!(x != dest_x && x == pOEM->Offset.x))
// @Mar/15/2001 <-
                pOEM->TextCurPos.x = x = dest_x;

            // Convert unit from dot to 1/720inch_unit at OLD models
            if (!(TEST_AFTER_SP10(pOEM->fModel) || BITTEST32(pOEM->fModel, GRP_MF150E)))
            {
                if (pOEM->nResoRatio == MASTERUNIT/240)   // 240dpi printer
                {
                    x *= 3;     // 3 = 720/240
                    y *= 3;
                    w *= 3;
                    h *= 3;
                }
                else    // MF530,150
                {
                    x *= 18;    // 18 = 720/400*10
                    w = (w * 18 + x % 10) / 10;     // Adjust fractional part
                    x /= 10;                        // KIRISUTE
                    y *= 18;
                    h = (h * 18 + y % 10) / 10;
                    y /= 10;
                }
            }
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), DRAW_TEXTRECT, x, y, w, h);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
        break;

      case CMD_DRAW_TEXTRECT_WHITE_REL: // @Aug/14/98, pdwParams:DestX,DestY @Aug/28/98
        if (pOEM->TextRectGray || !BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
        {
            pOEM->TextRectGray = 0;
            WRITESPOOLBUF(pdevobj, SET_TEXTRECT_WHITE, sizeof(SET_TEXTRECT_WHITE)-1);
        }
        goto _DRAW_RECT_REL;

      // Relative-coordinate rectangle command since NX-510  @Dec/12/97
      case CMD_DRAW_TEXTRECT_REL:       // pdwParams:DestX,DestY,GrayPercentage
        // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
        if (!pOEM->TextRectGray)
        {
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
            else
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        }
        if ((WORD)*(pdwParams+2) >= 1 && (WORD)*(pdwParams+2) <= 100 &&
            (WORD)*(pdwParams+2) != pOEM->TextRectGray)  // @Jan/08/98, 3rd param @Aug/28/98
        {
            if ((pOEM->TextRectGray = (WORD)*(pdwParams+2)) == 100)  // @Aug/26/98
            {
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_TEXTRECT_BLACK);
            }
            else
            {
                WORD gray;
                if ((gray = pOEM->TextRectGray * RPDLGRAYMAX / 100) < RPDLGRAYMIN)
                    gray = RPDLGRAYMIN;             // use RPDLGRAYMIN  @Aug/15/98
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_TEXTRECT_GRAY, gray);
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }

      _DRAW_RECT_REL:   // @Aug/14/98
        {
            LONG dest_x = *pdwParams / pOEM->nResoRatio + pOEM->Offset.x;

            // UNIDRV5 SIDE ISSUE
// @Mar/15/2001 ->
//          if (!(pOEM->TextCurPos.x != dest_x && pOEM->TextCurPos.x == pOEM->Offset.x &&
//                pOEM->TextCurPosRealY == pOEM->Offset.y))
            if (!(pOEM->TextCurPos.x != dest_x && pOEM->TextCurPos.x == pOEM->Offset.x))
// @Mar/15/2001 <-
            {
                pOEM->TextCurPos.x = dest_x;
            }
        }

        if (!BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))
        {
            BITSET32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), DRAW_TEXTRECT,
                           pOEM->TextCurPos.x, pOEM->TextCurPosRealY,
                           pOEM->TextRect.x, pOEM->TextRect.y);
        }
        else
        {
            LONG x = pOEM->TextCurPos.x - pOEM->TextRectPrevPos.x;
            LONG y = pOEM->TextCurPosRealY - pOEM->TextRectPrevPos.y;

            // If height is 1dot, this parameter can be omitted.
            if (pOEM->TextRect.y != 1)
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), DRAW_TEXTRECT_R_P4, x, y,
                               pOEM->TextRect.x, pOEM->TextRect.y);
            else
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), DRAW_TEXTRECT_R_P3, x, y,
                               pOEM->TextRect.x);
        }
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        pOEM->TextRectPrevPos.x = pOEM->TextCurPos.x;
        pOEM->TextRectPrevPos.y = pOEM->TextCurPosRealY;
        break;


      case CMD_SET_SRCBMP_H:            // @Jun/04/98
        pOEM->dwSrcBmpHeight = *pdwParams;
        break;

      case CMD_SET_SRCBMP_W:            // @Jun/04/98
        pOEM->dwSrcBmpWidthByte = *pdwParams;
        break;

      case CMD_OEM_COMPRESS_ON:         // @Jun/04/98
//      VERBOSE(("** OEM_COMPRESS_ON **\n"));
        BITSET32(pOEM->fGeneral2, OEM_COMPRESS_ON);
        BITCLR32(pOEM->fGeneral1, RLE_COMPRESS_ON);
        break;

      case CMD_RLE_COMPRESS_ON:
//      VERBOSE(("** RLE_COMPRESS_ON **\n"));
        BITSET32(pOEM->fGeneral1, RLE_COMPRESS_ON);
        BITCLR32(pOEM->fGeneral2, OEM_COMPRESS_ON);     // @Jun/04/98
        break;

      case CMD_COMPRESS_OFF:
//      VERBOSE(("** COMPRESS_OFF **\n"));
        BITCLR32(pOEM->fGeneral1, RLE_COMPRESS_ON);
        BITCLR32(pOEM->fGeneral2, OEM_COMPRESS_ON);     // @Jun/04/98
        break;

      case CMD_SEND_BLOCK:              // pdwParams:NumOfDataBytes,RasterDataH&W
        // Do FE-DeltaRow compression  @Jun/04/98
        if (BITTEST32(pOEM->fGeneral2, OEM_COMPRESS_ON))
        {
//          VERBOSE(("** OEM_COMPRESS_SEND (%d) **\n", *pdwParams));
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), BEGIN_SEND_BLOCK_DRC,
                           (WORD)*(pdwParams+2) * 8,      // RasterDataWidthInBytes
                           (WORD)*(pdwParams+1));         // RasterDataHeightInPixels
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
        else
        {
            // Do FE-RunLength compression
            if (BITTEST32(pOEM->fGeneral1, RLE_COMPRESS_ON))
            {
//              VERBOSE(("** RLE_COMPRESS_SEND (%d) **\n", *pdwParams));
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), BEGIN_SEND_BLOCK_C,
                               (WORD)*(pdwParams+2) * 8,  // RasterDataWidthInBytes
                               (WORD)*(pdwParams+1),      // RasterDataHeightInPixels
                               (WORD)*pdwParams);         // NumOfDataBytes
                WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            }
            // No compression
            else
            {
//              VERBOSE(("** NO_COMPRESS_SEND (%d) **\n", *pdwParams));
                {
                    ocmd = safe_sprintfA(Cmd, sizeof(Cmd), BEGIN_SEND_BLOCK_NC,
                                   (WORD)*(pdwParams+2) * 8,  // RasterDataWidthInBytes
                                   (WORD)*(pdwParams+1));     // RasterDataHeightInPixels
                    WRITESPOOLBUF(pdevobj, Cmd, ocmd);
                }
            }
        }
        break;


      case CMD_XM_ABS:                  // pdwParams:DestX
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
#ifdef DOWNLOADFONT
            pOEM->nCharPosMoveX = 0;
#endif // DOWNLOADFONT
            iRet = pOEM->TextCurPos.x = *pdwParams / pOEM->nResoRatio;  // @Aug/28/98
            pOEM->TextCurPos.x += pOEM->Offset.x;
            // Output Move_X command later.
            BITSET32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
//          VERBOSE(("** CMD_XM_ABS iRet=%d **\n", iRet));
        }
        break;

      case CMD_YM_ABS:                  // pdwParams:DestY
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = pOEM->TextCurPos.y = *pdwParams / pOEM->nResoRatio;  // @Aug/28/98
            pOEM->TextCurPosRealY = pOEM->TextCurPos.y;

            // PRINTER SIDE ISSUE: RPDL
            // Because RPDL do formfeed when vertical position is around
            // ymax-coordinate, we shift position upper 1mm.
            if (pOEM->TextCurPos.y > pOEM->PageMaxMoveY)
                pOEM->TextCurPos.y = pOEM->PageMaxMoveY;
            pOEM->TextCurPos.y += pOEM->Offset.y;
            pOEM->TextCurPosRealY += pOEM->Offset.y;
            // Output Move_Y command later.
            BITSET32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
//          VERBOSE(("** CMD_YM_ABS iRet=%d **\n", iRet));
        }
        break;

      case CMD_XM_REL:                  // pdwParams:DestXRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.x += iRet;
            // Output Move_X command later.
            BITSET32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        }
        break;

      case CMD_XM_RELLEFT:              // pdwParams:DestXRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.x -= iRet;
            // Output Move_X command later.
            BITSET32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        }
        break;

      case CMD_YM_REL:                  // pdwParams:DestYRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.y += iRet;
            pOEM->TextCurPosRealY = pOEM->TextCurPos.y;
            if (pOEM->TextCurPos.y > pOEM->PageMaxMoveY)
                pOEM->TextCurPos.y = pOEM->PageMaxMoveY;
            // Output Move_Y command later.
            BITSET32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
        }
        break;

      case CMD_YM_RELUP:                // pdwParams:DestYRel
        if (!BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID))
        {
            iRet = *pdwParams / pOEM->nResoRatio;           // @Aug/28/98
            pOEM->TextCurPos.y -= iRet;
            pOEM->TextCurPosRealY = pOEM->TextCurPos.y;
            // Output Move_Y command later.
            BITSET32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
        }
        break;

      case CMD_CR:
#ifdef DOWNLOADFONT
        pOEM->nCharPosMoveX = 0;    // @Jan/19/98
#endif // DOWNLOADFONT
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), CR);
        if ((pOEM->TextCurPos.x = pOEM->Offset.x) != 0)
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ESC_XM_ABS, pOEM->TextCurPos.x);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
//      VERBOSE(("** CMD_CR **\n"));
        break;

      case CMD_LF:
        WRITESPOOLBUF(pdevobj, LF, sizeof(LF)-1);
        break;

      case CMD_BS:
        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
        break;

      case CMD_FF:
        fDoFormFeed = FALSE;
        // If 2in1
        if (TEST_2IN1_MODE(pOEM->fGeneral1))
        {
            // If 2nd page finished
            if (pOEM->Nin1RemainPage)
            {
                pOEM->Nin1RemainPage = 0;
                // Initialize offset
                pOEM->Offset.x = pOEM->BaseOffset.x;
                pOEM->Offset.y = pOEM->BaseOffset.y;
                // Output formfeed command later
                fDoFormFeed = TRUE;
            }
            // If not 2nd page, disable formfeed and increase offset.
            else
            {
                WORD PageSpace, wTmp;

                pOEM->Nin1RemainPage++;
                // space(dot) between 2pages of 2in1.
                if (BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT))    // @Nov/27/97
                {
                    wTmp = BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_67)?
                           PageSpace_2IN1_67E2E[pOEM->DocPaperID] :
                           PAGESPACE_2IN1_100E2E;
                }
                else
                {
                    wTmp = BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_67)?
                           PageSpace_2IN1_67[pOEM->DocPaperID] :
                           PAGESPACE_2IN1_100;
                }
                PageSpace = ((WORD)(MASTERUNIT*10)/(WORD)254) * wTmp /
                             pOEM->nResoRatio;

                if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
                    pOEM->Offset.y = pOEM->PageMax.y + pOEM->BaseOffset.y + PageSpace;
                else
                    pOEM->Offset.x = pOEM->PageMax.x + pOEM->BaseOffset.x + PageSpace;
            } // 'if (Nin1RemainPage) else' end
        }
        // If 4in1
        else if (TEST_4IN1_MODE(pOEM->fGeneral1))     // OLD MF do not support this
        {
            switch (++pOEM->Nin1RemainPage)     // bug fix @Jan/20/99
            {
              default:  // If illegal, treat as 1st page finished.
                pOEM->Nin1RemainPage = 1;
                pOEM->Offset.y = pOEM->BaseOffset.y;
              case 1:
                pOEM->Offset.x = pOEM->PageMax.x + pOEM->BaseOffset.x;
                break;
              case 2:
                pOEM->Offset.x = pOEM->BaseOffset.x;
                pOEM->Offset.y = pOEM->PageMax.y + pOEM->BaseOffset.y;
                break;
              case 3:
                pOEM->Offset.x = pOEM->PageMax.x + pOEM->BaseOffset.x;
                break;
              case 4:   // 4th page finished
                pOEM->Nin1RemainPage = 0;
                // Initialize offset
                pOEM->Offset.x = pOEM->BaseOffset.x;
                pOEM->Offset.y = pOEM->BaseOffset.y;
                // Output formfeed command later
                fDoFormFeed = TRUE;
                break;
            }
        }
        // Usual case (non Nin1 mode)
        else
        {
            // Output formfeed command later
            fDoFormFeed = TRUE;
        } // 'if (TEST_2IN1_MODE) else if (TEST_4IN1_MODE) else' end

        BITCLR32(pOEM->fGeneral1, TEXT_CLIP_VALID);

        if (fDoFormFeed)
        {
            if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))  // @Sep/14/98
                DrawTOMBO(pdevobj, DRAW_TOMBO);

            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);       // moved here @Sep/14/98

            // SPEC of RPDL
            // Because RPDL's formfeed resets font status(vertical-text, bold, italic,
            // white-text and  TextMode clipping), we must output these commands again.
            if (BITTEST32(pOEM->fGeneral1, FONT_VERTICAL_ON))
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ESC_VERT_ON);
            if (BITTEST32(pOEM->fGeneral1, FONT_BOLD_ON))
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ESC_BOLD_ON);
            if (BITTEST32(pOEM->fGeneral1, FONT_ITALIC_ON))
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ESC_ITALIC_ON);
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ESC_WHITETEXT_ON);
        } // 'if (fDoFormFeed)' end

        // Reset coordinate x&y
        pOEM->TextCurPos.x = pOEM->Offset.x;
        pOEM->TextCurPos.y = pOEM->Offset.y;
        // SPEC of Unidrv5 & RPDL   @Aug/14/98
        // Unidrv5 doesn't order to set coordinate x,y to 0 after returning iRet=0,
        // and RPDL doesn't reset coordinate y of SEND_BLOCK after initializing
        // printer.
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ESC_XM_ABS, pOEM->TextCurPos.x);
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ESC_YM_ABS, pOEM->TextCurPos.y);
        // reset coordinate y without page_length adjustment, too.
        pOEM->TextCurPosRealY = pOEM->TextCurPos.y;
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_FONT_BOLD_ON:
        if (!BITTEST32(pOEM->fGeneral1, FONT_BOLD_ON))      // add  @Jan/28/99
        {
            BITSET32(pOEM->fGeneral1, FONT_BOLD_ON);
            WRITESPOOLBUF(pdevobj, ESC_BOLD_ON, sizeof(ESC_BOLD_ON)-1);
        }
        break;

      case CMD_FONT_BOLD_OFF:
        if (BITTEST32(pOEM->fGeneral1, FONT_BOLD_ON))       // add  @Jan/28/99
        {
            BITCLR32(pOEM->fGeneral1, FONT_BOLD_ON);
            WRITESPOOLBUF(pdevobj, ESC_BOLD_OFF, sizeof(ESC_BOLD_OFF)-1);
        }
        break;

      case CMD_FONT_ITALIC_ON:
        if (!BITTEST32(pOEM->fGeneral1, FONT_ITALIC_ON))    // add  @Jan/28/99
        {
            BITSET32(pOEM->fGeneral1, FONT_ITALIC_ON);
            WRITESPOOLBUF(pdevobj, ESC_ITALIC_ON, sizeof(ESC_ITALIC_ON)-1);
        }
        break;

      case CMD_FONT_ITALIC_OFF:
        if (BITTEST32(pOEM->fGeneral1, FONT_ITALIC_ON))     // add  @Jan/28/99
        {
            BITCLR32(pOEM->fGeneral1, FONT_ITALIC_ON);
            WRITESPOOLBUF(pdevobj, ESC_ITALIC_OFF, sizeof(ESC_ITALIC_OFF)-1);
        }
        break;

      case CMD_FONT_WHITETEXT_ON:
        BITSET32(pOEM->fGeneral1, FONT_WHITETEXT_ON);
        WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
        break;

      case CMD_FONT_WHITETEXT_OFF:
        BITCLR32(pOEM->fGeneral1, FONT_WHITETEXT_ON);
        WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        break;


#ifdef DOWNLOADFONT
      case CMD_DL_SET_FONT_ID:      // pdwParams:FontHeight
// OBSOLETE @Nov/20/98 ->
//      pOEM->DLFontH_MU = (WORD)*pdwParams;        // @Jun/30/98
// @Nov/20/98 <-
        break;

      case CMD_DL_SELECT_FONT_ID:
// OBSOLETE @Jun/30/98 ->
//      pOEM->DLFontCurID = (WORD)*pdwParams;       // CurrentFontID
// @Jun/30/98 <-
        break;

      case CMD_DL_SET_FONT_GLYPH:   // pdwParams:NextGlyph
//      VERBOSE(("[DL_SET_FONT_GLYPH] glyph=%d\n", (SHORT)*pdwParams));
        pOEM->DLFontCurGlyph = (WORD)*pdwParams;
        break;

//
// Following cases are called at the beginning of a print-job
//
      case CMD_SET_MEM0KB:          // JOB_SETUP.10  @Jan/14/98
        pOEM->DLFontMaxMemKB = 0;                   // disabled
        pOEM->pDLFontGlyphInfo = NULL;              // @Sep/08/98
        break;

      case CMD_SET_MEM128KB:
        pOEM->DLFontMaxMemKB = MEM128KB;            // 128Kbytes
        pOEM->DLFontMaxID    = DLFONT_ID_4;         // 2->4 @Oct/20/98
        goto _SET_MEM_ENABLE;

      case CMD_SET_MEM256KB:
        pOEM->DLFontMaxMemKB = MEM256KB;            // 256Kbytes
        pOEM->DLFontMaxID    = DLFONT_ID_8;         // 4->8 @Oct/20/98
        goto _SET_MEM_ENABLE;

      case CMD_SET_MEM512KB:
        pOEM->DLFontMaxMemKB = MEM512KB;            // 512Kbytes
        pOEM->DLFontMaxID    = DLFONT_ID_16;        // 8->16 @Oct/20/98
//      goto _SET_MEM_ENABLE;

      _SET_MEM_ENABLE:      // @Sep/08/98
        pOEM->DLFontMaxGlyph = DLFONT_GLYPH_TOTAL;  // 116->70 @Oct/20/98
        // allocate glyph info structure for TrueType download.
// fix memory leak @Nov/22/2002 ->
        // if already allocated, exit
        if(pOEM->pDLFontGlyphInfo)
            break;
// @Nov/22/2002 <-
        if(!(pOEM->pDLFontGlyphInfo = (FONTPOS*)MemAllocZ(pOEM->DLFontMaxID *
                                                          pOEM->DLFontMaxGlyph *
                                                          sizeof(FONTPOS))))
        {
            pOEM->DLFontMaxMemKB = 0;   // disabled
        }
        break;
#endif // DOWNLOADFONT

      case CMD_SELECT_STAPLE_NONE:  // JOB_SETUP.20  @Dec/02/97
        pOEM->StapleType = 0;
        break;

      case CMD_SELECT_STAPLE_1:
        pOEM->StapleType = 1;
        break;

      case CMD_SELECT_STAPLE_2:
        pOEM->StapleType = 2;
        break;

      case CMD_SELECT_STAPLE_MAX1:  // @Mar/18/99
        pOEM->StapleType = 3;       // stapling with FinisherSR12(max 1staple)
        break;

      case CMD_SELECT_PUNCH_NONE:   // JOB_SETUP.30  @Dec/02/97
        pOEM->PunchType = 0;
        break;

      case CMD_SELECT_PUNCH_1:
        pOEM->PunchType = 1;
        break;


      case CMD_BEGINDOC_SP4II:      // SP4mkII,5
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP4II);
        // Set Emulation:RPDL, Code:SJIS
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), BEGINDOC1);
        // Set Graphics:KAN-I G, Page-Length:max
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BEGINDOC2_1);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        goto _BEGINDOC_FINISH2;        // @Sep/09/98;

      case CMD_BEGINDOC_MF530:      // MF530
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF530);
        // Set Emulation:RPDL, Code:SJIS
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), BEGINDOC1);
        // Set Page-Length:max
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BEGINDOC2_2);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        goto _BEGINDOC_FINISH2;        // @Sep/09/98;

      case CMD_BEGINDOC_MF150:      // MF150
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF150);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF150E:     // MF150e,160
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF150E);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP8:        // SP8(7),8(7)mkII,80
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP8);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MFP250:     // MF-P250,355,250(FAX),355(FAX),MF-FD355,MF-P250e,355e
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MFP250);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP10:       // SP10,10mkII
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP10);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP9:        // SP9,10Pro
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP9);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_SP9II:      // SP9II,10ProII,90
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_SP9II);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF200:      // MF200,MF-p150,MF2200
        pOEM->fModel = 0;           // (separate BEGINDOC_SP9II @Sep/01/98)
        BITSET32(pOEM->fModel, GRP_MF200);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX100:      // NX-100
        pOEM->fModel = 0;
        // not support IBM extended character block
        BITSET32(pOEM->fModel, GRP_NX100);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX500:      // NX-500,1000,110,210,510,1100
        pOEM->fModel = 0;
        // TT font download capable
        BITSET32(pOEM->fModel, GRP_NX500);
        goto _BEGINDOC_FINISH1;

// OBSOLETE @Apr/15/99
//    case CMD_BEGINDOC_MFP250E:    // MF-P250e,355e
//      pOEM->fModel = 0;
//      BITSET32(pOEM->fModel, GRP_MFP250E);
//      goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF250M:    // MF250M
        // staple capable
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF250M);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF3550:    // MF2700,3500,3550,4550,5550,6550,3530,3570,4570,5550EX,6550EX,1530
        // staple & punch & media type option
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF3550);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF3530E:    // MF3530e,3570e,4570e,5570,7070,8570,105Pro  @Jun/25/2001
        // Job define command is needed for staple
        pOEM->fModel = 0;
        BITSET32(pOEM->fModel, GRP_MF3530E);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_MF3300:    // MF3300W,3350W,3540W,3580W
        pOEM->fModel = 0;
        // A2 printer
        BITSET32(pOEM->fModel, GRP_MF3300);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_IP1:       // IP-1
        pOEM->fModel = 0;
        // A1 plotter
        BITSET32(pOEM->fModel, GRP_IP1);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX70:      // NX70,71  @Feb/04/98
        pOEM->fModel = 0;
        // A4 printer, FE-DeltaRow
        BITSET32(pOEM->fModel, GRP_NX70);   // BITSET->BITSET32  @Jun/01/98
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX700:     // NX700,600,FAX Printer,MF700  @Jun/12/98
        pOEM->fModel = 0;
        // FE-DeltaRow
        BITSET32(pOEM->fModel, GRP_NX700);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX900:     // NX900  @Jan/08/99
        pOEM->fModel = 0;
        // Job define command is needed for shifted collate
        BITSET32(pOEM->fModel, GRP_NX900);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX800:     // NX800,910,810,MF2230,2730  @Mar/03/99, remove MF1530 @Jun/25/2001
        pOEM->fModel = 0;
        // Job define command is needed for staple
        BITSET32(pOEM->fModel, GRP_NX800);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX710:    // NX710,610  @Jun/23/2000
        pOEM->fModel = 0;
        // FE-DeltaRow & media type option (& variable scaling bug)
        BITSET32(pOEM->fModel, GRP_NX710);
        goto _BEGINDOC_FINISH1;

      case CMD_BEGINDOC_NX720:    // NX620,620N,720N,Neo350,350D,450,220,270  @Sep/26/2000
        pOEM->fModel = 0;
        // FE-DeltaRow & media type option (GW model)
        BITSET32(pOEM->fModel, GRP_NX720);
//      goto _BEGINDOC_FINISH1;

      _BEGINDOC_FINISH1:
// Jun/29/2001 ->
        pOEM->FinisherTrayNum = 1;
        // set Emulation:RPDL
        if (TEST_NEED_JOBDEF_CMD(pOEM->fModel))
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), BEGINDOC_TOP_JOBDEF);   // with Job define command
        else
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), BEGINDOC_TOP);          // without Job define command
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        ocmd = 0;
// Jun/29/2001 <-

        if (BITTEST32(pOEMExtra->fUiOption, FAX_MODEL))
            SendFaxNum(pdevobj);
        // Set Code:SJIS
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), BEGINDOC1_2);               // <-BEGINDOC1 @Jun/25/2001
        // Set Graphics:KAN-I G, Page-Length:max
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BEGINDOC2_1);
        // Set Duplex:off
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BEGINDOC3);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
#ifdef DOWNLOADFONT
        pOEM->dwDLFontUsedMem = 0;
        if (pOEM->DLFontMaxMemKB)
        {
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), DLFONT_MALLOC, pOEM->DLFontMaxMemKB, DLFONT_MIN_BLOCK_ID);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        }
#endif // DOWNLOADFONT

      _BEGINDOC_FINISH2:   // @Sep/09/98
        // Allocate heap memory for bOEMOutputCharStr&OEMDownloadCharGlyph. 
// fix memory leak @Nov/22/2002 ->
        // if already allocated, exit
        if(pOEM->pRPDLHeap2K)
            break;
// @Nov/22/2002 <-
        pOEM->pRPDLHeap2K = (PBYTE)MemAllocZ(HEAPSIZE2K);
        break;


      case CMD_SET_BASEOFFSETX_0:   // @May/07/98
      case CMD_SET_BASEOFFSETX_1:
      case CMD_SET_BASEOFFSETX_2:
      case CMD_SET_BASEOFFSETX_3:
      case CMD_SET_BASEOFFSETX_4:
      case CMD_SET_BASEOFFSETX_5:
        pOEM->BaseOffset.x = (LONG)(dwCmdCbID - CMD_SET_BASEOFFSETX_0);
        break;

      case CMD_SET_BASEOFFSETY_0:   // @May/07/98
      case CMD_SET_BASEOFFSETY_1:
      case CMD_SET_BASEOFFSETY_2:
      case CMD_SET_BASEOFFSETY_3:
      case CMD_SET_BASEOFFSETY_4:
      case CMD_SET_BASEOFFSETY_5:
        pOEM->BaseOffset.y = (LONG)(dwCmdCbID - CMD_SET_BASEOFFSETY_0);
        break;


      case CMD_RES240:
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/240;
        // Set Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        if (!BITTEST32(pOEM->fModel, GRP_SP4II))
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), IMAGE_OPT_OFF);
        // Set Spacing_Unit:1/240inch
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SELECT_RES240_1);
        if (TEST_AFTER_SP10(pOEM->fModel))                // SP10,9,etc
            // Set Graphics_Unit & Coordinate_Unit:1/240inch,Engine_Resolution:240dpi
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SELECT_RES240_2);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;

      case CMD_RES400:
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/400;
        // Set Spacing_Unit & Graphics_Unit:1/400inch
        // & Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SELECT_RES400_1);
        if (!BITTEST32(pOEM->fModel, GRP_MF530))
        {
            // Set Engine_Resolution:400dpi
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SELECT_RES400_2);
            if (TEST_AFTER_SP10(pOEM->fModel) ||
                BITTEST32(pOEM->fModel, GRP_MF150E))      // MF150e,160
            {
                // Set Coordinate_Unit:1/400inch
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SELECT_RES400_3);
            }
        }
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;

      case CMD_RES600:
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/600;
#ifdef DOWNLOADFONT
        // If non-DRC&&600dpi then make it half.  @Jun/15/98
        if (!TEST_CAPABLE_DOWNLOADFONT_DRC(pOEM->fModel))
            pOEM->DLFontMaxID /= 2;
#endif // DOWNLOADFONT
        // Set Spacing_Unit & Graphics_Unit & Coordinate_Unit:1/600inch,
        // Engine_Resolution:600dpi
        // & Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        WRITESPOOLBUF(pdevobj, SELECT_RES600, sizeof(SELECT_RES600)-1);
        break;

      case CMD_RES1200:             // @Mar/02/99
        pOEM->fGeneral1 = pOEM->fGeneral2 = 0;
        pOEM->nResoRatio = MASTERUNIT/1200;
#ifdef DOWNLOADFONT
        pOEM->DLFontMaxID /= 2;
#endif // DOWNLOADFONT
        // Set Spacing_Unit & Graphics_Unit & Coordinate_Unit:1/1200inch,
        // Engine_Resolution:1200dpi
        // & Options[duplex/2in1:off,reversed_output:on,sort/stack:off]
        WRITESPOOLBUF(pdevobj, SELECT_RES1200, sizeof(SELECT_RES1200)-1);
        break;


      case CMD_REGION_STANDARD:     // @Nov/29/97
        BITCLR32(pOEM->fGeneral2, EDGE2EDGE_PRINT);
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))  // @Sep/15/98
            WRITESPOOLBUF(pdevobj, SELECT_REGION_E2E, sizeof(SELECT_REGION_E2E)-1);
        else
            WRITESPOOLBUF(pdevobj, SELECT_REGION_STD, sizeof(SELECT_REGION_STD)-1);
        break;

      case CMD_REGION_EDGE2EDGE:    // @Nov/29/97
        BITSET32(pOEM->fGeneral2, EDGE2EDGE_PRINT);
        WRITESPOOLBUF(pdevobj, SELECT_REGION_E2E, sizeof(SELECT_REGION_E2E)-1);
        break;


      case CMD_IMGCTRL_100:
        if (pOEMExtra->UiScale != VAR_SCALING_DEFAULT)  // @Feb/06/98
        {
            pOEM->Scale = pOEMExtra->UiScale;           // @Mar/18/98
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), IMAGE_SCALING_VAR, pOEM->Scale);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
            break;
        }
        pOEM->Scale = 100;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_100, sizeof(IMAGE_SCALING_100)-1);
        break;

      case CMD_IMGCTRL_88:
        pOEM->Scale = 88;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_88, sizeof(IMAGE_SCALING_88)-1);
        break;

      case CMD_IMGCTRL_80:
        pOEM->Scale = 80;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_80, sizeof(IMAGE_SCALING_80)-1);
        break;

      case CMD_IMGCTRL_75:
        pOEM->Scale = 75;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_75, sizeof(IMAGE_SCALING_75)-1);
        break;

      case CMD_IMGCTRL_70:
        pOEM->Scale = 70;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_70, sizeof(IMAGE_SCALING_70)-1);
        break;

      case CMD_IMGCTRL_67:
        pOEM->Scale = 67;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        break;

      case CMD_IMGCTRL_115:
        pOEM->Scale = 115;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_115, sizeof(IMAGE_SCALING_115)-1);
        break;

      case CMD_IMGCTRL_122:
        pOEM->Scale = 122;                              // @Mar/18/98
        if (TEST_PLOTTERMODEL_SCALING(pOEM->fModel))
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_122, sizeof(IMAGE_SCALING_122)-1);
        }
        else
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_122V, sizeof(IMAGE_SCALING_122V)-1);
            BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
        }
        break;

      case CMD_IMGCTRL_141:
        pOEM->Scale = 141;                              // @Mar/18/98
        if (TEST_PLOTTERMODEL_SCALING(pOEM->fModel))
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_141, sizeof(IMAGE_SCALING_141)-1);
        }
        else
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_141V, sizeof(IMAGE_SCALING_141V)-1);
            BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
        }
        break;

      case CMD_IMGCTRL_200:
        pOEM->Scale = 200;                              // @Mar/18/98
        if (TEST_PLOTTERMODEL_SCALING(pOEM->fModel))
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_200, sizeof(IMAGE_SCALING_200)-1);
        }
        else
        {
            WRITESPOOLBUF(pdevobj, IMAGE_SCALING_200V, sizeof(IMAGE_SCALING_200V)-1);
            BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
        }
        break;

      case CMD_IMGCTRL_50:
        pOEM->Scale = 50;                               // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_50V, sizeof(IMAGE_SCALING_50V)-1);
        BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
        break;

      case CMD_IMGCTRL_AA67:        // A->A scaling(67%)
        pOEM->Scale = 67;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA67);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        break;

      case CMD_IMGCTRL_BA80:        // B->A scaling(80%)
        pOEM->Scale = 80;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_BA80);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_80, sizeof(IMAGE_SCALING_80)-1);
        break;

      case CMD_IMGCTRL_BA115:       // B->A scaling(115%)
        pOEM->Scale = 115;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_BA115);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_115, sizeof(IMAGE_SCALING_115)-1);
        break;

      case CMD_DRV_4IN1_50:         // 4in1
        pOEM->Scale = 50;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_4IN1_50);
        pOEM->Nin1RemainPage = 0;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_50V, sizeof(IMAGE_SCALING_50V)-1);
        BITSET32(pOEM->fGeneral1, VARIABLE_SCALING_VALID);  // @Jan/27/2000
        break;

      case CMD_DRV_2IN1_67:         // 2in1
        pOEM->Scale = 67;                               // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_2IN1_67);
        pOEM->Nin1RemainPage = 0;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        break;

      case CMD_DRV_2IN1_100:        // 2in1
        pOEM->Scale = 100;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_2IN1_100);
        pOEM->Nin1RemainPage = 0;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_100, sizeof(IMAGE_SCALING_100)-1);
        break;

      case CMD_IMGCTRL_AA141:       // IP-1,3300W,3350W:A->A scaling(141%)
        pOEM->Scale = 141;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA141);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_141, sizeof(IMAGE_SCALING_141)-1);
        break;

      case CMD_IMGCTRL_AA200:       // IP-1:A->A scaling(200%)
        pOEM->Scale = 200;                              // @Mar/18/98
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA200);
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_200, sizeof(IMAGE_SCALING_200)-1);
        break;

      case CMD_IMGCTRL_AA283:       // IP-1:A->A scaling(283%)
        BITSET32(pOEM->fGeneral1, IMGCTRL_AA283);
      case CMD_IMGCTRL_283:         // IP-1
        pOEM->Scale = 283;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_283, sizeof(IMAGE_SCALING_283)-1);
        break;

      case CMD_IMGCTRL_A1_400:      // IP-1:400% with A1
        BITSET32(pOEM->fGeneral1, IMGCTRL_A1_400);
      case CMD_IMGCTRL_400:         // IP-1
        pOEM->Scale = 400;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_400, sizeof(IMAGE_SCALING_400)-1);
        break;


      case CMD_SET_LANDSCAPE:
        BITSET32(pOEM->fGeneral1, ORIENT_LANDSCAPE);
        break;

      case CMD_SET_PORTRAIT:
        BITCLR32(pOEM->fGeneral1, ORIENT_LANDSCAPE);
        break;


// OBSOLETE (actually obsoleted at converting GPC to GPD) @Jan/08/99 ->
//    case CMD_DUPLEX_ON:
//      BITSET32(pOEM->fGeneral1, DUPLEX_VALID);
//      break;
// @Jan/08/99 <-

      case CMD_DUPLEX_VERT:
        BITSET32(pOEM->fGeneral1, DUPLEX_VALID);            // @Jan/08/99
        if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
        {
            if (!TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_H;
        }
        else
        {
            if (TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_H;
        }
      _DUP_V:
        if (pOEMExtra->UiBindMargin)
        {
            BITSET32(pOEM->fGeneral1, DUPLEX_LEFTMARGIN_VALID);
            // Convert mm to 5mm_unit(2=5mm,3=10mm,...,11=50mm)
            nTmp = (pOEMExtra->UiBindMargin + 4) / 5 + 1;
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_LEFTMARGIN, nTmp);
            // SP9II(except 1st lot),10ProII can set binding margin every 1 mm
            if (TEST_AFTER_SP9II(pOEM->fModel))
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_LEFTMARGIN_9II, pOEMExtra->UiBindMargin);
        }
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_BIND_RIGHT))
        {
            pOEM->BindPoint = BIND_RIGHT;
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DUPLEX_VERT_R);
        }
        else
        {
            pOEM->BindPoint = BIND_LEFT;
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DUPLEX_VERT);
        }
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DUPLEX_ON);
// DCR  @Jan/27/2000 ->
        // Emit IMAGE_SCALING_xxxV here, because DUPLEX_VERT resets IMAGE_SCALING_xxxV
        if (BITTEST32(pOEM->fGeneral1, VARIABLE_SCALING_VALID));
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, IMAGE_SCALING_VAR, pOEM->Scale);
// @Jan/27/2000 <-
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;

      case CMD_DUPLEX_HORZ:
        BITSET32(pOEM->fGeneral1, DUPLEX_VALID);            // @Jan/08/99
        if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
        {
            if (!TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_V;
        }
        else
        {
            if (TEST_2IN1_MODE(pOEM->fGeneral1))
                goto _DUP_V;
        }
      _DUP_H:
        if (pOEMExtra->UiBindMargin)
        {
            BITSET32(pOEM->fGeneral1, DUPLEX_UPPERMARGIN_VALID);
            nTmp = (pOEMExtra->UiBindMargin + 4) / 5 + 1;
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_UPPERMARGIN, nTmp);
            if (TEST_AFTER_SP9II(pOEM->fModel))
            {
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_UPPERMARGIN_9II, pOEMExtra->UiBindMargin);
            }
        }
        pOEM->BindPoint = BIND_UPPER;
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DUPLEX_HORZ);
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DUPLEX_ON);
// DCR  @Jan/27/2000 ->
        // Emit IMAGE_SCALING_xxxV here, because DUPLEX_HORZ resets IMAGE_SCALING_xxxV
        if (BITTEST32(pOEM->fGeneral1, VARIABLE_SCALING_VALID));
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, IMAGE_SCALING_VAR, pOEM->Scale);
// @Jan/27/2000 <-
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        break;


      case CMD_MEDIATYPE_STANDARD:
            pOEM->MediaType = MEDIATYPE_STD;    // use pOEM->MediaType  @Mar/03/99
            break;

      case CMD_MEDIATYPE_OHP:
            pOEM->MediaType = MEDIATYPE_OHP;
            break;

      case CMD_MEDIATYPE_THICK:
            pOEM->MediaType = MEDIATYPE_THICK;
            break;

      case CMD_MEDIATYPE_SPL:       // since MF1530  @Mar/03/99
            pOEM->MediaType = MEDIATYPE_SPL;
            break;

      case CMD_MEDIATYPE_TRACE:     // since MF5570  @Feb/15/2000
            pOEM->MediaType = MEDIATYPE_TRACE;
            break;

      case CMD_MEDIATYPE_LABEL:     // since Neo450  @Oct/12/2000
            pOEM->MediaType = MEDIATYPE_LABEL;
            break;

      case CMD_MEDIATYPE_THIN:      // since Neo270  @Feb/05/2001
            pOEM->MediaType = MEDIATYPE_THIN;
            break;

      case CMD_SELECT_PAPER_A2:
        pOEM->DocPaperID = RPDL_A2;
        // If A->A(67%), scale down papersize.
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = SELECT_PAPER_A3;
        else
            lpcmd = SELECT_PAPER_A2;
        // Store papername to buffer
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        // Because incapable, clear setting
        if (TEST_NIN1_MODE(pOEM->fGeneral1)              ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A3:
        pOEM->DocPaperID = RPDL_A3;
        // If able to select tray with "papername+X" && no staple && no punch
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO) &&
            TEST_CAPABLE_PAPER_A2(pOEM->fModel))
        {
            lpcmd = SELECT_PAPER_B3;
            pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
            goto _IMGCTRL_OFF1;
        }
        // If A->A(67%), scale down papersize.
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        // If A->A(141%), scale up papersize.
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = SELECT_PAPER_A2;
        // If A->A(200%) || A1(400%), scale up papersize.
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200) ||
                 BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = SELECT_PAPER_A3;
        // Store papername to buffer
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        // Because incapable, clear setting
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A4:
        pOEM->DocPaperID = RPDL_A4;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = SELECT_PAPER_B4;
            pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
            goto _IMGCTRL_OFF1;
        }
        // If 2in1(100%), scale up papersize.
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = SELECT_PAPER_A3;
        // If A->A(67%), scale down papersize.
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200))
            lpcmd = SELECT_PAPER_A2;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283) ||
                 BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A5:
        pOEM->DocPaperID = RPDL_A5;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67))
            lpcmd = SELECT_PAPER_A6;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200))
            lpcmd = SELECT_PAPER_A3;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
            lpcmd = SELECT_PAPER_A2;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_A6:
        pOEM->DocPaperID = RPDL_A6;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
            lpcmd = SELECT_PAPER_A3;
        else
            lpcmd = SELECT_PAPER_A6;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_POSTCARD:       // since NX700  @Feb/13/98
        pOEM->DocPaperID = RPDL_POSTCARD;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = SELECT_PAPER_A4X;
            pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
            goto _IMGCTRL_OFF1;
        }
        lpcmd = SELECT_PAPER_PCX;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B3:             // @Jan/07/98
        pOEM->DocPaperID = RPDL_B3;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = SELECT_PAPER_A3;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = SELECT_PAPER_A2;
        else
            lpcmd = SELECT_PAPER_B3;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1)              ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B4:
        pOEM->DocPaperID = RPDL_B4;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = SELECT_PAPER_A3;
            pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = SELECT_PAPER_A3;
        else
            lpcmd = SELECT_PAPER_B4;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B5:
        pOEM->DocPaperID = RPDL_B5;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = SELECT_PAPER_B4;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_B5X : SELECT_PAPER_B5W;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_B6:
        pOEM->DocPaperID = RPDL_B6;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        // If TOMBO is enabled, scale up papersize.  @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
            pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
            goto _IMGCTRL_OFF1;
        }
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = (fPaperX)? SELECT_PAPER_B5X : SELECT_PAPER_B5W;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80))
            lpcmd = SELECT_PAPER_A6;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115))
            lpcmd = (fPaperX)? SELECT_PAPER_A5X : SELECT_PAPER_A5W;
        else
            lpcmd = SELECT_PAPER_B6;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_C:
        pOEM->DocPaperID = RPDL_C;
        lpcmd = SELECT_PAPER_C;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_TABLOID:
        pOEM->DocPaperID = RPDL_TABD;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = SELECT_PAPER_TABD;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100) ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_LEGAL:
        pOEM->DocPaperID = RPDL_LEGL;
        lpcmd = SELECT_PAPER_LEGL;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_LETTER:
        pOEM->DocPaperID = RPDL_LETR;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = SELECT_PAPER_TABD;
        else if (BITTEST32(pOEM->fGeneral1, IMGCTRL_A1_400))
            lpcmd = SELECT_PAPER_A1;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_LETRX : SELECT_PAPER_LETRW;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_AA67)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA80)     ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_BA115)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA141)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA200)    ||
            BITTEST32(pOEM->fGeneral1, IMGCTRL_AA283))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      case CMD_SELECT_PAPER_STATEMENT:
        pOEM->DocPaperID = RPDL_STAT;
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        if (BITTEST32(pOEM->fGeneral1, IMGCTRL_2IN1_100))
            lpcmd = (fPaperX)? SELECT_PAPER_LETRX : SELECT_PAPER_LETRW;
        else
            lpcmd = (fPaperX)? SELECT_PAPER_STATX : SELECT_PAPER_STATW;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
            goto _IMGCTRL_OFF1;
        break;

      case CMD_SELECT_PAPER_A2TOA3:
        pOEM->DocPaperID = RPDL_A2A3;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
// DCR  @Jan/27/2000 ->
        // Emit DUPLEX_ON here, because IMAGE_SCALING_xxx resets DUPLEX_ON.
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_VALID))
            WRITESPOOLBUF(pdevobj, DUPLEX_ON, sizeof(DUPLEX_ON)-1);
// @Jan/27/2000 <-
        lpcmd = SELECT_PAPER_A3;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF2;
        }
        break;

      case CMD_SELECT_PAPER_A3TOA4:         // for NX70  @Feb/04/98
        pOEM->DocPaperID = RPDL_A3A4;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
// DCR  @Jan/27/2000 ->
        // Emit DUPLEX_ON here, because IMAGE_SCALING_xxx resets DUPLEX_ON.
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_VALID))
            WRITESPOOLBUF(pdevobj, DUPLEX_ON, sizeof(DUPLEX_ON)-1);
// @Jan/27/2000 <-
        lpcmd = SELECT_PAPER_A4X;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF2;
        }
        break;

      case CMD_SELECT_PAPER_B4TOA4:         // for NX70  @Feb/04/98
        pOEM->DocPaperID = RPDL_B4A4;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_80, sizeof(IMAGE_SCALING_80)-1);
// DCR  @Jan/27/2000 ->
        // Emit DUPLEX_ON here, because IMAGE_SCALING_xxx resets DUPLEX_ON.
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_VALID))
            WRITESPOOLBUF(pdevobj, DUPLEX_ON, sizeof(DUPLEX_ON)-1);
// @Jan/27/2000 <-
        lpcmd = SELECT_PAPER_A4X;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF2;
        }
        break;

      case CMD_SELECT_PAPER_11x15TOA4:      // @Feb/07/2000
        pOEM->DocPaperID = RPDL_11x15A4;
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_67, sizeof(IMAGE_SCALING_67)-1);
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_VALID))
            WRITESPOOLBUF(pdevobj, DUPLEX_ON, sizeof(DUPLEX_ON)-1);
        fPaperX = (TEST_CAPABLE_PAPERX(pOEM->fModel) && !pOEM->StapleType &&
                   !pOEM->PunchType)? TRUE : FALSE;
        lpcmd = (fPaperX)? SELECT_PAPER_A4X : SELECT_PAPER_A4W;
        pOEM->RPDLHeapCount = (WORD)safe_sprintfA(pOEM->RPDLHeap64, sizeof(pOEM->RPDLHeap64), lpcmd);

        // Emulate NEC MultiWriter 2200
        if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
        {
            pOEM->BaseOffset.x = 37;    // mm
            pOEM->BaseOffset.y = 15;
        }
        else
        {
            pOEM->BaseOffset.x = 15;
            pOEM->BaseOffset.y = 37;
        }

        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF2;
        }
        break;


      case CMD_SELECT_PAPER_DOUBLEPOSTCARD:
        BITSET32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD);
        goto _SET_CUSTOMSIZE;

      case CMD_SELECT_PAPER_CUSTOM:     // pdwParams:PhysPaperWidth,Length
        pOEM->PhysPaperWidth  = (WORD)*pdwParams;       // @Dec/26/97
        pOEM->PhysPaperLength = (WORD)*(pdwParams+1);
        BITSET32(pOEM->fGeneral1, PAPER_CUSTOMSIZE);

      _SET_CUSTOMSIZE:
        pOEM->DocPaperID = RPDL_CUSTOMSIZE;
        pOEM->RPDLHeapCount = 0;
        if (TEST_NIN1_MODE(pOEM->fGeneral1) ||
            TEST_SCALING_SEL_TRAY(pOEM->fGeneral1))
        {
            goto _IMGCTRL_OFF1;
        }
        break;

      _IMGCTRL_OFF1:
        // Invalidate image controls
        pOEM->Scale = 100;                              // @Mar/18/98
        WRITESPOOLBUF(pdevobj, IMAGE_SCALING_100, sizeof(IMAGE_SCALING_100)-1);
// DCR  @Jan/27/2000 ->
        // Emit DUPLEX_ON here, because IMAGE_SCALING_xxx resets DUPLEX_ON.
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_VALID))
            WRITESPOOLBUF(pdevobj, DUPLEX_ON, sizeof(DUPLEX_ON)-1);
// @Jan/27/2000 <-
      _IMGCTRL_OFF2:
        BITCLR_SCALING_SEL_TRAY(pOEM->fGeneral1);
        BITCLR_NIN1_MODE(pOEM->fGeneral1);
        break;


      case CMD_SET_LONG_EDGE_FEED:          // for Multi Tray  @May/25/98
        BITSET32(pOEM->fGeneral2, LONG_EDGE_FEED);
        break;

      case CMD_SET_SHORT_EDGE_FEED:         // for Multi Tray  @May/25/98
        BITCLR32(pOEM->fGeneral2, LONG_EDGE_FEED);
        break;


      case CMD_SELECT_AUTOFEED:
        // Set MediaType (modify  @Mar/03/99, @Feb/15/2000, moved top@Sep/27/2000)
        if (TEST_CAPABLE_MEDIATYPE(pOEM->fModel))
        {
// @Oct/13/2000 ->
//          ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SELECT_MEDIATYPE, 'T', '0'+pOEM->MediaType);
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SELECT_MEDIATYPE, 'T', pOEM->MediaType);
// @Oct/13/2000 <-
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            ocmd = 0;
        }
        if (BITTEST32(pOEM->fGeneral1, PAPER_CUSTOMSIZE) ||
            BITTEST32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD))
        {
            // Select ManualFeed
            WRITESPOOLBUF(pdevobj, SELECT_MANUALFEED, sizeof(SELECT_MANUALFEED)-1);
            goto _SELECTPAPER_CUSTOMSIZE;
        }
        // Output Set_Limitless_Paper_Supply_Mode
        WRITESPOOLBUF(pdevobj, SET_LIMITLESS_SUPPLY, sizeof(SET_LIMITLESS_SUPPLY)-1);
        // Output Select_Tray_By_Papersize command.
        //   if letter size, select A4 first in case of no letter paper.
        if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRX))
        {
            WRITESPOOLBUF(pdevobj, SEL_TRAY_PAPER_HEAD, sizeof(SEL_TRAY_PAPER_HEAD)-1);
            WRITESPOOLBUF(pdevobj, SELECT_PAPER_A4X, sizeof(SELECT_PAPER_A4X)-1);
        }
        else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRW))
        {
            WRITESPOOLBUF(pdevobj, SEL_TRAY_PAPER_HEAD, sizeof(SEL_TRAY_PAPER_HEAD)-1);
            WRITESPOOLBUF(pdevobj, SELECT_PAPER_A4W, sizeof(SELECT_PAPER_A4W)-1);
        }
        WRITESPOOLBUF(pdevobj, SEL_TRAY_PAPER_HEAD, sizeof(SEL_TRAY_PAPER_HEAD)-1);
        WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);
        break;

// @Dec/10/99 FK#49, add TRAY1,3,4,5 & reset limitless @Sep/27/2000 ->
      case CMD_SELECT_TRAY1:
      case CMD_SELECT_TRAY2:
      case CMD_SELECT_TRAY3:
      case CMD_SELECT_TRAY4:
      case CMD_SELECT_TRAY5:
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SELECT_TRAY_N, dwCmdCbID - CMD_SELECT_TRAY1 + 2);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        if (TEST_GWMODEL(pOEM->fModel))
            WRITESPOOLBUF(pdevobj, RESET_LIMITLESS_SUPPLY, sizeof(RESET_LIMITLESS_SUPPLY)-1);
        if (BITTEST32(pOEM->fGeneral1, PAPER_CUSTOMSIZE) ||
            BITTEST32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD))
        {
            goto _SELECTPAPER_CUSTOMSIZE;
        }
        break;
// @Dec/10/99, @Sep/27/2000 <-

      case CMD_SELECT_MANUALFEED:
      case CMD_SELECT_MULTIFEEDER:
      case CMD_SELECT_MULTITRAY:        // NXs' MultiTray
// Moved forward, because NX710(MultiTray) support MediaType  @Mar/11/99 ->
        // Set MediaType (modify @Mar/03/99, @Feb/15/2000)
        if (TEST_CAPABLE_MEDIATYPE(pOEM->fModel))
        {
// @Oct/13/2000 ->
//          ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SELECT_MEDIATYPE, 'T', '0'+pOEM->MediaType);
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SELECT_MEDIATYPE, 'T', pOEM->MediaType);
// @Oct/13/2000 <-
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            ocmd = 0;
        }
// @Mar/11/99 <-
        // Select Feeder
        if (dwCmdCbID == CMD_SELECT_MANUALFEED)
        {
            // Select ManualFeed
            WRITESPOOLBUF(pdevobj, SELECT_MANUALFEED, sizeof(SELECT_MANUALFEED)-1);
        }
        else
        {
            // Select MultiFeeder/MultTray
            WRITESPOOLBUF(pdevobj, SELECT_MULTIFEEDER, sizeof(SELECT_MULTIFEEDER)-1);
//@Sep/27/2000 ->
            if (TEST_GWMODEL(pOEM->fModel))
                WRITESPOOLBUF(pdevobj, RESET_LIMITLESS_SUPPLY, sizeof(RESET_LIMITLESS_SUPPLY)-1);
//@Sep/27/2000 <-
        }
        // If CustomSize, jump.
        if (BITTEST32(pOEM->fGeneral1, PAPER_CUSTOMSIZE) ||
            BITTEST32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD))
        {
            goto _SELECTPAPER_CUSTOMSIZE;
        }

        // Set papersize
        // If papersize without transverse (A1,A2,A3,A6,B3,B4,B6,C,Tabloid,Legal)
        if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A1)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A2)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A3)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A6)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B3)    ||    // @Feb/05/98
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B4)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B6)    ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_C)     ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_TABD)  ||
            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LEGL))
        {
            // Output Select_Papersize command
            WRITESPOOLBUF(pdevobj, SELECT_PAPER_HEAD, sizeof(SELECT_PAPER_HEAD)-1);
            WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);
        }
        else
        {
            if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A4X) ||
                !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A4W))
            {
                // If long edge feed is enabled, set transverse paper.  @May/25/98
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_A4;
                }
                else
                {
                    lpcmd = SELECT_PAPER_A4R;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A5X) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A5W))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_A5;
                }
                else
                {
                    lpcmd = SELECT_PAPER_A5R;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B5X) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B5W))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_B5;
                }
                else
                {
                    lpcmd = SELECT_PAPER_B5R;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRX) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LETRW))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_LETR;
                }
                else
                {
                    lpcmd = SELECT_PAPER_LETRR;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_STATX) ||
                     !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_STATW))
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_STAT;
                }
                else
                {
                    lpcmd = SELECT_PAPER_STATR;
                }
            }
            else if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_PCX))   // @Feb/13/98
            {
                if (dwCmdCbID == CMD_SELECT_MULTITRAY &&
                    BITTEST32(pOEM->fGeneral2, LONG_EDGE_FEED))
                {
                    lpcmd = SELECT_PAPER_PC;
                }
                else
                {
                    lpcmd = SELECT_PAPER_PCR;
                }
            }
            else
                break;  // exit

            // Output Select_Papersize command
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SELECT_PAPER_HEAD);
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, lpcmd);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        } // 'if (A1,A2,A3,A6,B4,B6,C,TABLOID,LEGAL) else' end
        // Reconfirm ManualFeed/AutoFeed.
        if (dwCmdCbID == CMD_SELECT_MANUALFEED)
            WRITESPOOLBUF(pdevobj, SELECT_MANUALFEED, sizeof(SELECT_MANUALFEED)-1);
        else
            WRITESPOOLBUF(pdevobj, SELECT_MULTIFEEDER, sizeof(SELECT_MULTIFEEDER)-1);
        break;

      _SELECTPAPER_CUSTOMSIZE:
        {
            DWORD   dwWidth, dwHeight;

            // If DoublePostcard
            if (BITTEST32(pOEM->fGeneral1, PAPER_DOUBLEPOSTCARD))
            {
                if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
                {
                    dwWidth  = 148;     // mm
                    dwHeight = 200;
                }
                else
                {
                    dwWidth  = 200;
                    dwHeight = 148;
                }
                // Set max pagesize (mm to dot with KIRISUTE)
                pOEM->PageMax.x = (LONG)(dwWidth * (DWORD)(MASTERUNIT*10) /
                                         (DWORD)254 / (DWORD)pOEM->nResoRatio);
                pOEM->PageMax.y = (LONG)(dwHeight * (DWORD)(MASTERUNIT*10) /
                                         (DWORD)254 / (DWORD)pOEM->nResoRatio);
            }
            // If CustomSize
            else
            {
                if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
                {
                    dwWidth  = pOEM->PhysPaperLength;           // masterunit
                    dwHeight = pOEM->PhysPaperWidth;
                }
                else
                {
                    dwWidth  = pOEM->PhysPaperWidth;            // masterunit
                    dwHeight = pOEM->PhysPaperLength;
                }
                // Set max pagesize
                pOEM->PageMax.x = (LONG)(dwWidth  / pOEM->nResoRatio);   // dot
                pOEM->PageMax.y = (LONG)(dwHeight / pOEM->nResoRatio);
                // masterunit to mm with SISHAGONYU
                dwWidth  = (dwWidth * (DWORD)254 + (DWORD)(MASTERUNIT*10/2)) /
                           (DWORD)(MASTERUNIT*10);
                dwHeight = (dwHeight * (DWORD)254 + (DWORD)(MASTERUNIT*10/2)) /
                           (DWORD)(MASTERUNIT*10);
            }

            BITCLR32(pOEM->fGeneral1, CUSTOMSIZE_USE_LAND);
            BITCLR32(pOEM->fGeneral1, CUSTOMSIZE_MAKE_LAND_PORT);

            // Because app sometimes sets under-limit in landscape,
            // we need to swap width and height.  @Oct/21/98
            if (dwHeight < USRD_H_MIN148)           // < 148
            {
                DWORD dwTmp;
                dwTmp = dwWidth;
                dwWidth = dwHeight;
                dwHeight = dwTmp;
            }
            else if (dwWidth >= dwHeight)
            {
                WORD fSwap = FALSE;

                // Because app sometimes sets over-limit width in portrait,
                // we need to swap width and height.
                if (TEST_CAPABLE_PAPER_A2(pOEM->fModel))
                {
                    if (dwWidth > USRD_W_A2)            // > 432
                        fSwap = TRUE;
                }
                else if (TEST_CAPABLE_PAPER_A3_W297(pOEM->fModel))
                {
                    if (dwWidth > USRD_W_A3)            // > 297
                        fSwap = TRUE;
                }
                else if (TEST_CAPABLE_PAPER_A4MAX(pOEM->fModel))
                {
                    if (dwWidth > USRD_W_A4)            // > 216
                        fSwap = TRUE;
                }
                else
                {
                    if (dwWidth > USRD_W_A3_OLD)        // > 296
                        fSwap = TRUE;
                }

                if (fSwap)
                {
                    DWORD dwTmp;
                    dwTmp = dwWidth;
                    dwWidth = dwHeight;
                    dwHeight = dwTmp;
                }
                // SPEC of RPDL
                // If width is larger than length, we need to set landscape.
                else
                {
                    BITSET32(pOEM->fGeneral1, CUSTOMSIZE_USE_LAND);
                }
            }
            else
            {
                BITSET32(pOEM->fGeneral1, CUSTOMSIZE_MAKE_LAND_PORT);
            }

// @Dec/10/99 FK#49, add TRAY1-5 & eliminate TRAYA-D @Sep/27/2000 ->
//          ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SELECT_PAPER_CUSTOM, (WORD)dwWidth, (WORD)dwHeight);
//          WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
            if (dwCmdCbID >= CMD_SELECT_TRAY1 && dwCmdCbID <= CMD_SELECT_TRAY5)
            {
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SELECT_PAPER_CUSTOM2, (WORD)dwWidth, (WORD)dwHeight,
                               dwCmdCbID - CMD_SELECT_TRAY1 + 2);
            }
            else    // manual feed
            {
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SELECT_PAPER_CUSTOM, (WORD)dwWidth, (WORD)dwHeight);
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SELECT_MANUALFEED, sizeof(SELECT_MANUALFEED)-1);
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
// @Dec/10/99, @Sep/27/2000 <-
        }
        break;

      case CMD_SELECT_ROLL1:                // IP-1
      case CMD_SELECT_ROLL2:
        // Select roll (plotter)
        if (dwCmdCbID == CMD_SELECT_ROLL1)
            WRITESPOOLBUF(pdevobj, SELECT_ROLL1, sizeof(SELECT_ROLL1)-1);
        else
            WRITESPOOLBUF(pdevobj, SELECT_ROLL2, sizeof(SELECT_ROLL2)-1);
        // Output Select_Papersize command ("papername+X" only)
        WRITESPOOLBUF(pdevobj, SELECT_PAPER_HEAD_IP1, sizeof(SELECT_PAPER_HEAD_IP1)-1);
        WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);
        break;


      case CMD_SELECT_FINISHER_TRAY2:   // @Jun/25/2001
        pOEM->FinisherTrayNum = 2;
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_PAPERDEST_FINISHER_GW, pOEM->FinisherTrayNum);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
        break;


      case CMD_SET_COLLATE_OFF:         // @Jul/31/98
        pOEM->CollateType = COLLATE_OFF;            // COLLATE_OFF<-0     @Dec/02/98
        break;

      case CMD_SET_COLLATE_ON:          // @Jul/31/98
        pOEM->CollateType = COLLATE_ON;             // COLLATE_ON<-1      @Dec/02/98
        break;

      case CMD_SELECT_COLLATE_UNIDIR:   // @Aug/10/98
        if (COLLATE_OFF != pOEM->CollateType)
            pOEM->CollateType = COLLATE_UNIDIR;     // COLLATE_UNIDIR<-2  @Dec/02/98
        break;

      case CMD_SELECT_COLLATE_ROTATED:  // @Aug/10/98
        if (COLLATE_OFF != pOEM->CollateType)
            pOEM->CollateType = COLLATE_ROTATED;    // COLLATE_ROTATED<-3 @Dec/02/98
        break;

      case CMD_SELECT_COLLATE_SHIFTED:  // @Dec/02/98
        if (COLLATE_OFF != pOEM->CollateType)
            pOEM->CollateType = COLLATE_SHIFTED;
        break;


      // Final command before print
      case CMD_MULTI_COPIES:                // pdwParams:NumOfCopies
        // If not CustomSize, set max pagesize.
        if ((nTmp = pOEM->DocPaperID) != RPDL_CUSTOMSIZE)
        {
            if (BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT))    // @Nov/27/97
            {
                pOEM->PageMax.x = RPDLPageSizeE2E[nTmp].x / pOEM->nResoRatio;
                pOEM->PageMax.y = RPDLPageSizeE2E[nTmp].y / pOEM->nResoRatio;
            }
            else
            {
                pOEM->PageMax.x = RPDLPageSize[nTmp].x / pOEM->nResoRatio;
                pOEM->PageMax.y = RPDLPageSize[nTmp].y / pOEM->nResoRatio;
            }

            if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
            {
                LONG tmp;
                tmp = pOEM->PageMax.x;    // swap x-y
                pOEM->PageMax.x = pOEM->PageMax.y;
                pOEM->PageMax.y = tmp;
            }
        }

        if (TEST_BUGFIX_FORMFEED(pOEM->fModel) ||           // add @Sep/15/98
            BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            pOEM->PageMaxMoveY = pOEM->PageMax.y;
        }
        else
        {
            // PRINTER SIDE ISSUE: RPDL
            // Because RPDL do formfeed when vertical position is around
            // ymax-coordinate, we shift position upper 1mm.
            // Set PageMaxMoveY for checking max vertical position.
            nTmp = BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT)?     // @Nov/27/97
                   DISABLE_FF_MARGIN_E2E : DISABLE_FF_MARGIN_STD;
            pOEM->PageMaxMoveY = pOEM->PageMax.y - 1 -
                                 (nTmp + pOEM->nResoRatio - 1) /
                                 pOEM->nResoRatio;                  // KIRIAGE
        }

        // If 2in1, switch orientation(portrait<->landscape).
        if (TEST_2IN1_MODE(pOEM->fGeneral1))
            BITSET32(pOEM->fGeneral1, SWITCH_PORT_LAND);
        if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
        {
            if (BITTEST32(pOEM->fGeneral1, SWITCH_PORT_LAND) ||
                BITTEST32(pOEM->fGeneral1, CUSTOMSIZE_MAKE_LAND_PORT))
            {
                fLandscape = FALSE;
            }
            else
            {
                fLandscape = TRUE;
            }
        }
        else    // portrait
        {
            fLandscape = BITTEST32(pOEM->fGeneral1, SWITCH_PORT_LAND)? TRUE : FALSE;
        }
        // Output RPDL orientation command
        if (fLandscape || BITTEST32(pOEM->fGeneral1, CUSTOMSIZE_USE_LAND))
            WRITESPOOLBUF(pdevobj, SET_LANDSCAPE, sizeof(SET_LANDSCAPE)-1);
        else                // portrait
            WRITESPOOLBUF(pdevobj, SET_PORTRAIT, sizeof(SET_PORTRAIT)-1);

        // Output copy#
        // Check whether copy# is in the range.  @Sep/01/98
        {
            DWORD dwCopy, dwMax;

            dwCopy = *pdwParams;    // NumOfCopies
            dwMax = TEST_MAXCOPIES_99(pOEM->fModel)? 99 : 999;

            if(dwCopy > dwMax)
                dwCopy = dwMax;
            else if(dwCopy < 1)
                dwCopy = 1;

            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_MULTI_COPY, (WORD)dwCopy);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
// @Jan/08/99 ->
            if (1 == dwCopy)
                pOEM->CollateType = COLLATE_OFF;
// @Jan/08/99 <-
        }

        fFinisherSR30Active = FALSE;    // @Mar/19/99

        // staple
        if (pOEM->StapleType)
        {
            ocmd = 0;
            if (BITTEST32(pOEM->fModel, GRP_MF250M))    // model = MF250M (No Punch Unit)
            {
                // sort:on (add duplex param since NX900 @Jan/08/99)
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_SORT_ON,
                               BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);

                // paper_destination:outer tray
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PAPERDEST_OUTTRAY);
                // staple:on
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_STAPLE_CORNER_ON,
                                (fLandscape)?
                                STAPLE_UPPERRIGHT_CORNER : STAPLE_UPPERLEFT_CORNER);
            }
            else    // model = MF2700,3500,3550,4550,5550,6550,NXs
            {
                WORD pnt;

                fFinisherSR30Active = TRUE;     // @Mar/19/99

                // sort:on (add duplex param since NX900 @Jan/08/99)
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_SORT_ON,
                               BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);

                // paper_destination:finisher shift tray
// @Jun/25/2001 ->
//              if (!TEST_GWMODEL(pOEM->fModel))  // add if  @Oct/10/2000
//                  ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PAPERDEST_FINISHER);
                if (TEST_GWMODEL(pOEM->fModel))
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PAPERDEST_FINISHER_GW, pOEM->FinisherTrayNum);
                else
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PAPERDEST_FINISHER, pOEM->FinisherTrayNum);
// @Jun/25/2001 <-
                // Disable rotated collate.
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, COLLATE_DISABLE_ROT);   // @Mar/19/99

                if (pOEM->StapleType == 2)          // 2 staples on the paper
                {
                    switch (pOEM->BindPoint)
                    {
                      case BIND_LEFT:
                        pnt = STAPLE_LEFT2;
                        break;
                      case BIND_RIGHT:
                        pnt = STAPLE_RIGHT2;
                        break;
                      case BIND_UPPER:
                        pnt = STAPLE_UPPER2;
                        break;
//                    case BIND_ANY:
                      default:
                        pnt = (fLandscape)? STAPLE_UPPER2 : STAPLE_LEFT2;
                        break;
                    }
                    // staple:on
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_STAPLE_ON, pnt);
                }
// @Mar/18/99 ->
                else if (pOEM->StapleType == 3)     // 1 staple with FinisherSR12
                {
// @Apr/06/99 ->
//                  if (BIND_RIGHT == pOEM->BindPoint)
//                      pnt = STAPLE_UPPERRIGHT_CORNER;
//                  else
//                      pnt = (fLandscape)? STAPLE_UPPERRIGHT_CORNER : STAPLE_UPPERLEFT_CORNER;
                    switch (pOEM->BindPoint)
                    {
                      case BIND_LEFT:
                        pnt = STAPLE_UPPERLEFT_CORNER;
                        break;
                      case BIND_RIGHT:
                        pnt = STAPLE_UPPERRIGHT_CORNER;
                        break;
                      default:
                        // If papersize without transverse (A3,B4,Tabloid,Legal)
                        if (!strcmp(pOEM->RPDLHeap64, SELECT_PAPER_A3)   ||
                            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_B4)   ||
                            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_TABD) ||
                            !strcmp(pOEM->RPDLHeap64, SELECT_PAPER_LEGL))
                        {
                            pnt = (fLandscape)? STAPLE_UPPERLEFT_CORNER : STAPLE_UPPERRIGHT_CORNER;
                        }
                        else
                        {
                            pnt = (fLandscape)? STAPLE_UPPERRIGHT_CORNER : STAPLE_UPPERLEFT_CORNER;
                        }
                        break;
                    }
// @Apr/06/99 <-
                    // staple:on
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_STAPLE_CORNER_ON, pnt);
                }
// @Mar/18/99 <-
                else                                // 1 staple
                {
                    switch (pOEM->BindPoint)
                    {
                      case BIND_RIGHT:
                        pnt = STAPLE_UPPERRIGHT_CORNER;
                        break;
                      default:
                        pnt = STAPLE_UPPERLEFT_CORNER;
                        break;
                    }
                    // staple:on
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_STAPLE_CORNER_ON, pnt);
                }
            }
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
        }

        // punch
        if (pOEM->PunchType)
        {
            WORD pnt;

            ocmd = 0;

            if (!fFinisherSR30Active)   // modify  @Mar/19/99
            {
                if (COLLATE_OFF != pOEM->CollateType)
                {
                    // sort:on (add duplex param since NX900 @Jan/08/99)
                    ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_SORT_ON,
                                   BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);
                }
                // paper_destination:finisher shift tray
// @Jun/25/2001 ->
//              if (!TEST_GWMODEL(pOEM->fModel))  // add if  @Oct/10/2000
//                  ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PAPERDEST_FINISHER);
                if (TEST_GWMODEL(pOEM->fModel))
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PAPERDEST_FINISHER_GW, pOEM->FinisherTrayNum);
                else
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PAPERDEST_FINISHER, pOEM->FinisherTrayNum);
// @Jun/25/2001 <-
                // SPEC of RPDL  @May/27/98
                // We must disable rotated collate here.
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, COLLATE_DISABLE_ROT);
            }

            switch (pOEM->BindPoint)
            {
              case BIND_LEFT:
                pnt = PUNCH_LEFT;
                break;
              case BIND_RIGHT:
                pnt = PUNCH_RIGHT;
                break;
              case BIND_UPPER:
                pnt = PUNCH_UPPER;
                break;
              default:
                pnt = (fLandscape)? PUNCH_UPPER : PUNCH_LEFT;
                break;
            }
            // punch:on
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PUNCH_ON, pnt);
            WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
        }

        // collate  (@Jul/31/98, entirely-modify @Dec/02/98)
        if (!pOEM->StapleType && !pOEM->PunchType)
        {
            // sort:on (add duplex param since NX900 @Jan/08/99)
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_SORT_ON,
                           BITTEST32(pOEM->fGeneral1, DUPLEX_VALID)? 1 : 0);
            switch (pOEM->CollateType)
            {
              case COLLATE_UNIDIR:
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, COLLATE_DISABLE_ROT);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              case COLLATE_ROTATED:
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, COLLATE_ENABLE_ROT);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              // If shifted collate, select finisher shift tray.
              case COLLATE_SHIFTED:
// @Jun/25/2001 ->
//              if (!TEST_GWMODEL(pOEM->fModel))  // add if  @Oct/10/2000
//                  ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PAPERDEST_FINISHER);
                if (TEST_GWMODEL(pOEM->fModel))
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PAPERDEST_FINISHER_GW, pOEM->FinisherTrayNum);
                else
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PAPERDEST_FINISHER, pOEM->FinisherTrayNum);
// @Jun/25/2001 <-
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              // if collate for MF-p150,MF200,250M,2200,NXs
              case COLLATE_ON:
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                break;

              default:
                break;
            }
        }

        ocmd = 0;
        if (TEST_AFTER_SP9II(pOEM->fModel) && !BITTEST32(pOEM->fModel, GRP_NX100))
        {
//@Jun/23/2000 ->
            // PRINTER SIDE ISSUE: NX610,710,71 RPDL
            // Printer hangs up with variable scaling command. Dummy font select is
            // effective on this problem.
            if (BITTEST32(pOEM->fModel, GRP_NX70) || BITTEST32(pOEM->fModel, GRP_NX710))
            {
                // Emit dummy Mincho font select.
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_JIS_FONT_SCALE_H_ONLY, 1000L);
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_JIS_FONT_NAME[0]);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
                ocmd = 0;
            }
//@Jun/23/2000 <-
            // Set IBM extended character code block, and set region to 'USA'. (latter @Feb/22/99)
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_IBM_EXT_BLOCK);
            // Disable formfeed when charcter position is around ymax-coordinate
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_PAGEMAX_VALID);
        }

        // Set color of Textmode RectangleFill black
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_TEXTRECT_BLACK);
        pOEM->TextRectGray = 100;           // @Jan/07/98

        // Set 5mm offset at MF530,150,150e,160.
        // (At these models, CMD_SET_BASEOFFSETs aren't called.)
        if (TEST_GRP_OLDMF(pOEM->fModel) &&
            !BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT) &&
            !BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO)) // add @Sep/15/98
        {
            pOEM->BaseOffset.x = pOEM->BaseOffset.y = 5;    // mm
        }

        // Convert mm to dot here ((LONG)<-(DWORD) @Feb/02/99)
        pOEM->BaseOffset.x = pOEM->BaseOffset.x * (LONG)(MASTERUNIT*10) /
                             (LONG)254 / (LONG)pOEM->nResoRatio;
        pOEM->BaseOffset.y = pOEM->BaseOffset.y * (LONG)(MASTERUNIT*10) /
                             (LONG)254 / (LONG)pOEM->nResoRatio;

        // Think about scaling  (@May/18/98, (LONG)<-(DWORD) @Feb/02/99)
        if (pOEM->Scale != 100 && pOEM->Scale != 0)
        {
            pOEM->BaseOffset.x = pOEM->BaseOffset.x * (LONG)100 / (LONG)pOEM->Scale;
            pOEM->BaseOffset.y = pOEM->BaseOffset.y * (LONG)100 / (LONG)pOEM->Scale;
        }

        // Calculate offset for TOMBO.(BaseOffset will be changed.) @Sep/14/98
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
            DrawTOMBO(pdevobj, INIT_TOMBO);

        // Initialize current position
        pOEM->TextCurPos.x = pOEM->Offset.x = pOEM->BaseOffset.x;
        pOEM->TextCurPos.y = pOEM->Offset.y = pOEM->BaseOffset.y;
        pOEM->TextCurPosRealY = pOEM->TextCurPos.y;

        // SPEC of Unidrv5 & RPDL   @Aug/14/98
        // Unidrv5 doesn't order to set coordinate x,y to 0 after returning iRet=0,
        // and RPDL doesn't reset coordinate y of SEND_BLOCK after initializing
        // printer.
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ESC_XM_ABS, pOEM->TextCurPos.x);
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ESC_YM_ABS, pOEM->TextCurPos.y);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd); 
        break;

//
// Following cases are called at the end of a print-job (JOB_FINISH)
//

      case CMD_ENDDOC_SP4II:        // SP4mkII,5
        // If Nin1 && document finished with remaining pages, output FF.
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        // Set Spacing_Unit:(H)1/120,(V)1/48inch, Code:JIS, Scaling:100%
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ENDDOC1);
        goto _ENDDOC_FINISH;

      case CMD_ENDDOC_SP8:          // SP8(7),8(7)mkII,80,10,10mkII
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        // Set Spacing_Unit:(H)1/120,(V)1/48inch, Code:JIS, Scaling:100%
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ENDDOC1);
        if (TEST_AFTER_SP10(pOEM->fModel))    // SP10,10mkII
        {
            // Set Graphics_Unit:1/240inch,Engine_Resolution:240dpi
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC2_240DPI);
            // Set Coordinate_Unit:1/720inch
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC3);
        }
        // Set Options[duplex/2in1:off,reversed_output:off,sort/stack:off]
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC4);
        goto _ENDDOC_FINISH;

      case CMD_ENDDOC_SP9:          // SP9,10Pro,9II,10ProII,90
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ENDDOC1);
        // Set Graphics_Unit:1/240inch,Engine_Resolution:400dpi
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC2_SP9);
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC3);
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC4);
        goto _ENDDOC_FINISH;

      case CMD_ENDDOC_400DPI_MODEL: // MF,MF-P,NX,IP-1
        if (TEST_NIN1_MODE(pOEM->fGeneral1) && pOEM->Nin1RemainPage)
            WRITESPOOLBUF(pdevobj, FF, sizeof(FF)-1);
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ENDDOC1);
        if (TEST_AFTER_SP10(pOEM->fModel) ||        // MF-P,NX,MF200,250M,MF-p150,MF2200
            BITTEST32(pOEM->fModel, GRP_MF150E))    // MF150e,160
        {
            // Set Graphics_Unit:1/400inch,Engine_Resolution:400dpi
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC2_400DPI);
            // Set Coordinate_Unit:1/720inch
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC3);
        }
        // If staple mode, do not change sort/stack of Options.
        if (pOEM->StapleType || pOEM->PunchType)
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC4_FINISHER);
        else
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC4);
//      goto _ENDDOC_FINISH;

      _ENDDOC_FINISH:
        // Reset smoothing/tonner_save_mode. (PRINTER SIDE ISSUE: We must not reset SP8.)
        if (TEST_BUGFIX_RESET_SMOOTH(pOEM->fModel))
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd,  SELECT_SMOOTHING2);
        // Terminate fax at imagio FAX
        if (BITTEST32(pOEMExtra->fUiOption, FAX_MODEL))
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDFAX);

// @Jun/29/2001  Add TEST_NEED_JOBDEF_CMD ->
        // PRINTER SIDE ISSUE: RPDL (job define command is needed)  GRP_NX900 @Jan/08/99
//        if (BITTEST32(pOEM->fModel, GRP_NX900) &&
//            (COLLATE_OFF != pOEM->CollateType || pOEM->StapleType || pOEM->PunchType))
        if (BITTEST32(pOEM->fModel, GRP_NX900) || TEST_NEED_JOBDEF_CMD(pOEM->fModel))
// @Jun/29/2001 <-
        {
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC_JOBDEF_END);
        }
        // Initialize printer
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, ENDDOC5);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        ocmd = 0;
        // If binding margin is set,reset it to 0mm.
        if (BITTEST32(pOEM->fGeneral1, DUPLEX_LEFTMARGIN_VALID))
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_LEFTMARGIN, 1);
        else if (BITTEST32(pOEM->fGeneral1, DUPLEX_UPPERMARGIN_VALID))
            ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_UPPERMARGIN, 1);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        if(pOEM->pRPDLHeap2K)               // @Sep/09/98
            MemFree(pOEM->pRPDLHeap2K);     // add ;  @Aug/02/2000
#ifdef DOWNLOADFONT
        if(pOEM->pDLFontGlyphInfo)          // @Sep/09/98
            MemFree(pOEM->pDLFontGlyphInfo);
#endif // DOWNLOADFONT
        break;


    default:
        ERR((("Unknown callback ID = %d.\n"), dwCmdCbID));
    }

    return iRet;
} //*** OEMCommandCallback


BOOL APIENTRY bOEMSendFontCmd(  // BOOL <- VOID @Mar/27/2002
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[STDVAR_BUFSIZE(3) / sizeof(DWORD)];
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        Cmd[128];
    PIFIMETRICS pIFI;
    POEMPDEV    pOEM = MINIDEV_DATA(pdevobj);   // @Oct/06/98
    DWORD       dwNeeded, dwUFO_FontH, dwUFO_FontW;
    DWORD       dwUFO_FontMaxW;     // MSKK Jul/23/98
    LONG        lTmp;

    VERBOSE(("** bOEMSendFontCmd() entry. **\n"));

// MSKK 1/24/98 UnSelect ->
    if (0 == pFInv->dwCount)
    {
        // No select command.  pProbably some of the
        // un-select case where no invokation command is
        // available.  (No explicit un-select.)
        return FALSE;   // BOOL <- VOID @Mar/27/2002
    }   
// MSKK 1/24/98 <-

    pubCmd = pFInv->pubCommand;
    pIFI = pUFObj->pIFIMetrics;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = STDVAR_BUFSIZE(3);
    pSV->dwNumOfVariable = 3;

    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTMAXWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_FONTWIDTH;

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
                            pSV->dwSize, &dwNeeded))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return FALSE;   // BOOL <- VOID @Mar/27/2002
    }

//  VERBOSE((("FONTHEIGHT=%d\n"), pSV->StdVar[0].lStdVariable));
//  VERBOSE((("FONTMAXWIDTH=%d\n"), pSV->StdVar[1].lStdVariable));
//  VERBOSE((("FONTWIDTH=%d\n"), pSV->StdVar[2].lStdVariable));

    dwUFO_FontH    = (DWORD)pSV->StdVar[0].lStdVariable;
    dwUFO_FontMaxW = (DWORD)pSV->StdVar[1].lStdVariable;    // MSKK Jul/23/98
    dwUFO_FontW    = (DWORD)pSV->StdVar[2].lStdVariable;

    dwOut = 0;

    BITCLR_BARCODE(pOEM->fGeneral2);
    for (dwIn = 0; dwIn < pFInv->dwCount;)
    {
        if (pubCmd[dwIn] == '#')
        {
            //** set width & height of scalable font for Japanese font **
            if (pubCmd[dwIn+1] == 'A')
            {
                DWORD   dwWidth, dwHeight;
                // pOEM->FontH_DOT(unit:dot) for TextMode clipping
                pOEM->FontH_DOT = MASTER_TO_SPACING_UNIT(pOEM, ((WORD)dwUFO_FontH)); // @Jan/30/98
                // dwHeight(unit:cpt) for RPDL command parameter
                dwHeight = dwUFO_FontH * (DWORD)(DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);

                if(IS_DBCSCHARSET(pIFI->jWinCharSet))
// MSKK Jul/23/98 ->
//                  dwWidth = dwUFO_FontW * 2;
                    dwWidth = dwUFO_FontMaxW;
// MSKK Jul/23/98 <-
                else
                    dwWidth = dwUFO_FontW;
                dwWidth *= DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT;

//              VERBOSE(("[OEMSCALABLEFONT] w=%d,h=%d(%ddot)\n",
//                      (WORD)dwWidth, (WORD)dwHeight, pOEM->FontH_DOT));

// @Jun/25/98 ->
                // If width is slightly different to height, we suppose they are same.
                if ((lTmp = dwHeight - dwWidth) != 0)
                {
                    if (lTmp < 0)
                        lTmp = -lTmp;
                    if ((DWORD)lTmp < dwHeight / 25)    // 1/25 = 4%
                        dwWidth = dwHeight;
                }
// @Jun/25/98 <-

                // Use 10pt-size raster font at SP4mkII,5,8(7),8(7)mkII
                if (TEST_GRP_240DPI(pOEM->fModel) && dwWidth == dwHeight &&
                    dwWidth >= NEAR10PT_MIN && dwWidth <= NEAR10PT_MAX)
                {
                    dwWidth = dwHeight = 960;   // unit:cpt(centi point)
                }
                pOEM->dwFontW_CPT = dwWidth;
                pOEM->dwFontH_CPT = dwHeight;
// @Jan/29/99 ->
                // If width equals to height, we emit height parameter only.
                // (This is applied to after SP9II because we want to avoid testing
                //  at too old models.)
                if (TEST_AFTER_SP9II(pOEM->fModel) && dwWidth == dwHeight)
                    dwOut += safe_sprintfA(&Cmd[dwOut], sizeof(Cmd) - dwOut, ",%ld", dwHeight);
                else
// @Jan/29/99 <-
                    dwOut += safe_sprintfA(&Cmd[dwOut], sizeof(Cmd) - dwOut, "%ld,%ld", dwWidth, dwHeight);
                dwIn += 2;
            } // 'if 'A'' end

            //** set width & height of scalable font for IBM ext font **
            else if (pubCmd[dwIn+1] == 'B')
            {
// @Jan/29/99 ->
                if (TEST_AFTER_SP9II(pOEM->fModel) && pOEM->dwFontW_CPT == pOEM->dwFontH_CPT)
                    dwOut += safe_sprintfA(&Cmd[dwOut], sizeof(Cmd) - dwOut, ",%ld", pOEM->dwFontH_CPT);
                else
// @Jan/29/99 <-
                    dwOut += safe_sprintfA(&Cmd[dwOut], sizeof(Cmd) - dwOut, "%ld,%ld",
                                     pOEM->dwFontW_CPT, pOEM->dwFontH_CPT);
                dwIn += 2;
            } // 'if 'B'' end

            // Set flag for barcode
            else if (pubCmd[dwIn+1] == 'C')
            {
                switch (pubCmd[dwIn+2])
                {
                  case '0':     // JAN(STANDARD)
                    pOEM->nBarMaxLen = 13 + 1;          goto _BARCODE_READY;

                  case '1':     // JAN(SHORT)
                    pOEM->nBarMaxLen = 8 + 1;           goto _BARCODE_READY;
// @Dec/07/99 FK#50 ->
                  case '7':     // CUSTOMER
                    pOEM->nBarMaxLen = 20 + 1;          goto _BARCODE_READY;
                  case '9':     // UPC(A)
                    pOEM->nBarMaxLen = 12 + 1;          goto _BARCODE_READY;
                  case 'A':     // UPC(A)
                    pOEM->nBarMaxLen = 8 + 1;           goto _BARCODE_READY;
                  case '8':     // CODE128
// @Dec/07/99 FK#50 <-
                  case '2':     // 2of5(INDUSTRIAL)
                  case '3':     // 2of5(MATRIX)
                  case '4':     // 2of5(ITF)
                  case '5':     // CODE39
                  case '6':     // NW-7
                    pOEM->nBarMaxLen = BARCODE_MAX;
                  _BARCODE_READY:
                    BITSET32(pOEM->fGeneral2, BARCODE_MODE_IN);
                    pOEM->dwBarRatioW = dwUFO_FontH * (DWORD)(DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);
// @Dec/17/99 FK#50 ->
//                  pOEM->nBarType = pubCmd[dwIn+2] - '0';
                    if (pubCmd[dwIn+2] < 'A')
                        pOEM->nBarType = pubCmd[dwIn+2] - '0';
                    else
                        pOEM->nBarType = pubCmd[dwIn+2] - 'A' + 10;
// @Dec/17/99 FK#50 <-
                    pOEM->RPDLHeapCount = 0;
                    VERBOSE(("** BARCODE(1) ratio=%d **\n",pOEM->dwBarRatioW));
                    break;

                  default:
                    break;
                }
                dwIn += 3;
            } // 'if 'C'' end

            //** set width of scalable font **
            else if (pubCmd[dwIn+1] == 'W')
            {
// MSKK Jul/23/98 ->
//              if (dwUFO_FontW > 0)
                if (dwUFO_FontW > 0 || dwUFO_FontMaxW > 0)
// MSKK Jul/23/98 <-
                {
                    DWORD dwWidth;
    
                    if(IS_DBCSCHARSET(pIFI->jWinCharSet))
// MSKK Jul/23/98 ->
//                      dwWidth = dwUFO_FontW * 2;
                        dwWidth = dwUFO_FontMaxW;
// MSKK Jul/23/98 <-
                    else
                        dwWidth = dwUFO_FontW;
                    pOEM->dwFontW_CPT = dwWidth * (DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);
                    dwOut += safe_sprintfA(&Cmd[dwOut], sizeof(Cmd) - dwOut, "%ld", pOEM->dwFontW_CPT);
                }
                dwIn += 2;
            } // 'if 'W'' end

            //** set height of scalable font (include Japanese proportional font) **
            else if (pubCmd[dwIn+1] == 'H')
            {
                pOEM->FontH_DOT = MASTER_TO_SPACING_UNIT(pOEM, ((WORD)dwUFO_FontH)); // @Jan/30/98
                pOEM->dwFontH_CPT = dwUFO_FontH * (DWORD)(DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT);
                dwOut += safe_sprintfA(&Cmd[dwOut], sizeof(Cmd) - dwOut, "%ld", pOEM->dwFontH_CPT);
                dwIn += 2;
            } // 'if 'H'' end

            //** set font pitch (Horizontal-Motion-Index) **
            else if (pubCmd[dwIn+1] == 'P')
            {
                SHORT nTmp1, nTmp2;

                switch (pubCmd[dwIn+2])     // modify(add Arial,Century,etc)
                {
                  case 'D':     // DBCS (Japanese font ZENKAKU)
//95/NT4            nTmp1 = lpFont->dfAvgWidth * 2;
// MSKK 1/25/98     nTmp1 = ((SHORT)dwUFO_FontW + 1) / 2 * 2;
// MSKK Jul/23/98   nTmp1 = (SHORT)dwUFO_FontW * 2;
                    nTmp1 = (SHORT)dwUFO_FontMaxW;
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1); // MSKK 1/25/98
                    VERBOSE(("** FontMaxW=%d dot **\n", nTmp1));
// @Aug/10/98       nTmp1 = (nTmp1 / 2 + 1) * 2;    // bigger even  @Jan/30/98
                    break;

                  case 'S':     // SBCS (Japanese font HANKAKU)
// RPDL pitch setting command of HANKAKU is EFFECTIVE to SPACE.
// OBSOLETE @Mar/26/99 ->
//// @Jan/29/99 ->
//                  // RPDL pitch setting command of HANKAKU is not effective, so
//                  // do not emit this. (We may not delete this string in UFM.)
//                  if (dwOut >= 4 && Cmd[dwOut-4] == '\x1B' && Cmd[dwOut-3] == 'N')
//                  {
//                      dwIn  += 3; // count up input '#PS'
//                      dwOut -= 4; // delete previous output '\x1BN\x1B\x1F'
//                      continue;   // goto for loop-end
//                  }
//                  else    // Maybe none comes here.
// @Jan/29/99 <-
// @Mar/26/99 <-
                    {
//95/NT4                nTmp1 = lpFont->dfAvgWidth;
// NSKK 1/25/98         nTmp1 = ((SHORT)dwUFO_FontW + 1) / 2;
                        nTmp1 = (SHORT)dwUFO_FontW;
                        nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1); // MSKK 1/25/98
                        VERBOSE(("** FontW=%d dot **\n", nTmp1));
// @Aug/10/98           nTmp1++;                        // 1dot bigger  @Jan/30/98
                    }
                    break;

                  case '1':     // SBCS (BoldFacePS)
                  case '2':     // SBCS (Arial)
                  case '3':     // SBCS (Century)
                    nTmp1 = (SHORT)(dwUFO_FontH * 3L / 10L);        // * 0.3
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '4':     // SBCS (TimesNewRoman)
                    nTmp1 = (SHORT)(dwUFO_FontH * 27L / 100L);      // * 0.27
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '5':     // SBCS (Symbol)
                    nTmp1 = (SHORT)dwUFO_FontH / 4;                 // * 0.25
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '6':     // SBCS (Wingding)
                    nTmp1 = (SHORT)dwUFO_FontH;                     // * 1
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;

                  case '7':     // DBCS (Japanese proportional font HANKAKU)
                    nTmp1 = (SHORT)(dwUFO_FontH * 78L / 256L);
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
                    break;
// OBSOLETE @Mar/26/99 ->
//                case '8':     // DBCS (Japanese proportional font ZENKAKU)
//                  nTmp1 = (SHORT)(dwUFO_FontH * 170L / 256L);
//                  nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);    // MSKK 1/25/98
//                  break;
// @Mar/26/99 <-
                  default:      // SBCS (Courier,LetterGothic,PrestigeElite)
//95/NT4            nTmp1 = lpFont->dfPixWidth;
                    nTmp1 = (SHORT)dwUFO_FontW;
                    nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1); // MSKK 1/25/98
                    dwIn --;
                    break;
                }

                if (nTmp1 >= 0x7E)
                {
                    Cmd[dwOut++] = (BYTE)(((nTmp1 + 2) >> 7) + 0x81);
                    // PRINTER SIDE ISSUE: RPDL (We cannot set value of 0x7F & 0x80.)
                    if ((nTmp2 = ((nTmp1 + 2) & 0x7F) + 1) > 0x7E)
                        nTmp2 = 0x7E;
                    Cmd[dwOut++] = (BYTE)nTmp2;
                }
                else
                {
                    Cmd[dwOut++] = (BYTE)(nTmp1 + 1);
                }
                dwIn += 3;
            } // 'if 'P'' end

            //** set Vertical-Motion-Index to draw combined font('^'+'A',etc). **
            //** (Courier,LetterGothic,PrestigeElite,BoldFacePS)               **
            else if (pubCmd[dwIn+1] == 'V')
            {
                SHORT nTmp1, nTmp2;
    
                // Set 1/3 height (adequate value to move vertically)
                nTmp1 = (SHORT)dwUFO_FontH / 3;
                nTmp1 = MASTER_TO_SPACING_UNIT(pOEM, nTmp1);
                if (nTmp1 >= 0x7E)
                {
                    Cmd[dwOut++] = (BYTE)(((nTmp1 + 2) >> 7) + 0x81);
                    // PRINTER SIDE ISSUE: RPDL (We cannot set value of 0x7F & 0x80.)
                    if ((nTmp2 = ((nTmp1 + 2) & 0x7F) + 1) > 0x7E)
                        nTmp2 = 0x7E;
                    Cmd[dwOut++] = (BYTE)nTmp2;
                }
                else
                {
                    Cmd[dwOut++] = (BYTE)(nTmp1 + 1);
                }
                dwIn += 2;
            } // 'if 'V'' end
        } // 'if '#'' end
        else
        {
            Cmd[dwOut++] = pubCmd[dwIn++];
        }
    } // 'for (dwIn = 0; dwIn < pFInv->dwCount;)' end

//  VERBOSE(("dwOut = %d\n", dwOut)); // MSKK 1/24/98

    WRITESPOOLBUF(pdevobj, Cmd, dwOut);
    return TRUE;   // BOOL <- VOID @Mar/27/2002
} //*** bOEMSendFontCmd


static BYTE IsDBCSLeadByteRPDL(BYTE Ch)
{
    return ShiftJisRPDL[Ch];
}

static BYTE IsDifferentPRNFONT(BYTE Ch)
{
    return VerticalFontCheck[Ch];
}

//---------------------------*[LOCAL] DrawTOMBO*-------------------------------
// Action:
//  (a) INIT_TOMBO: calculate offset in printing. (BaseOffset will be changed)
//  (b) DRAW_TOMBO: drawing TOMBO.
// Setp/14/98
//-----------------------------------------------------------------------------
static VOID DrawTOMBO(
    PDEVOBJ pdevobj,
    SHORT action)
{
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);   // @Oct/06/98
    POEMPDEV         pOEM = MINIDEV_DATA(pdevobj);          // @Oct/06/98
    POINT   P0;
    POINT   PaperSizeDoc, PaperSizeUse;
    BYTE    Cmd[256];         // build command here
    INT     ocmd = 0;
    LONG    lLen3, lLen10, lLen13, lWidth0_1, lSav, lTmp;
    SHORT   nPaperUse;

    switch (pOEM->DocPaperID)
    {
      case RPDL_A3:
        nPaperUse = RPDL_B3;    break;
      case RPDL_B4:
        nPaperUse = RPDL_A3;    break;
      case RPDL_A4:
        nPaperUse = RPDL_B4;    break;
      case RPDL_A5:
      case RPDL_A6:
      case RPDL_POSTCARD:
      case RPDL_B5:
      case RPDL_B6:
        nPaperUse = RPDL_A4;    break;
      default:
        return;     // draw nothing
    }

    // Set acutual printed paper size & document paper size
    PaperSizeUse = RPDLPageSizeE2E[nPaperUse];
    PaperSizeDoc = RPDLPageSizeE2E[pOEM->DocPaperID];

    // Orientation?
    if (BITTEST32(pOEM->fGeneral1, ORIENT_LANDSCAPE))
    {
        lTmp = PaperSizeUse.x;   // swap x-y
        PaperSizeUse.x = PaperSizeUse.y;
        PaperSizeUse.y = lTmp;
        lTmp = PaperSizeDoc.x;
        PaperSizeDoc.x = PaperSizeDoc.y;
        PaperSizeDoc.y = lTmp;
    }

    // upper-left TOMBO
    P0.x = (PaperSizeUse.x - PaperSizeDoc.x) / 2 / pOEM->nResoRatio;
    P0.y = (PaperSizeUse.y - PaperSizeDoc.y) / 2 / pOEM->nResoRatio;

    //   If action is INIT_TOMBO, set BaseOffset and return
    if (INIT_TOMBO == action)
    {
        LONG lUnprintable = BITTEST32(pOEM->fGeneral2, EDGE2EDGE_PRINT)?
                            0 : 240L / pOEM->nResoRatio;    // 240masterunit at GPD
        pOEM->BaseOffset.x += P0.x + lUnprintable;
        pOEM->BaseOffset.y += P0.y + lUnprintable;
        return;     // exit
    }

    lSav = P0.x;    // save left P0.x
    lLen3  =  3L * (LONG)(MASTERUNIT*10) / 254L / pOEM->nResoRatio;    // 3mm
    lLen10 = 10L * (LONG)(MASTERUNIT*10) / 254L / pOEM->nResoRatio;    // 10mm
    lLen13 = 13L * (LONG)(MASTERUNIT*10) / 254L / pOEM->nResoRatio;    // 13mm
    lWidth0_1 = (LONG)MASTERUNIT / 254L / pOEM->nResoRatio;            // 0.1mm
    if (lWidth0_1 < 1)
        lWidth0_1 = 1;
    else if (lWidth0_1 >= 2)
        lWidth0_1 = lWidth0_1 / 2 * 2 + 1;      // make it odd

    ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ENTER_VECTOR);          // enter VectorMode
    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, PEN_WIDTH, lWidth0_1);
    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DRAW_TOMBO_POLYLINE, P0.x, P0.y - lLen13,
                    0, lLen10, -lLen13, 0);
    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DRAW_TOMBO_POLYLINE, P0.x - lLen3, P0.y - lLen13,
                    0, lLen13, -lLen10, 0);

    // upper-right TOMBO
    // Add horizontal distance and adjustment (PaperSizeDoc.x:masterunit, AdjX:0.1mm unit)
    P0.x += (PaperSizeDoc.x + (LONG)pOEMExtra->nUiTomboAdjX * (LONG)MASTERUNIT / 254L)
            / pOEM->nResoRatio;
    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DRAW_TOMBO_POLYLINE, P0.x, P0.y - lLen13,
                    0, lLen10, lLen13, 0);
    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DRAW_TOMBO_POLYLINE, P0.x + lLen3, P0.y - lLen13,
                    0, lLen13, lLen10, 0);

    // lower-left TOMBO
    lTmp = P0.x;
    P0.x = lSav;    // restore left P0.x
    lSav = lTmp;    // save right P0.x
    // Add vertical distance and adjustment (PaperSizeDoc.y:masterunit, AdjY:0.1mm unit)
    P0.y += (PaperSizeDoc.y + (LONG)pOEMExtra->nUiTomboAdjY * (LONG)MASTERUNIT / 254L)
            / pOEM->nResoRatio;
    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DRAW_TOMBO_POLYLINE, P0.x, P0.y + lLen13,
                    0, -lLen10, -lLen13, 0);
    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DRAW_TOMBO_POLYLINE, P0.x - lLen3, P0.y + lLen13,
                    0, -lLen13, -lLen10, 0);

    // lower-right TOMBO
    P0.x = lSav;    // restore right P0.x
    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DRAW_TOMBO_POLYLINE, P0.x, P0.y + lLen13,
                    0, -lLen10, lLen13, 0);
    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DRAW_TOMBO_POLYLINE, P0.x + lLen3, P0.y + lLen13,
                    0, -lLen13, lLen10, 0);
    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, EXIT_VECTOR);   // exit VectorMode
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);
} // *** DrawTOMBO

//---------------------------*[LOCAL] AssignIBMfont*---------------------------
// Action:
//  (a) IBMFONT_ENABLE_ALL: assign IBM extended characters to block#1 where
//       JIS1 characters used to be assigned.
//  (b) IBMFONT_RESUME: resume (re-assign IBM extended characters to block#4.
//      block#4 is insufficient for all 388 IBM characters.)
//-----------------------------------------------------------------------------
static VOID AssignIBMfont(
    PDEVOBJ pdevobj,
    SHORT   rcID,
    SHORT   action)
{
    BYTE    Cmd[56];          // build command here
    INT     ocmd = 0;
    WORD    num;
    WORD    fHeightParamOnly;                   // @Jan/29/99
    DWORD   dwWidth, dwHeight;
    POEMPDEV pOEM = MINIDEV_DATA(pdevobj);      // @Oct/06/98

    switch (rcID)
    {
      case MINCHO_1:      case MINCHO_1+1:      // horizontal font: vertical font:
      case MINCHO_B1:     case MINCHO_B1+1:
      case MINCHO_E1:     case MINCHO_E1+1:
      case GOTHIC_B1:     case GOTHIC_B1+1:
      case GOTHIC_M1:     case GOTHIC_M1+1:
      case GOTHIC_E1:     case GOTHIC_E1+1:
      case MARUGOTHIC_B1: case MARUGOTHIC_B1+1:
      case MARUGOTHIC_M1: case MARUGOTHIC_M1+1:
      case MARUGOTHIC_L1: case MARUGOTHIC_L1+1:
      case GYOSHO_1:      case GYOSHO_1+1:
      case KAISHO_1:      case KAISHO_1+1:
      case KYOKASHO_1:    case KYOKASHO_1+1:
        num = (rcID - MINCHO_1) / 2;
        goto _SET_W_H;

      case MINCHO_3:      case MINCHO_3+1:    // for NX-100
        num = 0;
        goto _SET_W_H;
      case GOTHIC_B3:     case GOTHIC_B3+1:
        num = 3;
      _SET_W_H:
        dwWidth  = pOEM->dwFontW_CPT;
        dwHeight = pOEM->dwFontH_CPT;
        break;

      case MINCHO10_RAS:  case MINCHO10_RAS+1:
        num = 0;                    // same to MINCHO_1
        dwWidth = dwHeight = 960;   // unit:cpt(centi point)
        break;

      default:
        return; // exit AssignIBMfont()
    }
    
// @Jan/29/99 ->
    // If width equals to height, we emit height parameter only.
    // (This is applied to only NX-100 here.)
    if (TEST_AFTER_SP9II(pOEM->fModel) && dwWidth == dwHeight)
        fHeightParamOnly = TRUE;
    else
        fHeightParamOnly = FALSE;
// @Jan/29/99 <-

    if (IBMFONT_RESUME == action)
    {
        // Resume JIS1 characters block where they used to be. (JIS1 -> block#1)
// @Jan/29/99 ->
        if (fHeightParamOnly)
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_JIS_FONT_SCALE_H_ONLY, dwHeight);
        else
// @Jan/29/99 <-
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_JIS_FONT_SCALE, dwWidth, dwHeight);
        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_JIS_FONT_NAME[num]);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    }

    // Assign IBM extended characters to block.
// @Jan/29/99 ->
    if (fHeightParamOnly)
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_IBM_FONT_SCALE_H_ONLY, action, dwHeight);
    else
// @Jan/29/99 <-
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), SET_IBM_FONT_SCALE, action, dwWidth, dwHeight);
    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, SET_IBM_FONT_NAME[num]);
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    return;
} //*** AssignIBMfont


//---------------------------*[LOCAL] SendFaxNum*------------------------------
// Action: send fax number
// (Use fax data file @Sep/30/98, Use private devmode @Oct/15/98)
//-----------------------------------------------------------------------------
static VOID SendFaxNum(                                     // @Sep/17/98
    PDEVOBJ pdevobj)
{
    BYTE        Cmd[256], PreNumBuf[4+16], NumBuf[32+4];
    SHORT       PreNumLen, cnt, SrcLen, NumLen;
    INT         ocmd;
    LPSTR       lpSrc, lpDst;
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);
    FILEDATA     FileData;  // <-pFileData (formerly use MemAllocZ) @Mar/17/2000

    FileData.fUiOption = 0;
// @Mar/01/2002 ->
//  RWFileData(&FileData, pOEMExtra->SharedFileName, GENERIC_READ);
    RWFileData(&FileData, pOEMExtra->SharedFileName, sizeof(pOEMExtra->SharedFileName), GENERIC_READ);
// @Mar/01/2002 <-

    // If previous fax is finished and hold-options flag isn't valid,
    // do nothing and return.
    // This prevents unexpected fax until user pushes Apply button on the
    // fax property sheet.
    if (BITTEST32(FileData.fUiOption, PRINT_DONE) &&
        !BITTEST32(pOEMExtra->fUiOption, HOLD_OPTIONS))
    {
        VERBOSE(("** SendFaxNum: Exit without doing anything. **\n"));
        return;
    }

    // If not fax option ready, exit.
    if (!BITTEST32(pOEMExtra->fUiOption, FAX_SEND) || pOEMExtra->FaxNumBuf[0] == 0)
    {
        return;
    }

    // Set data_type(1:image, 2:RPDL command), compression (1:MH, 3:MMR),
    // simultaneous print avalilable, etc
    ocmd = safe_sprintfA(Cmd, sizeof(Cmd), BEGINFAX_HEAD,
                   BITTEST32(pOEMExtra->fUiOption, FAX_RPDLCMD)? 2 : 1,
                   BITTEST32(pOEMExtra->fUiOption, FAX_MH)? 1 : 3,
                   BITTEST32(pOEMExtra->fUiOption, FAX_SIMULPRINT)? 2 : 1);
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);

    // Copy fax channel & extra number to pre_number buffer
    PreNumLen = (SHORT)safe_sprintfA(PreNumBuf, sizeof(PreNumBuf), BEGINFAX_CH, pOEMExtra->FaxCh + 1);
    if (pOEMExtra->FaxExtNumBuf[0] != 0)
        PreNumLen += (SHORT)safe_sprintfA(&PreNumBuf[PreNumLen], sizeof(PreNumBuf) - PreNumLen, BEGINFAX_EXTNUM, pOEMExtra->FaxExtNumBuf);

    // Search each fax number (directly set number & addressbook set number)
    lpSrc  = pOEMExtra->FaxNumBuf;  // fax number which is set directly
    SrcLen = FAXBUFSIZE256-1;       // FaxNumBuf limit = 255
    lpDst  = NumBuf;
    NumLen = 0;
    {
        while (SrcLen-- > 0 && *lpSrc != 0)
        {
            // If character is DBCS, skip.
            if (IsDBCSLeadByteRPDL(*lpSrc))
            {
                lpSrc++;
            }
            // If character is valid, input it to NumBuf.
            else if (*lpSrc >= '0' && *lpSrc <= '9' || *lpSrc == '-' || *lpSrc == '#')
            {
                *lpDst++ = *lpSrc;
                if (NumLen++ > 32)          // limit of MF-P
                {
                    return;                 // error exit
                }
            }
            // If character is ',' , output fax number.
            else if (*lpSrc == ',')
            {
                *lpDst = 0;
                // Send fax number
                if (NumLen > 0)
                {
                    WRITESPOOLBUF(pdevobj, PreNumBuf, PreNumLen);
                    WRITESPOOLBUF(pdevobj, NumBuf, NumLen);
                }
                lpDst = NumBuf;
                NumLen = 0;
            }
            lpSrc++;
        } // 'while (SrcLen-- > 0 && *lpSrc != 0)' end

        // Flush last fax number
        if (NumLen > 0)
        {
            WRITESPOOLBUF(pdevobj, PreNumBuf, PreNumLen);
            WRITESPOOLBUF(pdevobj, NumBuf, NumLen);
        }
    } // 'while (cnt-- > 0)' end

    // Get tickcount for ID
    cnt = (SHORT)(GetTickCount() / 1000L);
    cnt = ABS(cnt);
    // Input ID & resolution & send time, etc
    if (BITTEST32(pOEMExtra->fUiOption, FAX_SETTIME) && pOEMExtra->FaxSendTime[0] != 0)
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), BEGINFAX_TAIL, cnt, pOEMExtra->FaxReso + 1, 2, pOEMExtra->FaxSendTime);
    else
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), BEGINFAX_TAIL, cnt, pOEMExtra->FaxReso + 1, 1, "");
    WRITESPOOLBUF(pdevobj, Cmd, ocmd);

    // Set PRINT_DONE flag in the file  @Oct/20/98
    FileData.fUiOption = pOEMExtra->fUiOption;
    BITSET32(FileData.fUiOption, PRINT_DONE);
// @Mar/01/2002 ->
//  RWFileData(&FileData, pOEMExtra->SharedFileName, GENERIC_WRITE);
    RWFileData(&FileData, pOEMExtra->SharedFileName, sizeof(pOEMExtra->SharedFileName), GENERIC_WRITE);
// @Mar/01/2002 <-

    return;
} //*** SendFaxNum


#ifdef JISGTT
//-----------------------------*[LOCAL] jis2sjis*------------------------------
// Action: convert JIS code to SJIS code
//-----------------------------------------------------------------------------
static VOID jis2sjis(       // @Oct/27/98
    BYTE jis[],
    BYTE sjis[])
{
        BYTE            h, l;

        h = jis[0];
        l = jis[1];
        if (h == 0)
        {
            sjis[0] = l;
            sjis[1] = 0;
            return;
        }
        l += 0x1F;
        if (h & 0x01)
            h >>= 1;
        else
        {
            h >>= 1;
            l += 0x5E;
            h--;
        }
        if (l >= 0x7F)
            l++;
        if (h < 0x2F)
            h += 0x71;
        else
            h += 0xB1;
        sjis[0] = h;
        sjis[1] = l;
} //*** jis2sjis
#endif // JISGTT


BOOL APIENTRY bOEMOutputCharStr(    // BOOL <- VOID @Mar/27/2002
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PBYTE aubBuff;              // <-BYTE aubBuff[256]  MSKK Aug/13/98
    PTRANSDATA pTrans;
#ifdef DBG_OUTPUTCHARSTR
    PWORD  pwUnicode;
#endif // DBG_OUTPUTCHARSTR
    DWORD  dwI;
    BYTE   Cmd[128];
    INT    ocmd = 0;            // INT<-SHORT  @Feb/22/99
    SHORT  rcID;
    WORD   fVertFont = FALSE, fEuroFont = FALSE, fIBMFontSupport = FALSE;
    WORD   fEuroFontFullset = FALSE;
#ifdef JISGTT
    WORD   fJisCode = FALSE;    // @Oct/27/98
#endif // JISGTT
    LPSTR  lpChar;
    BYTE   CharTmp1, CharTmp2;
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pdevobj);   // @Oct/06/98
    POEMPDEV         pOEM = MINIDEV_DATA(pdevobj);          // @Oct/06/98
#ifdef DOWNLOADFONT
    SHORT   mov;
    WORD    wSerialNum;         // short->DWORD @Jun/30/98, DWORD->WORD @Aug/21/98
    LONG    lFontID, lGlyphID;  // @Aug/21/98
    LPFONTPOS lpDLFont;
#endif // DOWNLOADFONT
    DWORD   dwNeeded;
    WORD    fMemAllocated;      // @Sep/09/98

//  VERBOSE(("** bOEMOutputCharStr() entry. **\n"));

    if (BITTEST32(pOEM->fGeneral2, TEXTRECT_CONTINUE))  // add  @Dec/11/97
    {
        BITCLR32(pOEM->fGeneral2, TEXTRECT_CONTINUE);
        // If white-rect has been done before, set raster drawmode to OR. @Jan/20/99
        if (!pOEM->TextRectGray)
        {
            if (BITTEST32(pOEM->fGeneral1, FONT_WHITETEXT_ON))
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_ON, sizeof(ESC_WHITETEXT_ON)-1);
            else
                WRITESPOOLBUF(pdevobj, ESC_WHITETEXT_OFF, sizeof(ESC_WHITETEXT_OFF)-1);
        }
    }

    //** flush Move_X,Y command saved at OEMCommandCallback
    if (BITTEST32(pOEM->fGeneral1, YM_ABS_GONNAOUT))
    {
        BITCLR32(pOEM->fGeneral1, YM_ABS_GONNAOUT);
        // Output Move_Y command here.
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ESC_YM_ABS, pOEM->TextCurPos.y);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    }
    if (BITTEST32(pOEM->fGeneral1, XM_ABS_GONNAOUT))
    {
        BITCLR32(pOEM->fGeneral1, XM_ABS_GONNAOUT);
        // Output Move_X command here.
        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ESC_XM_ABS, pOEM->TextCurPos.x);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
    }

//  VERBOSE(("dwType = %d\n", dwType)); // MKSKK 1/24/98

    switch (dwType)
    {
      case TYPE_GLYPHHANDLE:    // device font
// #333653: Change I/F for GETINFO_GLYPHSTRING // MSKK 5/17/99 {
        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;

        // Get the size of buffer for pGlyphOut.
        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
            GStr.dwSize, &dwNeeded) || !GStr.dwGlyphOutSize)
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            return FALSE;       // BOOL <- VOID @Mar/27/2002
        }
        if (pOEM->pRPDLHeap2K && GStr.dwGlyphOutSize <= HEAPSIZE2K)
        {
            aubBuff = pOEM->pRPDLHeap2K;
            fMemAllocated = FALSE;
        }
        else
        {
            if(!(aubBuff = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize)))
            {
                ERR(("aubBuff memory allocation failed.\n"));
                return FALSE;   // BOOL <- VOID @Mar/27/2002
            }
            fMemAllocated = TRUE;
        }
// } MSKK 5/17/99

#ifdef DBG_OUTPUTCHARSTR
        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_UNICODE;
        GStr.pGlyphOut = aubBuff;

        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
                                GStr.dwSize, &dwNeeded))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
// fix memory leak by yasuho Nov/20/2002 ->
            if(fMemAllocated)
                MemFree(aubBuff);
// Nov/20/2002 <-
            return FALSE;       // BOOL <- VOID @Mar/27/2002
        }

        pwUnicode = (PWORD)aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            VERBOSE((("Unicode[%d] = %x\n"), dwI, pwUnicode[dwI]));
        }
#endif // DBG_OUTPUTCHARSTR

#ifdef DOWNLOADFONT
    // If moving value of download font remain
    if (pOEM->nCharPosMoveX)
    {
        // Flush moving value of pre-printed download font.
        if (pOEM->nCharPosMoveX > 0)
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ESC_XM_REL, pOEM->nCharPosMoveX);
        else
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ESC_XM_RELLEFT, -pOEM->nCharPosMoveX);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);

        // Clear moving value
        pOEM->nCharPosMoveX = 0;
    } // 'if (nCharPosMoveX)' end
#endif // DOWNLOADFONT

        //
        // Call the Unidriver service routine to convert
        // glyph-handles into the character code data.
        //

        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = aubBuff;

        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
                                GStr.dwSize, &dwNeeded))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
// fix memory leak by yasuho Nov/20/2002 ->
            if(fMemAllocated)
                MemFree(aubBuff);
// Nov/20/2002 <-
            return FALSE;       // BOOL <- VOID @Mar/27/2002
        }

        pTrans = (PTRANSDATA)aubBuff;

//** Draw barcode **
// fix bug with Excel @Nov/24/98
        if (BITTEST32(pOEM->fGeneral2, BARCODE_MODE_IN))
        {
            WORD    unit1, unit2, offset_y;
            WORD    fCheckdigitCapable, fSetBarWidth, fJANDecrease1Char;
            WORD    fCode128;           // @Feb/08/2000
            LPSTR   lpDst, lpCmd;
            PTRANSDATA pTransTmp;       // @Nov/24/98
            WORD    wLen, wTmp;

            ocmd = 0;
            // Check start character
            wTmp = wLen = (WORD)dwCount;
            pTransTmp = pTrans;
            while (wTmp-- > 0)
            {
                if (pTransTmp->uCode.ubCode == '[')
                {
                    // barcode character is valid from now
                    BITSET32(pOEM->fGeneral2, BARCODE_DATA_VALID);
                    BITCLR32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON);
                    BITCLR32(pOEM->fGeneral2, BARCODE_ROT90);
                    BITCLR32(pOEM->fGeneral2, BARCODE_ROT270);
                    pOEM->RPDLHeapCount = 0;
                    wLen   = wTmp;
                    pTrans = pTransTmp+1;
#ifdef DEBUG
                    for (wTmp = 0; wTmp < BARCODE_MAX; wTmp++)
                        pOEM->RPDLHeap64[wTmp] = 0;
#endif // DEBUG
                    break;
                }
                pTransTmp++;
            }

            // Check barcode character length
            VERBOSE(("** BARCODE(2.2) len=%d **\n",wLen));
            fJANDecrease1Char = FALSE;
            if (wLen > (wTmp = pOEM->nBarMaxLen - pOEM->RPDLHeapCount))
            {
                wLen = wTmp;
                BITSET32(pOEM->fGeneral2, BARCODE_FINISH);
                VERBOSE(("** BARCODE(3) limit len=%d(last=%c) **\n", wLen,
                         (pTrans+wLen-1)->uCode.ubCode));
                // Decrease RPDLHeapCount later at JAN
                if (pOEM->nBarType == BAR_TYPE_JAN_STD || pOEM->nBarType == BAR_TYPE_JAN_SHORT)
                    fJANDecrease1Char = TRUE;
            }

            // Copy barcode characters to RPDLHeap64 (temporary buffer)
            lpDst = &pOEM->RPDLHeap64[pOEM->RPDLHeapCount];
            fCheckdigitCapable = TEST_AFTER_SP8(pOEM->fModel)? TRUE : FALSE;
            while (wLen-- > 0)
            {
                // Check checkdigit-on-flag-character(?) in pTrans->uCode.ubCode
                if (pTrans->uCode.ubCode == '?' && fCheckdigitCapable)
                {
                    BITSET32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON);
                    pTrans++;
                    continue;
                }
                // Check end character
                if (pTrans->uCode.ubCode == ']')
                {
                    VERBOSE(("** BARCODE(4) terminator **\n"));
                    BITSET32(pOEM->fGeneral2, BARCODE_FINISH);
                    break;
                }
                *lpDst++ = pTrans->uCode.ubCode;
                pTrans++;
                pOEM->RPDLHeapCount++;
            }
            VERBOSE(("** BARCODE(5) copy-end BarNum=%d **\n", pOEM->RPDLHeapCount));
            VERBOSE(("   [%s]\n",pOEM->RPDLHeap64));
            VERBOSE(("   CHK = %d\n", BITTEST32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON)));

            // Finish
            if (BITTEST32(pOEM->fGeneral2, BARCODE_DATA_VALID) &&
                BITTEST32(pOEM->fGeneral2, BARCODE_FINISH))
            {
                VERBOSE(("** BARCODE(6) finish [%s] **\n", pOEM->RPDLHeap64));
                // 1 barcode has been completed here
                BITCLR32(pOEM->fGeneral2, BARCODE_DATA_VALID);
                BITCLR32(pOEM->fGeneral2, BARCODE_FINISH);

                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ENTER_VECTOR);    // enter VectorMode

                // Add checkdigit
                if (BITTEST32(pOEM->fGeneral2, BARCODE_CHECKDIGIT_ON))
                {
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BAR_CHECKDIGIT);
                }

                // Check barcode-height
                if (pOEMExtra->UiBarHeight == 0)
                {
                    pOEMExtra->UiBarHeight = BAR_H_DEFAULT;     // default (=10mm)
                }
                else if (pOEMExtra->UiBarHeight != BAR_H_DEFAULT)
                {
                    // Set barcode-height (convert unit from mm to dot)  (SISHAGONYU)
                    unit1 = (WORD)(((DWORD)pOEMExtra->UiBarHeight * (DWORD)(MASTERUNIT*10)
                            / (DWORD)pOEM->nResoRatio + (DWORD)(254/2)) / (DWORD)254);
                    VERBOSE(("** BARCODE(7) set height %d **\n", unit1));
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BAR_H_SET, unit1);
                }

                if (BITTEST32(pOEMExtra->fUiOption, DISABLE_BAR_SUBFONT))
                {
                    // Disable printing font under barcode
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BAR_NOFONT[pOEM->nBarType]);
                    // Set guard-bar-height of JAN
                    if ((pOEM->nBarType == BAR_TYPE_JAN_STD || pOEM->nBarType == BAR_TYPE_JAN_SHORT) &&
                        !TEST_AFTER_SP8(pOEM->fModel))
                    {
                        offset_y = 2;
                    }
                    else    // no guard-bar
                    {
                        offset_y = 0;
                    }
                }
                else
                {
                    offset_y = 3;   // font-height = 3mm
                }
// @Dec/8/99 FK#50 ->
                if (pOEM->nBarType == BAR_TYPE_CUSTOMER)
                {
                    // calculate vertical offset (barcode-height)
                    offset_y = (WORD)(((DWORD)(BAR_H_CUSTOMER)      // 36 x 0.1mm
                               * (DWORD)MASTERUNIT
                               / (DWORD)pOEM->nResoRatio + (DWORD)(254/2)) / (DWORD)254);
                }
                else
                {
// @Dec/8/99 FK#50 <-
                // Calculate vertical offset (barcode-height + font-height)
                    offset_y = (WORD)(((DWORD)(pOEMExtra->UiBarHeight + offset_y)
                               * (DWORD)(MASTERUNIT*10)
                               / (DWORD)pOEM->nResoRatio + (DWORD)(254/2)) / (DWORD)254);
// @Dec/8/99 FK#50 ->
                }
// @Dec/8/99 FK#50 <-

                // Check vertical-flag-character('@') in RPDLHeap64
                VERBOSE(("** BARCODE(7-1) vertical check len=%d(%c..%c) **\n",
                        pOEM->RPDLHeapCount, pOEM->RPDLHeap64[0],
                        pOEM->RPDLHeap64[pOEM->RPDLHeapCount-1] ));
                // If characters are "@...", vertical(ROT270) barcode
                if (pOEM->RPDLHeap64[0] == '@')
                {
                    VERBOSE(("** BARCODE(7-2) vertical(ROT270) **\n"));
                    BITSET32(pOEM->fGeneral2, BARCODE_ROT270);
                    pOEM->RPDLHeapCount--;
                }
                // If characters are "...@", vertical(ROT90) barcode
                else if (pOEM->RPDLHeap64[pOEM->RPDLHeapCount-1] == '@')
                {
                    VERBOSE(("** BARCODE(7-2) vertical(ROT90) **\n"));
                    BITSET32(pOEM->fGeneral2, BARCODE_ROT90);
                    pOEM->RPDLHeapCount--;
                }
                // 1 charcter margin for '@' at JAN, we decrease here.
                else if (fJANDecrease1Char)
                {
                    pOEM->RPDLHeapCount--;
                }

                // Set barcode draw position
                if (BITTEST32(pOEM->fGeneral2, BARCODE_ROT270) &&
                    !TEST_NIN1_MODE(pOEM->fGeneral1))
                {
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BAR_ROT270);
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, MOVE_ABSOLUTE,
                                    pOEM->TextCurPos.y,
                                    pOEM->PageMax.x - pOEM->TextCurPos.x - offset_y);
                }
                else if (BITTEST32(pOEM->fGeneral2, BARCODE_ROT90) &&
                         !TEST_4IN1_MODE(pOEM->fGeneral1))
                {
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BAR_ROT90);
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, MOVE_ABSOLUTE,
                                    pOEM->PageMax.y - pOEM->TextCurPos.y,
                                    pOEM->TextCurPos.x - offset_y);
                }
                else
                {
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, MOVE_ABSOLUTE,
                                    pOEM->TextCurPos.x,
                                    pOEM->TextCurPos.y - offset_y);
                }

                // Check whether setting barcode-width or not.
                // (Scaling is valid when 5pt<=fontsize<9pt or fontsize>11pt)
                if ((pOEM->dwBarRatioW >= BAR_W_MIN_5PT &&
                    pOEM->dwBarRatioW < NEAR10PT_MIN) ||
                    pOEM->dwBarRatioW > NEAR10PT_MAX)
                {
                    fSetBarWidth = TRUE;
                }
                else
                {
                    fSetBarWidth = FALSE;
                }

                fCode128 = 0;           // @Feb/08/2000
                switch (pOEM->nBarType)
                {
                  case BAR_TYPE_JAN_STD:        // 0:JAN(STANDARD)
                  case BAR_TYPE_JAN_SHORT:      // 1:JAN(SHORT)
                  case BAR_TYPE_UPC_A:          // 9:UPC(A) @Dec/17/99 FK#50
                  case BAR_TYPE_UPC_E:          // 10:UPC(E) @Dec/17/99 FK#50
                    // Set barcode-width
                    if (fSetBarWidth)
                    {
                        // Convert unit from 1/1000mm_unit*1/1000 to dot  (SISHAGONYU)
                        unit1 = (WORD)(((DWORD)BAR_UNIT_JAN * pOEM->dwBarRatioW
                                / (DWORD)pOEM->nResoRatio / (DWORD)100
                                * (DWORD)MASTERUNIT / (DWORD)254 + (DWORD)(1000/2))
                                / (DWORD)1000);
                        VERBOSE(("** BARCODE(8) set unit %d **\n", unit1));
                        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BAR_W_SET_JAN, unit1);
                    }
                    // Output barcode command
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BAR_TYPE[pOEM->nBarType]);
                    break;

                  case BAR_TYPE_2OF5IND:        // 2:2of5(INDUSTRIAL)
                  case BAR_TYPE_2OF5MTX:        // 3:2of5(MATRIX)
                  case BAR_TYPE_2OF5ITF:        // 4:2of5(ITF)
                    lpCmd = BAR_W_SET_2OF5;
                    goto _BARCODE_CMD_OUT1;
                  case BAR_TYPE_CODE39:         // 5:CODE39
                    lpCmd = BAR_W_SET_C39;
// @Dec/17/99 FK#50 ->
                    goto _BARCODE_CMD_OUT1;
                  case BAR_TYPE_CODE128:        // 8:CODE128
                    lpCmd = BAR_W_SET_C39;
                    fCode128 = 1;
// @Dec/17/99 FK#50 <-
                  _BARCODE_CMD_OUT1:
                    // Set standard size of module unit  (1/1000mm_unit)
                    unit1 = BAR_UNIT1_2OF5;
                    unit2 = BAR_UNIT2_2OF5;
                    goto _BARCODE_CMD_OUT2;

                  case BAR_TYPE_NW7:            // 6:NW-7
                    lpCmd = BAR_W_SET_NW7;
                    // Set standard size of module unit
                    unit1 = BAR_UNIT1_NW7;
                    unit2 = BAR_UNIT2_NW7;
                  _BARCODE_CMD_OUT2:
                    // Set barcode-width
                    if (fSetBarWidth)
                    {
                        // Convert unit from 1/1000mm_unit*1/1000 to dot  (SISHAGONYU)
                        unit1 = (WORD)(((DWORD)unit1 * pOEM->dwBarRatioW
                                / (DWORD)pOEM->nResoRatio / (DWORD)100
                                * (DWORD)MASTERUNIT / (DWORD)254 + (DWORD)(1000/2))
                                / (DWORD)1000);
                        unit2 = (WORD)(((DWORD)unit2 * pOEM->dwBarRatioW
                                / (DWORD)pOEM->nResoRatio / (DWORD)100
                                * (DWORD)MASTERUNIT / (DWORD)254 + (DWORD)(1000/2))
                                / (DWORD)1000);
                        VERBOSE(("** BARCODE(8) set unit %d,%d **\n", unit1,unit2));
                        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, lpCmd);
                        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BAR_W_PARAMS, unit1, unit1,
                                        unit2, unit2, unit1);
                    }
                    // Output barcode command(operand) & character#
// @Dec/17/99 FK#50 ->
//                  ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BAR_TYPE[pOEM->nBarType],
//                                  pOEM->RPDLHeapCount);
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BAR_TYPE[pOEM->nBarType],
                                    pOEM->RPDLHeapCount + fCode128);
// @Dec/17/99 FK#50 <-
                    break;

// @Dec/07/99 FK#50 ->
                  case BAR_TYPE_CUSTOMER:       // 7:CUSTOMER
                    lpCmd = BAR_W_SET_CUST;
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, lpCmd);
                    unit1 = (WORD)(((pOEM->dwBarRatioW / 10) + 4) / 5) * 5 ;
                    if ((unit1 >= 80) && (unit1 <= 115))
                    {
                        ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, "%d", unit1);
                    }
                    // output barcode command(operand) & character#
                    ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, BAR_TYPE[pOEM->nBarType],
                                                        pOEM->RPDLHeapCount);
                    break;
// @Dec/07/99 FK#50 <-

                  default:
                    break;
                }

                WRITESPOOLBUF(pdevobj, Cmd, ocmd);

// @Dec/17/99 FK#50 ->
                // Code128 data format ",xx,xx,..."
                if (pOEM->nBarType == BAR_TYPE_CODE128)
                {
                    INT   len, cnt;
                    BYTE  Code128Buf[8];
                    LPSTR lpTemp;

                    lpTemp = pOEM->RPDLHeap64;
                    if (BITTEST32(pOEM->fGeneral2, BARCODE_ROT270))
                        lpTemp++;
                    // send start char
                    len = safe_sprintfA(Code128Buf, sizeof(Code128Buf),",%d",(BYTE)BAR_CODE128_START);
                    WRITESPOOLBUF(pdevobj, Code128Buf, len);
                    for (cnt = 0; cnt < (int)pOEM->RPDLHeapCount; cnt++)
                    {
                        len = safe_sprintfA(Code128Buf, sizeof(Code128Buf),",%d",(BYTE)(lpTemp[cnt]-32));
                        WRITESPOOLBUF(pdevobj, Code128Buf, len);
                    }
                }
                else
                {
// @Dec/17/99 FK#50 <-
                    // Output barcode characters
                    if (BITTEST32(pOEM->fGeneral2, BARCODE_ROT270))     // @Oct/22/97
                        WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64+1, pOEM->RPDLHeapCount);
                    else
                        WRITESPOOLBUF(pdevobj, pOEM->RPDLHeap64, pOEM->RPDLHeapCount);
// @Dec/17/99 FK#50 ->
                }
// @Dec/17/99 FK#50 <-

                pOEM->RPDLHeapCount = 0;
                // We add ';' for safe finish in case of insufficient character at JAN.
                ocmd = safe_sprintfA(Cmd, sizeof(Cmd), TERMINATOR);
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, EXIT_VECTOR); // exit VectorMode
                WRITESPOOLBUF(pdevobj, Cmd, ocmd);
            } // 'if BARCODE_DATA_VALID && BARCODE_FINISH' end

            if(fMemAllocated)
                MemFree(aubBuff);

            return TRUE;        // BOOL <- VOID @Mar/27/2002
        }
//** Draw barcode END **

//** Draw device font **
        BITCLR32(pOEM->fGeneral1, FONT_VERTICAL_ON);
        rcID = (SHORT)pUFObj->ulFontID;

        if (rcID >= JPN_FNT_FIRST && rcID <= JPN_FNT_LAST)
        {
            if (TEST_VERTICALFONT(rcID))
            {
                fVertFont = TRUE;   // vertical font
                BITSET32(pOEM->fGeneral1, FONT_VERTICAL_ON);
            }
            // IBM ext char(SJIS) supported from SP9II
            if (rcID >= AFTER_SP9II_FNT_FIRST)
                fIBMFontSupport = TRUE;
// @Oct/27/98 ->
#ifdef JISGTT
            // Current UFM of PMincho & PGothic declare JIS code set.
            if (rcID >= JPN_MSPFNT_FIRST)
                fJisCode = TRUE;
#endif // JISGTT
// @Oct/27/98 <-
        }
        else if (rcID >= EURO_FNT_FIRST && rcID <= EURO_FNT_LAST)
        {
            fEuroFont = TRUE; // European font(Courier,BoldFacePS,etc).
            // Fullset(0x20-0xFF) fonts(Arial,Century,TimesNewRoman,etc) are supported
            // from NX-110
            if (rcID >= EURO_MSFNT_FIRST)
                fEuroFontFullset = TRUE;
        }

        for (dwI = 0; dwI < dwCount; dwI ++, pTrans ++)     // increment pTrans  MSKK 98/3/16
        {
            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
              case MTYPE_DIRECT:    // SBCS (European font & Japanese font HANKAkU)
//              VERBOSE((("TYPE_TRANSDATA:ubCode:0x%x\n"), pTrans->uCode.ubCode));

                lpChar = &pTrans->uCode.ubCode;
                CharTmp1 = *lpChar;

                if (fEuroFont)  //** European font  **
                {
                    // ** print 1st SBCS font(0x20-0x7F) **
                    if (CharTmp1 < 0x80)
                    {
                        // PRINTER SIDE ISSUE: RPDL
                        // take care of device font bug
                        if (rcID == SYMBOL && CharTmp1 == 0x60)     // "radical extention"
                        {
                            WRITESPOOLBUF(pdevobj, DOUBLE_SPACE, sizeof(DOUBLE_SPACE)-1);
                            WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                            WRITESPOOLBUF(pdevobj, DOUBLE_BS, sizeof(DOUBLE_BS)-1);
                        }
                        else
                        {
                            WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        }
                        continue;       // goto for-loop end
                    }


                    // ** print 2nd SBCS font(0x80-0xFF) **
                    // If full-set(0x20-0xFF) font
                    if (fEuroFontFullset)
                    {
                        // If same to DBCS 1st byte
                        if (IsDBCSLeadByteRPDL(CharTmp1))
                            WRITESPOOLBUF(pdevobj, ESC_CTRLCODE, sizeof(ESC_CTRLCODE)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        continue;       // goto for-loop end
                    }

                    // If not full-set font
                    switch (CharTmp1)
                    {
                      case 0x82:
                        CharTmp1 = ',';     goto _WRITE1BYTE;
                      case 0x88:
                        CharTmp1 = '^';     goto _WRITE1BYTE;
                      case 0x8B:
                        CharTmp1 = '<';     goto _WRITE1BYTE;
                      case 0x9B:
                        CharTmp1 = '>';     goto _WRITE1BYTE;
                      case 0x91:        // single quatation
                      case 0x92:
                        CharTmp1 = 0x27;    goto _WRITE1BYTE;
                      case 0x93:        // double quatation
                      case 0x94:
                        CharTmp1 = 0x22;    goto _WRITE1BYTE;
                      case 0x96:
                      case 0x97:
                        CharTmp1 = '-';     goto _WRITE1BYTE;
                      case 0x98:
                        CharTmp1 = '~';     goto _WRITE1BYTE;
                      case 0xA6:
                        CharTmp1 = '|';     goto _WRITE1BYTE;
                      case 0xAD:
                        CharTmp1 = '-';     goto _WRITE1BYTE;
                      case 0xB8:
                        CharTmp1 = ',';     goto _WRITE1BYTE;
                      case 0xD7:
                        CharTmp1 = 'x';     goto _WRITE1BYTE;

                      case 0x83:
                        CharTmp1 = 0xBF;    goto _WRITE1BYTE;
                      case 0x86:
                        CharTmp1 = 0xA8;    goto _WRITE1BYTE;
                      case 0x99:
                        CharTmp1 = 0xA9;    goto _WRITE1BYTE;
                      case 0xE7:
                        CharTmp1 = 0xA2;    goto _WRITE1BYTE;
                      case 0xE8:
                        CharTmp1 = 0xBD;    goto _WRITE1BYTE;
                      case 0xE9:
                        CharTmp1 = 0xBB;    goto _WRITE1BYTE;
                      case 0xF9:
                        CharTmp1 = 0xBC;    goto _WRITE1BYTE;
                      case 0xFC:
                        CharTmp1 = 0xFD;    goto _WRITE1BYTE;

                      case 0xA0:
                      case 0xA3:
                      case 0xA4:
                        goto _WRITE1BYTE;

                      case 0xA2:
                        CharTmp1 = 0xDE;    goto _WRITE1BYTE;
                      case 0xA5:        //YEN mark
                        CharTmp1 = 0xCC;    goto _WRITE1BYTE;
                      case 0xA7:
                        CharTmp1 = 0xC0;    goto _WRITE1BYTE;
                      case 0xA8:
                        CharTmp1 = 0xBE;    goto _WRITE1BYTE;
                      case 0xA9:
                        CharTmp1 = 0xAB;    goto _WRITE1BYTE;
                      case 0xAE:
                        CharTmp1 = 0xAA;    goto _WRITE1BYTE;
                      case 0xAF:
                        CharTmp1 = 0xB0;    goto _WRITE1BYTE;
                      case 0xB0:
                      case 0xBA:
                        CharTmp1 = 0xA6;    goto _WRITE1BYTE;
                      case 0xB4:
                        CharTmp1 = 0xA7;    goto _WRITE1BYTE;
                      case 0xB5:
                        CharTmp1 = 0xA5;    goto _WRITE1BYTE;
                      case 0xB6:
                        CharTmp1 = 0xAF;    goto _WRITE1BYTE;
                      case 0xBC:
                        CharTmp1 = 0xAC;    goto _WRITE1BYTE;
                      case 0xBD:
                        CharTmp1 = 0xAE;    goto _WRITE1BYTE;
                      case 0xBE:
                        CharTmp1 = 0xAD;    goto _WRITE1BYTE;
                      case 0xC4:
                        CharTmp1 = 0xDB;    goto _WRITE1BYTE;
                      case 0xC5:
                        CharTmp1 = 0xD6;    goto _WRITE1BYTE;
                      case 0xC9:
                        CharTmp1 = 0xB8;    goto _WRITE1BYTE;
                      case 0xD6:
                        CharTmp1 = 0xDC;    goto _WRITE1BYTE;
                      case 0xDC:
                        CharTmp1 = 0xDD;    goto _WRITE1BYTE;
                      case 0xDF:
                        CharTmp1 = 0xFE;    goto _WRITE1BYTE;

                      _WRITE1BYTE:
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        break;


                      // Combine 2 fonts, because next fonts do not exist in device font
                      case 0x87:
                        CharTmp1 = '=';  CharTmp2 = '|';    goto _COMBINEDFONT;
                      case 0xD0:        // 'D' with middle bar
                        CharTmp1 = 'D';  CharTmp2 = '-';    goto _COMBINEDFONT;
                      case 0xD8:        // 'O' with slash
                        CharTmp1 = 'O';  CharTmp2 = '/';    goto _COMBINEDFONT;
                      case 0xE0:        // 'a' with right-down dash
                        CharTmp1 = 'a';  CharTmp2 = '`';    goto _COMBINEDFONT;
                      case 0xE1:        // 'a' with left-down dash
                        CharTmp1 = 'a';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xE2:        // 'a' with hat
                        CharTmp1 = 'a';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xE3:        // 'a' with tilde
                        CharTmp1 = 'a';  CharTmp2 = '~';    goto _COMBINEDFONT;
                      case 0xE4:        // 'a' with umlaut
                        CharTmp1 = 'a';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      case 0xE5:        // 'a' with circle
                        CharTmp1 = 'a';  CharTmp2 = 0xA6;   goto _COMBINEDFONT;
                      case 0xEA:        // 'e' with hat
                        CharTmp1 = 'e';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xEB:        // 'e' with umlaut
                        CharTmp1 = 'e';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      case 0xF1:        // 'n' with tilde
                        CharTmp1 = 'n';  CharTmp2 = '~';    goto _COMBINEDFONT;
                      case 0xF2:        // 'o' with right-down dash
                        CharTmp1 = 'o';  CharTmp2 = '`';    goto _COMBINEDFONT;
                      case 0xF3:        // 'o' with left-down dash
                        CharTmp1 = 'o';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xF4:        // 'o' with hat
                        CharTmp1 = 'o';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xF5:        // 'o' with tilde
                        CharTmp1 = 'o';  CharTmp2 = '~';    goto _COMBINEDFONT;
                      case 0xF6:        // 'o' with umlaut
                        CharTmp1 = 'o';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      case 0xF8:        // 'o' with slash
                        CharTmp1 = 'o';  CharTmp2 = '/';    goto _COMBINEDFONT;
                      case 0xFA:        // 'u' with left-down dash
                        CharTmp1 = 'u';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xFB:        // 'u' with hat
                        CharTmp1 = 'u';  CharTmp2 = '^';    goto _COMBINEDFONT;
                      case 0xFD:        // 'y' with left-down dash
                        CharTmp1 = 'y';  CharTmp2 = 0xA7;   goto _COMBINEDFONT;
                      case 0xFF:        // 'y' with umlaut
                        CharTmp1 = 'y';  CharTmp2 = 0xBE;   goto _COMBINEDFONT;
                      _COMBINEDFONT:
                        WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        if (rcID == BOLDFACEPS && CharTmp1 != 'D')  // BoldFacePS(except 'D'+'-')
                            WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        break;

                      case 0x9F:        // 'Y' with umlaut
                        CharTmp1 = 'Y';  CharTmp2 = 0xBE;   goto _COMBINEDFONT_HALFUP;
                      case 0xC0:        // 'A' with right-down dash
                        CharTmp1 = 'A';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xC1:        // 'A' with left-down dash
                        CharTmp1 = 'A';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xC2:        // 'A' with hat
                        CharTmp1 = 'A';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xC3:        // 'A' with tilde
                        CharTmp1 = 'A';  CharTmp2 = '~';    goto _COMBINEDFONT_HALFUP;
                      case 0xC8:        // 'E' with right-down dash
                        CharTmp1 = 'E';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xCA:        // 'E' with hat
                        CharTmp1 = 'E';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xCB:        // 'E' with umlaut
                        CharTmp1 = 'E';  CharTmp2 = 0xBE;   goto _COMBINEDFONT_HALFUP;
                      case 0xCC:        // 'I' with right-down dash
                        CharTmp1 = 'I';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xCD:        // 'I' with left-down dash
                        CharTmp1 = 'I';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xCE:        // 'I' with hat
                        CharTmp1 = 'I';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xCF:        // 'I' with umlaut
                        CharTmp1 = 'I';  CharTmp2 = 0xBE;   goto _COMBINEDFONT_HALFUP;
                      case 0xD1:        // 'N' with tilde
                        CharTmp1 = 'N';  CharTmp2 = '~';    goto _COMBINEDFONT_HALFUP;
                      case 0xD2:        // 'O' with right-down dash
                        CharTmp1 = 'O';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xD3:        // 'O' with left-down dash
                        CharTmp1 = 'O';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xD4:        // 'O' with hat
                        CharTmp1 = 'O';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xD5:        // 'O' with tilde
                        CharTmp1 = 'O';  CharTmp2 = '~';    goto _COMBINEDFONT_HALFUP;
                      case 0xD9:        // 'U' with right-down dash
                        CharTmp1 = 'U';  CharTmp2 = '`';    goto _COMBINEDFONT_HALFUP;
                      case 0xDA:        // 'U' with left-down dash
                        CharTmp1 = 'U';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      case 0xDB:        // 'U' with hat
                        CharTmp1 = 'U';  CharTmp2 = '^';    goto _COMBINEDFONT_HALFUP;
                      case 0xDD:        // 'Y' with left-down dash
                        CharTmp1 = 'Y';  CharTmp2 = 0xA7;   goto _COMBINEDFONT_HALFUP;
                      _COMBINEDFONT_HALFUP:
                        WRITESPOOLBUF(pdevobj, ESC_HALFUP, sizeof(ESC_HALFUP)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                        WRITESPOOLBUF(pdevobj, ESC_HALFDOWN, sizeof(ESC_HALFDOWN)-1);
                        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        if (rcID == BOLDFACEPS && CharTmp1 != 'I')  // BoldFacePS(except 'I')
                            WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        break;


                      case 0x84:        // double quatation at bottom
                        CharTmp1 = 0x22;
                        WRITESPOOLBUF(pdevobj, ESC_DOWN, sizeof(ESC_DOWN)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        WRITESPOOLBUF(pdevobj, ESC_UP, sizeof(ESC_UP)-1);
                        break;

                      case 0xB1:        // plus-minus
                        if (rcID == BOLDFACEPS)
                        {
                            CharTmp2 = '_';  CharTmp1 = '+';
                            WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                            WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        }
                        else
                        {
                            CharTmp2 = '+';  CharTmp1 = '-';
                            WRITESPOOLBUF(pdevobj, &CharTmp2, 1);
                        }
                        WRITESPOOLBUF(pdevobj, BS, sizeof(BS)-1);
                        WRITESPOOLBUF(pdevobj, ESC_DOWN, sizeof(ESC_DOWN)-1);
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        WRITESPOOLBUF(pdevobj, ESC_UP, sizeof(ESC_UP)-1);
                        break;

                      case 0x95:
                      case 0xB7:
                      default:          // print unprintable font by dot(KATAKANA)
                        // Set 2nd SBCS font table(0x80-0xFF) as KATAKANA
                        WRITESPOOLBUF(pdevobj, ESC_SHIFT_IN, sizeof(ESC_SHIFT_IN)-1);
                        CharTmp1 = 0xA5;
                        WRITESPOOLBUF(pdevobj, &CharTmp1, 1);
                        // Set 2nd SBCS font table(0x80-0xFF) as 2ndANK
                        WRITESPOOLBUF(pdevobj, ESC_SHIFT_OUT, sizeof(ESC_SHIFT_OUT)-1);
                        break;
                    } // 'switch (CharTmp1)' end
                }
                else            //** Japanese font (HANKAKU) **
                {
                    if (fVertFont)  // vertical font
                    {
                        // HANKAKU(Alphabetical&Numeric) fonts must not become vertical.
                        WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF)-1);
                        WRITESPOOLBUF(pdevobj, lpChar, 1);
                        WRITESPOOLBUF(pdevobj, ESC_VERT_ON, sizeof(ESC_VERT_ON)-1);
                    }
                    else            // normal (non vertical) font
                    {
                        WRITESPOOLBUF(pdevobj, lpChar, 1);
                    }
                } // 'if European font else Japanese font(HANKAKU)' end


                break;

              case MTYPE_PAIRED:    // DBCS (Japanes font ZENKAKU)
//              VERBOSE((("TYPE_TRANSDATA:ubPairs:0x%x\n"), *(PWORD)(pTrans->uCode.ubPairs)));

                lpChar = pTrans->uCode.ubPairs;

// For proportional font UFM which has GTT @Oct/27/98 ->
#ifdef JISGTT
                if (fJisCode)
                {
                    BYTE    jis[2], sjis[2];

                    jis[0] = *lpChar;
                    jis[1] = *(lpChar+1);
                    jis2sjis(jis, sjis);
                    (BYTE)*lpChar     = sjis[0];
                    (BYTE)*(lpChar+1) = sjis[1];
                }
#endif // JISGTT
// @Oct/27/98 <-
                CharTmp1 = *lpChar;
                CharTmp2 = *(lpChar+1);
                // Some vertical device font differ from TrueType font
                if (fVertFont)
                {
                    if (CharTmp1 == 0x81)
                    {
                        // Make vertical device font same to TrueType
                        if (IsDifferentPRNFONT(CharTmp2))
                        {
                            WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF)-1);
                            WRITESPOOLBUF(pdevobj, ESC_ROT90, sizeof(ESC_ROT90)-1);
                            WRITESPOOLBUF(pdevobj, lpChar, 2);
                            WRITESPOOLBUF(pdevobj, ESC_ROT0, sizeof(ESC_ROT0)-1);
                            WRITESPOOLBUF(pdevobj, ESC_VERT_ON, sizeof(ESC_VERT_ON)-1);
                            continue;   // goto for-loop end
                        }
                        else if (CharTmp2 >= 0xA8 && CharTmp2 <= 0xAB)
                        {   //IMAGIO's GOTHIC device font differ from TrueType font
                            goto _WITHOUTROTATION;
                        }
                    }

                    if (CharTmp1 == 0x84 &&
                        CharTmp2 >= 0x9F && CharTmp2 <= 0xBE)
                    {
                  _WITHOUTROTATION:
                        WRITESPOOLBUF(pdevobj, ESC_VERT_OFF, sizeof(ESC_VERT_OFF)-1);
                        WRITESPOOLBUF(pdevobj, lpChar, 2);
                        WRITESPOOLBUF(pdevobj, ESC_VERT_ON, sizeof(ESC_VERT_ON)-1);
                        continue;       // goto for-loop end
                    }
                } // 'if(fVertFont)' end

                // Code of HEISEI mark of device font differs from SJIS
                if (CharTmp1 == 0x87 && CharTmp2 == 0x7E)
                {
                    (BYTE)*(lpChar+1) = 0x9E;
                    WRITESPOOLBUF(pdevobj, lpChar, 2);
                    continue;           // goto for-loop end
                }

                // If models which support IBM ext char code
                if (fIBMFontSupport)
                {
                    WRITESPOOLBUF(pdevobj, lpChar, 2);
                    continue;           // goto for-loop end
                }

                // Handle IBM ext char code here at models which do not support it
                switch (CharTmp1)
                {
                  case 0xFA:
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0xFC)
                        (BYTE)*lpChar = 0x0EB;
                    goto _WRITE2BYTE;

                  case 0xFB:
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x9E)
                    {
                        (BYTE)*lpChar = 0xEC;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x9F && CharTmp2 <= 0xDD)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) -= 0x5F;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    if (CharTmp2 >= 0xDE && CharTmp2 <= 0xFC)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) -= 0x5E;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    goto _WRITE2BYTE;

                  case 0xFC:
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x4B)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) += 0x5F;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    goto _WRITE2BYTE;


                  case 0xED:        //IBM extended char selected by NEC
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x62)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) += 0x1C;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x63 && CharTmp2 <= 0x7E)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) += 0x1D;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x80 && CharTmp2 <= 0xE0)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) += 0x1C;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0xE1 && CharTmp2 <= 0xFC)
                    {
                        (BYTE)*lpChar      = 0xEC;
                        (BYTE)*(lpChar+1) -= 0xA1;
                        goto _WRITE2BYTE;
                    }
                    goto _WRITE2BYTE;

                  case 0xEE:        //IBM extended char selected by NEC
                    if (CharTmp2 >= 0x40 && CharTmp2 <= 0x62)
                    {
                        (BYTE)*lpChar      = 0xEC;
                        (BYTE)*(lpChar+1) += 0x1C;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x63 && CharTmp2 <= 0x7E)
                    {
                        (BYTE)*lpChar      = 0xEC;
                        (BYTE)*(lpChar+1) += 0x1D;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x80 && CharTmp2 <= 0x82)
                    {
                        (BYTE)*lpChar      = 0xEC;
                        (BYTE)*(lpChar+1) += 0x1C;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0x83 && CharTmp2 <= 0xC1)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) -= 0x43;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    if (CharTmp2 >= 0xC2 && CharTmp2 <= 0xEC)
                    {
                        (BYTE)*lpChar      = 0x8A;
                        (BYTE)*(lpChar+1) -= 0x42;
                        goto _WRITE2BYTE_SWITCHBLOCK;
                    }
                    if (CharTmp2 >= 0xEF && CharTmp2 <= 0xF8)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) -= 0xAF;
                        goto _WRITE2BYTE;
                    }
                    if (CharTmp2 >= 0xF9 && CharTmp2 <= 0xFC)
                    {
                        (BYTE)*lpChar      = 0xEB;
                        (BYTE)*(lpChar+1) -= 0xA5;
                        goto _WRITE2BYTE;
                    }
                    goto _WRITE2BYTE;

                  _WRITE2BYTE_SWITCHBLOCK:
                    // Assign IBM char to JIS1 block
                    AssignIBMfont(pdevobj, rcID, IBMFONT_ENABLE_ALL);
                    // Output char code
                    WRITESPOOLBUF(pdevobj, lpChar, 2);
                    // Resume the block
                    AssignIBMfont(pdevobj, rcID, IBMFONT_RESUME);
                    break;

                  default:
                  _WRITE2BYTE:
                    WRITESPOOLBUF(pdevobj, lpChar, 2);
                    break;
                } // 'switch (CharTmp1)' end

                break;
            } // 'switch (pTrans->ubType & MTYPE_FORMAT_MASK)' end
        } // 'for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)' end
//** Draw device font END **

       if(fMemAllocated)
           MemFree(aubBuff);

        break;


      case TYPE_GLYPHID:        // donwload font
#ifdef DOWNLOADFONT
        // If negative, do not draw. (lFontID should begin from 0.)
//      VERBOSE((("** ulFontID=%d **\n"), pUFObj->ulFontID));
        if ((lFontID = (LONG)pUFObj->ulFontID - DLFONT_ID_MIN_GPD) < 0)
            break;    // exit

//** Draw download font **
        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {
            // If negative, do not draw. (lGlyphID should begin from 0.)
            if ((lGlyphID = (LONG)*(PWORD)pGlyph - DLFONT_GLYPH_MIN_GPD) < 0)
                break;  // exit for-loop
            wSerialNum = (WORD)lGlyphID + (WORD)lFontID * DLFONT_GLYPH_TOTAL;
            lpDLFont = &pOEM->pDLFontGlyphInfo[wSerialNum];

//          VERBOSE((("** pGlyph=%d, local glyph_id=%d **\n"), *(PWORD)pGlyph, lGlyphID));

            // If space character
            if (lpDLFont->nPitch < 0)
            {
                // Save moving value for next font print with reseting flag
                pOEM->nCharPosMoveX += -lpDLFont->nPitch;
            }
            else
            {
                // Locate print position.
                if ((mov = pOEM->nCharPosMoveX + lpDLFont->nOffsetX) != 0)
                {
                    if (mov > 0)
                        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ESC_XM_REL, mov);
                    else
                        ocmd = safe_sprintfA(Cmd, sizeof(Cmd), ESC_XM_RELLEFT, -mov);
                }

                // Print download font
                ocmd += safe_sprintfA(&Cmd[ocmd], sizeof(Cmd) - ocmd, DLFONT_PRINT, wSerialNum,
                                pOEM->TextCurPos.y - lpDLFont->nOffsetY);
                WRITESPOOLBUF(pdevobj, Cmd, ocmd);
                ocmd = 0;

                // Save moving value for next font print.
                pOEM->nCharPosMoveX = lpDLFont->nPitch - lpDLFont->nOffsetX;
            } // 'if (pitch < 0) else' end
        } // 'for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)' end
#endif // DOWNLOADFONT
        break;
//** Draw download font END **
    } // 'switch (dwType)' end
    return TRUE;        // BOOL <- VOID @Mar/27/2002
} //*** bOEMOutputCharStr


DWORD APIENTRY OEMDownloadFontHeader(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj)
{
#ifndef DOWNLOADFONT
    return 0;   // not available
#else  // DOWNLOADFONT
    VERBOSE(("** OEMDownloadFontHeader() entry. **\n"));
    VERBOSE(("  FontID=%d\n", pUFObj->ulFontID));
// OBSOLETE @Apr/02/99 ->
// SPEC of Unidrv5
// Unidrv5 doesn't handle 0-return, once OEMTTDownloadMethod returns TTDOWNLOAD_BITMAP.
//  POEMPDEV    pOEM = MINIDEV_DATA(pdevobj);   // @Oct/06/98
//  LONG        lFontID;    // @Aug/21/98
//  // If FontID is beyond limit, exit.
//  if ((lFontID = (LONG)pUFObj->ulFontID - DLFONT_ID_MIN_GPD) < 0 ||
//      lFontID >= (LONG)pOEM->DLFontMaxID)
//  {
//      return 0;
//  }
// @Apr/02/99 <-
    return 1;   // available
#endif // DOWNLOADFONT
} //*** OEMDownloadFontHeader


DWORD APIENTRY OEMDownloadCharGlyph(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH hGlyph,
    PDWORD pdwWidth)
{
#ifndef DOWNLOADFONT
    return 0;       // not available
#else  // DOWNLOADFONT
    WORD        wSerialNum, wHeight, wWidthByte;
    DWORD       dwNeeded, dwSize;
    LPBYTE      lpBitmap;
    LPFONTPOS   lpDLFont;
    GETINFO_GLYPHBITMAP GBmp;
    POEMPDEV    pOEM = MINIDEV_DATA(pdevobj);   // @Oct/06/98
    LONG        lFontID, lGlyphID;

    VERBOSE(("** OEMDownloadCharGlyph() entry. **\n"));

    // If negative or beyond limit, do not download. (lGlyphID should begin from 0.)
    if ((lGlyphID = (LONG)pOEM->DLFontCurGlyph - DLFONT_GLYPH_MIN_GPD) < 0 ||
        lGlyphID >= pOEM->DLFontMaxGlyph)
    {
        return 0;   // exit
    }

    // If beyond limit, do not download. (lFontID should begin from 0.)
    if ((lFontID = (LONG)pUFObj->ulFontID - DLFONT_ID_MIN_GPD) < 0 ||
        lFontID >= (LONG)pOEM->DLFontMaxID)
    {
        return 0;   // exit
    }
    VERBOSE(("  FontID=%d, GlyphID=%d\n", lFontID, lGlyphID));

    wSerialNum = (WORD)lGlyphID + (WORD)lFontID * DLFONT_GLYPH_TOTAL;

    //
    // GETINFO_GLYPHBITMAP
    //
    GBmp.dwSize = sizeof(GETINFO_GLYPHBITMAP);
    GBmp.hGlyph = hGlyph;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp,
                            GBmp.dwSize, &dwNeeded))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\n"));
        return 0;   // exit
    }
    wWidthByte = ((WORD)GBmp.pGlyphData->gdf.pgb->sizlBitmap.cx + 7) >> 3;  // byte:8bit-boundary
    wHeight    = (WORD)GBmp.pGlyphData->gdf.pgb->sizlBitmap.cy;
    lpBitmap   = (LPBYTE)GBmp.pGlyphData->gdf.pgb->aj;
    lpDLFont   = &pOEM->pDLFontGlyphInfo[wSerialNum];
    lpDLFont->nPitch   = (SHORT)(GBmp.pGlyphData->fxD >> 4);
    lpDLFont->nOffsetX = (SHORT)GBmp.pGlyphData->gdf.pgb->ptlOrigin.x;
    lpDLFont->nOffsetY = -(SHORT)GBmp.pGlyphData->gdf.pgb->ptlOrigin.y;
    dwSize = wHeight * wWidthByte;

//  VERBOSE(("  width=%dbyte,height=%ddot,bmp[0]=%x\n", wWidthByte, wHeight, *lpBitmap));
//  VERBOSE(("  pitch=%d(FIX(28.4):%lxh),offsetx=%d,offsety=%d\n",
//           GBmp.pGlyphData->fxD >> 4, GBmp.pGlyphData->fxD,
//           lpDLFont->nOffsetX, lpDLFont->nOffsetY));
//  VERBOSE(("  dwSize(raw)=%ldbyte\n", dwSize));

    // If space character
    if (dwSize == 0 || dwSize == 1 && *lpBitmap == 0)
    {
        // Negate pitch to indicate space character
        lpDLFont->nPitch = -lpDLFont->nPitch;
        return 1;   // success return  (1<-0 @Jun/15/98)
    }
    else
    {
        BYTE        Cmd[64];
        INT         ocmd;   // INT<-SHORT  @Feb/22/99
        WORD        fDRC = FALSE;
        DWORD       dwSizeRPDL, dwSizeDRC;

        // Do FE-DeltaRow compression  (@Jun/15/98, pOEM->pRPDLHeap2K<-OutBuf[1024] @Sep/09/98)
        if (TEST_CAPABLE_DOWNLOADFONT_DRC(pOEM->fModel) && pOEM->pRPDLHeap2K &&
            -1 != (dwSizeDRC = DRCompression(lpBitmap, pOEM->pRPDLHeap2K, dwSize, HEAPSIZE2K,
                                             (DWORD)wWidthByte, (DWORD)wHeight)))
        {
            fDRC = TRUE;
            dwSize = dwSizeDRC;
            lpBitmap = pOEM->pRPDLHeap2K;
        }

        // Include header size and make it 32byte-boudary.
        dwSizeRPDL = (dwSize + (DLFONT_HEADER_SIZE + DLFONT_MIN_BLOCK - 1))
                     / DLFONT_MIN_BLOCK * DLFONT_MIN_BLOCK;

        // Check available memory size
        if((pOEM->dwDLFontUsedMem += dwSizeRPDL) > ((DWORD)pOEM->DLFontMaxMemKB << 10))
        {
            ERR(("DOWNLOAD MEMORY OVERFLOW.\n"));
            return 0;   // exit
        }
        VERBOSE(("  Consumed Memory=%ldbyte\n", pOEM->dwDLFontUsedMem));

        // Register glyph bitmap image
        if (fDRC)   // @Jun/15/98
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), DLFONT_SEND_BLOCK_DRC, wWidthByte*8, wHeight, wSerialNum, dwSize);
        else
            ocmd = safe_sprintfA(Cmd, sizeof(Cmd), DLFONT_SEND_BLOCK, wWidthByte*8, wHeight, wSerialNum);
        WRITESPOOLBUF(pdevobj, Cmd, ocmd);
        WRITESPOOLBUF(pdevobj, lpBitmap, dwSize);
        return dwSizeRPDL;
    }
#endif // DOWNLOADFONT
} //*** OEMDownloadCharGlyph


DWORD APIENTRY OEMTTDownloadMethod(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj)
{
#ifndef DOWNLOADFONT
    return TTDOWNLOAD_DONTCARE;
#else  // DOWNLOADFONT
// @Nov/18/98 ->
    GETINFO_FONTOBJ GFo;
    POEMPDEV pOEM = MINIDEV_DATA(pdevobj);
    DWORD    dwNeeded, dwWidth;

    VERBOSE(("** OEMTTDownloadMethod() entry. **\n"));

    // If printer doesn't support or user disabled downloading, do not download.
    if (!pOEM->DLFontMaxMemKB)
        return TTDOWNLOAD_DONTCARE;

    //
    // GETINFO_FONTOBJ
    //
    GFo.dwSize = sizeof(GETINFO_FONTOBJ);
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_FONTOBJ, &GFo,
                            GFo.dwSize, &dwNeeded))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_FONTOBJ failed.\n"));
        return TTDOWNLOAD_GRAPHICS;     // <-TTDOWNLOAD_DONTCARE @Apr/02/99
    }

    // If bold or italic font, do not download.
    // (SBCS font which has bold or italic glyph (e.g. Arial) doesn't fit this condition.)
    if (GFo.pFontObj->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC))
    {
        VERBOSE(("  UNAVAILABLE: BOLD/ITALIC\n"));
        return TTDOWNLOAD_GRAPHICS;     // <-TTDOWNLOAD_DONTCARE @Apr/02/99
    }

    dwWidth = GFo.pFontObj->cxMax * pOEM->nResoRatio;  // masterunit
//  VERBOSE(("  FontSize=%d\n", GFo.pFontObj->cxMax));

    // If font width is beyond limit, do not download.
    if (IS_DBCSCHARSET(pUFObj->pIFIMetrics->jWinCharSet))
    {
        if (dwWidth > DLFONT_SIZE_DBCS11PT_MU || dwWidth < DLFONT_SIZE_DBCS9PT_MU)
        {
            VERBOSE(("  UNAVAILABLE: DBCS FONTSIZE OUT OF RANGE(%ddot,%dcpt)\n",
                     GFo.pFontObj->cxMax, dwWidth*7200L/MASTERUNIT));
            return TTDOWNLOAD_GRAPHICS; // <-TTDOWNLOAD_DONTCARE @Apr/02/99
        }
    }
    else
    {
        if (dwWidth > DLFONT_SIZE_SBCS11PT_MU || dwWidth < DLFONT_SIZE_SBCS9PT_MU)
        {
            VERBOSE(("  UNAVAILABLE: SBCS FONTSIZE OUT OF RANGE(%ddot,%dcpt)\n",
                     GFo.pFontObj->cxMax, dwWidth*7200L/MASTERUNIT));
            return TTDOWNLOAD_GRAPHICS; // <-TTDOWNLOAD_DONTCARE @Apr/02/99
        }
    }
    VERBOSE(("  AVAILABLE\n"));
// @Nov/18/98 <-
    return TTDOWNLOAD_BITMAP;
#endif // DOWNLOADFONT
} //*** OEMTTDownloadMethod


INT APIENTRY OEMCompression(                        // @Jun/04/98
    PDEVOBJ pdevobj,
    PBYTE pInBuf,
    PBYTE pOutBuf,
    DWORD dwInLen, 
    DWORD dwOutLen)
{
    POEMPDEV pOEM = MINIDEV_DATA(pdevobj);          // @Oct/06/98

//  VERBOSE(("OEMCompression() entry.\n"));
    return DRCompression(pInBuf, pOutBuf, dwInLen, dwOutLen,
                         pOEM->dwSrcBmpWidthByte, pOEM->dwSrcBmpHeight);
} //*** OEMCompression


//---------------------------*[LOCAL] DRCompression*---------------------------
// Action: Compress data by FE-DeltaRow method
// Return: number of compressed bytes if successful
//         -1 if unable to compress the data within the specific buffer
// History:
//      Oct/25/97 Tatsuro Yoshioka(RICOH) Created.
//      Jun/11/98 Masatoshi Kubokura(RICOH) Modified.
//-----------------------------------------------------------------------------
static INT DRCompression(
    PBYTE pInBuf,       // Pointer to raster data to compress
    PBYTE pOutBuf,      // Pointer to output buffer for compressed data
    DWORD dwInLen,      // size of input data to compress
    DWORD dwOutLen,     // size of output buffer in bytes
    DWORD dwWidthByte,  // width of raster data in bytes
    DWORD dwHeight)     // height of raster data
{
    DWORD   dwCurRow, dwCurByte, dwSameByteCnt, dwRepeatByteCnt, dwTmp;
    DWORD   dwCompLen, dwCnt, dwCnt2;
    BYTE    *pTmpPre, *pTmpCur, *pCurRow, *pPreRow;
    BYTE    DiffBytes[16], FlagBit;

//  VERBOSE(("  dwInLen, dwOutLen=%d, %d\n", dwInLen, dwOutLen));
//  VERBOSE(("  Width, Height=%d, %d\n", dwWidthByte, dwHeight));

    if (dwOutLen > dwInLen)     // add  @Jun/19/98
        dwOutLen = dwInLen;

// @Apr/07/2000 ->
    // PRINTER SIDE ISSUE: RPDL
    // Bitmap image is destorted when width or height >= 10000dots
    if (dwWidthByte >= (10000L/8L) || dwHeight >= 10000L)
        return -1;
// @Apr/07/2000 <-
    if (dwHeight <= 3 || dwOutLen <= dwWidthByte * 3)
        return -1;
    pPreRow = pTmpPre = pOutBuf + dwOutLen - dwWidthByte;
    dwCnt = dwWidthByte;
    while (dwCnt--)         // fill seed row with 0
        *pTmpPre++ = 0;
    dwCompLen = 0;

    // Loop of each row
    for (dwCurRow = 0, pCurRow = pInBuf; dwCurRow < dwHeight;
         dwCurRow++, pCurRow += dwWidthByte)
    {
        dwCurByte = 0;
        // Loop of each byte-data in row
        while (dwCurByte < dwWidthByte)
        {
            // Search same byte-data between current row and previous row
            dwSameByteCnt = 0;
            dwTmp = dwCurByte;
            pTmpPre = pPreRow + dwTmp;
            pTmpCur = pCurRow + dwTmp;
            while (*pTmpCur++ == *pTmpPre++)
            {
// bug fix @Nov/19/98 ->
//              if (dwTmp++ >= dwWidthByte)
//                  break;
//              dwSameByteCnt++;
                dwSameByteCnt++;
                if (++dwTmp >= dwWidthByte)
                    break;
// @Nov/19/98 <-
            }

            // If we have same byte-data between current row and previous row
            if (dwSameByteCnt)
            {
                if (dwSameByteCnt != dwWidthByte)
                {
                    if ((dwCnt = dwSameByteCnt) >= 63)
                    {
                        dwCnt -= 63;
                        if (++dwCompLen > dwOutLen)
                        {
                            VERBOSE(("  OVERSIZE COMPRESSION(1)\n"));
                            return -1;
                        }
                        *pOutBuf++ = 0xBF;      // control data (same to previous row)

                        while (dwCnt >= 255)
                        {
                            dwCnt -= 255;
                            if (++dwCompLen > dwOutLen)
                            {
                                VERBOSE(("  OVERSIZE COMPRESSION(2)\n"));
                                return -1;
                            }
                            *pOutBuf++ = 0xFF;  // repeating count
                        }
                    }
                    else    // less than 63
                    {
                        dwCnt |= 0x80;
                    }

                    if (++dwCompLen > dwOutLen)
                    {
                        VERBOSE(("  OVERSIZE COMPRESSION(3)\n"));
                        return -1;
                    }
                    // If 63 or more, set the last repeating count, else set control data.
                    *pOutBuf++ = (BYTE)dwCnt;
                }
                dwCurByte += dwSameByteCnt;
            }
            // Same byte-data in previous row is none
            else
            {
                BYTE bTmp = *(pCurRow + dwCurByte);

                // How many same byte-data in current row?
                dwRepeatByteCnt = 1;
                dwTmp = dwCurByte + 1;
                pTmpCur = pCurRow + dwTmp;
                while (bTmp == *pTmpCur++)
                {
// bug fix @Nov/19/98 ->
//                  if (dwTmp++ >= dwWidthByte)
//                      break;
//                  dwRepeatByteCnt++;
                    dwRepeatByteCnt++;
                    if (++dwTmp >= dwWidthByte)
                        break;
// @Nov/19/98 <-
                }

                // If we have same byte-data in current row
                if (dwRepeatByteCnt > 1)
                {
                    if ((dwCnt = dwRepeatByteCnt) >= 63)
                    {
                        dwCnt -= 63;
                        if (++dwCompLen > dwOutLen)
                        {
                            VERBOSE(("  OVERSIZE COMPRESSION(4)\n"));
                            return -1;
                        }
                        *pOutBuf++ = 0xFF;      // repeating count

                        while (dwCnt >= 255)
                        {
                            dwCnt -= 255;
                            if (++dwCompLen > dwOutLen)
                            {
                                VERBOSE(("  OVERSIZE COMPRESSION(5)\n"));
                                return -1;
                            }
                            *pOutBuf++ = 0xFF;  // repeating count
                        }
                    }
                    // Less than 63
                    else
                    {
                        dwCnt |= 0xC0;
                    }

                    if ((dwCompLen += 2) > dwOutLen)
                    {
                        VERBOSE(("  OVERSIZE COMPRESSION(6)\n"));
                        return -1;
                    }
                    // If 63 or more, set the last repeating count, else set control data.
                    *pOutBuf++ = (BYTE)dwCnt;
                    *pOutBuf++ = *(pCurRow+dwCurByte);  // replacing data

                    dwCurByte += dwRepeatByteCnt;
                }
                // Same byte-data in current row is none
                else
                {
                     // If next serial 2 byte-data are same
                    if (dwWidthByte - dwCurByte > 2 &&
                        *(pCurRow+dwCurByte+1) == *(pCurRow+dwCurByte+2))
                    {
                        if ((dwCompLen += 2) > dwOutLen)
                        {
                            VERBOSE(("  OVERSIZE COMPRESSION(7)\n"));
                            return -1;
                        }
                        *pOutBuf++ = 0xC1;  // control data (1 data)
                        *pOutBuf++ = *(pCurRow+dwCurByte);  // replacing data

                        dwCurByte++;
                        continue;   // continue while(dwCurByte < dwWidthByte)
                    }

                    // We can pack 8 serial byte-data (may or may not be different to previus row)
                    DiffBytes[0] = 0x00; 
                    DiffBytes[1] = *(pCurRow+dwCurByte);
                    dwCnt2 = 2;
                    dwTmp = dwCurByte + 1;
                    pTmpPre = pPreRow + dwTmp;
                    pTmpCur = pCurRow + dwTmp;
                    FlagBit = 0x01;
                    if ((dwCnt = dwWidthByte - dwTmp) > 7)
                        dwCnt = 7;
                    while (dwCnt--)
                    {
                        // If encountered different data
                        if (*pTmpCur != *pTmpPre++)
                        {  
                            DiffBytes[0] |= FlagBit;        // set different-flag
                            DiffBytes[dwCnt2++] = *pTmpCur; // data
                        }
                        FlagBit <<= 1;
                        pTmpCur++;
                    }

                    if ((dwCompLen += dwCnt2) > dwOutLen)
                    {
                        VERBOSE(("  OVERSIZE COMPRESSION(8)\n"));
                        return -1;
                    }
                    pTmpCur = &DiffBytes[0];
                    while (dwCnt2--)
                        *pOutBuf++ = *pTmpCur++;    // different packed-data

                    dwCurByte += 8;                 // 8 byte-data are packed
                } // 'if (dwRepeatByteCnt > 1) else' end
            } // 'if (dwSameByteCnt) else' end
        } // 'while (dwCurByte < dwWidthByte)' end

        if (++dwCompLen > dwOutLen)
        {
            VERBOSE(("  OVERSIZE COMPRESSION(9)\n"));
            return -1;
        }
        *pOutBuf++ = 0x80;      // terminator of row

        pPreRow = pCurRow; 
    } // 'for (...; dwCurRow < dwHeight; ...)' end

//  VERBOSE(("  dwCompLen=%d\n", dwCompLen));
    return dwCompLen;
} //*** DRCompression
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\hlp\rpdlcfg2.hh ===
;IDH_Orientation=
;IDH_InputBin=
;IDH_Resolution=
;IDH_PaperSize=
;IDH_Collate=
;IDH_Duplex=
IDH_EdgeToEdgePrint=1
IDH_LeftMarginInPrinting=2
IDH_TopMarginInPrinting=3
IDH_EmulationMode=4
IDH_MediaType=5
IDH_OutputBin=6
IDH_Sorting=7
IDH_Stapling=8
IDH_Punching=9
IDH_ScanForRules=10
IDH_PrintQuality=11
IDH_PrintDensity=12
IDH_ImageControl=13
IDH_Halftone=14
IDH_Memory=15
IDH_LongEdgeFeed=16
IDH_CollateType=17
IDH_PrintTextAsBlack=18
;IDH_HardDisk=
;IDH_Finisher=
;IDH_PrintPost=
IDH_UI_VariableScaling=50
IDH_UI_BarHeight=51
IDH_UI_BarSubFont=52
IDH_UI_DuplexMargin=53
IDH_UI_BindRight=54
IDH_UI_TomboAdd=55
IDH_UI_TomboAdjX=56
IDH_UI_TomboAdjY=57
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\prp\mksjuni.c ===
/*
 *      mksjuni - Convert SJIS code to Unicode.
 *      (derived from mkunitab.c - Convert JIS code to Unicode.)
 *
 *      TODO:
 *
 *      HISTORY:
 *
 *      9/4/98 yasuho           Created.
 */
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>

#include <windef.h>
#include <winbase.h>
#include <winnls.h>

static char     buf[256];

static void mkunitab(char *name);
static void jis2sjis(BYTE jis[], BYTE sjis[]);
static void usage();
static void fatal(char *s);
static void error(char *s);

void __cdecl main(int argc, char *argv[])
{
        argc--, argv++;
        if (argc == 0)
                usage();
        while (argc--)
                mkunitab(*argv++);
        exit(0);
}

static void mkunitab(char *name)
{
        BYTE    jis[2];
        BYTE    sjis[4];
        WORD    v, n, len;
        INT     v1, v2;
        WCHAR   uni[2];
        FILE    *fp;

        if ((fp = fopen(name, "r")) == NULL)
                fatal(name);
        while (fgets(buf, sizeof buf, fp)) {
                len = strlen(buf);
                n = 0;
                while (isxdigit(buf[n]))
                        n++;
                if (n == 0)
                        continue;
                if (n != 2 && n != 4)
                        error("Invalid format");
                if (sscanf(buf, "%x %d %d", &v, &v1, &v2) != 3)
                        error("Invalid format");
                // SBCS Vertical font doesn't lying
                if (v <= 0xFF)
                        v2 = -v1;
// source file is sjis  v-masatk @Oct/26/98 ->
//              jis[0] = HIBYTE(v);
//              jis[1] = LOBYTE(v);
//              jis2sjis(jis, sjis);
                sjis[0] = HIBYTE(v);
                sjis[1] = LOBYTE(v);
// <-
                sjis[2] = 0;
                if (!MultiByteToWideChar(CP_ACP, 0, (const char *)sjis, 2,
                        uni, sizeof uni))
                        error("MultiByteToWideChar: fail");
                printf("%04x%8d%8d\n", uni[0], v1, v2);
        }
        fclose(fp);
}

static void jis2sjis(BYTE jis[], BYTE sjis[])
{
        BYTE            h, l;

        h = jis[0];
        l = jis[1];
        if (h == 0) {
                sjis[0] = l;
                sjis[1] = 0;
                return;
        }
        l += 0x1F;
        if (h & 0x01)
                h >>= 1;
        else {
                h >>= 1;
                l += 0x5E;
                h--;
        }
        if (l >= 0x7F)
                l++;
        if (h < 0x2F)
                h += 0x71;
        else
                h += 0xB1;
        sjis[0] = h;
        sjis[1] = l;
}

static void usage()
{
        fprintf(stderr, "Usage: mkunitab file[...]\n");
        exit(1);
}

static void fatal(char *s)
{
        fprintf(stderr, "mkunitab: ");
        perror(s);
        exit(1);
}

static void error(char *s)
{
        fprintf(stderr, "mkunitab: %s\n", s);
        exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\prp\mkwidth.c ===
/*
 *      mkwidth - Make WIDTHTABLE on ufm for Prop. DBCS device fonts.
 *
 *      TODO:
 *
 *      HISTORY:
 *
 *      9/4/98 yasuho           Created.
 */
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <prntfont.h>

typedef struct _GLYPHTABLE {
        WCHAR           wCode;
        WORD            wCount;
        WORD            wGID;
} GLYPHTABLE, *PGLYPHTABLE;

DWORD           ufmsize, gttsize;
DWORD           wtoffset;
DWORD           runsize;
PGLYPHTABLE     pGlyph;
UNIFM_HDR       ufm;
IFIMETRICS      IFI;
UNI_GLYPHSETDATA        gtt;
WIDTHTABLE      WidthTable;
PWIDTHRUN       pWidthRun;
DWORD           nWidthRun;
DWORD           loWidth;
PWORD           pWidth;
WORD            nWidth;

static int      vflag;
static int      Vflag;
static char     rbuf[256];

static void usage();
static void fatal(char *s);
static void error(char *s);

static void checkufm(char *name)
{
        FILE            *fp;
        struct _stat    sb;

        if (_stat(name, &sb) < 0)
                fatal(name);
        ufmsize = sb.st_size;
        if ((fp = fopen(name, "rb")) == NULL)
                fatal(name);
        if (fread(&ufm, sizeof ufm, 1, fp) != 1)
                fatal("fread ufmhdr");
        if (ufm.dwSize != ufmsize)
                error("Invalid ufmsize");
        if (ufm.loWidthTable != 0)
                error("loWidthTable != 0");
        fclose(fp);
}

static void getgtt(char *name)
{
        FILE            *fp;
        WORD            GID;
        DWORD           i;
        struct _stat    sb;
        GLYPHRUN        run;

        if (_stat(name, &sb) < 0)
                fatal(name);
        gttsize = sb.st_size;
        if ((fp = fopen(name, "rb")) == NULL)
                fatal(name);
        if (fread(&gtt, sizeof gtt, 1, fp) != 1)
                fatal(name);
        if (gtt.dwSize != gttsize)
                error("Invalid gttsize");

        runsize = gtt.dwRunCount * sizeof(GLYPHTABLE);
        if ((pGlyph = malloc(runsize)) == NULL)
                fatal("GLYPHTABLE");
        if (fseek(fp, gtt.loRunOffset, 0) < 0)
                fatal("loRunOffset");
        GID = 1;
        if (vflag) {
                printf("=== GTT ===\n");
                printf("Code\tCount\tGLYPHID\n");
                printf("---\t---\t---\n");
        }
        for (i = 0; i < gtt.dwRunCount; i++) {
                if (fread(&run, sizeof run, 1, fp) != 1)
                        fatal("GLYPHRUN");
                pGlyph[i].wCode = run.wcLow;
                pGlyph[i].wCount = run.wGlyphCount;
                pGlyph[i].wGID = GID;
                GID += run.wGlyphCount;
                if (vflag)
                        printf("0x%04x\t%d\t%ld\n", pGlyph[i].wCode,
                                pGlyph[i].wCount, pGlyph[i].wGID);
        }

        fclose(fp);
}

static WORD uni2gid(WORD code)
{
        DWORD           i;
        PGLYPHTABLE     p;

        for (i = 0, p = pGlyph; i < gtt.dwRunCount; i++, p++) {
                if (code >= p->wCode && code < p->wCode + p->wCount)
                        return p->wGID + (code - p->wCode);
        }
        return 0;
}

static void getdef(char *name)
{
        FILE            *fp;
        int             res;
        WORD            uni, width, count, v1, v2;
        WORD            GID, curGID;
        DWORD           i, j, line;
        PWORD           p;
        char            buf[80];

        if ((fp = fopen(name, "r")) == NULL)
                fatal(name);

        curGID = 0;
        nWidth = 0;
        count = 0;
        line = 0;
        while (fgets(rbuf, sizeof rbuf, fp)) {
                line++;
                if (!isxdigit(rbuf[0]))
                        continue;
                if ((res = sscanf(rbuf, "%x %d %d", &uni, &v1, &v2)) != 3) {
                        sprintf(buf, "sscanf=%d", res);
                        error(buf);
                }
                width = Vflag ? -v2 : v1;
                if ((GID = uni2gid(uni)) == 0) {
                        sprintf(buf, "Invalid code: %04x", uni);
                        error(buf);
                }
                if (GID <= curGID) {
                        sprintf(buf, "dup code: Line:%d: Uni=%d,GID=%d",
                                line, uni, GID);
                        error(buf);
                }
                if (curGID == 0 || GID != curGID + 1) {
                        if (pWidthRun == NULL) {
                                if ((pWidthRun = malloc(sizeof(*pWidthRun))) ==
                                        NULL)
                                        fatal("malloc pWidthRun");
                        } else {
                                pWidthRun[nWidthRun].wGlyphCount = count;
                                nWidthRun++;
                                if ((pWidthRun = realloc(pWidthRun,
                                        sizeof(*pWidthRun) * (nWidthRun + 1)))
                                        == NULL)
                                        fatal("realloc pWidthRun");
                        }
                        pWidthRun[nWidthRun].wStartGlyph = GID;
                        count = 0;
                }
                if (pWidth == NULL) {
                        if ((pWidth = malloc(sizeof(*pWidth))) == NULL)
                                fatal("malloc pWidth");
                } else {
                        if ((pWidth = realloc(pWidth, sizeof(*pWidth) *
                                (nWidth + 1))) == NULL)
                                fatal("realloc pWidth");
                }
                pWidth[nWidth] = width;
                nWidth++;
                count++;
                curGID = GID;
        }
        if (nWidth) {
                pWidthRun[nWidthRun].wGlyphCount = count;
                nWidthRun++;
        }

        if (vflag) {
                printf("\n=== WIDTHRUN ===\n");
                p = pWidth;
                for (i = 0; i < nWidthRun; i++) {
                        count = pWidthRun[i].wGlyphCount;
                        printf("Glyph=%-5d , Count=%-5d\n",
                                pWidthRun[i].wStartGlyph, count);
                        for (j = 0; j < count; j++)
                                printf("\tWidth[%5d]=%d\n", j, *p++);
                }
        }

        fclose(fp);
}

static void buildufm(char *name)
{
        FILE            *fp;
        DWORD           off, size;
        DWORD           i;
        PWIDTHRUN       pRun;

        if ((fp = fopen(name, "r+b")) == NULL)
                fatal(name);

        ufm.loWidthTable = off = ufmsize;
        if (fwrite(&ufm, sizeof ufm, 1, fp) != 1)
                fatal("fwrite ufmhdr");

        if (fseek(fp, ufm.loIFIMetrics, 0) < 0)
                fatal(name);
        if (fread(&IFI, sizeof IFI, 1, fp) != 1)
                fatal("fread IFIMETRICS");
        IFI.flInfo &= ~(FM_INFO_OPTICALLY_FIXED_PITCH|FM_INFO_DBCS_FIXED_PITCH);
        IFI.jWinPitchAndFamily |= VARIABLE_PITCH;
        IFI.jWinPitchAndFamily &= ~FIXED_PITCH;
        if (fseek(fp, ufm.loIFIMetrics, 0) < 0)
                fatal(name);
        if (fwrite(&IFI, sizeof IFI, 1, fp) != 1)
                fatal("fwrite IFIMETRICS");

        if (fseek(fp, off, 0) < 0)
                fatal(name);
        WidthTable.dwSize = sizeof(WidthTable) + sizeof(WIDTHRUN) *
                (nWidthRun - 1);
        WidthTable.dwRunNum = nWidthRun;
        size = sizeof(WidthTable) - sizeof(WIDTHRUN);
        if (fwrite(&WidthTable, size, 1, fp) != 1)
                fatal("fwrite WidthTable");
        off = WidthTable.dwSize;

        for (i = 0, pRun = pWidthRun; i < nWidthRun; i++, pRun++) {
                pRun->loCharWidthOffset = off;
                off += sizeof(*pWidth) * pRun->wGlyphCount;
        }
        if (fwrite(pWidthRun, sizeof(WIDTHRUN) * nWidthRun, 1, fp) != 1)
                fatal("fwrite WidthRun");
        if (fwrite(pWidth, sizeof(*pWidth) * nWidth, 1, fp) != 1)
                fatal("fwrite *pWidth");
}

void __cdecl main(int argc, char *argv[])
{
        argc--, argv++;
        for (; argc && **argv == '-'; argc--, argv++) switch (argv[0][1]) {
        case 'v':
                vflag++;
                break;
        case 'V':
                Vflag++;
                break;
        }
        if (argc != 3)
                usage();

        checkufm(argv[0]);
        getgtt(argv[1]);
        getdef(argv[2]);
        buildufm(argv[0]);

        exit(0);
}

static char     Usage[] = "Usage: %s [-v][-V] ufm-file gtt-file def-file\n";
static char     CmdName[] = "mkwidth";

static void usage()
{
        fprintf(stderr, Usage, CmdName);
        exit(1);
}

static void fatal(char *s)
{
        fprintf(stderr, "%s: ", CmdName);
        perror(s);
        exit(1);
}

static void error(char *s)
{
        fprintf(stderr, "%s: %s\n", CmdName, s);
        exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\prp\mkprpufm.c ===
/*
 *      mkwidth - Make WIDTHTABLE on ufm for Prop. DBCS device fonts.
 *
 *      TODO:
 *
 *      HISTORY:
 *
 *      9/4/98 yasuho           Created.
 */
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <prntfont.h>

typedef struct _GLYPHTABLE {
        WCHAR           wCode;
        WORD            wCount;
        WORD            wGID;
} GLYPHTABLE, *PGLYPHTABLE;

DWORD           ufmsize, gttsize;
DWORD           wtoffset;
DWORD           runsize;
PGLYPHTABLE     pGlyph;
UNIFM_HDR       ufm;
IFIMETRICS      IFI;
UNI_GLYPHSETDATA        gtt;
WIDTHTABLE      WidthTable;
PWIDTHRUN       pWidthRun;
DWORD           nWidthRun;
DWORD           loWidth;
PWORD           pWidth;
WORD            nWidth;

static int      vflag;
static int      Vflag;
static char     rbuf[256];

static void usage();
static void fatal(char *s);
static void error(char *s);

static void checkufm(char *name)
{
        FILE            *fp;
        struct _stat    sb;

        if (_stat(name, &sb) < 0)
                fatal(name);
        ufmsize = sb.st_size;
        if ((fp = fopen(name, "rb")) == NULL)
                fatal(name);
        if (fread(&ufm, sizeof ufm, 1, fp) != 1)
                fatal("fread ufmhdr");
        if (ufm.dwSize != ufmsize)
                error("Invalid ufmsize");
        if (ufm.loWidthTable != 0)
                error("loWidthTable != 0");
        fclose(fp);
}

static void getgtt(char *name)
{
        FILE            *fp;
        WORD            GID;
        DWORD           i;
        struct _stat    sb;
        GLYPHRUN        run;

        if (_stat(name, &sb) < 0)
                fatal(name);
        gttsize = sb.st_size;
        if ((fp = fopen(name, "rb")) == NULL)
                fatal(name);
        if (fread(&gtt, sizeof gtt, 1, fp) != 1)
                fatal(name);
        if (gtt.dwSize != gttsize)
                error("Invalid gttsize");

        runsize = gtt.dwRunCount * sizeof(GLYPHTABLE);
        if ((pGlyph = malloc(runsize)) == NULL)
                fatal("GLYPHTABLE");
        if (fseek(fp, gtt.loRunOffset, 0) < 0)
                fatal("loRunOffset");
        GID = 1;
        if (vflag) {
                printf("=== GTT ===\n");
                printf("Code\tCount\tGLYPHID\n");
                printf("---\t---\t---\n");
        }
        for (i = 0; i < gtt.dwRunCount; i++) {
                if (fread(&run, sizeof run, 1, fp) != 1)
                        fatal("GLYPHRUN");
                pGlyph[i].wCode = run.wcLow;
                pGlyph[i].wCount = run.wGlyphCount;
                pGlyph[i].wGID = GID;
                GID += run.wGlyphCount;
                if (vflag)
                        printf("0x%04x\t%d\t%ld\n", pGlyph[i].wCode,
                                pGlyph[i].wCount, pGlyph[i].wGID);
        }

        fclose(fp);
}

static WORD uni2gid(WORD code)
{
        DWORD           i;
        PGLYPHTABLE     p;

        for (i = 0, p = pGlyph; i < gtt.dwRunCount; i++, p++) {
                if (code >= p->wCode && code < p->wCode + p->wCount)
                        return p->wGID + (code - p->wCode);
        }
        return 0;
}

static void getdef(char *name)
{
        FILE            *fp;
        int             res;
        WORD            uni, width, count, v1, v2;
        WORD            GID, curGID;
        DWORD           i, j, line;
        PWORD           p;
        char            buf[80];

        if ((fp = fopen(name, "r")) == NULL)
                fatal(name);

        curGID = 0;
        nWidth = 0;
        count = 0;
        line = 0;
        while (fgets(rbuf, sizeof rbuf, fp)) {
                line++;
                if (!isxdigit(rbuf[0]))
                        continue;
                if ((res = sscanf(rbuf, "%x %d %d", &uni, &v1, &v2)) != 3) {
                        sprintf(buf, "sscanf=%d", res);
                        error(buf);
                }
                width = Vflag ? -v2 : v1;
                if ((GID = uni2gid(uni)) == 0) {
                        sprintf(buf, "Invalid code: %04x", uni);
                        error(buf);
                }
                if (GID <= curGID) {
                        sprintf(buf, "dup code: Line:%d: Uni=%d,GID=%d",
                                line, uni, GID);
                        error(buf);
                }
                if (curGID == 0 || GID != curGID + 1) {
                        if (pWidthRun == NULL) {
                                if ((pWidthRun = malloc(sizeof(*pWidthRun))) ==
                                        NULL)
                                        fatal("malloc pWidthRun");
                        } else {
                                pWidthRun[nWidthRun].wGlyphCount = count;
                                nWidthRun++;
                                if ((pWidthRun = realloc(pWidthRun,
                                        sizeof(*pWidthRun) * (nWidthRun + 1)))
                                        == NULL)
                                        fatal("realloc pWidthRun");
                        }
                        pWidthRun[nWidthRun].wStartGlyph = GID;
                        count = 0;
                }
                if (pWidth == NULL) {
                        if ((pWidth = malloc(sizeof(*pWidth))) == NULL)
                                fatal("malloc pWidth");
                } else {
                        if ((pWidth = realloc(pWidth, sizeof(*pWidth) *
                                (nWidth + 1))) == NULL)
                                fatal("realloc pWidth");
                }
                pWidth[nWidth] = width;
                nWidth++;
                count++;
                curGID = GID;
        }
        if (nWidth) {
                pWidthRun[nWidthRun].wGlyphCount = count;
                nWidthRun++;
        }

        if (vflag) {
                printf("\n=== WIDTHRUN ===\n");
                p = pWidth;
                for (i = 0; i < nWidthRun; i++) {
                        count = pWidthRun[i].wGlyphCount;
                        printf("Glyph=%-5d , Count=%-5d\n",
                                pWidthRun[i].wStartGlyph, count);
                        for (j = 0; j < count; j++)
                                printf("\tWidth[%5d]=%d\n", j, *p++);
                }
        }

        fclose(fp);
}

static void buildufm(char *name)
{
        FILE            *fp;
        DWORD           off, size;
        DWORD           i;
        PWIDTHRUN       pRun;

        if ((fp = fopen(name, "r+b")) == NULL)
                fatal(name);

#if 1 // v-masatk Oct/30/98
        ufm.loWidthTable = 0;
        off = ufmsize;
#else
        ufm.loWidthTable = off = ufmsize;
#endif // if 1 else end
        if (fwrite(&ufm, sizeof ufm, 1, fp) != 1)
                fatal("fwrite ufmhdr");

        if (fseek(fp, ufm.loIFIMetrics, 0) < 0)
                fatal(name);
        if (fread(&IFI, sizeof IFI, 1, fp) != 1)
                fatal("fread IFIMETRICS");
        IFI.flInfo &= ~(FM_INFO_OPTICALLY_FIXED_PITCH|FM_INFO_DBCS_FIXED_PITCH);
        IFI.jWinPitchAndFamily |= VARIABLE_PITCH;
        IFI.jWinPitchAndFamily &= ~FIXED_PITCH;
        if (fseek(fp, ufm.loIFIMetrics, 0) < 0)
                fatal(name);
        if (fwrite(&IFI, sizeof IFI, 1, fp) != 1)
                fatal("fwrite IFIMETRICS");
#if 0 // v-masatk Oct/30/98
        if (fseek(fp, off, 0) < 0)
                fatal(name);
        WidthTable.dwSize = sizeof(WidthTable) + sizeof(WIDTHRUN) *
                (nWidthRun - 1);
        WidthTable.dwRunNum = nWidthRun;
        size = sizeof(WidthTable) - sizeof(WIDTHRUN);
        if (fwrite(&WidthTable, size, 1, fp) != 1)
                fatal("fwrite WidthTable");
        off = WidthTable.dwSize;

        for (i = 0, pRun = pWidthRun; i < nWidthRun; i++, pRun++) {
                pRun->loCharWidthOffset = off;
                off += sizeof(*pWidth) * pRun->wGlyphCount;
        }
        if (fwrite(pWidthRun, sizeof(WIDTHRUN) * nWidthRun, 1, fp) != 1)
                fatal("fwrite WidthRun");
        if (fwrite(pWidth, sizeof(*pWidth) * nWidth, 1, fp) != 1)
                fatal("fwrite *pWidth");
#endif // if 0
}

void __cdecl main(int argc, char *argv[])
{
        argc--, argv++;
        for (; argc && **argv == '-'; argc--, argv++) switch (argv[0][1]) {
        case 'v':
                vflag++;
                break;
        case 'V':
                Vflag++;
                break;
        }
#if 0 // v-masatk Oct/30/98
        if (argc != 3)
                usage();

#endif // if 0
        checkufm(argv[0]);
#if 0 // v-masatk Oct/30/98
        getgtt(argv[1]);
        getdef(argv[2]);
#endif // if 0
        buildufm(argv[0]);

        exit(0);
}

static char     Usage[] = "Usage: %s [-v][-V] ufm-file gtt-file def-file\n";
static char     CmdName[] = "mkwidth";

static void usage()
{
        fprintf(stderr, Usage, CmdName);
        exit(1);
}

static void fatal(char *s)
{
        fprintf(stderr, "%s: ", CmdName);
        perror(s);
        exit(1);
}

static void error(char *s)
{
        fprintf(stderr, "%s: %s\n", CmdName, s);
        exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlres\prp\mkunitab.c ===
/*
 *      mkunitab - Convert JIS code to Unicode.
 *
 *      TODO:
 *
 *      HISTORY:
 *
 *      9/4/98 yasuho           Created.
 */
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>

#include <windef.h>
#include <winbase.h>
#include <winnls.h>

static char     buf[256];

static void mkunitab(char *name);
static void jis2sjis(BYTE jis[], BYTE sjis[]);
static void usage();
static void fatal(char *s);
static void error(char *s);

void __cdecl main(int argc, char *argv[])
{
        argc--, argv++;
        if (argc == 0)
                usage();
        while (argc--)
                mkunitab(*argv++);
        exit(0);
}

static void mkunitab(char *name)
{
        BYTE    jis[2];
        BYTE    sjis[4];
        WORD    v, n, len;
        INT     v1, v2;
        WCHAR   uni[2];
        FILE    *fp;

        if ((fp = fopen(name, "r")) == NULL)
                fatal(name);
        while (fgets(buf, sizeof buf, fp)) {
                len = strlen(buf);
                n = 0;
                while (isxdigit(buf[n]))
                        n++;
                if (n == 0)
                        continue;
                if (n != 2 && n != 4)
                        error("Invalid format");
                if (sscanf(buf, "%x %d %d", &v, &v1, &v2) != 3)
                        error("Invalid format");
                // SBCS Vertical font doesn't lying
                if (v <= 0xFF)
                        v2 = -v1;
                jis[0] = HIBYTE(v);
                jis[1] = LOBYTE(v);
                jis2sjis(jis, sjis);
                sjis[2] = 0;
                if (!MultiByteToWideChar(CP_ACP, 0, (const char *)sjis, 2,
                        uni, sizeof uni))
                        error("MultiByteToWideChar: fail");
                printf("%04x%8d%8d\n", uni[0], v1, v2);
        }
        fclose(fp);
}

static void jis2sjis(BYTE jis[], BYTE sjis[])
{
        BYTE            h, l;

        h = jis[0];
        l = jis[1];
        if (h == 0) {
                sjis[0] = l;
                sjis[1] = 0;
                return;
        }
        l += 0x1F;
        if (h & 0x01)
                h >>= 1;
        else {
                h >>= 1;
                l += 0x5E;
                h--;
        }
        if (l >= 0x7F)
                l++;
        if (h < 0x2F)
                h += 0x71;
        else
                h += 0xB1;
        sjis[0] = h;
        sjis[1] = l;
}

static void usage()
{
        fprintf(stderr, "Usage: mkunitab file[...]\n");
        exit(1);
}

static void fatal(char *s)
{
        fprintf(stderr, "mkunitab: ");
        perror(s);
        exit(1);
}

static void error(char *s)
{
        fprintf(stderr, "mkunitab: %s\n", s);
        exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlui\debug.c ===
#include <minidrv.h>

VOID DbgPrint(LPCSTR lpszMessage,  ...)
{
    char    szMsgBuf[1024];
    va_list VAList;

    if(NULL != lpszMessage)
    {
        // Dump string to debug output.
        va_start(VAList, lpszMessage);
        wvsprintfA(szMsgBuf, lpszMessage, VAList);
        OutputDebugStringA(szMsgBuf);
        va_end(VAList);
    }
    return;
} //*** DbgPrint


//////////////////////////////////////////////////////////////////////////
//  Function:   DebugMsgA
//
//  Description:  Outputs variable argument ANSI debug string.
//    
//
//  Parameters:
//
//      lpszMessage     Format string.
//
//
//  Returns:  TRUE on success and FALSE on failure.
//    
//
//  Comments:
//     
//
//  History:
//      12/18/96    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMsgA(LPCSTR lpszMessage, ...)
{
#if DBG || defined(_DEBUG)
    BOOL    bResult = FALSE;
    char    szMsgBuf[1024];
    va_list VAList;


    if(NULL != lpszMessage)
    {
        // Dump string to debug output.
        va_start(VAList, lpszMessage);
        wvsprintfA(szMsgBuf, lpszMessage, VAList);
        OutputDebugStringA(szMsgBuf);
        va_end(VAList);
        bResult = FALSE;
    }

    return bResult;
#else
    return TRUE;
#endif
} //*** DebugMsgA


//////////////////////////////////////////////////////////////////////////
//  Function:   DebugMsgW
//
//  Description:  Outputs variable argument UNICODE debug string.
//    
//
//  Parameters:
//
//      lpszMessage     Format string.
//
//
//  Returns:  TRUE on success and FALSE on failure.
//    
//
//  Comments:
//     
//
//  History:
//      12/18/96    APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMsgW(LPCWSTR lpszMessage, ...)
{
#if DBG || defined(_DEBUG)
    BOOL    bResult = FALSE;
    WCHAR   szMsgBuf[1024];
    va_list VAList;


    if(NULL != lpszMessage)
    {
        // Dump string to debug output.
        va_start(VAList, lpszMessage);
        wvsprintfW(szMsgBuf, lpszMessage, VAList);
        OutputDebugStringW(szMsgBuf);
        va_end(VAList);
        bResult = FALSE;
    }

    return bResult;
#else
    return TRUE;
#endif
} //*** DebugMsgW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlui\common.c ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           COMMON.C

Abstract:       Implementation of common functions for rendering & UI
                plugin module.

Functions:      OEMGetInfo
                OEMDevMode
                RWFileData
                safe_sprintfA
                safe_sprintfW

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/07/97 -zhanw-
        Created it.
    02/11/99 -Masatoshi Kubokura-
        Last modified for Windows2000.
    08/30/99 -Masatoshi Kubokura-
        Began to modify for NT4SP6(Unidrv5.4).
    09/27/99 -Masatoshi Kubokura-
        Last modified for NT4SP6.
    03/17/2000 -Masatoshi Kubokura-
        Eliminate "\\" from temp file name.
    05/22/2000 -Masatoshi Kubokura-
        V.1.03 for NT4
    09/22/2000 -Masatoshi Kubokura-
        Last modified for XP inbox.
    03/01/2002 -Masatoshi Kubokura-
        Include strsafe.h.
        Add FileNameBufSize as arg3 at RWFileData().
        Inplement safe_sprintfA/W().
    04/01/2002 -Masatoshi Kubokura-
        Use SecureZeroMemory() instead of memset(,0,)

--*/

#include "pdev.h"
#include "resource.h"
#ifndef WINNT_40
#include "strsafe.h"        // @Mar/01/2002
#endif // !WINNT_40

// shared data file between rendering and UI plugin
#ifndef WINNT_40
#define SHAREDFILENAME          L"RIMD5.BIN"        // eliminate "\\"  @Mar/15/2000
#else  // WINNT_40
#define SHAREDFILENAME          L"\\2\\RI%.4ls%02x.BIN" // %02x<-%02d  @Sep/21/99
DWORD gdwDrvMemPoolTag = 'meoD';    // minidrv.h requires this global var
#endif // WINNT_40

#if DBG && !defined(KM_DRIVER)
INT giDebugLevel = DBG_ERROR;
#endif

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
#if DBG
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMGetInfo
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
#if DBG
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));
#endif // DBG

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
} //*** OEMGetInfo


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDevMode
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMDevMode(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
#if DBG
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE((DLLTEXT("OEMDevMode(%s) entry.\n"), OEMDevMode_fMode[dwMode]));
#endif // DBG

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
#if DBG
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
#endif // DBG
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
#ifdef WINNT_40     // @Sep/20/99
        // Because NT4 spooler doesn't support collate, we clear dmCollate.
        // Later at OEMUICallBack, if printer collate is available, we set
        // dmCollate.
        pOEMDevModeParam->pPublicDMIn->dmCollate = DMCOLLATE_FALSE;
        pOEMDevModeParam->pPublicDMIn->dmFields &= ~DM_COLLATE;
#endif // WINNT_40
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
// @Jul/08/98 ->
//        // nothing to convert for this private devmode. So just initialize it.
//        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
// @Jul/08/98 <-
    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
} //*** OEMDevMode


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//  Parameters:
//      pOEMExtra    Pointer to a OEM Extra data.
//      dwSize       Size of OEM extra data.
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/97        APresley Created.
//          08/11/97        Masatoshi Kubokura Modified for RPDL
//
//////////////////////////////////////////////////////////////////////////
BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    INT num;

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    pOEMExtra->fUiOption = 0;
    pOEMExtra->UiScale = VAR_SCALING_DEFAULT;
    pOEMExtra->UiBarHeight = BAR_H_DEFAULT;
    pOEMExtra->UiBindMargin = DEFAULT_0;
    pOEMExtra->nUiTomboAdjX = pOEMExtra->nUiTomboAdjY = DEFAULT_0;  // add @Sep/14/98
// Use SecureZeroMemory  @Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
    memset(pOEMExtra->SharedFileName, 0, sizeof(pOEMExtra->SharedFileName));    // @Aug/31/99
#else
    SecureZeroMemory(pOEMExtra->SharedFileName, sizeof(pOEMExtra->SharedFileName));
#endif
// Mar/29/2002 <-
#ifdef JOBLOGSUPPORT_DM     // @Oct/05/2000
    pOEMExtra->JobType = IDC_RADIO_JOB_NORMAL;
    pOEMExtra->LogDisabled = IDC_RADIO_LOG_DISABLED;
#endif // JOBLOGSUPPORT_DM

    return TRUE;
} //*** BInitOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//  Parameters:
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//          08/11/97        Masatoshi Kubokura Modified for RPDL
//
//////////////////////////////////////////////////////////////////////////
BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut)
{
    if(pdmIn) {
        LPBYTE pDst = (LPBYTE)&(pdmOut->fUiOption);
        LPBYTE pSrc = (LPBYTE)&(pdmIn->fUiOption);
        DWORD  dwCount = sizeof(OEMUD_EXTRADATA) - sizeof(OEM_DMEXTRAHEADER);

        //
        // copy over the private fields, if they are valid
        //
        while (dwCount-- > 0)
            *pDst++ = *pSrc++;
    }

    return TRUE;
} //*** BMergeOEMExtraData


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
} //*** BIsValidOEMDevModeParam


#if DBG
//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//  Parameters:
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//  Returns:  N/A.
//
//  Comments:
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));
        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
} //*** VDumpOEMDevModeParam
#endif // DBG


//////////////////////////////////////////////////////////////////////////
//  Function:   RWFileData
//
//  Description:  Read/Write common file between UI plugin and rendering
//                plugin
//
//  Parameters:
//      pFileData           pointer to file data structure
//      pwszFileName        pointer to file name of private devmode
//      FileNameBufSize     file name buffer size (add 02/26/2002)
//      type                GENERIC_READ/GENERIC_WRITE
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//  Comments:  Rendering plugin records printing-done flag to the file.
//             Both rendering plugin and UI plugin can know that status.
//
//  History:
//              09/30/1998      Masatoshi Kubokura Created.
//              08/16/1999      takashim modified for Unidrv5.4 on NT4.
//              09/01/1999      Kubokura modified for Unidrv5.4 on NT4.
//              02/26/2002      Kubokura added FileNameBufSize param.
//
//////////////////////////////////////////////////////////////////////////
BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG FileNameBufSize, LONG type)
{
    HANDLE  hFile;
    DWORD   dwSize;
    BOOL    bRet = FALSE;
#ifndef KM_DRIVER
    WCHAR   szFileName[MY_MAX_PATH];    // MY_MAX_PATH=80
#endif // KM_DRIVER

    VERBOSE(("** Filename[0]=%d (%ls) **\n", pwszFileName[0], pwszFileName));

#ifndef KM_DRIVER
#ifndef WINNT_40
    //
    // CAUTION:
    //   TempPath is different whether EMF spool is enable(system) or not(user).
    //   We need to store the file name to private devmode.
    //

    // Set shared file name to private devmode at first time
    if (0 == pwszFileName[0])
    {
        if (0 == (dwSize = GetTempPath(MY_MAX_PATH, szFileName)))
        {
            ERR(("Could not get temp directory."));
            return bRet;
        }
// @Feb/26/2002 ->
//      wcscpy(&szFileName[dwSize], SHAREDFILENAME);
        StringCbCopyW(&szFileName[dwSize], sizeof(szFileName) - dwSize, SHAREDFILENAME);
// @Feb/26/2002 <-
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
// @Feb/26/2002 ->
//      wcscpy(pwszFileName, szFileName);
        StringCbCopyW(pwszFileName, FileNameBufSize, szFileName);
// @Feb/26/2002 <-
    }
#else  // WINNT_40
    //
    // CAUTION:
    //   The file path differs on each PC in printer sharing.
    //   We always update the file name (with path) of private devmode.
    //   (@Sep/03/99)
    //

    // Kernel-mode driver (NT4 RPDLRES.DLL) can access files under
    // %systemroot%\system32. Driver directory will be OK.
    if (GetPrinterDriverDirectory(NULL, NULL, 1, (PBYTE)szFileName,
                                  sizeof(szFileName), &dwSize))
    {
        WCHAR   szValue[MY_MAX_PATH] = L"XXXX";
        DWORD   dwSize2;
        DWORD   dwNum = 0;      // @Sep/21/99
        PWCHAR  pwszTmp;        // @Sep/21/99

        // Make unique filename "RIXXXXNN.BIN". "XXXX" is filled with top 4char of username.
        dwSize2 = GetEnvironmentVariable(L"USERNAME", szValue, MY_MAX_PATH);
// @Sep/21/99 ->
//        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], SHAREDFILENAME, szValue, dwSize2);
        pwszTmp = szValue;
        while (dwSize2-- > 0)
            dwNum += (DWORD)*pwszTmp++;
        wsprintf(&szFileName[dwSize/sizeof(WCHAR)-1], SHAREDFILENAME, szValue, (BYTE)dwNum);
// @Sep/21/99 <-
        VERBOSE(("** Set Filename: %ls **\n", szFileName));

        // copy file name to private devmode
        wcscpy(pwszFileName, szFileName);
    }
    else
    {
        ERR(("Could not get printer driver directory.(dwSize=%d)", dwSize));
        return bRet;
    }
#endif // WINNT_40

    hFile = CreateFile((LPTSTR) pwszFileName,   // filename
                       type,                    // open for read/write
                       FILE_SHARE_READ,         // share to read
                       NULL,                    // no security
                       OPEN_ALWAYS,             // open existing file,or open new if not exist
                       FILE_ATTRIBUTE_NORMAL,   // normal file
                       NULL);                   // no attr. template

    if (INVALID_HANDLE_VALUE == hFile)
    {
        ERR(("Could not create shared file."));
        return bRet;
    }

    if (GENERIC_WRITE == type)
        bRet = WriteFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);
    else if (GENERIC_READ == type)
        bRet = ReadFile(hFile, (PBYTE)pFileData, sizeof(FILEDATA), &dwSize, NULL);

    VERBOSE(("** RWFileData: bRet=%d, dwSize=%d**\n", bRet, dwSize));

    // Close files.
    CloseHandle(hFile);

#else  // KM_DRIVER
    if (0 != pwszFileName[0])
    {
        PBYTE   pTemp;

        if (GENERIC_WRITE == type)
        {
            hFile = DrvMapFileForWrite(pwszFileName, sizeof (FILEDATA),
                                       &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pTemp, pFileData, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
        else
        {
            hFile = DrvMapFileForRead(pwszFileName, &pTemp, &dwSize);
            if (NULL != hFile)
            {
                memcpy(pFileData, pTemp, sizeof (FILEDATA));
                DrvUnMapFile(hFile);
                bRet = TRUE;
            }
        }
    }
#endif // KM_DRIVER
    return bRet;
} //*** RWFileData


//////////////////////////////////////////////////////////////////////////
//  Function:   safe_sprintfA / safe_sprintfW
//
//  Description:  safer sprintf replacement.
//
//  History:
//              03/01/2002      Masatoshi Kubokura Created.
//
//////////////////////////////////////////////////////////////////////////
INT safe_sprintfA(char* pszDest, size_t cchDest, const char* pszFormat, ...)
{
#ifndef WINNT_40
    HRESULT hr;
    char*   pszDestEnd;
    size_t  cchRemaining;
#endif // !WINNT_40
    va_list argList;
    INT     retSize = 0;

    va_start(argList, pszFormat);
#ifndef WINNT_40
    hr = StringCchVPrintfExA(pszDest, cchDest, &pszDestEnd, &cchRemaining,
                             STRSAFE_NO_TRUNCATION, pszFormat, argList);
    if (SUCCEEDED(hr))
        retSize = cchDest - cchRemaining;
#else  // WINNT_40
    if ((retSize = vsprintf(pszDest, pszFormat, argList)) < 0)
        retSize = 0;
#endif // WINNT_40
    va_end(argList);
    return retSize;
} //*** safe_sprintfA


INT safe_sprintfW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszFormat, ...)
{
#ifndef WINNT_40
    HRESULT hr;
    wchar_t*   pszDestEnd;
    size_t  cchRemaining;
#endif // !WINNT_40
    va_list argList;
    INT     retSize = 0;

    va_start(argList, pszFormat);
#ifndef WINNT_40
    hr = StringCchVPrintfExW(pszDest, cchDest, &pszDestEnd, &cchRemaining,
                             STRSAFE_NO_TRUNCATION, pszFormat, argList);
    if (SUCCEEDED(hr))
        retSize = cchDest - cchRemaining;
#else  // WINNT_40
    if ((retSize = vswprintf(pszDest, pszFormat, argList)) < 0)
        retSize = 0;
#endif // WINNT_40
    va_end(argList);
    return retSize;
} //*** safe_sprintfW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlui\rpdldlg.cpp ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           RPDLDLG.CPP

Abstract:       Add OEM Page (FAX)

Functions:      FaxPageProc

Environment:    Windows NT Unidrv5 driver

Revision History:
    10/20/98 -Masatoshi Kubokura-
        Last modified for Windows2000.
    08/30/99 -Masatoshi Kubokura-
        Began to modify for NT4SP6(Unidrv5.4).
    09/02/99 -Masatoshi Kubokura-
        Last modified for NT4SP6.
    10/05/2000 -Masatoshi Kubokura-
        Last modified for XP inbox.
    03/04/2002 -Masatoshi Kubokura-
        Include strsafe.h.
        Use safe_sprintfW() instead of wsprintfW().
        Use OemToCharBuff() instead of OemToChar().
    04/01/2002 -Masatoshi Kubokura-
        Use safe_strlenW() instead of lstrlen().

--*/

#include "pdev.h"
#include "resource.h"
#include <prsht.h>
#ifndef WINNT_40
#include "strsafe.h"        // @Mar/01/2002
#endif // !WINNT_40

extern HINSTANCE ghInstance;    // MSKK 98/10/08

WORD wFaxResoStrID[3] = {
    IDS_RPDL_FAX_RESO_SUPER,
    IDS_RPDL_FAX_RESO_FINE,
    IDS_RPDL_FAX_RESO_COARSE
};

WORD wFaxChStrID[4] = {
    IDS_RPDL_FAX_CH_G3,
    IDS_RPDL_FAX_CH_G4,
    IDS_RPDL_FAX_CH_G3_1,
    IDS_RPDL_FAX_CH_G3_2
};
#define FAXCH_G4    1


extern "C" {
// External Functions' prototype
extern INT safe_sprintfW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszFormat, ...);
extern INT safe_strlenW(wchar_t* psz, size_t cchMax);

// Local Functions' prototype
INT_PTR APIENTRY FaxPageProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY FaxSubDialog(HWND, UINT, WPARAM, LPARAM);


/***************************************************************************
    Function Name : InitMainDlg
***************************************************************************/
VOID InitMainDlg(
HWND hDlg,
PUIDATA pUiData)
{
    // initialize check box (send fax, clear fax number after send)
    SendDlgItemMessage(hDlg, IDC_CHECK_SEND, BM_SETCHECK,
                       (WORD)TO1BIT(pUiData->fUiOption, FAX_SEND), 0);
    SendDlgItemMessage(hDlg, IDC_CHECK_CLRNUM, BM_SETCHECK,
                       BITTEST32(pUiData->fUiOption, HOLD_OPTIONS)? 0 : 1, 0);

    // initialize edit box
    SetDlgItemText(hDlg, IDC_EDIT_FAXNUM, pUiData->FaxNumBuf);
    SendDlgItemMessage(hDlg, IDC_EDIT_FAXNUM, EM_LIMITTEXT, FAXBUFSIZE256-1, 0);
    SetDlgItemText(hDlg, IDC_EDIT_EXTNUM, pUiData->FaxExtNumBuf);
    SendDlgItemMessage(hDlg, IDC_EDIT_EXTNUM, EM_LIMITTEXT, FAXEXTNUMBUFSIZE-1, 0);
} //*** InitMainDlg


/***************************************************************************
    Function Name : InitSubDlg
***************************************************************************/
VOID InitSubDlg(
HWND hDlg,
PUIDATA pUiData)
{
    WORD    num;
    WCHAR   wcTmp[64];

    // initialize edit box
    num = (pUiData->FaxSendTime[0] == 0)? FAXTIMEBUFSIZE : 0;
    SetDlgItemText(hDlg, IDC_EDIT_HOUR, pUiData->FaxSendTime);
    SendDlgItemMessage(hDlg, IDC_EDIT_HOUR, EM_LIMITTEXT, 2, 0);
    SetDlgItemText(hDlg, IDC_EDIT_MINUTE, &pUiData->FaxSendTime[3]);
    SendDlgItemMessage(hDlg, IDC_EDIT_MINUTE, EM_LIMITTEXT, 2, 0);
    // next while loop must be after SetDlgItemText(IDC_EDIT_xxx)
    while (num-- > 0)
        pUiData->FaxSendTime[num] = 0;

    // initialize combo box (FAX resolution, Send channel)
    SendDlgItemMessage(hDlg, IDC_COMBO_RESO, CB_RESETCONTENT, 0, 0);
    SendDlgItemMessage(hDlg, IDC_COMBO_CHANNEL, CB_RESETCONTENT, 0, 0);
    for (num = 0; num < 3; num++)
    {
        LoadString(ghInstance, wFaxResoStrID[num], wcTmp, 64);
        SendDlgItemMessage(hDlg, IDC_COMBO_RESO, CB_ADDSTRING, 0, (LPARAM)wcTmp);
    }
    for (num = 0; num < 4; num++)
    {
        LoadString(ghInstance, wFaxChStrID[num], wcTmp, 64);
        SendDlgItemMessage(hDlg, IDC_COMBO_CHANNEL, CB_ADDSTRING, 0, (LPARAM)wcTmp);
    }

    SendDlgItemMessage(hDlg, IDC_COMBO_RESO, CB_SETCURSEL, pUiData->FaxReso, 0);
    SendDlgItemMessage(hDlg, IDC_COMBO_CHANNEL, CB_SETCURSEL, pUiData->FaxCh, 0);

    // initialize check box (set time, set simultaneous print)
    if (BITTEST32(pUiData->fUiOption, FAX_SETTIME))
    {
        SendDlgItemMessage(hDlg, IDC_CHECK_TIME, BM_SETCHECK, 1, 0);
    }
    else
    {
        SendDlgItemMessage(hDlg, IDC_CHECK_TIME, BM_SETCHECK, 0, 0);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_HOUR), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_MINUTE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXSUB_HOUR), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXSUB_MINUTE), FALSE);
    }
    SendDlgItemMessage(hDlg, IDC_CHECK_PRINT, BM_SETCHECK,
                       (WORD)TO1BIT(pUiData->fUiOption, FAX_SIMULPRINT), 0);

    // initialize radio button (send RPDL command, use MH)
    CheckRadioButton(hDlg, IDC_RADIO_CMD_OFF, IDC_RADIO_CMD_ON,
                     BITTEST32(pUiData->fUiOption, FAX_RPDLCMD)?
                     IDC_RADIO_CMD_ON:IDC_RADIO_CMD_OFF);
    CheckRadioButton(hDlg, IDC_RADIO_MH_OFF, IDC_RADIO_MH_ON,
                     BITTEST32(pUiData->fUiOption, FAX_MH)?
                     IDC_RADIO_MH_ON:IDC_RADIO_MH_OFF);
} //*** InitSubDlg


/***************************************************************************
    Function Name : StoreSubDialogInfo
                    store option dialog infomation
***************************************************************************/
VOID StoreSubDialogInfo(
PUIDATA pUiData)
{
    WORD    num = FAXTIMEBUFSIZE;
    LPWSTR  lpDst = pUiData->FaxSendTimeTmp, lpSrc = pUiData->FaxSendTime;

    while (num-- > 0)
        *lpDst++ = *lpSrc++;
    pUiData->FaxResoTmp   = pUiData->FaxReso;
    pUiData->FaxChTmp     = pUiData->FaxCh;
    pUiData->fUiOptionTmp = pUiData->fUiOption;
} //*** StoreSubDialogInfo


/***************************************************************************
    Function Name : ResumeSubDialogInfo
                    resume option dialog infomation
***************************************************************************/
VOID ResumeSubDialogInfo(
PUIDATA pUiData)
{
    WORD    num = FAXTIMEBUFSIZE;
    LPWSTR  lpDst = pUiData->FaxSendTime, lpSrc = pUiData->FaxSendTimeTmp;

    while (num-- > 0)
        *lpDst++ = *lpSrc++;
    pUiData->FaxReso   = pUiData->FaxResoTmp;
    pUiData->FaxCh     = pUiData->FaxChTmp;
    pUiData->fUiOption = pUiData->fUiOptionTmp;
} //*** ResumeSubDialogInfo


/***************************************************************************
    Function Name : GetInfoFromOEMPdev
                    get fax data from private devmode
***************************************************************************/
VOID GetInfoFromOEMPdev(PUIDATA pUiData)
{
    POEMUD_EXTRADATA pOEMExtra = pUiData->pOEMExtra;
    BYTE TmpBuf[FAXTIMEBUFSIZE];

    // if previous fax is finished and hold-options flag isn't valid,
    // reset private devmode
    if (BITTEST32(pOEMExtra->fUiOption, PRINT_DONE) &&
        !BITTEST32(pOEMExtra->fUiOption, HOLD_OPTIONS))
    {
        WORD num;

        pOEMExtra->FaxReso = pOEMExtra->FaxCh = 0;
        for (num = 0; num < FAXBUFSIZE256; num++)
            pOEMExtra->FaxNumBuf[num] = 0;
        for (num = 0; num < FAXEXTNUMBUFSIZE; num++)
            pOEMExtra->FaxExtNumBuf[num] = 0;
        for (num = 0; num < FAXTIMEBUFSIZE; num++)
           pOEMExtra->FaxSendTime[num] = 0;
        BITCLR32(pOEMExtra->fUiOption, FAX_SEND);
        BITCLR32(pOEMExtra->fUiOption, FAX_SETTIME);
        BITCLR32(pOEMExtra->fUiOption, FAX_SIMULPRINT);
        BITCLR32(pOEMExtra->fUiOption, FAX_MH);
        BITCLR32(pOEMExtra->fUiOption, FAX_RPDLCMD);
        // do not clear PRINT_DONE flag here
    }

    // copy fax flag
    pUiData->fUiOption = pOEMExtra->fUiOption;

    // ascii to unicode
// @Mar/04/2002 ->
//    OemToChar((LPSTR)pOEMExtra->FaxNumBuf, pUiData->FaxNumBuf);
//    OemToChar((LPSTR)pOEMExtra->FaxExtNumBuf, pUiData->FaxExtNumBuf);
    OemToCharBuff((LPSTR)pOEMExtra->FaxNumBuf, pUiData->FaxNumBuf, FAXBUFSIZE256);
    OemToCharBuff((LPSTR)pOEMExtra->FaxExtNumBuf, pUiData->FaxExtNumBuf, FAXEXTNUMBUFSIZE);
// @Mar/04/2002 <-

    // modfify time string from "hhmm" to "hh"+"mm"
    TmpBuf[0] = pOEMExtra->FaxSendTime[0];
    TmpBuf[1] = pOEMExtra->FaxSendTime[1];
    TmpBuf[2] = TmpBuf[5] = 0;
    TmpBuf[3] = pOEMExtra->FaxSendTime[2];
    TmpBuf[4] = pOEMExtra->FaxSendTime[3];
// @Mar/04/2002 ->
//    OemToChar((LPSTR)&TmpBuf[0], &(pUiData->FaxSendTime[0]));
//    OemToChar((LPSTR)&TmpBuf[3], &(pUiData->FaxSendTime[3]));
    OemToCharBuff((LPSTR)&TmpBuf[0], &(pUiData->FaxSendTime[0]), FAXTIMEBUFSIZE);
    OemToCharBuff((LPSTR)&TmpBuf[3], &(pUiData->FaxSendTime[3]), FAXTIMEBUFSIZE - 3);
// @Mar/04/2002 <-

    pUiData->FaxReso = pOEMExtra->FaxReso;
    pUiData->FaxCh = pOEMExtra->FaxCh;
} //*** GetInfoFromOEMPdev


/***************************************************************************
    Function Name : SetInfoToOEMPdev
                    set fax data to private devmode
***************************************************************************/
VOID SetInfoToOEMPdev(PUIDATA pUiData)
{
    POEMUD_EXTRADATA pOEMExtra = pUiData->pOEMExtra;
    BYTE TmpBuf[FAXTIMEBUFSIZE];

    if (!BITTEST32(pUiData->fUiOption, FAXMAINDLG_UPDATED))
        return;

    // unicode to ascii
    CharToOem(pUiData->FaxNumBuf, (LPSTR)pOEMExtra->FaxNumBuf);
    CharToOem(pUiData->FaxExtNumBuf, (LPSTR)pOEMExtra->FaxExtNumBuf);

    // if only main dialog is changed
    if (!BITTEST32(pUiData->fUiOption, FAXSUBDLG_UPDATE_APPLIED))
    {
        // copy fax flag
        BITCPY32(pOEMExtra->fUiOption, pUiData->fUiOption, FAX_SEND);   // (dst, src, bit)
        BITCPY32(pOEMExtra->fUiOption, pUiData->fUiOption, HOLD_OPTIONS);
        BITCPY32(pOEMExtra->fUiOption, pUiData->fUiOption, PRINT_DONE); // @Sep/25/2001
    }
    // if sub dialog is also changed
    else
    {
        // copy fax flag
        pOEMExtra->fUiOption = pUiData->fUiOption;
        BITCLR32(pOEMExtra->fUiOption, FAXMAINDLG_UPDATED);
        BITCLR32(pOEMExtra->fUiOption, FAXSUBDLG_UPDATED);
        BITCLR32(pOEMExtra->fUiOption, FAXSUBDLG_UPDATE_APPLIED);
        BITCLR32(pOEMExtra->fUiOption, FAXSUBDLG_INITDONE);

        // modfify time string from "hh"+"mm" to "hhmm"
        CharToOem(&(pUiData->FaxSendTime[0]), (LPSTR)&TmpBuf[0]);
        CharToOem(&(pUiData->FaxSendTime[3]), (LPSTR)&TmpBuf[3]);
        //   hour
        if (TmpBuf[1] == 0)         // 1 number
        {
            pOEMExtra->FaxSendTime[0] = '0';
            pOEMExtra->FaxSendTime[1] = TmpBuf[0];
        }
        else
        {
            pOEMExtra->FaxSendTime[0] = TmpBuf[0];
            pOEMExtra->FaxSendTime[1] = TmpBuf[1];
        }
        //   minute
        if (TmpBuf[3] == 0)         // nothing set
        {
            pOEMExtra->FaxSendTime[2] = pOEMExtra->FaxSendTime[3] = '0';
        }
        else if (TmpBuf[4] == 0)    // 1 number
        {
            pOEMExtra->FaxSendTime[2] = '0';
            pOEMExtra->FaxSendTime[3] = TmpBuf[3];
        }
        else
        {
            pOEMExtra->FaxSendTime[2] = TmpBuf[3];
            pOEMExtra->FaxSendTime[3] = TmpBuf[4];
        }
        pOEMExtra->FaxSendTime[4] = 0;

        pOEMExtra->FaxReso = pUiData->FaxReso;
        pOEMExtra->FaxCh = pUiData->FaxCh;
    }
    return;
} //*** SetInfoToOEMPdev


/***************************************************************************
    Function Name : FaxPageProc

    Parameters    : HWND    hDlg            Handle of this Dialog
                    UINT    uMessage
                    WPARAM  wParam
                    LPARAM  lParam

    Modify Note   : Make this for Win95 minidriver.     Jun/05/96 Kubokura
                    Modify.                             Sep/22/98 Kubokura
***************************************************************************/
INT_PTR APIENTRY FaxPageProc(
HWND hDlg,
UINT uMessage,
WPARAM wParam,
LPARAM lParam)
{
    PUIDATA pUiData;
    WORD    fModified = FALSE;

    switch (uMessage)
    {
      case WM_INITDIALOG:
        pUiData = (PUIDATA)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pUiData);

        // get fax data from private devmode
        GetInfoFromOEMPdev(pUiData);

        InitMainDlg(hDlg, pUiData);
        BITCLR32(pUiData->fUiOption, FAXMAINDLG_UPDATED);
        BITCLR32(pUiData->fUiOption, FAXSUBDLG_UPDATE_APPLIED); // @Oct/02/98
        BITCLR32(pUiData->fUiOption, FAXSUBDLG_INITDONE);       // @Sep/29/98
#ifdef WINNT_40     // @Sep/02/99
        // Disable FAX tab options when user has no permission.
        if (BITTEST32(pUiData->fUiOption, UIPLUGIN_NOPERMISSION))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXMAIN_1), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXMAIN_2), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXMAIN_3), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXMAIN_4), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_SEND), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_FAXNUM), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_EXTNUM), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_OPTION), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_FAXMAIN_DEFAULT), FALSE);
// @Sep/21/2001 ->
//          EnableWindow(GetDlgItem(hDlg, IDC_LABEL_CLRNUM), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_CLRNUM), FALSE);
// @Sep/21/2001 <-
        }
#endif // WINNT_40
        break;

      case WM_COMMAND:
        pUiData = (PUIDATA)GetWindowLongPtr(hDlg, DWLP_USER);
        switch(LOWORD(wParam))
        {
          case IDC_CHECK_SEND:
            if (BITTEST32(pUiData->fUiOption, FAX_SEND))
                BITCLR32(pUiData->fUiOption, FAX_SEND);
            else
                BITSET32(pUiData->fUiOption, FAX_SEND);
            SendDlgItemMessage(hDlg, IDC_CHECK_SEND, BM_SETCHECK,
                               (WORD)TO1BIT(pUiData->fUiOption, FAX_SEND), 0);
            fModified = TRUE;
            break;

          case IDC_CHECK_CLRNUM:
            if (BITTEST32(pUiData->fUiOption, HOLD_OPTIONS))
                BITCLR32(pUiData->fUiOption, HOLD_OPTIONS);
            else
                BITSET32(pUiData->fUiOption, HOLD_OPTIONS);
            SendDlgItemMessage(hDlg, IDC_CHECK_CLRNUM, BM_SETCHECK,
                               BITTEST32(pUiData->fUiOption, HOLD_OPTIONS)? 0 : 1, 0);
            fModified = TRUE;
            break;

          case IDC_EDIT_FAXNUM:
            {
                int old_len = safe_strlenW(pUiData->FaxNumBuf, FAXBUFSIZE256);

                GetDlgItemText(hDlg, IDC_EDIT_FAXNUM, pUiData->FaxNumBuf,
                               FAXBUFSIZE256);
                if (old_len != safe_strlenW(pUiData->FaxNumBuf, FAXBUFSIZE256))
                    fModified = TRUE;
            }
            break;

          case IDC_EDIT_EXTNUM:
            {
                int old_len = safe_strlenW(pUiData->FaxExtNumBuf, FAXEXTNUMBUFSIZE);

                GetDlgItemText(hDlg, IDC_EDIT_EXTNUM, pUiData->FaxExtNumBuf,
                               FAXEXTNUMBUFSIZE);
                if (old_len != safe_strlenW(pUiData->FaxExtNumBuf, FAXEXTNUMBUFSIZE))
                    fModified = TRUE;
            }
            break;

          // set option button
          case IDD_OPTION:
            if(ghInstance)
            {
                //DLGPROC lpDlgFunc = (DLGPROC)MakeProcInstance(FaxSubDialog, ghInstance);  // add (DLGPROC) @Aug/30/99

                DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_FAXSUB),
                               hDlg, FaxSubDialog, (LPARAM)pUiData);
                //               hDlg, lpDlgFunc, (LPARAM)pUiData);
                //FreeProcInstance(lpDlgFunc);
                fModified = TRUE;
            }
            break;

          // set defaults button
          case IDD_FAXMAIN_DEFAULT:
            pUiData->FaxNumBuf[0]    =
            pUiData->FaxExtNumBuf[0] = 0;
            BITCLR32(pUiData->fUiOption, FAX_SEND);
            SendDlgItemMessage(hDlg, IDC_CHECK_SEND, BM_SETCHECK,
                               (WORD)TO1BIT(pUiData->fUiOption, FAX_SEND), 0);
            BITCLR32(pUiData->fUiOption, HOLD_OPTIONS);
            SendDlgItemMessage(hDlg, IDC_CHECK_CLRNUM, BM_SETCHECK,
                               BITTEST32(pUiData->fUiOption, HOLD_OPTIONS)? 0 : 1, 0);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_FAXNUM), TRUE);
            SetDlgItemText(hDlg, IDC_EDIT_FAXNUM, pUiData->FaxNumBuf);
            SetDlgItemText(hDlg, IDC_EDIT_EXTNUM, pUiData->FaxExtNumBuf);
            fModified = TRUE;
            break;

          default:
            return FALSE;
        }
        break;

      case WM_NOTIFY:
        pUiData = (PUIDATA)GetWindowLongPtr(hDlg, DWLP_USER);
        {
            NMHDR FAR *lpnmhdr = (NMHDR FAR *)lParam;

            switch (lpnmhdr->code)
            {
                WORD    num;

              case PSN_SETACTIVE:
                break;

              // In case of PSN_KILLACTIVE, return FALSE to get PSN_APPLY.
              case PSN_KILLACTIVE:  // this is when user pushs OK/APPLY button.(1)
                VERBOSE((DLLTEXT("** FaxPageProc: PSN_KILLACTIVE **\n")));
                BITSET32(pUiData->fUiOption, FAXMAINDLG_UPDATED);       // @Sep/29/98
                if (BITTEST32(pUiData->fUiOption, FAXSUBDLG_UPDATED))   // @Oct/02/98
                    BITSET32(pUiData->fUiOption, FAXSUBDLG_UPDATE_APPLIED);
                return FALSE;

              case PSN_APPLY:       // this is when user pushs OK/APPLY button.(2)
                VERBOSE((DLLTEXT("** FaxPageProc: PSN_APPLY **\n")));
                // clear PRINT_DONE flag of private devmode  @Oct/20/98
                if (BITTEST32(pUiData->fUiOption, PRINT_DONE))  // eliminate mid pOEMExtra->  @Sep/22/2000
                {
                    BITCLR32(pUiData->fUiOption, PRINT_DONE);   // eliminate mid pOEMExtra->  @Sep/22/2000
                    VERBOSE(("** Delete file: %ls **\n", pUiData->pOEMExtra->SharedFileName));
                    DeleteFile(pUiData->pOEMExtra->SharedFileName);
                }

                // set shared data to private devmode  @Oct/15/98
                SetInfoToOEMPdev(pUiData);

                // update private devmode           @Oct/15/98
                pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                         CPSFUNC_SET_RESULT,
                                         (LPARAM)pUiData->hPropPage,
                                         (LPARAM)CPSUI_OK);
                VERBOSE((DLLTEXT("** PSN_APPLY fUiOption=%x **\n"), pUiData->fUiOption));
                break;

              case PSN_RESET:       // this is when user pushs CANCEL button
                VERBOSE((DLLTEXT("** FaxPageProc: PSN_RESET **\n")));
                break;
            }
        }
        break;

      default:
        return FALSE;
    }

    // activate APPLY button
    if (fModified)
        PropSheet_Changed(GetParent(hDlg), hDlg);
    return TRUE;
} //*** FaxPageProc


/***************************************************************************
    Function Name : FaxSubDialog

    Parameters    : HWND    hDlg            Handle of this Dialog
                    UINT    uMessage
                    WPARAM  wParam
                    LPARAM  lParam

    Modify Note   : Make this for Win95 minidriver.     Jun/05/96 Kubokura
                    Modify.                             Sep/22/98 Kubokura
***************************************************************************/
INT_PTR APIENTRY FaxSubDialog(
HWND hDlg,
UINT uMessage,
WPARAM wParam,
LPARAM lParam)
{
    PUIDATA pUiData;

    switch (uMessage)
    {
      case WM_INITDIALOG:
        pUiData = (PUIDATA)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pUiData);

        // if right after opening this dialog
        if (!BITTEST32(pUiData->fUiOption, FAXSUBDLG_INITDONE))
        {
            BITSET32(pUiData->fUiOption, FAXSUBDLG_INITDONE);
            StoreSubDialogInfo(pUiData);
        }
        else
        {
            ResumeSubDialogInfo(pUiData);
        }
        InitSubDlg(hDlg, pUiData);
        BITCLR32(pUiData->fUiOption, FAXSUBDLG_UPDATED);
        break;

      case WM_COMMAND:
        pUiData = (PUIDATA)GetWindowLongPtr(hDlg, DWLP_USER);
        switch(LOWORD(wParam))
        {
            WORD    num;

          case IDC_CHECK_TIME:
            if (BITTEST32(pUiData->fUiOption, FAX_SETTIME))
            {
                BITCLR32(pUiData->fUiOption, FAX_SETTIME);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_HOUR), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_MINUTE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXSUB_HOUR), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXSUB_MINUTE), FALSE);
            }
            else
            {
                BITSET32(pUiData->fUiOption, FAX_SETTIME);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_HOUR), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_MINUTE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXSUB_HOUR), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXSUB_MINUTE), TRUE);
            }
            SendDlgItemMessage(hDlg, IDC_CHECK_TIME, BM_SETCHECK,
                               (WORD)TO1BIT(pUiData->fUiOption, FAX_SETTIME), 0);
            break;

          case IDC_CHECK_PRINT:
            if (BITTEST32(pUiData->fUiOption, FAX_SIMULPRINT))
                BITCLR32(pUiData->fUiOption, FAX_SIMULPRINT);
            else
                BITSET32(pUiData->fUiOption, FAX_SIMULPRINT);
            SendDlgItemMessage(hDlg, IDC_CHECK_PRINT, BM_SETCHECK,
                               (WORD)TO1BIT(pUiData->fUiOption, FAX_SIMULPRINT), 0);
            break;

          case IDC_EDIT_HOUR:
            {
                INT hour;

                // get hour of send time
                GetDlgItemText(hDlg, IDC_EDIT_HOUR, pUiData->FaxSendTime, 3);
                if ((hour = _wtoi(&pUiData->FaxSendTime[0])) < 10)
                    safe_sprintfW(&pUiData->FaxSendTime[0], FAXTIMEBUFSIZE, L"0%d", hour);
                else if (hour > 23)
                    safe_sprintfW(&pUiData->FaxSendTime[0], FAXTIMEBUFSIZE, L"23");
            }
            break;

          case IDC_EDIT_MINUTE:
            {
                INT minute;

                // get minute of send time
                GetDlgItemText(hDlg, IDC_EDIT_MINUTE, &pUiData->FaxSendTime[3], 3);
                if ((minute = _wtoi(&pUiData->FaxSendTime[3])) < 10)
                    safe_sprintfW(&pUiData->FaxSendTime[3], FAXTIMEBUFSIZE, L"0%d", minute);
                else if (minute > 59)
                    safe_sprintfW(&pUiData->FaxSendTime[3], FAXTIMEBUFSIZE, L"59");
            }
            break;

          case IDC_COMBO_RESO:
            if (HIWORD(wParam) == CBN_SELCHANGE)
                pUiData->FaxReso = (WORD)SendDlgItemMessage(hDlg, IDC_COMBO_RESO,
                                                            CB_GETCURSEL, 0, 0);
            break;

          case IDC_COMBO_CHANNEL:
            if (HIWORD(wParam) == CBN_SELCHANGE)
                pUiData->FaxCh = (WORD)SendDlgItemMessage(hDlg, IDC_COMBO_CHANNEL,
                                                          CB_GETCURSEL, 0, 0);
            // if channel is G4, disable send RPDL mode
            if (pUiData->FaxCh == FAXCH_G4)
            {
                BITCLR32(pUiData->fUiOption, FAX_RPDLCMD);
                CheckRadioButton(hDlg, IDC_RADIO_CMD_OFF, IDC_RADIO_CMD_ON,
                                 IDC_RADIO_CMD_OFF);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CMD_OFF), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CMD_ON), FALSE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CMD_OFF), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CMD_ON), TRUE);
            }
            break;

          case IDC_RADIO_CMD_OFF:
            BITCLR32(pUiData->fUiOption, FAX_RPDLCMD);
            CheckRadioButton(hDlg, IDC_RADIO_CMD_OFF, IDC_RADIO_CMD_ON,
                             IDC_RADIO_CMD_OFF);
            break;

          case IDC_RADIO_CMD_ON:
            BITSET32(pUiData->fUiOption, FAX_RPDLCMD);
            CheckRadioButton(hDlg, IDC_RADIO_CMD_OFF, IDC_RADIO_CMD_ON,
                             IDC_RADIO_CMD_ON);
            break;

          case IDC_RADIO_MH_OFF:
            BITCLR32(pUiData->fUiOption, FAX_MH);
            CheckRadioButton(hDlg, IDC_RADIO_MH_OFF, IDC_RADIO_MH_ON,
                             IDC_RADIO_MH_OFF);
            break;

          case IDC_RADIO_MH_ON:
            BITSET32(pUiData->fUiOption, FAX_MH);
            CheckRadioButton(hDlg, IDC_RADIO_MH_OFF, IDC_RADIO_MH_ON,
                             IDC_RADIO_MH_ON);
            break;

          // set defaults button
          case IDD_FAXSUB_DEFAULT:
            pUiData->FaxReso = pUiData->FaxCh = 0;
            BITCLR32(pUiData->fUiOption, FAX_SETTIME);
            BITCLR32(pUiData->fUiOption, FAX_SIMULPRINT);
            BITCLR32(pUiData->fUiOption, FAX_MH);
            BITCLR32(pUiData->fUiOption, FAX_RPDLCMD);

            SendDlgItemMessage(hDlg, IDC_CHECK_TIME, BM_SETCHECK,
                               (WORD)TO1BIT(pUiData->fUiOption, FAX_SETTIME), 0);
            SendDlgItemMessage(hDlg, IDC_CHECK_PRINT, BM_SETCHECK,
                               (WORD)TO1BIT(pUiData->fUiOption, FAX_SIMULPRINT), 0);
            SetDlgItemText(hDlg, IDC_EDIT_HOUR, NULL);
            SetDlgItemText(hDlg, IDC_EDIT_MINUTE, NULL);
            // next for loop must be after SetDlgItemText(IDC_EDIT_xxx)
            for (num = 0; num < FAXTIMEBUFSIZE; num++)
               pUiData->FaxSendTime[num] = 0;
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_HOUR), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_MINUTE), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXSUB_HOUR), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_LABEL_FAXSUB_MINUTE), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CMD_OFF), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CMD_ON), TRUE);
            SendDlgItemMessage(hDlg, IDC_COMBO_RESO, CB_SETCURSEL,
                               pUiData->FaxReso, 0);
            SendDlgItemMessage(hDlg, IDC_COMBO_CHANNEL, CB_SETCURSEL,
                               pUiData->FaxCh, 0);
            CheckRadioButton(hDlg, IDC_RADIO_CMD_OFF, IDC_RADIO_CMD_ON,
                             BITTEST32(pUiData->fUiOption, FAX_RPDLCMD)?
                             IDC_RADIO_CMD_ON:IDC_RADIO_CMD_OFF);
            CheckRadioButton(hDlg, IDC_RADIO_MH_OFF, IDC_RADIO_MH_ON,
                             BITTEST32(pUiData->fUiOption, FAX_MH)?
                             IDC_RADIO_MH_ON:IDC_RADIO_MH_OFF);
            break;

          case IDCANCEL:
            ResumeSubDialogInfo(pUiData);
            goto _OPT_END;
          case IDOK:
            StoreSubDialogInfo(pUiData);
            BITSET32(pUiData->fUiOption, FAXSUBDLG_UPDATED);
          _OPT_END:
            EndDialog(hDlg, wParam);
            break;

          default:
            return FALSE;
        }
        break;

      default:
        return FALSE;
    }
    return TRUE;
} //*** FaxSubDialog

} // End of extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlui\comoem.cpp ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           COMOEM.CPP

Abstract:       Necessary COM class definition to Unidrv OEM UI plugin module.

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/24/1998 -takashim-
        Written the original sample so that it is more C++.
    04/22/1999 -Masatoshi Kubokura-
        Last modified for Windows2000.
    10/05/2000 -Masatoshi Kubokura-
        Last modified for XP inbox.
    03/01/2002 -Masatoshi Kubokura-
        Include strsafe.h.
    03/29/2002 -Masatoshi Kubokura-
        Eliminate "#if 0".
        Change return value from E_FAIL to S_FALSE at DllCanUnloadNow().

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"
#ifndef WINNT_40
#include "strsafe.h"        // @Mar/01/2002
#endif // !WINNT_40

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUI
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
// @Mar/29/2002 ->
        if (NULL == ppv)
            return E_FAIL;
// @Mar/29/2002 <-
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n")));
        }
        else if (iid == IID_IPrintOemUI)
        {
            *ppv = static_cast<IPrintOemUI*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUI.\n")));
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n")));
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam)
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //


    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
        return S_OK;
    }

    //
    // CommonUIProp
    //

    STDMETHODIMP
    CommonUIProp(
        DWORD  dwMode,
        POEMCUIPPARAM   pOemCUIPParam)
    {
        if (OEMCommonUIProp(dwMode, pOemCUIPParam))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // DocumentPropertySheets
    //

    STDMETHODIMP
    DocumentPropertySheets(
        PPROPSHEETUI_INFO   pPSUIInfo,
        LPARAM              lParam)
    {
// @Oct/05/2000 ->
#if !defined(GWMODEL) || defined(JOBLOGSUPPORT_DLG)
        if (OEMDocumentPropertySheets(pPSUIInfo, lParam))
            return S_OK;
        else
            return E_FAIL;
#else  // !(defined(GWMODEL) || defined(JOBLOGSUPPORT_DLG))
        return E_NOTIMPL;
#endif // !(defined(GWMODEL) || defined(JOBLOGSUPPORT_DLG))
// @Oct/05/2000 <-
    }

    //
    // DevicePropertySheets
    //

    STDMETHODIMP
    DevicePropertySheets(
        PPROPSHEETUI_INFO   pPSUIInfo,
        LPARAM              lParam)
    {
        return E_NOTIMPL;
    }

    //
    // DevQueryPrintEx
    //

    STDMETHODIMP
    DevQueryPrintEx(
        POEMUIOBJ               poemuiobj,
        PDEVQUERYPRINT_INFO     pDQPInfo,
        PDEVMODE                pPublicDM,
        PVOID                   pOEMDM)
    {
        return E_NOTIMPL;
    }

    //
    // DeviceCapabilities
    //

    STDMETHODIMP
    DeviceCapabilities(
        POEMUIOBJ   poemuiobj,
        HANDLE      hPrinter,
        PWSTR       pDeviceName,
        WORD        wCapability,
        PVOID       pOutput,
        PDEVMODE    pPublicDM,
        PVOID       pOEMDM,
        DWORD       dwOld,
        DWORD       *dwResult)
    {
        return E_NOTIMPL;
    }

    //
    // UpgradePrinter
    //

    STDMETHODIMP
    UpgradePrinter(
        DWORD   dwLevel,
        PBYTE   pDriverUpgradeInfo)
    {
        return E_NOTIMPL;
    }

    //
    // PrinterEvent
    //

    STDMETHODIMP
    PrinterEvent(
        PWSTR   pPrinterName,
        INT     iDriverEvent,
        DWORD   dwFlags,
        LPARAM  lParam)
    {
        return E_NOTIMPL;
    }

    //
    // DriverEvent
    //

    STDMETHODIMP
    DriverEvent(
        DWORD   dwDriverEvent,
        DWORD   dwLevel,
        LPBYTE  pDriverInfo,
        LPARAM  lParam)
    {
        return E_NOTIMPL;
    }

    //
    // QueryColorProfile
    //

    STDMETHODIMP
    QueryColorProfile(
        HANDLE      hPrinter,
        POEMUIOBJ   poemuiobj,
        PDEVMODE    pPublicDM,
        PVOID       pOEMDM,
        ULONG       ulReserved,
        VOID       *pvProfileData,
        ULONG      *pcbProfileData,
        FLONG      *pflProfileData)
    {
        return E_NOTIMPL;
    }

    //
    // FontInstallerDlgProc
    //

    STDMETHODIMP
    FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
// @Apr/22/99 ->
//      WORD    wParam,
        WPARAM  wParam,
// @Apr/22/99 <-
        LPARAM  lParam)
    {
        return E_NOTIMPL;
    }

    //
    // UpdateExternalFonts
    //

    STDMETHODIMP
    UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
    {
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUI* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
            InterlockedIncrement(&g_cServerLocks);
        else
            InterlockedDecrement(&g_cServerLocks);
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
        return S_OK;
// @Mar/29/2002 (MS)
//     else
//         return E_FAIL;
    else
        return S_FALSE;
// @Mar/29/2002
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlui\rpdldlg2.cpp ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           RPDLDLG2.CPP (from RIAFUI.CPP)

Abstract:       Add OEM Page (Job/Log)

Functions:      JobPageProc

Environment:    Windows NT Unidrv5 driver

Revision History:
    09/22/2000 -Masatoshi Kubokura-
        Began to modify from RIAFUI code.
    11/29/2000 -Masatoshi Kubokura-
        Last modified for XP inbox.
    03/04/2002 -Masatoshi Kubokura-
        Include strsafe.h.
        Use OemToCharBuff() instead of OemToChar().
    03/27/2002 -Masatoshi Kubokura-
        Eliminate "#if 0".
    03/29/2002 -Masatoshi Kubokura-
        Use SecureZeroMemory() instead of memset(,0,)
    04/01/2002 -Masatoshi Kubokura-
        Use safe_strlenW() instead of lstrlen().

--*/


#include "pdev.h"
#include "resource.h"
//#include <minidrv.h>
//#include "devmode.h"
//#include "oem.h"
//#include "resource.h"
#include <prsht.h>
#include <mbstring.h>   // _ismbcdigit, _ismbcalnum
#ifndef WINNT_40
#include "strsafe.h"        // @Mar/01/2002
#endif // !WINNT_40

// Externals
extern HINSTANCE ghInstance;


extern "C" {
// External Functions' prototype
extern INT safe_strlenW(wchar_t* psz, size_t cchMax);

// Local Functions' prototype
INT_PTR CALLBACK JobPageProc(HWND, UINT, WPARAM, LPARAM);

/***************************************************************************
    Function Name : InitMainDlg
***************************************************************************/
VOID InitMainDlg(
HWND hDlg,
PUIDATA pUiData)
{
    // initialize edit box
    SetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERID, pUiData->UserIdBuf);
    SendDlgItemMessage(hDlg, IDC_EDIT_JOBMAIN_USERID, EM_LIMITTEXT, USERID_LEN, 0);
    SetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_PASSWORD, pUiData->PasswordBuf);
    SendDlgItemMessage(hDlg, IDC_EDIT_JOBMAIN_PASSWORD, EM_LIMITTEXT, PASSWORD_LEN, 0);
    SetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERCODE, pUiData->UserCodeBuf);
    SendDlgItemMessage(hDlg, IDC_EDIT_JOBMAIN_USERCODE, EM_LIMITTEXT, USERCODE_LEN, 0);

    // initialize radio button
    CheckRadioButton(hDlg, IDC_RADIO_JOB_NORMAL, IDC_RADIO_JOB_SECURE, pUiData->JobType);
    CheckRadioButton(hDlg, IDC_RADIO_LOG_DISABLED, IDC_RADIO_LOG_ENABLED, pUiData->LogDisabled);

    // initialize check box
    SendDlgItemMessage(hDlg, IDC_CHECK_JOB_DEFAULT, BM_SETCHECK,
                       (BITTEST32(pUiData->fUiOption, HOLD_OPTIONS)? 0 : 1), 0);

    if (1 <= safe_strlenW(pUiData->UserIdBuf, sizeof(pUiData->UserIdBuf)))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), FALSE);
    }
    if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
    }
    if (IDC_RADIO_LOG_ENABLED == pUiData->LogDisabled)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), FALSE);
    }

#ifdef WINNT_40
    // Disable tab options when user has no permission.
    if (BITTEST32(pUiData->fUiOption, UIPLUGIN_NOPERMISSION))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERID), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERID2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERID3), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_JOB), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_LOG), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERID), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_NORMAL), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_LOG_DISABLED), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_LOG_ENABLED), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), FALSE);
    }
#endif // WINNT_40
} //*** InitMainDlg


/***************************************************************************
    Function Name : GetInfoFromOEMPdev
                    get data from private devmode
***************************************************************************/
VOID GetInfoFromOEMPdev(PUIDATA pUiData)
{
    POEMUD_EXTRADATA pOEMExtra = pUiData->pOEMExtra;

    VERBOSE((DLLTEXT("GetInfoFromOEMPdev: print done?(%d)\n"),
            BITTEST32(pOEMExtra->fUiOption, PRINT_DONE)));
    // if previous printing is finished and reset-options flag is valid,
    // reset job setting.
    if (BITTEST32(pOEMExtra->fUiOption, PRINT_DONE) &&
        !BITTEST32(pOEMExtra->fUiOption, HOLD_OPTIONS))
    {
        pUiData->JobType = IDC_RADIO_JOB_NORMAL;
// Use SecureZeroMemory  @Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
        memset(pUiData->PasswordBuf, 0, sizeof(pUiData->PasswordBuf));
#else
        SecureZeroMemory(pUiData->PasswordBuf, sizeof(pUiData->PasswordBuf));
#endif
// @Mar/29/2002 <-
        // do not clear PRINT_DONE flag here
    }
    else
    {
        pUiData->JobType = pOEMExtra->JobType;
        // ascii to unicode
// @Mar/04/2002 ->
//        OemToChar((LPSTR)pOEMExtra->PasswordBuf, pUiData->PasswordBuf);
        OemToCharBuff((LPSTR)pOEMExtra->PasswordBuf, pUiData->PasswordBuf, PASSWORD_LEN);
// @Mar/04/2002 <-
    }

    pUiData->fUiOption = pOEMExtra->fUiOption;
    pUiData->LogDisabled = pOEMExtra->LogDisabled;
    // ascii to unicode
// @Mar/04/2002 ->
//    OemToChar((LPSTR)pOEMExtra->UserIdBuf, pUiData->UserIdBuf);
//    OemToChar((LPSTR)pOEMExtra->UserCodeBuf, pUiData->UserCodeBuf);
    OemToCharBuff((LPSTR)pOEMExtra->UserIdBuf, pUiData->UserIdBuf, USERID_LEN);
    OemToCharBuff((LPSTR)pOEMExtra->UserCodeBuf, pUiData->UserCodeBuf, USERCODE_LEN);
// @Mar/04/2002 <-
} //*** GetInfoFromOEMPdev


/***************************************************************************
    Function Name : SetInfoToOEMPdev
                    set data to private devmode
***************************************************************************/
VOID SetInfoToOEMPdev(PUIDATA pUiData)
{
    POEMUD_EXTRADATA pOEMExtra = pUiData->pOEMExtra;

    // if only main dialog is changed
    if (!BITTEST32(pUiData->fUiOption, JOBLOGDLG_UPDATED))
        return;

    // unicode to ascii
    CharToOem(pUiData->UserIdBuf, (LPSTR)pOEMExtra->UserIdBuf);
    CharToOem(pUiData->PasswordBuf, (LPSTR)pOEMExtra->PasswordBuf);
    CharToOem(pUiData->UserCodeBuf, (LPSTR)pOEMExtra->UserCodeBuf);

    pOEMExtra->fUiOption = pUiData->fUiOption & 0x00FF; // clear local bit
    pOEMExtra->JobType = pUiData->JobType;
    pOEMExtra->LogDisabled = pUiData->LogDisabled;
#if DBG
//DebugBreak();
#endif // DBG
    return;
} //*** SetInfoToOEMPdev


/***************************************************************************
    Function Name : JobPageProc

    Parameters    : HWND    hDlg            Handle of this Dialog
                    UINT    uMessage
                    WPARAM  wParam
                    LPARAM  lParam

    Modify Note   : Modify.                 03/01/2000 Masatoshi Kubokura
***************************************************************************/
INT_PTR CALLBACK JobPageProc(
HWND hDlg,
UINT uMessage,
WPARAM wParam,
LPARAM lParam)
{
    PUIDATA pUiData;
    WORD    wOldVal, fModified = FALSE, fError = FALSE;
    INT     iOldLen, iNewLen, iCnt;

#if DBG
giDebugLevel = DBG_VERBOSE;
#endif // DBG

    switch (uMessage)
    {
      case WM_INITDIALOG:
        pUiData = (PUIDATA)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pUiData);

        // get data from private devmode
        GetInfoFromOEMPdev(pUiData);

        InitMainDlg(hDlg, pUiData);
        BITCLR32(pUiData->fUiOption, JOBLOGDLG_UPDATED);
        break;

      case WM_COMMAND:
        pUiData = (PUIDATA)GetWindowLongPtr(hDlg, DWLP_USER);
        switch(LOWORD(wParam))
        {
          case IDC_EDIT_JOBMAIN_USERID:
            iOldLen = safe_strlenW(pUiData->UserIdBuf, sizeof(pUiData->UserIdBuf));
            GetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERID, pUiData->UserIdBuf,
                           sizeof(pUiData->UserIdBuf) / sizeof(WCHAR));
            iNewLen = safe_strlenW(pUiData->UserIdBuf, sizeof(pUiData->UserIdBuf));
            if (1 <= iNewLen)
            {
                if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), TRUE);
                }
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), TRUE);
            }
            // if UserID isn't set, disable Print Job setting.
            else
            {
                CheckRadioButton(hDlg, IDC_RADIO_JOB_NORMAL, IDC_RADIO_JOB_SECURE,
                                 (pUiData->JobType = IDC_RADIO_JOB_NORMAL));
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SAMPLE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_JOB_SECURE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_JOB_DEFAULT), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
            }
            if (iOldLen != iNewLen)
                fModified = TRUE;
            break;

          case IDC_EDIT_JOBMAIN_PASSWORD:
            iOldLen = safe_strlenW(pUiData->PasswordBuf, sizeof(pUiData->PasswordBuf));
            GetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_PASSWORD, pUiData->PasswordBuf,
                           sizeof(pUiData->PasswordBuf) / sizeof(WCHAR));
            if (iOldLen != safe_strlenW(pUiData->PasswordBuf, sizeof(pUiData->PasswordBuf)))
                fModified = TRUE;
            break;

          case IDC_EDIT_JOBMAIN_USERCODE:
            iOldLen = safe_strlenW(pUiData->UserCodeBuf, sizeof(pUiData->UserCodeBuf));
            GetDlgItemText(hDlg, IDC_EDIT_JOBMAIN_USERCODE, pUiData->UserCodeBuf,
                           sizeof(pUiData->UserCodeBuf) / sizeof(WCHAR));
            if (iOldLen != safe_strlenW(pUiData->UserCodeBuf, sizeof(pUiData->UserCodeBuf)))
                fModified = TRUE;
            break;

          case IDC_RADIO_JOB_NORMAL:
          case IDC_RADIO_JOB_SAMPLE:
          case IDC_RADIO_JOB_SECURE:
            wOldVal = pUiData->JobType;
            CheckRadioButton(hDlg, IDC_RADIO_JOB_NORMAL, IDC_RADIO_JOB_SECURE,
                             (pUiData->JobType = LOWORD(wParam)));
            if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_PASSWORD2), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD), FALSE);
            }
            if (wOldVal != pUiData->JobType)
                fModified = TRUE;
            break;

          case IDC_RADIO_LOG_DISABLED:
          case IDC_RADIO_LOG_ENABLED:
            wOldVal = pUiData->LogDisabled;
            CheckRadioButton(hDlg, IDC_RADIO_LOG_DISABLED, IDC_RADIO_LOG_ENABLED,
                             (pUiData->LogDisabled = LOWORD(wParam)));
            if (IDC_RADIO_LOG_ENABLED == pUiData->LogDisabled)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_LABEL_JOBMAIN_USERCODE2), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE), FALSE);
            }
            if (wOldVal != pUiData->LogDisabled)
                fModified = TRUE;
            break;

          case IDC_CHECK_JOB_DEFAULT:
            if (BITTEST32(pUiData->fUiOption, HOLD_OPTIONS))
                BITCLR32(pUiData->fUiOption, HOLD_OPTIONS);
            else
                BITSET32(pUiData->fUiOption, HOLD_OPTIONS);
            SendDlgItemMessage(hDlg, IDC_CHECK_JOB_DEFAULT, BM_SETCHECK,
                               (BITTEST32(pUiData->fUiOption, HOLD_OPTIONS)? 0 : 1), 0);
            fModified = TRUE;
            break;

          default:
            return FALSE;
        }
        break;

      case WM_NOTIFY:
        pUiData = (PUIDATA)GetWindowLongPtr(hDlg, DWLP_USER);
        {
            NMHDR FAR *lpnmhdr = (NMHDR FAR *)lParam;

            switch (lpnmhdr->code)
            {
              case PSN_SETACTIVE:
                break;

              // In case of PSN_KILLACTIVE, return FALSE to get PSN_APPLY.
              case PSN_KILLACTIVE:  // this is when user pushs OK/APPLY button.(1)
                VERBOSE((DLLTEXT("** JobPageProc: PSN_KILLACTIVE **\n")));
                BITSET32(pUiData->fUiOption, JOBLOGDLG_UPDATED);

                // Check User ID (Up to 8 alphanumeric characters)
                iNewLen = safe_strlenW(pUiData->UserIdBuf, sizeof(pUiData->UserIdBuf));
                for (iCnt = 0; iCnt < iNewLen; iCnt++)
                {
                    // SBCS alphanumeric?
                    if (!_ismbcalnum(pUiData->UserIdBuf[iCnt]))
                    {
                        fError = TRUE;
                        break;
                    }
                }
                if (fError)
                {
                    WCHAR   wcTmp1[64], wcTmp2[64];

                    // set cursor to User ID edit box
                    SetFocus(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERID));

                    // Display warning dialog
// yasho's point-out  @Nov/29/2000 ->
//                    LoadString(ghInstance, IDS_ERR_USERID_MSG, wcTmp1, sizeof(wcTmp1));
//                    LoadString(ghInstance, IDS_ERR_USERID_TITLE, wcTmp2, sizeof(wcTmp1));
                    LoadString(ghInstance, IDS_ERR_USERID_MSG, wcTmp1, sizeof(wcTmp1) / sizeof(*wcTmp1));
                    LoadString(ghInstance, IDS_ERR_USERID_TITLE, wcTmp2, sizeof(wcTmp2) / sizeof(*wcTmp2));
// @Nov/29/2000 <-
                    MessageBox(hDlg, wcTmp1, wcTmp2, MB_ICONEXCLAMATION|MB_OK);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

                    // Do not close property sheets
                    return TRUE;
                }

                // Check Password (4 digits)
                iNewLen = safe_strlenW(pUiData->PasswordBuf, sizeof(pUiData->PasswordBuf));
                if (PASSWORD_LEN != iNewLen)    // Password must be exactly 4 digits.
                {
                    fError = TRUE;
                }
                else
                {
                    for (iCnt = 0; iCnt < iNewLen; iCnt++)
                    {
                        // SBCS digit?
                        if (!_ismbcdigit(pUiData->PasswordBuf[iCnt]))
                        {
                            fError = TRUE;
                            break;
                        }
                    }
                }
                if (fError)
                {
                    // if Secure Print is enabled
                    if (IDC_RADIO_JOB_SECURE == pUiData->JobType)
                    {
                        WCHAR   wcTmp1[64], wcTmp2[64];

                        // set cursor to Password edit box
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_PASSWORD));

                        // Display warning dialog
                        LoadString(ghInstance, IDS_ERR_PASSWORD_MSG, wcTmp1, sizeof(wcTmp1) / sizeof(*wcTmp1));
                        LoadString(ghInstance, IDS_ERR_PASSWORD_TITLE, wcTmp2, sizeof(wcTmp2) / sizeof(*wcTmp2));
                        MessageBox(hDlg, wcTmp1, wcTmp2, MB_ICONEXCLAMATION|MB_OK);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

                        // Do not close property sheets
                        return TRUE;
                    }
                    else
                    {
                        // Clear invalid Password
// Use SecureZeroMemory  @Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
                        memset(pUiData->PasswordBuf, 0, sizeof(pUiData->PasswordBuf));
#else
                        SecureZeroMemory(pUiData->PasswordBuf, sizeof(pUiData->PasswordBuf));
#endif
// @Mar/29/2002 <-
                    }
                    fError = FALSE;
                }

                // Check User Code (Up to 8 characters)
                iNewLen = safe_strlenW(pUiData->UserCodeBuf, sizeof(pUiData->UserCodeBuf));
                for (iCnt = 0; iCnt < iNewLen; iCnt++)
                {
                    // SBCS digit?
                    if (!_ismbcdigit(pUiData->UserCodeBuf[iCnt]))
                    {
                        fError = TRUE;
                        break;
                    }
                }
                if (fError)
                {
                    // if Log is enabled
                    if (IDC_RADIO_LOG_ENABLED == pUiData->LogDisabled)
                    {
                        WCHAR   wcTmp1[64], wcTmp2[64];

                        // set cursor to User Code edit box
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT_JOBMAIN_USERCODE));

                        // Display warning dialog
                        LoadString(ghInstance, IDS_ERR_USERCODE_MSG, wcTmp1, sizeof(wcTmp1) / sizeof(*wcTmp1));
                        LoadString(ghInstance, IDS_ERR_USERCODE_TITLE, wcTmp2, sizeof(wcTmp2) / sizeof(*wcTmp2));
                        MessageBox(hDlg, wcTmp1, wcTmp2, MB_ICONEXCLAMATION|MB_OK);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

                        // Do not close property sheets
                        return TRUE;
                    }
                    else
                    {
                        // Clear invalid User Code
// Use SecureZeroMemory  @Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
                        memset(pUiData->UserCodeBuf, 0, sizeof(pUiData->UserCodeBuf));
#else
                        SecureZeroMemory(pUiData->UserCodeBuf, sizeof(pUiData->UserCodeBuf));
#endif
// Mar/29/2002 <-
                    }
                    fError = FALSE;
                }
                return FALSE;

              case PSN_APPLY:       // this is when user pushs OK/APPLY button.(2)
                VERBOSE((DLLTEXT("** JobPageProc: PSN_APPLY **\n")));

                // clear PRINT_DONE flag and delete file.
// BUGBUG: When printing document twice, printing job settings are cleared on app's print dialog
// in 2nd printing.  @Sep/05/2000 ->
//              if (BITTEST32(pUiData->pOEMExtra->fUiOption, PRINT_DONE))
//              {
//                  BITCLR32(pUiData->pOEMExtra->fUiOption, PRINT_DONE);
//                  VERBOSE(("** Delete file: %ls **\n", pUiData->pOEMExtra->SharedFileName));
//                  DeleteFile(pUiData->pOEMExtra->SharedFileName);
//              }
                if (BITTEST32(pUiData->fUiOption, PRINT_DONE))
                {
                    BITCLR32(pUiData->fUiOption, PRINT_DONE);
                    VERBOSE(("** Delete file: %ls **\n", pUiData->pOEMExtra->SharedFileName));
                    DeleteFile(pUiData->pOEMExtra->SharedFileName);
                }
// @Sep/05/2000 <-

                // set data to private devmode
                SetInfoToOEMPdev(pUiData);

                // update private devmode
                pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                         CPSFUNC_SET_RESULT,
                                         (LPARAM)pUiData->hPropPage,
                                         (LPARAM)CPSUI_OK);
                VERBOSE((DLLTEXT("** PSN_APPLY fUiOption=%x **\n"), pUiData->fUiOption));
                break;

              case PSN_RESET:       // this is when user pushs CANCEL button
                VERBOSE((DLLTEXT("** JobPageProc: PSN_RESET **\n")));
                break;
            }
        }
        break;

      default:
        return FALSE;
    }

    // activate APPLY button
    if (fModified)
        PropSheet_Changed(GetParent(hDlg), hDlg);
    return TRUE;
} //*** JobPageProc

} // End of extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RPDLDLG.RC
//
#define IDS_RPDL_SCALING                101
#define IDS_RPDL_BAR_HEIGHT             102
#define IDS_RPDL_BAR_SUBFONT            103
#define IDS_RPDL_TOMBO_ADD              104
#define IDS_RPDL_TOMBO_ADJX             105
#define IDS_RPDL_TOMBO_ADJY             106
#define IDS_RPDL_BIND_MARGIN            107
#define IDS_RPDL_BIND_RIGHT             108
#define IDS_RPDL_YES                    109
#define IDS_RPDL_NO                     110
#define IDS_RPDL_FAX_RESO_SUPER         150
#define IDS_RPDL_FAX_RESO_FINE          151
#define IDS_RPDL_FAX_RESO_COARSE        152
#define IDS_RPDL_FAX_CH_G3              153
#define IDS_RPDL_FAX_CH_G4              154
#define IDS_RPDL_FAX_CH_G3_1            155
#define IDS_RPDL_FAX_CH_G3_2            156
#define IDS_ERR_USERID_TITLE            200
#define IDS_ERR_USERID_MSG              201
#define IDS_ERR_PASSWORD_TITLE          202
#define IDS_ERR_PASSWORD_MSG            203
#define IDS_ERR_USERCODE_TITLE          204
#define IDS_ERR_USERCODE_MSG            205
#define IDS_ITEM_HARDDISK               250
#define IDS_ITEM_MEMORY_HARDDISK        251
#define ITEM_HARDDISK_NAMES             (IDS_ITEM_MEMORY_HARDDISK-IDS_ITEM_HARDDISK+1)
#define IDD_FAXMAIN                     400
#define IDD_FAXSUB                      401
#define IDI_ICON1                       402
#define IDD_JOBMAIN                     500
#define IDC_CHECK_SEND                  900
#define IDC_EDIT_FAXNUM                 901
#define IDC_EDIT_EXTNUM                 902
#define IDC_EDIT_EXTNUM2                903
#define IDD_OPTION                      904
#define IDD_FAXMAIN_DEFAULT             905
#define IDC_ICON_LOGO                   906
#define IDC_LABEL_FAXMAIN_1             907
#define IDC_LABEL_FAXMAIN_2             908
#define IDC_LABEL_FAXMAIN_3             909
#define IDC_LABEL_FAXMAIN_4             910
#define IDC_CHECK_CLRNUM                911
#define IDC_CHECK_TIME                  930
#define IDC_CHECK_PRINT                 931
#define IDC_EDIT_HOUR                   932
#define IDC_EDIT_MINUTE                 933
#define IDC_COMBO_RESO                  934
#define IDC_COMBO_CHANNEL               935
#define IDC_RADIO_CMD_OFF               936
#define IDC_RADIO_CMD_ON                937
#define IDC_RADIO_MH_OFF                938
#define IDC_RADIO_MH_ON                 939
#define IDD_FAXSUB_DEFAULT              940
#define IDC_LABEL_FAXSUB_HOUR           941
#define IDC_LABEL_FAXSUB_MINUTE         942
#define IDC_LABEL_FAXSUB_1              943
#define IDC_LABEL_FAXSUB_2              944
#define IDC_LABEL_FAXSUB_3              945
#define IDC_LABEL_FAXSUB_4              946
#define IDC_LABEL_FAXSUB_5              947
#define IDC_LABEL_CLRNUM                948    // for NT4  @Sep/02/99
#define IDC_LABEL_JOBMAIN_USERID        1000
#define IDC_LABEL_JOBMAIN_USERID2       1001
#define IDC_LABEL_JOBMAIN_USERID3       1002
#define IDC_LABEL_JOBMAIN_JOB           1003
#define IDC_LABEL_JOBMAIN_PASSWORD      1004
#define IDC_LABEL_JOBMAIN_PASSWORD2     1005
#define IDC_LABEL_JOBMAIN_LOG           1006
#define IDC_LABEL_JOBMAIN_USERCODE      1007
#define IDC_LABEL_JOBMAIN_USERCODE2     1008
#define IDC_EDIT_JOBMAIN_USERID         1009
#define IDC_EDIT_JOBMAIN_PASSWORD       1010
#define IDC_EDIT_JOBMAIN_USERCODE       1011
#define IDC_RADIO_JOB_NORMAL            1012
#define IDC_RADIO_JOB_SAMPLE            1013
#define IDC_RADIO_JOB_SECURE            1014
#define IDC_RADIO_LOG_DISABLED          1015
#define IDC_RADIO_LOG_ENABLED           1016
#define IDC_CHECK_JOB_DEFAULT           1017

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        501
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           206
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlui\rpdlui.cpp ===
/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           RPDLUI.CPP

Abstract:       Main file for OEM UI plugin module.

Functions:      OEMCommonUIProp
                OEMDocumentPropertySheets

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/01/99 -Masatoshi Kubokura-
        Last modified for Windows2000.
    08/30/99 -Masatoshi Kubokura-
        Began to modify for NT4SP6(Unidrv5.4).
    09/29/99 -Masatoshi Kubokura-
        Last modified for NT4SP6.
    05/22/2000 -Masatoshi Kubokura-
        V.1.03 for NT4
    11/29/2000 -Masatoshi Kubokura-
        Last modified for XP inbox.
    03/01/2002 -Masatoshi Kubokura-
        Include strsafe.h.
        Add FileNameBufSize as arg3 at RWFileData().
        Use safe_sprintfW() instead of wsprintfW().
    03/29/2002 -Masatoshi Kubokura-
        Eliminate "#if 0".
        Use SecureZeroMemory() instead of memset(,0,)
    04/03/2002 -Masatoshi Kubokura-
        Use safe_strlenW() instead of lstrlen().

--*/


#include "pdev.h"
#include "resource.h"
#include "rpdlui.h"
#include <prsht.h>
#ifndef WINNT_40
#include "strsafe.h"        // @Mar/01/2002
#endif // !WINNT_40

//#pragma setlocale(".932")   // MSKK 98/7/15,  OBSOLETE @Sep/19/98

////////////////////////////////////////////////////////
//      GLOBALS
////////////////////////////////////////////////////////
HINSTANCE ghInstance = NULL;

////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////
#if DBG
//giDebugLevel = DBG_VERBOSE;
////#define giDebugLevel DBG_VERBOSE    // enable VERBOSE() in each file
#endif

// @Apr/04/2002 ->
#define RES_ID_MASK     0xffff
#define is_valid_ptr(p) (~RES_ID_MASK & (UINT_PTR)(p))
// @Apr/04/2002 <-

// Resource in other DLL  @Sep/24/99
WCHAR STR_UNIRESDLL[]  = L"UNIRES.DLL";
WCHAR STR_RPDLRESDLL[] = L"RPDLRES.DLL";
#define UNIRES_DLL          0
#define RPDLRES_DLL         1
#define THIS_DLL            2
// ID of UNIRES.DLL (This comes from STDNAMES.GPD.)
#define IDS_UNIRES_IMAGECONTROL_DISPLAY 11112
// ID of RPDLRES.DLL (This comes from RPDLRES.RC.)
#define IDS_RPDLRES_COLLATETYPE         675     // @Sep/29/99

WCHAR REGVAL_ACTUALNAME[] = L"Model";           // @Oct/07/98
#ifndef GWMODEL                                 // @Sep/26/2000
#ifndef WINNT_40                                // @Sep/01/99
WCHAR HELPFILENAME[] = L"%s\\3\\RPDLCFG.HLP";   // add "\\3" @Oct/30/98
#else  // WINNT_40
WCHAR HELPFILENAME[] = L"%s\\2\\RPDLCFG.HLP";
#endif // WINNT_40
#else  // GWMODEL
#ifndef WINNT_40
WCHAR HELPFILENAME[] = L"%s\\3\\RPDLCFG2.HLP";
#else  // WINNT_40
WCHAR HELPFILENAME[] = L"%s\\2\\RPDLCFG2.HLP";
#endif // WINNT_40
#endif // GWMODEL

// OBSOLETE  @Sep/27/99 ->
//CHAR UNIDRV_FEATURE_DUPLEX[] = "Duplex";
//CHAR UNIDRV_DUPLEX_NONE[]    = "NONE";
// @Sep/27/99 <-

// OEM items: VariableScaling(1)+Barcode(2)+TOMBO(3)+Duplex(2)
// (add TOMBO @Sep/15/98)
#define RPDL_OEM_ITEMS      8

#define ITEM_SCALING        0
#define ITEM_BAR_HEIGHT     1
#define ITEM_BAR_SUBFONT    2
#define ITEM_TOMBO_ADD      3
#define ITEM_TOMBO_ADJX     4
#define ITEM_TOMBO_ADJY     5
#define ITEM_BIND_MARGIN    6       // <-3 @Sep/15/98
#define ITEM_BIND_RIGHT     7       // <-4 @Sep/15/98
#define DMPUB_SCALING       (DMPUB_USER+1+ITEM_SCALING)     // 101
#define DMPUB_BAR_H         (DMPUB_USER+1+ITEM_BAR_HEIGHT)  // 102
#define DMPUB_BAR_SUBFONT   (DMPUB_USER+1+ITEM_BAR_SUBFONT) // 103
#define DMPUB_TOMBO_ADD     (DMPUB_USER+1+ITEM_TOMBO_ADD)   // 104
#define DMPUB_TOMBO_ADJX    (DMPUB_USER+1+ITEM_TOMBO_ADJX)  // 105
#define DMPUB_TOMBO_ADJY    (DMPUB_USER+1+ITEM_TOMBO_ADJY)  // 106
#define DMPUB_BIND_MARGIN   (DMPUB_USER+1+ITEM_BIND_MARGIN) // 107
#define DMPUB_BIND_RIGHT    (DMPUB_USER+1+ITEM_BIND_RIGHT)  // 108
#define LEVEL_2             2
#define SEL_YES             0       // <-YES_2STATES @Sep/29/99
#define SEL_NO              1       // <-NO_2STATES  @Sep/29/99
#define SEL_STANDARD        0       // @Sep/29/99
#define SEL_DUPLEX_NONE     0       // @Sep/29/99

// max string size in resource (RPDLDLG.RC)
#define ITEM_STR_LEN128     128
#define ITEM_STR_LEN8       8

// string IDs in resource (RPDLDLG.RC)
WORD wItemStrID[RPDL_OEM_ITEMS] = {
    IDS_RPDL_SCALING,
    IDS_RPDL_BAR_HEIGHT,
    IDS_RPDL_BAR_SUBFONT,
    IDS_RPDL_TOMBO_ADD,
    IDS_RPDL_TOMBO_ADJX,
    IDS_RPDL_TOMBO_ADJY,
    IDS_RPDL_BIND_MARGIN,
    IDS_RPDL_BIND_RIGHT
};


OPTPARAM MinMaxRangeScalingOP[] = {
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        __TEXT("%"),                // pData (postfix)
        IDI_CPSUI_GENERIC_OPTION,   // IconID
        0                           // lParam
    },
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        NULL,                       // pData (help line)
        (DWORD)VAR_SCALING_MIN,     // IconID (low range)
        VAR_SCALING_MAX             // lParam (high range)
    }
};

OPTTYPE TVOTUDArrowScalingOT = {
        sizeof(OPTTYPE),            // cbSize
        TVOT_UDARROW,               // Type
        0,                          // Flags OPTTF_xxxx
        2,                          // Count
        0,                          // BegCtrlID
        MinMaxRangeScalingOP,       // pOptParam
        0                           // Style, OTS_xxxx
};

OPTPARAM MinMaxRangeBarHeightOP[] = {
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        __TEXT("mm"),               // pData (postfix)
        IDI_CPSUI_GENERIC_OPTION,   // IconID
        0                           // lParam
    },
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        NULL,                       // pData (help line)
        (DWORD)BAR_H_MIN,           // IconID (low range)
        BAR_H_MAX                   // lParam (high range)
    }
};

OPTTYPE TVOTUDArrowBarHeightOT = {
        sizeof(OPTTYPE),            // cbSize
        TVOT_UDARROW,               // Type
        0,                          // Flags OPTTF_xxxx
        2,                          // Count
        0,                          // BegCtrlID
        MinMaxRangeBarHeightOP,     // pOptParam
        0                           // Style, OTS_xxxx
};

OPTPARAM MinMaxRangeBindMarginOP[] = {
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        __TEXT("mm"),               // pData (postfix)
        IDI_CPSUI_GENERIC_OPTION,   // IconID
        0                           // lParam
    },
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        NULL,                       // pData (help line)
        (DWORD)BIND_MARGIN_MIN,     // IconID (low range)
        BIND_MARGIN_MAX             // lParam (high range)
    }
};

OPTTYPE TVOTUDArrowBindMarginOT = {
        sizeof(OPTTYPE),            // cbSize
        TVOT_UDARROW,               // Type
        0,                          // Flags OPTTF_xxxx
        2,                          // Count
        0,                          // BegCtrlID
        MinMaxRangeBindMarginOP,    // pOptParam
        0                           // Style, OTS_xxxx
};

// @Sep/15/98 ->
OPTPARAM MinMaxRangeTOMBO_AdjXOP[] = {
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        __TEXT("x 0.1mm"),          // pData (postfix)
        IDI_CPSUI_GENERIC_OPTION,   // IconID
        0                           // lParam
    },
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        NULL,                       // pData (help line)
        (DWORD)TOMBO_ADJ_MIN,       // IconID (low range)
        TOMBO_ADJ_MAX               // lParam (high range)
    }
};

OPTTYPE TVOTUDArrowTOMBO_AdjXOT = {
        sizeof(OPTTYPE),            // cbSize
        TVOT_UDARROW,               // Type
        0,                          // Flags OPTTF_xxxx
        2,                          // Count
        0,                          // BegCtrlID
        MinMaxRangeTOMBO_AdjXOP,    // pOptParam
        0                           // Style, OTS_xxxx
};

OPTPARAM MinMaxRangeTOMBO_AdjYOP[] = {
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        __TEXT("x 0.1mm"),          // pData (postfix)
        IDI_CPSUI_GENERIC_OPTION,   // IconID
        0                           // lParam
    },
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        NULL,                       // pData (help line)
        (DWORD)TOMBO_ADJ_MIN,       // IconID (low range)
        TOMBO_ADJ_MAX               // lParam (high range)
    }
};

OPTTYPE TVOTUDArrowTOMBO_AdjYOT = {
        sizeof(OPTTYPE),            // cbSize
        TVOT_UDARROW,               // Type
        0,                          // Flags OPTTF_xxxx
        2,                          // Count
        0,                          // BegCtrlID
        MinMaxRangeTOMBO_AdjYOP,    // pOptParam
        0                           // Style, OTS_xxxx
};
// @Sep/15/98 <-

OPTPARAM YesNoOP[] = {
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        NULL,                       // pData  (<-IDS_CPSUI_YES  MSKK Sep/11/98)
// @Sep/06/99 ->
//      IDI_CPSUI_EMPTY,            // IconID (<-IDI_CPSUI_YES  @Jul/30/98)
        IDI_CPSUI_GENERIC_OPTION,   // IconID
// @Sep/06/99 <-
        1                           // lParam
    },
    {
        sizeof(OPTPARAM),           // cbSize
        0,                          // OPTPF_xxx
        0,                          // style
        NULL,                       // pData  (<-IDS_CPSUI_NO  MSKK Sep/11/98)
// @Sep/06/99 ->
//      IDI_CPSUI_EMPTY,            // IconID (<-IDI_CPSUI_NO  @Jul/30/98)
        IDI_CPSUI_GENERIC_OPTION,   // IconID
// @Sep/06/99 <-
        0                           // lParam
    }
};

OPTTYPE YesNoOT = {
        sizeof(OPTTYPE),            // cbSize
        TVOT_2STATES,               // Type
        0,                          // Flags OPTTF_xxxx
        2,                          // Count
        0,                          // BegCtrlID
        YesNoOP,                    // pOptParam
        0                           // Style, OTS_xxxx
};


OPTITEM TVOEMUIOptItems[] = {
    {   // Variable Scaling
        sizeof(OPTITEM),            // cbSize(size of this structure)
        LEVEL_2,                    // Level(level in the tree view)
        0,                          // DlgPageIdx(Index to the pDlgPage)
        OPTIF_CALLBACK|OPTIF_HAS_POIEXT,    // add OPTIF_HAS_POIEXT @May/20/98
        0,                          // UserData(caller's own data)
        __TEXT(""),                 // pName(name of the item)
        VAR_SCALING_DEFAULT,        // Sel(current selection)
        NULL,                       // pExtChkBox/pExtPush
        &TVOTUDArrowScalingOT,      // pOptType
        50,                         // HelpIndex(Help file index)   @May/20/98
        DMPUB_SCALING               // DMPubID(Devmode public filed ID)
    },
    {   // Barcode Height
        sizeof(OPTITEM),            // cbSize(size of this structure)
        LEVEL_2,                    // Level(level in the tree view)
        0,                          // DlgPageIdx(Index to the pDlgPage)
        OPTIF_CALLBACK|OPTIF_HAS_POIEXT,    // add OPTIF_HAS_POIEXT
        0,                          // UserData(caller's own data)
        __TEXT(""),                 // pName(name of the item)
        BAR_H_DEFAULT,              // Sel(current selection)
        NULL,                       // pExtChkBox/pExtPush
        &TVOTUDArrowBarHeightOT,    // pOptType
        51,                         // HelpIndex(Help file index)
        DMPUB_BAR_H                 // DMPubID(Devmode public filed ID)
    },
    {   // Print Barcode with Readable Characters
        sizeof(OPTITEM),            // cbSize(size of this structure)
        LEVEL_2,                    // Level(level in the tree view)
        0,                          // DlgPageIdx(Index to the pDlgPage)
        OPTIF_CALLBACK|OPTIF_HAS_POIEXT,    // add OPTIF_HAS_POIEXT
        0,                          // UserData(caller's own data)
        __TEXT(""),                 // pName(name of the item)
        SEL_YES,                    // Sel(current selection)
        NULL,                       // pExtChkBox/pExtPush
        &YesNoOT,                   // pOptType
        52,                         // HelpIndex(Help file index)
        DMPUB_BAR_SUBFONT           // DMPubID(Devmode public filed ID)
    },
// @Sep/15/98 ->
    {   // Print Crops
        sizeof(OPTITEM),            // cbSize(size of this structure)
        LEVEL_2,                    // Level(level in the tree view)
        0,                          // DlgPageIdx(Index to the pDlgPage)
        OPTIF_CALLBACK|OPTIF_HAS_POIEXT,
        0,                          // UserData(caller's own data)
        __TEXT(""),                 // pName(name of the item)
        SEL_NO,                     // Sel(current selection)
        NULL,                       // pExtChkBox/pExtPush
        &YesNoOT,                   // pOptType
        55,                         // HelpIndex(Help file index)
        DMPUB_TOMBO_ADD             // DMPubID(Devmode public filed ID)
    },
    {   // Adjust Horizontal Distance of Crops
        sizeof(OPTITEM),            // cbSize(size of this structure)
        LEVEL_2,                    // Level(level in the tree view)
        0,                          // DlgPageIdx(Index to the pDlgPage)
        OPTIF_CALLBACK|OPTIF_HAS_POIEXT,
        0,                          // UserData(caller's own data)
        __TEXT(""),                 // pName(name of the item)
        DEFAULT_0,                  // Sel(current selection)
        NULL,                       // pExtChkBox/pExtPush
        &TVOTUDArrowTOMBO_AdjXOT,   // pOptType
        56,                         // HelpIndex(Help file index)
        DMPUB_TOMBO_ADJX            // DMPubID(Devmode public filed ID)
    },
    {   // Adjust Vertical Distance of Crops
        sizeof(OPTITEM),            // cbSize(size of this structure)
        LEVEL_2,                    // Level(level in the tree view)
        0,                          // DlgPageIdx(Index to the pDlgPage)
        OPTIF_CALLBACK|OPTIF_HAS_POIEXT,
        0,                          // UserData(caller's own data)
        __TEXT(""),                 // pName(name of the item)
        DEFAULT_0,                  // Sel(current selection)
        NULL,                       // pExtChkBox/pExtPush
        &TVOTUDArrowTOMBO_AdjYOT,   // pOptType
        57,                         // HelpIndex(Help file index)
        DMPUB_TOMBO_ADJY            // DMPubID(Devmode public filed ID)
    },
// @Sep/15/98 <-
    {   // Binding Margin
        sizeof(OPTITEM),            // cbSize(size of this structure)
        LEVEL_2,                    // Level(level in the tree view)
        0,                          // DlgPageIdx(Index to the pDlgPage)
        OPTIF_CALLBACK|OPTIF_HAS_POIEXT,    // add OPTIF_HAS_POIEXT
        0,                          // UserData(caller's own data)
        __TEXT(""),                 // pName(name of the item)
        DEFAULT_0,                  // Sel(current selection)  (0->DEFAULT_0 @Sep/15/98)
        NULL,                       // pExtChkBox/pExtPush
        &TVOTUDArrowBindMarginOT,   // pOptType
        53,                         // HelpIndex(Help file index)
        DMPUB_BIND_MARGIN           // DMPubID(Devmode public filed ID)
    },
    {   // Bind Right Side if Possible
        sizeof(OPTITEM),            // cbSize(size of this structure)
        LEVEL_2,                    // Level(level in the tree view)
        0,                          // DlgPageIdx(Index to the pDlgPage)
        OPTIF_CALLBACK|OPTIF_HAS_POIEXT,    // add OPTIF_HAS_POIEXT
        0,                          // UserData(caller's own data)
        __TEXT(""),                 // pName(name of the item)
        SEL_NO,                     // Sel(current selection)
        NULL,                       // pExtChkBox/pExtPush
        &YesNoOT,                   // pOptType
        54,                         // HelpIndex(Help file index)
        DMPUB_BIND_RIGHT            // DMPubID(Devmode public filed ID)
    }
};


////////////////////////////////////////////////////////
//      EXTERNAL
////////////////////////////////////////////////////////
extern "C" {
#ifndef GWMODEL
extern INT_PTR CALLBACK FaxPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
#endif // !GWMODEL
#ifdef JOBLOGSUPPORT_DLG
extern INT_PTR CALLBACK JobPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
#endif // JOBLOGSUPPORT_DLG
// @Mar/01/2002 ->
//extern BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG type);
extern BOOL RWFileData(PFILEDATA pFileData, LPWSTR pwszFileName, LONG FileNameBufSize, LONG type);
extern INT safe_sprintfW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszFormat, ...);
// @Mar/01/2002 <-
}

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////
LONG APIENTRY DOCPROP_CallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
#ifdef DISKLESSMODEL
LONG APIENTRY PRNPROP_CallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
#endif // DISKLESSMODEL
INT SearchItemByName(POPTITEM pOptItem, WORD cOptItem, UINT uiResDLL, UINT uiResID);
INT SearchItemByID(POPTITEM pOptItem, WORD cOptItem, BYTE DMPubID);
BOOL IsValidDuplex(POEMCUIPPARAM pOEMUIParam);

// Need to export these functions as c declarations.
extern "C" {

//////////////////////////////////////////////////////////////////////////
//  Function:   safe_strlenW
//////////////////////////////////////////////////////////////////////////
INT safe_strlenW(wchar_t* psz, size_t cchMax)
{
#ifndef WINNT_40
    HRESULT hr;
    size_t  cch = 0;

    hr = StringCchLengthW(psz, cchMax, &cch);
    VERBOSE(("** safe_strlenW: size(lstrlen)=%d **\n", lstrlen(psz)));
    VERBOSE(("** safe_strlenW: size(StringCchLength)=%d **\n", cch));
    if (SUCCEEDED(hr))
        return cch;
    else
        return 0;
#else  // WINNT_40
    return lstrlenW(psz);
#endif // WINNT_40
} //*** safe_strlenW


//////////////////////////////////////////////////////////////////////////
//  Function:   DllMain
//
//  Description:  Dll entry point for initialization..
//
//////////////////////////////////////////////////////////////////////////
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
    VERBOSE((DLLTEXT("** enter DllMain **\n")));
    switch(wReason)
    {
        case DLL_PROCESS_ATTACH:
            VERBOSE((DLLTEXT("** Process attach. **\n")));

            // Save DLL instance for use later.
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            VERBOSE((DLLTEXT("Thread attach.\n")));
            break;

        case DLL_PROCESS_DETACH:
            VERBOSE((DLLTEXT("Process detach.\n")));
            break;

        case DLL_THREAD_DETACH:
            VERBOSE((DLLTEXT("Thread detach.\n")));
            break;
    }

    return TRUE;
} //*** DllMain


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommonUIProp
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY OEMCommonUIProp(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pOEMUIParam);   // @Oct/06/98

#if DBG
    LPCSTR OEMCommonUIProp_Mode[] = {
        "Bad Index",
        "OEMCUIP_DOCPROP",
        "OEMCUIP_PRNPROP",
    };

    giDebugLevel = DBG_VERBOSE;
    VERBOSE((DLLTEXT("OEMCommonUI(%s) entry.  cOEMOptItems=%d\n"), 
             OEMCommonUIProp_Mode[dwMode], pOEMUIParam->cOEMOptItems));
#endif // DBG

// Sep/26/2000 ->
//    // if called from DrvDevicePropertySheets, exit  @Dec/26/97
//    if (OEMCUIP_PRNPROP == dwMode)
//    {
//        pOEMUIParam->cOEMOptItems = 0;
//        return TRUE;
//    }
//    // Validate parameters.
//    if((OEMCUIP_DOCPROP != dwMode) || !IsValidOEMUIParam(dwMode, pOEMUIParam))
//    {
//#if DBG
//        ERR((DLLTEXT("OEMCommonUI() ERROR_INVALID_PARAMETER.\n"
//            "\tdwMode = %d, pOEMUIParam = %#lx.\n"),
//            dwMode, pOEMUIParam));
//        DumpOEMUIParam(dwMode, pOEMUIParam);
//#endif // DBG
//        // Return invalid parameter error.
//        SetLastError(ERROR_INVALID_PARAMETER);
//        return FALSE;
//    }
// Sep/26/2000 <-

    if(NULL == pOEMUIParam->pOEMOptItems)   // The first call
    {
        DWORD           dwSize;
        WCHAR           wchNameBuf[64];

        VERBOSE((DLLTEXT("  The 1st call.\n")));
// Sep/22/2000 ->
        if (OEMCUIP_PRNPROP == dwMode)
        {
#ifndef DISKLESSMODEL
            pOEMUIParam->cOEMOptItems = 0;
#else  // DISKLESSMODEL
            pOEMUIParam->cOEMOptItems = 1;  // dummy item
#endif // DISKLESSMODEL
            return TRUE;
        }
// Sep/22/2000 <-

        // Return number of requested tree view items to add.
        pOEMUIParam->cOEMOptItems = RPDL_OEM_ITEMS;

        // Clear flag of printer capability.
        BITCLR_UPPER_FLAG(pOEMExtra->fUiOption);

        // Get actual printer name (completely modify @Oct/07/98)
        if (ERROR_SUCCESS == GetPrinterDataW(pOEMUIParam->hPrinter, REGVAL_ACTUALNAME,
                                             NULL, (LPBYTE)wchNameBuf, 64, &dwSize))
        {
            WORD wCnt;

            // Check printer capability from actual printer name.
            for (wCnt = 0; UniqueModel[wCnt].fCapability ; wCnt++)
            {
                if (!lstrcmpW(wchNameBuf, UniqueModel[wCnt].Name))
                {
                    VERBOSE((DLLTEXT("** UNIQUE MODEL:%ls **\n"), wchNameBuf));
                    pOEMExtra->fUiOption |= UniqueModel[wCnt].fCapability;
                    break;
                }
            }
#ifdef GWMODEL      // @Sep/21/2000
            pOEMExtra->fUiOption |= BIT(OPT_VARIABLE_SCALING);
#endif // GWMODEL
        }
    }
    else                                    // The second call
    {
        POPTITEM    pItemDst, pItemSrc;
        WORD        wCount;
        WCHAR       DrvDirName[MAX_PATH];       // MAX_PATH=260
        DWORD       dwSize;
        LPTSTR      pHelpFile;
        POPTPARAM   lpYNParam ;                 // MSKK Sep/11/98
        POPTPARAM   lpYesParam, lpNoParam ;     // @Sep/19/98
// @Sep/24/99 ->
        POPTITEM    pOptItem;
        INT         iNum;
// @Sep/24/99 <-

        VERBOSE((DLLTEXT("  The 2nd call.\n")));
// Sep/26/2000 ->
        if (0 == pOEMUIParam->cOEMOptItems)
            return TRUE;
// Sep/26/2000 <-

// Sep/22/2000 ->
        // fill out data for dummy item to call PRNPROP_CallBack
        if (OEMCUIP_PRNPROP == dwMode)
        {
#ifdef DISKLESSMODEL
            POPTITEM    pOptItem = pOEMUIParam->pOEMOptItems;
            pOptItem->cbSize   = sizeof(OPTITEM);
            pOptItem->Level    = 2;             // Level 2
            pOptItem->pName    = NULL;
            pOptItem->pOptType = NULL;
            pOptItem->DMPubID  = DMPUB_NONE;
            pOptItem->Flags    = OPTIF_HIDE | OPTIF_CALLBACK;   // invisible and with callback
            pOEMUIParam->OEMCUIPCallback = PRNPROP_CallBack;
#endif // DISKLESSMODEL
            return TRUE;
        }
// Sep/22/2000 <-

        // Init OEMOptItmes.
// Use SecureZeroMemory  @Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
        memset(pOEMUIParam->pOEMOptItems, 0, sizeof(OPTITEM) * pOEMUIParam->cOEMOptItems);
#else
        SecureZeroMemory(pOEMUIParam->pOEMOptItems, sizeof(OPTITEM) * pOEMUIParam->cOEMOptItems);
#endif
// Mar/29/2002 <-

        // Get printerdriver directory where help file is.
        pHelpFile = NULL;
        dwSize = sizeof(DrvDirName);
        if (GetPrinterDriverDirectoryW(NULL, NULL, 1, (PBYTE)DrvDirName, dwSize, &dwSize))
        {
            dwSize += sizeof(HELPFILENAME);
            pHelpFile = (LPTSTR)HeapAlloc(pOEMUIParam->hOEMHeap, HEAP_ZERO_MEMORY, dwSize);
            if (pHelpFile) { // 392060: PREFIX
                safe_sprintfW(pHelpFile, dwSize / sizeof(WCHAR), HELPFILENAME, DrvDirName);
                VERBOSE((DLLTEXT("** PrintDriverDir:size=%d, %ls **\n"), dwSize, pHelpFile));
            }
        }

        // Fill out tree view items.
        //   wCount   0:VariableScaling, 1,2:Barcode, 3-5:TOMBO 6,7:Duplex
        for (wCount = 0; wCount < pOEMUIParam->cOEMOptItems; wCount++)
        {
            pItemDst = &(pOEMUIParam->pOEMOptItems[wCount]);
            pItemSrc = &(TVOEMUIOptItems[wCount]);
            pItemDst->cbSize   = pItemSrc->cbSize;
            pItemDst->Level    = pItemSrc->Level;
            pItemDst->Flags    = pItemSrc->Flags;
            pItemDst->pName    = (LPTSTR)HeapAlloc(pOEMUIParam->hOEMHeap,
                                                   HEAP_ZERO_MEMORY, ITEM_STR_LEN128);
            LoadString(ghInstance, wItemStrID[wCount], pItemDst->pName, ITEM_STR_LEN128);
            pItemDst->pOptType = pItemSrc->pOptType;
            pItemDst->DMPubID  = pItemSrc->DMPubID;

            if (pHelpFile)
            {
                // enable help
                pItemDst->HelpIndex = pItemSrc->HelpIndex;
                pItemDst->pOIExt = (POIEXT)HeapAlloc(pOEMUIParam->hOEMHeap, HEAP_ZERO_MEMORY,
                                                     sizeof(OIEXT));
                if (pItemDst->pOIExt) { // 392061: PREFIX
                    pItemDst->pOIExt->cbSize = sizeof(OIEXT);

                    // set help file name
                    pItemDst->pOIExt->pHelpFile = pHelpFile;
                }
            }
        }

        // Set strings "Yes"/"No" at item options  (MSKK Sep/11/98, LoadString @Sep/19/98)
        //     at ITEM_BAR_SUBFONT
        lpYesParam = pOEMUIParam->pOEMOptItems[ITEM_BAR_SUBFONT].pOptType->pOptParam;
        lpYesParam->pData = (LPTSTR)HeapAlloc(pOEMUIParam->hOEMHeap,
                                              HEAP_ZERO_MEMORY, ITEM_STR_LEN8);
        LoadString(ghInstance, IDS_RPDL_YES, lpYesParam->pData, ITEM_STR_LEN8);
        lpNoParam = lpYesParam + 1;
        lpNoParam->pData = (LPTSTR)HeapAlloc(pOEMUIParam->hOEMHeap,
                                             HEAP_ZERO_MEMORY, ITEM_STR_LEN8);
        LoadString(ghInstance, IDS_RPDL_NO, lpNoParam->pData, ITEM_STR_LEN8);

        //     at ITEM_TOMBO_ADD  @Sep/15/98
        lpYNParam = pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADD].pOptType->pOptParam;
        lpYNParam->pData = lpYesParam->pData;
        (lpYNParam+1)->pData = lpNoParam->pData;

        //     at ITEM_BIND_RIGHT
        lpYNParam = pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].pOptType->pOptParam;
        lpYNParam->pData = lpYesParam->pData;
        (lpYNParam+1)->pData = lpNoParam->pData;


        // Initialize options
        if (BITTEST32(pOEMExtra->fUiOption, OPT_VARIABLE_SCALING))  // @Apr/20/98
            pOEMUIParam->pOEMOptItems[ITEM_SCALING].Sel = (LONG)pOEMExtra->UiScale;
        else
            pOEMUIParam->pOEMOptItems[ITEM_SCALING].Flags |= OPTIF_HIDE;

// @Sep/24/99 ->
        // If ImageControl isn't set to "Standard", disable Scaling.
        iNum = SearchItemByName((pOptItem = pOEMUIParam->pDrvOptItems),
                                (WORD)pOEMUIParam->cDrvOptItems,
                                UNIRES_DLL, IDS_UNIRES_IMAGECONTROL_DISPLAY);
        if (0 <= iNum && SEL_STANDARD != (pOptItem+iNum)->Sel)
            pOEMUIParam->pOEMOptItems[ITEM_SCALING].Flags |= OPTIF_DISABLED;
// @Sep/24/99 <-

        pOEMUIParam->pOEMOptItems[ITEM_BAR_HEIGHT].Sel = (LONG)pOEMExtra->UiBarHeight;
        if (BITTEST32(pOEMExtra->fUiOption, DISABLE_BAR_SUBFONT))
            pOEMUIParam->pOEMOptItems[ITEM_BAR_SUBFONT].Sel = SEL_NO;
        else
            pOEMUIParam->pOEMOptItems[ITEM_BAR_SUBFONT].Sel = SEL_YES;

// @Sep/16/98 ->
        if (BITTEST32(pOEMExtra->fUiOption, ENABLE_TOMBO))
        {
            pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADD].Sel = SEL_YES;
        }
        else
        {
            pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADD].Sel = SEL_NO;
            pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJX].Flags |= OPTIF_DISABLED;
            pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJY].Flags |= OPTIF_DISABLED;
        }
        pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJX].Sel = (LONG)pOEMExtra->nUiTomboAdjX;
        pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJY].Sel = (LONG)pOEMExtra->nUiTomboAdjY;
// @Sep/16/98 <-

        if (BITTEST32(pOEMExtra->fUiOption, OPT_NODUPLEX))          // @Apr/20/98
        {
            pOEMUIParam->pOEMOptItems[ITEM_BIND_MARGIN].Flags |= OPTIF_HIDE;
            pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].Flags  |= OPTIF_HIDE;
        }
        else
        {
            pOEMUIParam->pOEMOptItems[ITEM_BIND_MARGIN].Sel = (LONG)pOEMExtra->UiBindMargin;

            if (BITTEST32(pOEMExtra->fUiOption, ENABLE_BIND_RIGHT))
                pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].Sel = SEL_YES;
            else
                pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].Sel = SEL_NO;

            if (!IsValidDuplex(pOEMUIParam))
            {
                pOEMUIParam->pOEMOptItems[ITEM_BIND_MARGIN].Flags |= OPTIF_DISABLED;
                pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].Flags  |= OPTIF_DISABLED;
            }
        }

        pOEMUIParam->OEMCUIPCallback = DOCPROP_CallBack;
    }

    return TRUE;
} //*** OEMCommonUIProp

} // End of extern "C"


LONG APIENTRY DOCPROP_CallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG        Action     = CPSUICB_ACTION_NONE;
// @Sep/24/99 ->
    POPTITEM    pOptItem;
    INT         iNum;
    DWORD       dwPrevFlags;
// @Sep/24/99 <-

#if DBG
    VERBOSE((DLLTEXT("DOCPROP_CallBack() entry.\n")));

    switch (pCallbackParam->Reason)
    {
    case CPSUICB_REASON_SEL_CHANGED:
        VERBOSE((DLLTEXT("  CPSUICB_REASON_SEL_CHANGED\n")));      break;
    case CPSUICB_REASON_PUSHBUTTON:
        VERBOSE((DLLTEXT("  CPSUICB_REASON_PUSHBUTTON\n")));       break;
    case CPSUICB_REASON_DLGPROC:
        VERBOSE((DLLTEXT("  CPSUICB_REASON_DLGPROC\n")));          break;
    case CPSUICB_REASON_UNDO_CHANGES:
        VERBOSE((DLLTEXT("  CPSUICB_REASON_UNDO_CHANGES\n")));     break;
    case CPSUICB_REASON_EXTPUSH:
        VERBOSE((DLLTEXT("  CPSUICB_REASON_EXTPUSH\n")));          break;
    case CPSUICB_REASON_APPLYNOW:
        VERBOSE((DLLTEXT("  CPSUICB_REASON_APPLYNOW\n")));         break;
    case CPSUICB_REASON_OPTITEM_SETFOCUS:
        VERBOSE((DLLTEXT("  CPSUICB_REASON_OPTITEM_SETFOCUS\n"))); break;
    case CPSUICB_REASON_ITEMS_REVERTED:
        VERBOSE((DLLTEXT("  CPSUICB_REASON_ITEMS_REVERTED\n")));   break;
    case CPSUICB_REASON_ABOUT:
        VERBOSE((DLLTEXT("  CPSUICB_REASON_ABOUT\n")));            break;
    }
    VERBOSE((DLLTEXT("  DMPubID=%d, Sel=%d, Flags=%x\n"),
             pCallbackParam->pCurItem->DMPubID,
             pCallbackParam->pCurItem->Sel,
             pCallbackParam->pCurItem->Flags));
#endif // DBG

    switch (pCallbackParam->Reason)
    {
    case CPSUICB_REASON_OPTITEM_SETFOCUS:
// @May/22/2000 ->
#ifdef WINNT_40
        // If collate check box exists (i.e. printer collate is available),
        // set dmCollate.

        // Search Copies&Collate item
        if ((iNum = SearchItemByID((pOptItem = pOEMUIParam->pDrvOptItems),
                                   (WORD)pOEMUIParam->cDrvOptItems,
                                   DMPUB_COPIES_COLLATE)) >= 0)
        {
            if ((pOptItem+iNum)->pExtChkBox && pOEMUIParam->pPublicDM)
            {
                pOEMUIParam->pPublicDM->dmCollate = DMCOLLATE_TRUE;
                pOEMUIParam->pPublicDM->dmFields |= DM_COLLATE;
            }
        }
#endif // WINNT_40
// @May/22/2000 <-
        break;

    case CPSUICB_REASON_SEL_CHANGED:
        // if duplex setting is changed
        if (DMPUB_DUPLEX == pCallbackParam->pCurItem->DMPubID)
        {
            // if duplex is disabled
            if (!IsValidDuplex(pOEMUIParam))
            {
                // disable ITEM_BIND_xxx.
                pOEMUIParam->pOEMOptItems[ITEM_BIND_MARGIN].Flags |= OPTIF_DISABLED;
                pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].Flags  |= OPTIF_DISABLED;
            }
            else
            {
                // enable ITEM_BIND_xxx.
                pOEMUIParam->pOEMOptItems[ITEM_BIND_MARGIN].Flags &= ~OPTIF_DISABLED;
                pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].Flags  &= ~OPTIF_DISABLED;
            }
            pOEMUIParam->pOEMOptItems[ITEM_BIND_MARGIN].Flags |= OPTIF_CHANGED;
            pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].Flags  |= OPTIF_CHANGED;
            Action = CPSUICB_ACTION_OPTIF_CHANGED;
// OBSOLETE  @Sep/24/99 ->
//          break;  // @Sep/16/98
// @Sep/24/99 <-
        }
// @Sep/16/98 ->
        // if TOMBO_ADD setting is changed
        if (DMPUB_TOMBO_ADD == pCallbackParam->pCurItem->DMPubID)
        {
            // if TOMBO is enabled
            if (SEL_YES == pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADD].Sel)
            {
                // enable ITEM_TOMBO_ADJX/Y.
                pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJX].Flags &= ~OPTIF_DISABLED;
                pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJY].Flags &= ~OPTIF_DISABLED;
            }
            else
            {
                // disable ITEM_TOMBO_ADJX/Y.
                pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJX].Flags |= OPTIF_DISABLED;
                pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJY].Flags |= OPTIF_DISABLED;
            }
            pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJX].Flags |= OPTIF_CHANGED;
            pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJY].Flags |= OPTIF_CHANGED;
            Action = CPSUICB_ACTION_OPTIF_CHANGED;
// OBSOLETE  @Sep/24/99 ->
//          break;
// @Sep/24/99 <-
        }
// @Sep/16/98 <-
// @Sep/24/99 ->
        // If ImageControl isn't set to "Standard", disable Scaling.
        dwPrevFlags = pOEMUIParam->pOEMOptItems[ITEM_SCALING].Flags;
        iNum = SearchItemByName((pOptItem = pOEMUIParam->pDrvOptItems),
                                (WORD)pOEMUIParam->cDrvOptItems,
                                UNIRES_DLL, IDS_UNIRES_IMAGECONTROL_DISPLAY);
        if (0 <= iNum && SEL_STANDARD != (pOptItem+iNum)->Sel)
            pOEMUIParam->pOEMOptItems[ITEM_SCALING].Flags |= OPTIF_DISABLED;
        else
            pOEMUIParam->pOEMOptItems[ITEM_SCALING].Flags &= ~OPTIF_DISABLED;

        if (pOEMUIParam->pOEMOptItems[ITEM_SCALING].Flags != dwPrevFlags)
        {
            pOEMUIParam->pOEMOptItems[ITEM_SCALING].Flags |= OPTIF_CHANGED;
            Action = CPSUICB_ACTION_OPTIF_CHANGED;
        }
// @Sep/24/99 <-
        break;

    case CPSUICB_REASON_APPLYNOW:
        {
            POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pOEMUIParam);   // @Oct/06/98

            if (BITTEST32(pOEMExtra->fUiOption, OPT_VARIABLE_SCALING))
                pOEMExtra->UiScale = (WORD)pOEMUIParam->pOEMOptItems[ITEM_SCALING].Sel;
            else
                pOEMExtra->UiScale = VAR_SCALING_DEFAULT;

            pOEMExtra->UiBarHeight = (WORD)pOEMUIParam->pOEMOptItems[ITEM_BAR_HEIGHT].Sel;

            if (SEL_YES == pOEMUIParam->pOEMOptItems[ITEM_BAR_SUBFONT].Sel)
                BITCLR32(pOEMExtra->fUiOption, DISABLE_BAR_SUBFONT);
            else
                BITSET32(pOEMExtra->fUiOption, DISABLE_BAR_SUBFONT);

// @Sep/16/98 ->
            if (SEL_YES == pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADD].Sel)
                BITSET32(pOEMExtra->fUiOption, ENABLE_TOMBO);
            else
                BITCLR32(pOEMExtra->fUiOption, ENABLE_TOMBO);
            pOEMExtra->nUiTomboAdjX = (SHORT)pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJX].Sel;
            pOEMExtra->nUiTomboAdjY = (SHORT)pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJY].Sel;
// @Sep/16/98 <-

            if (!BITTEST32(pOEMExtra->fUiOption, OPT_NODUPLEX))
            {
                pOEMExtra->UiBindMargin = (WORD)pOEMUIParam->pOEMOptItems[ITEM_BIND_MARGIN].Sel;

                if (SEL_YES == pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].Sel)
                    BITSET32(pOEMExtra->fUiOption, ENABLE_BIND_RIGHT);
                else
                    BITCLR32(pOEMExtra->fUiOption, ENABLE_BIND_RIGHT);
            }
        }
        Action = CPSUICB_ACTION_ITEMS_APPLIED;
        break;

    case CPSUICB_REASON_ITEMS_REVERTED:
// @Sep/16/98 ->
        if (!BITTEST32(MINIPRIVATE_DM(pOEMUIParam)->fUiOption, OPT_NODUPLEX))
        {
            // if duplex is enabled
            if (IsValidDuplex(pOEMUIParam))
            {
                // enable ITEM_BIND_xxx.
                pOEMUIParam->pOEMOptItems[ITEM_BIND_MARGIN].Flags &= ~OPTIF_DISABLED;
                pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].Flags  &= ~OPTIF_DISABLED;
            }
            else
            {
                // disable ITEM_BIND_xxx.
                pOEMUIParam->pOEMOptItems[ITEM_BIND_MARGIN].Flags |= OPTIF_DISABLED;
                pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].Flags  |= OPTIF_DISABLED;
            }
            pOEMUIParam->pOEMOptItems[ITEM_BIND_MARGIN].Flags |= OPTIF_CHANGED;
            pOEMUIParam->pOEMOptItems[ITEM_BIND_RIGHT].Flags  |= OPTIF_CHANGED;
        }

        // if TOMBO is enabled
        if (SEL_YES == pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADD].Sel)
        {
            // enable ITEM_TOMBO_ADJX/Y.
            pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJX].Flags &= ~OPTIF_DISABLED;
            pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJY].Flags &= ~OPTIF_DISABLED;
        }
        else
        {
            // disable ITEM_TOMBO_ADJX/Y.
            pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJX].Flags |= OPTIF_DISABLED;
            pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJY].Flags |= OPTIF_DISABLED;
        }
        pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJX].Flags |= OPTIF_CHANGED;
        pOEMUIParam->pOEMOptItems[ITEM_TOMBO_ADJY].Flags |= OPTIF_CHANGED;
// @Sep/24/99 ->
        // If ImageControl isn't set to "Standard", disable Scaling.
        iNum = SearchItemByName((pOptItem = pOEMUIParam->pDrvOptItems),
                                (WORD)pOEMUIParam->cDrvOptItems,
                                UNIRES_DLL, IDS_UNIRES_IMAGECONTROL_DISPLAY);
        if (0 <= iNum && SEL_STANDARD != (pOptItem+iNum)->Sel)
            pOEMUIParam->pOEMOptItems[ITEM_SCALING].Flags |= OPTIF_DISABLED;
        else
            pOEMUIParam->pOEMOptItems[ITEM_SCALING].Flags &= ~OPTIF_DISABLED;
        pOEMUIParam->pOEMOptItems[ITEM_SCALING].Flags |= OPTIF_CHANGED;
// @Sep/24/99 <-
        Action = CPSUICB_ACTION_OPTIF_CHANGED;
// @Sep/16/98 <-
        break;
    }

    return Action;
} //*** DOCPROP_CallBack


// @Sep/22/2000 ->
#ifdef DISKLESSMODEL
LONG APIENTRY PRNPROP_CallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    Action = CPSUICB_ACTION_NONE;

#if DBG
    giDebugLevel = DBG_VERBOSE;
#endif // DBG
    VERBOSE((DLLTEXT("PRNPROP_CallBack() entry.\n")));

    switch (pCallbackParam->Reason)
    {
      case CPSUICB_REASON_APPLYNOW:
        Action = CPSUICB_ACTION_ITEMS_APPLIED;
        {
            POPTITEM    pOptItem;
            WCHAR       wcHDName[ITEM_STR_LEN128];
            INT         iCnt2;
            INT         iCnt = ITEM_HARDDISK_NAMES;
            INT         cOptItem = (INT)pOEMUIParam->cDrvOptItems;
            UINT        uID = IDS_ITEM_HARDDISK;
            BYTE        ValueData = 0;  // We suppose Hard Disk isn't installed as default.

            // Check item name with several candidate ("HDD", "Memory / HDD",...).
            while (iCnt-- > 0)
            {
// yasho's point-out  @Nov/29/2000 ->
//                LoadString(ghInstance, uID, wcHDName, sizeof(wcHDName));
                LoadString(ghInstance, uID, wcHDName, sizeof(wcHDName) / sizeof(*wcHDName));
                uID++; 
// @Nov/29/2000 <-

                pOptItem = pOEMUIParam->pDrvOptItems;
                for (iCnt2 = 0; iCnt2 < cOptItem; iCnt2++, pOptItem++)
                {
                    VERBOSE((DLLTEXT("%d: %ls\n"), iCnt2, pOptItem->pName));
// @Apr/04/2002 ->
//                    if (lstrlen(pOptItem->pName))
                    if (is_valid_ptr(pOptItem->pName) && safe_strlenW(pOptItem->pName, ITEM_STR_LEN128))
// @Apr/04/2002 <-
                    {
                        // Is item name same as "Hard Disk" or something like?
                        if (!lstrcmp(pOptItem->pName, wcHDName))
                        {
                            // if Hard Disk is installed, value will be 1
                            ValueData = (BYTE)(pOptItem->Sel % 2);
                            goto _CHECKNAME_FINISH;
                        }
                    }
                }
            }
_CHECKNAME_FINISH:
            // Because pOEMUIParam->pOEMDM (pointer to private devmode) is NULL when
            // DrvDevicePropertySheets calls this callback, we use registry.
            SetPrinterData(pOEMUIParam->hPrinter, REG_HARDDISK_INSTALLED, REG_BINARY,
                           (PBYTE)&ValueData, sizeof(BYTE));
        }
        break;
    }
    return Action;
} //*** PRNPROP_CallBack
#endif // DISKLESSMODEL
// @Sep/22/2000 <-


// @Sep/24/99 ->
//////////////////////////////////////////////////////////////////////////
//  Function:  SearchItemByName
//
//  Description:  Search option item, whose DMPubID == 0, by name
//                (e.g. Halftoning, Output Bin, Image Control)
//  Parameters:
//      pOptItem     Pointer to OPTITEMs
//      cOptItem     Count of OPTITEMs
//      uiResDLL     resource dll#
//      uiResID      item's name ID in resource dll
//
//  Returns:  the item's count(>=0); -1 if fail.
//
//////////////////////////////////////////////////////////////////////////
INT SearchItemByName(POPTITEM pOptItem, WORD cOptItem, UINT uiResDLL, UINT uiResID)
{
    HINSTANCE   hInst;
    WCHAR       wszTargetName[ITEM_STR_LEN128];
    INT         iCnt = -1;

    if (UNIRES_DLL == uiResDLL)
        hInst = LoadLibrary(STR_UNIRESDLL);     // resource in UNIRES.DLL
    else if (RPDLRES_DLL == uiResDLL)
        hInst = LoadLibrary(STR_RPDLRESDLL);    // resource in RPDLRES.DLL  @Sep/27/99
    else
        hInst = ghInstance;                     // resource in this DLL(RPDLCFG.DLL)

    if (hInst)
    {
        LoadString(hInst, uiResID, wszTargetName, ITEM_STR_LEN128);
        for (iCnt = 0; iCnt < (INT)cOptItem; iCnt++, pOptItem++)
        {
            VERBOSE((DLLTEXT("** DMPubID=%d, pName=%lx **\n"), pOptItem->DMPubID, pOptItem->pName));
// @Apr/04/2002 ->
//            if (lstrlen(pOptItem->pName) && !lstrcmp(pOptItem->pName, wszTargetName))
            if (is_valid_ptr(pOptItem->pName) && safe_strlenW(pOptItem->pName, ITEM_STR_LEN128) && !lstrcmp(pOptItem->pName, wszTargetName))
// @Apr/04/2002 <-
                goto _SEARCHITEM_BYNAME_EXIT;
        }
        iCnt = -1;  // search fail
    }

_SEARCHITEM_BYNAME_EXIT:
#if DBG
    if (iCnt >= 0)
    {
        VERBOSE((DLLTEXT("** SearchItemByName():SUCCESS #%d **\n"), iCnt));
        VERBOSE((DLLTEXT("** DMPubID=%d"), pOptItem->DMPubID));
// @Apr/04/2002 ->
//        if (lstrlen(pOptItem->pName))
        if (is_valid_ptr(pOptItem->pName) && safe_strlenW(pOptItem->pName, ITEM_STR_LEN128))
// @Apr/04/2002 <-
            VERBOSE((", pName=%ls", pOptItem->pName));
        VERBOSE((" **\n"));
    }
    else
    {
        VERBOSE((DLLTEXT("** SearchItemByName():FAIL **\n")));
    }
#endif // DBG
    if (hInst != 0 && hInst != ghInstance)
        FreeLibrary(hInst);
    return iCnt;
} //*** SearchItemByName


//////////////////////////////////////////////////////////////////////////
//  Function:  SearchItemByID
//
//  Description:  Search option item by DMPubID
//
//  Parameters:
//      pOptItem     Pointer to OPTITEMs
//      cOptItem     Count of OPTITEMs
//      DMPubID      Devmode public filed ID
//
//  Returns:  the item's count(>=0); -1 if fail.
//
//////////////////////////////////////////////////////////////////////////
INT SearchItemByID(POPTITEM pOptItem, WORD cOptItem, BYTE DMPubID)
{
    INT         iCnt;

    for (iCnt = 0; iCnt < (INT)cOptItem; iCnt++, pOptItem++)
    {
        if (DMPubID == pOptItem->DMPubID)
            return iCnt;
    }
    return -1;  // search fail
} //*** SearchItemByID
// @Sep/24/99 <-


//////////////////////////////////////////////////////////////////////////
//  Function:   IsValidDuplex
//
//  Description:  Check Duplex Feature in UI
//
//  Parameters:
//      pOEMUIParam
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//////////////////////////////////////////////////////////////////////////
BOOL IsValidDuplex(POEMCUIPPARAM pOEMUIParam)
{
// not use DrvGetDriverSetting  @Sep/27/99 ->
//    DWORD   dwNeeded = 64, dwOptions, dwLastError;
//    BYTE    Output[64];
//// @Oct/06/98 ->
////  PFN_DrvGetDriverSetting DrvGetDriverSetting = pOEMUIParam->poemuiobj->pOemUIProcs->DrvGetDriverSetting;
//// @Oct/06/98 <-
//
//    SetLastError(0);
//    UI_GETDRIVERSETTING(pOEMUIParam->poemuiobj, UNIDRV_FEATURE_DUPLEX,
//                        Output, dwNeeded, &dwNeeded, &dwOptions);       // @Oct/06/98
//    dwLastError = GetLastError();
//    VERBOSE((DLLTEXT("IsValidDuplex: dwLastError=%d\n"), dwLastError));
//
//    if (ERROR_SUCCESS == dwLastError)
//    {
//        VERBOSE((DLLTEXT("** Output=%s **\n"), Output));
//
//        // if duplex is not valid, return FALSE
//        if (!lstrcmpA((LPCSTR)Output, UNIDRV_DUPLEX_NONE))
//            return FALSE;
//    }
//    return TRUE;

    POPTITEM    pOptItem;
    INT         iNum;

    iNum = SearchItemByID((pOptItem = pOEMUIParam->pDrvOptItems),
                          (WORD)pOEMUIParam->cDrvOptItems,
                          DMPUB_DUPLEX);
    return (0 <= iNum && SEL_DUPLEX_NONE != (pOptItem+iNum)->Sel);
// @Sep/27/99 <-
} //*** IsValidDuplex


extern "C" {

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDocumentPropertySheets
//////////////////////////////////////////////////////////////////////////
LRESULT APIENTRY OEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LRESULT lResult = FALSE;
    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        IsBadWritePtr(pPSUIInfo, pPSUIInfo->cbSize)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
        ||
        ( (PROPSHEETUI_REASON_INIT != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_GET_INFO_HEADER != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_GET_ICON != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_SET_RESULT != pPSUIInfo->Reason)
          &&
          (PROPSHEETUI_REASON_DESTROY != pPSUIInfo->Reason)
        )
      )
    {
        ERR((DLLTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\n")));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    VERBOSE(("\n"));
    VERBOSE((DLLTEXT("OEMDocumentPropertySheets() entry. Reason=%d\n"), pPSUIInfo->Reason));

// @Sep/22/2000 ->
#ifdef DISKLESSMODEL
    {
        DWORD   dwError, dwType, dwNeeded;
        BYTE    ValueData;
        POEMUIPSPARAM    pOEMUIPSParam = (POEMUIPSPARAM)pPSUIInfo->lParamInit;

        dwError = GetPrinterData(pOEMUIPSParam->hPrinter, REG_HARDDISK_INSTALLED, &dwType,
                                 (PBYTE)&ValueData, sizeof(BYTE), &dwNeeded);
        if (ERROR_SUCCESS != dwError)
        {
            VERBOSE((DLLTEXT("  CAN'T READ REGISTRY (%d).\n"), dwError));
            return FALSE;
        }
        else if (!ValueData)
        {
            VERBOSE((DLLTEXT("  HARD DISK ISN'T INSTALLED.\n")));
            return FALSE;
        }
    }
#endif // DISKLESSMODEL
// @Sep/22/2000 <-

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                POEMUIPSPARAM    pOEMUIPSParam = (POEMUIPSPARAM)pPSUIInfo->lParamInit;
                POEMUD_EXTRADATA pOEMExtra = MINIPRIVATE_DM(pOEMUIPSParam); // @Oct/06/98

#ifdef WINNT_40     // @Sep/02/99
                VERBOSE((DLLTEXT("** dwFlags=%lx **\n"), pOEMUIPSParam->dwFlags));
                if (pOEMUIPSParam->dwFlags & DM_NOPERMISSION)
                    BITSET32(pOEMExtra->fUiOption, UIPLUGIN_NOPERMISSION);
#endif // WINNT_40

                pPSUIInfo->UserData = NULL;

#ifndef GWMODEL     // @Sep/21/2000
                // if fax model, add fax page
                if (BITTEST32(pOEMExtra->fUiOption, FAX_MODEL) &&
                    (pPSUIInfo->UserData = (LPARAM)HeapAlloc(pOEMUIPSParam->hOEMHeap,
                                                             HEAP_ZERO_MEMORY,
                                                             sizeof(UIDATA))))
                {
                    PROPSHEETPAGE   Page;
                    PUIDATA         pUiData = (PUIDATA)pPSUIInfo->UserData;
                    FILEDATA        FileData;   // <-pFileData (formerly use MemAllocZ) @Mar/17/2000

                    // read PRINT_DONE flag from shared data file  @Oct/19/98
                    FileData.fUiOption = 0;
// @Mar/01/2002 ->
//                    RWFileData(&FileData, pOEMExtra->SharedFileName, GENERIC_READ);
                    RWFileData(&FileData, pOEMExtra->SharedFileName, sizeof(pOEMExtra->SharedFileName), GENERIC_READ);
// @Mar/01/2002 <-
                    VERBOSE((DLLTEXT("** Shared File Name=%ls **\n"), pOEMExtra->SharedFileName));
                    // set PRINT_DONE flag
                    if (BITTEST32(FileData.fUiOption, PRINT_DONE))
                        BITSET32(pOEMExtra->fUiOption, PRINT_DONE);

                    pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;
                    pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
                    pUiData->pOEMExtra = pOEMExtra;

                    // Init property page.
// Use SecureZeroMemory  @Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
                    memset(&Page, 0, sizeof(PROPSHEETPAGE));
#else
                    SecureZeroMemory(&Page, sizeof(PROPSHEETPAGE));
#endif
// Mar/29/2002 <-
                    Page.dwSize = sizeof(PROPSHEETPAGE);
                    Page.dwFlags = PSP_DEFAULT;
                    Page.hInstance = ghInstance;
                    Page.pszTemplate = MAKEINTRESOURCE(IDD_FAXMAIN);
                    Page.pfnDlgProc = FaxPageProc;     // add (DLGPROC) @Aug/30/99
                    Page.lParam = (LPARAM)pUiData;

                    // Add property sheets.
                    lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                                                         CPSFUNC_ADD_PROPSHEETPAGE,
                                                         (LPARAM)&Page, 0);
                    pUiData->hPropPage = (HANDLE)lResult;
                    VERBOSE((DLLTEXT("** INIT: lResult=%x **\n"), lResult));
                    lResult = (lResult > 0)? TRUE : FALSE;
                }
#else  // GWMODEL
#ifdef JOBLOGSUPPORT_DLG
                // add Job/Log page
                if ((pPSUIInfo->UserData = (LPARAM)Heap