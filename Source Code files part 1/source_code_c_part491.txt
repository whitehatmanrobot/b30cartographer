IWizImport
//
//  The import wizard to import public key related files to a certificate
//  store
//
//  dwFlags can be set to any combination of the following flags:
//  CRYPTUI_WIZ_NO_UI                           No UI will be shown.  Otherwise, User will be
//                                              prompted by a wizard.
//  CRYPTUI_WIZ_IMPORT_ALLOW_CERT               Allow importing certificate
//  CRYPTUI_WIZ_IMPORT_ALLOW_CRL                Allow importing CRL(certificate revocation list)
//  CRYPTUI_WIZ_IMPORT_ALLOW_CTL                Allow importing CTL(certificate trust list)
//  CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE     user will not be allowed to change
//                                              the hDesCertStore in the wizard page
//  Please notice that if neither of following three flags is in dwFlags, default to is
//  allow everything.
//  CRYPTUI_WIZ_IMPORT_ALLOW_CERT
//  CRYPTUI_WIZ_IMPORT_ALLOW_CRL
//  CRYPTUI_WIZ_IMPORT_ALLOW_CTL
//
//
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags:
//      hwndParent:         Ignored
//      pwszWizardTitle:    Ignored
//      pImportSubject:     IN Required:    The subject to import.
//      hDesCertStore:      IN Optional:    The destination certficate store
//
//  If CRYPTUI_WIZ_NO_UI is not set in dwFlags:
//      hwndPrarent:        IN Optional:    The parent window for the wizard
//      pwszWizardTitle:    IN Optional:    The title of the wizard
//                                          If NULL, the default will be IDS_IMPORT_WIZARD_TITLE
//      pImportSubject:     IN Optional:    The file name to import.
//                                          If NULL, the wizard will prompt user to enter the file name
//      hDesCertStore:      IN Optional:    The destination certificate store where the file wil be
//                                          imported to.  The store should be opened with
//                                          flag CERT_STORE_SET_LOCALIZED_NAME_FLAG.  If NULL, the wizard will prompt user to select
//                                          a certificate store.
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizImport(
     DWORD                               dwFlags,
     HWND                                hwndParent,
     LPCWSTR                             pwszWizardTitle,
     PCCRYPTUI_WIZ_IMPORT_SRC_INFO       pImportSrc,
     HCERTSTORE                          hDestCertStore
);


//-------------------------------------------------------------------------
//
//	Struct to define the information needed to build a new CTL
//
//  CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO
{
	DWORD			    dwSize;				    //Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_NEW_CTL)
    PCERT_ENHKEY_USAGE  pSubjectUsage;          //Optioanl: The purpose of the CTL
    LPWSTR              pwszListIdentifier;     //Optional: The string to identify the CTL
    LPCSTR              pszSubjectAlgorithm;    //Optional: The hashing algorithm.
                                                //          Currently, only SHA1 or MD5 hashing is supported
    HCERTSTORE          hCertStore;             //Optional: The certificate in the CTL.  Only the certificates
                                                //          with the enhanced key usage specified by pSubjectUsage
                                                //          will be included in the CTL
    FILETIME            NextUpdate;             //Optional: The next update time of the CTL.  If the value
                                                //          is more than 99 month from the current system time,
                                                //          the value will be ignored.
    LPWSTR              pwszFriendlyName;       //Optional: The friendly name of the CTL
    LPWSTR              pwszDescription;        //Optional: The description of the CTL
}CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO, *PCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO *PCCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO;

//-------------------------------------------------------------------------
//
//	Valid values for dwSourceChoice for CRYPTUI_WIZ_BUILDCTL_SRC_INFO
//-------------------------------------------------------------------------
#define         CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL       1
#define         CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL            2

//-------------------------------------------------------------------------
//
//	Struct to define the source of certBuildCTL wizard
//
//  CRYPTUI_WIZ_BUILDCTL_SRC_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_SRC_INFO
{
	DWORD			dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_SRC_INFO)
    DWORD           dwSourceChoice;     //Required: indicate the source from which to build the CTL
                                        //          if can be one of the following:
                                        //          CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL
                                        //          CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL
    union
    {
        PCCTL_CONTEXT                       pCTLContext;    //Required if dwSourceChoice == CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL
                                                            //          An existing CTL based on which a new CTL is to be built
        PCCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO pNewCTLInfo;        //Required if dwSourceChoise == CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL
    };
}CRYPTUI_WIZ_BUILDCTL_SRC_INFO, *PCRYPTUI_WIZ_BUILDCTL_SRC_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_SRC_INFO *PCCRYPTUI_WIZ_BUILDCTL_SRC_INFO;

//-------------------------------------------------------------------------
//
//	Valid values for dwDestinationChoice for CRYPTUI_WIZ_BUILDCTL_DEST_INFO
//-------------------------------------------------------------------------
#define         CRYPTUI_WIZ_BUILDCTL_DEST_CERT_STORE     1
#define         CRYPTUI_WIZ_BUILDCTL_DEST_FILE           2
//-------------------------------------------------------------------------
//
//	Struct to define the desination of certBuildCTL wizard
//
//  CRYPTUI_WIZ_BUILDCTL_DEST_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_DEST_INFO
{
	DWORD					dwSize;				 //Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_DEST_INFO)
	DWORD					dwDestinationChoice; //Required:	indicate the type of the desination:
                                                 //          If can one of the following:
                                                 //          CRYPTUI_WIZ_BUILDCTL_DEST_CERT_STORE
                                                 //          CRYPTUI_WIZ_BUILDCTL_DEST_FILE
    union
	{
		LPCWSTR          	pwszFileName;	
        HCERTSTORE          hCertStore;
    };

}CRYPTUI_WIZ_BUILDCTL_DEST_INFO, *PCRYPTUI_WIZ_BUILDCTL_DEST_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_DEST_INFO *PCCRYPTUI_WIZ_BUILDCTL_DEST_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizBuildCTL
//
//  Build a new CTL or modify an existing CTL.   The UI for wizard will
//  always show in this case
//
//
//  dwFlags:            IN  Optional:   Can be set to the any combination of the following:
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION.
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE
//  hwndParnet:         IN  Optional:   The parent window handle
//  pwszWizardTitle:    IN  Optional:   The title of the wizard
//                                      If NULL, the default will be IDS_BUILDCTL_WIZARD_TITLE
//  pBuildCTLSrc:       IN  Optional:   The source from which the CTL will be built
//  pBuildCTLDest:      IN  Optional:   The desination where the newly
//                                      built CTL will be stored
//  ppCTLContext:       OUT Optaionl:   The newly build CTL
//
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizBuildCTL(
    IN              DWORD                                   dwFlags,
    IN  OPTIONAL    HWND                                    hwndParent,
    IN  OPTIONAL    LPCWSTR                                 pwszWizardTitle,
    IN  OPTIONAL    PCCRYPTUI_WIZ_BUILDCTL_SRC_INFO         pBuildCTLSrc,
    IN  OPTIONAL    PCCRYPTUI_WIZ_BUILDCTL_DEST_INFO        pBuildCTLDest,
    OUT OPTIONAL    PCCTL_CONTEXT                           *ppCTLContext
);


//-------------------------------------------------------------------------
//
//	Valid values for dwSubjectChoice in CRYPTUI_WIZ_EXPORT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_EXPORT_CERT_CONTEXT 			        1
#define     CRYPTUI_WIZ_EXPORT_CTL_CONTEXT  			        2
#define     CRYPTUI_WIZ_EXPORT_CRL_CONTEXT  			        3
#define     CRYPTUI_WIZ_EXPORT_CERT_STORE   			        4
#define     CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY   	5

//-------------------------------------------------------------------------
//
//	Struct to define the object to be exported and where to export it to
//
//  CRYPTUI_WIZ_EXPORT_SUBJECT_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_EXPORT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_EXPORT_INFO)
    LPCWSTR                 pwszExportFileName; //Required if the CRYPTUI_WIZ_NO_UI flag is set, Optional otherwise.
                                                //The fully qualified file name to export to, if this is
                                                //non-NULL and the CRYPTUI_WIZ_NO_UI flag is NOT set, then it is
                                                //displayed to the user as the default file name
	DWORD					dwSubjectChoice;	//Required:	indicate the type of the subject:
                                                //          If can one of the following:
                                                //          CRYPTUI_WIZ_EXPORT_CERT_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CTL_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CRL_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CERT_STORE
						                        //	        CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY
    union
	{
	PCCERT_CONTEXT      pCertContext;
        PCCTL_CONTEXT       pCTLContext;
        PCCRL_CONTEXT       pCRLContext;
        HCERTSTORE          hCertStore;
    };

    DWORD                   cStores;            // Optional: count of extra stores to search for the certs in the
                                                //           trust chain if the chain is being exported with a cert.
                                                //           this is ignored if dwSubjectChoice is anything other
                                                //           than CRYPTUI_WIZ_EXPORT_CERT_CONTEXT
    HCERTSTORE *            rghStores;          // Optional: array of extra stores to search for the certs in the
                                                //           trust chain if the chain is being exported with a cert.
                                                //           this is ignored if dwSubjectChoice is anything other
                                                //           than CRYPTUI_WIZ_EXPORT_CERT_CONTEXT

}CRYPTUI_WIZ_EXPORT_INFO, *PCRYPTUI_WIZ_EXPORT_INFO;

typedef const CRYPTUI_WIZ_EXPORT_INFO *PCCRYPTUI_WIZ_EXPORT_INFO;


//-------------------------------------------------------------------------
//
//	Valid values for dwExportFormat in CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_EXPORT_FORMAT_DER                   1
#define     CRYPTUI_WIZ_EXPORT_FORMAT_PFX                   2
#define     CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7                 3
#define     CRYPTUI_WIZ_EXPORT_FORMAT_BASE64                4
#define     CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE 5   // NOTE: not currently supported!!

//-------------------------------------------------------------------------
//
//	Struct to define the information needed to export a CERT_CONTEXT
//
//  CRYPTUI_WIZ_EXPORT_NOUI_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_EXPORT_NOUI_INFO)
	DWORD					dwExportFormat;	    //Required:
                                                //          It can be one of the following:
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_DER
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_PFX
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE

    BOOL                    fExportChain;       //Required
    BOOL                    fExportPrivateKeys; //Required 
    LPCWSTR                 pwszPassword;       //Required if the fExportPrivateKeys boolean is TRUE, otherwise,
                                                //it is ignored
    BOOL                    fStrongEncryption;  //Required if dwExportFormat is CRYPTUI_WIZ_EXPORT_FORMAT_PFX
                                                //Note that if this flag is TRUE then the PFX blob produced is
                                                //NOT compatible with IE4.

}CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO, *PCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO;

typedef const CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO *PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizExport
//
//  The export wizard to export public key related objects to a file
//
//  If dwFlags is set to CRYPTUI_WIZ_NO_UI, no UI will be shown.  Otherwise,
//  User will be prompted for input through a wizard.
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags:
//      hwndParent:         Ignored
//      pwszWizardTitle:    Ignored
//      pExportInfo:        IN Required:    The subject to export.
//      pvoid:              IN Required:    Contains information about how to do the export based on what
//                                          is being exported
//
//                                          dwSubjectChoice                     INPUT TYPE
//                                          -------------------------------------------------------------------------
//                                          CRYPTUI_WIZ_EXPORT_CERT_CONTEXT     PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
//                                          CRYPTUI_WIZ_EXPORT_CTL_CONTEXT      NULL
//                                          CRYPTUI_WIZ_EXPORT_CRL_CONTEXT      NULL
//                                          CRYPTUI_WIZ_EXPORT_CERT_STORE       NULL
//
//  If CRYPTUI_WIZ_NO_UI is not set in dwFlags:
//      hwndPrarent:        IN Optional:    The parent window for the wizard
//      pwszWizardTitle:    IN Optional:    The title of the wizard
//                                          If NULL, the default will be IDS_EXPORT_WIZARD_TITLE
//      pExportInfo:        IN Required:    The subject to export.
//      pvoid:              IN Optional:    Contains information about how to do the export based on what
//                                          is being exported.  See above table for values, if this is non-NULL
//                                          the values are displayed to the user as the default choices.
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizExport(
     DWORD                                  dwFlags,
     HWND                                   hwndParent,
     LPCWSTR                                pwszWizardTitle,
     PCCRYPTUI_WIZ_EXPORT_INFO              pExportInfo,
     void                                   *pvoid
);



//-------------------------------------------------------------------------
//valid values for dwSubjectChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE           0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB           0x02


//-------------------------------------------------------------------------
//valid values for dwSigningCertChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_CERT                   0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_STORE                  0x02
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK                    0x03

//-------------------------------------------------------------------------
//valid values for dwAddtionalCertChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
//include the entire certificate trust chain in the signature
#define CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN               0x00000001

//include the entilre certificate trust chain, with the exception of the root
//certificate, in the signature
#define CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT       0x00000002

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO
//
//  dwSize			IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO)
//  pGuidSubject    IN Required: Idenfity the sip functions to load
//  cbBlob			IN Required: the size of BLOB, in bytes
//  pbBlob		    IN Required: the pointer to the BLOB
//  pwszDispalyName IN Optional: the display name of the BLOB to sign.
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO
{
    DWORD               dwSize;			
    GUID                *pGuidSubject;
    DWORD               cbBlob;				
    BYTE                *pbBlob;			
    LPCWSTR             pwszDisplayName;
}CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO
//
//	dwSize				IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO)
//  cCertStore          IN Required: The acount of certificate store array that includes potentical sining certs
//  rghCertStore        IN Required: The certificate store array that includes potential signing certs
//  pFilterCallback     IN Optional: The filter call back function for display the certificate
//  pvCallbackData      IN Optional: The call back data
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO
{
	DWORD               dwSize;	
	DWORD               cCertStore;			
    HCERTSTORE          *rghCertStore;
    PFNCFILTERPROC      pFilterCallback;
    void *              pvCallbackData;
}CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO
//
//	dwSize				        IN Required: should be set to sizeof(CRYPT_WIZ_DIGITAL_SIGN_PVK_FILE_INFO)
//  pwszPvkFileName             IN Required: the PVK file name
//  pwszProvName                IN Required: the provider name
//  dwProvType                  IN Required: the provider type
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO
{
	DWORD                   dwSize;
    LPWSTR                  pwszPvkFileName;
    LPWSTR                  pwszProvName;
    DWORD                   dwProvType;
}CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO;

//-------------------------------------------------------------------------
//
// valid values for dwPvkChoice in CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE        0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV        0x02


//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO
//
//	dwSize				        IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO)
//  pwszSigningCertFileName     IN Required: the file name that contains the signing cert(s)
//  dwPvkChoice                 IN Required: Indicate the private key type:
//                                           It can be one of the following:
//                                           CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE
//                                           CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV
//  pPvkFileInfo                IN Required if dwPvkChoice == CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE
//  pPvkProvInfo                IN Required if dwPvkContainer== CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO
{
	DWORD                   dwSize;
    LPWSTR                  pwszSigningCertFileName;
    DWORD					dwPvkChoice;		
    union
	{
        PCCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO      pPvkFileInfo;
        PCRYPT_KEY_PROV_INFO                        pPvkProvInfo;
    };

}CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO;

//-------------------------------------------------------------------------
//
// valid values for dwAttrFlags in CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO struct
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL         0x0001
#define     CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL         0x0002

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO
//
//   dwSize			        IN Required:  should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO)
//   dwAttrFlags            IN Required:  Flag to indicate signing options.
//                                        It can be one of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL
//   pwszDescription        IN Optional:  The description of the signing subject
//   pwszMoreInfoLocation   IN Optional:  the localtion to get more information about file
//                                        this information will be shown upon download time
//   pszHashAlg             IN Optional:  the hashing algorithm for the signature
//                                        NULL means using SHA1 hashing algorithm
//   pwszSigningCertDisplayString  IN Optional: The display string to be displayed on the
//                                        signing certificate wizard page.  The string should
//                                        prompt user to select a certificate for a particular purpose
//   hAddtionalCertStores  IN Optional:   the addtional cert store to add to the signature
//   psAuthenticated	    IN Optional:  user supplied authenticated attributes added to the signature
//   psUnauthenticated	    IN Optional:  user supplied unauthenticated attributes added to the signature
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO
{
	DWORD		            dwSize;			
    DWORD                   dwAttrFlags;
    LPCWSTR                 pwszDescription;
	LPCWSTR				    pwszMoreInfoLocation;		
    LPCSTR                  pszHashAlg;
    LPCWSTR                 pwszSigningCertDisplayString;
    HCERTSTORE              hAdditionalCertStore;
	PCRYPT_ATTRIBUTES		psAuthenticated;	
	PCRYPT_ATTRIBUTES		psUnauthenticated;	
}CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO;
//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_DIGITAL_SIGN_INFO
//
// dwSize			    IN Required: Has to be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO)
// dwSubjectChoice	    IN Required if CRYPTUI_WIZ_NO_UI is set in dwFlags of the CryptUIWizDigitalSigning,         :
//                         Optional if CRYPTUI_WIZ_NO_UI is not set in dwFlags of the CryptUIWizDigitalSigning
//                                  Indicate whether to sign a file or to sign a memory BLOB.
//                                  0 means promting user for the file to sign
//                                  It can be one of the following:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE
//			                        CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB
//
//
//pwszFileName	        IN Required if dwSubjectChoice==CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE
//pSignBlobInfo	        IN Required if dwSubhectChoice==CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB
//
//dwSigningCertChoice   IN Optional: Indicate the signing certificate.
//                                  0 means using the certificates in "My" store"
//                                  It can be one of the following choices:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_CERT
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_STORE
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//                                  If CRYPTUI_WIZ_NO_UI is set in dwFlags of the CryptUIWizDigitalSigning,
//                                  dwSigningCertChoice has to be CRYPTUI_WIZ_DIGITAL_SIGN_CERT or
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//
//pSigningCertContext       IN Required if dwSigningCertChoice==CRYPTUI_WIZ_DIGITAL_SIGN_CERT
//pSigningCertStore         IN Required if dwSigningCertChoice==CRYPTUI_WIZ_DIGITAL_SIGN_STORE
//pSigningCertPvkInfo       IN Required if dwSigningCertChoise==CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//
//pwszTimestampURL      IN Optional: The timestamp URL address
//
//dwAdditionalCertChoice IN Optional: Indicate additional certificates to be included in the signature.                                                       //
//                                  0 means no addtional certificates will be added
//                                  The following flags are mutually exclusive.
//                                  Only one of them can be set:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT
//
//
//pSignExtInfo         IN Optional: The extended information for signing
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_INFO
{
	DWORD			                            dwSize;			
	DWORD					                    dwSubjectChoice;	
	union
	{
		LPCWSTR                                 pwszFileName;	
		PCCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO    pSignBlobInfo;	
	};

    DWORD                                       dwSigningCertChoice;
    union
    {
        PCCERT_CONTEXT                              pSigningCertContext;
        PCCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO       pSigningCertStore;
        PCCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO    pSigningCertPvkInfo;
    };

    LPCWSTR                                     pwszTimestampURL;
    DWORD                                       dwAdditionalCertChoice;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO    pSignExtInfo;

}CRYPTUI_WIZ_DIGITAL_SIGN_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT
//
//  dwSize			 set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT)
//  cbBlob			 the size of pbBlob.  In bytes
//  pbBlob		     the signed BLOB
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT
{
    DWORD               dwSize;			
    DWORD               cbBlob;				
    BYTE                *pbBlob;			
}CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT, *PCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT *PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT;

//-----------------------------------------------------------------------
//
// CryptUIWizDigitalSign
//
//  The wizard to digitally sign a document or a BLOB.
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags, no UI will be shown.  Otherwise,
//  User will be prompted for input through a wizard.
//
//  dwFlags:            IN  Required:
//  hwndParnet:         IN  Optional:   The parent window handle
//  pwszWizardTitle:    IN  Optional:   The title of the wizard
//                                      If NULL, the default will be IDS_DIGITAL_SIGN_WIZARD_TITLE
//  pDigitalSignInfo:   IN  Required:   The information about the signing process
//  ppSignContext       OUT Optional:   The context pointer points to the signed BLOB
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizDigitalSign(
     IN                 DWORD                               dwFlags,
     IN     OPTIONAL    HWND                                hwndParent,
     IN     OPTIONAL    LPCWSTR                             pwszWizardTitle,
     IN                 PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO     pDigitalSignInfo,
     OUT    OPTIONAL    PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT  *ppSignContext);


BOOL
WINAPI
CryptUIWizFreeDigitalSignContext(
     IN  PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT   pSignContext);


//-------------------------------------------------------------------------
//valid values for dwPageChoice in CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//-------------------------------------------------------------------------

#define     CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES       0x0001
#define     CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES       0x0002
#define     CRYPTUI_WIZ_DIGITAL_SIGN_CUSTOM_SIGNING_OPTION_PAGES        0x0004
#define     CRYPTUI_WIZ_DIGITAL_SIGN_ALL_SIGNING_OPTION_PAGES           0x0008

#define     CRYPTUI_WIZ_DIGITAL_SIGN_WELCOME_PAGE                       0x0100
#define     CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE                     0x0200
#define     CRYPTUI_WIZ_DIGITAL_SIGN_CONFIRMATION_PAGE                  0x0400


//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//
//	dwSize				IN Required:    should be set to sizeof(CRYPTUI_WIZ_SIGN_GET_PAGE_INFO)
//  dwPageChoice:       IN Required:    It should one of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_ALL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_CUSTOM_SIGNING_OPTION_PAGES
//                                      It can also be ORed with any of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_WELCOME_PAGE
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_CONFIRMATION_PAGE
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE
//                                      If user tries to sign a BLOB, CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE
//                                      should not be set
//  dwFlags;            IN Optional:    Flags and has to be set to 0
//  hwndParent          IN Optional:    The parent window of the dialogue
//  pwszPageTitle       IN Optional:    The title for the pages and the message boxes.
//  pDigitalSignInfo    IN Optional:    the addtional information for signing
//  pPropPageCallback   IN Optional:    this callback will be called when each page that is
//                                      returned in the CryptUIGetViewSignaturesPages call
//                                      is about to be created or destroyed.  if this is NULL no
//                                      callback is made.
//  pvCallbackData      IN Optional:    this is uniterpreted data that is passed back when the
//                                      when pPropPageCallback is made
//  fResult             OUT:            The result of signing
//  dwError             OUT:            The value of GetLastError() if fResult is FALSE
//  pSignContext        OUT:            The context pointer to the signed BLOB.  User needs to free
//                                      the blob by CryptUIWizDigitalSignFreeContext
//  dwReserved          Reserved:       The private data used by the signing process.
//                                      must be set to NULL
//  pvSignReserved      Reserved:       The private data used by the signing process
//                                      must be set to NULL
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_GET_SIGN_PAGE_INFO
{
	DWORD				                dwSize;	
    DWORD                               dwPageChoice;
    DWORD                               dwFlags;
    HWND                                hwndParent;
    LPWSTR                              pwszPageTitle;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO     pDigitalSignInfo;
    PFNCPROPPAGECALLBACK                pPropPageCallback;
    void *                              pvCallbackData;
    BOOL                                fResult;
    DWORD                               dwError;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT  pSignContext;
    DWORD                               dwReserved;
    void                                *pvSignReserved;
}CRYPTUI_WIZ_GET_SIGN_PAGE_INFO, *PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO;

typedef const CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *PCCRYPTUI_WIZ_GET_SIGN_PAGE_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizGetDigitalSignPages
//
//  Get specific wizard pages from the CryptUIWizDigitalSign wizard.
//  Application can include the pages to other wizards.  The pages will
//  gather user inputs throught the new "Parent" wizard.
//  After user clicks the finish buttion, signing process will start the signing
//  and return the result in fResult and dwError field of CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//  struct.  If not enough information can be gathered through the wizard pages,
//  user should supply addtional information in pSignGetPageInfo.
//
//
// pSignGetPageInfo    IN   Required:   The struct that user allocate.   It can be used
//                                      to supply additinal information which is not gathered
//                                      from the selected wizard pages
// prghPropPages,      OUT  Required:   The wizard pages returned.  Please
//                                      notice the pszTitle of the struct is set to NULL
// pcPropPages         OUT  Required:   The number of wizard pages returned
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizGetDigitalSignPages(
     IN     PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO     pSignGetPageInfo,
     OUT    PROPSHEETPAGEW                      **prghPropPages,
     OUT    DWORD                               *pcPropPages);

BOOL
WINAPI
CryptUIWizFreeDigitalSignPages(
            IN PROPSHEETPAGEW    *rghPropPages,
            IN DWORD             cPropPages
            );








#pragma pack()

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // _CRYPTUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\external\inc\proofbse.h ===
/********************************************************************
  ProofBase.h - Base API definitions for CSAPI, CTAPI, & CHAPI
	Speller, Thesaurus, and Hyphenator

  Version 3.0 - all api's

    History:
	5/97	DougP	Created
	12/97	DougP	Copied from ProofAPI.h and Separated into tool section files

    The Natural Language Group maintains this file.

  1997 Microsoft Corporation
********************************************************************/

#if !defined(PROOFBASE_H)
#define PROOFBASE_H

#pragma pack(push, proofapi_h, 8)	// default alignment

#include "vendor.h"

  // you may wish to include lid.h for some convenient langid defs
#if !defined(lidUnknown)
#	define lidUnknown	0xffff
#endif

/*************************************************************
     PART 1 - Structure Defs
**************************************************************/
/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) --------- */

/* hardcoded ordinals are the exported dll entry points */
// individual def files have these as well so be sure to change them
// if you change these
#define idllProofVersion		20
#define idllProofInit			21
#define idllProofTerminate		22
#define idllProofOpenLex		23
#define idllProofCloseLex		24
#define idllProofSetOptions		25
#define idllProofGetOptions		26

typedef unsigned long PTEC;		// ptec

/******************* Proofing Tool Error Codes ************************/
	/* Major Error Codes in low two bytes (WORD) of PTEC */
enum {
	ptecNoErrors,
	ptecOOM,			/* memory error */
	ptecModuleError,	/* Something wrong with parameters, or state of spell module. */
	ptecIOErrorMainLex,	 /* Read,write,or share error with Main Dictionary. */
	ptecIOErrorUserLex,	 /* Read,write,or share error with User Dictionary. */
	ptecNotSupported,	/* No support for requested operation */
	ptecBufferTooSmall,	/* Insufficient room for return info */
	ptecNotFound,		/* Hyphenator and Thesaurus only */
	ptecModuleNotLoaded,	/* underlying module not loaded (Glue Dll's) */
};

/* Minor Error Codes in high two bytes of PTEC */
/* (Not set unless major code also set) */
enum {
	ptecModuleAlreadyBusy=128,	/* For non-reentrant code */
	ptecInvalidID,				/* Not yet inited or already terminated.*/
	ptecInvalidWsc,				/* Illegal values in WSC struct (speller only) */
	ptecInvalidMainLex,		/* Mdr not registered with session */
	ptecInvalidUserLex,		/* Udr not registered with session */
	ptecInvalidCmd,				/* Command unknown */
	ptecInvalidFormat,			/* Specified dictionary not correct format */
	ptecOperNotMatchedUserLex,	/* Illegal operation for user dictionary type. */
	ptecFileRead,				/* Generic read error */
	ptecFileWrite,				/* Generic write error */
	ptecFileCreate,				/* Generic create error */
	ptecFileShare,				/* Generic share error */
	ptecModuleNotTerminated,	/* Module not able to be terminated completely.*/
	ptecUserLexFull,			/* Could not update Udr without exceeding limit.*/
	ptecInvalidEntry,			/* invalid chars in string(s) */
	ptecEntryTooLong,			/* Entry too long, or invalid chars in string(s) */
	ptecMainLexCountExceeded,	/* Too many Mdr references */
	ptecUserLexCountExceeded,	/* Too many udr references */
	ptecFileOpenError,			/* Generic Open error */
	ptecFileTooLargeError,		/* Generic file too large error */
	ptecUserLexReadOnly,		/* Attempt to add to or write RO udr */
	ptecProtectModeOnly,		/* (obsolete) */
	ptecInvalidLanguage,		/* requested language not available */
};


#define ProofMajorErr(x) LOWORD(x)
#define ProofMinorErr(x) HIWORD(x)

/************* Structure def macros *************
Smoke and mirrors to allow initialization of some members when
using C++
***********************************/
#if !defined(__cplusplus)
#	define STRUCTUREBEGIN(x) typedef struct {
#	define STRUCTUREEND0(x) } x;
#	define STRUCTUREEND1(x, y) } x;
#	define STRUCTUREEND2(x, y, z) } x;
#	define STRUCTUREEND3(x, y, z, w) } x;
#else
#	define STRUCTUREBEGIN(x) struct x {
#	define STRUCTUREEND0(x) };
#	define STRUCTUREEND1(x, y) public: x() : y {} };
#	define STRUCTUREEND2(x, y, z) public: x() : y, z {} };
#	define STRUCTUREEND3(x, y, z, w) public: x() : y, z, w {} };
#endif

typedef DWORD PROOFVERNO;	// version

  /* Proof Information Structure - return info from ToolVersion */
STRUCTUREBEGIN(PROOFINFO)	// info
	WCHAR			*pwszCopyright;	/* pointer to copyright buffer -
											can be NULL if size is zero */
	PROOFVERNO	versionAPI;	  /* API */
	PROOFVERNO	versionVendor;	/* includes buildnumber */
	VENDORID		vendorid; 	/* from vendor.h */
	  /* size of copyright buffer in chars - client sets */
	DWORD			cchCopyright;	/* no error if too small or zero */
	DWORD			xcap;	/* tool dependent */
STRUCTUREEND2(PROOFINFO, pwszCopyright(0), cchCopyright(0))

/* xcap is the bitwise-or of */
enum {
	xcapNULL					=	0x00000000,
	xcapWildCardSupport			=	0x00000001,	// Speller only
	xcapMultiLexSupport			=	0x00000002,
	xcapUserLexSupport			=	0x00000008,	// a must for spellers
	xcapLongDefSupport			=	0x00000010,	// Thesaurus only
	xcapExampleSentenceSupport	=	0x00000020,	// Thesaurus only
	xcapLemmaSupport			=	0x00000040,	// Thesaurus only
	xcapAnagramSupport			=	0x00000100,	// Speller only
};	// xcap

typedef void * PROOFLEX;	// lex

typedef enum {
	lxtChangeOnce=0,
	lxtChangeAlways,
	lxtUser,
	lxtExclude,
	lxtMain,
	lxtMax,
	lxtIgnoreAlways=lxtUser,
} PROOFLEXTYPE;	// lxt


  // note this API does not support external user dictionaries with
  // Change (lxtChangeAlways or lxtChangeOnce) properties
  // It does support either UserLex (the norm) or Exclude types
  // Opening a udr with type Exclude automatically makes it apply to
  // the entire session
STRUCTUREBEGIN(PROOFLEXIN)	/* Dictionary Input Info - lxin */
	const WCHAR		*pwszLex;	// full path of dictionary to open
	BOOL			fCreate;	/* create if not already exist? (UDR's only) */
	PROOFLEXTYPE	lxt;	/* lxtMain, lxtUser, or lxtExclude (Speller UDR's only) */
	LANGID			lidExpected;	// expected LANGID of dictionary
STRUCTUREEND3(PROOFLEXIN, lidExpected(lidUnknown), fCreate(TRUE), lxt(lxtMain))


STRUCTUREBEGIN(PROOFLEXOUT)    /* Dictionary Output Info - lxout */
	WCHAR		*pwszCopyright;	/* pointer to copyright buffer (MDR only)
										-- can be NULL if size (below) is zero*/
	PROOFLEX	lex;			/* id for use in subsequent calls */
	DWORD		cchCopyright;	/* client sets - no error if too small or zero */
	PROOFVERNO	version;		/* version of lexfile - includes buildnumber */
	BOOL		fReadonly;		/* set if can't be written on */
	LANGID		lid;			/* LANGID actually used */
STRUCTUREEND2(PROOFLEXOUT, pwszCopyright(0), cchCopyright(0))

typedef void *PROOFID;	// id (or sid, hid, or tid)

#define PROOFMAJORVERSION(x)			(HIBYTE(HIWORD(x)))
#define PROOFMINORVERSION(x)			(LOBYTE(HIWORD(x)))
#define PROOFMAJORMINORVERSION(x)		(HIWORD(x))
#define PROOFBUILDNO(x)					(LOWORD(x))
#define PROOFMAKEVERSION1(major, minor, buildno)	(MAKELONG(buildno, MAKEWORD(minor, major)))
#define PROOFMAKEVERSION(major, minor)	PROOFMAKEVERSION1(major, minor, 0)

#define PROOFTHISAPIVERSION				PROOFMAKEVERSION(3, 0)

STRUCTUREBEGIN(PROOFPARAMS)	// xpar
	DWORD	versionAPI;	// API version requested
STRUCTUREEND1(PROOFPARAMS, versionAPI(PROOFTHISAPIVERSION))



/*************************************************************
     PART 2 - Function Defs
**************************************************************/
#if defined(__cplusplus)
extern "C" {
#endif

/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) -------------- 

the functions in this section are for documentation only -
separate versions exist for each tool.

  ---------------------------------------------- */
// ****************************************************************
//  ******** PROOFVERSION ****************
//  This is the only routine that can be called outside of a session.
//	ToolInit begins a session.

//	The version numbers are in hex format with  
//	the high byte representing the major version number,
//	the next byte the minor revision number, and the
//	low order bytes represent an optional build number. 
//	For example, version 1.00 is 0x01000000.  Version 2.13
//	is 0x020d0000.  Engines that support
//	this API should return 0x03000000 for iAPIVersion.

//	The engine ID identifies the core engine creator.  The list
//	in vendor.h identifies the possible values.  For example,
//	the Inso derived speller returns VendorIdInso.   iVendorVersion
//	is up to the vendor to manage and determine.

//	This routine may return in xcap the functionality
//	supported by the module.  Since modules are usually
//	dynamically linked, the application should read the
//	information and verify that required functionality is
//	present.
// PTEC WINAPI ToolVersion(ToolInfo *pInfo);
typedef PTEC (WINAPI *PROOFVERSION) (PROOFINFO *pinfo);

// ***********************************************************
// *** ToolInit
// This is the entry point for a session.  With the exception
// of ToolVersion, this routine must return successfully before
// use of any other routines.  ToolInit initializes internal
// structures and resources needed for subsequent calls into the
// module.  For example, SpellerInit initializes the UserLex,
// ChangeOnce, and ChangeAlways built-in UDR's.  In general,
// modules allocate and free resources as needed, transparent to
// the application.  pToolId is the handle to those variables.
// Modules store any data from the PROOFPARAMS structure internally
// and do not rely on the data in the structure remaining intact.

// PTEC WINAPI ToolInit(PROOFID *pToolid, const PROOFPARAMS *pxpar);
typedef PTEC (WINAPI *PROOFINIT) (PROOFID *pid, const PROOFPARAMS *pxpar);


// ************************************************************
// *** ToolTerminate 
// This function marks the end of the session.  It attempts to
// close all dictionaries and free up any and all other resources
// allocated by the module since ToolInit.

// Do not call ToolTerminate if  ToolInit was not successful.

// If fForce is TRUE, ToolTerminate is guaranteed to succeed.  If
// fForce is false, it may fail.  For example, there may be errors
// writing the user dictionaries out to disk.  After ToolTerminate
// (whether it succeeds or fails), all other module routines with
// the exception of ToolTerminate and ToolVersion are unusable
// until the module is successfully reinitialized using ToolInit.  

// If this call fails, successful re-initialization of the module
// is not guaranteed on all platforms.  In addition, failure to
// successfully terminate each session may lock memory and file
// resources in an unrecoverable way until terminate is successful.
// If the terminate call fails, the main application should either
// fix the problem (e.g., insert floppy in drive) and try to
// terminate again, or should terminate using the fForce flag
// switch.

// PTEC WINAPI ToolTerminate(PROOFID id, BOOL fForce);
typedef PTEC (WINAPI *PROOFTERMINATE) (PROOFID id, BOOL fForce);


// *****************************************************************
// *** ToolSetOptions
// Set the value of an option for a tool.  The value to set is in iOptVal.

// PTEC WINAPI ToolSetOptions(PROOFID id, int iOptionSelect, int iOptVal);
typedef PTEC (WINAPI *PROOFSETOPTIONS) (PROOFID id, DWORD iOptionSelect, const DWORD iOptVal);


// *****************************************************************
// *** ToolGetOptions
// Get the current value of an option from a tool.  Returns in *piOptVal;
// PTEC WINAPI ToolGetOptions(PROOFID id, int iOptionSelect, int *piOptVal);
typedef PTEC (WINAPI *PROOFGETOPTIONS) (PROOFID id, DWORD iOptionSelect, DWORD *piOptVal);


// *****************************************************************
// *** ToolOpenLex 
// The dictionary file (main or user) is opened and verified, but not
// necessarily loaded.
// PTEC WINAPI ToolOpenLex(PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);
typedef PTEC (WINAPI *PROOFOPENLEX) (PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);


// *****************************************************************
// *** ToolCloseLex
// Closes the specified dictionary and disassociates that dictionary
// from any subsequent checks.  In the case of user dictionaries,
// updates the disk file (if any).  If the dictionary file cannot
// be updated, the call fails unless the fForce parameter is also set.

// If fForce is true, ToolCloseLex is guaranteed to successfully
// remove the dictionary from the dictionary list and effectively
// close the file.  In this case, it the file could not be updated,
// the changes are lost, but the function is considered successful,
// and therefore returns ptecNOERRORS.

// PTEC WINAPI ToolCloseLex(PROOFID id, PROOFLEX dict, BOOL fforce);
typedef PTEC (WINAPI *PROOFCLOSELEX) (PROOFID id, PROOFLEX lex, BOOL fforce);
// fForce forces closing the specified user dictionary, even if the
// dictionary cannot be updated.  Has no meaning for main
// dictionaries.


/******************************** Special Glue DLL API ******************
For the glue dll's (converts the API for clients to tools that use API v1 for
speller, hyphenator, v2 for thesaurus), we need to set the name of the previous version
DLL to use - and the code page (that it can't figure out from the LANGID)
to use for any data conversion.
The glue dll's use the lid to set the code page for data conversion.

BOOL WINAPI ToolSetDllName(const WCHAR *pwszDllName, const UINT uCodePage);
*************************************************************************/
#define idllProofSetDllName		19
typedef BOOL (WINAPI *PROOFSETDLLNAME)(const WCHAR *pwszDllName, const UINT uCodePage);


#if defined(__cplusplus)
}
#endif
#pragma pack(pop, proofapi_h)	// restore to whatever was before

#endif // PROOFBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\exploder\exploder.cpp ===
// --------------------------------------------------------------------------------
// Exploder.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "resource.h"

// --------------------------------------------------------------------------------
// Constants
// --------------------------------------------------------------------------------
#define CCHMAX_RES              1024
#define CCHMAX_PATH_EXPLODER    1024

// --------------------------------------------------------------------------------
// String Consts
// --------------------------------------------------------------------------------
static const char c_szRegCmd[]      = "/reg";
static const char c_szUnRegCmd[]    = "/unreg";
static const char c_szReg[]         = "Reg";
static const char c_szUnReg[]       = "UnReg";
static const char c_szAdvPackDll[]  = "ADVPACK.DLL";
static const char c_szSource[]      = "/SOURCE:";
static const char c_szDest[]        = "/DEST:";

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
HINSTANCE       g_hInst=NULL;
CHAR            g_szTitle[CCHMAX_RES];
IMalloc        *g_pMalloc=NULL;

// --------------------------------------------------------------------------------
// BODYFILEINFO
// --------------------------------------------------------------------------------
typedef struct tagBODYFILEINFO {
    HBODY           hBody;
    LPSTR           pszCntId;
    LPSTR           pszCntLoc;
    LPSTR           pszFileName;
    LPSTR           pszFilePath;
    BYTE            fIsHtml;
    IStream        *pStmFile;
} BODYFILEINFO, *LPBODYFILEINFO;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
HRESULT CallRegInstall(LPCSTR szSection);
HRESULT ReplaceContentIds(LPSTREAM pStmHtml, LPBODYFILEINFO prgBody, DWORD cBodies);
int     WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPTSTR pszCmdLine, int nCmdShow);
HRESULT MimeOleExplodeMhtmlFile(LPCSTR pszSrcFile, LPSTR pszDstDir, INT *pnError);

// --------------------------------------------------------------------------------
// IF_FAILEXIT_ERROR
// --------------------------------------------------------------------------------
#define IF_FAILEXIT_ERROR(_nError, hrExp) \
    if (FAILED(hrExp)) { \
        TraceResult(hr); \
        *pnError = _nError; \
        goto exit; \
    } else

// --------------------------------------------------------------------------------
// ModuleEntry - Stolen from the CRT, used to shirink our code
// --------------------------------------------------------------------------------
int _stdcall ModuleEntry(void)
{
    // Locals
    int             i;
    STARTUPINFOA    si;
    LPTSTR          pszCmdLine;

    // Get Malloc
    CoGetMalloc(1, &g_pMalloc);

    // Get the command line
    pszCmdLine = GetCommandLine();

    // We don't want the "No disk in drive X:" requesters, so we set the critical error mask such that calls will just silently fail
    SetErrorMode(SEM_FAILCRITICALERRORS);

    // Parse the command line
    if (*pszCmdLine == TEXT('\"')) 
    {
        // Scan, and skip over, subsequent characters until another double-quote or a null is encountered.
        while ( *++pszCmdLine && (*pszCmdLine != TEXT('\"')))
            {};

        // If we stopped on a double-quote (usual case), skip over it.
        if (*pszCmdLine == TEXT('\"'))
            pszCmdLine++;
    }
    else 
    {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    // Skip past any white space preceeding the second token.
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) 
        pszCmdLine++;

    // Register
    if (0 == lstrcmpi(c_szRegCmd, pszCmdLine))
    {
        CallRegInstall(c_szReg);
        goto exit;
    }

    // Unregister
    else if (0 == lstrcmpi(c_szUnRegCmd, pszCmdLine))
    {
        CallRegInstall(c_szUnReg);
        goto exit;
    }

    // Get startup information...
    si.dwFlags = 0;
    GetStartupInfoA(&si);

    // Call the real winmain
    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine, si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

exit:
    // Cleanup
    SafeRelease(g_pMalloc);

    // Since we now have a way for an extension to tell us when it is finished, we will terminate all processes when the main thread goes away.
    ExitProcess(i);

    // Done
    return i;
}

// --------------------------------------------------------------------------------
// WinMainT
// --------------------------------------------------------------------------------
int WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPTSTR pszCmdLine, int nCmdShow)
{
    // Locals
    HRESULT         hr;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szSource[CCHMAX_PATH_EXPLODER];
    CHAR            szDest[CCHMAX_PATH_EXPLODER];
    LPSTR           pszT;
    DWORD           i;
    INT             nError;

    // Message
    LoadString(hInst, IDS_TITLE, g_szTitle, ARRAYSIZE(g_szTitle));

    // Message
    LoadString(hInst, IDS_HELP, szRes, ARRAYSIZE(szRes));

    // If Command Line is Empty...
    if (NULL == pszCmdLine || StrStrA(pszCmdLine, szRes) || *pszCmdLine == '?' || lstrcmpi("\\?", pszCmdLine) == 0)
    {
        // Message
        LoadString(hInst, IDS_CMDLINE_FORMAT, szRes, ARRAYSIZE(szRes));

        // Message
        MessageBox(NULL, szRes, g_szTitle, MB_OK | MB_ICONINFORMATION);

        // Done
        goto exit;
    }

    // Null Out Source and Dest
    *szSource = '\0';
    *szDest = '\0';

    // If pszCmdLine specifies a specific, existing file...
    if (PathFileExists(pszCmdLine))
    {
        // Copy To source
        lstrcpyn(szSource, pszCmdLine, ARRAYSIZE(szSource));

        // Pick a Temporary Location to store the thicket
        GetTempPath(ARRAYSIZE(szDest), szDest);
    }

    // Otherwise, try to get a source
    else
    {
        // Lets Upper Case the Command Line
        CharUpper(pszCmdLine);

        // Try to locate /SOURCE:
        pszT = StrStrA(pszCmdLine, c_szSource);

        // If we found /SOURCE, then read the contents...
        if (pszT)
        {
            // Step over /SOURCE:
            pszT += lstrlen(c_szSource);

            // Initialize
            i = 0;

            // Read into szSource, until I hit a / or end of string...
            while ('\0' != *pszT && '/' != *pszT && i < CCHMAX_PATH_EXPLODER)
                szSource[i++] = *pszT++;

            // Pound in a Null
            szSource[i] = '\0';

            // Strip Leading and Trailing Whitespace
            UlStripWhitespace(szSource, TRUE, TRUE, NULL);

            // See if file exists
            if (FALSE == PathFileExists(szSource))
            {
                // Locals
                CHAR szError[CCHMAX_RES + CCHMAX_PATH_EXPLODER];

                // Message
                LoadString(hInst, IDS_FILE_NOEXIST, szRes, ARRAYSIZE(szRes));

                // Format the error message
                wsprintf(szError, szRes, szSource);

                // Message
                INT nAnswer = MessageBox(NULL, szError, g_szTitle, MB_YESNO | MB_ICONEXCLAMATION );

                // Done
                if (IDNO == nAnswer)
                    goto exit;

                // Otherwise, clear szSource
                *szSource = '\0';
            }
        }

        // No Source File, lets browser for one
        if (FIsEmptyA(szSource))
        {
            // Locals
            OPENFILENAME    ofn;            
            CHAR            rgszFilter[CCHMAX_PATH_EXPLODER];
            CHAR            szDir[MAX_PATH];

            // Copy in the source of exploder.exe
            GetModuleFileName(hInst, szDir, ARRAYSIZE(szDir));

            // Initialize szDest
            PathRemoveFileSpecA(szDir);

            // Initialize ofn
            ZeroMemory(&ofn, sizeof(OPENFILENAME));

            // Initialize the STring
            *szSource ='\0';

            // Load the MHTML File Filter
            LoadString(hInst, IDS_MHTML_FILTER, rgszFilter, ARRAYSIZE(rgszFilter));

            // Fixup the String
            ReplaceChars(rgszFilter, '|', '\0');

            // Initialize the Open File Structure
            ofn.lStructSize     = sizeof(OPENFILENAME);
            ofn.hwndOwner       = NULL;
            ofn.hInstance       = hInst;
            ofn.lpstrFilter     = rgszFilter;
            ofn.nFilterIndex    = 1;
            ofn.lpstrFile       = szSource;
            ofn.nMaxFile        = CCHMAX_PATH_EXPLODER;
            ofn.lpstrInitialDir = szDir;
            ofn.Flags           = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;

            // Get Open File Name
            if (FALSE == GetOpenFileName(&ofn))
                goto exit;
        }
    }

    // Do we have a valid destination...
    if (FALSE == PathIsDirectoryA(szDest))
    {
        // Try to locate /DEST:
        pszT = StrStrA(pszCmdLine, c_szDest);

        // If we found /DEST, then read the contents...
        if (pszT)
        {
            // Step over /DEST:
            pszT += lstrlen(c_szDest);

            // Initialize
            i = 0;

            // Read into szSource, until I hit a / or end of string...
            while ('\0' != *pszT && '/' != *pszT && i < CCHMAX_PATH_EXPLODER)
                szDest[i++] = *pszT++;

            // Pound in a Null
            szDest[i] = '\0';

            // Strip Leading and Trailing Whitespace
            UlStripWhitespace(szDest, TRUE, TRUE, NULL);

            // See if file exists
            if (FALSE == PathIsDirectoryA(szDest))
            {
                // Locals
                CHAR szError[CCHMAX_RES + CCHMAX_PATH_EXPLODER];

                // Message
                LoadString(hInst, IDS_DIRECTORY_NOEXIST, szRes, ARRAYSIZE(szRes));

                // Format the error message
                wsprintf(szError, szRes, szDest);

                // Message
                INT nAnswer = MessageBox(NULL, szError, g_szTitle, MB_YESNO | MB_ICONEXCLAMATION );

                // Done
                if (IDNO == nAnswer)
                    goto exit;

                // Try to create the directory
                if (FALSE == CreateDirectory(szDest, NULL))
                {
                    // Message
                    LoadString(hInst, IDS_NOCREATE_DIRECTORY, szRes, ARRAYSIZE(szRes));

                    // Format the error message
                    wsprintf(szError, szRes, szDest);

                    // Message
                    INT nAnswer = MessageBox(NULL, szError, g_szTitle, MB_YESNO | MB_ICONEXCLAMATION );

                    // Done
                    if (IDNO == nAnswer)
                        goto exit;

                    // Clear *szDest
                    *szDest = '\0';
                }
            }
        }

        // No Source File, lets browser for one
        if (FIsEmptyA(szDest))
        {
            // Copy in the source of exploder.exe
            GetModuleFileName(hInst, szDest, ARRAYSIZE(szDest));

            // Initialize szDest
            PathRemoveFileSpecA(szDest);

            // Failure
            if (FALSE == BrowseForFolder(hInst, NULL, szDest, ARRAYSIZE(szDest), IDS_BROWSE_DEST, TRUE))
                goto exit;

            // Better be a directory
            Assert(PathIsDirectoryA(szDest));
        }
    }

    // Validate the dest and source
    Assert(PathIsDirectoryA(szDest) && PathFileExists(szSource));

    // Explode the file
    nError = 0;
    hr = MimeOleExplodeMhtmlFile(szSource, szDest, &nError);

    // Failure ?
    if (FAILED(hr) || 0 != nError)
    {
        // Locals
        CHAR szError[CCHMAX_RES + CCHMAX_PATH_EXPLODER];

        // Message
        LoadString(hInst, nError, szRes, ARRAYSIZE(szRes));

        // Need to format with file name ?
        if (IDS_OPEN_FILE == nError || IDS_LOAD_FAILURE == nError || IDS_NO_HTML == nError)
        {
            // Format the error message
            wsprintf(szError, szRes, szSource, hr);
        }

        // Otherwise,
        else
        {
            // Format the error message
            wsprintf(szError, szRes, hr);
        }

        // Message
        MessageBox(NULL, szError, g_szTitle, MB_OK | MB_ICONEXCLAMATION);
    }

exit:
    // Done
    return(1);
}

// --------------------------------------------------------------------------------
// MimeOleExplodeMhtmlFile
// --------------------------------------------------------------------------------
HRESULT MimeOleExplodeMhtmlFile(LPCSTR pszSrcFile, LPSTR pszDstDir, INT *pnError)
{
    // Locals
    HRESULT             hr=S_OK;
    IStream            *pStmFile=NULL;
    IMimeMessage       *pMessage=NULL;
    HBODY               hRootHtml=NULL;
    DWORD               cMaxBodies;
    DWORD               cBodies=0;
    FINDBODY            FindBody={0};
    DWORD               cchDstDir;
    DWORD               iRootBody=0xffffffff;
    HBODY               hBody;
    PROPVARIANT         Variant;
    SHELLEXECUTEINFO    ExecuteInfo;
    LPBODYFILEINFO      prgBody=NULL;
    LPBODYFILEINFO      pInfo;
    DWORD               i;
    IMimeBody          *pBody=NULL;

    // Trace
    TraceCall("MimeOleExplodeMhtmlFile");

    // Invalid Args
    if (FALSE == PathIsDirectoryA(pszDstDir) || FALSE == PathFileExists(pszSrcFile) || NULL == pnError)
        return TraceResult(E_INVALIDARG);

    // Initialize
    *pnError = 0;

    // Get DstDir Length
    cchDstDir = lstrlen(pszDstDir);

    // Remove last \\ from pszDstDir
    if (cchDstDir && pszDstDir[cchDstDir - 1] == '\\')
    {
        pszDstDir[cchDstDir - 1] = '\0';
        cchDstDir--;
    }

    // Create a Mime Message
    IF_FAILEXIT_ERROR(IDS_MEMORY, hr = MimeOleCreateMessage(NULL, &pMessage));

    // Initialize the message
    IF_FAILEXIT_ERROR(IDS_GENERAL_ERROR, hr = pMessage->InitNew());

    // Create a stream on the file
    IF_FAILEXIT_ERROR(IDS_OPEN_FILE, hr = OpenFileStream((LPSTR)pszSrcFile, OPEN_EXISTING, GENERIC_READ, &pStmFile));

    // Load the Message
    IF_FAILEXIT_ERROR(IDS_LOAD_FAILURE, hr = pMessage->Load(pStmFile));

    // Invalid Message
    if (MIME_S_INVALID_MESSAGE == hr)
    {
        *pnError = IDS_LOAD_FAILURE;
        goto exit;
    }

    // Count the Bodies
    IF_FAILEXIT(hr = pMessage->CountBodies(NULL, TRUE, &cMaxBodies));

    // Allocate
    IF_FAILEXIT_ERROR(IDS_MEMORY, hr = HrAlloc((LPVOID *)&prgBody, sizeof(BODYFILEINFO) * cMaxBodies));

    // Zero
    ZeroMemory(prgBody, sizeof(BODYFILEINFO) * cMaxBodies);

    // Get the root body...
    IF_FAILEXIT_ERROR(IDS_NO_HTML, hr = pMessage->GetTextBody(TXT_HTML, IET_DECODED, NULL, &hRootHtml));

    // Loop through all the bodies
    hr = pMessage->FindFirst(&FindBody, &hBody);

    // Loop
    while(SUCCEEDED(hr))
    {
        // Must have an hBody
        Assert(hBody);

        // Skip Multipart Bodies
        if (S_FALSE == pMessage->IsContentType(hBody, STR_CNT_MULTIPART, NULL))
        {
            // Is this the root ?
            if (hBody == hRootHtml)
                iRootBody = cBodies;

            // Readability
            pInfo = &prgBody[cBodies];

            // Better not over run prgBody
            pInfo->hBody = hBody;

            // Init the Variant
            Variant.vt = VT_LPSTR;

            // Get the Content Id
            if (SUCCEEDED(pMessage->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTID), 0, &Variant)))
                pInfo->pszCntId = Variant.pszVal;

            // Get the Content Location
            if (SUCCEEDED(pMessage->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTLOC), 0, &Variant)))
                pInfo->pszCntLoc = Variant.pszVal;

            // Generate a filename
            if (SUCCEEDED(pMessage->GetBodyProp(hBody, PIDTOSTR(PID_ATT_GENFNAME), 0, &Variant)))
                pInfo->pszFileName = Variant.pszVal;

            // If its html, lets make sure that the filename has a .html file extension
            pInfo->fIsHtml = (S_OK == pMessage->IsContentType(hBody, STR_CNT_TEXT, STR_SUB_HTML)) ? TRUE : FALSE;

            // Take the filename and build the file path
            Assert(pInfo->pszFileName);

            // Don't Crash
            if (NULL == pInfo->pszFileName)
            {
                hr = TraceResult(E_UNEXPECTED);
                goto exit;
            }

            // Validate Extension
            if (pInfo->fIsHtml)
            {
                // Get Extension
                LPSTR pszExt = PathFindExtensionA(pInfo->pszFileName);

                // If Null or not .html..
                if (NULL == pszExt || lstrcmpi(pszExt, ".html") != 0)
                {
                    // Re-allocate pInfo->pszFileName...
                    IF_FAILEXIT_ERROR(IDS_MEMORY, hr = HrRealloc((LPVOID *)&pInfo->pszFileName, lstrlen(pInfo->pszFileName) + 10));

                    // Rename the Extension
                    PathRenameExtensionA(pInfo->pszFileName, ".html");
                }
            }

            // Build that full file path
            IF_FAILEXIT_ERROR(IDS_MEMORY, hr = HrAlloc((LPVOID *)&pInfo->pszFilePath, lstrlen(pszDstDir) + lstrlen(pInfo->pszFileName) + 10));

            // Formath the filepath
            wsprintf(pInfo->pszFilePath, "%s\\%s", pszDstDir, pInfo->pszFileName);

            // Save the body to the file
            IF_FAILEXIT(hr = pMessage->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody));

            // Save to the file
            IF_FAILEXIT(hr = pBody->SaveToFile(IET_DECODED, pInfo->pszFilePath));

            // Open a file stream
            if (pInfo->fIsHtml)
            {
                // Open it if its html
                IF_FAILEXIT(hr = OpenFileStream(pInfo->pszFilePath, OPEN_ALWAYS, GENERIC_READ | GENERIC_WRITE, &pInfo->pStmFile));
            }

            // Increment cBodies
            cBodies++;
        }

        // Loop through all the bodies
        hr = pMessage->FindNext(&FindBody, &hBody);
    }

    // Reset hr
    hr = S_OK;

    // Root Body was not found
    Assert(iRootBody != 0xffffffff);

    // Bad News
    if (0xffffffff == iRootBody)
    {
        hr = TraceResult(E_UNEXPECTED);
        goto exit;
    }

    // Walk through and fixup all HTML files and close all streams
    for (i=0; i<cBodies; i++)
    {
        // Readability
        pInfo = &prgBody[i];

        // If HTML...
        if (pInfo->fIsHtml)
        {
            // Better have an open stream
            Assert(pInfo->pStmFile);

            // Failure
            if (NULL == pInfo->pStmFile)
            {
                hr = TraceResult(E_UNEXPECTED);
                goto exit;
            }

            // Replace all the CID references with file references...
            ReplaceContentIds(pInfo->pStmFile, prgBody, cBodies);
        }

        // Release this stream
        SafeRelease(pInfo->pStmFile);
    }

    // Launch the Currently Registered HTML Editor ontop of iRootBody pszFilePath
    ZeroMemory(&ExecuteInfo, sizeof(SHELLEXECUTEINFO));
    ExecuteInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    ExecuteInfo.cbSize = sizeof(SHELLEXECUTEINFO);
    ExecuteInfo.lpVerb = "Edit";
    ExecuteInfo.lpFile = prgBody[iRootBody].pszFilePath;
    ExecuteInfo.lpParameters = NULL;
    ExecuteInfo.lpDirectory = pszDstDir;
    ExecuteInfo.nShow = SW_SHOWNORMAL;

    // Compress szBlobFile
    ShellExecuteEx(&ExecuteInfo);

exit:
    // General Error
    if (FAILED(hr) && 0 == *pnError)
        *pnError = IDS_GENERAL_ERROR;

    // Free prgBody
    if (prgBody)
    {
        // Loop
        for (i=0; i<cBodies; i++)
        {
            SafeMemFree(prgBody[i].pszCntId);
            SafeMemFree(prgBody[i].pszCntLoc);
            SafeMemFree(prgBody[i].pszFileName);
            SafeMemFree(prgBody[i].pszFilePath);
            SafeRelease(prgBody[i].pStmFile);
        }

        // Free the Array
        CoTaskMemFree(prgBody);
    }

    // Cleanup
    SafeRelease(pStmFile);
    SafeRelease(pBody);
    SafeRelease(pMessage);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// ReplaceContentIds
// --------------------------------------------------------------------------------
HRESULT ReplaceContentIds(LPSTREAM pStmHtml, LPBODYFILEINFO prgBody, DWORD cBodies)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cb;
    LPSTR           pszFound;
    LPSTR           pszT;
    LPSTR           pszHtml=NULL;
    LPSTR           pszCntId=NULL;
    DWORD           i;
    DWORD           cchCntId;
    ULARGE_INTEGER  uliSize;

    // Trac
    TraceCall("ReplaceContentIds");

    // Invalid Args
    Assert(pStmHtml && prgBody && cBodies);

    // Loop through the bodies
    for (i=0; i<cBodies; i++)
    {
        // No Content-ID here...
        if (NULL == prgBody[i].pszCntId)
            continue;

        // Better have a filename
        Assert(prgBody[i].pszFileName);

        // Load the stream into memory...
        IF_FAILEXIT(hr = HrGetStreamSize(pStmHtml, &cb));

        // Allocate Memory
        IF_FAILEXIT(hr = HrAlloc((LPVOID *)&pszHtml, cb + 1));

        // Rewind
        IF_FAILEXIT(hr = HrRewindStream(pStmHtml));

        // Read the Stream
        IF_FAILEXIT(hr = pStmHtml->Read(pszHtml, cb, NULL));

        // Stuff Null terminator
        pszHtml[cb] = '\0';

        // Kill pStmHtml
        uliSize.QuadPart = 0;
        IF_FAILEXIT(hr = pStmHtml->SetSize(uliSize));

        // Allocate Memory
        IF_FAILEXIT(hr = HrAlloc((LPVOID *)&pszCntId, lstrlen(prgBody[i].pszCntId) + lstrlen("cid:") + 5));

        // Format
        pszT = prgBody[i].pszCntId;
        if (*pszT == '<')
            pszT++;
        wsprintf(pszCntId, "cid:%s", pszT);

        // Remove trailing >
        cchCntId = lstrlen(pszCntId);
        if (pszCntId[cchCntId - 1] == '>')
            pszCntId[cchCntId - 1] = '\0';

        // Set pszT
        pszT = pszHtml;

        // Begin replace loop
        while(1)
        {
            // Find pszCntId
            pszFound = StrStrA(pszT, pszCntId);

            // Done
            if (NULL == pszFound)
            {
                // Write from pszT to pszFound
                IF_FAILEXIT(hr = pStmHtml->Write(pszT, (pszHtml + cb) - pszT, NULL));

                // Done
                break;
            }

            // Write from pszT to pszFound
            IF_FAILEXIT(hr = pStmHtml->Write(pszT, pszFound - pszT, NULL));

            // Write 
            IF_FAILEXIT(hr = pStmHtml->Write(prgBody[i].pszFileName, lstrlen(prgBody[i].pszFileName), NULL));

            // Set pszT
            pszT = pszFound + lstrlen(pszCntId);
        }

        // Commit
        IF_FAILEXIT(hr = pStmHtml->Commit(STGC_DEFAULT));

        // Cleanup
        SafeMemFree(pszHtml);
        SafeMemFree(pszCntId);
    }

exit:
    // Cleanup
    SafeMemFree(pszHtml);
    SafeMemFree(pszCntId);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CallRegInstall
// --------------------------------------------------------------------------------
HRESULT CallRegInstall(LPCSTR szSection)
{
    int         cch;
    HRESULT     hr;
    HINSTANCE   hAdvPack, hinst;
    REGINSTALL  pfnri;
    char        szExploderDll[CCHMAX_PATH_EXPLODER], szDir[CCHMAX_PATH_EXPLODER];
    STRENTRY    seReg[2];
    STRTABLE    stReg;
    char        c_szExploder[] = "EXPLODER";
    char        c_szExploderDir[] = "EXPLODER_DIR";


    hr = E_FAIL;

    hinst = GetModuleHandle(NULL);

    hAdvPack = LoadLibraryA(c_szAdvPackDll);
    if (hAdvPack != NULL)
        {
        // Get Proc Address for registration util
        pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
        if (pfnri != NULL)
            {
            stReg.cEntries = 0;
            stReg.pse = seReg;

            GetModuleFileName(hinst, szExploderDll, ARRAYSIZE(szExploderDll));
            seReg[stReg.cEntries].pszName = c_szExploder;
            seReg[stReg.cEntries].pszValue = szExploderDll;
            stReg.cEntries++;

            lstrcpy(szDir, szExploderDll);
            cch = lstrlen(szDir);
            for ( ; cch > 0; cch--)
                {
                if (szDir[cch] == '\\')
                    {
                    szDir[cch] = 0;
                    break;
                    }
                }
            seReg[stReg.cEntries].pszName = c_szExploderDir;
            seReg[stReg.cEntries].pszValue = szDir;
            stReg.cEntries++;

            // Call the self-reg routine
            hr = pfnri(hinst, szSection, &stReg);
            }

        FreeLibrary(hAdvPack);
        }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\external\inc\lid.h ===
/*------------------------------------------------------------
    lid.h - Unified language id file

	1/10/97	dougp	created
	1/30/97	dougp	added Farsi
        4/15/97 dougp	add Basque, SLovenian, Latvian, Lithuanian, Romainian, Bulgarian
	9/ 2/97 DougP	add Ukranian, Greek, Estonian
	9/12/97 DougP	add Gallego	

    Note:  The Natural Language Group maintains this file.
	Please contact us with change requests.
------------------------------------------------------------*/

#if !defined(LID_H)
#define LID_H

#ifndef LID
typedef unsigned short    LID;      /* two byte language identifier code */
#endif

/* IPG two byte language id's.  Returned in LID field. */
#define lidAmerican         0x0409  /* "AM" American English   */
#define lidAustralian       0x0c09  /* "EA" English Australian */
#define lidBritish          0x0809  /* "BR" English            */
#define lidEnglishCanadian  0x1009  /* "EC" English Canadian   */
#define lidCatalan          0x0403  /* "CT" Catalan            */
#define lidDanish           0x0406  /* "DA" Danish             */
#define lidDutch            0x0413  /* "NL" Dutch              */
#define lidDutchPreferred   0x0013  /* "NL" Dutch Preferred    */
#define lidFinnish          0x040b  /* "FI" Finish             */
#define lidFrench           0x040c  /* "FR" French             */
#define lidFrenchCanadian   0x0c0c  /* "FC" French Canadian    */
#define lidGerman           0x0407  /* "GE" German             */
#define lidSwissGerman      0x0807  /* "GS" German Swiss       */
#define lidItalian          0x0410  /* "IT" Italian            */
#define lidNorskBokmal      0x0414  /* "NO" Norwegian Bokmal   */
#define lidNorskNynorsk     0x0814  /* "NN" Norwegian Nynorsk  */
#define lidPortBrazil       0x0416  /* "PB" Portuguese Brazil  */
#define lidPortIberian      0x0816  /* "PT" Portuguese Iberian */
#define lidSpanish          0x040a  /* "SP" Spanish            */
#define lidSwedish          0x041d  /* "SW" Swedish            */
#define lidRussian          0x0419  /* "RU" Russian            */
#define lidCzech            0x0405  /* "CZ" Czech              */
#define lidHungarian        0x040e  /* "HU" Hungarian          */
#define lidPolish           0x0415  /* "PL" Polish             */
#define lidTurkish          0x041f  /* "TR" Turkish            */
#define	lidFarsi	    0x0429

#define lidBasque	    0x042d  /* "EU" Basque/Euskara     */ 
#define lidSlovenian	    0x0424  /*	Slovene - Slovenia	*/
#define lidLatvian	    0x0426  /*	Latvian - Latvia - Latvia */
#define lidLithuanian	    0x0427  /*	Lithuanian - Lithuania */
#define lidRomanian 	    0x0418  /*	Romanian - Romania */
#define lidRomanianMoldavia 0x0818  /*	Romanian - Moldavia */
#define lidBulgarian 	    0x0402  /*	Bulgarian - Bulgaria */


/* African languages */
#define lidSutu             0x0430  /* "ST" Sutu               */
#define lidTsonga           0x0431  /* "TS" Tsonga             */
#define lidTswana           0x0432  /* "TN" Tswana             */
#define lidVenda            0x0433  /* "VE" Venda			   */
#define lidXhosa            0x0434  /* "XH" Xhosa              */
#define lidZulu             0x0435  /* "ZU" Zulu               */

#define lidAfrikaans        0x0436  /* "AF" Afrikaans          */

#define lidKoreanExtWansung	0x0412	/* Korean(Extended Wansung) - Korea */
#define lidKoreanJohab		0x0812	/* Korean(Johab) - Korea */

#define	lidUkranian	0x0422	/* Ukrainian - Ukraine */
#define	lidGreek	0x0408	/* Greek */
#define	lidEstonian	0x0425	/* Estonian */
#define	lidGalician	0x0456	/* Gallego */

/* These are currently not used, but added for future support. */
#define lidArabic           0x0401
#define lidHebrew           0x040d
#define lidJapanese         0x0411
#define lidLatin            0x041a /* Croato-Serbian (Latin)   */
#define lidCyrillic         0x081a /* Serbo-Croatian (Cyrillic) */
#define lidSlovak           0x041b

#define LID_UNKNOWN         0xffff
#if !defined(lidUnknown)
#	define lidUnknown		0xffff
#endif

#endif /* LID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\external\inc\spellapi.h ===
/********************************************************************
  spellAPI.h - API definitions for CSAPI, the Speller

You are not entitled to any support or assistance from Microsoft Corporation
regarding your use of the documentation, this C-header file, or any sample source
code associated with the Common Speller Application Programming Interface (CSAPI).
We regret that Microsoft is unable to support or
assist you should you have problems using these files.

To use the CSAPI (including without limitation, the documentation,
C-header file, and any sample source code), you must have executed the
CSAPI end user license agreement (EULA),
available through Microsoft.

IF YOU HAVE NOT SIGNED THE CSAPI EULA,
YOU ARE NOT AUTHORIZED TO USE THE CSAPI.

  Version 3.0 - all api's

    History:
    5/97    DougP   Created
    11/97   DougP   This separate speller part

    The Natural Language Group maintains this file.

  1997 Microsoft Corporation
********************************************************************/

#if !defined(SPELLAPI_H)
#define SPELLAPI_H

/**********************************************************
The Speller, Hyphenator, and Thesaurus share 7 functions.
The prototypes, etc. for these functions are in ProofBase.h
**********************************************************/
#if !defined(PROOFBASE_H)
#include "ProofBse.h"
#endif

/*************************************************************
     PART 1 - Structure Defs
**************************************************************/
#pragma pack(push, proofapi_h, 8)   // default alignment

// eliminate Wizard Special Characters */
    /* all this array are well defined Unicode (and Latin-1) characters. */

typedef PROOFPARAMS SpellerParams;  // spm
typedef DWORD   SpellerState;   // sstate

STRUCTUREBEGIN(WSIB)            /* Spell Input Buffer - sib */
    const WCHAR *pwsz;      /* Ptr to buffer of text to be processed */
    PROOFLEX    *prglex;    /* List of dicts to use */
    size_t      cch;        /* Count of characters in pwsz */
    size_t      clex;       /* Count of dicts specified in prglex */
                                /* State relative to prev. SpellerCheck call */
    SpellerState    sstate;     // sstate
    DWORD       ichStart;   /* position in pwsz to start (New) */
    size_t      cchUse;     /* count of characters in pwsz to consider (New) */
STRUCTUREEND2(WSIB, ichStart(0), sstate(0))

typedef enum {  /* Spell Check Return Status */
    sstatNoErrors,          /* All buffer processed. */
    sstatUnknownInputWord,  /* Unknown word. */
    sstatReturningChangeAlways, /* Returning a Change Always word in SRB. */
    sstatReturningChangeOnce,  /* Returning a Change Once word in SRB. */
    sstatInvalidHyphenation,   /* obsolete - Error in hyphenation point.*/
    sstatErrorCapitalization,   /* Cap pattern not valid. */
    sstatWordConsideredAbbreviation, /* Word is considered an abbreviation. */
    sstatHyphChangesSpelling, /* obsolete - Word changes spelling when not hyphenated. */
    sstatNoMoreSuggestions,  /* All methods used. */
    sstatMoreInfoThanBufferCouldHold,  /* More suggestions than could fit in SRB. */
    sstatNoSentenceStartCap,  /* obsolete - Start of sentence was not capitalized. */
    sstatRepeatWord,    /* Repeat word found. */
    sstatExtraSpaces,   /* obsolete - Too many spaces for context.*/
    sstatMissingSpace, /* obsolete - Too few space(s) between words or sentences. */
    sstatInitialNumeral,  /* Word starts with numeral & sobitFlagInitialNumeral set */
    sstatNoErrorsUDHit, /* obsolete - No errors, but at least 1 word found in user dicts */
    sstatReturningAutoReplace,  /* Returning an AutoReplace suggestion in WSRB */
    sstatErrorAccent,   /* accents not valid - returns correctly accented word */
} SPELLERSTATUS;    // sstat


typedef struct {
    WCHAR   *pwsz;  // pointer to the suggestion (in pwsz)
    DWORD   ichSugg;    // position in input buffer corresponding to suggestion
    DWORD   cchSugg;    // length in input buffer corresponding to suggestion
    DWORD   iRating;    // rating value of this suggestion (0 - 255)
} SPELLERSUGGESTION;    // sugg

STRUCTUREBEGIN(WSRB)                 /* Spell Return Buffer - srb */
    WCHAR       *pwsz;      /* Ptr to suggestion buffer.
                         Format: word\0word\0...word\0\0 */
    SPELLERSUGGESTION   *prgsugg;   // ptr to array of suggestions (see above)
    DWORD       ichError;   /* Position of verif. error in SIB */
    DWORD       cchError;     /* Length of verif. error in SIB.*/
    DWORD       ichProcess;     /* position where processing began */
    DWORD       cchProcess;     /* length of processed region */
    SPELLERSTATUS    sstat;       /* Spell check return status */
    DWORD       csz;           /* Count of wsz's in pwsz
                                can be greater than cszAlloc,
                                in which case you got sstatMoreInfoThanBufferCouldHold */
    DWORD       cszAlloc;       /* number of entries allocated in pSuggestion
                                    (set by App) */
    DWORD       cchMac; /* Current chars used in pwsz (incl all trailing nulls) */
    DWORD       cchAlloc;          /* Size in chars of pwsz (Set by App) */
STRUCTUREEND2(WSRB, pwsz(0), prgsugg(0))

// for a null response (no returns), csz=0, cchMac=1 (for the trailing null)
// and *pwsz = L'\0'.  To be really safe, pwsz[1] = L'\0' as well

/*
    Client typically allocates arrays for pwsz and rgSuggestion:
    #define MAXSUGGBUFF 512
    #define MAXSUGG 20
    SPELLERSUGGESTION   rgsugg[MAXSUGG];
    WCHAR   SuggestionBuffer[MAXSUGGBUF];
    WSRB    srb;
    srb.pwsz = SuggestionBuffer;
    srb.prgsugg = rgsugg;
    srb.cszAlloc = MAXSUGG;
    srb.cchAlloc = MAXSUGGBUFF;

  Now the return buffer is ready to receive suggestions lists.  The list
  comes back as a list of null terminated strings in pwsz.  It also comes
  back in the array that rgSugg points to.  rgSugg also contains information
  for each suggestion as to the area of the input buffer that the suggestion
  applies to.
*/

// rating guidelines - these guidelines apply to both the AutoReplaceThreshold
// and the ratings optionally returned in the WSRB
// These give clients guidelines for setting the AutoReplace Threshold
// Spellers can deviate from these guidelines as appropriate for a language.
enum
{
    SpellerRatingNone                   =256,   // this rating is so high it turns off all AutoReplace
    SpellerRatingCapit                  =255,   // capitalization and accent errors
    SpellerRatingDropDoubleConsonant    =255-13,    // dropped one of a doubled consonant
    SpellerRatingDropDoubleVowel        =255-15,    // dropped one of a doubled vowel
    SpellerRatingAddDoubleConsonant     =255-13,    // doubled a consonant
    SpellerRatingAddDoubleVowel         =255-15,    // doubled a vowel
    SpellerRatingTransposeVowel         =255-14,    // transposed vowels
    SpellerRatingTransposeConsonant     =255-17,    // transposed consonants
    SpellerRatingTranspose              =255-18,    // other transpositions
    SpellerRatingSubstituteVowel        =255-20,    // substitute vowels
    SpellerRatingDrop                   =255-30,    // drop a letter
    SpellerRatingSubstituteConsonant    =255-40,    // substitute Consonants
    SpellerRatingAdd                    =255-34,    // add a letter
    SpellerRatingSubstitute             =255-42,    // other substitutions
};

/*************************************************************
     PART 2 - Function Defs
**************************************************************/
#if defined(__cplusplus)
extern "C" {
#endif

/* -------------- Speller Section --------------
--------------------------------------------- */

//PTEC WINAPI SpellerVersion(PROOFINFO *pinfo);

//PTEC WINAPI SpellerInit(PROOFID *psid, const SpellerParams *pspm);

//PTEC WINAPI SpellerTerminate(PROOFID sid, BOOL fForce);

enum {
    sobitSuggestFromUserLex     = 0x00000001L,  /* Suggest from user dictionaries. */
    sobitIgnoreAllCaps          = 0x00000002L,  /* Ignore words in all UPPERCASE. */
    sobitIgnoreMixedDigits      = 0x00000004L, /* Ignore words with any numbers in it. */
    sobitIgnoreRomanNumerals    = 0x00000008L, /* Ignore words composed of all roman numerals. */

    sobitFindRepeatWord         = 0x00000040L, /* Flag repeated words. */

    sobitRateSuggestions        = 0x00000400L, /* Rate the suggestions on scale
                                                *  of 1-255, 255 being most likely
                                                */

    sobitFindInitialNumerals    = 0x00000800L, /* Flag words starting with number(s) */

    sobitSglStepSugg            = 0x00010000L, /* Break after each suggestion task for faster
                                                * return of control to the application.
                                                */

    sobitIgnoreSingleLetter     = 0x00020000L, /* Do not check single letters: e.g., "a)".
                                                */
    sobitIgnoreInitialCap       = 0x00040000L, /* ignore words with initial letter capped */

    sobitLangMode               = 0xF0000000L, /* Language Mode mask */
      /* Hebrew Language Modes -- (CT only) */
    sobitHebrewFullScript       = 0x00000000L,
    sobitHebrewPartialScript    = 0x10000000L,
    sobitHebrewMixedScript      = 0x20000000L,
    sobitHebrewMixedAuthorizedScript    = 0x30000000L,
      /* French Language Modes -- (HM only) */
    sobitFrenchDialectDefault       = 0x00000000L,
    sobitFrenchUnaccentedUppercase  = 0x10000000L,
    sobitFrenchAccentedUppercase    = 0x20000000L,
      /* Russian Language Modes -- (HM only) */
    sobitRussianDialectDefault      = 0x00000000L,
    sobitRussianIE                  = 0x10000000L,
    sobitRussianIO                  = 0x20000000L,
      /* Korean Language Modes */
    sobitKoreanNoAuxCombine         = 0x10000000L,  /* Auxiliary verb and Auxiliary adjective can combine together. */
    sobitKoreanNoMissSpellDictSearch    = 0x20000000L,  /* Search frequently-misspelled-word dictionary. */
    sobitKoreanNoCompoundNounProc  = 0x40000000L,  /* Do not search frequently-misspelled word dictionary */
    sobitKoreanDefault              = 0,    /* Korean default */
      /* German Language Modes */
    sobitGermanUsePrereform         = 0x10000000L,  /* use prereform spelling */
};

  /* Option Set and Get Codes */
enum {
    soselBits,  /*  Set bit-oriented options (as before). */
    soselPossibleBits,  /*  GetOptions only.  The returned value in *piOptRet shows which options can be turned on. */
    soselAutoReplace,   /* AutoReplaceThreshold (0-255) */
};
typedef DWORD SPELLEROPTIONSELECT;  // sosel

//PTEC WINAPI SpellerSetOptions(PROOFID sid, SPELLEROPTIONSELECT sosel, const DWORD iOptVal);

//PTEC WINAPI SpellerGetOptions(PROOFID sid, SPELLEROPTIONSELECT sosel, DWORD *piOptVal);

//PTEC WINAPI SpellerOpenLex(PROOFID sid, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);

//PTEC WINAPI SpellerCloseLex(PROOFID sid, PROOFLEX lex, BOOL fforce);

/* Flag values for dwSpellState field in Sib. */
enum {
    sstateIsContinued       = 0x0001,
    /* Call is continuing from where last call returned.  Must be cleared
    *  for first call into SpellCheck().
    */

    sstateStartsSentence    = 0x0002,
   /* First word in buffer is known to be start of
   *  sentence/paragraph/document.  This is only used if the
   *  fSibIsContinued bit is not set.  It should not be needed if the
   *  fSibIsContinued bit is being used.  If this bit is set during a
   *  suggestion request, suggestions will be capitalized.
   */

    sstateIsEditedChange    = 0x0004,
   /* The run of text represented in the SIB is a change from either
   *  a change pair (change always or change once) edit, or from a
   *  user specified change, possibly from a suggestion list presented
   *  to the user.  This text should be checked for repeat word
   *  problems, and possibly sentence status, but should not be subject
   *  to subsequent spell verification or change pair substitutions.
   *  Note that if an app is not using the fSibIsContinued support,
   *  they do not need to pass in these edited changes, thus bypassing
   *  the potential problem, and working faster.
   */

    sstateNoStateInfo       = 0x0000,
   /* App is responsible for checking for all repeat word and sentence
   *  punctuation, and avoiding processing loops such as change always
   *  can=can can.
   */
};  /* End of Sib Spell State flag definitions. */

typedef enum {
    scmdVerifyBuffer=2,
    scmdSuggest,
    scmdSuggestMore,

    scmdWildcard=6, // no reason to support this
    scmdAnagram,    // or this

    scmdVerifyBufferAutoReplace=10, // Same as VerifyBuffer - but offer AutoReplacements
} SPELLERCOMMAND;   // scmd 

//PTEC WINAPI SpellerCheck(PROOFID sid, SPELLERCOMMAND scmd, const WSIB *psib, WSRB *psrb);
typedef PTEC (WINAPI *SPELLERCHECK)(PROOFID sid, SPELLERCOMMAND scmd, const WSIB *psib, WSRB *psrb);

/* Add the string referenced in pwszAdd to the specified UDR.
The UDR must be either the built-in UserLex UDR or a
UDR opened with UserLex. */
//PTEC WINAPI SpellerAddUdr(PROOFID sid, PROOFLEX lex, const WCHAR *pwszAdd);
typedef PTEC (WINAPI *SPELLERADDUDR) (PROOFID sid, PROOFLEX lex, const WCHAR *pwszAdd);

/* Add the pair of strings referenced in pwszAdd and pwszChange to the specified UDR.
Since this call can only refer to the built-in ChangeOnce or ChangeAlways UDRs, we need
only specify the type. */
//PTEC WINAPI SpellerAddChangeUdr(PROOFID sid, PROOFLEXTYPE lxt, const WCHAR *pwszAdd, const WCHAR *pwszChange);
typedef PTEC (WINAPI *SPELLERADDCHANGEUDR)(PROOFID sid, PROOFLEXTYPE lxt, const WCHAR *pwszAdd, const WCHAR *pwszChange);

/* Delete the specified word referenced in pwszDel from the
specified user dictionary.  If the string is not in dictionary,
the routine still returns success.
If the string found in the specified UDR is the first part
of a change pair entry, then both strings of the change pair
is removed from the word list, i.e., the entire entry is deleted.
The UDR can reference any of the built-in UDR's or a legally
open user dictionary. */
//PTEC WINAPI SpellerDelUdr(PROOFID sid, PROOFLEX lex, const WCHAR *pwszDel);
typedef PTEC (WINAPI *SPELLERDELUDR)(PROOFID sid, PROOFLEX lex, const WCHAR *pwszDel);

/* Completely clears the specified built-in UDR of all entries.
Note that in order to completely purge the built-in UDR's, this
call would have to be made once for each of UserLex,
lxtChangeOnce, and lxtChangeAlways.
Note:
v1 API spellers may not support
SpellerClearUdr for non-built-in dictionary files.  This function
allows multiple document spell checks to clear out the built-in
UDR's between documents, without stopping and restarting a spell
session between every document.
*/
//PTEC WINAPI SpellerClearUdr(PROOFID sid, PROOFLEX lex);
typedef PTEC (WINAPI *SPELLERCLEARUDR)(PROOFID sid, PROOFLEX lex);

/* Determines the number of entries in any of the opened
user dictionaries, including the built-in dictionaries.
Note that spell pair entries are considered a single entry.
*/
//PTEC WINAPI SpellerGetSizeUdr(PROOFID sid, PROOFLEX lex, DWORD *pcWords);
typedef PTEC (WINAPI *SPELLERGETSIZEUDR)(PROOFID sid, PROOFLEX lex, DWORD *pcWords);

/* This function lists the contents of any of the open user
dictionaries, which includes the exclusion or built-in
dictionaries.
The WSRB is filled with null terminated strings (Sz's) from the
specified UDR starting at the entry indexed by the iszStart
parameter until the buffer is full, or until the end of the file
is reached.  Note that the buffer in the WSRB is overwritten
from the beginning on each call.
For dictionaries with the ChangeAlways or ChangeOnce property,
the entries are returned in a slightly modified way.  Each word
pair entry is stripped of any embedded formatting and divided
into its two parts, and each part is added as a separate Sz
into the WSRB buffer.  Therefore, these types of dictionaries
or word lists always yield an even number of Sz strings in the
WSRB buffer, and represents two Sz's strings for every entry
in the list.
When getting all the words from a dictionary, it is important
to remember that SpellerGetSizeUdr finds the number of entries,
while SpellerGetListUdr gives back a count of strings (WSRB.csz)
in the buffer.  The only way to know when all the words have been
retrieved is by checking WSRB.sstat.  It should contain
SpellRetNoErrors when all words have been returned and
SpellRetMoreInfoThanBufferCouldHold when more words remain.
Although user dictionary entries have embedded formatting to
distinguish their property type, the strings returned in the
WSRB buffer are completely stripped of any formatting or padding,
and are simply terminated as an Sz string.
This routine does not use or reference the ichError or cchError
fields of WSRB, which are used in the SpellerCheck function.
*/
//PTEC WINAPI SpellerGetListUdr(PROOFID sid, PROOFLEX lex, DWORD iszStart, WSRB *psrb);
typedef PTEC (WINAPI *SPELLERGETLISTUDR)(PROOFID sid, PROOFLEX lex, DWORD iszStart, WSRB *psrb);

/* Return the UDR id of one of the built-in user dictionarys. */
//PROOFLEX WINAPI SpellerBuiltinUdr(PROOFID sid, PROOFLEXTYPE lxt);
typedef PROOFLEX (WINAPI *SPELLERBUILTINUDR)(PROOFID sid, PROOFLEXTYPE lxt);

  // Optional Prototypes for possible static linking (not recommended)
#if defined(WINCE) || defined(PROTOTYPES)
PTEC WINAPI SpellerVersion(PROOFINFO *pInfo);
PTEC WINAPI SpellerInit(PROOFID *pSpellerid, const SpellerParams *pParams);
PTEC WINAPI SpellerTerminate(PROOFID splid, BOOL fForce);
PTEC WINAPI SpellerSetOptions(PROOFID splid, DWORD iOptionSelect, const DWORD iOptVal);
PTEC WINAPI SpellerGetOptions(PROOFID splid, DWORD iOptionSelect, DWORD *piOptVal);
PTEC WINAPI SpellerOpenLex(PROOFID splid, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);
PTEC WINAPI SpellerCloseLex(PROOFID splid, PROOFLEX lex, BOOL fforce);
PTEC WINAPI SpellerCheck(PROOFID splid, SPELLERCOMMAND iScc, const WSIB *pSib, WSRB *pSrb);
PTEC WINAPI SpellerAddUdr(PROOFID splid, PROOFLEX udr, const WCHAR *pwszAdd);
PTEC WINAPI SpellerAddChangeUdr(PROOFID splid, PROOFLEXTYPE utype, const WCHAR *pwszAdd, const WCHAR *pwszChange);
PTEC WINAPI SpellerDelUdr(PROOFID splid, PROOFLEX udr, const WCHAR *pwszDel);
PTEC WINAPI SpellerClearUdr(PROOFID splid, PROOFLEX udr);
PTEC WINAPI SpellerGetSizeUdr(PROOFID splid, PROOFLEX udr, DWORD *pcWords);
PTEC WINAPI SpellerGetListUdr(PROOFID splid, PROOFLEX udr, DWORD iszStart, WSRB *pSrb);
PROOFLEX WINAPI SpellerBuiltinUdr(PROOFID splid, PROOFLEXTYPE udrtype);
BOOL WINAPI SpellerSetDllName(const WCHAR *pwszDllName, const UINT uCodePage);
#endif

#if defined(__cplusplus)
}
#endif

#pragma pack(pop, proofapi_h)   // restore to whatever was before

#endif  // SPELLAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\external\inc\vendor.h ===
/*------------------------------------------------------------
    vendor.h - Unified vendor include file

        2/5/97  dougp   created

    Note:  The Natural Language Group maintains this file.
        Please contact us with change requests.
------------------------------------------------------------*/

#if !defined(VENDOR_H)
#define VENDOR_H

/* unified codes */
// I originally used an enum here - but RC doesn't like it

typedef int VENDORID;   // vendorid

#define  vendoridSoftArt            1
#define  vendoridInso               2

  // these came from the original list from the speller
  // but don't conflict with any others - so they are safe for all tools
#define vendoridInformatic         17     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define vendoridAmebis             18     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define vendoridLogos              19     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define vendoridDatecs             20     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define vendoridFilosoft           21     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define vendoridLingsoft           22     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define vendoridPolderland         23     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */


#define  vendoridMicrosoft          64
#define  vendoridSynapse            65              /* Synapse - French(Spelling:Mssp3fr.lex, Mssp3fr.dll) */
#define  vendoridFotonija           66              /* Fotonija - Lithuanian(Spelling:Mssp_lt.lex, Msplt32.dll) - added 3/25/97 */
#define  vendoridFotonja        vendoridFotonija                /* To make up for earlier misspelling */
#define  vendoridHizkia             67              /* Hizkia -Basque (Spelling:Mssp_eu.lex, Mspeu32.dll) - added 5/21/97 */
#define  vendoridExpertSystem       68              /* ExpertSystem - Italian(Spelling:Mssp3lt.lex, Mssp3lt.dll) - added 7/17/97 */
#define  vendoridWYSIWYG            69      /* Various languages as an addon - 2/2/98 */

  // next five added at Ireland's request 3/27/98
#define  vendoridSYS                70  // Croatian - Spelling:Mssp_cr.lex, Mspcr32.dll
#define  vendoridTilde              71  // Latvian - Spelling:Mssp_lv.lex, Msplv32.dll
#define  vendoridSignum             72  // Spanish - Spelling:Mssp3es.lex, Mssp3es.dll
#define  vendoridProLing            73  // Ukrainian - Spelling:Mssp3ua.lex, Mssp3ua.dll
#define  vendoridItautecPhilcoSA    74  // Brazilian - Spelling:mssp3PB.lex, Mssp3PB.dll


/*************** legacy codes ******************/

/* Spell Engine Id's */
#define sidSA    vendoridSoftArt      /* Reserved */
#define sidInso  vendoridInso      /* Inso */
#define sidHM    sidInso      /* Inso was Houghton Mifflin */
#define sidML    3      /* MicroLytics */
#define sidLS    4      /* LanSer Data */
#define sidCT    5      /* Center of Educational Technology */
#define sidHS    6      /* HSoft - Turkish(mssp_tr.lex, Msptr32.dll)*/
#define sidMO    7      /* Morphologic - Romanian(Mssp_ro.lex, Msthro32.dll) and Hungarian(Mssp_hu.lex, Msphu32.dll) */
#define sidTI    8      /* TIP - Polish(Mssp_pl.lex, Mspl32.dll) */
#define sidTIP sidTI
#define sidKF    9      /* Korean Foreign Language University */
#define sidKFL sidKF
#define sidPI    10     /* Priberam Informatica Lince - Portuguese(Mssp3PT.lex, Mssp3PT.dll) */
#define sidPIL sidPI
#define sidColtec   11  /* Coltec (Arabic) */
#define sidGS    sidColtec     /* Glyph Systems - this was an error */
#define sidRA    12     /* Radiar (Romansch) */
#define sidIN    13     /* Intracom - Greek(Mssp_el.lex, Mspel32.dll) */
#define sidSY    14     /* Sylvan */
#define sidHI    15     /* Hizkia (obsolete - use vendoridHizkia) */
#define sidFO    16     /* Forma - Slovak(Mssp_sk.lex, Mspsk32.dll) */
#define sidIF    vendoridInformatic     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define sidAM    vendoridAmebis     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define sidLO    vendoridLogos     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define sidDT    vendoridDatecs     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define sidFS    vendoridFilosoft     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define sidLI    vendoridLingsoft     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define sidPL    vendoridPolderland     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */

  /* Thesaurus Engine Id's */
#define teidSA    vendoridSoftArt
#define teidInso  vendoridInso    /* Inso */
#define teidHM    teidInso    /* Inso was Houghton-Mifflin */
#define teidIF    3    /* Informatic */
#define teidIN    4    /* Intracom */
#define teidMO    5    /* MorphoLogic */
#define teidTI    6    /* TiP */
#define teidPI    7    /* Priberam Informatica Lince */
#define teidAM    8    /* Amebis */
#define teidDT    9    /* Datecs */
#define teidES   10    /* Expert System */
#define teidFS   11    /* Filosoft */
#define teidFO   12    /* Forma */
#define teidHS   13    /* HSoft */
#define teidLI   14    /* Lingsoft */
#define teidLO   15    /* Logos */
#define teidPL   16    /* Polderland */

/* HYphenation Engine ID's */
#define hidSA    vendoridSoftArt
#define hidHM    vendoridInso      /* Houghton Mifflin */
#define hidML    3      /* MicroLytics */
#define hidLS    4      /* LanSer Data */
#define hidFO    5      /* Forma */
#define hidIF    6      /* Informatic */
#define hidAM    7      /* Amebis */
#define hidDT    8      /* Datecs */
#define hidFS    9      /* Filosoft */
#define hidHS   10      /* HSoft */
#define hidLI   11      /* Lingsoft */
#define hidLO   12      /* Logos */
#define hidMO   13      /* MorphoLogic */
#define hidPL   14      /* Polderland */
#define hidTI   15      /* TiP */

/* Grammar Id Engine Defines */
#define geidHM    1    /* Houghton-Mifflin */
#define geidRF    2    /* Reference */
#define geidES    3    /* Expert System */
#define geidLD    4    /* Logidisque */
#define geidSMK   5    /* Sumitomo Kinzoku (Japanese) */
#define geidIF    6    /* Informatic */
#define geidMO    7    /* MorphoLogic */
#define geidMS    8    /* Microsoft Reserved */
#define geidNO    9    /* Novell */
#define geidCTI  10    /* CTI (Greek) */
#define geidAME  11    /* Amebis (Solvenian) */
#define geidTIP  12    /* TIP (Polish) */

#endif  /* VENDOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\defguid.cpp ===
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
#include "pch.hxx"
#include <initguid.h>
#include <ole2.h>
#define INITGUID
#include "mimeole.h"
#include <msoert.h>
#include "envguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\external\inc\wintrust.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996-1998
//
//  File:       wintrust.h
//
//  Contents:   Microsoft Internet Security Trust Provider Model
//
//  History:    31-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef WINTRUST_H
#define WINTRUST_H

#include    <wincrypt.h>

#ifdef __cplusplus
extern "C"
{
#endif


#ifndef WIN_CERT_REVISION_1_0   // there were duplicate definitions in winbase.h
#   define  WT_DEFINE_ALL_APIS
#else
#   undef   WT_DEFINE_ALL_APIS
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//      Client definitions, typedefs, and prototypes
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_DATA Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust to pass necessary information into
//  the Providers.
//
typedef struct _WINTRUST_DATA
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_DATA)

    LPVOID          pPolicyCallbackData;        // optional: used to pass data between the app and policy
    LPVOID          pSIPClientData;             // optional: used to pass data between the app and SIP.

    DWORD           dwUIChoice;                 // required: UI choice.  One of the following.
#                       define      WTD_UI_ALL              1
#                       define      WTD_UI_NONE             2
#                       define      WTD_UI_NOBAD            3
#                       define      WTD_UI_NOGOOD           4

    DWORD           fdwRevocationChecks;        // required: certificate revocation check options
#                       define      WTD_REVOKE_NONE         0x00000000
#                       define      WTD_REVOKE_WHOLECHAIN   0x00000001

    DWORD           dwUnionChoice;              // required: which structure is being passed in?
#                       define      WTD_CHOICE_FILE         1
#                       define      WTD_CHOICE_CATALOG      2
#                       define      WTD_CHOICE_BLOB         3
#                       define      WTD_CHOICE_SIGNER       4
#                       define      WTD_CHOICE_CERT         5
    union
    {
        struct WINTRUST_FILE_INFO_      *pFile;         // individual file
        struct WINTRUST_CATALOG_INFO_   *pCatalog;      // member of a Catalog File
        struct WINTRUST_BLOB_INFO_      *pBlob;         // memory blob
        struct WINTRUST_SGNR_INFO_      *pSgnr;         // signer structure only
        struct WINTRUST_CERT_INFO_      *pCert;
    };

    DWORD           dwStateAction;                      // optional (Catalog File Processing)
#                       define      WTD_STATEACTION_IGNORE           0x00000000
#                       define      WTD_STATEACTION_VERIFY           0x00000001
#                       define      WTD_STATEACTION_CLOSE            0x00000002
#                       define      WTD_STATEACTION_AUTO_CACHE       0x00000003
#                       define      WTD_STATEACTION_AUTO_CACHE_FLUSH 0x00000004

    HANDLE          hWVTStateData;                      // optional (Catalog File Processing)

    WCHAR           *pwszURLReference;          // optional: (future) used to determine zone.

    // 17-Feb-1998 philh: added
    DWORD           dwProvFlags;
#       define WTD_PROV_FLAGS_MASK          0x0000FFFF
#       define WTD_USE_IE4_TRUST_FLAG       0x00000001
#       define WTD_NO_IE4_CHAIN_FLAG        0x00000002
#       define WTD_NO_POLICY_USAGE_FLAG     0x00000004
} WINTRUST_DATA, *PWINTRUST_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_FILE_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against an individual file.
//
typedef struct WINTRUST_FILE_INFO_
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_FILE_INFO)

    LPCWSTR         pcwszFilePath;              // required, file name to be verified
    HANDLE          hFile;                      // optional, open handle to pcwszFilePath

    // 09-Dec-1997 pberkman: added
    GUID            *pgKnownSubject;            // optional: fill if the subject type is known.

} WINTRUST_FILE_INFO, *PWINTRUST_FILE_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CATALOG_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a member of a Microsoft Catalog
//  file.
//
typedef struct WINTRUST_CATALOG_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_CATALOG_INFO)

    DWORD           dwCatalogVersion;       // optional: Catalog version number
    LPCWSTR         pcwszCatalogFilePath;   // required: path/name to Catalog file

    LPCWSTR         pcwszMemberTag;         // required: tag to member in Catalog
    LPCWSTR         pcwszMemberFilePath;    // required: path/name to member file
    HANDLE          hMemberFile;            // optional: open handle to pcwszMemberFilePath

    // 30-Oct-1997 pberkman: added
    BYTE            *pbCalculatedFileHash;  // optional: pass in the calculated hash
    DWORD           cbCalculatedFileHash;   // optional: pass in the count bytes of the calc hash

    // 15-Jan-1998 pberkman: added
    PCCTL_CONTEXT   pcCatalogContext;       // optional: pass in to use instead of CatalogFilePath.

} WINTRUST_CATALOG_INFO, *PWINTRUST_CATALOG_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_BLOB_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a memory blob.
//
typedef struct WINTRUST_BLOB_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_BLOB_INFO)

    GUID            gSubject;               // SIP to load

    LPCWSTR         pcwszDisplayName;       // display name of object

    DWORD           cbMemObject;
    BYTE            *pbMemObject;

    DWORD           cbMemSignedMsg;
    BYTE            *pbMemSignedMsg;

} WINTRUST_BLOB_INFO, *PWINTRUST_BLOB_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_SGNR_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CMSG_SIGNER_INFO Structure
//
typedef struct WINTRUST_SGNR_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_SGNR_INFO)

    LPCWSTR         pcwszDisplayName;       // name of the "thing" the pbMem is pointing to.

    CMSG_SIGNER_INFO *psSignerInfo;

    DWORD           chStores;               // number of stores in pahStores
    HCERTSTORE      *pahStores;             // array of stores to add to internal list

} WINTRUST_SGNR_INFO, *PWINTRUST_SGNR_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CERT_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CERT_CONTEXT Structure
//
typedef struct WINTRUST_CERT_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_CERT_INFO)

    LPCWSTR         pcwszDisplayName;       // display name

    CERT_CONTEXT    *psCertContext;

    DWORD           chStores;               // number of stores in pahStores
    HCERTSTORE      *pahStores;             // array of stores to add to internal list

    // 17-Nov-1997 pberkman: added
    DWORD           dwFlags;
#                       define      WTCI_DONT_OPEN_STORES   0x00000001  // only open dummy "root" all other are in pahStores.
#                       define      WTCI_OPEN_ONLY_ROOT     0x00000002

    // 26-Nov-1997 pberkman: added
    FILETIME        *psftVerifyAsOf;        // if not null, each cert will be validated as of this time.

} WINTRUST_CERT_INFO, *PWINTRUST_CERT_INFO;

#include <poppack.h>


//////////////////////////////////////////////////////////////////////////////
//
// WinVerifyTrust
//----------------------------------------------------------------------------
//  Exported from WINTRUST.DLL.
//  Call this function to verify the trust based on a digital signer.
//
//  Returns:
//          ERROR_SUCCESS               If the trust is authenticated or
//                                      if the user accepted the risk.
//
//          TRUST_E_PROVIDER_UNKNOWN    there was an error loading one of the
//                                      required Providers.
//
//          all error codes passed back are based on the Policy Provider used.
//
extern LONG WINAPI WinVerifyTrust(HWND hwnd, GUID *pgActionID,
                                  LPVOID pWVTData);


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//      Trust, Policy, and UI Provider definitions, typedefs, and prototypes
//
//  Model:
//      A client wishing to validate trust through WinVerifyTrust will
//      select an appropriate Action ID guid for the call.
//      This guid is defined by each Policy Provider and represents the
//      functions called based on the policy for the given object.
//
//      In this model, the Policy Provider determines which style of UI
//      will be shown to the user (this only applies to style, the
//      determination of whether UI is displayed is set by the calling client
//      in the UI flags member of WINTRUST_DATA).
//
//      Since the function entry points are common (same return value and
//      parameters), it allows Policy Provider developers to take advantage
//      of existing, generic, code to fill the CRYPT_PROVIDER_DATA structure.
//
//      This also allows the developer to simply add the specific policy they
//      need, then, call the generic Policy Provider - if appropriate.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Wintrust Policy Flags
//----------------------------------------------------------------------------
//  These are set during install and can be modified by the user
//  through various means.  The SETREG.EXE utility (found in the Authenticode
//  Tools Pack) will select/deselect each of them.
//
#define WTPF_TRUSTTEST              0x00000020  // trust any "TEST" certificate
#define WTPF_TESTCANBEVALID         0x00000080
#define WTPF_IGNOREEXPIRATION       0x00000100  // Use expiration date
#define WTPF_IGNOREREVOKATION       0x00000200  // Do revocation check
#define WTPF_OFFLINEOK_IND          0x00000400  // off-line is ok individual certs
#define WTPF_OFFLINEOK_COM          0x00000800  // off-line is ok commercial certs
#define WTPF_OFFLINEOKNBU_IND       0x00001000  // off-line is ok individual certs, no bad ui
#define WTPF_OFFLINEOKNBU_COM       0x00002000  // off-line is ok commercial certs, no bad ui
#define WTPF_VERIFY_V1_OFF          0x00010000  // turn verify of v1 certs off
#define WTPF_IGNOREREVOCATIONONTS   0x00020000  // ignore TimeStamp revocation checks
#define WTPF_ALLOWONLYPERTRUST      0x00040000  // allow only items in personal trust db.

//////////////////////////////////////////////////////////////////////////////
//
// WintrustGetRegPolicyFlags
//----------------------------------------------------------------------------
//  This API call is exported from WINTRUST.DLL and is the recommended method
//  of retrieving the DWORD representing the Policy Flags.
//
extern void WINAPI      WintrustGetRegPolicyFlags(DWORD *pdwPolicyFlags);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustSetRegPolicyFlags
//----------------------------------------------------------------------------
//  This API call is exported from WINTRUST.DLL and is the recommended method
//  of setting the DWORD representing the Policy Flags.  MAKE SURE to call
//  WintrustGetRegPolicyFlags to get the current value and or/and the value
//  you need then call the set the flags.
//
extern BOOL WINAPI      WintrustSetRegPolicyFlags(DWORD dwPolicyFlags);



//////////////////////////////////////////////////////////////////////////////
//
// Trust Provider "Step" Error defines
//----------------------------------------------------------------------------
//  Each "step" of the Trust process has an error "slot" associated with it.
//  If an error occurs, the "step" will assign its result to this "slot".  These
//  errors can be any valid WINERROR.H HRESULT code.
//

    //
    //  step errors 0 through 20 are reserved for Authenticode specific.  If
    //  you are not calling any of the SOFTPUB.DLL (Authenticode) providers, you
    //  may use these as needed.
    //
#define TRUSTERROR_STEP_WVTPARAMS                   0
#define TRUSTERROR_STEP_FILEIO                      2
#define TRUSTERROR_STEP_SIP                         3
#define TRUSTERROR_STEP_SIPSUBJINFO                 5
#define TRUSTERROR_STEP_CATALOGFILE                 6
#define TRUSTERROR_STEP_CERTSTORE                   7
#define TRUSTERROR_STEP_MESSAGE                     8
#define TRUSTERROR_STEP_MSG_SIGNERCOUNT             9
#define TRUSTERROR_STEP_MSG_INNERCNTTYPE            10
#define TRUSTERROR_STEP_MSG_INNERCNT                11
#define TRUSTERROR_STEP_MSG_STORE                   12
#define TRUSTERROR_STEP_MSG_SIGNERINFO              13
#define TRUSTERROR_STEP_MSG_SIGNERCERT              14
#define TRUSTERROR_STEP_MSG_CERTCHAIN               15
#define TRUSTERROR_STEP_MSG_COUNTERSIGINFO          16
#define TRUSTERROR_STEP_MSG_COUNTERSIGCERT          17
#define TRUSTERROR_STEP_VERIFY_MSGHASH              18
#define TRUSTERROR_STEP_VERIFY_MSGINDIRECTDATA      19

    //
    //  step errors 30 through 37 are reserved for the ending error code for each
    //  entry point in the Trust Model.
    //
#define TRUSTERROR_STEP_FINAL_WVTINIT               30
#define TRUSTERROR_STEP_FINAL_INITPROV              31
#define TRUSTERROR_STEP_FINAL_OBJPROV               32
#define TRUSTERROR_STEP_FINAL_SIGPROV               33
#define TRUSTERROR_STEP_FINAL_CERTPROV              34
#define TRUSTERROR_STEP_FINAL_CERTCHKPROV           35
#define TRUSTERROR_STEP_FINAL_POLICYPROV            36
#define TRUSTERROR_STEP_FINAL_UIPROV                37

#define TRUSTERROR_MAX_STEPS                        38

//////////////////////////////////////////////////////////////////////////////
//
//  allocation and free function prototypes
//----------------------------------------------------------------------------
//
typedef void        *(*PFN_CPD_MEM_ALLOC)(IN DWORD cbSize);
typedef void        (*PFN_CPD_MEM_FREE)(IN void *pvMem2Free);

typedef BOOL        (*PFN_CPD_ADD_STORE)(IN struct _CRYPT_PROVIDER_DATA *pProvData,
                                         IN HCERTSTORE hStore2Add);

typedef BOOL        (*PFN_CPD_ADD_SGNR)(IN          struct _CRYPT_PROVIDER_DATA *pProvData,
                                        IN          BOOL fCounterSigner,
                                        IN OPTIONAL DWORD idxSigner,
                                        IN          struct _CRYPT_PROVIDER_SGNR *pSgnr2Add);

typedef BOOL        (*PFN_CPD_ADD_CERT)(IN          struct _CRYPT_PROVIDER_DATA *pProvData,
                                        IN          DWORD idxSigner,
                                        IN          BOOL fCounterSigner,
                                        IN OPTIONAL DWORD idxCounterSigner,
                                        IN          PCCERT_CONTEXT pCert2Add);

typedef BOOL        (*PFN_CPD_ADD_PRIVDATA)(IN struct _CRYPT_PROVIDER_DATA *pProvData,
                                            IN struct _CRYPT_PROVIDER_PRIVDATA *pPrivData2Add);

//////////////////////////////////////////////////////////////////////////////
//
//  Provider function prototypes
//----------------------------------------------------------------------------
//

//
//  entry point for the object provider
//
typedef HRESULT     (*PFN_PROVIDER_INIT_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the object provider
//
typedef HRESULT     (*PFN_PROVIDER_OBJTRUST_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Signature Provider
//
typedef HRESULT     (*PFN_PROVIDER_SIGTRUST_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Certificate Provider
//
typedef HRESULT     (*PFN_PROVIDER_CERTTRUST_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's final call (from the trust provider)
//
typedef HRESULT     (*PFN_PROVIDER_FINALPOLICY_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's "dump structure" call
//
typedef HRESULT     (*PFN_PROVIDER_TESTFINALPOLICY_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's clean up routine for any PRIVDATA allocated
//
typedef HRESULT     (*PFN_PROVIDER_CLEANUP_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's Cert Check call.  This will return
//  true if the Trust Provider is to continue building the certificate chain.
//  If the PP returns FALSE, it is assumed that we have reached a "TRUSTED",
//  self-signed, root.  it is also the CertCheck's responsibility to set the
//  fTrustedRoot flag in the certificate structure.
//
typedef BOOL        (*PFN_PROVIDER_CERTCHKPOLICY_CALL)( IN          struct _CRYPT_PROVIDER_DATA *pProvData,
                                                        IN          DWORD idxSigner,
                                                        IN          BOOL fCounterSignerChain,
                                                        IN OPTIONAL DWORD idxCounterSigner);


#define WVT_OFFSETOF(t,f)   ((ULONG_PTR)(&((t*)0)->f))

#define WVT_ISINSTRUCT(structtypedef, structpassedsize, member) \
                    ((WVT_OFFSETOF(structtypedef, member) < structpassedsize) ? TRUE : FALSE)


#define WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(structtypedef, structpassedsize, member) \
                    WVT_ISINSTRUCT(structtypedef, structpassedsize, member)

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_DATA Structure
//----------------------------------------------------------------------------
//  Used to pass information between WinVerifyTrust and all of the Provider
//  calls.
//
//  IMPORTANT:  1.  All dynamically allocated members MUST use the allocation
//                  and Add2 functions provided.
//
typedef struct _CRYPT_PROVIDER_DATA
{
    DWORD                               cbStruct;               // = sizeof(TRUST_PROVIDER_DATA) (set in WVT)

    WINTRUST_DATA                       *pWintrustData;         // NOT verified (set in WVT)
    BOOL                                fOpenedFile;            // the provider opened the file handle (if applicable)
    HWND                                hWndParent;             // if passed in, else, Desktop hWnd (set in WVT).
    GUID                                *pgActionID;            // represents the Provider combination (set in WVT).

    HCRYPTPROV                          hProv;                  // set to NULL to let CryptoAPI to assign.

    DWORD                               dwError;                // error if a low-level, system error was encountered

    DWORD                               dwRegSecuritySettings;  // ie security settings (set in WVT)
    DWORD                               dwRegPolicySettings;    // setreg settings (set in WVT)

    struct _CRYPT_PROVIDER_FUNCTIONS    *psPfns;                // set in WVT.

    DWORD                               cdwTrustStepErrors;     // set in WVT.
    DWORD                               *padwTrustStepErrors;   // allocated in WVT.  filled in WVT & Trust Provider

    DWORD                               chStores;               // number of stores in pahStores (root set in WVT)
    HCERTSTORE                          *pahStores;             // array of known stores (root set in WVT) root is ALWAYS #0!!!

    DWORD                               dwEncoding;             // message encoding type (set in WVT and Signature Prov)
    HCRYPTMSG                           hMsg;                   // set in Signature Prov.

    DWORD                               csSigners;              // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_SGNR         *pasSigners;            // use Add2 and Get functions!

    DWORD                               csProvPrivData;         // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_PRIVDATA     *pasProvPrivData;       // use Add2 and Get functions!

    DWORD                               dwSubjectChoice;
#                       define              CPD_CHOICE_SIP          1

    union
    {
        struct _PROVDATA_SIP            *pPDSip;
    };

    char                                *pszUsageOID;           // set in Init Provider

    // 03-Oct-1997 pberkman: added
    BOOL                                fRecallWithState;       // state was maintained for Catalog Files.

    // 10-Nov-1997 pberkman: added
    FILETIME                            sftSystemTime;

    // 16-Jan-1998 pberkman: added
    char                                *pszCTLSignerUsageOID;

    // 17-Feb-1998 philh: added
    // LOWORD intialized from WINTRUST_DATA's dwProvFlags.
    //
    // Debug version reads "DEBUG_TRUST_PROV_FLAGS" environment variable
    // and OR's with WINTRUST_DATA's dwProvFlags to initialize the LOWORD.
    DWORD                               dwProvFlags;
#       define CPD_USE_NT5_CHAIN_FLAG       0x80000000

    // 24-Feb-1998 philh: added
    DWORD                               dwFinalError;

    // 20-May-1998 KeithV: added
    PCERT_USAGE_MATCH					pRequestUsage;

} CRYPT_PROVIDER_DATA, *PCRYPT_PROVIDER_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_FUNCTIONS structure
//----------------------------------------------------------------------------
//
typedef struct _CRYPT_PROVIDER_FUNCTIONS
{
    DWORD                               cbStruct;

    PFN_CPD_MEM_ALLOC                   pfnAlloc;               // set in WVT
    PFN_CPD_MEM_FREE                    pfnFree;                // set in WVT

    PFN_CPD_ADD_STORE                   pfnAddStore2Chain;      // call to add a store to the chain.
    PFN_CPD_ADD_SGNR                    pfnAddSgnr2Chain;       // call to add a sgnr struct to a msg struct sgnr chain
    PFN_CPD_ADD_CERT                    pfnAddCert2Chain;       // call to add a cert struct to a sgnr struct cert chain
    PFN_CPD_ADD_PRIVDATA                pfnAddPrivData2Chain;   // call to add provider private data to struct.

    PFN_PROVIDER_INIT_CALL              pfnInitialize;          // initialize Policy data.
    PFN_PROVIDER_OBJTRUST_CALL          pfnObjectTrust;         // build info up to the signer info(s).
    PFN_PROVIDER_SIGTRUST_CALL          pfnSignatureTrust;      // build info to the signing cert
    PFN_PROVIDER_CERTTRUST_CALL         pfnCertificateTrust;    // build the chain
    PFN_PROVIDER_FINALPOLICY_CALL       pfnFinalPolicy;         // final call to policy
    PFN_PROVIDER_CERTCHKPOLICY_CALL     pfnCertCheckPolicy;     // check each cert will building chain
    PFN_PROVIDER_TESTFINALPOLICY_CALL   pfnTestFinalPolicy;     // dump structures to a file (or whatever the policy chooses)

    struct _CRYPT_PROVUI_FUNCS          *psUIpfns;

                    // 23-Jul-1997 pberkman: added
    PFN_PROVIDER_CLEANUP_CALL           pfnCleanupPolicy;       // PRIVDATA cleanup routine.

} CRYPT_PROVIDER_FUNCTIONS, *PCRYPT_PROVIDER_FUNCTIONS;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVUI_FUNCS structure
//----------------------------------------------------------------------------
//

typedef BOOL        (*PFN_PROVUI_CALL)(IN HWND hWndSecurityDialog, IN struct _CRYPT_PROVIDER_DATA *pProvData);

typedef struct _CRYPT_PROVUI_FUNCS
{
    DWORD                               cbStruct;

    struct _CRYPT_PROVUI_DATA           *psUIData;

    PFN_PROVUI_CALL                     pfnOnMoreInfoClick;
    PFN_PROVUI_CALL                     pfnOnMoreInfoClickDefault;

    PFN_PROVUI_CALL                     pfnOnAdvancedClick;
    PFN_PROVUI_CALL                     pfnOnAdvancedClickDefault;

} CRYPT_PROVUI_FUNCS, *PCRYPT_PROVUI_FUNCS;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVUI_DATA
//----------------------------------------------------------------------------
//
typedef struct _CRYPT_PROVUI_DATA
{
    DWORD                               cbStruct;

    DWORD                               dwFinalError;

    WCHAR                               *pYesButtonText;        // default: "&Yes"
    WCHAR                               *pNoButtonText;         // default: "&No"
    WCHAR                               *pMoreInfoButtonText;   // default: "&More Info"
    WCHAR                               *pAdvancedLinkText;     // default: <none>

    // 15-Sep-1997 pberkman: added
        // good: default:
                // "Do you want to install and run ""%1"" signed on %2 and distributed by:"
    WCHAR                               *pCopyActionText;
        // good no time stamp: default:
                // "Do you want to install and run ""%1"" signed on an unknown date/time and distributed by:"
    WCHAR                               *pCopyActionTextNoTS;
        // bad: default:
                // "Do you want to install and run ""%1""?"
    WCHAR                               *pCopyActionTextNotSigned;


} CRYPT_PROVUI_DATA, *PCRYPT_PROVUI_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_SGNR structure
//----------------------------------------------------------------------------
//  After the Signature Provider is finished there will be zero to many of these
//  filled out.  One for each signer of the message.  Also, there will be zero
//  to many of these filled out inside this structure.  One for each counter
//  signer of the signer.
//
//  IMPORTANT:  1.  All dynamically allocated members MUST use allocation
//                  and Add2 functions provided.
//
typedef struct _CRYPT_PROVIDER_SGNR
{
    DWORD                               cbStruct;

    FILETIME                            sftVerifyAsOf;      // either today's filetime or the timestamps

    DWORD                               csCertChain;        // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_CERT         *pasCertChain;      // use Add2 and Get functions!

    DWORD                               dwSignerType;       // set if known by policy
#                                           define  SGNR_TYPE_TIMESTAMP     0x00000010

    CMSG_SIGNER_INFO                    *psSigner;          // must use the pfnAlloc allocator!

    DWORD                               dwError;            // error encounted while building/verifying the signer.

    DWORD                               csCounterSigners;   // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_SGNR         *pasCounterSigners; // use Add2 and Get functions!

    // 11-Feb-1998 philh: added
    PCCERT_CHAIN_CONTEXT                pChainContext;

} CRYPT_PROVIDER_SGNR, *PCRYPT_PROVIDER_SGNR;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_CERT structure
//----------------------------------------------------------------------------
//  After the Signature and Certificate Providers are finished there will
//  be zero to many of these filled out in the CRYPT_PROVIDER_SGNR
//  structure.  One for each certificate in the chain.
//
//
typedef struct _CRYPT_PROVIDER_CERT
{
    DWORD                               cbStruct;

    PCCERT_CONTEXT                      pCert;              // must have its own ref-count!

    BOOL                                fCommercial;
    BOOL                                fTrustedRoot;       // certchk policy should set this.
    BOOL                                fSelfSigned;        // set in cert provider

    BOOL                                fTestCert;          // certchk policy will set

    DWORD                               dwRevokedReason;

    DWORD                               dwConfidence;       // set in the Certificate Provider
#                                           define  CERT_CONFIDENCE_SIG             0x10000000  // this cert
#                                           define  CERT_CONFIDENCE_TIME            0x01000000  // issuer cert
#                                           define  CERT_CONFIDENCE_TIMENEST        0x00100000  // this cert
#                                           define  CERT_CONFIDENCE_AUTHIDEXT       0x00010000  // this cert
#                                           define  CERT_CONFIDENCE_HYGIENE         0x00001000  // this cert
#                                           define  CERT_CONFIDENCE_HIGHEST         0x11111000

    DWORD                               dwError;

    CTL_CONTEXT                         *pTrustListContext;

    // 16-Jan-1998 pberkman: added
    BOOL                                fTrustListSignerCert;

    // 25-Feb-1998 philh: added
    //
    // The following two are only applicable to Self Signed certificates
    // residing in a CTL.
    PCCTL_CONTEXT                       pCtlContext;
    DWORD                               dwCtlError;

    // 12-Mar-1998 philh: added
    BOOL                                fIsCyclic;

    // 12-Oct-2000 DSIE: added
    PCERT_CHAIN_ELEMENT                 pChainElement;

} CRYPT_PROVIDER_CERT, *PCRYPT_PROVIDER_CERT;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_PRIVDATA structure
//----------------------------------------------------------------------------
//  This structure is to allow Policy Provider functions to share
//  POLICY SPECIFIC data between Policy Functions.
//  The Policy must use the pfnAddPrivateData2Chain function and
//  must free any data within the member before the Final Policy returns
//  to WVT.
//  To allow multiple providers to use this feature, each provider that
//  uses this member must set the provider ID to it's Action ID so that
//  the provider can find its data and ignore any other.
//
typedef struct _CRYPT_PROVIDER_PRIVDATA
{
    DWORD                               cbStruct;

    GUID                                gProviderID;

    DWORD                               cbProvData;
    void                                *pvProvData;

} CRYPT_PROVIDER_PRIVDATA, *PCRYPT_PROVIDER_PRIVDATA;

//////////////////////////////////////////////////////////////////////////////
//
// PROVDATA_SIP
//----------------------------------------------------------------------------
//
typedef struct _PROVDATA_SIP
{
    DWORD                               cbStruct;               // = sizeof(PROVDATA_SIP)

    GUID                                gSubject;               // subject guid of file/member file. (set in Sig Prov)

    struct SIP_DISPATCH_INFO_           *pSip;                  // set in Sig Prov - defined in sipbase.h
    struct SIP_DISPATCH_INFO_           *pCATSip;               // set in Sig Prov - defined in sipbase.h
    struct SIP_SUBJECTINFO_             *psSipSubjectInfo;      // set in Sig Prov - defined in sipbase.h
    struct SIP_SUBJECTINFO_             *psSipCATSubjectInfo;   // set in Sig Prov - defined in sipbase.h
    struct SIP_INDIRECT_DATA_           *psIndirectData;        // set in Sig Prov - defined in sipbase.h

} PROVDATA_SIP, *PPROVDATA_SIP;

//////////////////////////////////////////////////////////////////////////////
//
// structures used to register action IDs
//----------------------------------------------------------------------------
//
#define WT_CURRENT_VERSION                  0x00000200

typedef struct _CRYPT_TRUST_REG_ENTRY
{
    DWORD                               cbStruct;

    WCHAR                               *pwszDLLName;
    WCHAR                               *pwszFunctionName;  // no more than WT_MAX_FUNC_NAME!

} CRYPT_TRUST_REG_ENTRY, *PCRYPT_TRUST_REG_ENTRY;

typedef struct _CRYPT_REGISTER_ACTIONID
{
    DWORD                               cbStruct;

    CRYPT_TRUST_REG_ENTRY               sInitProvider;
    CRYPT_TRUST_REG_ENTRY               sObjectProvider;
    CRYPT_TRUST_REG_ENTRY               sSignatureProvider;
    CRYPT_TRUST_REG_ENTRY               sCertificateProvider;
    CRYPT_TRUST_REG_ENTRY               sCertificatePolicyProvider;
    CRYPT_TRUST_REG_ENTRY               sFinalPolicyProvider;
    CRYPT_TRUST_REG_ENTRY               sTestPolicyProvider;

                    // 23-Jul-1997 pberkman: added
    CRYPT_TRUST_REG_ENTRY               sCleanupProvider;

} CRYPT_REGISTER_ACTIONID, *PCRYPT_REGISTER_ACTIONID;

typedef BOOL (*PFN_ALLOCANDFILLDEFUSAGE)(IN const char *pszUsageOID,
                                         IN struct _CRYPT_PROVIDER_DEFUSAGE *psDefUsage);
typedef BOOL (*PFN_FREEDEFUSAGE)(IN const char *pszUsageOID,
                                 IN struct _CRYPT_PROVIDER_DEFUSAGE *psDefUsage);

typedef struct _CRYPT_PROVIDER_REGDEFUSAGE
{
    DWORD                   cbStruct;   // = sizeof CRYPT_PROVIDER_REGDEFUSAGE

    GUID                    *pgActionID;

    WCHAR                   *pwszDllName;
    char                    *pwszLoadCallbackDataFunctionName;
    char                    *pwszFreeCallbackDataFunctionName;

} CRYPT_PROVIDER_REGDEFUSAGE, *PCRYPT_PROVIDER_REGDEFUSAGE;

typedef struct _CRYPT_PROVIDER_DEFUSAGE
{
    DWORD                   cbStruct;               // = sizeof CRYPT_PROVIDER_DEFUSAGE

    GUID                    gActionID;            // ActionID of provider

    LPVOID                  pDefPolicyCallbackData; // normally filled in WINTRUST_DATA
    LPVOID                  pDefSIPClientData;      // normally filled in WINTRUST_DATA

} CRYPT_PROVIDER_DEFUSAGE, *PCRYPT_PROVIDER_DEFUSAGE;

#include <poppack.h>

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST.DLL Provider defines
//----------------------------------------------------------------------------
//  The following are definitions of the Microsoft Generic Cert Provider
//
#define WT_PROVIDER_DLL_NAME                L"WINTRUST.DLL"
#define WT_PROVIDER_CERTTRUST_FUNCTION      L"WintrustCertificateTrust"

//////////////////////////////////////////////////////////////////////////////
//
// WintrustAddActionID
//----------------------------------------------------------------------------
//  Adds a new Provider combination to the users'
//  system.  Creates all necessary registry entries, etc.  This should be done
//  during the Policy Provider's DllRegisterServer.
//
//  *** THE ONLY ONE WHO SHOULD CALL THIS IS THE POLICY PROVIDER ***
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
extern BOOL WINAPI  WintrustAddActionID(IN GUID *pgActionID,
                                        IN DWORD fdwReserved,    // future use.
                                        IN CRYPT_REGISTER_ACTIONID *psProvInfo);


//////////////////////////////////////////////////////////////////////////////
//
// WintrustRemoveActionID
//----------------------------------------------------------------------------
//  Removes the Provider action combination from the users'
//  system.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
extern BOOL WINAPI  WintrustRemoveActionID(IN GUID *pgActionID);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustLoadFunctionPointers
//----------------------------------------------------------------------------
//  Retrieves the function entry points based on the Action ID given.
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
extern BOOL WINAPI WintrustLoadFunctionPointers(GUID *pgActionID, CRYPT_PROVIDER_FUNCTIONS *pPfns);


//////////////////////////////////////////////////////////////////////////////
//
// WintrustAddDefaultForUsage
//----------------------------------------------------------------------------
//  Sets the default Action ID for the usage.  If the provider uses this
//  function, and the provider requires any of the "callback" data in
//  WINTRUST_DATA to be filled out, it MUST completely fill out the
//  CRYPT_PROVIDER_REGDEFUSAGE structure.
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
extern BOOL WINAPI              WintrustAddDefaultForUsage(IN const char *pszUsageOID,
                                                           IN CRYPT_PROVIDER_REGDEFUSAGE *psDefUsage);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustGetDefaultForUsage
//----------------------------------------------------------------------------
//  Retrieves the Action ID and default callback data for the specified usage
//
//  this function must be called again with dwAction set to FREE to deallocate
//
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
#define                             DWACTION_ALLOCANDFILL           1
#define                             DWACTION_FREE                   2
extern BOOL WINAPI              WintrustGetDefaultForUsage(IN DWORD dwAction,
                                                           IN const char *pszUsageOID,
                                                           IN OUT CRYPT_PROVIDER_DEFUSAGE *psUsage);

extern CRYPT_PROVIDER_SGNR * WINAPI     WTHelperGetProvSignerFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                                       DWORD idxSigner,
                                                                       BOOL fCounterSigner,
                                                                       DWORD idxCounterSigner);
extern CRYPT_PROVIDER_CERT * WINAPI     WTHelperGetProvCertFromChain(CRYPT_PROVIDER_SGNR *pSgnr,
                                                                     DWORD idxCert);

extern CRYPT_PROVIDER_DATA * WINAPI     WTHelperProvDataFromStateData(HANDLE hStateData);

extern CRYPT_PROVIDER_PRIVDATA * WINAPI WTHelperGetProvPrivateDataFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                                            GUID *pgProviderID);
extern BOOL WINAPI                      WTHelperCertIsSelfSigned(DWORD dwEncoding, CERT_INFO *pCert);

//////////////////////////////////////////////////////////////////////////////
//
// Supported ASN structures contained in WINTRUST.DLL
//----------------------------------------------------------------------------
//
#include <pshpack8.h>

//
//  CTL Trusted CA Lists
//
#define szOID_TRUSTED_CODESIGNING_CA_LIST   "1.3.6.1.4.1.311.2.2.1"
#define szOID_TRUSTED_CLIENT_AUTH_CA_LIST   "1.3.6.1.4.1.311.2.2.2"
#define szOID_TRUSTED_SERVER_AUTH_CA_LIST   "1.3.6.1.4.1.311.2.2.3"

//
//  encode/decode OID defines
//
#define SPC_COMMON_NAME_OBJID               szOID_COMMON_NAME
#define SPC_TIME_STAMP_REQUEST_OBJID        "1.3.6.1.4.1.311.3.2.1"
#define SPC_INDIRECT_DATA_OBJID             "1.3.6.1.4.1.311.2.1.4"
#define SPC_SP_AGENCY_INFO_OBJID            "1.3.6.1.4.1.311.2.1.10"
#define SPC_STATEMENT_TYPE_OBJID            "1.3.6.1.4.1.311.2.1.11"
#define SPC_SP_OPUS_INFO_OBJID              "1.3.6.1.4.1.311.2.1.12"
#define SPC_CERT_EXTENSIONS_OBJID           "1.3.6.1.4.1.311.2.1.14"
#define SPC_PE_IMAGE_DATA_OBJID             "1.3.6.1.4.1.311.2.1.15"
#define SPC_RAW_FILE_DATA_OBJID             "1.3.6.1.4.1.311.2.1.18"
#define SPC_STRUCTURED_STORAGE_DATA_OBJID   "1.3.6.1.4.1.311.2.1.19"
#define SPC_JAVA_CLASS_DATA_OBJID           "1.3.6.1.4.1.311.2.1.20"
#define SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.21"
#define SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.22"
#define SPC_CAB_DATA_OBJID                  "1.3.6.1.4.1.311.2.1.25"
#define SPC_GLUE_RDN_OBJID                  "1.3.6.1.4.1.311.2.1.25"    // obsolete!
#define SPC_MINIMAL_CRITERIA_OBJID          "1.3.6.1.4.1.311.2.1.26"
#define SPC_FINANCIAL_CRITERIA_OBJID        "1.3.6.1.4.1.311.2.1.27"
#define SPC_LINK_OBJID                      "1.3.6.1.4.1.311.2.1.28"
#define SPC_SIGINFO_OBJID                   "1.3.6.1.4.1.311.2.1.30"

#define CAT_NAMEVALUE_OBJID                 "1.3.6.1.4.1.311.12.2.1"
#define CAT_MEMBERINFO_OBJID                "1.3.6.1.4.1.311.12.2.2"


//
//  encode/decode internal defines
//
#define SPC_SP_AGENCY_INFO_STRUCT           ((LPCSTR) 2000)
#define SPC_MINIMAL_CRITERIA_STRUCT         ((LPCSTR) 2001)
#define SPC_FINANCIAL_CRITERIA_STRUCT       ((LPCSTR) 2002)
#define SPC_INDIRECT_DATA_CONTENT_STRUCT    ((LPCSTR) 2003)
#define SPC_PE_IMAGE_DATA_STRUCT            ((LPCSTR) 2004)
#define SPC_LINK_STRUCT                     ((LPCSTR) 2005)
#define SPC_STATEMENT_TYPE_STRUCT           ((LPCSTR) 2006)
#define SPC_SP_OPUS_INFO_STRUCT             ((LPCSTR) 2007)
#define SPC_CAB_DATA_STRUCT                 ((LPCSTR) 2008)
#define SPC_JAVA_CLASS_DATA_STRUCT          ((LPCSTR) 2009)

#define SPC_SIGINFO_STRUCT                  ((LPCSTR) 2130)

#define CAT_NAMEVALUE_STRUCT                ((LPCSTR) 2221)
#define CAT_MEMBERINFO_STRUCT               ((LPCSTR) 2222)


#define SPC_UUID_LENGTH     16
typedef BYTE SPC_UUID[SPC_UUID_LENGTH];

typedef struct _SPC_SERIALIZED_OBJECT
{
    SPC_UUID            ClassId;
    CRYPT_DATA_BLOB     SerializedData;

} SPC_SERIALIZED_OBJECT, *PSPC_SERIALIZED_OBJECT;

typedef struct SPC_SIGINFO_
{
    DWORD       dwSipVersion;
    GUID        gSIPGuid;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
    DWORD       dwReserved5;

} SPC_SIGINFO, *PSPC_SIGINFO;

typedef struct SPC_LINK_
{
    DWORD dwLinkChoice;
#               define          SPC_URL_LINK_CHOICE         1
#               define          SPC_MONIKER_LINK_CHOICE     2
#               define          SPC_FILE_LINK_CHOICE        3

    union
    {
        LPWSTR                  pwszUrl;
        SPC_SERIALIZED_OBJECT   Moniker;
        LPWSTR                  pwszFile;
    };

} SPC_LINK, *PSPC_LINK;

typedef struct _SPC_PE_IMAGE_DATA
{
    CRYPT_BIT_BLOB            Flags;
    PSPC_LINK                 pFile;

} SPC_PE_IMAGE_DATA, *PSPC_PE_IMAGE_DATA;

typedef struct _SPC_INDIRECT_DATA_CONTENT
{
    CRYPT_ATTRIBUTE_TYPE_VALUE  Data;
    CRYPT_ALGORITHM_IDENTIFIER  DigestAlgorithm;
    CRYPT_HASH_BLOB             Digest;

} SPC_INDIRECT_DATA_CONTENT, *PSPC_INDIRECT_DATA_CONTENT;

typedef struct _SPC_FINANCIAL_CRITERIA
{
    BOOL                        fFinancialInfoAvailable;
    BOOL                        fMeetsCriteria;

} SPC_FINANCIAL_CRITERIA, *PSPC_FINANCIAL_CRITERIA;

typedef struct _SPC_IMAGE
{
    struct SPC_LINK_            *pImageLink;
    CRYPT_DATA_BLOB             Bitmap;
    CRYPT_DATA_BLOB             Metafile;
    CRYPT_DATA_BLOB             EnhancedMetafile;
    CRYPT_DATA_BLOB             GifFile;

} SPC_IMAGE, *PSPC_IMAGE;

typedef struct _SPC_SP_AGENCY_INFO
{
    struct SPC_LINK_            *pPolicyInformation;
    LPWSTR                      pwszPolicyDisplayText;
    PSPC_IMAGE                  pLogoImage;
    struct SPC_LINK_            *pLogoLink;

} SPC_SP_AGENCY_INFO, *PSPC_SP_AGENCY_INFO;

typedef struct _SPC_STATEMENT_TYPE
{
    DWORD                       cKeyPurposeId;
    LPSTR                       *rgpszKeyPurposeId;     // pszObjId

} SPC_STATEMENT_TYPE, *PSPC_STATEMENT_TYPE;

typedef struct _SPC_SP_OPUS_INFO
{
    LPCWSTR                     pwszProgramName;
    struct SPC_LINK_            *pMoreInfo;
    struct SPC_LINK_            *pPublisherInfo;

} SPC_SP_OPUS_INFO, *PSPC_SP_OPUS_INFO;

typedef struct _CAT_NAMEVALUE
{
    LPWSTR          pwszTag;
    DWORD           fdwFlags;
    CRYPT_DATA_BLOB Value;

} CAT_NAMEVALUE, *PCAT_NAMEVALUE;

typedef struct _CAT_MEMBERINFO
{
    LPWSTR          pwszSubjGuid;
    DWORD           dwCertVersion;

} CAT_MEMBERINFO, *PCAT_MEMBERINFO;

#include <poppack.h>



//////////////////////////////////////////////////////////////////////////////////
//
//  support for old calling convention: *** DO NOT USE ***
//
#ifdef WT_DEFINE_ALL_APIS

typedef struct _WIN_CERTIFICATE
{
    DWORD       dwLength;
    WORD        wRevision;
    WORD        wCertificateType;   // WIN_CERT_TYPE_xxx
    BYTE        bCertificate[ANYSIZE_ARRAY];

} WIN_CERTIFICATE, *LPWIN_CERTIFICATE;

#define WIN_CERT_REVISION_1_0               (0x0100)
#define WIN_CERT_REVISION_2_0               (0x0200)

#define WIN_CERT_TYPE_X509                  (0x0001)   // bCertificate contains an X.509 Certificate
#define WIN_CERT_TYPE_PKCS_SIGNED_DATA      (0x0002)   // bCertificate contains a PKCS SignedData structure
#define WIN_CERT_TYPE_RESERVED_1            (0x0003)   // Reserved


typedef LPVOID WIN_TRUST_SUBJECT;

typedef struct _WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT
{
    HANDLE            hClientToken;
    GUID *            SubjectType;
    WIN_TRUST_SUBJECT Subject;

} WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT, *LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT ;


typedef struct _WIN_TRUST_ACTDATA_SUBJECT_ONLY
{
    GUID *            SubjectType;
    WIN_TRUST_SUBJECT Subject;

} WIN_TRUST_ACTDATA_SUBJECT_ONLY, *LPWIN_TRUST_ACTDATA_SUBJECT_ONLY;

/* RawFile == 959dc450-8d9e-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_RAW_FILE                              \
            { 0x959dc450,                                        \
              0x8d9e,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* PeImage == 43c9a1e0-8da0-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_PE_IMAGE                              \
            { 0x43c9a1e0,                                        \
              0x8da0,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }


/* JavaClass = 08ad3990-8da1-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_JAVA_CLASS                            \
            { 0x08ad3990,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }
/* Cabinet = d17c5374-a392-11cf-9df5-00aa00c184e0 */
#define WIN_TRUST_SUBJTYPE_CABINET                               \
            { 0xd17c5374,                                        \
              0xa392,                                            \
              0x11cf,                                            \
              { 0x9d, 0xf5, 0x0, 0xaa, 0x0, 0xc1, 0x84, 0xe0 }   \
            }

typedef struct _WIN_TRUST_SUBJECT_FILE
{
    HANDLE  hFile;
    LPCWSTR lpPath;

} WIN_TRUST_SUBJECT_FILE, *LPWIN_TRUST_SUBJECT_FILE;

#define WIN_TRUST_SUBJTYPE_RAW_FILEEX                            \
            { 0x6f458110,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_PE_IMAGEEX                            \
            { 0x6f458111,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_JAVA_CLASSEX                          \
            { 0x6f458113,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_CABINETEX                             \
            { 0x6f458114,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

typedef struct _WIN_TRUST_SUBJECT_FILE_AND_DISPLAY
{
    HANDLE  hFile;              // handle to the open file if you got it
    LPCWSTR lpPath;             // the path to open if you don't
    LPCWSTR lpDisplayName;      // (optional) display name to show to user

} WIN_TRUST_SUBJECT_FILE_AND_DISPLAY, *LPWIN_TRUST_SUBJECT_FILE_AND_DISPLAY;

/* OleStorage == c257e740-8da0-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_OLE_STORAGE                           \
            { 0xc257e740,                                        \
              0x8da0,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }


/* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb */
#define WIN_SPUB_ACTION_TRUSTED_PUBLISHER                        \
            { 0x66426730,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* NtActivateImage == 8bc96b00-8da1-11cf-8736-00aa00a485eb */
#define     WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE                    \
            { 0x8bc96b00,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* PublishedSoftware == 64b9d180-8da2-11cf-8736-00aa00a485eb */
#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE                       \
            { 0x64b9d180,                                        \
              0x8da2,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

typedef struct _WIN_SPUB_TRUSTED_PUBLISHER_DATA
{
    HANDLE            hClientToken;
    LPWIN_CERTIFICATE lpCertificate;

} WIN_SPUB_TRUSTED_PUBLISHER_DATA, *LPWIN_SPUB_TRUSTED_PUBLISHER_DATA;

#endif



#ifdef __cplusplus
}
#endif

#endif // WINTRUST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\external\inc\softpub.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996-1998
//
//  File:       softpub.h
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef SOFTPUB_H
#define SOFTPUB_H

#include "wintrust.h"

#ifdef __cplusplus
extern "C" 
{
#endif

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// Softpub Policy Provider defines
//----------------------------------------------------------------------------
//  The following are definitions of the Microsoft Authenticode Policy Provider
//  (SOFTPUB.DLL's Policy Provider)
//  

#define SP_POLICY_PROVIDER_DLL_NAME         L"SOFTPUB.DLL"

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_VERIFY_V2 Guid  (Authenticode)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a file/object using the Microsoft Authenticode
//  Policy Provider,
//  
//          {00AAC56B-CD44-11d0-8CC2-00C04FC295EE}
//
#define WINTRUST_ACTION_GENERIC_VERIFY_V2                       \
            { 0xaac56b,                                         \
              0xcd44,                                           \
              0x11d0,                                           \
              { 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_INIT_FUNCTION                    L"SoftpubInitialize"
#define SP_OBJTRUST_FUNCTION                L"SoftpubLoadMessage"
#define SP_SIGTRUST_FUNCTION                L"SoftpubLoadSignature"
#define SP_CHKCERT_FUNCTION                 L"SoftpubCheckCert"
#define SP_FINALPOLICY_FUNCTION             L"SoftpubAuthenticode"
#define SP_CLEANUPPOLICY_FUNCTION           L"SoftpubCleanup"

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_TRUSTPROVIDER_TEST (Authenticode TEST)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to dump
//  the CRYPT_PROVIDER_DATA structure to a file after calling the 
//  Authenticode Policy Provider.
//  
//          {573E31F8-DDBA-11d0-8CCB-00C04FC295EE}
//
#define WINTRUST_ACTION_TRUSTPROVIDER_TEST                      \
            { 0x573e31f8,                                       \
              0xddba,                                           \
              0x11d0,                                           \
              { 0x8c, 0xcb, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_TESTDUMPPOLICY_FUNCTION_TEST     L"SoftpubDumpStructure"


//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_CERT_VERIFY
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify
//  a certificate chain only.  This is only valid when passing in a
//  certificate context in the WinVerifyTrust input structures.
//  
//          {189A3842-3041-11d1-85E1-00C04FC295EE}
//
#define WINTRUST_ACTION_GENERIC_CERT_VERIFY                     \
            { 0x189a3842,                                       \
              0x3041,                                           \
              0x11d1,                                           \
              { 0x85, 0xe1, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_GENERIC_CERT_INIT_FUNCTION       L"SoftpubDefCertInit"


//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_CHAIN_VERIFY
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify
//  certificate chains created from any object type: file, cert, signer, ...
//  A callback is provided to implement the final chain policy using
//  the chain context for each signer and counter signer.
//  
//          {fc451c16-ac75-11d1-b4b8-00c04fb66ea0}
//
#define WINTRUST_ACTION_GENERIC_CHAIN_VERIFY                    \
            { 0xfc451c16,                                       \
              0xac75,                                           \
              0x11d1,                                           \
              { 0xb4, 0xb8, 0x00, 0xc0, 0x4f, 0xb6, 0x6e, 0xa0 }\
            }
#define GENERIC_CHAIN_FINALPOLICY_FUNCTION      L"GenericChainFinalProv"
#define GENERIC_CHAIN_CERTTRUST_FUNCTION        L"GenericChainCertificateTrust"


typedef struct _WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO
    WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO,
        *PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO;

struct _WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };
    PCCERT_CHAIN_CONTEXT                    pChainContext;

    // SGNR_TYPE_TIMESTAMP defined in wintrust.h
    DWORD                                   dwSignerType;
    PCMSG_SIGNER_INFO                       pMsgSignerInfo;
    DWORD                                   dwError;

    DWORD                                   cCounterSigner;
    PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO   *rgpCounterSigner;
};

typedef HRESULT (WINAPI *PFN_WTD_GENERIC_CHAIN_POLICY_CALLBACK)(
    IN PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD dwStepError,
    IN DWORD dwRegPolicySettings,
    IN DWORD cSigner,
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *rgpSigner,
    IN void *pvPolicyArg
    );

// The fields in the following data structure are passed to
// CertGetCertificateChain().
typedef struct _WTD_GENERIC_CHAIN_POLICY_CREATE_INFO {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };

    HCERTCHAINENGINE                        hChainEngine;
    PCERT_CHAIN_PARA                        pChainPara;
    DWORD                                   dwFlags;
    void                                    *pvReserved;
} WTD_GENERIC_CHAIN_POLICY_CREATE_INFO, *PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO;

typedef struct _WTD_GENERIC_CHAIN_POLICY_DATA {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };

    PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO   pSignerChainInfo;
    PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO   pCounterSignerChainInfo;
    PFN_WTD_GENERIC_CHAIN_POLICY_CALLBACK   pfnPolicyCallback;
    void                                    *pvPolicyArg;
} WTD_GENERIC_CHAIN_POLICY_DATA, *PWTD_GENERIC_CHAIN_POLICY_DATA;


//////////////////////////////////////////////////////////////////////////////
//
// HTTPSPROV_ACTION Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  SSL/PCT connections through IE.
//  
//          {573E31F8-AABA-11d0-8CCB-00C04FC295EE}
//
#define HTTPSPROV_ACTION                                        \
            { 0x573e31f8,                                       \
              0xaaba,                                           \
              0x11d0,                                           \
              { 0x8c, 0xcb, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define HTTPS_FINALPOLICY_FUNCTION          L"HTTPSFinalProv"
#define HTTPS_CHKCERT_FUNCTION              L"HTTPSCheckCertProv"
#define HTTPS_CERTTRUST_FUNCTION            L"HTTPSCertificateTrust"

// fdwChecks flags are defined in wininet.h
typedef struct _HTTPSPolicyCallbackData
{
    union {
        DWORD           cbStruct;       // sizeof(HTTPSClientData);
        DWORD           cbSize;         // sizeof(HTTPSClientData);
    };

    DWORD           dwAuthType;
#                       define      AUTHTYPE_CLIENT         1
#                       define      AUTHTYPE_SERVER         2

    DWORD           fdwChecks;

    WCHAR           *pwszServerName; // used to check against CN=xxxx

} HTTPSPolicyCallbackData, *PHTTPSPolicyCallbackData,
    SSL_EXTRA_CERT_CHAIN_POLICY_PARA, *PSSL_EXTRA_CERT_CHAIN_POLICY_PARA;




//////////////////////////////////////////////////////////////////////////////
//
// OFFICESIGN_ACTION_VERIFY Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a Structured Storage file using the Microsoft Office
//  Authenticode add-on Policy Provider,
//  
//          {5555C2CD-17FB-11d1-85C4-00C04FC295EE}
//
#define     OFFICESIGN_ACTION_VERIFY                                    \
                { 0x5555c2cd,                                           \
                  0x17fb,                                               \
                  0x11d1,                                               \
                  { 0x85, 0xc4, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }     \
                }

#define     OFFICE_POLICY_PROVIDER_DLL_NAME             SP_POLICY_PROVIDER_DLL_NAME
#define     OFFICE_INITPROV_FUNCTION                    L"OfficeInitializePolicy"
#define     OFFICE_CLEANUPPOLICY_FUNCTION               L"OfficeCleanupPolicy"


//////////////////////////////////////////////////////////////////////////////
//
// DRIVER_ACTION_VERIFY Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a WHQL signed driver.  This is an Authenticode add-on
//  Policy Provider,
//  
//          {F750E6C3-38EE-11d1-85E5-00C04FC295EE}
//
#define     DRIVER_ACTION_VERIFY                                        \
                { 0xf750e6c3,                                           \
                  0x38ee,                                               \
                  0x11d1,                                               \
                  { 0x85, 0xe5, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }     \
                }

#define     DRIVER_INITPROV_FUNCTION                    L"DriverInitializePolicy"
#define     DRIVER_FINALPOLPROV_FUNCTION                L"DriverFinalPolicy"
#define     DRIVER_CLEANUPPOLICY_FUNCTION               L"DriverCleanupPolicy"

typedef struct DRIVER_VER_MAJORMINOR_
{
    DWORD           dwMajor;
    DWORD           dwMinor;

} DRIVER_VER_MAJORMINOR;

typedef struct DRIVER_VER_INFO_
{
    DWORD                               cbStruct;               // IN - set to sizeof(DRIVER_VER_INFO)

    DWORD                               dwReserved1;            // IN - set to NULL
    DWORD                               dwReserved2;            // IN - set to NULL

    DWORD                               dwPlatform;             // IN - OPTIONAL: platform to use
    DWORD				dwVersion;		// IN - OPTIONAL: major version to use, same as sOSVersionLow

    WCHAR                               wszVersion[MAX_PATH];   // OUT: version string from catalog file
    WCHAR                               wszSignedBy[MAX_PATH];  // OUT: signer display name from certificate
    PCCERT_CONTEXT                      pcSignerCertContext;    // OUT: client MUST free this!!!

    // 08-Dec-1997 pberkman: added
    DRIVER_VER_MAJORMINOR               sOSVersionLow;          // IN - OPTIONAL: lowest compatible version
    DRIVER_VER_MAJORMINOR		sOSVersionHigh; 	// IN - OPTIONAL: for now must be the same as sOSVersionLow

} DRIVER_VER_INFO, *PDRIVER_VER_INFO;

#include <poppack.h>


#ifdef __cplusplus
}
#endif

#endif // SOFTPUB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\dllmain.h ===
// --------------------------------------------------------------------------------
// Dllmain.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __DLLMAIN_H
#define __DLLMAIN_H

// --------------------------------------------------------------------------------
// Defined later

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern CRITICAL_SECTION     g_csDllMain;
extern CRITICAL_SECTION     g_csCounter;
extern DWORD                g_dwCounter;     // boundary/cid/mid ratchet
extern LONG                 g_cRef;
extern LONG                 g_cLock;
extern HINSTANCE            g_hInst;
extern HINSTANCE            g_hLocRes;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
ULONG DllAddRef(void);
ULONG DllRelease(void);
DWORD DwCounterNext(void);
HRESULT GetTypeLibrary(ITypeLib **ppTypeLib);

#endif // __DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDBCS_DIVIDE -D_WIN32_OE=0x0500

WIN32_IE_VERSION=0x0300

INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(BASEDIR)\public\sdk\inc; \
    $(ATHROOT)\inc; \
    $(ATHROOT)\mailnews\extinc; \
    $(INCLUDES)

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin

PRECOMPILED_CXX=1
#ifndef WIN16
PRECOMPILED_OPTION=/Yupch.hxx /Fp$R\inc\$(_OBJ_DIR)\*\pch.pch
#else
PRECOMPILED_OPTION=/fh=$R\inc\$(_OBJ_DIR)\*\pch.pch
#endif
PRECOMPILED_TARGET=$(R)\inc\$(_OBJ_DIR)\*\pch.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\dllmain.cpp ===
// --------------------------------------------------------------------------------
// Dllmain.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#define DEFINE_STRING_CONSTANTS
#define DEFINE_STRCONST
#define DEFINE_PROPSYMBOLS
#define DEFINE_TRIGGERS
#include "msoert.h"
#include "Mimeole.h"
#include <advpub.h>
#include "dllmain.h"
#include "init.h"

// --------------------------------------------------------------------------------
// Globals - Object count and lock count
// --------------------------------------------------------------------------------
CRITICAL_SECTION    g_csDllMain={0};
LONG                g_cRef=0;
LONG                g_cLock=0;
HINSTANCE           g_hInst=NULL;
IMalloc            *g_pMalloc=NULL;

// --------------------------------------------------------------------------------
// Debug Globals
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// InitGlobalVars
// --------------------------------------------------------------------------------
void InitGlobalVars(void)
{
    // Locals
    SYSTEM_INFO rSystemInfo;

	// Initialize Global Critical Sections
    InitializeCriticalSection(&g_csDllMain);

	// Create OLE Task Memory Allocator
	CoGetMalloc(1, &g_pMalloc);
	Assert(g_pMalloc);
}

// --------------------------------------------------------------------------------
// FreeGlobalVars
// --------------------------------------------------------------------------------
void FreeGlobalVars(void)
{
    DeleteCriticalSection(&g_csDllMain);
	SafeRelease(g_pMalloc);
}

// --------------------------------------------------------------------------------
// Win32 Dll Entry Point
// --------------------------------------------------------------------------------
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Handle Attach - detach reason
    switch (dwReason)                 
    {
    case DLL_PROCESS_ATTACH:
	    g_hInst = hInst;
		InitGlobalVars();
        SideAssert(DisableThreadLibraryCalls(hInst));
        break;

    case DLL_PROCESS_DETACH:
		FreeGlobalVars();
	    break;
    }

    // Done
    return TRUE;
}


// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    TraceCall("DllAddRef");
    if (g_cRef == 0 && !g_fInitialized)
        InitGWNoteThread(TRUE);

    return (ULONG)InterlockedIncrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    TraceCall("DllRelease");
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    EnterCriticalSection(&g_csDllMain);

    HRESULT hr = (0 == g_cRef && 0 == g_cLock) ? S_OK : S_FALSE;

    if (hr==S_OK && g_fInitialized)
        InitGWNoteThread(FALSE);

    LeaveCriticalSection(&g_csDllMain);
    return hr;
}

// --------------------------------------------------------------------------------
// CallRegInstall - Self-Registration Helper
// --------------------------------------------------------------------------------
HRESULT CallRegInstall(LPCSTR szSection)
{
    // Locals
    HRESULT     hr=S_OK;
    HINSTANCE   hAdvPack=NULL;
    REGINSTALL  pfnri;

    // TraceCAll
    TraceCall("CallRegInstall");

    // Load ADVPACK.DLL
    hAdvPack = LoadLibraryA("ADVPACK.DLL");
    if (NULL == hAdvPack)
    {
        hr = TraceResult(TYPE_E_CANTLOADLIBRARY);
        goto exit;
    }

    // Get Proc Address for registration util
    pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
    if (NULL == pfnri)
    {
        hr = TraceResult(TYPE_E_CANTLOADLIBRARY);
        goto exit;
    }

    // Call the self-reg routine

    IF_FAILEXIT(hr = pfnri(g_hInst, szSection, NULL));

exit:
    // Cleanup
    SafeFreeLibrary(hAdvPack);
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("DllRegisterServer");

    // Register my self
    IF_FAILEXIT(hr = CallRegInstall("Reg"));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("DllUnregisterServer");

    // UnRegister
    IF_FAILEXIT(hr = CallRegInstall("UnReg"));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Override new operator
// --------------------------------------------------------------------------------
void * __cdecl operator new(UINT cb)
{
    LPVOID  lpv = 0;

    lpv = CoTaskMemAlloc(cb);
    if (lpv)
    {
#ifdef DEBUG
        memset(lpv, 0xFF, cb);
#endif 
    }
    return lpv;
}

// --------------------------------------------------------------------------------
// Override delete operator
// --------------------------------------------------------------------------------
#ifndef WIN16
void __cdecl operator delete(LPVOID pv)
#else
void __cdecl operator delete(PVOID pv)
#endif
{
    CoTaskMemFree(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\factory.h ===
// --------------------------------------------------------------------------------
// Factory.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __FACTORY_H
#define __FACTORY_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CClassFactory;

// --------------------------------------------------------------------------------
// Object Flags
// --------------------------------------------------------------------------------
#define OIF_ALLOWAGGREGATION  0x0001

// --------------------------------------------------------------------------------
// Object Creation Prototypes
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);
#define CreateObjectInstance (*m_pfCreateInstance)

// --------------------------------------------------------------------------------
// InetComm ClassFactory
// --------------------------------------------------------------------------------
class CClassFactory : public IClassFactory
{
public:
    // ----------------------------------------------------------------------------
    // Public Data
    // ----------------------------------------------------------------------------
    CLSID const        *m_pclsid;
    DWORD               m_dwFlags;
    PFCREATEINSTANCE    m_pfCreateInstance;

    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

    // ----------------------------------------------------------------------------
    // IUnknown members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IClassFactory members
    // ----------------------------------------------------------------------------
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};

// --------------------------------------------------------------------------------
// Object Creators
// --------------------------------------------------------------------------------
HRESULT GWNote_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);

#endif // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\envhost.h ===
/*
 *    e n v h o s t . h
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _ENVHOST_H
#define _ENVHOST_H

#include "privunk.h"
#include <envelope.h>
#include <mso.h>
#include <envguid.h>


class CEnvHost:
    public IMsoEnvelopeHost,
    public CPrivateUnknown
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // *** IMsoEnvelopeHost ***
    virtual HRESULT STDMETHODCALLTYPE CreateNote(IUnknown *punk,REFCLSID clsidCreate, LPCWSTR wszTheme, LPCWSTR wszAuthor, LPCWSTR wszPrefix, DWORD grfCreate);
    virtual HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock);

    CEnvHost(IUnknown *pUnkOuter=NULL);
    virtual ~CEnvHost();

private:

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

};


class CGWNote:
    public IPersistMime,
    public IServiceProvider,
    public IMsoEnvelopeSite,
    public IMsoComponentManager,
    public CPrivateUnknown
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // *** IServiceProvider ***
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    // *** IPersist ***
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClassID);

    // *** IPersistMime ***
	virtual HRESULT STDMETHODCALLTYPE Load(IMimeMessage *pMsg);
	virtual HRESULT STDMETHODCALLTYPE Save(IMimeMessage *pMsg, DWORD dwFlags);

    // *** IEnvelopeSite ***
    virtual HRESULT STDMETHODCALLTYPE RequestResize(int *pcHeight);
    virtual HRESULT STDMETHODCALLTYPE CloseNote(DWORD grfClose);
    virtual HRESULT STDMETHODCALLTYPE GetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody);
    virtual HRESULT STDMETHODCALLTYPE SetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody);
    virtual HRESULT STDMETHODCALLTYPE SetFocus(BOOL fTab);
    virtual HRESULT STDMETHODCALLTYPE OnEnvSetFocus();
    virtual HRESULT STDMETHODCALLTYPE DirtyToolbars(void);

    virtual HRESULT STDMETHODCALLTYPE OnPropChange(ULONG dispid);
    virtual HRESULT STDMETHODCALLTYPE IsBodyDirty();
    virtual HRESULT STDMETHODCALLTYPE HandsOff();
    virtual HRESULT STDMETHODCALLTYPE GetMsoInst(HMSOINST *phinst);
    virtual HRESULT STDMETHODCALLTYPE GetFrameWnd(HWND *phwndFrame);
    virtual HRESULT STDMETHODCALLTYPE DisplayMessage(HRESULT hr, LPCWSTR wszError, DWORD grfMsg);

    virtual HRESULT STDMETHODCALLTYPE SetHelpMode(BOOL fEnter);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerators(MSG *pMsg);
    
    // *** IMsoComponentManager ***       
	//HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID iid, void **ppvObj);
    BOOL STDMETHODCALLTYPE FDebugMessage(HMSOINST hinst, UINT message, WPARAM wParam, LPARAM lParam);
	BOOL STDMETHODCALLTYPE FRegisterComponent(IMsoComponent *piComponent, const MSOCRINFO *pcrinfo, DWORD *pdwComponentID);
	BOOL STDMETHODCALLTYPE FRevokeComponent(DWORD dwComponentID);
	BOOL STDMETHODCALLTYPE FUpdateComponentRegistration(DWORD dwComponentID, const MSOCRINFO *pcrinfo);
	BOOL STDMETHODCALLTYPE FOnComponentActivate(DWORD dwComponentID);
	BOOL STDMETHODCALLTYPE FSetTrackingComponent(DWORD dwComponentID, BOOL fTrack);
	void STDMETHODCALLTYPE OnComponentEnterState(DWORD dwComponentID, ULONG uStateID, ULONG uContext, ULONG cpicmExclude, IMsoComponentManager **rgpicmExclude, DWORD dwReserved);
	BOOL STDMETHODCALLTYPE FOnComponentExitState(DWORD dwComponentID, ULONG uStateID, ULONG uContext, ULONG cpicmExclude, IMsoComponentManager **rgpicmExclude);
	BOOL STDMETHODCALLTYPE FInState(ULONG uStateID, void *pvoid);
	BOOL STDMETHODCALLTYPE FContinueIdle ();
	BOOL STDMETHODCALLTYPE FPushMessageLoop(DWORD dwComponentID, ULONG uReason, void *pvLoopData);
	BOOL STDMETHODCALLTYPE FCreateSubComponentManager(IUnknown *piunkOuter, IUnknown *piunkServProv,REFIID riid, void **ppvObj);
	BOOL STDMETHODCALLTYPE FGetParentComponentManager(IMsoComponentManager **ppicm);
    BOOL STDMETHODCALLTYPE FGetActiveComponent(DWORD dwgac, IMsoComponent **ppic, MSOCRINFO *pcrinfo, DWORD dwReserved);

    CGWNote(IUnknown *pUnkOuter=NULL);
    virtual ~CGWNote();

    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT Init(REFCLSID clsidEnvelope, DWORD dwFlags);
    HRESULT Show();
    
    HRESULT TranslateAcclerator(MSG *lpmsg);

private:
    IMsoEnvelope    *m_pEnv;
    IMsoComponent   *m_pComponent;

    HWND            m_hwnd,
                    m_hwndRE,
                    m_hwndFocus;
    ULONG           m_cyEnv;

    HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
    LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT OnNCDestroy();
    HRESULT OnCreate(HWND hwnd);
    HRESULT InitEnvelope(REFCLSID clsidEnvelope, DWORD dwFlags);
    HRESULT WMCommand(HWND hwndCmd, int id, WORD wCmd);
    HRESULT WMNotify(int idFrom, NMHDR *pnmh);

    HRESULT HrHeaderExecCommand(UINT uCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn);

    //saveas helpers
    HRESULT SaveToFile(LPWSTR pszW);
    HRESULT SaveAs();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\init.h ===
#ifndef _INIT_H
#define _INIT_H

class CGWNote;

#define ITM_SHUTDOWNTHREAD		(WM_USER + 1)
#define ITM_CREATENOTEONTHREAD	(WM_USER + 2)

void InitGWNoteThread(BOOL fInit);
HRESULT HrCreateNote(REFCLSID clsidEnvelope, DWORD dwFlags);

extern CGWNote  *g_pActiveNote;
extern HWND     g_hwndInit;
extern HEVENT   g_hEventSpoolerInit;
extern DWORD    g_dwNoteThreadID;
extern BOOL     g_fInitialized;

#endif //_INIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\privunk.cpp ===
// --------------------------------------------------------------------------------
// Privunk.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "msoert.h"
#include "privunk.h"

// --------------------------------------------------------------------------------
// CPrivateUnknown::CPrivateUnknown
// --------------------------------------------------------------------------------
CPrivateUnknown::CPrivateUnknown(IUnknown *pUnkOuter) 
{
    m_pUnkOuter = pUnkOuter ? pUnkOuter : &m_cUnkInner;
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::SetOuter
// --------------------------------------------------------------------------------
void CPrivateUnknown::SetOuter(IUnknown *pUnkOuter)
{
    // Must have an outer, and should not have been aggregated yet...
    Assert(pUnkOuter && m_pUnkOuter == &m_cUnkInner);

    // Save pUnkOuter
    m_pUnkOuter = pUnkOuter;
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::QueryInterface
// --------------------------------------------------------------------------------
HRESULT CPrivateUnknown::CUnkInner::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    // I can handle the unknown
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // Return IUnknown
        *ppvObj = SAFECAST(this, IUnknown *);

        // Increment Ref Count
        InterlockedIncrement(&m_cRef);

        // Done
        return S_OK;
    }

    // Get my parent (computes the offset of the parent's base address)
    CPrivateUnknown *pParent = IToClass(CPrivateUnknown, m_cUnkInner, this);

    // Dispatch to PrivateQueryInterface
    return pParent->PrivateQueryInterface(riid, ppvObj);
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::AddRef
// --------------------------------------------------------------------------------
ULONG CPrivateUnknown::CUnkInner::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::Release
// --------------------------------------------------------------------------------
ULONG CPrivateUnknown::CUnkInner::Release(void)
{
    // Decrement Internal Reference Count
    LONG cRef = InterlockedDecrement(&m_cRef);

    // No dead yet...
    if (cRef > 0)
        return (ULONG)cRef;

    // Some groovy, mystical, disco stuff
    // protect against cached pointers bumping us up then down
    m_cRef = 1000; 

    // Get the parent
    CPrivateUnknown* pParent = IToClass(CPrivateUnknown, m_cUnkInner, this);

    // Kill the parent
    delete pParent;

    // Done
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\privunk.h ===
// --------------------------------------------------------------------------------
// Privunk.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __PRIVUNK_H
#define __PRIVUNK_H

// --------------------------------------------------------------------------------
// CPrivateUnknown
// --------------------------------------------------------------------------------
class CPrivateUnknown : public IUnknown
{
private:
    // ----------------------------------------------------------------------------
    // Embed default IUnknown handler
    // ----------------------------------------------------------------------------
    class CUnkInner : public IUnknown
    {
    private:
        LONG m_cRef;     // Private Ref Count

    public:
        // Construction
        CUnkInner(void) { m_cRef = 1; }

        // IUnknown Members
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);
    };

    friend class CUnkInner;

    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    CUnkInner           m_cUnkInner;      // Private Inner
    IUnknown           *m_pUnkOuter;      // points to _cUnkInner or aggregating IUnknown

protected:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CPrivateUnknown(IUnknown *pUnkOuter);
    virtual ~CPrivateUnknown(void) {};

    // ----------------------------------------------------------------------------
    // This is the QueryInterface the aggregator implements
    // ----------------------------------------------------------------------------
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj) = 0;

public:
    // ----------------------------------------------------------------------------
    // This is the IUnknown that subclasses returns from their CreateInstance func
    // ----------------------------------------------------------------------------
    IUnknown* GetInner() { return &m_cUnkInner; }

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    inline virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) {
        return m_pUnkOuter->QueryInterface(riid, ppvObj); }
    inline virtual STDMETHODIMP_(ULONG) AddRef(void) {
        return m_pUnkOuter->AddRef(); }
    inline virtual STDMETHODIMP_(ULONG) Release(void) {
        return m_pUnkOuter->Release(); }

    // ----------------------------------------------------------------------------
    // Public Utilities
    // ----------------------------------------------------------------------------
    void SetOuter(IUnknown *pUnkOuter);
};

#endif // __PRIVUNK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\init.cpp ===
/*
 *    i n i t . c p p
 *    
 *    Purpose:
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "dllmain.h"
#include "msoert.h"
#include "mimeole.h"
#include "envhost.h"
#include "init.h"

LRESULT CALLBACK InitWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
HRESULT HrCreateNoteThisThread(WPARAM wp, LPARAM lp);
DWORD MainThreadProc(LPVOID lpvUnused);
void NoteMsgPump();


CGWNote             *g_pActiveNote=0;
HWND                g_hwndInit = NULL;
HEVENT              g_hEventSpoolerInit =NULL;
DWORD               g_dwNoteThreadID=0;
BOOL                g_fInitialized=FALSE;

static HTHREAD      s_hMainThread = NULL;
static HEVENT       s_hInitEvent = NULL;
static DWORD        s_dwMainThreadId = 0;
static TCHAR        s_szInitWndClass[] = "GWInitWindow";

void InitGWNoteThread(BOOL fInit)
{
    if (fInit)
        {
        // create an event for the main thread to signal
        if (s_hInitEvent = CreateEvent(NULL, FALSE, FALSE, NULL))
            {
            if (s_hMainThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)MainThreadProc, NULL, 0, &s_dwMainThreadId))
                {
                HANDLE  rghWait[]={s_hMainThread, s_hInitEvent};

                // wait for the main thread to signal that initialization is complete
                WaitForMultipleObjects(sizeof(rghWait)/sizeof(HANDLE), rghWait, FALSE, INFINITE);
                }
            
            CloseHandle(s_hInitEvent);
            s_hInitEvent = NULL;
            }
        }
    else
        {
        // tell the main thread to deinitialize everything
        // the SendMessage() will block the calling thread until deinit is complete,
        if (g_hwndInit)
            SendMessage(g_hwndInit, ITM_SHUTDOWNTHREAD, 0, 0);

        // wait for main thread to terminate (when it exits its message loop)
        // this isn't strictly necessary, but it helps to ensure proper cleanup.
        WaitForSingleObject(s_hMainThread, INFINITE);

        CloseHandle(s_hMainThread);
        s_hMainThread = NULL;
        }
}

DWORD MainThreadProc(LPVOID lpvUnused)
{
    DWORD   dw;
    HRESULT hr;
    RECT    rc={0};
 
    WNDCLASS wc = { 0,                  // style
                    InitWndProc,        // lpfnWndProc
                    0,                  // cbClsExtra
                    0,                  // cbWndExtra
                    g_hInst,            // hInstance
                    NULL,               // hIcon
                    NULL,               // hCursor
                    NULL,               // hbrBackground
                    NULL,               // lpszMenuName
                    s_szInitWndClass }; // lpszClassName

    g_dwNoteThreadID = GetCurrentThreadId();

    if (!RegisterClass(&wc))
        return 0;

    g_hwndInit = CreateWindowEx(NULL,
                                s_szInitWndClass,
                                s_szInitWndClass,
                                WS_POPUP,
                                0,0,0,0,
                                NULL,
                                NULL,
                                g_hInst,
                                NULL);
    if (!g_hwndInit)
        return 0;

    OleInitialize(0);

    g_fInitialized=TRUE;
    SetEvent(s_hInitEvent);

    NoteMsgPump();
    return 0;
}

LRESULT CALLBACK InitWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    BOOL fRet;
    HRESULT hr;

    switch(msg)
        {
        case ITM_SHUTDOWNTHREAD:
            Assert(GetCurrentThreadId()==s_dwMainThreadId);
            OleUninitialize();
            DestroyWindow(hwnd);
            PostThreadMessage(s_dwMainThreadId, WM_QUIT, 0, 0);
            g_fInitialized=FALSE;
            return 0;

        case ITM_CREATENOTEONTHREAD:
            return (LONG)HrCreateNoteThisThread(wp, lp);

        }
    return DefWindowProc(hwnd, msg, wp, lp);
}



void NoteMsgPump()
{
    MSG     msg;

    while (GetMessage(&msg, NULL, 0, 0))
        {
        if (msg.hwnd != g_hwndInit &&               // ignore init window msgs
            IsWindow(msg.hwnd))                     // ignore per-task msgs where hwnd=0
            {
            if(g_pActiveNote &&                     // if a note has focus, call it's XLateAccelerator...
                g_pActiveNote->TranslateAcclerator(&msg)==S_OK)
                continue;
            }
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
}

HRESULT HrCreateNote(REFCLSID clsidEnvelope, DWORD dwFlags)
{
    LPOLESTR    pstr;
    HRESULT     hr;

    if (FAILED(StringFromCLSID(clsidEnvelope, &pstr)))
        return E_FAIL;

    // switch thread
    hr = SendMessage (g_hwndInit, ITM_CREATENOTEONTHREAD, (WPARAM)pstr, (LPARAM)dwFlags);
    CoTaskMemFree(pstr);
    return hr;

}


HRESULT HrCreateNoteThisThread(WPARAM wp, LPARAM lp)
{
    static HINSTANCE s_hRichEdit=0;
    HRESULT hr;
    CGWNote *pNote=0;
    CLSID   clsid;

    // hack, need to free lib this
    if (!s_hRichEdit)
        s_hRichEdit = LoadLibrary("RICHED32.DLL");
 
    // need to create this puppy on new thread 
    pNote = new CGWNote(NULL);
    if (!pNote)
        return E_OUTOFMEMORY;

    CLSIDFromString((LPOLESTR)wp, &clsid);

    hr = pNote->Init(clsid, (DWORD)lp);
    if (FAILED(hr))
        goto error;

    hr = pNote->Show();

error:
    ReleaseObj(pNote);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\factory.cpp ===
// --------------------------------------------------------------------------------
// Factory.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "factory.h"
#include "msoert.h"
#include "mimeole.h"
#include "envhost.h"

// --------------------------------------------------------------------------------
// Pretty
// --------------------------------------------------------------------------------
#define OBJTYPE0        0
#define OBJTYPE1        OIF_ALLOWAGGREGATION

// --------------------------------------------------------------------------------
// Global Object Info Table
// --------------------------------------------------------------------------------
static CClassFactory g_rgFactory[] = {
    CClassFactory(&CLSID_GWEnvelopeHost,          OBJTYPE0, (PFCREATEINSTANCE)GWNote_CreateInstance)
};
                 
// --------------------------------------------------------------------------------
// DllGetClassObject
// --------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK; 
    ULONG       i;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // No memory allocator
    if (NULL == g_pMalloc)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            CHECKHR(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, no class
    hr = TrapError(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::CClassFactory
// --------------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

// --------------------------------------------------------------------------------
// CClassFactory::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // Invalid Arg
    if (NULL == ppvObj)
        return TrapError(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TrapError(E_NOINTERFACE);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    DllAddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CClassFactory::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    DllAddRef();
    return 2;
}

// --------------------------------------------------------------------------------
// CClassFactory::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    DllRelease();
    return 1;
}

// --------------------------------------------------------------------------------
// CClassFactory::CreateInstance
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Bad param
    if (ppvObj == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter && IID_IUnknown != riid)
        return TrapError(CLASS_E_NOAGGREGATION);

    // No memory allocator
    if (NULL == g_pMalloc)
        return TrapError(E_OUTOFMEMORY);

    // Can I do aggregaton
    if (pUnkOuter !=NULL && !(m_dwFlags & OIF_ALLOWAGGREGATION))  
        return TrapError(CLASS_E_NOAGGREGATION);

    // Create the object...
    CHECKHR(hr = CreateObjectInstance(pUnkOuter, &pObject));

    // Aggregated, then we know we're looking for an IUnknown, return pObject, otherwise, QI
    if (pUnkOuter)
    {
        // Matches Release after Exit
        pObject->AddRef();

        // Return pObject::IUnknown
        *ppvObj = (LPVOID)pObject;
    }

    // Otherwise
    else
    {
        // Get the interface requested from pObj
        CHECKHR(hr = pObject->QueryInterface(riid, ppvObj));
    }
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::LockServer
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) InterlockedIncrement(&g_cLock);
    else       InterlockedDecrement(&g_cLock);
    return NOERROR;
}

// --------------------------------------------------------------------------------
// GWNote_CreateInstance
// --------------------------------------------------------------------------------
HRESULT GWNote_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CEnvHost *pNew= new CEnvHost(pUnkOuter);
    if (NULL == pNew)
        return (E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMsoEnvelopeHost *);

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\envhost.cpp ===
/*
 *    e n v h o s t . c p p
 *    
 *    Purpose:
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "resource.h"
#include "envcid.h"
#include "commdlg.h"
#include "docobj.h"
#include "dllmain.h"
#include "msoert.h"
#include "mimeole.h"
#include "envhost.h"
#include "richedit.h"
#include "init.h"
#include "shellapi.h"

HINSTANCE   s_hRichEdit;
HINSTANCE   g_hLocRes ;
HACCEL      g_hAccelMailSend;

HRESULT HrRicheditStreamOut(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags);
void SaveFocus(BOOL fActive, HWND *phwnd);
        

static const TCHAR  c_szGWNoteWndClass[] = "GW_Note";

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CEnvHost::CEnvHost(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    DllAddRef();
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CEnvHost::~CEnvHost()
{
    DllRelease();
}

//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CEnvHost::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IMsoEnvelopeHost *)this;
    else if (IsEqualIID(riid, IID_IMsoEnvelopeHost))
        *lplpObj = (LPVOID)(IMsoEnvelopeHost *)this;
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NOERROR;
}



HRESULT CEnvHost::CreateNote(IUnknown *punk, REFCLSID clsidCreate, LPCWSTR wszTheme, LPCWSTR wszAuthor, LPCWSTR wszPrefix, DWORD grfCreate)
{
    return HrCreateNote(clsidCreate, grfCreate);
}

HRESULT CEnvHost::LockServer(BOOL fLock)
{
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CGWNote::CGWNote(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    m_pEnv=NULL;
    m_hwnd=NULL;
    m_hwndRE=NULL;
    m_pComponent=NULL;
    m_hwndFocus=NULL;

    DllAddRef();
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CGWNote::~CGWNote()
{
    DllRelease();
}

//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CGWNote::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IPersistMime *)this;
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *lplpObj = (LPVOID)(IServiceProvider *)this;
    else if (IsEqualIID(riid, IID_IPersistMime))
        *lplpObj = (LPVOID)(IPersistMime *)this;
    else if (IsEqualIID(riid, IID_IMsoEnvelopeSite))
        *lplpObj = (LPVOID)(IMsoEnvelopeSite *)this;
    else if (IsEqualIID(riid, IID_IMsoComponentManager))
        *lplpObj = (LPVOID)(IMsoComponentManager *)this;
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NOERROR;
}



//+---------------------------------------------------------------
//
//  Member:     GetClassID
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CGWNote::GetClassID(CLSID *pClassID)
{
	*pClassID = CLSID_GWEnvelopeHost;
    return NOERROR;
}

// *** IServiceProvider ***
//+---------------------------------------------------------------
//
//  Member:     QueryService
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CGWNote::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    if (IsEqualGUID(guidService, IID_IMsoComponentManager))
        return PrivateQueryInterface(riid, ppvObject);

    return E_NOINTERFACE;
}

// *** IPersistMime ***
//+---------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CGWNote::Load(IMimeMessage *pMsg)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CGWNote::Save(IMimeMessage *pMsg, DWORD dwFlags)
{
    IPersistMime    *pPM;
    IStream         *pstm;
    HRESULT         hr;

    // save envelope props
    if (m_pEnv &&
        m_pEnv->QueryInterface(IID_IPersistMime, (LPVOID *)&pPM)==S_OK)
        {
        hr = pPM->Save(pMsg, dwFlags);
        pPM->Release();
        }

    // save body props
    if (MimeOleCreateVirtualStream(&pstm)==S_OK)
        {
        if (HrRicheditStreamOut(m_hwndRE, pstm, SF_TEXT)==S_OK)
            pMsg->SetTextBody(TXT_PLAIN, IET_BINARY, NULL, pstm, NULL);
        
        pstm->Release();
        }
    return hr;
}

HRESULT CGWNote::RequestResize(int *pcHeight)
{
    RECT rc;

    m_cyEnv = *pcHeight;

    GetClientRect(m_hwnd, &rc);
    rc.top +=2;
    rc.bottom = m_cyEnv+2;
    m_pEnv->Resize(&rc);

    GetClientRect(m_hwnd, &rc);
    rc.top += m_cyEnv + 4;
    rc.bottom -=2;
    SetWindowPos(m_hwndRE, NULL, 0, rc.top, rc.right-rc.left, rc.bottom-rc.top, SWP_NOZORDER);
    return S_OK;
}

HRESULT CGWNote::CloseNote(DWORD grfClose)
{
    SendMessage(m_hwnd, WM_CLOSE, 0, 0);
    return S_OK;
}

HRESULT CGWNote::GetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody)
{
    return E_NOTIMPL;
}

HRESULT CGWNote::SetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody)
{
    return S_OK;
}

HRESULT CGWNote::SetFocus(BOOL fTab)
{
    if (fTab)
        ::SetFocus(m_hwndRE);
    return S_OK;
}

HRESULT CGWNote::OnEnvSetFocus()
{
    return S_OK;
}

HRESULT CGWNote::OnPropChange(ULONG dispid)
{
    return S_OK;
}

HRESULT CGWNote::IsBodyDirty()
{
    return S_OK;
}

HRESULT CGWNote::HandsOff()
{
    return S_OK;
}

HRESULT CGWNote::GetMsoInst(HMSOINST *phinst)
{
    return E_NOTIMPL;
}

HRESULT CGWNote::GetFrameWnd(HWND *phwndFrame)
{
    return E_NOTIMPL;
}

HRESULT CGWNote::DisplayMessage(HRESULT hr, LPCWSTR wszError, DWORD grfMsg)
{
    return S_OK;
}

LRESULT CGWNote::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CGWNote *pNote;

    if(msg==WM_CREATE)
        {
        pNote=(CGWNote *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(!pNote)
            return -1;

        if(FAILED(pNote->OnCreate(hwnd)))
            return -1;
        }
    
    pNote = (CGWNote *)GetWndThisPtr(hwnd);
    if(pNote)
        return pNote->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);

}

LRESULT CGWNote::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LONG    lret;

    switch (msg)
        {
        case WM_NOTIFY:
            return (WMNotify(wParam, (NMHDR *)lParam)==S_OK);
                

        case WM_COMMAND:
            if (WMCommand(  GET_WM_COMMAND_HWND(wParam, lParam),
                            GET_WM_COMMAND_ID(wParam, lParam),
                            GET_WM_COMMAND_CMD(wParam, lParam))==S_OK)
                return 0;

            break;

        case WM_SIZE:
            RequestResize((int *)&m_cyEnv);
            break;

        case WM_NCDESTROY:
            OnNCDestroy();
            break;
        }

    lret = DefWindowProc(hwnd, msg, wParam, lParam);

    if(msg==WM_ACTIVATE)
        {
        // post-process wm_activates to set focus back to
        // control
        SaveFocus((BOOL)(LOWORD(wParam)), &m_hwndFocus);
        g_pActiveNote = (LOWORD(wParam)==WA_INACTIVE)?NULL:this;
        }

    return lret;

}





HRESULT CGWNote::Init(REFCLSID clsidEnvelope, DWORD dwFlags)
{

    HRESULT     hr=S_OK;
    HWND        hwnd;
    WNDCLASS    wc;
    HMENU       hMenu;

	TraceCall("CDocHost::Init");

    if (!GetClassInfo(g_hInst, c_szGWNoteWndClass, &wc))
        {
        ZeroMemory(&wc, sizeof(WNDCLASS));
        wc.lpfnWndProc   = CGWNote::ExtWndProc;
        wc.hInstance     = g_hInst;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName = c_szGWNoteWndClass;
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.style = CS_DBLCLKS;

        if(!RegisterClass(&wc))
            return E_OUTOFMEMORY;
        }

    hMenu = LoadMenu(g_hInst, "GWNOTEMENU");
    if (!hMenu)
        return E_OUTOFMEMORY;

    hwnd=CreateWindowEx(WS_EX_WINDOWEDGE|WS_EX_CONTROLPARENT,
                        c_szGWNoteWndClass, 
						"GW Note Control",
                        WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN,
                        0, 
						0,
						400, 
						400, 
						NULL, 
                        hMenu, 
						g_hInst, 
						(LPVOID)this);
    if(!hwnd)
        {
        hr=E_OUTOFMEMORY;
        goto error;
        }

    
    hr = InitEnvelope(clsidEnvelope, dwFlags);

error:
    return hr;
}

HRESULT CGWNote::OnCreate(HWND hwnd)
{
    CHARFORMAT  cf={0};

    m_hwnd = hwnd;
    SetWindowLong(hwnd, GWL_USERDATA, (LPARAM)this);

    m_hwndRE  = CreateWindowEx(WS_EX_CLIENTEDGE, 
                                "RichEdit",
                                "",
                                //ES_MULTILINE|ES_SAVESEL|ES_AUTOVSCROLL|ES_SELECTIONBAR|ES_WANTRETURN|WS_VSCROLL|WS_CHILD|WS_TABSTOP|WS_VISIBLE,
                                ES_SAVESEL|ES_WANTRETURN|ES_MULTILINE|WS_CHILD|WS_TABSTOP|WS_VISIBLE|ES_AUTOVSCROLL|WS_VSCROLL,
                                0, 0, 0, 0,
                                hwnd, 
                                (HMENU)99,
                                g_hInst,
                                NULL);
    
    if (!m_hwndRE)
        return E_FAIL;

    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_COLOR|CFM_FACE;
    cf.crTextColor = RGB(0,0,255);
    lstrcpy(cf.szFaceName, "Verdana");

    SendMessage(m_hwndRE, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
    SendMessage(m_hwndRE, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    SendMessage(m_hwndRE, EM_SETEVENTMASK, 0, ENM_KEYEVENTS);
    AddRef();
    return S_OK;
}


HRESULT CGWNote::OnNCDestroy()
{
    SafeRelease(m_pEnv);
    if (m_pComponent)
        {
        m_pComponent->Terminate();
        SafeRelease(m_pComponent);
        }

    SetWindowLong(m_hwnd, GWL_USERDATA, NULL);
    m_hwnd = NULL;
    Release();
    return S_OK;
}

HRESULT CGWNote::Show()
{
    ShowWindow(m_hwnd, SW_SHOW);
    return S_OK;
}

HRESULT CGWNote::InitEnvelope(REFCLSID clsidEnvelope, DWORD dwFlags)
{
    HRESULT hr;
    RECT    rc;

    hr = CoCreateInstance(clsidEnvelope, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER, IID_IMsoEnvelope, (LPVOID *)&m_pEnv);
    if (FAILED(hr))
        goto error;

    hr = m_pEnv->Init(NULL, (IMsoEnvelopeSite *)this, dwFlags);
    if (FAILED(hr))
        goto error;

    hr = m_pEnv->SetParent(m_hwnd);
    if (FAILED(hr))
        goto error;

    hr = m_pEnv->Show(TRUE);
    if (FAILED(hr))
        goto error;

    m_pEnv->SetFocus(ENV_FOCUS_INITIAL);

error:
    return hr;        
}


HRESULT CGWNote::TranslateAcclerator(MSG *lpmsg)
{
    if (!g_hAccelMailSend)
        g_hAccelMailSend= LoadAccelerators(g_hInst, MAKEINTRESOURCE(idacMail_SendNote));

    if (::TranslateAccelerator(m_hwnd, g_hAccelMailSend, lpmsg))
        return S_OK;


    if (m_pComponent &&
        m_pComponent->FPreTranslateMessage(lpmsg))
        return S_OK;

    return S_FALSE;
}



DWORD CALLBACK EditStreamOutCallback(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb)
{
    return ((LPSTREAM)dwCookie)->Write(pbBuff, cb, (ULONG *)pcb);
}



HRESULT HrRicheditStreamOut(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags)
{
    EDITSTREAM  es;

    if(!pstm)
        return E_INVALIDARG;

    if(!IsWindow(hwndRE))
        return E_INVALIDARG;

    HrRewindStream(pstm);

    es.dwCookie = (DWORD)pstm;
    es.pfnCallback=(EDITSTREAMCALLBACK)EditStreamOutCallback;
    SendMessage(hwndRE, EM_STREAMOUT, uSelFlags, (LONG)&es);
    return S_OK;
}




BOOL CGWNote::FRegisterComponent(IMsoComponent *piComponent, const MSOCRINFO *pcrinfo, DWORD *pdwComponentID)
{
    if (m_pComponent)   // only one register allowed
        return E_FAIL;

    ReplaceInterface(m_pComponent, piComponent);
    *pdwComponentID=666;
    return TRUE;
}

BOOL CGWNote::FRevokeComponent(DWORD dwComponentID)
{
    return TRUE;
}

BOOL CGWNote::FUpdateComponentRegistration(DWORD dwComponentID, const MSOCRINFO *pcrinfo)
{
    return FALSE;
}

BOOL CGWNote::FOnComponentActivate(DWORD dwComponentID)
{
    return FALSE;
}

BOOL CGWNote::FSetTrackingComponent(DWORD dwComponentID, BOOL fTrack)
{
    return FALSE;
}

void CGWNote::OnComponentEnterState(DWORD dwComponentID, ULONG uStateID, ULONG uContext,ULONG cpicmExclude,IMsoComponentManager **rgpicmExclude, DWORD dwReserved)
{
}

BOOL CGWNote::FOnComponentExitState(DWORD dwComponentID, ULONG uStateID, ULONG uContext,ULONG cpicmExclude,IMsoComponentManager **rgpicmExclude)
{
    return FALSE;
}

BOOL CGWNote::FInState(ULONG uStateID, void *pvoid)
{
    return FALSE;
}

BOOL CGWNote::FContinueIdle ()
{
    return FALSE;
}

BOOL CGWNote::FPushMessageLoop(DWORD dwComponentID, ULONG uReason, void *pvLoopData)
{
    return FALSE;
}

BOOL CGWNote::FCreateSubComponentManager(IUnknown *piunkOuter, IUnknown *piunkServProv,REFIID riid, void **ppvObj)
{
    return FALSE;
}

BOOL CGWNote::FGetParentComponentManager(IMsoComponentManager **ppicm)
{
    return FALSE;
}

BOOL CGWNote::FGetActiveComponent(DWORD dwgac, IMsoComponent **ppic, MSOCRINFO *pcrinfo, DWORD dwReserved)
{
    return FALSE;
}


BOOL CGWNote::FDebugMessage(HMSOINST hinst, UINT message, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}




HRESULT CGWNote::WMCommand(HWND hwndCmd, int id, WORD wCmd)
{
    if (wCmd > 1)
        return S_FALSE;

    switch(id)
        {
        case idmNewMsg:
            ShellExecute(m_hwnd, NULL, "mailto:", 0, 0, SW_SHOW);
            return S_OK;

        case idmProperties:
            MessageBox(m_hwnd, "PlaceHolder", "Properties", MB_OK);
            return S_OK;

        case idmSaveAs:
            return SaveAs();

        case idmClose:
            PostMessage(m_hwnd, WM_CLOSE, 0, 0);
            return S_OK;

        case idmCheckNames:
            return HrHeaderExecCommand(MSOEENVCMDID_CHECKNAMES, MSOCMDEXECOPT_PROMPTUSER, NULL);

        case idmPickRecipients:
            return HrHeaderExecCommand(MSOEENVCMDID_SELECTRECIPIENTS, MSOCMDEXECOPT_DODEFAULT, NULL);

        case idmViewContacts:
            return HrHeaderExecCommand(MSOEENVCMDID_VIEWCONTACTS, MSOCMDEXECOPT_DODEFAULT, NULL);
        
        default:
            MessageBox(m_hwnd, "Not Yet Implemented", "Menu Command", MB_OK);
            return S_OK;
        }
            
    return S_FALSE;
}



HRESULT CGWNote::HrHeaderExecCommand(UINT uCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn)
{
    HRESULT             hr = S_FALSE;
    IOleCommandTarget   *pCmdTarget;

    if(m_pEnv &&
        m_pEnv->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
        {
        hr = pCmdTarget->Exec(&CGID_Envelope, uCmdID, nCmdExecOpt, pvaIn, NULL);
        pCmdTarget->Release();
        }
    return hr;

}

HRESULT CGWNote::WMNotify(int idFrom, NMHDR *pnmh)
{
    MSGFILTER   *pmf=(MSGFILTER *)pnmh;
    BOOL        fShift;

    switch (pnmh->code)
        {
        case EN_MSGFILTER:
            if (pmf->msg == WM_KEYDOWN && pmf->wParam == VK_TAB && !(GetKeyState(VK_CONTROL) & 0x8000))
                {
                // shift tab puts focus in the envelope
                if (GetKeyState(VK_SHIFT)&0x8000 && m_pEnv)
                    {
                    m_pEnv->SetFocus(ENV_FOCUS_TAB);
                    return S_OK;
                    }
                }
            break;
        }
    return S_FALSE;
}



void SaveFocus(BOOL fActive, HWND *phwnd)
{
    if(fActive&&IsWindow(*phwnd))
        SetFocus(*phwnd);
    else
        *phwnd=GetFocus();
}



static char c_szFilter[] = "Rfc 822 Messages (*.eml)\0*.eml\0\0";

HRESULT CGWNote::SaveAs()
{
    OPENFILENAME    ofn;
    TCHAR           szFile[MAX_PATH];
    TCHAR           szTitle[MAX_PATH];
    TCHAR           szDefExt[30];
    WCHAR           szFileW[MAX_PATH];

    lstrcpy(szFile, "c:\\*.eml");
    lstrcpy(szDefExt, ".eml");
    lstrcpy(szTitle, "Save Message As...");
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFilter = c_szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof (szFile);
    ofn.lpstrTitle = szTitle;
    ofn.lpstrDefExt = szDefExt;
    ofn.Flags = OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT;

    if (*szFile==NULL)
        return E_FAIL;
    

    // Show OpenFile Dialog
    if (!GetSaveFileName(&ofn))
        return MIMEEDIT_E_USERCANCEL;
 
    MultiByteToWideChar(CP_ACP, 0, szFile, -1, szFileW, MAX_PATH);

    return SaveToFile(szFileW);
}


HRESULT CGWNote::SaveToFile(LPWSTR pszW)
{
    IPersistMime        *ppm;
    IPersistFile        *pPF;
    IMimeMessage        *pMsg;
    HRESULT             hr;

    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
    if (!FAILED(hr))
        {
        pMsg->InitNew();
        
        hr = pMsg->QueryInterface(IID_IPersistFile, (LPVOID *)&pPF);
        if (!FAILED(hr))
            {
            hr = Save(pMsg, 0);
            if (!FAILED(hr))
                {
                hr = pPF->Save(pszW, FALSE);
                }
            pPF->Release();
            }
        pMsg->Release();
        }
    return hr;
}


HRESULT CGWNote::DirtyToolbars(void)
{
    return S_OK;
}


HRESULT CGWNote::SetHelpMode(BOOL fEnter)
{
    return S_OK;
}

HRESULT CGWNote::TranslateAccelerators(MSG *pMsg)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\badata.cpp ===
// badata.cpp: implementation of the CAddressBook class.
// WAB & Messenger integration to OE
// Created 04/20/98 by YST
//
//////////////////////////////////////////////////////////////////////

#include "pch.hxx"
#include <commctrl.h>
#include "msoert.h"
#include "bactrl.h"
#include "badata.h"
#include "baui.h"
#include "baprop.h"
#include "shlwapi.h" 
#include "ourguid.h"
#include "mapiguid.h"
#include "shlwapip.h" 

// #include "ipab.h"
// #include "multiusr.h"
// #include "demand.h"
// #include "secutil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


#define WAB_USE_OUTLOOK_CONTACT_STORE 0x10000000// Note: This internal flag needs to be
                                                // harmonious with external flags defined 
                                                // in wabapi.h for WAB_PARAM structs


//////////////////////////////////////////////////////////////////////
// Defines for the various MAPI Tables we request from the WAB
//////////////////////////////////////////////////////////////////////

#define MAX_QUERY_SIZE 1000

// Here are some private properties that the WAB stores
#define WAB_INTERNAL_BASE       0x6600
#define PR_WAB_LDAP_SERVER      PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 1)
#define PR_WAB_RESOLVE_FLAG     PROP_TAG(PT_BOOLEAN,    WAB_INTERNAL_BASE + 2)


// This BA's private GUID:
// {2BAD7EE0-36AB-11d1-9BAC-00A0C91F9C8B}
static const GUID WAB_ExtBAGuid = 
{ 0x2bad7ee0, 0x36ab, 0x11d1, { 0x9b, 0xac, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b } };

static const LPTSTR lpMsgrPropNames[] = 
{   
    "MsgrID"
};

enum _MsgrTags
{
    MsgrID = 0,
    msgrMax
};

ULONG MsgrPropTags[msgrMax];
ULONG PR_MSGR_DEF_ID = 0;


// These two define the table we request from the WAB when showing the
// contents of the local address book.

enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
    ieidPR_OBJECT_TYPE,
    ieidPR_MSGR_DEF_ID,
    ieidPR_HOME_TELEPHONE_NUMBER,
    ieidPR_BUSINESS_TELEPHONE_NUMBER,
    ieidPR_MOBILE_TELEPHONE_NUMBER,
//    ieidPR_WAB_IPPHONE,
    ieidPR_EMAIL_ADDRESS, 
    ieidPR_USER_X509_CERTIFICATE,
    ieidPR_RECORD_KEY,
    ieidMax
};

static SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME_W,
        PR_ENTRYID,
        PR_OBJECT_TYPE,
        0,
        PR_HOME_TELEPHONE_NUMBER_W,
        PR_BUSINESS_TELEPHONE_NUMBER_W,
        PR_MOBILE_TELEPHONE_NUMBER_W,
//        PR_WAB_IPPHONE,
        PR_EMAIL_ADDRESS_W, 
        PR_USER_X509_CERTIFICATE,
        PR_RECORD_KEY
    }
};


// These two define the table we request to see which LDAP servers should
// be resolved against.
enum {
    irnPR_OBJECT_TYPE = 0,
    irnPR_WAB_RESOLVE_FLAG,
    irnPR_ENTRYID,
    irnPR_DISPLAY_NAME,
    irnMax
};

static const SizedSPropTagArray(irnMax, irnColumns) =
{
    irnMax,
    {
        PR_OBJECT_TYPE,
        PR_WAB_RESOLVE_FLAG,
        PR_ENTRYID,
        PR_DISPLAY_NAME_W,
    }
};


enum {
    icrPR_DEF_CREATE_MAILUSER = 0,
    icrPR_DEF_CREATE_DL,
    icrMax
};

const SizedSPropTagArray(icrMax, ptaCreate)=
{
    icrMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};


// --------------------------------------------------------------------------
// PszAllocW
// --------------------------------------------------------------------------
LPWSTR IEPszAllocW(INT nLen)
{
    // Locals
    LPWSTR  pwsz=NULL;

    // Empty ?
    if (nLen == 0)
        goto exit;

    // Allocate
    if (FAILED(HrAlloc((LPVOID *)&pwsz, (nLen + 1) * sizeof (WCHAR))))
        goto exit;
    
exit:
    // Done
    return pwsz;
}

// --------------------------------------------------------------------------
// IEPszToUnicode
// --------------------------------------------------------------------------
LPWSTR IEPszToUnicode(UINT cp, LPCSTR pcszSource)
{
    // Locals
    INT         cchNarrow,
                cchWide;
    LPWSTR      pwszDup=NULL;

    // No Source
    if (pcszSource == NULL)
        goto exit;

    // Length
    cchNarrow = lstrlenA(pcszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, NULL, 0);

    // Error
    if (cchWide == 0)
        goto exit;

    // Alloc temp buffer
    pwszDup = IEPszAllocW(cchWide + 1);
    if (!pwszDup)
        goto exit;

    // Do the actual translation
	cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, pwszDup, cchWide+1);

    // Error
    if (cchWide == 0)
    {
        SafeMemFree(pwszDup);
        goto exit;
    }

exit:
    // Done
    return pwszDup;
}



//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAddressBookData::CAddressBookData()
{
    m_pWABObject = NULL;
    m_hInstWAB = NULL;
    m_pAdrBook = NULL;
    m_ulConnection = 0;
}


CAddressBookData::~CAddressBookData()
{
    // Release the Address Book pointer
    SafeRelease(m_pAdrBook);

    // Release the WAB object
    SafeRelease(m_pWABObject);

    if (m_hInstWAB)
    {
        FreeLibrary(m_hInstWAB);
        m_hInstWAB = NULL;
    }
}

//
//  FUNCTION:   CAddressBookData::OpenWabFile()
//
//  PURPOSE:    Finds the WAB DLL, loads the DLL, and opens the WAB.
//
HRESULT CAddressBookData::OpenWabFile(BOOL fWAB)
{
    TCHAR       szDll[MAX_PATH];
    TCHAR       szExpanded[MAX_PATH];
    DWORD       dwType = 0;
    LPTSTR      psz = szDll;
    ULONG       cbData = sizeof(szDll);
    HKEY        hKey = NULL;
    HRESULT     hr = E_FAIL;
    LPWABOPEN   lpfnWABOpen;

    // Initialize the path string
    *szDll = '\0';

    // First look under the default WAB DLL path location in the Registry.
    // WAB_DLL_PATH_KEY is defined in wabapi.h
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, _T(""), NULL, &dwType, (LPBYTE) szDll, &cbData))
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStrings(szDll, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }

        RegCloseKey(hKey);
    }

    // If the registry thing came up blank, then do a LoadLibrary on wab32.dll
    m_hInstWAB = LoadLibrary((lstrlen(psz)) ? (LPCTSTR) psz : (LPCTSTR) WAB_DLL_NAME);

    if (m_hInstWAB)
    {
        // If we've got the DLL, then get the entry point
        lpfnWABOpen = (LPWABOPEN) GetProcAddress(m_hInstWAB, "WABOpen");

        if (lpfnWABOpen)
        {
            WAB_PARAM       wp = {0};
            wp.cbSize = sizeof(WAB_PARAM);
            wp.guidPSExt = CLSID_IEMsgAb;
            wp.ulFlags = WAB_ENABLE_PROFILES | WAB_USE_OE_SENDMAIL;
            if(!fWAB)
            {
                wp.ulFlags = wp.ulFlags | WAB_USE_OUTLOOK_CONTACT_STORE;
                hr = lpfnWABOpen(&m_pAdrBook, &m_pWABObject, &wp, 0);
                if(hr == S_OK)
                    return (hr);  // in error case, try to open WAB
                else
                    wp.ulFlags = WAB_ENABLE_PROFILES | WAB_USE_OE_SENDMAIL;
            }
            hr = lpfnWABOpen(&m_pAdrBook, &m_pWABObject, &wp, 0);

        }
    }
    if(!m_pAdrBook || !m_pWABObject || FAILED(hr))
    {
        WCHAR wszTitle[CCHMAX_STRINGRES];
        WCHAR wszMsg[CCHMAX_STRINGRES];

        if(!AthLoadString(idsAthena, wszTitle, ARRAYSIZE(wszTitle)))
            wszTitle[0] = L'\0';

        if(!AthLoadString(idsWabNotFound, wszMsg, ARRAYSIZE(wszMsg)))
            wszMsg[0] = L'\0';

        MessageBoxW(NULL, wszMsg, wszTitle, MB_OK | MB_ICONSTOP);
    }
    return (hr);
}



//
//  FUNCTION:   CAddressBookData::LoadWabContents()
//
//  PURPOSE:    Loads the contents of the WAB into the provided ListView control.
//
//  PARAMETERS: 
//      [in] ctlList - Pointer to the ListView control to load the WAB into.
//
HRESULT CAddressBookData::LoadWabContents(CContainedWindow& ctlList, CIEMsgAb *pSink)
{
    ULONG       ulObjType = 0;
    LPMAPITABLE lpAB =  NULL;
    LPTSTR     *lppszArray = NULL;
    ULONG       cRows = 0;
    LPSRowSet   lpRow = NULL;
    LPSRowSet   lpRowAB = NULL;
    LPABCONT    lpContainer = NULL;
    int         cNumRows = 0;
    int         nRows = 0;
    HRESULT     hr = E_FAIL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;
    LPSRowSet   pSRowSet = NULL;

    Assert(m_pAdrBook);
    if (!m_pAdrBook)
        return E_UNEXPECTED;

    // Get the entryid of the root PAB container
    hr = m_pAdrBook->GetPAB(&lpcbEID, &lpEID);

    if(!PR_MSGR_DEF_ID)
        InitNamedProps();

    // Open the root PAB container.  This is where all the WAB contents reside.
    ulObjType = 0;
    hr = m_pAdrBook->OpenEntry(lpcbEID,
                               (LPENTRYID)lpEID,
                               NULL,
                               0,
                               &ulObjType,
                               (LPUNKNOWN *) &lpContainer);

    if(HR_FAILED(hr))
        goto exit;

    if(pSink)
        m_pAB = pSink;

#ifdef LATER
    if (pSink && !m_ulConnection)
        m_pAdrBook->Advise(lpcbEID, lpEID, fnevObjectModified, (IMAPIAdviseSink *) pSink, &m_ulConnection);
#endif

    // Get a contents table of all the contents in the WABs root container.
    hr = lpContainer->GetContentsTable(WAB_PROFILE_CONTENTS  | MAPI_UNICODE, &lpAB);
    if(HR_FAILED(hr))
        goto exit;

    // Order the columns in the ContentsTable to conform to the ones we want
    // - which are mainly DisplayName, EntryID and ObjectType.  The table is 
    // guaranteed to set the columns in the order requested.
    Assert(PR_MSGR_DEF_ID);
    ptaEid.aulPropTag[ieidPR_MSGR_DEF_ID] = PR_MSGR_DEF_ID;
    hr = lpAB->SetColumns((LPSPropTagArray) &ptaEid, 0);
    if(HR_FAILED(hr))
        goto exit;

    // Reset to the beginning of the table
    hr = lpAB->SeekRow(BOOKMARK_BEGINNING, 0, NULL);
    if(HR_FAILED(hr))
        goto exit;

    // If we got this far, we have a populated table.  We can query the rows
    // now.
    hr = _QueryAllRows(lpAB, NULL, NULL, NULL, MAX_QUERY_SIZE, &pSRowSet);
    if (FAILED(hr) || !pSRowSet)
        goto exit;
    
    // Fill the provided ListView with this table
    _FillListFromTable(ctlList, pSRowSet);

exit:
    if (lpEID)
        m_pWABObject->FreeBuffer(lpEID);

    if (pSRowSet)
        _FreeProws(pSRowSet);

    if (lpContainer)
        lpContainer->Release();

    if (lpAB)
        lpAB->Release();

    return hr;
}


HRESULT CAddressBookData::DoLDAPSearch(LPTSTR pszText, CContainedWindow& ctlList)
{
    // Build a restriction based on the given text
    SRestriction SRes;
    if (SUCCEEDED(_GetLDAPSearchRestriction(pszText, &SRes)))
    {
        // Figure out what the entry ID is for the LDAP container
        ULONG     cbEntryID = 0;
        LPENTRYID pEntryID = 0;

        if (SUCCEEDED(_GetLDAPContainer(&cbEntryID, &pEntryID)))
        {
            // Perform the search
            SORT_INFO si = {0, 0};
            _GetLDAPContentsList(cbEntryID, pEntryID, si, &SRes, ctlList);

            if (pEntryID)
                m_pWABObject->FreeBuffer(pEntryID);

        }

        if (SRes.res.resAnd.lpRes)
            m_pWABObject->FreeBuffer(SRes.res.resAnd.lpRes);
    }

    return (S_OK);
}
    
    
void CAddressBookData::_FreeProws(LPSRowSet prows)
{
    if (prows)
    {
        for (ULONG irow = 0; irow < prows->cRows; ++irow)
            m_pWABObject->FreeBuffer(prows->aRow[irow].lpProps);

        m_pWABObject->FreeBuffer(prows);
    }
}


//
//  FUNCTION:   CAddressBookData::_MergeRowSets()
//
//  PURPOSE:    Merges prows with *pprowsDst, reallocating *pprowsDst if 
//              necessary.  Destroys the container portion of prows (but not 
//              the individual rows it contains).
//
//  PARAMETERS: 
//      [in]       prows     - source set of rows
//      [in, out] *pprowsDst - set of rows to merge the prows into 
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CAddressBookData::_MergeRowSets(LPSRowSet prows, LPSRowSet FAR *pprowsDst)
{
    SCODE       sc = S_OK;
    LPSRowSet   prowsT;
    UINT        crowsSrc;
    UINT        crowsDst;

    _ASSERTE(!IsBadWritePtr(pprowsDst, sizeof(LPSRowSet)));
    _ASSERTE(prows);

    // If the table is completely empty we want to return this.
    if (!*pprowsDst || (*pprowsDst)->cRows == 0)
    {
        m_pWABObject->FreeBuffer(*pprowsDst);
        *pprowsDst = prows;
        prows = NULL;                           // Don't free it!
        goto exit;
    }

    if (prows->cRows == 0)
    {
        goto exit;
    }

    // OK, now we know there are rows in both rowsets, we have to do a real 
    // merge.
    crowsSrc = (UINT) prows->cRows;
    crowsDst = (UINT) (*pprowsDst)->cRows;      //  handle 0

    if (FAILED(sc = m_pWABObject->AllocateBuffer(CbNewSRowSet(crowsSrc + crowsDst), (LPVOID*) &prowsT)))
        goto exit;
    if (crowsDst)
        CopyMemory(prowsT->aRow, (*pprowsDst)->aRow, crowsDst * sizeof(SRow));
    CopyMemory(&prowsT->aRow[crowsDst], prows->aRow, crowsSrc * sizeof(SRow));
    prowsT->cRows = crowsSrc + crowsDst;

    m_pWABObject->FreeBuffer(*pprowsDst);
    *pprowsDst = prowsT;

exit:
    // if (prows)
    //     m_pWABObject->FreeBuffer(&prows);

    return ResultFromScode(sc);
}


/*
 -	HrQueryAllRows
 -	
 *	Purpose:
 *		Retrieves all rows from an IMAPITable interface up to a set
 *		maximum. It will optionally set the column set, sort order,
 *		and restriction on the table before querying.
 *	
 *		If the table is empty, an SRowSet with zero rows is
 *		returned (just like QueryRows).
 *	
 *		The seek position of the table is undefined both before and
 *		after this call.
 *	
 *		If the function fails with an error other than
 *		MAPI_E_NOT_ENOUGH_MEMORY, extended error information is
 *		available through the table interface.
 *	
 *	Arguments:
 *		ptable		in		the table interface to query
 *		ptaga		in		if not NULL, column set for the table
 *		pres		in		if not NULL, restriction to be applied
 *		psos		in		if not NULL, sort order to be applied
 *		crowsMax	in		if nonzero, limits the number of rows
 *							to be returned.
 *		pprows		out		all rows of the table
 *	
 *	Returns:
 *		HRESULT. Extended error information normally is in the
 *		table.
 *	
 *	Side effects:
 *		Seek position of table is undefined.
 *	
 *	Errors:
 *		MAPI_E_TABLE_TOO_BIG if the table contains more than
 *		cRowsMax rows.
 */
HRESULT CAddressBookData::_QueryAllRows(LPMAPITABLE ptable,
	                                LPSPropTagArray ptaga, 
                                    LPSRestriction pres, 
                                    LPSSortOrderSet psos,
	                                LONG crowsMax, 
                                    LPSRowSet FAR *pprows)
{
	HRESULT		hr;
	LPSRowSet	prows = NULL;
	UINT		crows = 0;
	LPSRowSet	prowsT=NULL;
	UINT		crowsT;

	*pprows = NULL;

	// Set up the table, if the corresponding setup parameter is present.
	if (ptaga && FAILED(hr = ptable->SetColumns(ptaga, TBL_BATCH)))
		goto exit;
	if (pres && FAILED(hr = ptable->Restrict(pres, TBL_BATCH)))
		goto exit;
	if (psos && FAILED(hr = ptable->SortTable(psos, TBL_BATCH)))
		goto exit;

	// Set position to beginning of the table.
	if (FAILED(hr = ptable->SeekRow(BOOKMARK_BEGINNING, 0, NULL)))
		goto exit;

	if (crowsMax == 0)
		crowsMax = 0xffffffff;

	for (;;)
	{
		prowsT = NULL;

		// Retrieve some rows. Ask for the limit.
		hr = ptable->QueryRows(crowsMax, 0, &prowsT);
		if (FAILED(hr))
		{
			// Note: the failure may actually have happened during one of the 
            // setup calls, since we set TBL_BATCH.
			goto exit;
		}
		_ASSERTE(prowsT->cRows <= 0xFFFFFFFF);
		crowsT = (UINT) prowsT->cRows;

		// Did we get more rows than caller can handle?
		if ((LONG) (crowsT + (prows ? prows->cRows : 0)) > crowsMax)
		{
			hr = ResultFromScode(MAPI_E_TABLE_TOO_BIG);
			//_FreeProws(prowsT);
			goto exit;
		}

		// Add the rows just retrieved into the set we're building.		
        //
        // NOTE: this handles boundary conditions including either row set is 
        // empty.
        // 
		// NOTE: the merge destroys prowsT.
		if (FAILED(hr = _MergeRowSets(prowsT, &prows)))
			goto exit;

		// Did we hit the end of the table? Unfortunately, we have to ask twice 
        // before we know.
		if (crowsT == 0)
			break;
	}

    if(prows->cRows != 0)
	    *pprows = prows;

exit:
    if (prowsT)
        _FreeProws(prowsT);

	if (FAILED(hr))
		_FreeProws(prows);

	return hr;
}


HRESULT CAddressBookData::_GetLDAPContainer(ULONG *pcbEntryID, LPENTRYID *ppEntryID)
{
    ULONG           ulObjectType = 0;
    IABContainer   *pRoot = 0;
    LPMAPITABLE     pRootTable = 0;
    HRESULT         hr = S_OK;

    // Get the root Address Book container
    hr = m_pAdrBook->OpenEntry(0, NULL, NULL, 0, &ulObjectType, (LPUNKNOWN *) &pRoot);
    if (FAILED(hr))
        goto exit;

    // From the address book container, get a table of it's contents
    hr = pRoot->GetContentsTable(0, &pRootTable);
    if (FAILED(hr))
        goto exit;

    // Set the columns
    pRootTable->SetColumns((LPSPropTagArray) &irnColumns, 0);

    // Build a restriction to only display LDAP servers that we're supposed
    // to resolve against.
    SRestriction resAnd[2];         // 0 = LDAP, 1 = ResolveFlag
    SRestriction resLDAPResolve;
    SPropValue   ResolveFlag;

    // Restrict: Only show LDAP containers with Resolve TRUE
    resAnd[0].rt = RES_EXIST;
    resAnd[0].res.resExist.ulReserved1 = 0;
    resAnd[0].res.resExist.ulReserved2 = 0;
    resAnd[0].res.resExist.ulPropTag = PR_WAB_LDAP_SERVER;

    ResolveFlag.ulPropTag = PR_WAB_RESOLVE_FLAG;
    ResolveFlag.Value.b = TRUE;

    resAnd[1].rt = RES_PROPERTY;
    resAnd[1].res.resProperty.relop = RELOP_EQ;
    resAnd[1].res.resProperty.ulPropTag = PR_WAB_RESOLVE_FLAG;
    resAnd[1].res.resProperty.lpProp = &ResolveFlag;

    resLDAPResolve.rt = RES_AND;
    resLDAPResolve.res.resAnd.cRes = 2;
    resLDAPResolve.res.resAnd.lpRes = resAnd;

    // Apply the restruction
    hr = pRootTable->Restrict(&resLDAPResolve, 0);
    if (HR_FAILED(hr))
        goto exit;

    // We're going to just blindly grab the first item in this table as the
    // LDAP container we're going to use.
    LPSRowSet pRowSet;
    hr = pRootTable->QueryRows(1, 0, &pRowSet);
    if (FAILED(hr))
        goto exit;

    // Grab the size of the entry id
    *pcbEntryID = pRowSet->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.cb;

    // Make a copy of the entry id
    hr = m_pWABObject->AllocateBuffer(*pcbEntryID, (LPVOID *) ppEntryID);
    if (FAILED(hr))
        goto exit;

    CopyMemory(*ppEntryID, pRowSet->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.lpb, 
               *pcbEntryID);

exit:
    if (pRootTable)
        pRootTable->Release();

    if (pRoot)
        pRoot->Release();

    if (pRowSet)
        _FreeProws(pRowSet);

    return (hr);
}


HRESULT CAddressBookData::_GetLDAPSearchRestriction(LPTSTR pszText, LPSRestriction lpSRes)
{
    SRestriction    SRes = { 0 };
    LPSRestriction  lpPropRes = NULL;
    ULONG           ulcPropCount = 0;
    HRESULT         hr = E_FAIL;
    ULONG           i = 0;
    SCODE           sc = ERROR_SUCCESS;
    LPSPropValue    lpPropArray = NULL;


    if (!lstrlen(pszText))
    {
        ATLTRACE(_T("No Search Props"));
        goto exit;
    }

    lpSRes->rt = RES_AND;
    lpSRes->res.resAnd.cRes = 1;

    // Allocate a buffer for the restriction
    lpSRes->res.resAnd.lpRes = NULL;
    sc = m_pWABObject->AllocateBuffer(1 * sizeof(SRestriction), 
                                      (LPVOID *) &(lpSRes->res.resAnd.lpRes));
    if (S_OK != sc || !(lpSRes->res.resAnd.lpRes))
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpPropRes = lpSRes->res.resAnd.lpRes;

    // Create the first part of the OR clause
    lpPropRes[0].rt = RES_PROPERTY;
    lpPropRes[0].res.resProperty.relop = RELOP_EQ;
    lpPropRes[0].res.resProperty.ulPropTag = PR_EMAIL_ADDRESS;

    lpPropRes[0].res.resProperty.lpProp = NULL;
    m_pWABObject->AllocateMore(sizeof(SPropValue), lpPropRes, (LPVOID*) &(lpPropRes[0].res.resProperty.lpProp));
    lpPropArray = lpPropRes[0].res.resProperty.lpProp;
    if (!lpPropArray)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpPropArray->ulPropTag = PR_EMAIL_ADDRESS;
    lpPropArray->Value.LPSZ = NULL;

    ULONG cchSize = lstrlen(pszText) + 1;
    m_pWABObject->AllocateMore(cchSize * sizeof(TCHAR), lpPropRes, (LPVOID *) &(lpPropArray->Value.LPSZ));
    if (!lpPropArray->Value.LPSZ)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    StrCpyN(lpPropArray->Value.LPSZ, pszText, cchSize);

    hr = S_OK;

exit:
    return hr;
}


HRESULT CAddressBookData::_GetLDAPContentsList(ULONG cbContainerEID,
                                           LPENTRYID pContainerEID,
                                           SORT_INFO rSortInfo,
                                           LPSRestriction pPropRes,
                                           CContainedWindow& ctlList)
{
    HRESULT          hr = S_OK;
    HRESULT          hrTemp;
    ULONG            ulObjectType = 0;
    LPMAPICONTAINER  pContainer = NULL;
    LPMAPITABLE      pContentsTable = NULL;
    LPSRowSet        pSRowSet = NULL;

    // Open the container object corresponding to pContainerEID
    hr = m_pAdrBook->OpenEntry(cbContainerEID, pContainerEID, NULL, 0, 
                               &ulObjectType, (LPUNKNOWN *) &pContainer);
    if (FAILED(hr))
        goto exit;

    // Get the contents table from this container
    hr = pContainer->GetContentsTable(0, &pContentsTable);
    if (FAILED(hr))
        goto exit;

    // Order the columns in the ContentsTable to conform to the ones we want
    // - which are mainly DisplayName, EntryID and ObjectType.  The table is 
    // guaranteed to set the columns in the order requested.
    Assert(PR_MSGR_DEF_ID);
    ptaEid.aulPropTag[ieidPR_MSGR_DEF_ID] = PR_MSGR_DEF_ID;
    hr = pContentsTable->SetColumns((LPSPropTagArray) &ptaEid, 0);
    if(HR_FAILED(hr))
        goto exit;

    // Do the find
    hr = pContentsTable->FindRow(pPropRes, BOOKMARK_BEGINNING, 0);
    if (FAILED(hr))
        goto exit;

    // If this was a partial completion error, we want to continue but also
    // return this information to the caller
    if (MAPI_W_PARTIAL_COMPLETION == hr)
        hrTemp = hr;

    // If we got this far, we have a populated table.  We can query the rows
    // now.
    hr = _QueryAllRows(pContentsTable, NULL, NULL, NULL, MAX_QUERY_SIZE, &pSRowSet);
    if (FAILED(hr) || !pSRowSet)
        goto exit;

    // Fill in the ListView from the table
    _FillListFromTable(ctlList, pSRowSet, TRUE);

exit:
    if (pSRowSet)
        _FreeProws(pSRowSet);

    if (pContentsTable)
        pContentsTable->Release();

    if (pContainer)
        pContainer->Release();

    return (hr);
}


HRESULT CAddressBookData::_FillListFromTable(CContainedWindow& ctlList, LPSRowSet pSRowSet, BOOL bLDAP)
{
    LPSBinary lpSB;
    PNONEENTRIES Phones;

    // Make sure the caller passed us a rowset
    Assert(pSRowSet);
    Assert(PR_MSGR_DEF_ID);

    // Loop through the rows in the rowset
    for (ULONG i = 0; i < pSRowSet->cRows; i++)
    {
        // Get the information out of the table that we need.  Right now we're 
        // grabbing the entry ID, the display name, and the business phone number.
        LPENTRYID lpEID = (LPENTRYID) pSRowSet->aRow[i].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
        ULONG     cbEID = pSRowSet->aRow[i].lpProps[ieidPR_ENTRYID].Value.bin.cb;
        DWORD     nFlag = (pSRowSet->aRow[i].lpProps[ieidPR_OBJECT_TYPE].Value.l == MAPI_DISTLIST) ? MAB_GROUP : MAB_CONTACT;
        LPWSTR    lpwszID = NULL;
        LPWSTR    lpwszName = NULL;
        
        if(nFlag == MAB_CONTACT)
        {
            if(pSRowSet->aRow[i].lpProps[ieidPR_USER_X509_CERTIFICATE].ulPropTag == PR_USER_X509_CERTIFICATE)
                nFlag |= MAB_CERT;
        }

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_MSGR_DEF_ID/*ieidPR_EMAIL_ADDRESS*/].ulPropTag) == PT_UNICODE )
        {
            nFlag = nFlag | MAB_BUDDY;
            lpwszID = pSRowSet->aRow[i].lpProps[ieidPR_MSGR_DEF_ID/*ieidPR_EMAIL_ADDRESS*/].Value.lpszW;
        }
        else if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_EMAIL_ADDRESS].ulPropTag) == PT_UNICODE )
            lpwszID = pSRowSet->aRow[i].lpProps[ieidPR_EMAIL_ADDRESS].Value.lpszW;
        else
            lpwszID = NULL;

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_DISPLAY_NAME].ulPropTag) == PT_UNICODE )
            lpwszName = pSRowSet->aRow[i].lpProps[ieidPR_DISPLAY_NAME].Value.lpszW;
        else
            lpwszName = lpwszID;
        
        // LPTSTR    lpszPhone = pSRowSet->aRow[i].lpProps[ieidPR_BUSINESS_TELEPHONE_NUMBER].Value.lpszW;
        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_HOME_TELEPHONE_NUMBER].ulPropTag) == PT_UNICODE )
            Phones.pchHomePhone = pSRowSet->aRow[i].lpProps[ieidPR_HOME_TELEPHONE_NUMBER].Value.lpszW;
        else
            Phones.pchHomePhone = NULL;

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_BUSINESS_TELEPHONE_NUMBER].ulPropTag) == PT_UNICODE )
            Phones.pchWorkPhone = pSRowSet->aRow[i].lpProps[ieidPR_BUSINESS_TELEPHONE_NUMBER].Value.lpszW;
        else
            Phones.pchWorkPhone = NULL;

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_MOBILE_TELEPHONE_NUMBER].ulPropTag) == PT_UNICODE )
            Phones.pchMobilePhone = pSRowSet->aRow[i].lpProps[ieidPR_MOBILE_TELEPHONE_NUMBER].Value.lpszW;
        else
            Phones.pchMobilePhone = NULL;

         Phones.pchIPPhone = NULL; // temporary disabled pSRowSet->aRow[i].lpProps[ieidPR_HOME_TELEPHONE_NUMBER].Value.lpszW;

        // Allocate an ITEMINFO struct to store this information
        lpSB = NULL;
        m_pWABObject->AllocateBuffer(sizeof(SBinary), (LPVOID *) &lpSB);
        if (lpSB)
        {
            // Save the information we'll need later
            m_pWABObject->AllocateMore(cbEID, lpSB, (LPVOID *) &(lpSB->lpb));
            if (!lpSB->lpb)
            {
                m_pWABObject->FreeBuffer(lpSB);
                continue;
            }

            CopyMemory(lpSB->lpb, lpEID, cbEID);
            lpSB->cb = cbEID;

            // Create an item to add to the list
            m_pAB->CheckAndAddAbEntry(lpSB, lpwszID, lpwszName, nFlag, &Phones);
        }
    }

    // Let's make sure the first item is selected
//    ListView_SetItemState(ctlList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
   
    return (S_OK);
}

HRESULT CAddressBookData::NewContact(HWND hwndParent)
{    
    HRESULT     hr;
    ULONG       cbNewEntry;
    LPENTRYID   pNewEntry;
    ULONG           cbContainerID;
    LPENTRYID       pContainerID = 0;

    if(!m_pAdrBook)
        return E_FAIL;

    hr = m_pAdrBook->GetPAB(&cbContainerID, &pContainerID);
    if (FAILED(hr))
        return(hr);

    hr = m_pAdrBook->NewEntry((ULONG_PTR) hwndParent, /*CREATE_CHECK_DUP_STRICT*/ 0, cbContainerID, pContainerID, 0, NULL,
                              &cbNewEntry, &pNewEntry);

    return (hr);
}

// Add new (Msgr) contact to address book
HRESULT CAddressBookData::AutoAddContact(TCHAR * pchName, TCHAR * pchID)
{
    LPMAILUSER      lpMailUser = NULL;
    ULONG           ulcPropCount = 1;
    ULONG           ulIndex = 0;
    LPSPropValue    lpPropArray = NULL;
    SCODE           sc;
    LPWSTR          pwszName = NULL,
                    pwszID = NULL;
    HRESULT         hr = S_OK;

    if(!m_pAdrBook || !m_pWABObject)
        return(S_FALSE);

    // 1. Add entry to Address book
    pwszName = IEPszToUnicode(CP_ACP, pchName);
    if (!pwszName && (pchName && *pchName))
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }

    pwszID = IEPszToUnicode(CP_ACP, pchID);
    if (!pwszID && (pchID && *pchID))
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }

#ifdef LATER
    hr = HrWABCreateEntry(m_pAdrBook,
                            m_pWABObject,
                            pwszName,
                            pwszID,
                            CREATE_CHECK_DUP_STRICT,
                            &lpMailUser, KEEP_OPEN_READWRITE);
#endif
    if(SUCCEEDED(hr))
    {
        // 2. Set custom property: default address for buddy
        
        // Create a return prop array to pass back to the WAB
        sc = m_pWABObject->AllocateBuffer(sizeof(SPropValue), 
                                            (LPVOID *)&lpPropArray);
        if (sc!=S_OK)
            goto out;

        int nLen = lstrlen(pchID) + 1;
        if(nLen)
        {
            lpPropArray[0].ulPropTag = MsgrPropTags[0];
            sc = m_pWABObject->AllocateMore((nLen)*sizeof(TCHAR), lpPropArray, 
                                    (LPVOID *)&(lpPropArray[0].Value.LPSZ));

            if (sc!=S_OK)
                goto out;
            StrCpyN(lpPropArray[0].Value.LPSZ, pchID, nLen);
        }
        // Set this new data on the object
        //
        if(lpMailUser)
        {
            hr = lpMailUser->SetProps(1, lpPropArray, NULL);
            if(SUCCEEDED(hr))
                hr = lpMailUser->SaveChanges(FORCE_SAVE);
        }
    }

out:
    MemFree(pwszName);
    MemFree(pwszID);
    if(lpPropArray)
        m_pWABObject->FreeBuffer(lpPropArray);

    if(lpMailUser)
        ReleaseObj(lpMailUser);

    return(hr);
}

// Unicode string property version of template array
SizedSPropTagArray(6, ptaAddr_W) =
{
    6,
    {
        PR_ADDRTYPE_W,
        PR_DISPLAY_NAME_W,
        PR_EMAIL_ADDRESS_W,
        PR_ENTRYID,
        PR_CONTACT_EMAIL_ADDRESSES_W,  //4
        PR_SEARCH_KEY
    }
};

// ANSI string property version of template array
SizedSPropTagArray(6, ptaAddr_A) =
{
    6,
    {
        PR_ADDRTYPE_A,
        PR_DISPLAY_NAME_A,
        PR_EMAIL_ADDRESS_A,
        PR_ENTRYID,
        PR_CONTACT_EMAIL_ADDRESSES_A,
        PR_SEARCH_KEY
    }
};

HRESULT CAddressBookData::AddRecipient(LPMIMEADDRESSTABLEW pAddrTable, LPSBinary pSB, BOOL fGroup)
{
    HRESULT     hr;
    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;
    ULONG       ulObjType = 0;
    LPMAPITABLE lpAB =  NULL;
    LPABCONT    lpContainer = NULL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;

    // Retrieve the item from the wab
    hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

    // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_W, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    // Set those badboys on the address table
    if(pPropArray[2].ulPropTag == PR_EMAIL_ADDRESS_W)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[2].Value.lpszW, NULL , NULL);
    else if(pPropArray[4].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES_W)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[4].Value.MVszW.lppszW[0], NULL , NULL);
    else if((pPropArray[1].ulPropTag == PR_DISPLAY_NAME_W) && fGroup)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[1].Value.lpszW, NULL , NULL);

    // Bug 34077 - they don't want to have a display name...
    /* else if(pPropArray[1].ulPropTag == PR_DISPLAY_NAME)
        pAddrTable->Append(IAT_TO, IET_DECODED, pPropArray[1].Value.lpszW, NULL , NULL);
    else
        Assert(FALSE); */
exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (hr);
}

HRESULT CAddressBookData::SetDefaultMsgrID(LPSBinary pSB, LPWSTR pchID)
{
    ULONG       ulType = 0;
    IMailUser  *lpMailUser = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &lpMailUser);
    if (FAILED(hr))
        goto exit;

    if(SUCCEEDED(hr))
    {
        // 2. Set custom property: default address for buddy
        
        // Create a return prop array to pass back to the WAB
        sc = m_pWABObject->AllocateBuffer(sizeof(SPropValue), 
                                            (LPVOID *)&lpPropArray);
        if (sc!=S_OK)
            goto exit;

        int nLen = lstrlenW(pchID) +1 ;
        if(nLen)
        {
            lpPropArray[0].ulPropTag = MsgrPropTags[0];
            sc = m_pWABObject->AllocateMore(nLen * sizeof(WCHAR), lpPropArray, 
                                    (LPVOID *)&(lpPropArray[0].Value.lpszW));

            if (sc!=S_OK)
                goto exit;

            StrCpyNW(lpPropArray[0].Value.lpszW, pchID, nLen);
        }
        // Set this new data on the object
        //
        if(lpMailUser)
        {
            hr = lpMailUser->SetProps(1, lpPropArray, NULL);
            if(SUCCEEDED(hr))
                hr = lpMailUser->SaveChanges(FORCE_SAVE);
        }
    }

exit:
//    if(lpPropArray)
//        m_pWABObject->FreeBuffer(lpPropArray);

    SafeRelease(lpMailUser);
    return (hr);
}

HRESULT CAddressBookData::GetDisplayName(LPSBinary pSB, LPWSTR wszDisplayName, int nMax)
{

    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

        // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_W, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    StrCpyNW(wszDisplayName, pPropArray[1].Value.lpszW, nMax);
    wszDisplayName[nMax - 1] = L'\0';

exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (hr);

}

BOOL CAddressBookData::CheckEmailAddr(LPSBinary pSB, LPWSTR wszEmail)
{
    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;
    LPSPropValue lpPropMVEmail = NULL;
    UINT i = 0;
    BOOL fRet = FALSE;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

        // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_W, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    // 4 element is PR_CONTACT_EMAIL_ADDRESSES in ptaAddr
    lpPropMVEmail = &(pPropArray[4]);
    if(lpPropMVEmail && (lpPropMVEmail->ulPropTag == PR_CONTACT_EMAIL_ADDRESSES))
    {
        // we have a multiple emails
        //Assume, if this is present, so is MVAddrType, and defaultindex
        for(i = 0; i < lpPropMVEmail->Value.MVszW.cValues; i++)
        {

            if(!lstrcmpiW(lpPropMVEmail->Value.MVszW.lppszW[i], wszEmail))
                fRet = TRUE;
        }
    }
exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (fRet);
}



HRESULT CAddressBookData::FreeListViewItem(LPSBinary pSB)
{
    if (pSB)
        m_pWABObject->FreeBuffer(pSB);
    return (S_OK);
}

HRESULT CAddressBookData::ShowDetails(HWND hwndParent, LPSBinary pSB)
{
    HRESULT hr;
    ULONG_PTR   ulUIParam = (ULONG_PTR) hwndParent;

    hr = m_pAdrBook->Details(&ulUIParam, NULL, NULL, pSB->cb, (LPENTRYID) pSB->lpb, 
                             NULL, NULL, NULL, 0);

    return (hr);
}

HRESULT CAddressBookData::AddAddress(LPWSTR pwszDisplay, LPWSTR pwszAddress)
{
    HRESULT         hr;
    LPABCONT        pABContainer = NULL;
    ULONG           cbContainerID,
        ul;
    LPENTRYID       pContainerID = 0;
    LPMAPIPROP      lpProps = 0;
    SPropValue      rgpv[3];
    SPropTagArray   ptaEID = { 1, { PR_ENTRYID } };
    LPSPropValue    ppvDefMailUser=0;
    SizedSPropTagArray(1, ptaDefMailUser) =
    { 1, { PR_DEF_CREATE_MAILUSER } };
    
    DWORD           cUsedValues;
    
    // Get the entry ID for the PAB
    hr = m_pAdrBook->GetPAB(&cbContainerID, &pContainerID);
    if (FAILED(hr))
        goto error;
    
    // Request the container
    hr = m_pAdrBook->OpenEntry(cbContainerID, pContainerID, NULL,
        0, &ul, (LPUNKNOWN *) &pABContainer);
    Assert(ul == MAPI_ABCONT);
    if (FAILED(hr))
        goto error;
    
    // Free the entry ID
    m_pWABObject->FreeBuffer(pContainerID);
    
    // Get the properties for the default mail template
    hr = pABContainer->GetProps((LPSPropTagArray) &ptaDefMailUser, 0, &ul, &ppvDefMailUser);
    if (FAILED(hr) || !ppvDefMailUser || ppvDefMailUser->ulPropTag != PR_DEF_CREATE_MAILUSER)
        goto error;
    
    // Create a new entry
    hr=pABContainer->CreateEntry(ppvDefMailUser->Value.bin.cb, 
        (LPENTRYID) ppvDefMailUser->Value.bin.lpb,
        CREATE_CHECK_DUP_STRICT, &lpProps);
    if (FAILED(hr))
        goto error;
    
    // Fill in the properties for the display name and address
    rgpv[0].ulPropTag   = PR_DISPLAY_NAME_W;
    rgpv[0].Value.lpszW = pwszDisplay;
    rgpv[1].ulPropTag   = PR_EMAIL_ADDRESS_W;
    rgpv[1].Value.lpszW = pwszAddress;
    
    cUsedValues = 2;
    // Set those props on the entry
    hr = lpProps->SetProps(cUsedValues, rgpv, NULL);
    if (FAILED(hr))
        goto error;
    
    // Save 'em
    hr = lpProps->SaveChanges(KEEP_OPEN_READONLY);
    if (FAILED(hr))
        goto error;
    
error:
    ReleaseObj(lpProps);
    ReleaseObj(pABContainer);
    
    if (ppvDefMailUser)
        m_pWABObject->FreeBuffer(ppvDefMailUser);
    
    return hr;
}


HRESULT CAddressBookData::DeleteItems(ENTRYLIST *pList)
{
    ULONG       ulObjType = 0;
    LPABCONT    lpContainer = NULL;
    HRESULT     hr = E_FAIL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;

    // Get the entryid of the root PAB container
    hr = m_pAdrBook->GetPAB(&lpcbEID, &lpEID);

    // Open the root PAB container.  This is where all the WAB contents reside.
    ulObjType = 0;
    hr = m_pAdrBook->OpenEntry(lpcbEID,
                               (LPENTRYID)lpEID,
                               NULL,
                               0,
                               &ulObjType,
                               (LPUNKNOWN *) &lpContainer);

    m_pWABObject->FreeBuffer(lpEID);
    lpEID = NULL;

    // Delete those items
    lpContainer->DeleteEntries(pList, 0);

    lpContainer->Release();
    return (S_OK);
}

HRESULT CAddressBookData::Find(HWND hwndParent)
{
    m_pWABObject->Find(m_pAdrBook, hwndParent);
    return (S_OK);
}


HRESULT CAddressBookData::NewGroup(HWND hwndParent)
{
    HRESULT     hr;
    ULONG       cbNewEntry = 0;
    LPENTRYID   pNewEntry = 0;
    LPENTRYID   pTplEid;
    ULONG       cbTplEid;

    hr = _GetWABTemplateID(MAPI_DISTLIST, &cbTplEid, &pTplEid);
    if (SUCCEEDED(hr))
    {
        hr = m_pAdrBook->NewEntry((ULONG_PTR) hwndParent, 0, 0, NULL, cbTplEid, pTplEid, &cbNewEntry, &pNewEntry);
        Assert(pTplEid);
        m_pWABObject->FreeBuffer(pTplEid);
    }

    return (hr);
}

HRESULT CAddressBookData::AddressBook(HWND hwndParent)
{
#ifdef LATER
    CWab *pWab = NULL;
    
    if (SUCCEEDED(HrCreateWabObject(&pWab)))
    {
        pWab->HrBrowse(hwndParent);
        pWab->Release();
    }
    else
    {
        AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsGeneralWabError), 
                      NULL, MB_OK | MB_ICONEXCLAMATION);
    }
#endif
    return (S_OK);
}


HRESULT CAddressBookData::_GetWABTemplateID(ULONG ulObjectType, ULONG *lpcbEID, LPENTRYID *lppEID)
{
    LPABCONT lpContainer = NULL;
    HRESULT  hr  = S_OK;
    SCODE    sc = ERROR_SUCCESS;
    ULONG    ulObjType = 0;
    ULONG    cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewProps = NULL;
    ULONG    cNewProps;
    ULONG    nIndex;

    if ((!m_pAdrBook) || ((ulObjectType != MAPI_MAILUSER) && (ulObjectType != MAPI_DISTLIST)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    *lpcbEID = 0;
    *lppEID  = NULL;

    if (FAILED(hr = m_pAdrBook->GetPAB(&cbWABEID, &lpWABEID)))
    {
        goto out;
    }

    if (HR_FAILED(hr = m_pAdrBook->OpenEntry(cbWABEID,     // size of EntryID to open
                                              lpWABEID,     // EntryID to open
                                              NULL,         // interface
                                              0,            // flags
                                              &ulObjType,
                                              (LPUNKNOWN *) &lpContainer)))
    {
        goto out;
    }

    // Get us the default creation entryids
    if (FAILED(hr = lpContainer->GetProps((LPSPropTagArray) &ptaCreate,
                                          0, &cNewProps, &lpCreateEIDs)))
    {
        goto out;
    }

    // Validate the properites
    if (lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
        lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        goto out;
    }

    if (ulObjectType == MAPI_DISTLIST)
        nIndex = icrPR_DEF_CREATE_DL;
    else
        nIndex = icrPR_DEF_CREATE_MAILUSER;

    *lpcbEID = lpCreateEIDs[nIndex].Value.bin.cb;

    m_pWABObject->AllocateBuffer(*lpcbEID, (LPVOID *) lppEID);
    
    if (sc != S_OK)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    CopyMemory(*lppEID,lpCreateEIDs[nIndex].Value.bin.lpb,*lpcbEID);

out:
    if (lpCreateEIDs)
        m_pWABObject->FreeBuffer(lpCreateEIDs);

    if (lpContainer)
        lpContainer->Release();

    if (lpWABEID)
        m_pWABObject->FreeBuffer(lpWABEID);

    return hr;
}

/*//$$****************************************************************
//
// InitNamedProps
//
// Gets the PropTags for the Named Props this app is interested in
//
//********************************************************************/
HRESULT CAddressBookData::InitNamedProps(/*LPWABEXTDISPLAY lpWED*/)
{
    ULONG i;
    HRESULT hr = E_FAIL;
    LPSPropTagArray lptaMsgrProps = NULL;
    LPMAPINAMEID * lppMsgrPropNames;
    SCODE sc;
    // LPMAILUSER lpMailUser = NULL;
    WCHAR szBuf[msgrMax][MAX_PATH];

/*    if(!lpWED)
        goto err;

    lpMailUser = (LPMAILUSER) lpWED->lpPropObj;

    if(!lpMailUser)
        goto err; */

    sc = m_pWABObject->AllocateBuffer(sizeof(LPMAPINAMEID) * msgrMax, 
                                            (LPVOID *) &lppMsgrPropNames);
    if(sc)
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    for(i=0;i<msgrMax;i++)
    {
        sc = m_pWABObject->AllocateMore(sizeof(MAPINAMEID), 
                                                lppMsgrPropNames, 
                                                (LPVOID *)&(lppMsgrPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppMsgrPropNames[i]->lpguid = (LPGUID) &WAB_ExtBAGuid;
        lppMsgrPropNames[i]->ulKind = MNID_STRING;

        *(szBuf[i]) = '\0';

        // Convert prop name to wide-char
        if ( !MultiByteToWideChar( GetACP(), 0, lpMsgrPropNames[i], -1, szBuf[i], ARRAYSIZE(szBuf[i]) ))
        {
            continue;
        }

        lppMsgrPropNames[i]->Kind.lpwstrName = (LPWSTR) szBuf[i];
    }

    hr = m_pAdrBook->GetIDsFromNames(   msgrMax, 
                                        lppMsgrPropNames,
                                        MAPI_CREATE, 
                                        &lptaMsgrProps);
    if(HR_FAILED(hr))
        goto err;

    if(lptaMsgrProps)
    {
        // Set the property types on the returned props
        MsgrPropTags[MsgrID] = PR_MSGR_DEF_ID = CHANGE_PROP_TYPE(lptaMsgrProps->aulPropTag[MsgrID], PT_TSTRING);
    }

err:
    if(lptaMsgrProps)
        m_pWABObject->FreeBuffer( lptaMsgrProps);

    if(lppMsgrPropNames)
        m_pWABObject->FreeBuffer( lppMsgrPropNames);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\badata.h ===
// badata.h: interface for the CAddressBookData class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __BADATA_H_
#define __BADATA_H_

// Pull in the WAB header files
#include <wab.h>
#include <mimeole.h>

class CIEMsgAb;

typedef struct tagITEMINFO {
    LONG        lObjectType;
    LPENTRYID   pEntryID;
    ULONG       cbEntryID;
} ITEMINFO, *PITEMINFO;

typedef enum
{
    LPARAM_MENTRY = 1,
    LPARAM_ABENTRY,
    LPARAM_MABENTRY,
    LPARAM_ABGRPENTRY,
    MAX_LPARAM
} MABENUM;

// MAB types masks

#define  MAB_CONTACT    0x001
#define  MAB_GROUP      0x002
#define  MAB_BUDDY      0x004     
#define  MAB_CERT       0x008


class ATL_NO_VTABLE CAddressBookData
{
public:
	/////////////////////////////////////////////////////////////////////////
	// Constructor & Destructor
	//
	CAddressBookData();
	virtual ~CAddressBookData();

	/////////////////////////////////////////////////////////////////////////
	// WAB Functions
	//
	BOOL	fIsWabLoaded(void) {return(m_pAdrBook ? TRUE : FALSE);};
	HRESULT OpenWabFile(BOOL fWAB);
	HRESULT LoadWabContents(CContainedWindow& ctlList, CIEMsgAb *pSink);
    HRESULT DoLDAPSearch(LPTSTR pszText, CContainedWindow& ctlList);
    HRESULT NewContact(HWND hwndParent);
    HRESULT AddRecipient(LPMIMEADDRESSTABLEW pAddrTable, LPSBinary pInfo, BOOL fGroup);
    HRESULT FreeListViewItem(LPSBinary pSB);
    HRESULT ShowDetails(HWND hwndParent, LPSBinary pSB);
    HRESULT AddAddress(LPWSTR pwszDisplay, LPWSTR pwszAddress);
    HRESULT GetDisplayName(LPSBinary pSB, LPWSTR pwszDisplayName, int nMax);
    HRESULT DeleteItems(ENTRYLIST *pList);
    HRESULT Unadvise(void)
    {
        if (m_ulConnection)
           m_pAdrBook->Unadvise(m_ulConnection);
        return (S_OK);
    }
    HRESULT Find(HWND hwndParent);
    HRESULT AddressBook(HWND hwndParent);
    HRESULT NewGroup(HWND hwndParent);
    HRESULT AutoAddContact(TCHAR * pchName, TCHAR * pchID);
    HRESULT InitNamedProps(void);
    HRESULT SetDefaultMsgrID(LPSBinary pSB, LPWSTR pchID);
    BOOL CheckEmailAddr(LPSBinary pSB, LPWSTR wszEmail);

    /////////////////////////////////////////////////////////////////////////
    // MAPI Utility Functions
    //
protected:
    void    _FreeProws(LPSRowSet prows);
    HRESULT	_MergeRowSets(LPSRowSet prows, LPSRowSet FAR *pprowsDst);
    HRESULT _QueryAllRows(LPMAPITABLE ptable, LPSPropTagArray ptaga, 
                          LPSRestriction pres, LPSSortOrderSet psos,
	                      LONG crowsMax, LPSRowSet FAR *pprows);
    HRESULT _FillListFromTable(CContainedWindow& ctlList, LPSRowSet pSRowSet,
                               BOOL bLDAP = FALSE);
    HRESULT _GetWABTemplateID(ULONG ulObjectType, ULONG *lpcbEID, LPENTRYID *lppEID);
    HRESULT _AllocateBuffer(ULONG   cbSize, LPVOID FAR *lppBuffer);
    HRESULT _FreeBuffer(LPVOID lppBuffer);
    HRESULT _AllocateMore(ULONG   cbSize, LPVOID lpObject, LPVOID FAR *lppBuffer);

    /////////////////////////////////////////////////////////////////////////
    // LDAP Routines
    //

    typedef struct _SortInfo
    {
        BOOL bSortAscending;
        BOOL bSortByLastName;
    } SORT_INFO, *LPSORT_INFO;

    HRESULT _GetLDAPContainer(ULONG *pcbEntryID, LPENTRYID *ppEntryID);
    HRESULT _GetLDAPSearchRestriction(LPTSTR pszText, LPSRestriction lpSRes);
    HRESULT _GetLDAPContentsList(ULONG cbContainerEID, LPENTRYID pContainerEID, 
                                 SORT_INFO rSortInfo, LPSRestriction pPropRes, 
                                 CContainedWindow& ctlList);

// Private member data
private:

	// WAB Stuff
	LPWABOBJECT m_pWABObject;
    HINSTANCE	m_hInstWAB;
    LPADRBOOK	m_pAdrBook; 
    ULONG       m_ulConnection;
    // LPMAPISESSION m_pSession;

    CIEMsgAb * m_pAB;
};

void AddAccountsToList(HWND hDlg, int id, LPARAM lParam);

#endif  // __BADATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\baui.cpp ===
// baui.cpp : Implementation of CIEMsgAb
// Messenger integration to OE
// Created 04/20/98 by YST
// #define YST 1


#include "pch.hxx"
#include <windowsx.h>
#include "msoert.h"
#include "basicim2.h"
#include "shlwapi.h"
#include "bactrl.h"
#include "baprop.h"
#include "baui.h"
#include "bllist.h"
#include <wabapi.h>
#include "shlwapip.h"
#include "clutil.h"
#include <mapi.h>
#include "hotlinks.h"

static CAddressBookData  * st_pAddrBook = NULL;

#define MAX_MENUSTR             256
//
//  Pseudoclass for the variable-sized OLECMDTEXT structure.
//  You need to declare it as a class (and not a BYTE buffer that is
//  suitable cast) because BYTE buffers are not guaranteed to be aligned.
//
template <int n>
class OLECMDTEXTV : public OLECMDTEXT {
    WCHAR wszBuf[n-1];          // "-1" because OLECMDTEXT includes 1 wchar
};



#ifdef DEBUG
DWORD dwDOUTLevel = 0;
#endif
HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState);
STDAPI OESimulateDrop(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                      const POINTL *ppt, DWORD *pdwEffect);

typedef enum _tagGetPropertyIDs
{
    TBEX_BUTTONTEXT     = 100,     // VT_BSTR
    TBEX_TOOLTIPTEXT    = 101,     // VT_BSTR
    TBEX_GRAYICON       = 102,     // HICON as a VT_BYREF
    TBEX_HOTICON        = 103,     // HICON as a VT_BYREF
    TBEX_GRAYICONSM     = 104,     // HICON as a VT_BYREF
    TBEX_HOTICONSM      = 105,     // HICON as a VT_BYREF
    TBEX_DEFAULTVISIBLE = 106,     // VT_BOOL
    TMEX_MENUTEXT       = 200,     // VT_BSTR
    TMEX_STATUSBARTEXT  = 201,     // VT_BSTR
    TMEX_CUSTOM_MENU    = 202,     // VT_BSTR
} GETPROPERTYIDS;

static const int BA_SortOrder[] =
{
    BIMSTATE_ONLINE,
    BIMSTATE_BE_RIGHT_BACK,
    BIMSTATE_OUT_TO_LUNCH,
    BIMSTATE_IDLE,
    BIMSTATE_AWAY,
    BIMSTATE_ON_THE_PHONE,
    BIMSTATE_BUSY,
    BIMSTATE_INVISIBLE,
    BIMSTATE_OFFLINE,
    BIMSTATE_UNKNOWN
};


// Create control
HRESULT CreateIEMsgAbCtrl(IIEMsgAb **ppIEMsgAb)
{
    HRESULT         hr;
    IUnknown         *pUnknown;

    TraceCall("CreateMessageList");

    // Get the class factory for the MessageList object
    IClassFactory *pFactory = NULL;
    hr = _Module.GetClassObject(CLSID_IEMsgAb, IID_IClassFactory,
                                (LPVOID *) &pFactory);

    // If we got the factory, then get an object pointer from it
    if (SUCCEEDED(hr))
    {
        hr = pFactory->CreateInstance(NULL, IID_IUnknown,
                                      (LPVOID *) &pUnknown);
        if (SUCCEEDED(hr))
        {
            hr = pUnknown->QueryInterface(IID_IIEMsgAb, (LPVOID *) ppIEMsgAb);
            pUnknown->Release();
        }
        pFactory->Release();
    }

    return (hr);
}

/////////////////////////////////////////////////////////////////////////////
// CIEMsgAb
CIEMsgAb::CIEMsgAb():m_ctlList(_T("SysListView32"), this, 1)
{
    m_bWindowOnly = TRUE;

    m_pDataObject = 0;
    m_cf = 0;

    m_hwndParent    = NULL;
    m_pFolderBar    = NULL;
    m_pObjSite      = NULL;
    m_nSortType =  HIWORD(DwGetOptions());
    m_pCMsgrList = NULL;

    m_himl = NULL;

    m_fLogged = FALSE;
    m_dwFontCacheCookie = 0;
    m_nChCount = 0;

    m_lpWED = NULL;
    m_lpWEDContext = NULL;
    m_lpPropObj = NULL;

    m_szOnline = NULL;
    // m_szInvisible = NULL;
    m_szBusy = NULL;
    m_szBack = NULL;
    m_szAway = NULL;
    m_szOnPhone = NULL;
    m_szLunch = NULL;
    m_szOffline = NULL;
    m_szIdle = NULL;
    m_szEmptyList = NULL;
    m_szMsgrEmptyList = NULL;
    m_szLeftBr = NULL;
    m_szRightBr = NULL;

    m_fNoRemove = FALSE;
    m_delItem = 0;

    m_dwHideMessenger = DwGetMessStatus();
    m_dwDisableMessenger = DwGetDisableMessenger();

    WORD wShow =  LOWORD(DwGetOptions());

    m_fShowAllContacts = FALSE;
    m_fShowOnlineContacts = FALSE;
    m_fShowOfflineContacts = FALSE;
    m_fShowEmailContacts  = FALSE;
    m_fShowOthersContacts  = FALSE;

    if(wShow == 0)
        m_fShowAllContacts = TRUE;
    else if (wShow == 1)
        m_fShowOfflineContacts = TRUE;
    else
        m_fShowOnlineContacts = TRUE;

    m_fWAB = TRUE;

    // Initialize the applicaiton
#ifdef LATER
    g_pInstance->DllAddRef();
#endif

    // Raid-32933: OE: MSIMN.EXE doesn't always exit
    // g_pInstance->CoIncrementInit();

    // LATER this is temporary hack for resources!!!
    _ASSERT(g_hLocRes);
//    g_hLocRes = g_hInst; //_Module.GetResourceInstance();
}

CIEMsgAb::~CIEMsgAb()
{
// #ifdef  TEST
    SafeRelease(m_pObjSite);
// #endif

    // unregister from Msgr list
    if(m_pCMsgrList)
    {
        m_pCMsgrList->UnRegisterUIWnd(m_hWnd);
        OE_CloseMsgrList(m_pCMsgrList);
        m_pCMsgrList = NULL;
    }  
    
    SafeMemFree(m_szOnline);
    // SafeMemFree(m_szInvisible);
    SafeMemFree(m_szBusy);
    SafeMemFree(m_szBack);
    SafeMemFree(m_szAway);
    SafeMemFree(m_szOnPhone);
    SafeMemFree(m_szLunch);
    SafeMemFree(m_szOffline);
    SafeMemFree(m_szIdle);
    SafeMemFree(m_szMsgrEmptyList);
    SafeMemFree(m_szEmptyList);
    SafeMemFree(m_szLeftBr);
    SafeMemFree(m_szRightBr);

    // Raid-32933: OE: MSIMN.EXE doesn't always exit
    // g_pInstance->CoDecrementInit();
#ifdef LATER
    g_pInstance->DllRelease();
#endif
}

LRESULT CIEMsgAb::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    WORD wShow;
    if(m_fShowOnlineContacts)
        wShow = 2;
    else if(m_fShowOfflineContacts)
        wShow = 1;
    else
        wShow = 0;

    DwSetOptions((DWORD) MAKELONG(wShow, m_nSortType));

//    KillTimer(IDT_PANETIMER);
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);

#ifdef LATER
    if (m_dwFontCacheCookie && g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Unadvise(m_dwFontCacheCookie);
            pConnection->Release();
        }
    }
    m_cAddrBook.Unadvise();
#endif
    // RevokeDragDrop(m_hWnd); 

    if (m_himl != NULL)
        ImageList_Destroy(m_himl);
    return 0;
}

HRESULT CIEMsgAb::OnDraw(ATL_DRAWINFO& di)
{
    RECT&   rc = *(RECT*)di.prcBounds;

#if 0
    int     patGray[4];
    HBITMAP hbm;
    HBRUSH  hbr;
    COLORREF cFg;
    COLORREF cBkg;

    // Initialize the pattern
    patGray[0] = 0x005500AA;
    patGray[1] = 0x005500AA;
    patGray[2] = 0x005500AA;
    patGray[3] = 0x005500AA;

    // Create a bitmap from the pattern
    hbm = CreateBitmap(8, 8, 1, 1, (LPSTR)patGray);

    if ((HBITMAP) NULL != hbm)
    {
        hbr = CreatePatternBrush(hbm);
        if (hbr)
        {
            // Select the right colors into the DC
            cFg = SetTextColor(di.hdcDraw, GetSysColor(COLOR_3DFACE));
            cBkg = SetBkColor(di.hdcDraw, RGB(255, 255, 255));

            // Fill the rectangle
            FillRect(di.hdcDraw, &rc, hbr);

            SetTextColor(di.hdcDraw, cFg);
            SetBkColor(di.hdcDraw, cBkg);

            DeleteObject(hbr);
        }

        DeleteObject(hbm);
    }
#endif

    // Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
    return S_OK;
}

LRESULT CIEMsgAb::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Define a bogus rectangle for the controls.  They will get resized in
    // our size handler.
    RECT rcPos = {0, 0, 100, 100};
    WCHAR       sz[CCHMAX_STRINGRES];

    // Create the various controls
    m_ctlList.Create(m_hWnd, rcPos, _T("Outlook Express Address Book ListView"),
                     WS_TABSTOP | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN |
                     LVS_REPORT | LVS_NOCOLUMNHEADER | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS /* | LVS_SORTASCENDING*/);

    if(m_ctlList.m_hWnd == NULL)
    {
        DWORD dwErr = GetLastError();
        Assert(FALSE);
    }

    ListView_SetUnicodeFormat(m_ctlList, TRUE);
    ListView_SetExtendedListViewStyleEx(m_ctlList, LVS_EX_INFOTIP | LVS_EX_LABELTIP, LVS_EX_INFOTIP | LVS_EX_LABELTIP);

    // Image List
    Assert(m_himl == NULL);
    m_himl = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbAddrBookHot), 16, 0,
                               RGB(255, 0, 255), IMAGE_BITMAP,
                               LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);

    ListView_SetImageList(m_ctlList, m_himl, LVSIL_SMALL);

    LVCOLUMN lvc;

    lvc.mask = LVCF_SUBITEM;
    lvc.iSubItem = 0;

    ListView_InsertColumn(m_ctlList, 0, &lvc);

#ifdef LATER
    m_ctlList.SendMessage(WM_SETFONT, NULL, 0);
    SetListViewFont(m_ctlList, GetListViewCharset(), TRUE);

    if (g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Advise((IUnknown *)(IFontCacheNotify *) this, &m_dwFontCacheCookie);
            pConnection->Release();
        }
    }
#endif

    if(!m_dwHideMessenger && !m_dwDisableMessenger)
    {
        // Msgr Initialization
        m_pCMsgrList = OE_OpenMsgrList();
        // Register our control for Msgr list
        if(m_pCMsgrList)
        {
            m_pCMsgrList->RegisterUIWnd(m_hWnd);
            if(m_pCMsgrList->IsLocalOnline())
            {
                m_fLogged = TRUE;
                FillMsgrList();
            }
        }
    }

    // Initialize the address book object too
    m_fWAB = CheckForWAB();
	if(m_fWAB)
	{
		HRESULT hr = m_cAddrBook.OpenWabFile(m_fWAB);
		if(hr == S_OK) // && m_fShowAllContacts)
			m_cAddrBook.LoadWabContents(m_ctlList, this);
	}
    else
    {   if(m_fShowAllContacts)
        {
            // Bug 23934. We show only online/offline contacts if we use Outlook
            m_fShowAllContacts = FALSE;
            m_fShowOnlineContacts = FALSE;
            m_fShowOfflineContacts = TRUE;
        }
    }

    st_pAddrBook = &m_cAddrBook;

    // Sort and Select the first item
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    ListView_SetItemState(m_ctlList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

    // Add the tooltip
    // Load Tooltip strings

    if(AthLoadString(idsBAOnline, sz, ARRAYSIZE(sz)))
    {
        ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szOnline, cchSize * sizeof(WCHAR)))
            StrCpyNW(m_szOnline, sz, cchSize);
    }

    if(AthLoadString(idsBABusy, sz, ARRAYSIZE(sz)))
    {
        ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szBusy, cchSize*sizeof(WCHAR)))
            StrCpyNW(m_szBusy, sz, cchSize);
    }

    if(AthLoadString(idsBABack, sz, ARRAYSIZE(sz)))
    {
        ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szBack, cchSize*sizeof(WCHAR)))
            StrCpyNW(m_szBack, sz, cchSize);
    }

    if(AthLoadString(idsBAAway, sz, ARRAYSIZE(sz)))
    {
        ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szAway, cchSize*sizeof(WCHAR)))
            StrCpyNW(m_szAway, sz, cchSize);
    }

    if(AthLoadString(idsBAOnPhone, sz, ARRAYSIZE(sz)))
    {
       ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szOnPhone, cchSize*sizeof(WCHAR)))
            StrCpyNW(m_szOnPhone, sz, cchSize);
    }

    if(AthLoadString(idsBALunch, sz, ARRAYSIZE(sz)))
    {
        ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szLunch, cchSize*sizeof(WCHAR)))
            StrCpyNW(m_szLunch, sz, cchSize);
    }

    if(AthLoadString(idsBAOffline, sz, ARRAYSIZE(sz)))
    {
        ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szOffline, cchSize*sizeof(WCHAR)))
            StrCpyNW(m_szOffline, sz, cchSize);
    }

    if(AthLoadString(idsBAIdle, sz, ARRAYSIZE(sz)))
    {
        ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szIdle, cchSize*sizeof(WCHAR)))
            StrCpyNW(m_szIdle, sz, cchSize);
    }

    if(AthLoadString(idsMsgrEmptyList, sz, ARRAYSIZE(sz)))
    {
        ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szEmptyList, cchSize*sizeof(WCHAR)))
            StrCpyNW(m_szEmptyList, sz, cchSize);
    }

    if(AthLoadString(idsMSNEmptyList, sz, ARRAYSIZE(sz)))
    {
        ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szMsgrEmptyList, cchSize*sizeof(WCHAR)))
            StrCpyNW(m_szMsgrEmptyList, sz, cchSize);
    }

    if(AthLoadString(idsLeftBr, sz, ARRAYSIZE(sz)))
    {
        ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szLeftBr, cchSize*sizeof(WCHAR)))
            StrCpyNW(m_szLeftBr, sz, cchSize);
    }

    if(AthLoadString(idsRightBr, sz, ARRAYSIZE(sz)))
    {
        ULONG cchSize = lstrlenW(sz) + 1;
        if(MemAlloc((LPVOID *) &m_szRightBr, cchSize*sizeof(WCHAR)))
            StrCpyNW(m_szRightBr, sz, cchSize);
    }

    m_ctlList.SetFocus();

    // Register ourselves as a drop target
    // RegisterDragDrop(m_hWnd, (IDropTarget *) this);

    // Update the size of the listview columns
    _AutosizeColumns();

    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPWSTR) (m_fShowAllContacts ? m_szEmptyList : m_szMsgrEmptyList));

//    SetTimer(IDT_PANETIMER, ELAPSE_MOUSEOVERCHECK, NULL);
    // Finished
    return (0);
}

LRESULT CIEMsgAb::OnSetFocus(UINT  nMsg , WPARAM  wParam , LPARAM  lParam , BOOL&  bHandled )
{
    CComControlBase::OnSetFocus(nMsg, wParam, lParam, bHandled);
    m_ctlList.SetFocus();
#ifdef TEST
    if (m_pObjSite)
    {
        m_pObjSite->OnFocusChangeIS((IInputObject*) this, TRUE);
    }
#endif //TEST
    return 0;
}

LRESULT CIEMsgAb::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    RECT rc;
    DWORD width = LOWORD(lParam);
    DWORD height = HIWORD(lParam);

    // Position the listview to fill the entire area
    RECT rcList;
    rcList.left   = 0;
    rcList.top    = 0;
    rcList.right  = width;
    rcList.bottom = height;

    m_ctlList.SetWindowPos(NULL, &rcList, SWP_NOACTIVATE | SWP_NOZORDER);

    // Update the size of the listview columns
    _AutosizeColumns();
    // bHandled = FALSE;
    return (0);
}

void CIEMsgAb::_AutosizeColumns(void)
{
    RECT rcList;
    m_ctlList.GetClientRect(&rcList);
    ListView_SetColumnWidth(m_ctlList, 0, rcList.right - 5);
}


#ifdef LATER
//
//  FUNCTION:   CMessageList::OnPreFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache before it changes the fonts we're
//              using.  In response we tell the ListView to dump any custom
//              font's it's using.
//
STDMETHODIMP CIEMsgAb::OnPreFontChange(void)
{
    m_ctlList.SendMessage(WM_SETFONT, 0, 0);
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::OnPostFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache after it updates the font's we're
//              using.  In response, we set the new font for the current charset.
//
STDMETHODIMP CIEMsgAb::OnPostFontChange(void)
{
    SetListViewFont(m_ctlList, GetListViewCharset(), TRUE);
    return (S_OK);
}
#endif

LRESULT CIEMsgAb::CmdSetOnline(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();

    if(!pEntry || (pEntry->tag == LPARAM_MENTRY) || !m_pCMsgrList)
        return S_FALSE;

    // m_cAddrBook.SetDefaultMsgrID(pEntry->lpSB, pEntry->pchWABID);
    if(m_pCMsgrList && (PromptToGoOnline() == S_OK) )
        m_pCMsgrList->AddUser(pEntry->pchWABID);

    return S_OK;
}

LRESULT CIEMsgAb::CmdNewOnlineContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if(m_pCMsgrList)
    {
        if(PromptToGoOnline() == S_OK)
            m_pCMsgrList->NewOnlineContact();
    }

    return S_OK;
}

LRESULT CIEMsgAb::CmdNewContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Tell the WAB to bring up it's new contact UI
	HRESULT hr = S_OK;

	if(!m_cAddrBook.fIsWabLoaded())
	{
		if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
			goto exit;
	}
    if(FAILED(hr = m_cAddrBook.NewContact(m_hWnd)))
		goto exit;

    _ReloadListview();
exit:
    return (hr);
}

LRESULT CIEMsgAb::NewInstantMessage(LPMABENTRY pEntry)
{
    if(((INT_PTR)  pEntry) == -1)
        return(m_pCMsgrList->SendInstMessage(NULL));
    else if(m_pCMsgrList)
    {
        if(PromptToGoOnline() == S_OK)
            return(m_pCMsgrList->SendInstMessage(pEntry->lpMsgrInfo->pchID));
    }

    return(S_OK);
}

LRESULT CIEMsgAb::CmdDialPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return(CallPhone(NULL, FALSE));
}

LRESULT CIEMsgAb::CmdHomePhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();
    if(!pEntry || !(pEntry->lpPhones))
    {
        Assert(FALSE);
        return(E_FAIL);
    }
    return(CallPhone(pEntry->lpPhones->pchHomePhone, (pEntry->tag == LPARAM_MENTRY)));
}

LRESULT CIEMsgAb::CmdWorkPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();
    if(!pEntry || !(pEntry->lpPhones))
    {
        Assert(FALSE);
        return(E_FAIL);
    }
    return(CallPhone(pEntry->lpPhones->pchWorkPhone, (pEntry->tag == LPARAM_MENTRY)));
}

LRESULT CIEMsgAb::CmdMobilePhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();
    if(!pEntry || !(pEntry->lpPhones))
    {
        Assert(FALSE);
        return(E_FAIL);
    }
    return(CallPhone(pEntry->lpPhones->pchMobilePhone, (pEntry->tag == LPARAM_MENTRY)));
}

LRESULT CIEMsgAb::CmdIPPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();
    if(!pEntry || !(pEntry->lpPhones))
    {
        Assert(FALSE);
        return(E_FAIL);
    }
    return(CallPhone(pEntry->lpPhones->pchIPPhone, (pEntry->tag == LPARAM_MENTRY)));
}

LRESULT CIEMsgAb::CallPhone(WCHAR *wszPhone, BOOL fMessengerContact)
{
    WCHAR wszTmp[MAX_PATH] ={0};
    
    if((lstrlenW(wszPhone) + 5) >= MAX_PATH)
        return(E_FAIL);
    
    if(!(!m_pCMsgrList || !m_pCMsgrList->IsLocalOnline()))
    {
        // Use Messenger API
        if(fMessengerContact)
        {
            StrCpyNW(wszTmp, L"+", ARRAYSIZE(wszTmp));
            StrCatBuffW(wszTmp, wszPhone, ARRAYSIZE(wszTmp));
        }
        else
            StrCpyNW(wszTmp, wszPhone, ARRAYSIZE(wszTmp));
        
        if(SUCCEEDED(m_pCMsgrList->LaunchPhoneUI(wszTmp)))
            return(S_OK);
    }
    
    Assert(IsTelInstalled());
    
    StrCpyNW(wszTmp, L"Tel:", ARRAYSIZE(wszTmp));
    if(wszPhone)
    {
        StrCatBuffW(wszTmp, wszPhone, ARRAYSIZE(wszTmp));
    }
    
    SHELLEXECUTEINFOW ExecInfo;
    ExecInfo.cbSize = sizeof(SHELLEXECUTEINFOW);
    ExecInfo.nShow = SW_SHOWNORMAL;
    ExecInfo.fMask = 0;
    ExecInfo.hwnd = m_hWnd;
    ExecInfo.lpDirectory = NULL;
    ExecInfo.lpParameters = NULL;
    ExecInfo.lpVerb = L"open";
    ExecInfo.lpFile = wszTmp;
    
    if(!ShellExecuteExW(&ExecInfo))
    {
        WCHAR wszMsg[CCHMAX_STRINGRES];
        WCHAR wszTitle[CCHMAX_STRINGRES];

        if(!AthLoadString(idsAthena, wszTitle, ARRAYSIZE(wszTitle)))
            wszTitle[0] = L'\0';

        if(!AthLoadString(idsTelFail, wszMsg, ARRAYSIZE(wszMsg)))
            wszMsg[0] = L'\0';

        MessageBoxW(NULL, wszMsg, wszTitle, MB_OK | MB_ICONSTOP);

    }
    return(S_OK);
}

LRESULT CIEMsgAb::CmdNewEmaile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LVITEM                  lvi;
    LPMABENTRY              pEntry;
    LPRECIPLIST             lpList = NULL;
    LPRECIPLIST             lpListNext = lpList;
    ULONG                   nRecipCount = 0;
    TCHAR                   szBuf[MAX_PATH];
    HRESULT hr = S_OK;

    // Loop through the selected items
    lvi.mask = LVIF_PARAM;
    lvi.iItem = -1;
    lvi.iSubItem = 0;

    while (-1 != (lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVIS_SELECTED)))
    {
        // We need to get the entry ID from the item
        ListView_GetItem(m_ctlList, &lvi);

        // Tell the data source to add this person to the message
        pEntry = (LPMABENTRY) lvi.lParam;
        Assert(pEntry);

        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY)
        {
         //   m_cAddrBook.AddRecipient(pAddrTableW, pEntry->lpSB, FALSE);

            lpListNext = AddTeimToRecipList(lpListNext, pEntry->pchWABID, pEntry->pchWABName, pEntry->lpSB);
            if(!lpList)
                lpList = lpListNext;
            nRecipCount++;
        }
/*        else if(pEntry->tag == LPARAM_ABGRPENTRY)
            m_cAddrBook.AddRecipient(pAddrTableW, pEntry->lpSB, TRUE);*/
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            Assert(pEntry->lpMsgrInfo);
            lpListNext = AddTeimToRecipList(lpListNext, pEntry->lpMsgrInfo->pchID, pEntry->lpMsgrInfo->pchMsgrName, NULL);
            if(!lpList)
                lpList = lpListNext;
            nRecipCount++;
        }
        else
            Assert(FALSE);
    }


    if(nRecipCount)
        hr = HrStartMailThread( m_hWnd, nRecipCount,
                            lpList,                     // HrSendMail frees lpList so dont reuse
                            CheckForOutlookExpress(szBuf, ARRAYSIZE(szBuf)));

    return (hr);
}

LRESULT CIEMsgAb::CmdNewIMsg(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return(CmdNewMessage(wNotifyCode, ID_SEND_INSTANT_MESSAGE, hWndCtl, bHandled));
}

LRESULT CIEMsgAb::CmdNewMessage(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LVITEM                  lvi;
    LPMABENTRY             pEntry;

    pEntry = GetEntryForSendInstMsg();

    if(wID == ID_SEND_INSTANT_MESSAGE)
    {
        if(pEntry)
            return(NewInstantMessage(pEntry));
        else
        {
            Assert(FALSE);
            return(-1);
        }
    }
    else if((((INT_PTR) pEntry) != -1) && pEntry)
        return(NewInstantMessage(pEntry));
    else
        return(CmdNewEmaile(wNotifyCode, wID, hWndCtl, bHandled));
}
// Exec for Properties command
LRESULT CIEMsgAb::CmdProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    LPMABENTRY pEntry = GetSelectedEntry();

    if(pEntry)
    {
        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
		{
			if(!m_cAddrBook.fIsWabLoaded())
			{
				if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
					return(hr);
			}

            m_cAddrBook.ShowDetails(m_hWnd, pEntry->lpSB);
		}
    }

    _ReloadListview();
    return (0);
}

LRESULT CIEMsgAb::NotifyDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NMLISTVIEW *pnmlv = (NMLISTVIEW *) pnmh;
    LVITEM lvi;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = pnmlv->iItem;
    lvi.iSubItem = 0;

    ListView_GetItem(m_ctlList, &lvi);
    LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;

    if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
	{
		Assert(m_cAddrBook.fIsWabLoaded());
        m_cAddrBook.FreeListViewItem(pEntry->lpSB);
	}
    RemoveBlabEntry(pEntry);
    if(m_delItem > 0)
        m_delItem--;
    else
        Assert(FALSE);
    return (0);
}


LRESULT CIEMsgAb::NotifyItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    ULONG       uChanged;
    NMLISTVIEW *pnmlv = (NMLISTVIEW *) pnmh;

    if (pnmlv->uChanged & LVIF_STATE)
    {
        uChanged = pnmlv->uNewState ^ pnmlv->uOldState;
        if (uChanged & LVIS_SELECTED)
            _EnableCommands();
    }

    return (0);
}

// Sort compare
int CALLBACK BA_Sort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    LPMABENTRY pEntry1 = (LPMABENTRY) lParam1;
    LPMABENTRY pEntry2 = (LPMABENTRY) lParam2;

    WCHAR pchName1[MAXNAME];
    WCHAR pchName2[MAXNAME];

    int nIndex1 = 0;
    int nIndex2 = 0 ;

    if(!(pEntry1->lpMsgrInfo))
    {
        nIndex1 = sizeof(BA_SortOrder)/sizeof(int);
        if(pEntry1->tag == LPARAM_ABGRPENTRY)
            nIndex1++;
    }
    else
    {
        while((pEntry1->lpMsgrInfo) && (BA_SortOrder[nIndex1] != pEntry1->lpMsgrInfo->nStatus) && (BA_SortOrder[nIndex1] != BIMSTATE_UNKNOWN))
            nIndex1++;
    }

    if(!(pEntry2->lpMsgrInfo))
    {
        nIndex2 = sizeof(BA_SortOrder)/sizeof(int);
        if(pEntry2->tag == LPARAM_ABGRPENTRY)
            nIndex2++;
    }
    else
    {
        while((BA_SortOrder[nIndex2] != pEntry2->lpMsgrInfo->nStatus) && (BA_SortOrder[nIndex2] != BIMSTATE_UNKNOWN))
            nIndex2++;
    }

    if(pEntry1->tag == LPARAM_MENTRY)              // if no AB entry
        StrCpyNW(pchName1, pEntry1->lpMsgrInfo->pchMsgrName, ARRAYSIZE(pchName1));
    else
        StrCpyNW(pchName1, pEntry1->pchWABName, ARRAYSIZE(pchName1));
        // st_pAddrBook->GetDisplayName(pEntry1->lpSB, pchName1);
    pchName1[ARRAYSIZE(pchName1) - 1] = L'\0';

    if(pEntry2->tag == LPARAM_MENTRY)              // if no AB entry
        StrCpyNW(pchName2, pEntry2->lpMsgrInfo->pchMsgrName, ARRAYSIZE(pchName2));
    else
        StrCpyNW(pchName2, pEntry2->pchWABName, ARRAYSIZE(pchName2));
        // st_pAddrBook->GetDisplayName(pEntry2->lpSB, pchName2);
    pchName2[ARRAYSIZE(pchName2) - 1] = L'\0';

    switch(lParamSort)
    {
        case BASORT_NAME_ACSEND:
            return(lstrcmpiW(pchName1, pchName2));

        case BASORT_NAME_DESCEND:
            return(lstrcmpiW(pchName2, pchName1));

        default:
            if((pEntry1->lpMsgrInfo) && (pEntry2->lpMsgrInfo) && (pEntry1->lpMsgrInfo->nStatus == pEntry2->lpMsgrInfo->nStatus))
            {
                if(lParamSort == BASORT_STATUS_ACSEND)
                    return(lstrcmpiW(pchName1, pchName2));
                else
                    return(lstrcmpiW(pchName2, pchName1));
            }
            else
            {
                if(lParamSort == BASORT_STATUS_ACSEND)
                    return(nIndex1 - nIndex2);
                else
                    return(nIndex2 - nIndex1);
            }
    }

    Assert(FALSE);
    return(0);
}

void CIEMsgAb::_EnableCommands(void)
{
#ifdef LATER
    if(g_pBrowser)
        g_pBrowser->UpdateToolbar();
#endif
}

LRESULT CIEMsgAb::NotifyItemActivate(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    return (SendMessage(WM_COMMAND, ID_SEND_INSTANT_MESSAGE2, 0));
}


// GETDISPLAYINFO notification message
LRESULT CIEMsgAb::NotifyGetDisplayInfo(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LV_DISPINFOW * plvdi = (LV_DISPINFOW *)pnmh;
    LRESULT hr;

    if(plvdi->item.lParam)
    {
        LPMABENTRY pEntry = (LPMABENTRY) plvdi->item.lParam;
        LPMABENTRY pFindEntry = NULL;

        if (plvdi->item.mask &  LVIF_IMAGE)
        {
            if((hr = SetUserIcon(pEntry, (pEntry->lpMsgrInfo ? pEntry->lpMsgrInfo->nStatus : BIMSTATE_OFFLINE), &(plvdi->item.iImage) ) ) != S_OK)
                return(hr);
        }

        if (plvdi->item.mask &  LVIF_TEXT)
        {

            if(pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
            {
                // if((hr = m_cAddrBook.GetDisplayName(pEntry->lpSB, plvdi->item.pszText)) != S_OK)
                //    return(hr);
                Assert(pEntry->pchWABName);
                StrCpyNW(plvdi->item.pszText, pEntry->pchWABName, plvdi->item.cchTextMax - 1);
                plvdi->item.pszText[plvdi->item.cchTextMax - 1] = L'\0';
            }
            else if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_MENTRY)
            {
#ifdef LATER
                if(pEntry->tag == LPARAM_MENTRY && (pEntry->lpMsgrInfo->nStatus == BIMSTATE_ONLINE) &&
                        lstrcmpiW(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID) && m_fWAB)
                {
                    StrCpyN(plvdi->item.pszText, pEntry->lpMsgrInfo->pchMsgrName, plvdi->item.cchTextMax - 1);
                    plvdi->item.pszText[plvdi->item.cchTextMax - 1] = L'\0';

                    // Don't need redraw now, do it later
                    hr = MAPI_E_COLLISION; // m_cAddrBook.AutoAddContact(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID);
                    if(hr == MAPI_E_COLLISION)      // already have a contact in AB
                    {
                        int Index = -1;
                        WCHAR *pchID = NULL;

                        ULONG cchSize = lstrlenW(pEntry->lpMsgrInfo->pchID) + 1;
                        if(MemAlloc((LPVOID *) &pchID, cchSize * sizeof(WCHAR)))
                        {
                            StrCpyN(pchID, pEntry->lpMsgrInfo->pchID, cchSize);
                            do
                            {
                                pFindEntry = FindUserEmail(pchID, &Index, FALSE);
                            }while((pFindEntry != NULL) && (pFindEntry->tag == LPARAM_MENTRY));

                            if(pFindEntry != NULL)
                            {
                                hr = m_cAddrBook.SetDefaultMsgrID(pFindEntry->lpSB, pchID);
                                if(hr == S_OK)
                                    _ReloadListview();
                            }
                            MemFree(pchID);
                        }
                    }
                    //if we not found...
                    if(hr != S_OK)
                    {
                        hr = m_cAddrBook.AutoAddContact(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID);
                        if(hr == S_OK)
                            _ReloadListview();
                    }

                }
                else
                {
#endif //LATER
                    StrCpyNW(plvdi->item.pszText, pEntry->lpMsgrInfo->pchMsgrName, plvdi->item.cchTextMax - 1);
                    plvdi->item.pszText[plvdi->item.cchTextMax - 1] = L'\0';
                    // plvdi->item.pszText = pEntry->lpMsgrInfo->pchMsgrName;
//                }
            }
            else    // Unknown tag
                Assert(FALSE);
        }
    }
    return S_OK;
}


LRESULT CIEMsgAb::NotifyGetInfoTip(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NMLVGETINFOTIPW *plvgit = (NMLVGETINFOTIPW *) pnmh;

    LVITEM lvi;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = plvgit->iItem;
    lvi.iSubItem = plvgit->iSubItem;

    ListView_GetItem(m_ctlList, &lvi);

    LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;

    if (pEntry->lpMsgrInfo != NULL)
    {
        StrCpyNW(plvgit->pszText, pEntry->lpMsgrInfo->pchMsgrName, plvgit->cchTextMax);
        StrCatBuffW(plvgit->pszText, m_szLeftBr, plvgit->cchTextMax);
        StrCatBuffW(plvgit->pszText, pEntry->lpMsgrInfo->pchID, plvgit->cchTextMax);
        StrCatBuffW(plvgit->pszText, m_szRightBr, plvgit->cchTextMax);

        LPCWSTR szStatus;

        switch(pEntry->lpMsgrInfo->nStatus)
        {
        case BIMSTATE_ONLINE:
            szStatus = m_szOnline;
            break;
        case BIMSTATE_BUSY:
            szStatus = m_szBusy;
            break;
        case BIMSTATE_BE_RIGHT_BACK:
            szStatus = m_szBack;
            break;
        case BIMSTATE_IDLE:
            szStatus = m_szIdle;
            break;
        case BIMSTATE_AWAY:
            szStatus = m_szAway;
            break;
        case BIMSTATE_ON_THE_PHONE:
            szStatus = m_szOnPhone;
            break;
        case BIMSTATE_OUT_TO_LUNCH:
            szStatus = m_szLunch;
            break;

        default:
            szStatus = m_szOffline;
            break;
        }

        StrCatBuffW(plvgit->pszText, szStatus, plvgit->cchTextMax);
    }

    else if (plvgit->dwFlags & LVGIT_UNFOLDED)
    {
        // If this is not a messenger item and the text
        // isn't truncated do not display a tooltip.

        plvgit->pszText[0] = L'\0';
    }

    return 0;
}


LRESULT CIEMsgAb::SetUserIcon(LPMABENTRY pEntry, int nStatus, int * pImage)
{
    switch(pEntry->tag)
    {
    case LPARAM_MENTRY:
    case LPARAM_MABENTRY:
        {
            switch(nStatus)
            {
            case BIMSTATE_ONLINE:
                *pImage = IMAGE_ONLINE;
                break;

            case BIMSTATE_INVISIBLE:
                *pImage = IMAGE_STOPSIGN;
                break;

            case BIMSTATE_BUSY:
                *pImage = IMAGE_STOPSIGN;
                break;

            case BIMSTATE_BE_RIGHT_BACK:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_BE_RIGHT_BACK;
                break;

            case BIMSTATE_IDLE:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_IDLE;
                break;

            case BIMSTATE_AWAY:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_AWAY;
                break;

            case BIMSTATE_ON_THE_PHONE:
                *pImage = IMAGE_STOPSIGN; // IMAGE_ON_THE_PHONE;
                break;

            case BIMSTATE_OUT_TO_LUNCH:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_OUT_TO_LUNCH;
                break;

            default:
                *pImage = IMAGE_OFFLINE;
                break;

            }
        }
        break;

    case LPARAM_ABGRPENTRY:
        // WAB group
        *pImage = IMAGE_DISTRIBUTION_LIST;
        break;

    default:
        // Not a buddy...
        if(pEntry->fCertificate)
            *pImage = IMAGE_CERT;
        else
            *pImage = IMAGE_NEW_MESSAGE;
        break;
    }
    return(S_OK);

}

// Return MAB entry for first selected item
LPMABENTRY CIEMsgAb::GetSelectedEntry()
{
    LVITEM lvi;

    // Get the focused item
    lvi.iItem = ListView_GetNextItem(m_ctlList, -1, LVNI_SELECTED | LVNI_FOCUSED);

    // Get the lParam for that item
    if (lvi.iItem != -1)
    {
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM;

        if(ListView_GetItem(m_ctlList, &lvi))
            return((LPMABENTRY) lvi.lParam);
    }
    return(NULL);   // unscucces
}


/*
LRESULT CIEMsgAb::CmdMsgrOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return(m_pCMsgrList->LaunchOptionsUI()); // (MOPTDLG_GENERAL_PAGE);

}
*/

// Check entry for possibility to send Instant message
LPMABENTRY CIEMsgAb::GetEntryForSendInstMsg(LPMABENTRY pEntry)
{
    if(!IsMessengerInstalled())
        return(NULL);

    if(ListView_GetSelectedCount(m_ctlList) == 1)
    {
        if(!pEntry)     // if we don'y have pEntry yet then get it
            pEntry = GetSelectedEntry();

        if(pEntry && (pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_MENTRY) &&
                    (pEntry->lpMsgrInfo->nStatus != BIMSTATE_OFFLINE) && (pEntry->lpMsgrInfo->nStatus != BIMSTATE_INVISIBLE) &&
                    !(m_pCMsgrList->IsLocalName(pEntry->lpMsgrInfo->pchID)))
            return(pEntry);
    }

#ifdef NEED
    if(m_pCMsgrList)
    {
        if(m_pCMsgrList->IsLocalOnline() && (m_pCMsgrList->GetCount() > 0))
            return(NULL);   // should be /*return((LPMABENTRY) -1);*/ - temporary disabled (YST)
    }
#endif

    return(NULL);
}

// Display right-mouse click (context) menu
LRESULT CIEMsgAb::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPMABENTRY pEntry;
    HMENU       hPopup = 0;
    HWND        hwndHeader;
    int         id = 0;
    POINT       pt = { (int)(short) LOWORD(lParam), (int)(short) HIWORD(lParam) };
    int n = -1;
    // Figure out if this came from the keyboard or not
    if (lParam == -1)
    {
        Assert((HWND) wParam == m_ctlList);
        int i = ListView_GetFirstSel(m_ctlList);
        if (i == -1)
            return (0);

        ListView_GetItemPosition(m_ctlList, i, &pt);
        m_ctlList.ClientToScreen(&pt);
    }

    LVHITTESTINFO lvhti;
    lvhti.pt = pt;
    m_ctlList.ScreenToClient(&lvhti.pt);
    ListView_HitTest(m_ctlList, &lvhti);

    if (lvhti.iItem == -1)
        return (0);

    // Load the context menu
    hPopup = LoadPopupMenu(IDR_BA_POPUP);
    if (!hPopup)
        goto exit;

    pEntry = GetSelectedEntry();
    pEntry = GetEntryForSendInstMsg(pEntry);

    if(pEntry)
        SetMenuDefaultItem(hPopup, ID_SEND_INSTANT_MESSAGE, FALSE);
    else
        SetMenuDefaultItem(hPopup, ID_SEND_MESSAGE, FALSE);

    if (!m_pCMsgrList)
    {
        DeleteMenu(hPopup, ID_SEND_INSTANT_MESSAGE, MF_BYCOMMAND);
        DeleteMenu(hPopup, ID_SET_ONLINE_CONTACT, MF_BYCOMMAND);
        DeleteMenu(hPopup, ID_NEW_ONLINE_CONTACT, MF_BYCOMMAND);
    }

    MenuUtil_EnablePopupMenu(hPopup, this);

    TrackPopupMenuEx(hPopup, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                     pt.x, pt.y, m_hWnd, NULL);

exit:
    if (hPopup)
        DestroyMenu(hPopup);

    return (0);
}

//
//  FUNCTION:   CIEMsgAb::DragEnter()
//
//  PURPOSE:    This get's called when the user starts dragging an object
//              over our target area.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
STDMETHODIMP CIEMsgAb::DragEnter(IDataObject* pDataObject, DWORD grfKeyState,
                                     POINTL pt, DWORD* pdwEffect)
{
    IEnumFORMATETC *pEnum;
    FORMATETC       fe;
    ULONG           celtFetched;

    // Verify we got this
    if (!pDataObject)
        return (S_OK);

    // Init
    ZeroMemory(&fe, sizeof(FORMATETC));

    // Set the default return value to be failure
    *pdwEffect = DROPEFFECT_NONE;

    // Get the FORMATETC enumerator for this data object
    if (SUCCEEDED(pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum)))
    {
        // Walk through the data types to see if we can find the ones we're
        // interested in.
        pEnum->Reset();

        while (S_OK == pEnum->Next(1, &fe, &celtFetched))
        {
            Assert(celtFetched == 1);

#ifdef LATER
            // The only format we care about is CF_INETMSG
            if ((fe.cfFormat == CF_INETMSG) /*|| (fe.cfFormat == CF_OEMESSAGES)*/)
            {
                *pdwEffect = DROPEFFECT_COPY;
                break;
            }
#endif
        }

        pEnum->Release();
    }

    // We we're going to allow the drop, then keep a copy of the data object
    if (*pdwEffect != DROPEFFECT_NONE)
    {
        m_pDataObject = pDataObject;
        m_pDataObject->AddRef();
        m_cf = fe.cfFormat;
        m_fRight = (grfKeyState & MK_RBUTTON);
    }

    return (S_OK);
}


//
//  FUNCTION:   CIEMsgAb::DragOver()
//
//  PURPOSE:    This is called as the user drags an object over our target.
//              If we allow this object to be dropped on us, then we will have
//              a pointer in m_pDataObject.
//
//  PARAMETERS:
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
STDMETHODIMP CIEMsgAb::DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    // If we didn't cache a data object in IDropTarget::DragEnter(), we
    // blow this off.
    if (NULL == m_pDataObject)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return (S_OK);
    }

    // We always do a copy
    *pdwEffect = DROPEFFECT_COPY;
    return (S_OK);
}

//
//  FUNCTION:   CIEMsgAb::DragLeave()
//
//  PURPOSE:    Allows us to release any stored data we have from a successful
//              DragEnter()
//
//  RETURN VALUE:
//      S_OK - Everything is groovy
//
STDMETHODIMP CIEMsgAb::DragLeave(void)
{
    // Free everything up at this point.
    if (NULL != m_pDataObject)
    {
        m_pDataObject->Release();
        m_pDataObject = 0;
        m_cf = 0;
    }

    return (S_OK);
}


//
//  FUNCTION:   CIEMsgAb::Drop()
//
//  PURPOSE:    The user has let go of the object over our target.  If we
//              can accept this object we will already have the pDataObject
//              stored in m_pDataObject.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - Everything worked OK
//
STDMETHODIMP CIEMsgAb::Drop(IDataObject* pDataObject, DWORD grfKeyState,
                                POINTL pt, DWORD* pdwEffect)
{
    HRESULT             hr = S_OK;
#ifdef LATER
    FORMATETC           fe;
    STGMEDIUM           stm;
    IMimeMessage        *pMessage = 0;

    // Get the stream from the DataObject
    ZeroMemory(&stm, sizeof(STGMEDIUM));
    SETDefFormatEtc(fe, CF_INETMSG, TYMED_ISTREAM);

    if (FAILED(hr = pDataObject->GetData(&fe, &stm)))
        goto exit;

    // Create a new message object
    if (FAILED(hr = HrCreateMessage(&pMessage)))
        goto exit;

    // Load the message from the stream
    if (FAILED(hr = pMessage->Load(stm.pstm)))
        goto exit;

    // If this was a right-drag, then we bring up a context menu etc.
    if (m_fRight)
        _DoDropMenu(pt, pMessage);
    else
        _DoDropMessage(pMessage);

exit:
    ReleaseStgMedium(&stm);
    SafeRelease(pMessage);

    m_pDataObject->Release();
    m_pDataObject = 0;
    m_cf = 0;
#endif
    return (hr);
}

HRESULT CIEMsgAb::_DoDropMessage(LPMIMEMESSAGE pMessage)
{
    HRESULT     hr;
#ifdef LATER
    ADDRESSLIST addrList = { 0 };
    ULONG       i;
    SECSTATE    secState = {0};
    BOOL        fSignTrusted = FALSE;

    if(FAILED(hr = HandleSecurity(m_hWnd, pMessage)))
        return hr;

    if (IsSecure(pMessage) && SUCCEEDED(HrGetSecurityState(pMessage, &secState, NULL)))
    {
        fSignTrusted = !!IsSignTrusted(&secState);
        CleanupSECSTATE(&secState);
    }

    // Get the address list from the message
    hr = pMessage->GetAddressTypes(IAT_FROM | IAT_SENDER, IAP_FRIENDLYW | IAP_EMAIL | IAP_ADRTYPE, &addrList);
    if (FAILED(hr))
        goto exit;

    // Loop through the addresses
    for (i = 0; i < addrList.cAdrs; i++)
    {
		if(!m_cAddrBook.fIsWabLoaded())
		{
			if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
				return(hr);
		}
        m_cAddrBook.AddAddress(addrList.prgAdr[i].pszFriendlyW, addrList.prgAdr[i].pszEmail);
#ifdef DEAD
        TCHAR *pch = StrStr(CharUpper(addrList.prgAdr[i].pszEmail), szHotMail);
        if((pch != NULL) && m_pCMsgrList)
            m_pCMsgrList->AddUser(addrList.prgAdr[i].pszEmail);
#endif // DEAD
    }

    if(fSignTrusted)
    {
        FILETIME ftNull = {0};
        HrAddSenderCertToWab(NULL, pMessage, NULL, NULL, NULL, ftNull, WFF_CREATE);
    }

#ifdef NEEDED
    // Reload the table
    _ReloadListview();
#endif

exit:
#endif
    return (S_OK);

}

HRESULT CIEMsgAb::_DoDropMenu(POINTL pt, LPMIMEMESSAGE pMessage)
{
    HRESULT     hr = S_OK;
#ifdef LATER
    ADDRESSLIST addrList = { 0 };
    ULONG       i;
    HMENU       hPopup = 0, hSubMenu = 0;
    UINT        id = 0;
    BOOL        fReload = FALSE;
    SECSTATE    secState = {0};
    BOOL        fSignTrusted = FALSE;

    // Get the address list from the message
    if(FAILED(hr = HandleSecurity(m_hWnd, pMessage)))
        return hr;

    if (IsSecure(pMessage) && SUCCEEDED(HrGetSecurityState(pMessage, &secState, NULL)))
    {
        fSignTrusted = !!IsSignTrusted(&secState);
        CleanupSECSTATE(&secState);
    }

    hr = pMessage->GetAddressTypes(IAT_KNOWN, IAP_FRIENDLYW | IAP_EMAIL | IAP_ADRTYPE, &addrList);
    if (FAILED(hr))
        goto exit;

    // Load the context menu
    hPopup = LoadPopupMenu(IDR_BA_DRAGDROP_POPUP);
    if (!hPopup)
        goto exit;

    // Bold the "Save All" item
    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STATE;
    if (GetMenuItemInfo(hPopup, ID_SAVE_ALL, FALSE, &mii))
    {
        mii.fState |= MFS_DEFAULT;
        SetMenuItemInfo(hPopup, ID_SAVE_ALL, FALSE, &mii);
    }

    // Create the "Save >" item
    hSubMenu = CreatePopupMenu();

    // Loop through the addresses
    for (i = 0; i < addrList.cAdrs; i++)
    {
        AppendMenuWrapW(hSubMenu, MF_STRING | MF_ENABLED, ID_SAVE_ADDRESS_FIRST + i, addrList.prgAdr[i].pszFriendlyW);
    }

    mii.fMask = MIIM_SUBMENU;
    mii.hSubMenu = hSubMenu;
    SetMenuItemInfo(hPopup, ID_SAVE, FALSE, &mii);

    id = TrackPopupMenuEx(hPopup, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                          pt.x, pt.y, m_hWnd, NULL);

    if (id == ID_SAVE_ALL_ADDRESSES)
    {
        for (i = 0; i < addrList.cAdrs; i++)
        {
            m_cAddrBook.AddAddress(addrList.prgAdr[i].pszFriendlyW, addrList.prgAdr[i].pszEmail);
        }
        fReload = TRUE;
    }
    else if (id >= ID_SAVE_ADDRESS_FIRST && id < ID_SAVE_ADDRESS_LAST)
    {
        m_cAddrBook.AddAddress(addrList.prgAdr[id - ID_SAVE_ADDRESS_FIRST].pszFriendlyW,
                               addrList.prgAdr[id - ID_SAVE_ADDRESS_FIRST].pszEmail);
        fReload = TRUE;
    }

    if(fSignTrusted)
    {
        FILETIME ftNull = {0};
        HrAddSenderCertToWab(NULL, pMessage, NULL, NULL, NULL, ftNull, WFF_CREATE);
    }


    if (fReload)
    {
        // Reload the table
        _ReloadListview();
    }

exit:
    if (hSubMenu)
        DestroyMenu(hSubMenu);

    if (hPopup)
        DestroyMenu(hPopup);
#endif
    return (S_OK);
}

LRESULT CIEMsgAb::CmdDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    LVITEM lvi;
    ENTRYLIST rList;
    ULONG cValues;
    SBinary UNALIGNED *pEntryId;
    BOOL fConfirm = TRUE;
    TCHAR szText[CCHMAX_STRINGRES + MAXNAME];
    WCHAR wszBuff[CCHMAX_STRINGRES];

    if(m_delItem > 0)
    {
        MessageBeep(MB_OK);
        return(S_OK);
    }

    if(m_fNoRemove)
        m_fNoRemove = FALSE;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = -1;

    // Figure out how many items are selected
    cValues = ListView_GetSelectedCount(m_ctlList);
    m_delItem = cValues;
    if (cValues != 1)
    {
        // Remove only Msgr entry
#ifdef LATER
        AthLoadString(idsBADelMultiple, wszBuff, ARRAYSIZE(wszBuff));
        wnsprintf(szText, ARRAYSIZE(szText), wszBuff, cValues);

        if(IDNO == AthMessageBoxW(NULL, MAKEINTRESOURCE(idsAthena), MAKEINTRESOURCE(idsAthena),
                NULL, MB_YESNO | MB_ICONEXCLAMATION))
        {
            return (0);
        }
        else
#endif // LATER
            if(m_fNoRemove)
        {
            MessageBeep(MB_OK);
            return(S_OK);
        }
        else
            fConfirm = FALSE;

        //        Assert(FALSE);
        //        return (0);
    }
    while(cValues > 0)
    {
        lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVNI_SELECTED);

        if(lvi.iItem < 0)
        {
ErrBeep:
            MessageBeep(MB_OK);
            return(S_OK);
        }
        // Get the item from the ListView
        if(ListView_GetItem(m_ctlList, &lvi) == FALSE)
            goto ErrBeep;

        // Check buddy state
        LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;
        if(pEntry->tag == LPARAM_MENTRY)
        {
            if(m_pCMsgrList && m_pCMsgrList->IsLocalOnline())
            {
                // Remove only Msgr entry
                if(fConfirm)
                {
#ifdef LATER
                    AthLoadString(idsBADelBLEntry, wszBuff, ARRAYSIZE(wszBuff));
                    wnsprintf(szText, ARRAYSIZE(szTExt), wszBuff,  pEntry->lpMsgrInfo->pchMsgrName);


                    if(IDNO == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                        NULL, MB_YESNO | MB_ICONEXCLAMATION))
                    {
                        m_delItem = 0;
                        return (0);
                    }
                    else if(m_fNoRemove)
                        goto ErrBeep;
#endif // LATER

                }
                if(pEntry->lpMsgrInfo)
                {
                    m_delItem--;
                    hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
                }
                else
                {
                    m_delItem = 0;
                    return(S_OK);
                }
            }
            else
                goto ErrBeep;
        }
        else if(pEntry->tag == LPARAM_MABENTRY)
        {
            int nID = IDNO;
            if(fConfirm)
            {

#ifdef LATER
                AthLoadString(idsBADelBLABEntry, wszBuff, ARRAYSIZE(wszBuff));
                wnsprintf(szText, ARRAYSIZE(szText), wszBuff, pEntry->pchWABName);

                nID = AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                    NULL, MB_YESNOCANCEL | MB_ICONEXCLAMATION);
#endif // LATER
            }
            if(((nID == IDYES) || !fConfirm) && !m_fNoRemove)
            {
                if(m_pCMsgrList && m_pCMsgrList->IsLocalOnline())
                {
                    // Remove only Msgr & AB entry
                    if(pEntry->lpMsgrInfo)
                        hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
                    else
                    {
                        m_delItem = 0;
                        return(S_OK);
                    }

                    // Allocate a structure big enough for all of 'em
                    if (MemAlloc((LPVOID *) &(rList.lpbin), sizeof(SBinary)))
                    {
                        rList.cValues = 0;
                        pEntryId = rList.lpbin;

                        *pEntryId = *(pEntry->lpSB);
                        pEntryId++;
                        rList.cValues = 1;
                        // Tell the WAB to delete 'em
                        m_nChCount++;    // increase count of our notification messages from WAB

						if(!m_cAddrBook.fIsWabLoaded())
						{
							if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
								return(hr);
						}

                        m_cAddrBook.DeleteItems(&rList);

                        // Free our array
                        MemFree(rList.lpbin);

                    }
                    // m_delItem++;
                    ListView_DeleteItem(m_ctlList, lvi.iItem);
                    lvi.iItem--;
                    ListView_SetItemState(m_ctlList, ((lvi.iItem >= 0) ? lvi.iItem : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                }
                else
                    MessageBeep(MB_OK);
            }
            else if((nID == IDNO) && !m_fNoRemove)
            {
                // Remove only Msgr entry
                m_delItem--;
                hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
            }
            else
            {
                // Remove nothing
                m_delItem--;
                hr = S_OK;
            }

        }
        else
        {
            // remove AN entry (group or contact)
            if(fConfirm)
            {
#ifdef LATER
                AthLoadString(idsBADelABEntry, wszBuff, ARRAYSIZE(wszBuff));
                wnsprintf(szText, ARRAYSIZE(szText), wszBuff, pEntry->pchWABName);

                if(IDNO == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                    NULL, MB_YESNO | MB_ICONEXCLAMATION))
                {
                    m_delItem = 0;
                    return(0);
                }
                else if(m_fNoRemove)
                    goto ErrBeep;
#endif // LATER

            }
            // Allocate a structure big enough for all of 'em
            if(pEntry->lpSB)
            {
                if (MemAlloc((LPVOID *) &(rList.lpbin), sizeof(SBinary)))
                {
                    rList.cValues = 0;
                    pEntryId = rList.lpbin;

                    *pEntryId = *(pEntry->lpSB);
                    pEntryId++;
                    rList.cValues = 1;
                    // Tell the WAB to delete 'em
                    m_nChCount++;    // increase count of our notification messages from WAB

					if(!m_cAddrBook.fIsWabLoaded())
					{
						if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
							return(hr);
					}

                    m_cAddrBook.DeleteItems(&rList);

                    // Free our array
                    MemFree(rList.lpbin);
                }
            }
            // m_delItem++;
            ListView_DeleteItem(m_ctlList, lvi.iItem);
            lvi.iItem--;
        }
        cValues--;
    }

    if(ListView_GetItemCount(m_ctlList) > 0)
    {
        m_cEmptyList.Hide();
        ListView_SetItemState(m_ctlList, ((lvi.iItem >= 0) ? lvi.iItem : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    }
    else
        m_cEmptyList.Show(m_ctlList, (LPWSTR) (m_fShowAllContacts ? m_szEmptyList : m_szMsgrEmptyList));

    _ReloadListview();
    return (hr);
}

STDMETHODIMP CIEMsgAb::get_InstMsg(BOOL * pVal)
{
    *pVal = (GetEntryForSendInstMsg() != NULL);
    return S_OK;
}

/* STDMETHODIMP CIEMsgAb::put_InstMsg(BOOL newVal)
{
    return S_OK;
}  */

STDMETHODIMP CIEMsgAb::HasFocusIO()
{
    if (GetFocus() == m_ctlList)
        return S_OK;
    else
        return S_FALSE;
}

STDMETHODIMP CIEMsgAb::TranslateAcceleratorIO(LPMSG pMsg)
{
    if(!pMsg)
        goto SNDMsg;

#ifdef NEED
    if ((pMsg->message == WM_SYSKEYDOWN) && (pMsg->wParam == ((int) 'D')))
        return(S_FALSE);
#endif

    if (pMsg->message != WM_KEYDOWN)
        goto SNDMsg;

    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        goto SNDMsg;

    m_ctlList.SendMessage(WM_KILLFOCUS, (WPARAM) NULL, (LPARAM) 0);
    return S_OK;

SNDMsg:
    ::TranslateMessage(pMsg);
    ::DispatchMessage(pMsg);

    // m_ctlList.SendMessage(pMsg->message, pMsg->wParam, pMsg->lParam);

    return (S_OK);
}

STDMETHODIMP CIEMsgAb::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    if (!m_pObjSite)
        return E_FAIL;
    if (!IsWindow(m_hWnd))
    {
        IOleWindow  *pOleWnd;

        if (SUCCEEDED(m_pObjSite->QueryInterface(IID_IOleWindow, (LPVOID*)&pOleWnd)))
        {
            if(SUCCEEDED(pOleWnd->GetWindow(&m_hwndParent)))
            {
            //Will be resized by parent
            RECT    rect = {0};

            m_hWnd = CreateControlWindow(m_hwndParent, rect);
            if (!m_hWnd)
                return E_FAIL;
            }
        }
        pOleWnd->Release();
    }

    if (fActivate)
    {
        m_ctlList.SetFocus();
    }

    m_pObjSite->OnFocusChangeIS((IInputObject*) this, fActivate);
    return (S_OK);
}

STDMETHODIMP CIEMsgAb::SetSite(IUnknown  *punksite)
{
    //If we already have a site, we release it
    SafeRelease(m_pObjSite);

    IInputObjectSite    *pObjSite;
    if ((punksite) && (SUCCEEDED(punksite->QueryInterface(IID_IInputObjectSite, (LPVOID*)&pObjSite))))
    {
        m_pObjSite = pObjSite;

//         IOleWindow* pOleWindow;
//        if(SUCCEEDED(punksite->QueryInterface(IID_IOleWindowe, (LPVOID*)&pOleWindow))))
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CIEMsgAb::GetSite(REFIID  riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

HRESULT CIEMsgAb::RegisterFlyOut(CFolderBar *pFolderBar)
{
#ifdef LATER
    Assert(m_pFolderBar == NULL);
    m_pFolderBar = pFolderBar;
    m_pFolderBar->AddRef();
#endif
    return S_OK;
}

HRESULT CIEMsgAb::RevokeFlyOut(void)
{
#ifdef LATER
    if (m_pFolderBar)
    {
        m_pFolderBar->Release();
        m_pFolderBar = NULL;
    }
#endif
    return S_OK;
}

void CIEMsgAb::_ReloadListview(void)
{
    // Kill timer first
//    KillTimer(IDT_PANETIMER);

    // Turn off redrawing
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);
    SetWindowRedraw(m_ctlList, FALSE);
    int index = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);
    if(index == -1)
        index = 0;

    // Delete everything and reload
    SideAssert(ListView_DeleteAllItems(m_ctlList));
    if(m_pCMsgrList && m_pCMsgrList->IsLocalOnline())
    {
        m_fLogged = TRUE;
        FillMsgrList(); // User list reload
    }

    if(m_fShowAllContacts)
    {
		if(!m_cAddrBook.fIsWabLoaded())
		{
            if(FAILED(m_cAddrBook.OpenWabFile(m_fWAB)))
				return;
		}
        m_cAddrBook.LoadWabContents(m_ctlList, this);
    }

    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    ListView_SetItemState(m_ctlList, index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    ListView_EnsureVisible(m_ctlList, index, FALSE);
    SetWindowRedraw(m_ctlList, TRUE);
//    Invalidate(TRUE); //

   if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPWSTR) (m_fShowAllContacts ? m_szEmptyList : m_szMsgrEmptyList));

    UpdateWindow(/*m_ctlList*/);

//    SetTimer(IDT_PANETIMER, ELAPSE_MOUSEOVERCHECK, NULL);
    return;
}

ULONG STDMETHODCALLTYPE CIEMsgAb::OnNotify(ULONG cNotif, LPNOTIFICATION pNotifications)
{
    // Well something changed in WAB, but we don't know what.  We should reload.
    // Sometimes these changes from us and we should ignore it.
    if(m_nChCount > 0)
        m_nChCount--;
    else
        _ReloadListview();
    return (0);
}

LRESULT CIEMsgAb::CmdFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    if(!m_cAddrBook.fIsWabLoaded())
	{
	    if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
		    return(hr);
    }

    m_cAddrBook.Find(m_hWnd);
    return (0);
}

LRESULT CIEMsgAb::CmdNewGroup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    if(!m_cAddrBook.fIsWabLoaded())
	{
	    if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
		    return(hr);
    }
    m_cAddrBook.NewGroup(m_hWnd);
    _ReloadListview();
    return (0);
}

LRESULT CIEMsgAb::CmdIEMsgAb(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    if(!m_cAddrBook.fIsWabLoaded())
	{
	    if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
		    return(hr);
    }
    m_cAddrBook.AddressBook(m_hWnd);
    return (0);
}

void CIEMsgAb::AddMsgrListItem(LPMINFO lpMsgrInfo)
{
    LV_ITEMW lvItem;
    m_cEmptyList.Hide(); // m,ust be sure that empty mesage is hide
    lvItem.iItem = ListView_GetItemCount(m_ctlList);
    lvItem.mask = LVIF_PARAM  | LVIF_IMAGE | LVIF_TEXT;
    lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_MENTRY, NULL, lpMsgrInfo, NULL, NULL, FALSE);
    lvItem.iSubItem = 0;
    lvItem.pszText = LPSTR_TEXTCALLBACKW;
    lvItem.iImage = I_IMAGECALLBACK;
    // SetUserIcon(LPARAM_MENTRY, lpMsgrInfo->nStatus, &(lvItem.iImage));
    ::SendMessage(m_ctlList, LVM_INSERTITEMW, 0, ((LPARAM) &lvItem));

    return;
}

HRESULT CIEMsgAb::FillMsgrList()
{
    LPMINFO pEntry = NULL;

    if(!m_pCMsgrList)
    {
        // Assert(FALSE); // Possible situation. See Bug 31262
        return(S_OK);
    }

    pEntry = m_pCMsgrList->GetFirstMsgrItem();

    while(pEntry)
    {
        // if(m_fShowAllContacts || ((pEntry->nStatus != BIMSTATE_OFFLINE) && (pEntry->nStatus != BIMSTATE_INVISIBLE) &&
        //             !(m_pCMsgrList->IsLocalName(pEntry->pchID) )))
        if(m_fShowAllContacts)
            AddMsgrListItem(pEntry);
        else if((m_fShowOnlineContacts || m_fShowOfflineContacts) && ((pEntry->nStatus != BIMSTATE_OFFLINE) && (pEntry->nStatus != BIMSTATE_INVISIBLE) &&
                     !(m_pCMsgrList->IsLocalName(pEntry->pchID))))
            AddMsgrListItem(pEntry);
        else if(m_fShowOfflineContacts && (((pEntry->nStatus == BIMSTATE_OFFLINE) || (pEntry->nStatus == BIMSTATE_INVISIBLE)) &&
                     !(m_pCMsgrList->IsLocalName(pEntry->pchID))))
            AddMsgrListItem(pEntry);

        pEntry = m_pCMsgrList->GetNextMsgrItem(pEntry);
    }
    return S_OK;
}

// Add BLAB table entry
LPMABENTRY CIEMsgAb::AddBlabEntry(MABENUM tag, LPSBinary lpSB, LPMINFO lpMsgrInfo, WCHAR *pchMail, WCHAR *pchDisplayName, BOOL fCert, LPPNONEENTRIES  lpPhs)
{
    WCHAR szName[MAXNAME];
    LPMABENTRY pEntry = NULL;
    WCHAR *pchName = NULL;
    int nLen = 0;

    if (!MemAlloc((LPVOID *) &pEntry, sizeof(mabEntry)))
        return(NULL);

    pEntry->tag = tag;
    pEntry->lpSB = lpSB;
    pEntry->pchWABName = NULL;
    pEntry->pchWABID = NULL;
    pEntry->fCertificate = fCert;
    pEntry->lpPhones = NULL;

    if(lpSB != NULL)
    {
        if(!pchDisplayName)
        {
            if(!m_cAddrBook.fIsWabLoaded())
	        {
	            if(FAILED(m_cAddrBook.OpenWabFile(m_fWAB)))
		            return(NULL);
            }
            m_cAddrBook.GetDisplayName(pEntry->lpSB, szName, ARRAYSIZE(szName));
            pchName = szName;
        }
        else
            pchName = pchDisplayName;

        if(pchName)
        {
            ULONG cchSize = lstrlenW(pchName) + 1;
            if (!MemAlloc((LPVOID *) &(pEntry->pchWABName), cchSize * sizeof(WCHAR) ))
            {
                MemFree(pEntry);
                return(NULL);
            }
            StrCpyNW(pEntry->pchWABName, pchName, cchSize);
        }

        if(pchMail != NULL)
        {
            ULONG cchSize = lstrlenW(pchMail) + 1;
            if (MemAlloc((LPVOID *) &(pEntry->pchWABID), cchSize * sizeof(WCHAR) ))
                StrCpyNW(pEntry->pchWABID, pchMail, cchSize);
        }
    }

    if(lpMsgrInfo && MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo), sizeof(struct _tag_OEMsgrInfo)))
    {

        pEntry->lpMsgrInfo->nStatus = lpMsgrInfo->nStatus;
        pEntry->lpMsgrInfo->pPrev = NULL;
        pEntry->lpMsgrInfo->pNext = NULL;

        if(lpMsgrInfo->pchMsgrName && MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo->pchMsgrName), (lstrlenW(lpMsgrInfo->pchMsgrName) + 1)*sizeof(WCHAR)))
            StrCpyNW(pEntry->lpMsgrInfo->pchMsgrName, lpMsgrInfo->pchMsgrName, lstrlenW(lpMsgrInfo->pchMsgrName) + 1);
        else
            pEntry->lpMsgrInfo->pchMsgrName = NULL;

        if(lpMsgrInfo->pchID && MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo->pchID), (lstrlenW(lpMsgrInfo->pchID) + 1)*sizeof(WCHAR)))
            StrCpyNW(pEntry->lpMsgrInfo->pchID, lpMsgrInfo->pchID, lstrlenW(lpMsgrInfo->pchID) + 1);
        else
            pEntry->lpMsgrInfo->pchID = NULL;

        if((lpMsgrInfo->pchWorkPhone || lpMsgrInfo->pchHomePhone || lpMsgrInfo->pchMobilePhone) && MemAlloc((LPVOID *) &(pEntry->lpPhones), sizeof(PNONEENTRIES)))
        {

            if(lpMsgrInfo->pchHomePhone && MemAlloc((LPVOID *) &(pEntry->lpPhones->pchHomePhone), (lstrlenW(lpMsgrInfo->pchHomePhone) + 1)*sizeof(WCHAR)))
                StrCpyNW(pEntry->lpPhones->pchHomePhone, lpMsgrInfo->pchHomePhone, lstrlenW(lpMsgrInfo->pchHomePhone) + 1);
            else
                pEntry->lpPhones->pchHomePhone = NULL;

            if(lpMsgrInfo->pchWorkPhone && MemAlloc((LPVOID *) &(pEntry->lpPhones->pchWorkPhone), (lstrlenW(lpMsgrInfo->pchWorkPhone) + 1)*sizeof(WCHAR)))
                StrCpyNW(pEntry->lpPhones->pchWorkPhone, lpMsgrInfo->pchWorkPhone, lstrlenW(lpMsgrInfo->pchWorkPhone) + 1);
            else
                pEntry->lpPhones->pchWorkPhone = NULL;

            if(lpMsgrInfo->pchMobilePhone && MemAlloc((LPVOID *) &(pEntry->lpPhones->pchMobilePhone), (lstrlenW(lpMsgrInfo->pchMobilePhone) + 1)*sizeof(WCHAR)))
                StrCpyNW(pEntry->lpPhones->pchMobilePhone, lpMsgrInfo->pchMobilePhone, lstrlenW(lpMsgrInfo->pchMobilePhone) + 1);
            else
                pEntry->lpPhones->pchMobilePhone = NULL;

            pEntry->lpPhones->pchIPPhone = NULL;

            return(pEntry);
        }

    }
    else
        pEntry->lpMsgrInfo = NULL;

    // Add information about pfones
    if(lpPhs && MemAlloc((LPVOID *) &(pEntry->lpPhones), sizeof(PNONEENTRIES)))
    {
        if(lpPhs->pchHomePhone && (nLen = lstrlenW(lpPhs->pchHomePhone)))
        {
            if(MemAlloc((LPVOID *) &(pEntry->lpPhones->pchHomePhone), (nLen + 1)*sizeof(WCHAR)))
                StrCpyNW(pEntry->lpPhones->pchHomePhone, lpPhs->pchHomePhone, nLen + 1);
            else
                pEntry->lpPhones->pchHomePhone = NULL;
        }
        else
            pEntry->lpPhones->pchHomePhone = NULL;

        if(lpPhs->pchWorkPhone && (nLen = lstrlenW(lpPhs->pchWorkPhone)))
        {
            if(MemAlloc((LPVOID *) &(pEntry->lpPhones->pchWorkPhone), (nLen + 1)*sizeof(WCHAR)))
                StrCpyNW(pEntry->lpPhones->pchWorkPhone, lpPhs->pchWorkPhone, nLen + 1);
            else
                pEntry->lpPhones->pchWorkPhone = NULL;
        }
        else
            pEntry->lpPhones->pchWorkPhone = NULL;

        if(lpPhs->pchMobilePhone && (nLen = lstrlenW(lpPhs->pchMobilePhone)))
        {
            if(MemAlloc((LPVOID *) &(pEntry->lpPhones->pchMobilePhone), (nLen + 1)*sizeof(WCHAR)))
                StrCpyNW(pEntry->lpPhones->pchMobilePhone, lpPhs->pchMobilePhone, nLen + 1);
            else
                pEntry->lpPhones->pchMobilePhone = NULL;
        }
        else
            pEntry->lpPhones->pchMobilePhone = NULL;

        if(lpPhs->pchIPPhone && (nLen = lstrlenW(lpPhs->pchIPPhone)))
        {
            if(MemAlloc((LPVOID *) &(pEntry->lpPhones->pchIPPhone), (nLen + 1)*sizeof(WCHAR)))
                StrCpyNW(pEntry->lpPhones->pchIPPhone, lpPhs->pchIPPhone, nLen + 1);
            else
                pEntry->lpPhones->pchIPPhone = NULL;
        }
        else
            pEntry->lpPhones->pchIPPhone = NULL;
    }

    return(pEntry);
}

void CIEMsgAb::RemoveMsgrInfo(LPMINFO lpMsgrInfo)
{
    SafeMemFree(lpMsgrInfo->pchMsgrName);
    SafeMemFree(lpMsgrInfo->pchID);
    SafeMemFree(lpMsgrInfo);
}

// Remove BLAB table entry
void CIEMsgAb::RemoveBlabEntry(LPMABENTRY lpEntry)
{
    if(lpEntry == NULL)
        return;

    if(lpEntry->pchWABName)
        MemFree(lpEntry->pchWABName);

    if(lpEntry->pchWABID)
        MemFree(lpEntry->pchWABID);

    if(lpEntry->lpPhones)
    {
        if(lpEntry->lpPhones->pchHomePhone)
            MemFree(lpEntry->lpPhones->pchHomePhone);

        if(lpEntry->lpPhones->pchWorkPhone)
            MemFree(lpEntry->lpPhones->pchWorkPhone);

        if(lpEntry->lpPhones->pchMobilePhone)
            MemFree(lpEntry->lpPhones->pchMobilePhone);

        if(lpEntry->lpPhones->pchIPPhone)
            MemFree(lpEntry->lpPhones->pchIPPhone);
        MemFree(lpEntry->lpPhones);
    }

    if(lpEntry->lpMsgrInfo)
    {
        RemoveMsgrInfo(lpEntry->lpMsgrInfo);
        lpEntry->lpMsgrInfo = NULL;
    }

    MemFree(lpEntry);
    lpEntry = NULL;

    return;
}

// This function check buddy and if we have AB entry then set LPARAM_MABENTRY tag
void CIEMsgAb::CheckAndAddAbEntry(LPSBinary lpSB, WCHAR *pchEmail, WCHAR *pchDisplayName, DWORD nFlag, LPPNONEENTRIES pPhEnries)
{
    WCHAR szName[MAXNAME];
    LPMABENTRY pEntry = NULL;

    LV_ITEMW lvItem;

    lvItem.iItem = ListView_GetItemCount(m_ctlList);
    lvItem.mask = LVIF_PARAM  | LVIF_IMAGE | LVIF_TEXT;
    lvItem.iSubItem = 0;
    lvItem.pszText = LPSTR_TEXTCALLBACKW;
    lvItem.iImage = I_IMAGECALLBACK;

    m_cEmptyList.Hide(); // must be sure that empty mesage is hide
    if(!(nFlag & MAB_BUDDY))
    {
        if(m_fShowAllContacts || (m_fShowEmailContacts && pchEmail) || (m_fShowOthersContacts && (pchEmail == NULL)))
        {
            lvItem.lParam = (LPARAM) AddBlabEntry((nFlag & MAB_GROUP) ? LPARAM_ABGRPENTRY : LPARAM_ABENTRY, lpSB, NULL, pchEmail,
                                    pchDisplayName, (nFlag & MAB_CERT), pPhEnries);
        // SetUserIcon(LPARAM_ABGRPENTRY, 0, &(lvItem.iImage));

            ::SendMessage(m_ctlList, LVM_INSERTITEMW, 0, ((LPARAM) &lvItem));
            // ListView_InsertItem(m_ctlList, &lvItem);
        }
        return;
    }

    if(pchEmail)
        pEntry = FindUserEmail(pchEmail, NULL, TRUE);

    if(pEntry)      // buddy found
    {
        // if we already linked this budyy to AN entry, add new list item)
        if(pEntry->tag == LPARAM_MABENTRY)
        {
            lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_MABENTRY, lpSB, pEntry->lpMsgrInfo, pchEmail, pchDisplayName, (nFlag & MAB_CERT), pPhEnries);
            // SetUserIcon(LPARAM_MABENTRY, pEntry->lpMsgrInfo->nStatus, &(lvItem.iImage));
            ListView_InsertItem(m_ctlList, &lvItem);
        }
        else if(pEntry->tag == LPARAM_MENTRY)      // buddy was not linked to AB entry
        {
            pEntry->tag = LPARAM_MABENTRY;
            pEntry->lpSB = lpSB;
            Assert(lpSB);

            if(!m_cAddrBook.fIsWabLoaded())
	        {
	            if(FAILED(m_cAddrBook.OpenWabFile(m_fWAB)))
		            return;
            }

            m_cAddrBook.GetDisplayName(pEntry->lpSB, szName, ARRAYSIZE(szName));
            pEntry->pchWABName = NULL;
            pEntry->pchWABID = NULL;

            ULONG cchSize = lstrlenW(szName) + 1;
            if (MemAlloc((LPVOID *) &(pEntry->pchWABName), cchSize*sizeof(WCHAR) ))
                StrCpyNW(pEntry->pchWABName, szName, cchSize);

            cchSize = lstrlenW(pchEmail) + 1;
            if(MemAlloc((LPVOID *) &(pEntry->pchWABID), cchSize*sizeof(WCHAR) ))
                StrCpyNW(pEntry->pchWABID, pchEmail, cchSize);
        }
        else
            Assert(FALSE);      // something strange
    }
    else        // buddy not found, simple AB entry
    {
        if(m_fShowAllContacts || (m_fShowEmailContacts && pchEmail) || (m_fShowOthersContacts && (pchEmail == NULL)))
        {
            lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_ABENTRY, lpSB, NULL, pchEmail, pchDisplayName, (nFlag & MAB_CERT), pPhEnries);
            // SetUserIcon(LPARAM_ABENTRY, 0, &(lvItem.iImage));
            ListView_InsertItem(m_ctlList, &lvItem);
        }
    }
}

LPMABENTRY CIEMsgAb::FindUserEmail(WCHAR *pchEmail, int *pIndex, BOOL fMsgrOnly)
{
    LPMABENTRY pEntry = NULL;
    LVITEMW             lvi;

    lvi.mask = LVIF_PARAM;
    if(pIndex != NULL)
        lvi.iItem = *pIndex;
    else
        lvi.iItem = -1;
    lvi.iSubItem = 0;

    while((lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVNI_ALL)) != -1)
    {
        ListView_GetItem(m_ctlList, &lvi);
        pEntry = (LPMABENTRY) lvi.lParam;
        if(pEntry)
        {
            if(fMsgrOnly)
            {
                if(pEntry->lpMsgrInfo)
                {
                    if((pEntry->lpMsgrInfo)->pchID)
                    {
                        if(!lstrcmpiW((pEntry->lpMsgrInfo)->pchID, pchEmail))
                        {
                            if(pIndex != NULL)
                                *pIndex = lvi.iItem;
                            return(pEntry);
                        }
                    }
                }
            }
            else
            {
                if(pEntry->pchWABID)
                {
                    if(!lstrcmpiW(pEntry->pchWABID, pchEmail))
                    {
                        if(pIndex != NULL)
                            *pIndex = lvi.iItem;
                        return(pEntry);
                    }
                }
                if(pEntry->lpSB)
                {
                    Assert(m_cAddrBook.fIsWabLoaded());
                    if(m_cAddrBook.CheckEmailAddr(pEntry->lpSB, pchEmail))
                    {
                        if(pIndex != NULL)
                            *pIndex = lvi.iItem;
                        return(pEntry);
                    }
                }

            }
        }
    }

    return(NULL);
}

// messenger want shutown. release messenger object
HRESULT CIEMsgAb::OnMsgrShutDown(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    if(m_pCMsgrList)
    {
        m_pCMsgrList->UnRegisterUIWnd(m_hWnd);
        OE_CloseMsgrList(m_pCMsgrList);
        m_pCMsgrList = NULL;
    }  
    m_dwHideMessenger = 1;
    m_dwDisableMessenger = 1;
    _ReloadListview();
    ::SendMessage(m_hwndParent, WM_MSGR_LOGRESULT, 0, 0);
    return(S_OK);
    
}

// Set new buddy status (online/ofline/etc. and redraw list view entry)
HRESULT CIEMsgAb::OnUserStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
    LPMABENTRY  pEntry = NULL;
    int index = -1;
    BOOL fNeedRefresh = m_fShowOnlineContacts ;

    if(fNeedRefresh)
    {
        m_fShowOfflineContacts = TRUE;
        m_fShowOnlineContacts = FALSE;
        _ReloadListview();
    }

    while((pEntry = FindUserEmail((LPWSTR) lParam, &index, TRUE)) != NULL)
    {
        pEntry->lpMsgrInfo->nStatus = (int) wParam;
        ListView_RedrawItems(m_ctlList, index, index+1);
    }

    if(fNeedRefresh)
    {
        m_fShowOfflineContacts = FALSE;
        m_fShowOnlineContacts = TRUE;
        _ReloadListview();
    }

    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    return(hr);
}

// Message: buddy was removed
HRESULT CIEMsgAb::OnUserRemoved(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
    int index = -1;
    LPMABENTRY  pEntry = NULL;

    while((pEntry = FindUserEmail((LPWSTR) lParam, &index, TRUE)) != NULL)
    {
        // Not removed yet
        if(pEntry->tag == LPARAM_MABENTRY)
        {
            Assert(pEntry->lpMsgrInfo);
            if(pEntry->lpMsgrInfo)
            {
                RemoveMsgrInfo(pEntry->lpMsgrInfo);

                pEntry->lpMsgrInfo = NULL;
            }

            pEntry->tag = LPARAM_ABENTRY;
            ListView_RedrawItems(m_ctlList, index, index+1);
        }
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            int index1 = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);
            m_delItem++;
            ListView_DeleteItem(m_ctlList, index);
            if(index == index1)
            {
                index1--;
                ListView_SetItemState(m_ctlList, ((index1 >= 0) ? index1 : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            }
        }
        else
            index++;
    }

    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPWSTR) (m_fShowAllContacts ? m_szEmptyList : m_szMsgrEmptyList));
    return(hr);
}

// Event User was added => add buddy to our list.
HRESULT CIEMsgAb::OnUserAdded(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    LPMINFO  pEntry =  (LPMINFO) lParam;
    
    if(m_fShowAllContacts)
        AddMsgrListItem(pEntry);
    else if((m_fShowOnlineContacts || m_fShowOfflineContacts) && ((pEntry->nStatus != BIMSTATE_OFFLINE) && (pEntry->nStatus != BIMSTATE_INVISIBLE) &&
        !(m_pCMsgrList->IsLocalName(pEntry->pchID))))
        AddMsgrListItem(pEntry);
    else if(m_fShowOfflineContacts && (((pEntry->nStatus == BIMSTATE_OFFLINE) || (pEntry->nStatus == BIMSTATE_INVISIBLE)) &&
        !(m_pCMsgrList->IsLocalName(pEntry->pchID))))
        AddMsgrListItem(pEntry);
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    
    return(S_OK);
}

HRESULT CIEMsgAb::OnUserNameChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
#ifdef NEEDED
    LPMINFO  pItem =  (LPMINFO) lParam;
    LPMABENTRY  pEntry = NULL;
    int index = -1;

    while((pEntry = FindUserEmail(pItem->pchID, &index, TRUE)) != NULL)
    {
        if((pEntry->tag == LPARAM_MENTRY) && lstrcmpi(pItem->pchID, pItem->pchMsgrName))
        {
            hr = m_cAddrBook.AutoAddContact(pItem->pchMsgrName, pItem->pchID);
            // _ReloadListview();
        }
        ListView_RedrawItems(m_ctlList, index, index+1);
    }
#endif
    _ReloadListview();
    return(hr);
}

HRESULT CIEMsgAb::OnUserLogoffEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
    ::SendMessage(m_hwndParent, nMsg, wParam, lParam);

    if(!m_fLogged)
        return S_OK;
    else
        m_fLogged = FALSE;

    SetWindowRedraw(m_ctlList, FALSE);
    int index = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);

    // Delete everything and reload
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);
    ListView_DeleteAllItems(m_ctlList);
//     FillMsgrList();                         // User list reload
    if(m_fShowAllContacts)
    {
        if(!m_cAddrBook.fIsWabLoaded())
	    {
	        if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
		        return(hr);
        }

        m_cAddrBook.LoadWabContents(m_ctlList, this);
    }

    ListView_SetItemState(m_ctlList, index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    SetWindowRedraw(m_ctlList, TRUE);

    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPWSTR) (m_fShowAllContacts ? m_szEmptyList : m_szMsgrEmptyList));
    UpdateWindow(/*m_ctlList*/);

    return S_OK;

}

HRESULT CIEMsgAb::OnLocalStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    ::SendMessage(m_hwndParent, nMsg, wParam, lParam);

    return S_OK;
}

HRESULT CIEMsgAb::OnUserLogResultEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    ::SendMessage(m_hwndParent, nMsg, wParam, lParam);

    _ReloadListview();

    if(SUCCEEDED(lParam))
    {
        m_fLogged = TRUE;
    }
    return S_OK;
}

LRESULT CIEMsgAb::NotifyKillFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT hres = E_FAIL;

    if (m_pObjSite != NULL)
        {
        IInputObjectSite *pis;

        hres = m_pObjSite->QueryInterface(IID_IInputObjectSite, (LPVOID*)&pis);
        if (SUCCEEDED(hres))
            {
            hres = pis->OnFocusChangeIS((IInputObject*) this, FALSE);
            pis->Release();
            }
        }
    return (hres);
}

LRESULT CIEMsgAb::NotifySetFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
// #ifdef LATER
//    UnkOnFocusChangeIS(m_pObjSite, (IInputObject*) this, TRUE);
// #endif
    HRESULT hres = S_OK;

/*    if (m_pObjSite != NULL)
        {
        IInputObjectSite *pis;

        hres = m_pObjSite->QueryInterface(IID_IInputObjectSite, (LPVOID*)&pis);
        if (SUCCEEDED(hres))
            {
            hres = pis->OnFocusChangeIS((IInputObject*) this, TRUE);
            pis->Release();
            }
        }*/
    return (hres);
}

HRESULT  STDMETHODCALLTYPE CIEMsgAb::QueryStatus(const GUID *pguidCmdGroup,
                                                ULONG cCmds, OLECMD *prgCmds,
                                                OLECMDTEXT *pCmdText)
{
    int     nEnable;
    HRESULT hr;
    DWORD   cSelected = ListView_GetSelectedCount(m_ctlList);
    UINT    id;
    BIMSTATE  State;

    // Loop through all the commands in the array
    for ( ; cCmds > 0; cCmds--, prgCmds++)
    {
        // Only look at commands that don't have OLECMDF_SUPPORTED;
        if (prgCmds->cmdf == 0)
        {
            switch (prgCmds->cmdID)
            {
                case ID_HIDE_IM:
                    if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else if(!m_dwDisableMessenger)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_INVISIBLE;

                    break;

                case ID_SHOW_IM:
                    if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else if(!m_dwDisableMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                // These commands are enabled if and only if one item is selected
                case ID_DELETE_CONTACT:
                    if (cSelected > 0)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_FIND_PEOPLE:
                case ID_ADDRESS_BOOK:
                    if(m_fWAB)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    break;

                case ID_SEND_MESSAGE:
                    if((HasFocusIO() == S_OK) && cSelected >= 1)
                       prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SEND_INSTANT_MESSAGE2:
                {
                    if (cSelected == 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_SORT_BY_STATUS:
                    if(!IsMessengerInstalled())
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }
                    else
                        if(ListView_GetItemCount(m_ctlList) > 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    if((m_nSortType == BASORT_STATUS_ACSEND) || (m_nSortType == BASORT_STATUS_DESCEND))
                        prgCmds->cmdf |= OLECMDF_NINCHED;
                    break;

                case ID_SORT_BY_NAME:
                    if(!IsMessengerInstalled())
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }
                    else if(ListView_GetItemCount(m_ctlList) > 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    if((m_nSortType == BASORT_NAME_ACSEND) || (m_nSortType == BASORT_NAME_DESCEND))
                        prgCmds->cmdf |= OLECMDF_NINCHED;


                    break;

                // These commands are always enabled
                case ID_POPUP_NEW_ACCOUNT:
                case ID_NEW_HOTMAIL_ACCOUNT:
                case ID_NEW_ATT_ACCOUNT:
                case ID_NEW_CONTACT:
                case ID_POPUP_MESSENGER:
                    prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SET_ONLINE_CONTACT:
                    {
                        if(m_dwHideMessenger)
                        {
                            prgCmds->cmdf = OLECMDF_INVISIBLE;
                            break;
                        }
                        else if(cSelected != 1)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                        LPMABENTRY pEntry = GetSelectedEntry();
                        if(!pEntry && m_pCMsgrList)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                        else if(pEntry && pEntry->tag != LPARAM_ABENTRY)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                    }
                case ID_NEW_ONLINE_CONTACT:
                    if(m_pCMsgrList)
                    {
                        if(m_pCMsgrList->IsLocalOnline())
                            prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                    }
                    else if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    break;

                // Properties is only enabled if the input focus is in the
                // list view.  Otherwise, we don't mark it as supported at all.
                case ID_PROPERTIES:
                {
                    LPMABENTRY pEntry = GetSelectedEntry();
                    if(pEntry && pEntry->tag != LPARAM_MENTRY)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_VIEW_ONLINE:
                    if(m_fShowOnlineContacts)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED ;
                    break;

                case ID_VIEW_ONANDOFFLINE:
                    if(m_fShowOfflineContacts)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED ;
                    break;

                case ID_VIEW_ALL:
                    if(m_fShowAllContacts)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED ;
                    break;

                case ID_MESSENGER_OPTIONS:

                    if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else if (!m_pCMsgrList)
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;

                    break;

                case ID_CALL:
                case ID_DIAL_PHONE_NUMBER:
                    if((ListView_GetItemCount(m_ctlList) < 1) || (!IsTelInstalled())) // && (!m_pCMsgrList || !m_pCMsgrList->IsLocalOnline())))
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_HOME_PHONE:
                case ID_WORK_PHONE:
                case ID_MOBILE_PHONE:
                case ID_IP_PHONE:
                    if(_FillPhoneNumber(prgCmds->cmdID, pCmdText))
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    break;

                case SEP_PHONE:
                    {
                    LPMABENTRY pEntry = GetSelectedEntry();
                    if(pEntry  && pEntry->lpPhones && (pEntry->lpPhones->pchIPPhone || pEntry->lpPhones->pchMobilePhone || pEntry->lpPhones->pchWorkPhone || pEntry->lpPhones->pchHomePhone))
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    else
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    }
                    break;

                // These depend on whether
                case ID_LOGIN_MESSENGER:
                case ID_LOGOFF_MESSENGER:
                case ID_MESSENGER_ONLINE:
                case ID_MESSENGER_INVISIBLE:
                case ID_MESSENGER_BUSY:
                case ID_MESSENGER_BACK:
                case ID_MESSENGER_AWAY:
                case ID_MESSENGER_ON_PHONE:
                case ID_MESSENGER_LUNCH:
                case ID_POPUP_MESSENGER_STATUS:
                {
                    // If messenger isn't installed, then none of these commands will
                    // be enabled.
                    if(m_dwHideMessenger)
                    {
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                        break;
                    }
                    else if (!m_pCMsgrList)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }

                    if (FAILED(m_pCMsgrList->GetLocalState(&State)))
                        State = BIMSTATE_UNKNOWN;

                    // Convert the online state to a command ID
                    switch (State)
                    {
                        case BIMSTATE_ONLINE:
                        case BIMSTATE_IDLE:
                            id = ID_MESSENGER_ONLINE;
                            break;
                        case BIMSTATE_INVISIBLE:
                            id = ID_MESSENGER_INVISIBLE;
                            break;
                        case BIMSTATE_BUSY:
                            id = ID_MESSENGER_BUSY;
                            break;
                        case BIMSTATE_BE_RIGHT_BACK:
                            id = ID_MESSENGER_BACK;
                            break;
                        case BIMSTATE_AWAY:
                            id = ID_MESSENGER_AWAY;
                            break;
                        case BIMSTATE_ON_THE_PHONE:
                            id = ID_MESSENGER_ON_PHONE;
                            break;
                        case BIMSTATE_OUT_TO_LUNCH:
                            id = ID_MESSENGER_LUNCH;
                            break;
                        default:
                            id = 0xffff;
                    }

                    // Logon is handled a bit seperatly
                    if (prgCmds->cmdID == ID_LOGIN_MESSENGER)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id == 0xffff)
                            prgCmds->cmdf |= OLECMDF_ENABLED;
                    }
                    else if (prgCmds->cmdID == ID_LOGOFF_MESSENGER)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id != 0xffff)
                            prgCmds->cmdf |= OLECMDF_ENABLED;
                    }
                    else
                    {
                        // For all other commands, if we in a known state
                        // then the command is enabled.
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id != 0xffff)
                            prgCmds->cmdf = OLECMDF_ENABLED;

                        // If the command is the same as our state, it should be checked
                        if (id == prgCmds->cmdID)
                            prgCmds->cmdf |= OLECMDF_NINCHED;
                    }
                }
                break;

                case ID_SEND_INSTANT_MESSAGE:
                {
                    if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else if (GetEntryForSendInstMsg())
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }
            }
        }
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CIEMsgAb::Exec(const GUID  *pguidCmdGroup,
                                                    DWORD        nCmdID,
                                                    DWORD        nCmdExecOpt,
                                                    VARIANTARG   *pvaIn,
                                                    VARIANTARG   *pvaOut)
{
    HRESULT     hr = OLECMDERR_E_NOTSUPPORTED;
    BOOL        bHandled = 0;
    BIMSTATE      State = BIMSTATE_UNKNOWN;

    switch (nCmdID)
    {

    case ID_HIDE_IM:
        Assert(!m_dwHideMessenger && !m_dwDisableMessenger)

        m_dwDisableMessenger = 1;
        DwSetDisableMessenger(m_dwDisableMessenger);
        if(m_pCMsgrList)
        {
            m_pCMsgrList->UnRegisterUIWnd(m_hWnd);
            OE_CloseMsgrList(m_pCMsgrList);
            m_pCMsgrList = NULL;
            _ReloadListview();
        }
        ::SendMessage(m_hwndParent, WM_MSGR_LOGRESULT, 0, 0);
        break;

    case ID_SHOW_IM:
        Assert(!m_dwHideMessenger && m_dwDisableMessenger)

        m_dwDisableMessenger = 0;
        DwSetDisableMessenger(m_dwDisableMessenger);
        if(!m_pCMsgrList)
        {
            m_pCMsgrList = OE_OpenMsgrList();
            // Register our control for Msgr list
            if(m_pCMsgrList)
            {
                m_pCMsgrList->RegisterUIWnd(m_hWnd);
                if(m_pCMsgrList->IsLocalOnline())
                {
                    m_fLogged = TRUE;
                    FillMsgrList();
                    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
                }
            }
        }
        ::SendMessage(m_hwndParent, WM_MSGR_LOGRESULT, 0, 0);

        break;

    case ID_SHOWALLCONTACT:
        if(m_fShowAllContacts)
        {
            m_fShowAllContacts = FALSE;
            m_fShowOnlineContacts = TRUE;
            m_fShowOfflineContacts = FALSE;
        }
        else if(m_fShowOnlineContacts)
        {
            m_fShowAllContacts = FALSE;
            m_fShowOnlineContacts = FALSE;
            m_fShowOfflineContacts = TRUE;
        }
        else if(m_fShowOfflineContacts)
        {
            m_fShowAllContacts = TRUE;
            m_fShowOnlineContacts = FALSE;
            m_fShowOfflineContacts = FALSE;
        }
        _ReloadListview();
        break;

    case ID_VIEW_ONLINE:
        m_fShowAllContacts = FALSE;
        m_fShowOfflineContacts = FALSE;
        m_fShowOnlineContacts = TRUE;
        _ReloadListview();
        break;

    case ID_VIEW_ONANDOFFLINE:
        m_fShowAllContacts = FALSE;
        m_fShowOnlineContacts = FALSE;
        m_fShowOfflineContacts = TRUE;
        _ReloadListview();
        break;

    case ID_VIEW_ALL:
        m_fShowAllContacts = TRUE;
        m_fShowOnlineContacts = FALSE;
        m_fShowOfflineContacts = FALSE;
        _ReloadListview();
        break;

    case ID_DIAL_PHONE_NUMBER:
        CallPhone(NULL, FALSE);
        break;

    case ID_HOME_PHONE:
    case ID_WORK_PHONE:
    case ID_MOBILE_PHONE:
    case ID_IP_PHONE:
        {
        LPMABENTRY pEntry = GetSelectedEntry();
        if(!pEntry || !(pEntry->lpPhones))
        {
            Assert(FALSE);
            break;
        }
        switch(nCmdID)
        {
        case ID_HOME_PHONE:
            CallPhone(pEntry->lpPhones->pchHomePhone, (pEntry->tag == LPARAM_MENTRY));
            break;

        case ID_WORK_PHONE:
            CallPhone(pEntry->lpPhones->pchWorkPhone, (pEntry->tag == LPARAM_MENTRY));
            break;

        case ID_MOBILE_PHONE:
            CallPhone(pEntry->lpPhones->pchMobilePhone, (pEntry->tag == LPARAM_MENTRY));
            break;

        case ID_IP_PHONE:
            CallPhone(pEntry->lpPhones->pchIPPhone, (pEntry->tag == LPARAM_MENTRY));
            break;
        }
        }
        break;

    case ID_SEND_INSTANT_MESSAGE2:
        CmdNewMessage(HIWORD(nCmdID), ID_SEND_INSTANT_MESSAGE2, m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_DELETE_CONTACT:
        hr = (HRESULT) CmdDelete(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;

    case ID_NEW_CONTACT:
//        if(HasFocusIO() == S_OK)
        CmdNewContact(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_SET_ONLINE_CONTACT:
        CmdSetOnline(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_NEW_ONLINE_CONTACT:
        CmdNewOnlineContact(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_PROPERTIES:
        CmdProperties(0, 0, m_ctlList, bHandled);
        hr = S_OK;
        break;

#ifdef GEORGEH
    case ID_NEW_MSG_DEFAULT:
        if(HasFocusIO() == S_OK)
            hr = CmdNewMessage(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;
#endif // GEORGEH

    case ID_FIND_PEOPLE:
    case ID_ADDRESS_BOOK:
        {
            WCHAR wszWABExePath[MAX_PATH];
            if(S_OK == HrLoadPathWABEXE(wszWABExePath, sizeof(wszWABExePath)/sizeof(wszWABExePath[0])))
            {
                SHELLEXECUTEINFOW ExecInfo;
                ExecInfo.cbSize = sizeof(SHELLEXECUTEINFOW);
                ExecInfo.nShow = SW_SHOWNORMAL;
                ExecInfo.fMask = 0;
                ExecInfo.hwnd = NULL;
                ExecInfo.lpDirectory = NULL;
                ExecInfo.lpParameters = ((nCmdID == ID_FIND_PEOPLE) ? L"/find" : L"");
                ExecInfo.lpVerb = L"open";
                ExecInfo.lpFile = wszWABExePath;

                ShellExecuteExW(&ExecInfo);

                // ShellExecuteW(NULL, L"open", wszWABExePath,
                //            ((nCmdID == ID_FIND_PEOPLE) ? L"/find" : L""),
                //            "", SW_SHOWNORMAL);

            }
            break;
        }

    case ID_SEND_MESSAGE:
        if(HasFocusIO() == S_OK)
            hr = (HRESULT) CmdNewEmaile(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;

    case ID_SEND_INSTANT_MESSAGE:
        // Assert(m_pCMsgrList);
        CmdNewIMsg(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_MESSENGER_OPTIONS:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->LaunchOptionsUI(); //CmdMsgrOptions();
        break;

    case ID_MESSENGER_ONLINE:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_ONLINE);
        break;

    case ID_MESSENGER_INVISIBLE:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_INVISIBLE);
        break;

    case ID_MESSENGER_BUSY:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_BUSY);
        break;

    case ID_MESSENGER_BACK:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_BE_RIGHT_BACK);
        break;

    case ID_MESSENGER_AWAY:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_AWAY);
        break;

    case ID_MESSENGER_ON_PHONE:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_ON_THE_PHONE);
        break;

    case ID_MESSENGER_LUNCH:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_OUT_TO_LUNCH);
        break;

    case ID_LOGIN_MESSENGER:
        if(m_pCMsgrList)
        {
            if(!m_pCMsgrList->IsLocalOnline())
            {
                if(PromptToGoOnline() == S_OK)
                    m_pCMsgrList->UserLogon();
            }
            hr = S_OK;
        }
        break;

    case ID_LOGOFF_MESSENGER:
        Assert(m_pCMsgrList);
        if(m_pCMsgrList)
                m_pCMsgrList->UserLogoff();
        hr = S_OK;
        break;

    case ID_SORT_BY_NAME:
        m_nSortType = BASORT_NAME_ACSEND;
        ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
        break;

    case ID_SORT_BY_STATUS:
        m_nSortType = BASORT_STATUS_ACSEND;
        ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
        break;

    default:
        break;
    }
    return hr;
}


// fill a phone number for menu
BOOL CIEMsgAb::_FillPhoneNumber(UINT Id, OLECMDTEXT *pcmdText)
{
    LPMABENTRY pEntry = GetSelectedEntry();
    WCHAR   szTmp[CCHMAX_STRINGRES];
    WCHAR * pch = NULL;
    TCHAR * pchStr = NULL;

    if(!pEntry || !(pEntry->lpPhones))
    {
err:
        pcmdText->cwBuf = 0;
        return(FALSE);
    }

    szTmp[0] = L'\0';
    switch(Id)
    {
    case ID_HOME_PHONE:
        pch = pEntry->lpPhones->pchHomePhone;
        AthLoadString(idsHome, szTmp, ARRAYSIZE(szTmp));
        break;

    case ID_WORK_PHONE:
        pch = pEntry->lpPhones->pchWorkPhone;
        AthLoadString(idsWork, szTmp, ARRAYSIZE(szTmp));
        break;

    case ID_MOBILE_PHONE:
        pch = pEntry->lpPhones->pchMobilePhone;
        AthLoadString(idsMobile, szTmp, ARRAYSIZE(szTmp));
        break;

    case ID_IP_PHONE:
        pch = pEntry->lpPhones->pchIPPhone;
        AthLoadString(idsIPPhone, szTmp, ARRAYSIZE(szTmp));
        break;

    default:
        pch = NULL;
        Assert(FALSE);
        break;
    }

    if(!pch)
        goto err;

    if(pcmdText->cmdtextf == OLECMDTEXTF_NONE)
        return(TRUE);

    pcmdText->cwBuf = (lstrlenW(pch) + 2 + lstrlenW(szTmp));
    if(pcmdText->cwBuf > MAX_MENUSTR)
        Assert(FALSE);

    else
    {
#ifdef NEW
        if(!MultiByteToWideChar(GetACP(), 0, pch, -1, pcmdText->rgwz, pcmdText->cwBuf))
        {
            Assert(FALSE);
            pcmdText->cwBuf = 0;
        }
#else
        pchStr = ((TCHAR *)(pcmdText->rgwz));

        LPTSTR pchTmpA = LPTSTRfromBstr(pch);
        StrCpyN(pchStr, pchTmpA, ARRAYSIZE(pcmdText->rgwz));
        MemFree(pchTmpA);

        LPTSTR pchA = LPTSTRfromBstr(szTmp);
        StrCatBuff(pchStr, pchA, ARRAYSIZE(pcmdText->rgwz));
        MemFree(pchA);

        pcmdText->cwActual = lstrlen(pchStr) + 1;

#endif

    }
/*    else
        goto err; */

    return(TRUE);
}

STDMETHODIMP CIEMsgAb::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
#ifdef LATER
    TCHAR sz[CCHMAX_STRINGRES];
    if(m_lpWED->fReadOnly)
        return NOERROR;

    PROPSHEETPAGE psp;

    // hinstApp        = g_hInst;
    psp.dwSize      = sizeof(psp);   // no extra data
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USETITLE ;
    psp.hInstance   = g_hLocRes;
    psp.lParam      = (LPARAM) &(m_lpWED);
    psp.pcRefParent = (UINT *)&(m_cRefThisDll);

    psp.pszTemplate = MAKEINTRESOURCE(iddWabExt);

    psp.pfnDlgProc  = WabExtDlgProc;
    psp.pszTitle    = AthLoadString(idsWABExtTitle, sz, ARRAYSIZE(sz)); // Title for your tab AthLoadString(idsWABExtTitle, sz, ARRAYSIZE(sz))

    m_hPage1 = ::CreatePropertySheetPage(&psp);
    if (m_hPage1)
    {
        if (!lpfnAddPage(m_hPage1, lParam))
            ::DestroyPropertySheetPage(m_hPage1);
    }

    return NOERROR;
#else
    return E_NOTIMPL;
#endif
}

STDMETHODIMP CIEMsgAb::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    Assert(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CIEMsgAb::Initialize(LPWABEXTDISPLAY lpWABExtDisplay)
{

    if (lpWABExtDisplay == NULL)
    {
	    TRACE("CIEMsgAb::Initialize() no data object");
	    return E_FAIL;
    }

    if(st_pAddrBook == NULL)
    {
	    TRACE("CIEMsgAb::Initialize() - run from not OE - no st_pAddrbook");
	    return E_FAIL;
    }

    if (!m_dwHideMessenger && !m_dwDisableMessenger)
    {
        if(!m_pCMsgrList)
        {
            m_pCMsgrList = OE_OpenMsgrList();
            if(!m_pCMsgrList)
            {
    	        TRACE("CIEMsgAb::Initialize() - Messeneger not installed");
	            return E_FAIL;
            }
        }
    }

    // However if this is a context menu extension, we need to hang
    // onto the propobj till such time as InvokeCommand is called ..
    // At this point just AddRef the propobj - this will ensure that the
    // data in the lpAdrList remains valid till we release the propobj..
    // When we get another ContextMenu initiation, we can release the
    // older cached propobj - if we dont get another initiation, we
    // release the cached object at shutdown time
    if(lpWABExtDisplay->ulFlags & WAB_CONTEXT_ADRLIST) // this means a IContextMenu operation is occuring
    {
        if(m_lpPropObj)
        {
            m_lpPropObj->Release();
            m_lpPropObj = NULL;
        }

        m_lpPropObj = lpWABExtDisplay->lpPropObj;
        m_lpPropObj->AddRef();

        m_lpWEDContext = lpWABExtDisplay;
    }
    else
    {
        // For property sheet extensions, the lpWABExtDisplay will
        // exist for the life of the property sheets ..
        m_lpWED = lpWABExtDisplay;
    }

    return S_OK;
}

HRESULT CIEMsgAb::PromptToGoOnline()
{
    HRESULT     hr = S_OK;

#ifdef LATER
    if (g_pConMan->IsGlobalOffline())
    {
        if (IDYES == AthMessageBoxW(m_hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                  0, MB_YESNO | MB_ICONEXCLAMATION ))
        {
            g_pConMan->SetGlobalOffline(FALSE);
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
        hr = S_OK;
#endif
    return hr;
}

HRESULT CIEMsgAb::ResizeChildWindows(LPCRECT prcPos)
{
    RECT rc;

    // Get the size of the outer window
    if (!prcPos)
    {
        GetClientRect(&rc);
	    rc.right = rc.right - rc.left;
	    rc.bottom = rc.bottom - rc.top;
    }
    else
    {
        rc.top = 0;
        rc.left = 0;
		rc.right = prcPos->right - prcPos->left;
		rc.bottom = prcPos->bottom - prcPos->top;
    }

#if 0
    // If we have to reserve room for the status bar and menu bar, do it
    if (m_fStatusBar)
        rc.bottom -= m_cyStatusBar;

    if (m_fMenuBar)
        rc.top += m_cyMenuBar;
#endif

    // Move the ListView into the right place
/*	::SetWindowPos(m_ctlList.m_hWnd, NULL, rc.top, rc.left,
                   rc.right, rc.bottom, SWP_NOZORDER | SWP_NOACTIVATE); */

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
// IDeskBand implementation
//

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::GetBandInfo()
//
///////////////////////////////////////////////////////////////////////////
#define MIN_SIZE_X 50
#define MIN_SIZE_Y 50

STDMETHODIMP CIEMsgAb::GetBandInfo(DWORD dwBandID,
								   DWORD dwViewMode,
								   DESKBANDINFO* pdbi)
{
   if (pdbi)
   {
//      _dwBandID = dwBandID;
//      _dwViewMode = dwViewMode;

      if (pdbi->dwMask & DBIM_MINSIZE)
      {
         pdbi->ptMinSize.x = MIN_SIZE_X;
         pdbi->ptMinSize.y = MIN_SIZE_Y;
      }

      if (pdbi->dwMask & DBIM_MAXSIZE)
      {
         pdbi->ptMaxSize.x = -1;
         pdbi->ptMaxSize.y = -1;
      }

      if (pdbi->dwMask & DBIM_INTEGRAL)
      {
         pdbi->ptIntegral.x = 1;
         pdbi->ptIntegral.y = 1;
      }

      if (pdbi->dwMask & DBIM_ACTUAL)
      {
         pdbi->ptActual.x = 0;
         pdbi->ptActual.y = 0;
      }

      if (pdbi->dwMask & DBIM_TITLE)
      {
         StrCpyNW(pdbi->wszTitle, L"WebBand Search", ARRAYSIZE(pdbi->wszTitle));
      }

      if (pdbi->dwMask & DBIM_MODEFLAGS)
         pdbi->dwModeFlags = DBIMF_VARIABLEHEIGHT;

      if (pdbi->dwMask & DBIM_BKCOLOR)
      {
         // Use the default background color by removing this flag.
         pdbi->dwMask &= ~DBIM_BKCOLOR;
      }

      return S_OK;
   }

   return E_INVALIDARG;
}

///////////////////////////////////////////////////////////////////////////
//
// IDockingWindow Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::ShowDW()
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIEMsgAb::ShowDW(BOOL fShow)
{
   if (m_hWnd)
   {
      //
      // Hide or show the window depending on
      // the value of the fShow parameter.
      //
      if (fShow)
          ::ShowWindow(m_hWnd, SW_SHOW);
      else
          ::ShowWindow(m_hWnd, SW_HIDE);
   }

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::CloseDW()
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIEMsgAb::CloseDW(DWORD dwReserved)
{
   ShowDW(FALSE);

   // Assert(FALSE);
   if (IsWindow(m_hWnd))
       ::DestroyWindow(m_hWnd);

   m_hWnd = NULL;

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::ResizeBorderDW()
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIEMsgAb::ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkToolbarSite,
                                            BOOL fReserved)
{
   // This method is never called for Band Objects.
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleWindow Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::GetWindow()
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIEMsgAb::GetWindow(HWND *phwnd)
{
   *phwnd = m_hWnd;
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::ContextSensitiveHelp()
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIEMsgAb::ContextSensitiveHelp(BOOL fEnterMode)
{
   return E_NOTIMPL;
}

STDMETHODIMP CIEMsgAb::Init (REFGUID refguid)
{
    return S_OK;
}

STDMETHODIMP CIEMsgAb::GetProperty(SHORT iPropID, VARIANTARG * pvarProperty)
{
    HRESULT hr = S_OK;

    switch (iPropID)
    {
    case TBEX_BUTTONTEXT:
        if (pvarProperty)
        {
            pvarProperty->vt = VT_BSTR;
            pvarProperty->bstrVal = SysAllocString(L"YST Button");
            if (NULL == pvarProperty->bstrVal)
                hr = E_OUTOFMEMORY;
        }
        break;

    case TBEX_GRAYICON:
        hr = E_NOTIMPL; // hr = _GetIcon(TEXT("Icon"), 20, 20, _hIcon, pvarProperty);
        break;

    case TBEX_GRAYICONSM:
        hr = E_NOTIMPL; // hr = _GetIcon(TEXT("Icon"), 16, 16, _hIconSm, pvarProperty);
        break;

    case TBEX_HOTICON:
        hr = E_NOTIMPL; // hr = _GetIcon(TEXT("HotIcon"), 20, 20, _hHotIcon, pvarProperty);
        break;

    case TBEX_HOTICONSM:
        hr = E_NOTIMPL; //hr = _GetIcon(TEXT("HotIcon"), 16, 16, _hHotIcon, pvarProperty);
        break;

    case TBEX_DEFAULTVISIBLE:
        if (pvarProperty)
        {
            // BOOL fVisible = _RegGetBoolValue(L"Default Visible", FALSE);
            pvarProperty->vt = VT_BOOL;
            pvarProperty->boolVal = VARIANT_TRUE;
        }
        break;

    case TMEX_CUSTOM_MENU:
        {
            if (pvarProperty != NULL)
            {
                pvarProperty->vt = VT_BSTR;
                pvarProperty->bstrVal = SysAllocString(L"YST test");
                if (pvarProperty->bstrVal == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        break;

    case TMEX_MENUTEXT:
        if (pvarProperty)
        {
            pvarProperty->vt = VT_BSTR;
            pvarProperty->bstrVal = SysAllocString(L"YST test 1");
            if (NULL == pvarProperty->bstrVal)
                hr = E_OUTOFMEMORY;
        }
        break;

    case TMEX_STATUSBARTEXT:
        if (pvarProperty)
        {
            pvarProperty->vt = VT_BSTR;
            pvarProperty->bstrVal = SysAllocString(L"YST test 2");
            if (NULL == pvarProperty->bstrVal)
                hr = E_OUTOFMEMORY;
        }
        break;
    default:
        hr = E_NOTIMPL;
    }
    return hr;
}

// --------------------------------------------------------------------------------
// AthLoadString
// --------------------------------------------------------------------------------
LPSTR ANSI_AthLoadString(UINT id, TCHAR* sz, int cch)
{
    LPSTR szT;

    if (sz == NULL)
    {
        if (!MemAlloc((LPVOID*)&szT, CCHMAX_STRINGRES))
            return(NULL);
        cch = CCHMAX_STRINGRES;
    }
    else
        szT = sz;

    if(g_hLocRes)
    {
        cch = LoadString(g_hLocRes, id, szT, cch);
        Assert(cch > 0);

        if (cch == 0)
        {
            if (sz == NULL)
                MemFree(szT);
            szT = NULL;
        }
    }
    else
    {
        if (sz == NULL)
            MemFree(szT);
        szT = NULL;

    }
    return(szT);
}

// --------------------------------------------------------------------------------
// AthLoadString
// --------------------------------------------------------------------------------
LPWSTR AthLoadString(UINT id, LPWSTR sz, int cch)
{
    LPWSTR szT;

    if (sz == NULL)
    {
        if (!MemAlloc((LPVOID*)&szT, CCHMAX_STRINGRES*sizeof(WCHAR)))
            return(NULL);
        cch = CCHMAX_STRINGRES;
    }
    else
        szT = sz;

    if(g_hLocRes)
    {
        cch = LoadStringW(g_hLocRes, id, szT, cch);
        Assert(cch > 0);

        if (cch == 0)
        {
            if (sz == NULL)
                MemFree(szT);
            szT = NULL;
        }
    }
    else
    {
        if (sz == NULL)
            MemFree(szT);
        szT = NULL;

    }
    return(szT);
}

//
// REVIEW: We need this function because current version of USER.EXE does
//  not support pop-up only menu.
//
HMENU LoadPopupMenu(UINT id)
{
    HMENU hmenuParent = LoadMenuW(g_hLocRes, MAKEINTRESOURCEW(id));

    if (hmenuParent) {
        HMENU hpopup = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
        return hpopup;
    }

    return NULL;
}

void MenuUtil_BuildMenuIDList(HMENU hMenu, OLECMD **prgCmds, ULONG *pcStart, ULONG *pcCmds)
{
    ULONG        cItems = 0;
    MENUITEMINFO mii;

    if(!IsMenu(hMenu))
    return;
    // Start by getting the count of items on this menu
    cItems = GetMenuItemCount(hMenu);
    if (!cItems)
        return;

    // Realloc the array to be cItems elements bigger
    if (!MemRealloc((LPVOID *) prgCmds, sizeof(OLECMD) * (cItems + (*pcCmds))))
        return;

    *pcCmds += cItems;

    // Walk this menu and add our items to it
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;
    for (ULONG i = 0; i < cItems; i++)
    {
        if (GetMenuItemInfo(hMenu, i, TRUE, &mii))
        {
            // Make sure this isn't a separator
            if (mii.wID != -1 && mii.wID != 0)
            {
                // Add the ID to our array
                (*prgCmds)[*pcStart].cmdID = mii.wID;
                (*prgCmds)[*pcStart].cmdf = 0;
                (*pcStart)++;

                // See if we need to recurse
                if (mii.hSubMenu)
                {
                    MenuUtil_BuildMenuIDList(mii.hSubMenu, prgCmds, pcStart, pcCmds);
                }
            }
        }
    }

    return;
}

//
//  FUNCTION:   MenuUtil_EnablePopupMenu()
//
//  PURPOSE:    Walks the given menu and takes care of enabling and
//              disabling each item via the provided commnand target.
//
//  PARAMETERS:
//      [in] hPopup
//      [in] *pTarget
//
HRESULT MenuUtil_EnablePopupMenu(HMENU hPopup, CIEMsgAb *pTarget)
{
    HRESULT             hr = S_OK;
    int                 i;
    int                 cItems;
    OLECMD             *rgCmds = NULL;
    ULONG               cStart = 0;
    ULONG               cCmds = 0;
    MENUITEMINFO        mii = {0};
    OLECMDTEXT          CmdText;
    OLECMDTEXTV<MAX_MENUSTR> CmdNewText;

    Assert(hPopup && pTarget);

    // Build the array of menu ids
    MenuUtil_BuildMenuIDList(hPopup, &rgCmds, &cCmds, &cStart);

    // Ask our parent for the state of the commands
    CmdText.cmdtextf = OLECMDTEXTF_NONE;

    if (SUCCEEDED(hr = pTarget->QueryStatus(NULL, cCmds, rgCmds, &CmdText)))
    {
        mii.cbSize = sizeof(MENUITEMINFO);

        // Now loop through the menu and apply the state
        for (i = 0; i < (int) cCmds; i++)
        {
            BOOL f;
            CmdNewText.cwBuf = 0;

            if(rgCmds[i].cmdf & OLECMDF_INVISIBLE)
                RemoveMenu(hPopup, rgCmds[i].cmdID, MF_BYCOMMAND);
            else
            {
               // The default thing we're going to update is the state
                mii.fMask = MIIM_STATE;

                // Enabled or Disabled
                if (rgCmds[i].cmdf & OLECMDF_ENABLED)
                {
                    mii.fState = MFS_ENABLED;
                }
                else
                    mii.fState = MFS_GRAYED;

                // Checked?
                if (rgCmds[i].cmdf & OLECMDF_LATCHED)
                    mii.fState |= MFS_CHECKED;

                if(mii.fState == MFS_ENABLED)
                {
                    // special for phones
                    if((rgCmds[i].cmdID > ID_DIAL_PHONE_NUMBER) && (rgCmds[i].cmdID < ID_DIAL_PHONE_LAST))
                    {
                        OLECMD Cmd[1];
                        Cmd[0].cmdf = 0;
                        Cmd[0].cmdID = rgCmds[i].cmdID;
                        CmdNewText.cmdtextf = OLECMDTEXTF_NAME;

                        if (SUCCEEDED(hr = pTarget->QueryStatus(NULL, 1, Cmd, &CmdNewText)))
                        {
                            if(CmdNewText.cwBuf)
                            {
                                mii.fType = MFT_STRING;
                                mii.fMask |= MIIM_TYPE;
                                mii.dwTypeData = ((LPSTR) CmdNewText.rgwz);
                                mii.cch = CmdNewText.cwBuf;
                            }
                            else
                            {
                                mii.dwTypeData = NULL;
                                mii.cch = 0;
                            }
                        }
                    }
                }
                // Set the item state
                f = SetMenuItemInfo(hPopup, rgCmds[i].cmdID, FALSE, &mii);

                // if(CmdNewText.cwBuf)
                //    MemFree(&(CmdNewText.rgwz[0]));

                // Radio Check?
                if ((rgCmds[i].cmdf & OLECMDF_NINCHED) && rgCmds[i].cmdID != (-1))
                {
                    CheckMenuRadioItem(hPopup, rgCmds[i].cmdID, rgCmds[i].cmdID, rgCmds[i].cmdID, MF_BYCOMMAND);
                    // mii.fMask |= MIIM_TYPE;
                    // mii.fType = MFT_RADIOCHECK;
                    // mii.fState |= MFS_CHECKED;
                }
                // Assert(f);
            }
        }
    }

    SafeMemFree(rgCmds);
    return (hr);
}

HRESULT CEmptyList::Show(HWND hwndList, LPWSTR pszString)
{
    // We're already doing a window
    if (m_hwndList)
    {
        Hide();
    }

    // Keep a copy of the listview window handle
    m_hwndList = hwndList;

    if(MemAlloc((LPVOID *) &m_pwszString, (lstrlenW(pszString) + 1)*sizeof(WCHAR)))
        StrCpyNW(m_pwszString, pszString, lstrlenW(pszString) + 1);

    // Get the header window handle from the listview
    m_hwndHeader = ListView_GetHeader(m_hwndList);

    // Save our this pointer on the listview window
    SetProp(m_hwndList, _T("EmptyListClass"), (HANDLE) this);
    // Subclass the listview so we can steal sizing messages
    if (!m_pfnWndProc)
        m_pfnWndProc = SubclassWindow(m_hwndList, SubclassWndProc);

    // Create our window on top
    if (!m_hwndBlocker)
    {
        m_hwndBlocker = CreateWindow(_T("Button"), _T("Blocker"), 
                                     WS_CHILD | WS_TABSTOP | WS_CLIPSIBLINGS |  BS_OWNERDRAW /*| ES_MULTILINE | ES_READONLY*/,
                                     0, 0, 0, 0, m_hwndList, (HMENU) NULL, g_hLocRes, NULL);
        Assert(m_hwndBlocker);
    }


    // Set the font for the blocker
    if(!m_hFont)
    {
        LOGFONT     lf;
        // Figure out which font to use
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, FALSE);

        // Create the fonts
        m_hFont = CreateFontIndirect(&lf);
    }

    // Show the silly thing
    if(m_hFont)
    {
        SendMessageW(m_hwndBlocker, WM_SETFONT, (WPARAM) m_hFont, MAKELPARAM(TRUE, 0));
    } 

    // SetWindowTextW(m_hwndBlocker, m_pwszString);

    // Position the blocker
    RECT rcList = {0};
    RECT rcHead = {0};

    GetClientRect(m_hwndList, &rcList);
    if(m_hwndHeader)
        GetClientRect(m_hwndHeader, &rcHead);

    SetWindowPos(m_hwndBlocker, 0, 0, rcHead.bottom, rcList.right,
                 rcList.bottom - rcHead.bottom, SWP_NOACTIVATE | SWP_NOZORDER);

    ShowWindow(m_hwndBlocker, SW_SHOW);
    return (S_OK);
}

HRESULT CEmptyList::Hide(void)
{
    // Verify we have the blocker up first
    if (m_pfnWndProc)
    {
        // Hide the window
        ShowWindow(m_hwndBlocker, SW_HIDE);

        // Unsubclass the window
        SubclassWindow(m_hwndList, m_pfnWndProc);

        // Delete the property
        RemoveProp(m_hwndList, _T("EmptyListClass"));

        // Free the string
        SafeMemFree(m_pwszString);

        // NULL everything out
        m_pfnWndProc = 0;
        m_hwndList = 0;
    }

    return (S_OK);

}

CEmptyList::~CEmptyList()
{
    if(m_hFont)
        DeleteObject(m_hFont);

    if (IsWindow(m_hwndBlocker))
        DestroyWindow(m_hwndBlocker);
    SafeMemFree(m_pwszString);
    if (NULL != m_hbrBack)
        DeleteObject(m_hbrBack);
}

LRESULT CEmptyList::SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CEmptyList* pThis = (CEmptyList *) GetProp(hwnd, _T("EmptyListClass"));
    Assert(pThis);

    switch (uMsg)
    {
        case WM_DRAWITEM:
            if (pThis && IsWindow(pThis->m_hwndBlocker))
            {
                LPDRAWITEMSTRUCT pdis = (LPDRAWITEMSTRUCT) lParam;
                RECT rc = pdis->rcItem;
                WCHAR  wszStr[RESSTRMAX];
                HBRUSH hbr3DFace = NULL;
                hbr3DFace = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
                FillRect(pdis->hDC, &(pdis->rcItem), hbr3DFace);
                SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
                DeleteObject(hbr3DFace);

                // Position the blocker
                RECT rcList = {0};
                RECT rcHead = {0};

                GetClientRect(pThis->m_hwndList, &rcList);
                if(pThis->m_hwndHeader)
                    GetClientRect(pThis->m_hwndHeader, &rcHead);

                SetWindowPos(pThis->m_hwndBlocker, 0, 0, rcHead.bottom, rcList.right,
                             rcList.bottom - rcHead.bottom, SWP_NOACTIVATE | SWP_NOZORDER);

                SelectFont(pdis->hDC, pThis->m_hFont);
                rc.left = 0;
                rc.top = rcHead.bottom;
                rc.right = rcList.right;
                rc.bottom = rcList.bottom - rcHead.bottom;

                hbr3DFace = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
                FillRect(pdis->hDC, &(pdis->rcItem), hbr3DFace);
                SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
                DeleteObject(hbr3DFace);

                DrawTextW(pdis->hDC, pThis->m_pwszString, -1, &rc, DT_WORDBREAK | DT_VCENTER | DT_CENTER );
                return(0);
            } 
            break;

        case WM_SIZE:
            if (pThis && IsWindow(pThis->m_hwndBlocker))
            {
                RECT rcHeader = {0};

                GetClientRect(pThis->m_hwndHeader, &rcHeader);
                SetWindowPos(pThis->m_hwndBlocker, 0, 0, 0, LOWORD(lParam),
                             HIWORD(lParam) - rcHeader.bottom,
                             SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
                InvalidateRect(pThis->m_hwndBlocker, NULL, FALSE);
            }
            break;

        case WM_CTLCOLORSTATIC:
            if ((HWND) lParam == pThis->m_hwndBlocker)
            {
                if (!pThis->m_hbrBack)
                {
                    pThis->m_hbrBack = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
                }
                SetBkColor((HDC) wParam, GetSysColor(COLOR_WINDOW));
                return (LRESULT) pThis->m_hbrBack;
            }
            break;

        case WM_SYSCOLORCHANGE:
            if (pThis)
            {
                DeleteObject(pThis->m_hbrBack);
                pThis->m_hbrBack = 0;

                SendMessage(pThis->m_hwndBlocker, uMsg, wParam, lParam);
            }
            break;

        case WM_WININICHANGE:
        case WM_FONTCHANGE:
            if (pThis)
            {
                LRESULT lResult = CallWindowProc(pThis->m_pfnWndProc, hwnd, uMsg, wParam, lParam);

                SendMessage(pThis->m_hwndBlocker, uMsg, wParam, lParam);
                // HFONT hf = (HFONT) SendMessage(pThis->m_hwndList, WM_GETFONT, 0, 0);
                // SendMessage(pThis->m_hwndBlocker, WM_SETFONT, (WPARAM) hf, MAKELPARAM(TRUE, 0));

                return (lResult);
            }

        case WM_DESTROY:
            {
                if (pThis)
                {
                    WNDPROC pfn = pThis->m_pfnWndProc;
                    pThis->Hide();
                    return (CallWindowProc(pfn, hwnd, uMsg, wParam, lParam));
                }
            }
            break;
    }

    return (CallWindowProc(pThis->m_pfnWndProc, hwnd, uMsg, wParam, lParam));
}


extern "C" const GUID CLSID_MailRecipient;

HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState)
{
    IDropTarget *pdrop;
    HRESULT hres = CoCreateInstance(CLSID_MailRecipient,
        NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
        IID_IDropTarget, (void **) &pdrop);

    if (SUCCEEDED(hres))
    {
        hres = OESimulateDrop(pdrop, pdtobj, grfKeyState, NULL, NULL);
        pdrop->Release();
    }
    return hres;
}
STDAPI OESimulateDrop(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                      const POINTL *ppt, DWORD *pdwEffect)
{
    POINTL pt;
    DWORD dwEffect;

    if (!ppt)
    {
        ppt = &pt;
        pt.x = 0;
        pt.y = 0;
    }

    if (!pdwEffect)
    {
        pdwEffect = &dwEffect;
        dwEffect = DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY;
    }

    DWORD dwEffectSave = *pdwEffect;    // drag enter returns the default effect

    HRESULT hr = pdrop->DragEnter(pdtobj, grfKeyState, *ppt, pdwEffect);
    if (*pdwEffect)
    {
        *pdwEffect = dwEffectSave;      // do Drop with the full set of bits
        hr = pdrop->Drop(pdtobj, grfKeyState, *ppt, pdwEffect);
    }
    else
    {
        pdrop->DragLeave();
        hr = S_FALSE;     // HACK? S_FALSE DragEnter said no
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\baui.h ===
// abui.h : Declaration of the CIEMsgAb
// Messanger integration to OE
// Created 04/20/98 by YST

#ifndef __BAUI_H_
#define __BAUI_H_

class CFolderBar;
class CPaneFrame;

#include "resource.h"       // main symbols
//#include "blobevnt.h"
#include "bactrl.h"
#include "commctrl.h"
#include "badata.h"
#include <docobj.h>
#include <shlobj.h>
#include <shlguid.h>
#include <wab.h>
#include <mapiguid.h>
#include "bllist.h"
// #include "menures.h"
#include <wabapi.h>
// #include "util.h"
// {32bb8320-b41b-11cf-a6bb-0080c7b2d682}
DEFINE_GUID(IID_IBrowserExtension, 0x32bb8320, 0xb41b, 0x11cf, 0xa6, 0xbb, 0x0, 0x80, 0xc7, 0xb2, 0xd6, 0x82);
#define IDT_PANETIMER           100
#define ELAPSE_MOUSEOVERCHECK   60000

// Load resource string once
#define RESSTRMAX   64

extern HINSTANCE  g_hLocRes;

interface IBrowserExtension : IUnknown
{
    virtual STDMETHODIMP Init(REFGUID refguid) = 0;
    virtual STDMETHODIMP GetProperty(SHORT iPropID, VARIANTARG * varProperty) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Bitmap Indices
//

enum {
    IMAGE_NEW_MESSAGE = 0,
    IMAGE_DISTRIBUTION_LIST,
    IMAGE_ONLINE,
    IMAGE_OFFLINE,
    IMAGE_STOPSIGN,
    IMAGE_CLOCKSIGN,
    IMAGE_CERT,
    IMAGE_EMPTY,
    ABIMAGE_MAX
};

enum {
    BASORT_STATUS_ACSEND = 0,
    BASORT_STATUS_DESCEND,
    BASORT_NAME_ACSEND,
    BASORT_NAME_DESCEND
};

HRESULT CreateIEMsgAbCtrl(IIEMsgAb **pIEMsgAb);

typedef struct _tag_Phones
{
    WCHAR   *   pchHomePhone;
    WCHAR   *   pchWorkPhone;
    WCHAR   *   pchMobilePhone;
    WCHAR   *   pchIPPhone;
} PNONEENTRIES;

typedef PNONEENTRIES * LPPNONEENTRIES;

typedef struct _tag_MABEntry
{
    MABENUM         tag;
    WCHAR   *       pchWABName;
    WCHAR   *       pchWABID;
    LPSBinary       lpSB;
    LPMINFO         lpMsgrInfo;
    BOOL            fCertificate;
    LPPNONEENTRIES  lpPhones;
} mabEntry;

typedef mabEntry * LPMABENTRY;

class CEmptyList
{
public:
    CEmptyList()
    {
        m_hwndList = NULL;
        m_hwndBlocker = NULL;
        m_hwndHeader = NULL;
        m_pwszString = NULL;
        m_pfnWndProc = NULL;
        m_hbrBack = NULL;
        m_hFont = NULL;
    }

    ~CEmptyList();
    HRESULT Show(HWND hwndList, LPWSTR pwszString);
    HRESULT Hide(void);
    static LRESULT SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
private:
    HWND    m_hwndList;
    HWND    m_hwndBlocker;
    HWND    m_hwndHeader;
    WCHAR  *m_pwszString;
    WNDPROC m_pfnWndProc;
    HBRUSH  m_hbrBack;
    HFONT   m_hFont;
};


/////////////////////////////////////////////////////////////////////////////
// CIEMsgAb
class ATL_NO_VTABLE CIEMsgAb : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CIEMsgAb, &CLSID_IEMsgAb>,
    public CComControl<CIEMsgAb>,
    public IDispatchImpl<IIEMsgAb, &IID_IIEMsgAb, &LIBID_IEMsgAbLib>,
    public IProvideClassInfo2Impl<&CLSID_IEMsgAb, NULL, &LIBID_IEMsgAbLib>,
    public IPersistStreamInitImpl<CIEMsgAb>,
    public IPersistStorageImpl<CIEMsgAb>,
    public IQuickActivateImpl<CIEMsgAb>,
    public IOleControlImpl<CIEMsgAb>,
    public IOleObjectImpl<CIEMsgAb>,
    public IOleInPlaceActiveObjectImpl<CIEMsgAb>,
    public IViewObjectExImpl<CIEMsgAb>,
    public IOleInPlaceObjectWindowlessImpl<CIEMsgAb>,
    public IDataObjectImpl<CIEMsgAb>,
    public IConnectionPointContainerImpl<CIEMsgAb>,
	public IPropertyNotifySinkCP<CIEMsgAb>,
    public ISpecifyPropertyPagesImpl<CIEMsgAb>,
    public IInputObject,
    public IObjectWithSite,
//    public IBrowserExtension,
    public IDeskBand,
//    public IPersistStream,
    public IDropTarget,
    public IOleCommandTarget,
    // public IWABExtInit,
    public IShellPropSheetExt
{
public:
    // Declare our own window class that doesn't have the CS_HREDRAW etc set
    static CWndClassInfo& GetWndClassInfo() 
    { 
        static CWndClassInfo wc = 
        { 
            { sizeof(WNDCLASSEX), 0, StartWindowProc, 
              0, 0, 0, 0, 0, 0 /*(HBRUSH) (COLOR_DESKTOP + 1) */, 0, TEXT("Outlook Express Address Book Control"), 0 }, 
              NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
        }; 
        return wc; 
    }
    CIEMsgAb();
    ~CIEMsgAb();

DECLARE_REGISTRY_RESOURCEID(IDR_BLVIEW)
    
BEGIN_COM_MAP(CIEMsgAb)
    COM_INTERFACE_ENTRY(IIEMsgAb)
    // COM_INTERFACE_ENTRY(IBrowserExtension)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IDeskBand)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IDropTarget)
    COM_INTERFACE_ENTRY(IInputObject)
    COM_INTERFACE_ENTRY(IOleCommandTarget)
//    COM_INTERFACE_ENTRY(IFontCacheNotify)
    COM_INTERFACE_ENTRY(IObjectWithSite)
//    COM_INTERFACE_ENTRY_IID(IID_IDropDownFldrBar, IDropDownFldrBar)
//    COM_INTERFACE_ENTRY(IMAPIAdviseSink)
//    COM_INTERFACE_ENTRY(IPersistStream)
    // COM_INTERFACE_ENTRY(IWABExtInit)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CIEMsgAb)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_CONNECTION_POINT_MAP(CIEMsgAb)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()


BEGIN_MSG_MAP(CIEMsgAb)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_WININICHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_MSGR_SHUTDOWN, OnMsgrShutDown)
    MESSAGE_HANDLER(WM_USER_STATUS_CHANGED, OnUserStateChanged)
    MESSAGE_HANDLER(WM_USER_MUSER_REMOVED, OnUserRemoved)
    MESSAGE_HANDLER(WM_MSGR_LOGOFF, OnUserLogoffEvent)
    MESSAGE_HANDLER(WM_MSGR_LOGRESULT, OnUserLogResultEvent)
    MESSAGE_HANDLER(WM_USER_MUSER_ADDED, OnUserAdded)
    MESSAGE_HANDLER(WM_USER_NAME_CHANGED, OnUserNameChanged)
    MESSAGE_HANDLER(WM_LOCAL_STATUS_CHANGED, OnLocalStateChanged)

    COMMAND_ID_HANDLER(ID_FIND_PEOPLE, CmdFind)
    COMMAND_ID_HANDLER(ID_ADDRESS_BOOK, CmdIEMsgAb)
    COMMAND_ID_HANDLER(ID_DELETE_CONTACT, CmdDelete)

//    COMMAND_ID_HANDLER(ID_NEW_MSG_DEFAULT, CmdNewMessage)
    COMMAND_ID_HANDLER(ID_PROPERTIES, CmdProperties)
    COMMAND_ID_HANDLER(ID_NEW_CONTACT, CmdNewContact)
    COMMAND_ID_HANDLER(ID_NEW_ONLINE_CONTACT, CmdNewOnlineContact)
    COMMAND_ID_HANDLER(ID_SET_ONLINE_CONTACT, CmdSetOnline)
    COMMAND_ID_HANDLER(ID_NEW_GROUP, CmdNewGroup)
    COMMAND_ID_HANDLER(ID_SEND_INSTANT_MESSAGE, CmdNewIMsg)
    COMMAND_ID_HANDLER(ID_SEND_INSTANT_MESSAGE2, CmdNewMessage)
    COMMAND_ID_HANDLER(ID_SEND_MESSAGE, CmdNewEmaile)
    COMMAND_ID_HANDLER(ID_NEW_MSG_DEFAULT, CmdNewEmaile)
    COMMAND_ID_HANDLER(ID_HOME_PHONE, CmdHomePhone)
    COMMAND_ID_HANDLER(ID_WORK_PHONE, CmdWorkPhone)
    COMMAND_ID_HANDLER(ID_MOBILE_PHONE, CmdMobilePhone)
    COMMAND_ID_HANDLER(ID_IP_PHONE, CmdIPPhone)
    COMMAND_ID_HANDLER(ID_DIAL_PHONE_NUMBER, CmdDialPhone)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_FONTCHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_QUERYNEWPALETTE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_PALETTECHANGED, OnSysParamsChange)

    NOTIFY_CODE_HANDLER(LVN_GETDISPINFOW, NotifyGetDisplayInfo)
    NOTIFY_CODE_HANDLER(LVN_GETINFOTIPW, NotifyGetInfoTip)
    NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, NotifyItemChanged)
    NOTIFY_CODE_HANDLER(LVN_DELETEITEM, NotifyDeleteItem)
    NOTIFY_CODE_HANDLER(LVN_ITEMACTIVATE, NotifyItemActivate)
    NOTIFY_CODE_HANDLER(NM_SETFOCUS, NotifySetFocus)
    NOTIFY_CODE_HANDLER(NM_KILLFOCUS, NotifyKillFocus)
END_MSG_MAP()

// CComControlBase

    HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
    {
        m_hwndParent = hWndParent; 
		return Create(hWndParent, rcPos, NULL, WS_CHILD | WS_TABSTOP | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 
                      WS_EX_CONTROLPARENT);
    } 
// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

// IQuickActivate
    STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl)
    {
        // $REVIEW - Someone updated the size of QACONTAINER to add two
        //           new members, pOleControlSite and pServiceProvider.
        //           This causes ATL to assert in a big way, but to 
        //           avoid the assert we tweek the structure size.  This
        //           is a bad thing. -- steveser
        pQACont->cbSize = sizeof(QACONTAINER);
        return (IQuickActivateImpl<CIEMsgAb>::QuickActivate(pQACont, pQACtrl));
    }

// IOleInPlaceActiveObjectImpl
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg)
    {
        if (lpmsg->message == WM_CHAR && lpmsg->wParam == VK_DELETE)
        {
            PostMessage(WM_COMMAND, ID_DELETE, 0);
            return (S_OK);
        }
        return (S_FALSE);
    }

// IIEMsgAb

public:
    STDMETHOD(get_InstMsg)(BOOL *pVal);
    HRESULT OnDraw(ATL_DRAWINFO& di);
	HRESULT ResizeChildWindows(LPCRECT prcPos = NULL);

   // IOleWindow methods
   STDMETHOD(GetWindow)(HWND* phwnd);
   STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

   STDMETHOD(Init) (REFGUID refguid);
   STDMETHOD(GetProperty)(SHORT iPropID, VARIANTARG * varProperty);

    // IDockingWindow methods
   STDMETHOD(ShowDW)(BOOL fShow);
   STDMETHOD(CloseDW)(DWORD dwReserved);
   STDMETHOD(ResizeBorderDW)(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);

   // IDeskBand methods
   STDMETHOD(GetBandInfo)(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi);

   // IDropTarget
    STDMETHOD(DragEnter)(THIS_ IDataObject *pDataObject, DWORD grfKeyState,
                         POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(THIS_ DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)(THIS);
    STDMETHOD(Drop)(THIS_ IDataObject *pDataObject, DWORD grfKeyState,
                    POINTL pt, DWORD *pdwEffect);

//IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID    *pguidCmdGroup, 
                                          ULONG         cCmds, 
                                          OLECMD        rgCmds[], 
                                          OLECMDTEXT    *pCmdText);
    HRESULT STDMETHODCALLTYPE Exec(const GUID   *pguidCmdGroup, 
                                    DWORD       nCmdID, 
                                    DWORD       nCmdExecOpt, 
                                    VARIANTARG  *pvaIn, 
                                    VARIANTARG  *pvaOut);


// IInputObject
    STDMETHOD(HasFocusIO)(THIS);
    STDMETHOD(TranslateAcceleratorIO)(THIS_ LPMSG lpMsg);
    STDMETHOD(UIActivateIO)(THIS_ BOOL fActivate, LPMSG lpMsg);

#ifdef LATER
/////////////////////////////////////////////////////////////////////////
// IFontCacheNotify
//
	STDMETHOD(OnPreFontChange)(void);
	STDMETHOD(OnPostFontChange)(void);
#endif
//     STDMETHOD(IOleObject_SetClientSite) (IOleClientSite *pClientSite) { return S_OK;}
//     STDMETHOD(IOleObject_GetClientSite) (IOleClientSite **ppClientSite){ return S_OK;}
//IObjectWithSite
    STDMETHOD(SetSite)(IUnknown  *punksite);
    STDMETHOD(GetSite)(REFIID  riid, LPVOID *ppvSite);

//IDropDownFolderBar
    HRESULT RegisterFlyOut(CFolderBar *pFolderBar);
    HRESULT RevokeFlyOut();

// IMAPIAdviseSink
    STDMETHOD_(ULONG, OnNotify)(ULONG cNotif, LPNOTIFICATION pNotifications);

// IShellPropSheetExt interface
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    // IWABExtInit interface
    STDMETHOD(Initialize)(LPWABEXTDISPLAY lpWED);

    // STDMETHOD (EventUserStateChanged)(THIS_ IBasicIMUser * pUser);

    LPMABENTRY AddBlabEntry(MABENUM tag, LPSBinary lpSB, LPMINFO lpMsgrInfo = NULL, WCHAR *pchMail = NULL, 
                                    WCHAR *pchDisplayName = NULL, BOOL fCert = FALSE, LPPNONEENTRIES  lpPhs = NULL);
    void CheckAndAddAbEntry(LPSBinary lpSB, WCHAR *pchEmail, WCHAR *pchDisplayName, DWORD nFlag, LPPNONEENTRIES pPhEnries);
    BOOL DontShowMessenger(void) { return (m_pCMsgrList ? m_pCMsgrList->IsLocalOnline() :(m_dwHideMessenger ? TRUE : (m_dwDisableMessenger ? TRUE : FALSE))); }
    BOOL HideViewMenu(void) { return(m_dwHideMessenger); }
    BOOL IsMessengerInstalled(void) { return (m_pCMsgrList ? TRUE : FALSE); }

// Message Handlers
private:
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT  nMsg , WPARAM  wParam , LPARAM  lParam , BOOL&  bHandled );

    LRESULT OnTimer(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
    {
        if(wParam == IDT_PANETIMER)
            _ReloadListview();
        return 0;
    }

    LRESULT OnSysParamsChange(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
    {
        m_ctlList.SendMessage(nMsg, wParam, lParam);

        return 0;
    }
    HRESULT OnMsgrShutDown(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserRemoved(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserLogoffEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserLogResultEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserAdded(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserNameChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnLocalStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);

    LRESULT CmdDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdIEMsgAb(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewOnlineContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewMessage(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewGroup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewEmaile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewIMsg(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdSetOnline(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//    LRESULT CmdMsgrOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT NewInstantMessage(LPMABENTRY pEntry);

    LRESULT CmdHomePhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdWorkPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdMobilePhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdIPPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdDialPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT NotifyDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyItemActivate(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyGetDisplayInfo(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyGetInfoTip(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
//     LRESULT NotifyColumnClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT CmdProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT NotifySetFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyKillFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // Utility Functions
    HRESULT _ResizeElements(LPCRECT prcPos = NULL, LPCRECT prcClip = NULL);
    void    _AutosizeColumns(void);
    void    _EnableCommands(void);
    HRESULT _DoDropMessage(LPMIMEMESSAGE pMessage);
    HRESULT _DoDropMenu(POINTL pt, LPMIMEMESSAGE pMessage);
    void    _ReloadListview(void);
    LRESULT SetUserIcon(LPMABENTRY pEntry, int nStatus, int * pImage);
    void AddMsgrListItem(LPMINFO lpMsgrInfo);
    HRESULT FillMsgrList();
    void RemoveBlabEntry(LPMABENTRY lpEntry);
    LPMABENTRY FindUserEmail(WCHAR *pchEmail, int *pIndex = NULL, BOOL fMsgrOnly = TRUE);
    LPMABENTRY GetSelectedEntry(void);
    LPMABENTRY GetEntryForSendInstMsg(LPMABENTRY pEntry = NULL);
    HRESULT PromptToGoOnline(void);
    void RemoveMsgrInfo(LPMINFO lpMsgrInfo);
    BOOL _FillPhoneNumber(UINT Id, OLECMDTEXT *cmdText);
    LRESULT CallPhone(WCHAR *szPhone, BOOL fMessengerContact);

    // Member Data
private:
    // Address Book Object
    CAddressBookData  m_cAddrBook;

    // Child windows
    CContainedWindow m_ctlList;         // Displays the list of people

    HIMAGELIST              m_himl;
    DWORD                   m_dwFontCacheCookie;        // For the Advise on the font cache
    CEmptyList              m_cEmptyList;
    WCHAR *                 m_szOnline;
    // TCHAR *                 m_szInvisible;
    WCHAR *                 m_szBusy;
    WCHAR *                 m_szBack;
    WCHAR *                 m_szAway;
    WCHAR *                 m_szOnPhone;
    WCHAR *                 m_szLunch;
    WCHAR *                 m_szOffline;
    WCHAR *                 m_szIdle;
    WCHAR *                 m_szEmptyList;
    WCHAR *                 m_szMsgrEmptyList;
    WCHAR *                 m_szLeftBr;
    WCHAR *                 m_szRightBr;
    BOOL                    m_fNoRemove:1;
    BOOL                    m_fShowAllContacts:1;
    BOOL                    m_fShowOnlineContacts:1;
    BOOL                    m_fShowOfflineContacts:1;
    BOOL                    m_fShowEmailContacts:1;
    BOOL                    m_fShowOthersContacts:1;
    BOOL                    m_fWAB:1;
    BOOL                    m_fRight:1;
    BOOL                    m_fLogged:1;
    int                     m_delItem;
    DWORD                   m_dwHideMessenger;
    DWORD                   m_dwDisableMessenger;

    // Drag & Drop stuff
    IDataObject     *m_pDataObject;
    CLIPFORMAT       m_cf;

    // Properties
    //Site ptr
    IInputObjectSite *m_pObjSite;

    HWND             m_hwndParent;
    CFolderBar       *m_pFolderBar;

    int m_nSortType;
    CMsgrList *m_pCMsgrList;        // pointer to OE Msgr

    int             m_nChCount;

    // WAB extension
    UINT            m_cRefThisDll;     // Reference count for this DLL
    HPROPSHEETPAGE  m_hPage1; // Handle to the property sheet page

    LPWABEXTDISPLAY m_lpWED;

    LPWABEXTDISPLAY m_lpWEDContext;
    LPMAPIPROP      m_lpPropObj; // For context menu extensions, hang onto the prop obj

};

int CALLBACK BA_Sort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
INT_PTR CALLBACK WabExtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#define AthMessageBox(hwnd, pszT, psz1, psz2, fu) MessageBoxInst(g_hLocRes, hwnd, pszT, psz1, psz2, fu)
#define AthMessageBoxW(hwnd, pwszT, pwsz1, pwsz2, fu) MessageBoxInstW(g_hLocRes, hwnd, pwszT, pwsz1, pwsz2, fu, LoadStringWrapW, MessageBoxWrapW)

LPWSTR AthLoadString(UINT id, LPWSTR sz, int cch);
LPSTR ANSI_AthLoadString(UINT id, TCHAR* sz, int cch);
HMENU LoadPopupMenu(UINT id);
void MenuUtil_BuildMenuIDList(HMENU hMenu, OLECMD **prgCmds, ULONG *pcStart, ULONG *pcCmds);
HRESULT MenuUtil_EnablePopupMenu(HMENU hPopup, CIEMsgAb *pTarget);



#endif //__BAUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\baprop.h ===
// baprop.h
// WAB & Messenger integration to OE
// Created 06/23/98 by YST
//
//////////////////////////////////////////////////////////////////////

#ifndef __BAPROP_H_
#define __BAPROP_H_

#include "pch.hxx"
#include "badata.h"
// #include "demand.h"

// Definitions
void AddCBEmailItem(HWND hWndCB, LPTSTR  lpszEmailAddress, BOOL fDefault, LPTSTR lpszPendName);
INT_PTR CALLBACK WabExtDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
void AddAccountsToList(HWND hDlg, LPWABEXTDISPLAY lpWED, LPTSTR lpszPendName = NULL);
void SetAsDefault(HWND hDlg, LPWABEXTDISPLAY lpWED);
void AddMsgrId(HWND hDlg, LPWABEXTDISPLAY lpWED);
void SetDefaultID(TCHAR *szName, HWND hdlg, LPWABEXTDISPLAY lpWED);
BOOL AsciiTrimSpaces(TCHAR * szBuf);
HRESULT AddPropToMVPString(LPWABEXTDISPLAY lpWED, LPSPropValue lpaProps, DWORD cProps, DWORD index, LPTSTR lpszNew);
void WabSendIMsg(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL InitFonts(void);
void DeleteFonts(void);
BOOL WabIsItemOnline(HWND hDlg, int iItem);

#endif // __BAPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\gwnote\resource.h ===
//
// resource.h
//
// contains global resource identifiers
//

#ifndef __RESOURCE_H_
#define __RESOURCE_H_

#define RT_FILE                         2110

/////////////////////////////////////////////////////////////////////////////
//
//  * * * RESOURCE NAMING CONVENTIONS * * *
//
/////////////////////////////////////////////////////////////////////////////
//
//  Resource Type       Prefix      Comments
//  -------------       ------      --------
//
//  String              ids         menu help strings should end in MH
//  Menu command        idm
//  Menu resource       idmr
//  Bitmap              idb
//  Icon                idi
//  Animation           idan
//  Dialog              idd
//  Dialog control      idc
//  Cursor              idcur
//  Raw RCDATA          idr
//  Accelerator         idac
//  Window              idw
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN String Resource IDs
//
// MENU HELP strings
#define MH_BASE                         1
#define idsNewMsgMH                     (idmNewMsg + MH_BASE)
#define idsNewMsg2MH                    (idmNewMsg2 + MH_BASE)
#define idsNewContactMH                 (idmNewContact + MH_BASE)
#define idsHelpAboutMH                  (idmHelpAbout + MH_BASE)
#define idsPrintMH                      (idmPrint + MH_BASE)
#define idsCompactAllMH                 (idmCompactAll + MH_BASE)
#define idsSpellingMH                   (idmSpelling + MH_BASE)
#define idsOpenMH                       (idmOpen + MH_BASE)
#define idsSaveAsMH                     (idmSaveAs + MH_BASE)
#define idsSaveAttachMH                 (idmSaveAttach + MH_BASE)
#define idsSubscribeNewsMH              (idmSubscribeNews + MH_BASE)
#define idsSubscribeGroupMH             (idmSubscribeGroup + MH_BASE)
#define idsConnectMH                    (idmConnect + MH_BASE)
#define idsPropertiesMH                 (idmProperties + MH_BASE)
#define idsUndoMH                       (idmUndo + MH_BASE)
#define idsCutMH                        (idmCut + MH_BASE)
#define idsCopyMH                       (idmCopy + MH_BASE)
#define idsPasteMH                      (idmPaste + MH_BASE)
#define idsSelectAllMH                  (idmSelectAll + MH_BASE)
#define idsMarkReadMH                   (idmMarkRead + MH_BASE)
#define idsMarkTopicReadMH              (idmMarkTopicRead + MH_BASE)
#define idsMarkAllReadMH                (idmMarkAllRead + MH_BASE)
#define idsMarkDownloadMH               (idmMarkDownload + MH_BASE)
#define idsMarkTopicDownloadMH          (idmMarkTopicDownload + MH_BASE)
#define idsFindMH                       (idmFind + MH_BASE)
#define idsFindNextMH                   (idmFindNext + MH_BASE)
#define idsViewDecryptMH                (idmViewDecrypt + MH_BASE)
#define idsColumnsMH                    (idmColumns + MH_BASE)
#define idsNextMH                       (idmNext + MH_BASE)
#define idsPreviousMH                   (idmPrevious + MH_BASE)
#define idsNewArticleMH                 (idmNewArticle + MH_BASE)
#define idsNewArticle2MH                (idmNewArticle2 + MH_BASE)
#define idsReplyPostMH                  (idmReplyPost + MH_BASE)
#define idsReplyMailMH                  (idmReplyMail + MH_BASE)
#define idsForwardMH                    (idmForward + MH_BASE)
#define idsGetNextHeadersMH             (idmGetNextHeaders + MH_BASE)
#define idsHelpTopicsMH                 (idmHelpTopics + MH_BASE)
#define idsGotoNewsgroupMH              (idmGotoNewsgroup + MH_BASE)
#define idsViewContactsMH               (idmViewContacts + MH_BASE)
#define idsPopupOfflineMH               (idmPopupOffline + MH_BASE)
#define idsPopupArrangeMH               (idmPopupArrange + MH_BASE)
#define idsFindTextMH                   (idmFindText + MH_BASE)
#define idsReplyMH                      (idmReply + MH_BASE)
#define idsReplyAllMH                   (idmReplyAll + MH_BASE)
#define idsGotoInboxMH                  (idmGotoInbox + MH_BASE)
#define idsDeliverMailMH                (idmDeliverMail + MH_BASE)
#define idsMoveToMH                     (idmMoveTo + MH_BASE)
#define idsCopyToMH                     (idmCopyTo + MH_BASE)
#define idsFldrCreateMH                 (idmFldrCreate + MH_BASE)
#define idsFldrCreate2MH                (idmFldrCreate2 + MH_BASE)
#define idsFldrRenameMH                 (idmFldrRename + MH_BASE)
#define idsFldrEmptyMH                  (idmFldrEmpty + MH_BASE)
#define idsDeleteMH                     (idmDelete + MH_BASE)
#define idsPopupImportMH                (idmPopupImport + MH_BASE)
#define idsPopupExportMH                (idmPopupExport + MH_BASE)
#define idsImportAddressBookMH          (idmImportAddressBook + MH_BASE)
#define idsImportMessagesMH             (idmImportMessages + MH_BASE)
#define idsImportAcctsMH                (idmImportAccts + MH_BASE)
#define idsExportAddressBookMH          (idmExportAddressBook + MH_BASE)
#define idsExportMessagesMH             (idmExportMessages + MH_BASE)
#define idsMarkUnreadMH                 (idmMarkUnread + MH_BASE)
#define idsPopupPreviewMH               (idmPopupPreview + MH_BASE)
#define idsThreadArticlesMH             (idmThreadArticles + MH_BASE)
#define idsViewAllArticlesMH            (idmViewAllArticles + MH_BASE)
#define idsViewUnreadArticlesMH         (idmViewUnreadArticles + MH_BASE)
#define idsCombineAndDecodeMH           (idmCombineAndDecode + MH_BASE)
#define idsViewNewGroupsMH              (idmViewNewGroups + MH_BASE)
#define idsPrintNowMH                   (idmPrintNow + MH_BASE)
#define idsForwardMsgAttachMH           (idmForwardMsgAttach + MH_BASE)
#define idsSortToggleMH                 (idmSortToggle + MH_BASE)
#define idsFldrCompactMH                (idmFldrCompact + MH_BASE)
#define idsExpandThreadMH               (idmExpandThread + MH_BASE)
#define idsCollapseThreadMH             (idmCollapseThread + MH_BASE)
#define idsCancelArticleMH              (idmCancelArticle + MH_BASE)
#define idsAddToWABMH                   (idmAddrObj_AddToWAB + MH_BASE)
#define idsReadmeMH                     (idmReadme + MH_BASE)
#define idsLanguagePopupMH              (idmLanguagePopup + MH_BASE)
#define idsCleanUpFilesMH               (idmCleanUpFiles + MH_BASE)
#define idsCustomizeToolbarMH           (idmCustomizeToolbar + MH_BASE)
#define idsInboxRulesMH                 (idmInboxRules + MH_BASE)
#define idsPostAndDownloadMH            (idmPostAndDownload + MH_BASE)
#define idsSaveMessageMH                (idmSaveMessage + MH_BASE)     
#define idsMarkNewsgroupsMH             (idmMarkNewsgroups + MH_BASE)
#define idsMarkAllDownloadMH            (idmMarkAllDownload + MH_BASE)
#define idsUnmarkMH                     (idmUnmark + MH_BASE)
#define idsReplyPostAndMailMH           (idmReplyPostAndMail + MH_BASE)
#define idsDisconnectMH                 (idmDisconnect + MH_BASE)
#define idsHelpMSWebMH                  (idmHelpMSWeb + MH_BASE)
#define idsViewNewsMH                   (idmViewNews + MH_BASE)
#define idsViewMailMH                   (idmViewMail + MH_BASE)
#define idsBrowseWebMH                  (idmBrowseWeb + MH_BASE)
#define idsStopMH                       (idmStop + MH_BASE)
#define idsViewTipOfTheDayMH            (idmViewTipOfTheDay + MH_BASE)
#define idsViewRefreshMH                (idmViewRefresh + MH_BASE)
#define idsUnDeleteMH                   (idmUnDelete + MH_BASE)
#define idsExpungeMH                    (idmExpunge + MH_BASE)
#define idsViewDeletedArticlesMH        (idmViewDeletedArticles + MH_BASE)
#define idsFoldersMH                    (idmFolders + MH_BASE)
#define idsSubscribeFolderMH            (idmSubscribeFolder + MH_BASE)
#define idsDownloadAttachMH             (idmDownloadAttach + MH_BASE)
#define idsViewFilteredArticlesMH       (idmViewFilteredArticles + MH_BASE)
//#define idsDigSignMH                    (idmDigSign + MH_BASE)
//#define idsEncryptMH                    (idmEncrypt + MH_BASE)
#define idsSaveAttachAllMH              (idmSaveAttachAll + MH_BASE)
#define idsRefreshFoldersMH             (idmRefreshFolders + MH_BASE)
#define idsSpoolerWarningsMH            (idmSpoolerWarnings + MH_BASE)
#define idsSpoolerShowMH                (idmSpoolerShow + MH_BASE)

// TOOLTIP strings
#define TT_BASE                         (IDM_LAST + MH_BASE + 1)
#define idsNewMsg                       (idmNewMsg + TT_BASE)
#define idsNewContactTT                 (idmNewContact + TT_BASE)
#define idsPrint                        (idmPrint + TT_BASE)
#define idsNextUnreadNewsgroup          (idmNextUnreadNewsgroup + TT_BASE)
#define idsNextUnreadArticle            (idmNextUnreadArticle + TT_BASE)
#define idsNextUnreadTopic              (idmNextUnreadThread + TT_BASE)
#define idsMarkRead                     (idmMarkRead + TT_BASE)
#define idsConnect                      (idmConnect + TT_BASE)
#define idsMarkDownload                 (idmMarkDownload + TT_BASE)
#define idsFind                         (idmFind + TT_BASE)
#define idsSpellingTT                   (idmSpelling + TT_BASE)
#define idsNewArticleTT                 (idmNewArticle + TT_BASE)
#define idsReplyPostTT                  (idmReplyPost + TT_BASE)
#define idsReplyMailTT                  (idmReplyMail + TT_BASE)
#define idsForwardTT                    (idmForward + TT_BASE)
#define idsPrintNowTT                   (idmPrintNow + TT_BASE)
#define idsReplyTT                      (idmReply + TT_BASE)
#define idsReplyAllTT                   (idmReplyAll + TT_BASE)
#define idsGotoInboxTT                  (idmGotoInbox + TT_BASE)
#define idsDeliverMailTT                (idmDeliverMail + TT_BASE)
#define idsUndoTT                       (idmUndo + TT_BASE)
#define idsDeleteTT                     (idmDelete + TT_BASE)
#define idsSendMsgTT                    (idmSendMsg + TT_BASE)
#define idsSaveTT                       (idmSave + TT_BASE)
#define idsCutTT                        (idmCut + TT_BASE)
#define idsCopyTT                       (idmCopy + TT_BASE)
#define idsPasteTT                      (idmPaste + TT_BASE)
#define idsCheckNamesTT                 (idmCheckNames + TT_BASE)
#define idsPickRecipientsTT             (idmPickRecipients + TT_BASE)
#define idsInsertFileTT                 (idmInsertFile + TT_BASE)
#define idsPreviousTT                   (idmPrevious + TT_BASE)
#define idsNextTT                       (idmNext + TT_BASE)
#define idsFindTextTT                   (idmFindText + TT_BASE)
#define idsFmtSizeTT                    (idmFmtSize + TT_BASE)
#define idsFmtColorTT                   (idmFmtColor + TT_BASE)
#define idsFmtBoldTT                    (idmFmtBold + TT_BASE)
#define idsFmtItalicTT                  (idmFmtItalic + TT_BASE)
#define idsFmtUnderlineTT               (idmFmtUnderline + TT_BASE)
#define idsFmtBulletsTT                 (idmFmtBullets + TT_BASE)
#define idsFmtDecreaseIndentTT          (idmFmtDecreaseIndent + TT_BASE)
#define idsFmtIncreaseIndentTT          (idmFmtIncreaseIndent + TT_BASE)
#define idsFmtLeftTT                    (idmFmtLeft + TT_BASE)
#define idsFmtCenterTT                  (idmFmtCenter + TT_BASE)
#define idsFmtRightTT                   (idmFmtRight + TT_BASE)
#define idsPostMsgTT                    (idmPostMsg + TT_BASE)
#define idsMarkAllReadTT                (idmMarkAllRead + TT_BASE)
#define idsMarkTopicReadTT              (idmMarkTopicRead + TT_BASE)
#define idsMarkTopicDownloadTT          (idmMarkTopicDownload + TT_BASE)
#define idsInsertSigTT                  (idmInsertSig + TT_BASE)
#define idsViewContactsTT               (idmViewContacts + TT_BASE)
#define idsSaveAsTT                     (idmSaveAs + TT_BASE)
#define idsUnDeleteTT                   (idmUnDelete + TT_BASE)
#define idsExpungeTT                    (idmExpunge + TT_BASE)
#define idsViewDeletedArticlesTT        (idmViewDeletedArticles + TT_BASE)
#define idsFoldersTT                    (idmFolders + TT_BASE)
#define idsSubscribeFolderTT            (idmSubscribeFolder + TT_BASE)
#define idsDownloadAttachTT             (idmDownloadAttach + TT_BASE)
#define idsDigSignTT                    (idmDigSign + TT_BASE)
#define idsEncryptTT                    (idmEncrypt + TT_BASE)
#define idsLanguage                     (idmLangFirst + TT_BASE)
#define idsFolderListTT                 (idmViewFolders + TT_BASE)
#define idsSpoolerWarningsTT            (idmSpoolerWarnings + TT_BASE)
#define idsSpoolerShowTT                (idmSpoolerShow + TT_BASE)
#define idsDownloadAccountTT            (idmSyncAccount + TT_BASE)
#define idsDownloadNewsgroupTT          (idmSyncSelected + TT_BASE)
#define idsPostDefaultTT                (idmPostDefault + TT_BASE)
#define idsSendDefaultTT                (idmSendDefault + TT_BASE)
#define idsViewRefreshTT                (idmViewRefresh + TT_BASE)
#define idsPurgeTT                      (idmExpunge + TT_BASE)

// regular strings (not tooltips and not menu help strings)
#define STR_FIRST                       (IDM_LAST + TT_BASE + 1)
#define idsAthena                       (STR_FIRST + 8)
#define idsAthenaMail                   idsAthena
#define idsAthenaNews                   idsAthena
#define idsNlogErrConnClosed            (STR_FIRST + 10)
#define idsNlogIConnect                 (STR_FIRST + 11)
#define idsNlogErrConnError             (STR_FIRST + 12)
#define idsTo                           (STR_FIRST + 13)
#define idsFrom                         (STR_FIRST + 14)
#define idsSubject                      (STR_FIRST + 15)
#define idsReceived                     (STR_FIRST + 16)
#define idsSent                         (STR_FIRST + 17)
#define idsSize                         (STR_FIRST + 18)

// keep the mailview column description string ids in sequence
#define idsFromField                    (STR_FIRST + 21)
#define idsToField                      (STR_FIRST + 22)
#define idsCcField                      (STR_FIRST + 23)
#define idsSubjectField                 (STR_FIRST + 24)
#define idsTTFormattingFont             (STR_FIRST + 25)
#define idsTTFormattingSize             (STR_FIRST + 27)
#define idsAutoColor                    (STR_FIRST + 31)
#define idsColor1                       (STR_FIRST + 32)
#define idsColor2                       (STR_FIRST + 33)
#define idsColor3                       (STR_FIRST + 34)
#define idsColor4                       (STR_FIRST + 35)
#define idsColor5                       (STR_FIRST + 36)
#define idsColor6                       (STR_FIRST + 37)
#define idsColor7                       (STR_FIRST + 38)
#define idsColor8                       (STR_FIRST + 39)
#define idsColor9                       (STR_FIRST + 40)
#define idsColor10                      (STR_FIRST + 41)
#define idsColor11                      (STR_FIRST + 42)
#define idsColor12                      (STR_FIRST + 43)
#define idsColor13                      (STR_FIRST + 44)
#define idsColor14                      (STR_FIRST + 45)
#define idsColor15                      (STR_FIRST + 46)
#define idsColor16                      (STR_FIRST + 47)
#define idsSmapiClose                   (STR_FIRST + 48)
#define idsHideHotmailMenu              (STR_FIRST + 49)
#define idsNewsgroups                   (STR_FIRST + 52)
#define idsDescription                  (STR_FIRST + 53)
#define idsEmptyTo                      (STR_FIRST + 60)
#define idsEmptyCc                      (STR_FIRST + 61)
#define idsEmptySubject                 (STR_FIRST + 62)
#define idsNoCcOrTo                     (STR_FIRST + 63)
#define idsNoSubject                    (STR_FIRST + 64)
#define idsTTTo                         (STR_FIRST + 65)
#define idsTTCc                         (STR_FIRST + 66)
#define idsTTSubject                    (STR_FIRST + 67)
#define idsTTRecipients                 (STR_FIRST + 68)
#define idsTTStampForSendnote           (STR_FIRST + 69)
#define idsSaveChangesMsg               (STR_FIRST + 71)
#define idsCantSaveMsg                  (STR_FIRST + 72)
#define idsCantDeleteMsg                (STR_FIRST + 73)
#define idsNewsgroupsField              (STR_FIRST + 81)
#define idsEmptyNewsgroups              (STR_FIRST + 82)
#define idsDateField                    (STR_FIRST + 83)
#define idsErrInvalidGroup              (STR_FIRST + 84)
#define idsWantToSubscribe              (STR_FIRST + 85)
#define idsWantToUnSubscribe            (STR_FIRST + 89)
#define idsUnsubscribeMenu              (STR_FIRST + 90)
#define idsSubscribeMenu                (STR_FIRST + 91)
#define idsErrNewsCantReply             (STR_FIRST + 92)
#define idsHTMLErrNewsCantOpen          (STR_FIRST + 93)
#define idsErrAttmanLoadFail            (STR_FIRST + 94)

#define idsSaveAttachmentAs             (STR_FIRST + 97)
#define idsNoFromField                  (STR_FIRST + 102)
#define idsTTNewsgroups                 (STR_FIRST + 103)
#define idsDownloadArtTitle             (STR_FIRST + 104)
#define idsDownloadArtMsg               (STR_FIRST + 105)
#define idsErrNoPoster                  (STR_FIRST + 106)
#define idsDownloadingGroups            (STR_FIRST + 110)
#define idsSortingGroups                (STR_FIRST + 111)
#define idsDownloadingDesc              (STR_FIRST + 112)
#define idsWritingFile                  (STR_FIRST + 113)
#define idsUnknown                      (STR_FIRST + 114)
#define idsNewsLogon                    (STR_FIRST + 116)
#define idsShowDetails                  (STR_FIRST + 117)
#define idsHideDetails                  (STR_FIRST + 118)
#define idsFilterAttSave                (STR_FIRST + 129)
#define idsCompose                      (STR_FIRST + 139)
#define idsPostReply                    (STR_FIRST + 140)
#define idsMailReply                    (STR_FIRST + 141)
#define idsForward                      (STR_FIRST + 142)
#define idsReply                        (STR_FIRST + 144)
#define idsReplyAll                     (STR_FIRST + 145)
#define idsDefMailExt                   (STR_FIRST + 148)
#define idsDefNewsExt                   (STR_FIRST + 149)
#define idsNewsSaveAsTitle              (STR_FIRST + 150)
#define idsMailSaveAsTitle              (STR_FIRST + 151)
#define idsUnableToSaveMessage          (STR_FIRST + 152)

#define idsDownloadingHeaders           (STR_FIRST + 172)
#define idsDownloadingArticle           (STR_FIRST + 173)
#define idsNewsStatus                   (STR_FIRST + 174)
#define idsErrPeerClosed                (STR_FIRST + 179)
#define idsErrAuthenticate              (STR_FIRST + 193)

// Options Spelling dialog strings
#define idsSpellClose                   (STR_FIRST + 201)
#define idsSpellCaption                 (STR_FIRST + 202)
#define idsSpellRepeatWord              (STR_FIRST + 203)
#define idsSpellWordNeedsCap            (STR_FIRST + 204)
#define idsSpellWordNotFound            (STR_FIRST + 205)
#define idsSpellNoSuggestions           (STR_FIRST + 206)
#define idsSpellDelete                  (STR_FIRST + 207)
#define idsSpellDeleteAll               (STR_FIRST + 208)
#define idsSpellChange                  (STR_FIRST + 209)
#define idsSpellChangeAll               (STR_FIRST + 210)
#define idsSpellMsgDone                 (STR_FIRST + 212)
#define idsSpellMsgContinue             (STR_FIRST + 213)
#define idsSpellMsgConfirm              (STR_FIRST + 214)
#define idsSpellMsgSendOK               (STR_FIRST + 215)

#define idsErrSpellGenericSpell         (STR_FIRST + 221)
#define idsErrSpellGenericLoad          (STR_FIRST + 222)
#define idsErrSpellMainDictLoad         (STR_FIRST + 223)
#define idsErrSpellVersion              (STR_FIRST + 224)
#define idsErrSpellUserDictLoad         (STR_FIRST + 226)
#define idsErrSpellUserDictOpenRO       (STR_FIRST + 227)
#define idsErrSpellCacheWordLen         (STR_FIRST + 230)
#define idsPrefixReply                  (STR_FIRST + 231)
#define idsPrefixForward                (STR_FIRST + 232)
#define idsErrCannotOpenMailMsg         (STR_FIRST + 233)
#define idsErrSpellLangChanged          (STR_FIRST + 234)
#define idsErrSpellWarnDictionary       (STR_FIRST + 235)

#ifdef  WIN16   // Because Win16 don't have long file name support!!!
#define idsInboxFile                    (STR_FIRST + 236)
#define idsOutboxFile                   (STR_FIRST + 237)
#define idsSentItemsFile                (STR_FIRST + 238)
#define idsDeletedItemsFile             (STR_FIRST + 239)
#define idsDraftFile                    (STR_FIRST + 240)
#define idsNewsOutboxFile               (STR_FIRST + 241)
#endif

// keep this contiguous please, or i'll kill you
#define idsInbox                        (STR_FIRST + 242)
#define idsOutbox                       (STR_FIRST + 243)
#define idsSentItems                    (STR_FIRST + 244)
#define idsDeletedItems                 (STR_FIRST + 245)
#define idsDraft                        (STR_FIRST + 246)
#define idsSharedInbox                  (STR_FIRST + 247)
// keep this contiguous please, or i'll kill you

#define idsAllFilesFilter               (STR_FIRST + 248)
#define idsTextFileFilter               (STR_FIRST + 249)
#define idsLinkExtension                (STR_FIRST + 251)
#define idsAttach                       (STR_FIRST + 252)
#define idsInsertAttachment             (STR_FIRST + 253)
#define idsOverwriteFile                (STR_FIRST + 254)
#define idsDropLinkDirs                 (STR_FIRST + 255)
#define idsAttConfirmDeletion           (STR_FIRST + 256)
#define idsTextOrHtmlFileFilter         (STR_FIRST + 257)

// leave a little space for addrview stuff...
// end addrview strings

#define idsErrCreateNewFld              (STR_FIRST + 259)
#define idsErrRenameFld                 (STR_FIRST + 260)
#define idsErrDeleteFld                 (STR_FIRST + 261)
#define idsWarnDeleteFolder             (STR_FIRST + 262)
#define idsErrRenameSpecialFld          (STR_FIRST + 263)
#define idsErrFolderNameConflict        (STR_FIRST + 264)
#define idsErrBadFolderName             (STR_FIRST + 265)
#define idsErrDeleteSpecialFolder       (STR_FIRST + 266)
#define idsWarnEmptyDeletedItems        (STR_FIRST + 267)
#define idsWarnPermDelete               (STR_FIRST + 268)
#define idsWarnPermDeleteSome           (STR_FIRST + 269)
#define idsErrStartupFailed             (STR_FIRST + 270)
#define idsDoYouWantToSave              (STR_FIRST + 274)
#define idsXMsgsYUnread                 (STR_FIRST + 277)
#define idsXMsgs                        (STR_FIRST + 278)
#define idsErrNoRecipients              (STR_FIRST + 299)

#define idsPropPageSecurity             (STR_FIRST + 301)
#define idsPropPageGeneral              (STR_FIRST + 302)
#define idsPropPageDetails              (STR_FIRST + 303)
#define idsErrReplyForward              (STR_FIRST + 304)
#define idsShowFavorites                (STR_FIRST + 310)
#define idsNewArticleTitle              (STR_FIRST + 311)
#define idsAttDefaultName               (STR_FIRST + 313)
#define idsErrNoGroupsFound             (STR_FIRST + 314)
#define idsErrCantResolveGroup          (STR_FIRST + 315)
#define idsEmptySubjectRO               (STR_FIRST + 316)
#define idsReplyTextPrefix              (STR_FIRST + 318)
#define idsMailRundllFailed             (STR_FIRST + 319)
#define idsNewsRundllFailed             (STR_FIRST + 320)
#define idsRecipient                    (STR_FIRST + 322)
#define idsWarnMultipleOpens            (STR_FIRST + 323)
#define idsNoNewGroupsAvail             (STR_FIRST + 328)
#define idsNewGroups                    (STR_FIRST + 329)
#define idsDllExpired                   (STR_FIRST + 332)
#define idsErrNoSubject                 (STR_FIRST + 333)
#define idsEmlFileFilter                (STR_FIRST + 334)
#define idsNwsFileFilter                (STR_FIRST + 335)
#define idsBase64                       (STR_FIRST + 338)
#define idsQuotedPrintable              (STR_FIRST + 339)
#define idsEnterPollTime                (STR_FIRST + 342)
#define idsEnterSigText                 (STR_FIRST + 345)
#define idsEnterSigFile                 (STR_FIRST + 346)
#define idsOptions                      (STR_FIRST + 347)
#define idsWarnSigTruncated             (STR_FIRST + 348)
#define idsWarnSigNotFound              (STR_FIRST + 350)
#define idsWarnSigBinary                (STR_FIRST + 351)
#define idsDLChecking                   (STR_FIRST + 352)
#define idsWarnUnsentMail               (STR_FIRST + 355)
#define idsErrRemoveServer              (STR_FIRST + 358)
#define idsEnterPreviewTime             (STR_FIRST + 361)
#define idsEnterDownloadChunks          (STR_FIRST + 362)
#define idsSBSending                    (STR_FIRST + 367)
#define idsSBReceiving                  (STR_FIRST + 368)
#define idsSBConnecting                 (STR_FIRST + 369)
#define idsSBNoNewMsgs                  (STR_FIRST + 370)
#define idsSBNewMsgsControl             (STR_FIRST + 371)
#define idsSBChecking                   (STR_FIRST + 372)
#define idsPropAttachNone               (STR_FIRST + 373)
#define idsUnderComp                    (STR_FIRST + 375)
#define idsSortAsc                      (STR_FIRST + 376)
#define idsSortMenuHelpControl          (STR_FIRST + 377)
#define idsReplyTextAppend              (STR_FIRST + 378)
#define idsErrPreviewLoadFail           (STR_FIRST + 379)
#define idsCharsetMapChange             (STR_FIRST + 380)

#define idsDisplayFavoritesDlg          (STR_FIRST + 383)
#define idsNoNewsgroupParen             (STR_FIRST + 384)
#define idsNewsStatusNoServer           (STR_FIRST + 385)
#define idsNone                         (STR_FIRST + 387)
#define idsAuthorizing                  (STR_FIRST + 389)
#define idsPropNoSubject                (STR_FIRST + 390)
#define idsErrNoMailInstalled           (STR_FIRST + 394)
#define idsErrCantCompactFolder         (STR_FIRST + 395)
#define idsErrCantCompactInUse          (STR_FIRST + 396)
#define idsCompactStore                 (STR_FIRST + 397)
#define idsRenameFolderTitle            (STR_FIRST + 398)
#define idsTabSubscribed                (STR_FIRST + 399)
#define idsTabAll                       (STR_FIRST + 400)
#define idsTabNew                       (STR_FIRST + 401)
#define idsFile                         (STR_FIRST + 402)
#define idsVersion                      (STR_FIRST + 403)
#define idsFollowupToField              (STR_FIRST + 404)
#define idsReplyToField                 (STR_FIRST + 405)
#define idsOrgField                     (STR_FIRST + 406)
#define idsDistributionField            (STR_FIRST + 407)
#define idsKeywordsField                (STR_FIRST + 408) 
#define idsApprovedField                (STR_FIRST + 409)

// Address Book Strings
#define idsPickNamesTitle               (STR_FIRST + 410)
#define idsGeneralWabError              (STR_FIRST + 412)

#define idsStartupError                 (STR_FIRST + 413)
#define idsEmptyFollowupTo              (STR_FIRST + 415)
#define idsEmptyDistribution            (STR_FIRST + 416)
#define idsEmptyKeywords                (STR_FIRST + 417)
#define idsEmptyReplyTo                 (STR_FIRST + 418)
#define idsNotSpecified                 (STR_FIRST + 419)                                   
#define idsVerifyCancel                 (STR_FIRST + 420)
#define idsCantCancel                   (STR_FIRST + 421)
#define idsCancelFailed                 (STR_FIRST + 422)
#define idsErrRemoveServerInUse         (STR_FIRST + 423)
#define idsHTMLPressSpaceToDownload     (STR_FIRST + 425)
#define idsEnterAutoWrap                (STR_FIRST + 427)
#define idsLines                        (STR_FIRST + 428)
#define idsReadingCachedHeaders         (STR_FIRST + 436)
#define idsErrEmptyMessage              (STR_FIRST + 437)
#define idsErrOnlyQuotedText            (STR_FIRST + 438)
#define idsErrLinesLongerThan80         (STR_FIRST + 439)
#define idsErrTooMuchQuoted             (STR_FIRST + 440)

#define idsMsgRecipients                (STR_FIRST + 441)
#define idsErrAddToWAB                  (STR_FIRST + 442)
#define idsErrAddrProps                 (STR_FIRST + 443)
#define idsErrBadRecipients             (STR_FIRST + 444)
#define idsErrDeleteMsg                 (STR_FIRST + 445)
#define idsErrPickNames                 (STR_FIRST + 446)
#define idsErrAddrDupe                  (STR_FIRST + 447)

#define idsControlField                 (STR_FIRST + 448)
#define idsTTControl                    (STR_FIRST + 449)

#define idsErrConfigureServer           (STR_FIRST + 450)
#define idsErrCantForward               (STR_FIRST + 451)
#define idsErrAddCertToWAB              (STR_FIRST + 452)
#define idsErrOpenManyMessages          (STR_FIRST + 453)
#define idsIgnoreResolveError           (STR_FIRST + 458)

#define idsErrSendMail                  (STR_FIRST + 473)
#define idsErrStoreInit                 (STR_FIRST + 475)
#define idsErrMailInit                  (STR_FIRST + 476)
#define idsErrDelete                    (STR_FIRST + 478)
#define idsErrImport                    (STR_FIRST + 480)
#define idsErrImportLoad                (STR_FIRST + 481)
#define idsHTMLErrNewsExpired           (STR_FIRST + 483)
#define idsBack                         (STR_FIRST + 484)
#define idsNext                         (STR_FIRST + 485)

#define idsTTFollowup                   (STR_FIRST + 510)
#define idsTTDistribution               (STR_FIRST + 511)
#define idsTTKeywords                   (STR_FIRST + 512)
#define idsTTReplyTo                    (STR_FIRST + 513)
#define idsTTApproved                   (STR_FIRST + 514)
#define idsTTPickNewsgroups             (STR_FIRST + 515)
#define idsErrDeleteOnExit              (STR_FIRST + 518)
#define idsFolderLocked                 (STR_FIRST + 519)
#define idsGenericError                 (STR_FIRST + 520)
#define idsCcWell                       (STR_FIRST + 521)
#define idsErrOnlyOneReplyTo            (STR_FIRST + 522)
#define idsReplyToWell                  (STR_FIRST + 523)
#define idsErrMove                      (STR_FIRST + 525)
#define idsErrCopy                      (STR_FIRST + 528)
#define idsWarnMailEmptySubj            (STR_FIRST + 531)
#define idsEnterDays                    (STR_FIRST + 532)
#define idsAllServers                   (STR_FIRST + 533)
#define idsWastedKB                     (STR_FIRST + 536)

#define idsEnterCompactPer              (STR_FIRST + 538)
#define idsDelete                       (STR_FIRST + 542)
#define idsCantLoadMapi32Dll            (STR_FIRST + 544)
#define idsErrBadFindParams             (STR_FIRST + 545)
#define idsNoMoreMsgFound               (STR_FIRST + 546)
#define idsErrNewsgroupLineTooLong      (STR_FIRST + 549)
#define idsNoteLangTitle                (STR_FIRST + 550)
#define idsCompacting                   (STR_FIRST + 551)
#define idsConfirmDelAll                (STR_FIRST + 552)
#define idsConfirmDelGroup              (STR_FIRST + 553)
#define idsConfirmDelServer             (STR_FIRST + 554)

// don't make me kill you for reordering the following ids...
#define idsNotConnected                 (STR_FIRST + 556)
#define idsReconnecting                 (STR_FIRST + 557)
#define idsFindingHost                  (STR_FIRST + 558)
#define idsFoundHost                    (STR_FIRST + 559)
#define idsConnecting                   (STR_FIRST + 560)
#define idsConnected                    (STR_FIRST + 561)
#define idsSecuring                     (STR_FIRST + 562)
// don't make me kill you for reordering the preceding ids...

#define idsBCcField                     (STR_FIRST + 563)
#define idsEmptyBCc                     (STR_FIRST + 564)
#define idsTTBCc                        (STR_FIRST + 565)
#define idsErrCompactAll                (STR_FIRST + 566)
#define idsMemory                       (STR_FIRST + 567)
#define idsDiskFull                     (STR_FIRST + 568)
#define idsErrExport                    (STR_FIRST + 574)
#define idsCleaningUp                   (STR_FIRST + 575)
#define idsErrBadRecips                 (STR_FIRST + 576)
#define idsSaveAs                       (STR_FIRST + 577)
#define idsCancelArticle                (STR_FIRST + 578)
#define idsMarkAllRead                  (STR_FIRST + 579)
#define idsMarkUnread                   (STR_FIRST + 580)
#define idsGotoOutbox                   (STR_FIRST + 581)
#define idsGotoPosted                   (STR_FIRST + 582)
#define idsMarkNewsgroups               (STR_FIRST + 583)
#define idsMarkThreadDownload           (STR_FIRST + 584)
#define idsMarkAllDownload              (STR_FIRST + 585)
#define idsMarkThreadRead               (STR_FIRST + 586)
#define idsHelp                         (STR_FIRST + 587)
#define idsProgDLPost                   (STR_FIRST + 588)
#define idsProgDLMessage                (STR_FIRST + 589)
#define idsProgDLGetLines               (STR_FIRST + 593)
#define idsPostedItems                  (STR_FIRST + 596)
#define idsGoToSentItems                (STR_FIRST + 598)
#define idsMarkReadTT                   (STR_FIRST + 599)
#define idsErrSelectGroup               (STR_FIRST + 602)
#define idsSavedItems                   (STR_FIRST + 605)
#define idsActionMoveTo                 (STR_FIRST + 606)
#define idsActionCopyTo                 (STR_FIRST + 607)
#define idsActionDontDownload           (STR_FIRST + 608)
#define idsIf                           (STR_FIRST + 609)
#define idsSubjectContains              (STR_FIRST + 610)
#define idsFromContains                 (STR_FIRST + 611)
#define idsToContains                   (STR_FIRST + 612)
#define idsCCContains                   (STR_FIRST + 613)
#define idsAnd                          (STR_FIRST + 614)
#define idsMaxCoolbarBtnWidth           (STR_FIRST + 619)
#define idsProgCombiningMsgs            (STR_FIRST + 620)
#define idsProgCopyMessages             (STR_FIRST + 621)
#define idsProgMoveMessages             (STR_FIRST + 622)
#define idsProgDeleteMessages           (STR_FIRST + 623)
#define idsMaxOutbarBtnWidth            (STR_FIRST + 624)
#define idshrRasInitFailure             (STR_FIRST + 625)
#define idshrRasDialFailure             (STR_FIRST + 626)
#define idshrRasServerNotFound          (STR_FIRST + 627)
#define idsRasError                     (STR_FIRST + 628)

#define idshrGetDialParamsFailed        (STR_FIRST + 630)
#define idsEndOfListReached             (STR_FIRST + 631)
#define idsMime                         (STR_FIRST + 632)
#define idsUUEncode                     (STR_FIRST + 633)
#define idsPriLow                       (STR_FIRST + 634)
#define idsPriHigh                      (STR_FIRST + 635)
#define idsPriNormal                    (STR_FIRST + 636)
#define idsWarnHTMLToPlain              (STR_FIRST + 638)
#define idsMoveTo                       (STR_FIRST + 647)
#define idsCopyTo                       (STR_FIRST + 648)
#define idsDisconnect                   (STR_FIRST + 649)
#define IDS_BROWSE_FOLDER               (STR_FIRST + 650)
#define idsRasErrorGeneral              (STR_FIRST + 651)
#define idsRas_Dialing                  (STR_FIRST + 652)
#define idsRas_Authentication           (STR_FIRST + 653)
#define idsErrorText                    (STR_FIRST + 654)
#define idsRas_Authenticated            (STR_FIRST + 655)
#define idsRASCS_OpenPort               (STR_FIRST + 657)
#define idsRASCS_PortOpened             (STR_FIRST + 658)
#define idsRASCS_ConnectDevice          (STR_FIRST + 659)
#define idsRASCS_DeviceConnected        (STR_FIRST + 660)
#define idsRASCS_AuthNotify             (STR_FIRST + 661)
#define idsRASCS_AuthRetry              (STR_FIRST + 662)
#define idsRASCS_AuthCallback           (STR_FIRST + 663)
#define idsRASCS_AuthChangePassword     (STR_FIRST + 664)
#define idsRASCS_AuthProject            (STR_FIRST + 665)
#define idsRASCS_AuthLinkSpeed          (STR_FIRST + 666)
#define idsRASCS_AuthAck                (STR_FIRST + 667)
#define idsRASCS_Authenticated          (STR_FIRST + 669)
#define idsRASCS_PrepareForCallback     (STR_FIRST + 670)
#define idsRASCS_WaitForModemReset      (STR_FIRST + 671)
#define idsRASCS_WaitForCallback        (STR_FIRST + 672)
#define idsRASCS_Projected              (STR_FIRST + 673)
#define idsRASCS_Connected              (STR_FIRST + 674)
#define idsRASCS_Disconnected           (STR_FIRST + 675)
#define idshrSetDialParamsFailed        (STR_FIRST + 676)
#define idsOK                           (STR_FIRST + 677)
#define idsRASCS_AllDevicesConnected    (STR_FIRST + 678)
#define idsErrCouldntCopyMessage        (STR_FIRST + 679)
#define idsErrMailBombHtml              (STR_FIRST + 680)
#define idsDefault                      (STR_FIRST + 681)
#define idsFailACacheCompact            (STR_FIRST + 682)
#define idsFailACacheCompactReason      (STR_FIRST + 683)

// For the HTML Welcome message
#define idsWelcomeMessageSubj           (STR_FIRST + 686)
#define idsSecWelcomeMessageSubj        (STR_FIRST + 687)
#define idsSpoolerDisconnect            (STR_FIRST + 696)
#define idsHTMLErrArticleNotCached      (STR_FIRST + 699)

#define idsStopTT                       (STR_FIRST + 701)

#define idsSecurityWarning              (STR_FIRST + 702)
#define idsErrServerNotConnected        (STR_FIRST + 703)
#define idsCacheRemovingReadArts        (STR_FIRST + 704)
#define idsCacheRemovingExpired         (STR_FIRST + 705)
#define idsProgDLPostTo                 (STR_FIRST + 707)
#define idsCacheRemovingBody            (STR_FIRST + 708)        // Bug# 51180 (v-snatar)

#define idsHelpMSWebFirst               (STR_FIRST + 710)
#define idsHelpMSWebFree                (STR_FIRST + 711)
#define idsHelpMSWebProductNews         (STR_FIRST + 712)
#define idsHelpMSWebFaq                 (STR_FIRST + 713)
#define idsHelpMSWebSupport             (STR_FIRST + 714)
#define idsHelpMSWebFeedback            (STR_FIRST + 715)
#define idsHelpMSWebBest                (STR_FIRST + 716)
#define idsHelpMSWebSearch              (STR_FIRST + 717)
#define idsHelpMSWebHome                (STR_FIRST + 718)
#define idsHelpMSWebOutlook             (STR_FIRST + 719)
#define idsHelpMSWebIE                  (STR_FIRST + 720)
#define idsHelpMSWebCert                (STR_FIRST + 721)
#define idsHelpMSWebCertSubName         (STR_FIRST + 722)
#define idsHelpMSWebHotmail             (STR_FIRST + 723)
#define idsHelpMSWebLast                (STR_FIRST + 730)

#define idsCombineAndDecodeTT           (STR_FIRST + 732)
#define idsPostAndDownloadTT            (STR_FIRST + 733)
#define idsGetNextTT                    (STR_FIRST + 734)
#define idsUnscrambleTT                 (STR_FIRST + 735)
#define idsUnmarkTT                     (STR_FIRST + 736)
#define idsErrCantCombineNotConnected   (STR_FIRST + 737)
#define idsDefTextExt                   (STR_FIRST + 738)
#define idsInsertTextTitle              (STR_FIRST + 739)
#define idsErrHTMLInNewsIsBad           (STR_FIRST + 740)
#define idsRasPromptDisconnect          (STR_FIRST + 741)
#define idsProgReceivedLines            (STR_FIRST + 743)
#define idsErrServerNotCongured         (STR_FIRST + 744)
#define idsErrSendDownloadFail          (STR_FIRST + 745)
#define idsErrSaveDownloadFail          (STR_FIRST + 746)

#define idsHTMLErrNewsDLCancelled       (STR_FIRST + 781)
#define idsErrGrpListDL                 (STR_FIRST + 782)
#define idsNewMailNotify                (STR_FIRST + 794)
#define idsXMsgsYUnreadZonServ          (STR_FIRST + 795)
#define idsGetHeaderFmt                 (STR_FIRST + 796)
#define idsPassReqd                     (STR_FIRST + 798)
#define idsHTMLDiskOutOfSpace           (STR_FIRST + 799)   // Bug# 50704 (v-snatar)

#define idsToWell                       (STR_FIRST + 822)
#define idsFromWell                     (STR_FIRST + 823)
#define idsFolder                       (STR_FIRST + 829)
#define idsErrCantRepairInUse           (STR_FIRST + 832)
#define idsRulesNoActions               (STR_FIRST + 833)
#define idsRulesNoCriteria              (STR_FIRST + 834)
#define idsRuleNoForwardTo              (STR_FIRST + 835)
#define idsActionForwardTo              (STR_FIRST + 836)
#define idsIn                           (STR_FIRST + 838)
#define idsOn                           (STR_FIRST + 839)
#define idsForAllMessages               (STR_FIRST + 840)
#define idsMessagePostedMoreThan        (STR_FIRST + 841)
#define idsDaysAgo                      (STR_FIRST + 842)
#define idsMessageSizeGreaterThan       (STR_FIRST + 843)
#define idsKB                           (STR_FIRST + 844)
#define idsActionReplyWith              (STR_FIRST + 845)
#define idsActionDeleteOffServer        (STR_FIRST + 846)
#define idsDontShowMessages             (STR_FIRST + 847)
#define idsInAnyGroup                   (STR_FIRST + 848)
#define idsRulesPickGroup               (STR_FIRST + 850)
#define idsRuleNoReplyWithFile          (STR_FIRST + 851)
#define idsRulePickFrom                 (STR_FIRST + 852)
#define idsRulePickTo                   (STR_FIRST + 853)
#define idsRulePickForwardTo            (STR_FIRST + 854)
#define idsRulePickCC                   (STR_FIRST + 855)
#define idsReasonMoveTo                 (STR_FIRST + 856)
#define idsReasonCopyTo                 (STR_FIRST + 857)
#define idsReasonForwardTo              (STR_FIRST + 858)
#define idsReasonReplyWith              (STR_FIRST + 859)
#define idsReasonActions                (STR_FIRST + 860)
#define idsNameCol                      (STR_FIRST + 861)
#define idsUnread                       (STR_FIRST + 862)
#define idsNew                          (STR_FIRST + 863)
#define idsLastUpdated                  (STR_FIRST + 864)
#define idsWastedSpace                  (STR_FIRST + 865)
#define idsTotal                        (STR_FIRST + 866)
#define idsErrDDFileNotFound            (STR_FIRST + 867)
#define idsGroupPropStatusDef           (STR_FIRST + 871) 
#define idsFolderPropStatusDef          (STR_FIRST + 872) 
#define idsGroupPropStatus              (STR_FIRST + 873) 
#define idsFolderPropStatus             (STR_FIRST + 874) 
#define idsTipOfTheDay                  (STR_FIRST + 875)
#define idsNextTip                      (STR_FIRST + 876)

#define idsEmptyControl                 (STR_FIRST + 878)
#define idsEmptyApproved                (STR_FIRST + 879)

#define idshrCantOpenOutbox             (STR_FIRST + 908)
#define idsUrlDetecting                 (STR_FIRST + 909)
#define idshrAuthFailed                 (STR_FIRST + 912)
#define idsInetMailConnectingHost       (STR_FIRST + 923)
#define idsInetMailRecvStatus           (STR_FIRST + 932)
#define idsReplySep                     (STR_FIRST + 933)
#define idsReplyFont                    (STR_FIRST + 934)
#define idsDetail_Account               (STR_FIRST + 941)
#define idsDetail_Server                (STR_FIRST + 942)
#define idsDetail_UserName              (STR_FIRST + 943)
#define idsDetail_Protocol              (STR_FIRST + 944)
#define idsDetail_Port                  (STR_FIRST + 945)
#define idsDetail_Secure                (STR_FIRST + 946)
#define idsDetail_ErrorNumber           (STR_FIRST + 947)
#define idsDetail_HRESULT               (STR_FIRST + 948)
#define idsDetails_Config               (STR_FIRST + 949)

#define idshrLockUidCacheFailed         (STR_FIRST + 986)
#define idshrCantLeaveOnServer          (STR_FIRST + 988)
#define idsNewsRulesTitle               (STR_FIRST + 989)
#define idsUpOneLevel                   (STR_FIRST + 990)
#define idsAccount                      (STR_FIRST + 997)
#define idsSendMsgUsing                 (STR_FIRST + 999)
#define idsSendMsgAccelTip              (STR_FIRST + 1000)
#define idsDefaultAccount               (STR_FIRST + 1001)
#define idsConnection                   (STR_FIRST + 1002)
#define idsConnectionLAN                (STR_FIRST + 1003)
#define idsConnectionManual             (STR_FIRST + 1004)
#define idsGroupFilters                 (STR_FIRST + 1007)
#define idsSendMsgOneAccount            (STR_FIRST + 1008)
#define idsErrNoSendAccounts            (STR_FIRST + 1009)
#define idshrErrNoSmtpResponse          (STR_FIRST + 1011)
#define idshrErrNoPop3Response          (STR_FIRST + 1012)
#define idsWarnDeleteAccount            (STR_FIRST + 1014)
#define idsPollAllAccounts              (STR_FIRST + 1015)
#define idsSecurityField                (STR_FIRST + 1017)
#define idsStitchingMessages            (STR_FIRST + 1018)
#define idsRuleReplyWithFilter          (STR_FIRST + 1019)
#define idsCopy                         (STR_FIRST + 1020)
#define idsCopyCaption                  (STR_FIRST + 1021)
#define idsMove                         (STR_FIRST + 1022)
#define idsMoveCaption                  (STR_FIRST + 1023)
#define idsNoMoveDestinationFolder      (STR_FIRST + 1024)
#define idsNoCopyDestinationFolder      (STR_FIRST + 1025)
#define idsErrFolderMove                (STR_FIRST + 1026)
#define idsErrCantMoveIntoSubfolder     (STR_FIRST + 1027)
#define idsErrURLExec                   (STR_FIRST + 1028)
#define idsErrNoteDeferedInit           (STR_FIRST + 1029)
#define idsErrCannotMoveSpecial         (STR_FIRST + 1030)
#define idsErrLoadingHtmlEdit           (STR_FIRST + 1031)
#define idsErrLoadingWAB                (STR_FIRST + 1032)
#define idsErrWAB                       (STR_FIRST + 1033)
#define idsErrWABNotFound               (STR_FIRST + 1034)

// Languages for purposes of spelling
#define idsSpellLangAmerican            (STR_FIRST + 1035)
#define idsSpellLangAustralian          (STR_FIRST + 1036)
#define idsSpellLangBritish             (STR_FIRST + 1037)
#define idsSpellLangCatalan             (STR_FIRST + 1038)
#define idsSpellLangCzecheslovakian     (STR_FIRST + 1039)
#define idsSpellLangDanish              (STR_FIRST + 1040)
#define idsSpellLangDutch               (STR_FIRST + 1041)
#define idsSpellLangFinnish             (STR_FIRST + 1042)
#define idsSpellLangFrench              (STR_FIRST + 1043)
#define idsSpellLangFrenchCanadian      (STR_FIRST + 1044)
#define idsSpellLangGerman              (STR_FIRST + 1045)
#define idsSpellLangGreek               (STR_FIRST + 1046)
#define idsSpellLangHungarian           (STR_FIRST + 1047)
#define idsSpellLangItalian             (STR_FIRST + 1048)
#define idsSpellLangNorskBokmal         (STR_FIRST + 1049)
#define idsSpellLangNorskNynorsk        (STR_FIRST + 1050)
#define idsSpellLangPolish              (STR_FIRST + 1051)
#define idsSpellLangPortBrazil          (STR_FIRST + 1052)
#define idsSpellLangPortIberian         (STR_FIRST + 1053)
#define idsSpellLangRussian             (STR_FIRST + 1054)
#define idsSpellLangSpanish             (STR_FIRST + 1055)
#define idsSpellLangSwedish             (STR_FIRST + 1056)
#define idsSpellLangTurkish             (STR_FIRST + 1057)
#define idsSpellLangDefault             (STR_FIRST + 1058)

#define idsErrCantDeleteFolderWithSub   (STR_FIRST + 1060)
#define idsIMAP                         (STR_FIRST + 1064)
#define idsErrResetSubList              (STR_FIRST + 1065)
#define idsMessagesOn                   (STR_FIRST + 1069)
#define idsWarnDeleteManyFolders        (STR_FIRST + 1070)
#define idsErrMsgURLNotFound            (STR_FIRST + 1071)
#define idsDownloadingImapFldrs         (STR_FIRST + 1072)
#define idsColLines                     (STR_FIRST + 1073)
#define idsNewFolder                    (STR_FIRST + 1074)
#define idsNewFolderNumber              (STR_FIRST + 1075)
#define idsImapLogon                    (STR_FIRST + 1076)
#define idsFontSize0                    (STR_FIRST + 1079)
#define idsFontSize1                    (STR_FIRST + 1080)
#define idsFontSize2                    (STR_FIRST + 1081)
#define idsFontSize3                    (STR_FIRST + 1082)
#define idsFontSize4                    (STR_FIRST + 1083)
#define idsFontSize5                    (STR_FIRST + 1084)
#define idsFontSize6                    (STR_FIRST + 1085)
#define idsErrLoadWinMM                 (STR_FIRST + 1086)
#define idsErrInetcplLoad               (STR_FIRST + 1087)
#define idsErrSicilyFailedToLoad        (STR_FIRST + 1089)
#define idsErrSicilyLogonFailed         (STR_FIRST + 1090)
#define idsOui                          (STR_FIRST + 1101)
#define idsNon                          (STR_FIRST + 1102)
#define idsBit                          (STR_FIRST + 1103)
#define idsMaybe                        (STR_FIRST + 1104)
#define idsMessageSizeLessThan          (STR_FIRST + 1106)
#define idsLogCouldNotConnect           (STR_FIRST + 1110)
#define idsErrCoCreateTrident           (STR_FIRST + 1122)
#define idsLogErrorGroup                (STR_FIRST + 1123)
#define idsLogErrorConnection           (STR_FIRST + 1124)
#define idsLogCheckingNewMessages       (STR_FIRST + 1125)
#define idsErrNotSaveUntilDownloadDone  (STR_FIRST + 1126)
#define idsLogErrorSwitchGroup          (STR_FIRST + 1127)
#define idsSendBeforeFullyDisplayed     (STR_FIRST + 1128)
#define idsLogStartDownloadAll          (STR_FIRST + 1132)
#define idsDetails                      (STR_FIRST + 1145)
#define idsIMAPCmdCompletionError       (STR_FIRST + 1149)
#define idsIMAPFolderListFailed         (STR_FIRST + 1150)
#define idsIMAPCreateFailed             (STR_FIRST + 1151)
#define idsIMAPCreateListFailed         (STR_FIRST + 1152)
#define idsIMAPCreateSubscribeFailed    (STR_FIRST + 1153)
#define idsIMAPFolderCacheTitle         (STR_FIRST + 1154)
#define idsIMAPFolderCacheError         (STR_FIRST + 1155)

#define idsIMAPSendNextOpErrTitle       (STR_FIRST + 1157)
#define idsIMAPSendNextOpErrText        (STR_FIRST + 1158)
#define idsIMAPFmgrInitErrTitle         (STR_FIRST + 1159)
#define idsIMAPFmgrInitErrText          (STR_FIRST + 1160)
#define idsIMAPCreateFldrErrorTitle     (STR_FIRST + 1161)
#define idsIMAPCreateFldrErrorText      (STR_FIRST + 1162)
#define idsIMAPFldrInitHdrsErrTitle     (STR_FIRST + 1163)
#define idsIMAPFldrInitHdrsErrText      (STR_FIRST + 1164)
#define idsIMAPServerAlertTitle         (STR_FIRST + 1165)
#define idsIMAPServerAlertIntro         (STR_FIRST + 1166)
#define idsIMAPServerParseErrTitle      (STR_FIRST + 1167)
#define idsIMAPServerParseErrIntro      (STR_FIRST + 1168)
#define idsIMAPOutOfSyncTitle           (STR_FIRST + 1169)
#define idsWarnChangeSecurity           (STR_FIRST + 1170)

#define idsIMAPNewHdrErrTitle           (STR_FIRST + 1171)
#define idsIMAPNewHdrErrText            (STR_FIRST + 1172)
#define idsIMAPNewBodyErrTitle          (STR_FIRST + 1173)
#define idsIMAPNewBodyErrText           (STR_FIRST + 1174)
#define idsIMAPNewFlagsErrTitle         (STR_FIRST + 1175)
#define idsIMAPNewFlagsErrText          (STR_FIRST + 1176)
#define idsIMAPErrorNotificationText    (STR_FIRST + 1177)
#define idsIMAPAuthFailureText          (STR_FIRST + 1178)
#define idsIMAPMsgDeleteSyncErrTitle    (STR_FIRST + 1179)
#define idsIMAPMsgDeleteSyncErrText     (STR_FIRST + 1180)
#define idsIMAPSelectFailureTitle       (STR_FIRST + 1181)
#define idsIMAPSelectFailureTextFmt     (STR_FIRST + 1182)
#define idsIMAPNewMsgDLErrTitle         (STR_FIRST + 1183)
#define idsIMAPNewMsgDLErrText          (STR_FIRST + 1184)
#define idsIMAPOldMsgUpdateFailure      (STR_FIRST + 1185)
#define idsIMAPFldrDeleteSyncErrTitle   (STR_FIRST + 1186)
#define idsIMAPFldrDeleteSyncErrText    (STR_FIRST + 1187)
#define idsErrNewsgroupBlocked          (STR_FIRST + 1188)
#define idsErrNewsgroupNoPosting        (STR_FIRST + 1189)
#define idsNewsOutbox                   (STR_FIRST + 1190)
#define idsIMAP_HCFCouldNotDelete       (STR_FIRST + 1191)
#define idsIMAPNoHierarchy              (STR_FIRST + 1192)
#define idsIMAPNoHierarchyLosePrefix    (STR_FIRST + 1193)
#define idsIMAPPrefixCreateFailedFmt    (STR_FIRST + 1194)

#define idsSaveAttachControl            (STR_FIRST + 1196)
#define idsOpenAttachControl            (STR_FIRST + 1197)
#define idsAll                          (STR_FIRST + 1198)
#define idsSaveAllBrowse                (STR_FIRST + 1199)
#define idsErrCmdFailed                 (STR_FIRST + 1200)
#define idsEmptyFolderMenuCommand       (STR_FIRST + 1201)

#define idsIMAPDeleteFldrFailed         (STR_FIRST + 1203)
#define idsIMAPDeleteFldrUnsubFailed    (STR_FIRST + 1204)
#define idsIMAPUnselectFailed           (STR_FIRST + 1205)
#define idsIMAPDeleteFldrErrorTitle     (STR_FIRST + 1206)
#define idsIMAPDeleteFldrErrorText      (STR_FIRST + 1207)
#define idsIMAPUpldProgressFmt          (STR_FIRST + 1208)
#define idsIMAPAppendFailed             (STR_FIRST + 1209)
#define idsIMAPUploadMsgFailedTitle     (STR_FIRST + 1211)
#define idsIMAPUploadMsgStoreFail       (STR_FIRST + 1212)
#define idsIMAPUploadMsgMoveDelFail     (STR_FIRST + 1213)
#define idsIMAPUploadMsgNoRootLvl       (STR_FIRST + 1214)
#define idsIMAPUploadMsgErrorText       (STR_FIRST + 1215)
#define idsInlineImageHeader            (STR_FIRST + 1216)
#define idsInlineImagePlaceHolder       (STR_FIRST + 1217)
#define idsBccWell                      (STR_FIRST + 1218)
#define idsErrNewsCantOpen              (STR_FIRST + 1219)
#define idsErrNewsExpired               (STR_FIRST + 1220)
#define idsPrintHeader                  (STR_FIRST + 1221)
#define idsIMAPImapCopyMoveNYI          (STR_FIRST + 1223)
#define idsIMAPCopyMsgsFailed           (STR_FIRST + 1224)
#define idsIMAPMoveMsgsFailed           (STR_FIRST + 1225)
#define idsIMAPCopyMsgProgressFmt       (STR_FIRST + 1226)
#define idsIMAPMoveMsgProgressFmt       (STR_FIRST + 1227)
#define idsIMAPCopyDlgTitleFmt          (STR_FIRST + 1228)
#define idsIMAPMoveDlgTitleFmt          (STR_FIRST + 1229)
#define idsButtonReadNews               (STR_FIRST + 1231)
#define idsButtonReadMail               (STR_FIRST + 1232)
#define idsButtonCompose                (STR_FIRST + 1233)
#define idsButtonUpdate                 (STR_FIRST + 1234)
#define idsButtonFind                   (STR_FIRST + 1235)
#define idsAthenaTitle                  (STR_FIRST + 1236)
#define idsIMAPDnldDlgErrorTitle        (STR_FIRST + 1238)
#define idsIMAPDnldProgressFmt          (STR_FIRST + 1239)
#define idsIMAPDnldDlgDLFailed          (STR_FIRST + 1240)
#define idsIMAPDnldDlgAbort             (STR_FIRST + 1241)
#define idsIMAPDnldDlgHeaderFailure     (STR_FIRST + 1242)
#define idsIMAPDnldDlgGetMsgFailure     (STR_FIRST + 1243)
#define idsIMAPDnldDlgSaveFailure       (STR_FIRST + 1244)
#define idsIMAPBodyFetchFailed          (STR_FIRST + 1245)
#define idsIMAPDeleteFailed             (STR_FIRST + 1246)
#define idsIMAPDnldDlgInitFailure       (STR_FIRST + 1247)
#define idsSecurityLineDigSign          (STR_FIRST + 1249)
#define idsSecurityLineSignGood         (STR_FIRST + 1250)
#define idsSecurityLineSignBad          (STR_FIRST + 1251)
#define idsSecurityLineSignUnsure       (STR_FIRST + 1252)
#define idsSecurityLineBreakStr         (STR_FIRST + 1253)
#define idsSecurityLineEncryption       (STR_FIRST + 1254)
#define idsSecurityLineEncGood          (STR_FIRST + 1255)
#define idsSecurityLineEncBad           (STR_FIRST + 1256)
#define idsPerformingRepair             (STR_FIRST + 1257)
#define idsErrViewLanguage              (STR_FIRST + 1258)
#define idsReplaceContents              (STR_FIRST + 1259)
#define idsFromAccount                  (STR_FIRST + 1260)
#define idsErrorPickAccount             (STR_FIRST + 1261)
#define idsSpellingOptions              (STR_FIRST + 1264)
#define idsErrSecurityNoSigningCert     (STR_FIRST + 1265)
#define idsIMAPNoHierarchyCharsFmt      (STR_FIRST + 1266)
#define idsIMAPRenameFldrErrorTitle     (STR_FIRST + 1267)
#define idsIMAPRenameFldrErrorText      (STR_FIRST + 1268)
#define idsIMAPRenameFailed             (STR_FIRST + 1269)
#define idsIMAPRenameFCUpdateFailure    (STR_FIRST + 1270)
#define idsIMAPReconnectFailed          (STR_FIRST + 1271)
#define idsIMAPRenameSubscribeFailed    (STR_FIRST + 1272)
#define idsIMAPRenameUnsubscribeFailed  (STR_FIRST + 1273)
#define idsIMAPRenameINBOX              (STR_FIRST + 1274)
#define idsIMAPAtomicRenameFailed       (STR_FIRST + 1275)
#define idsIMAPFldrInitError            (STR_FIRST + 1276)
#define idsEmptyStr                     (STR_FIRST + 1277)
#define idsIMAPTurnOnPolling            (STR_FIRST + 1278)
#define idsIMAPUIDValidityError         (STR_FIRST + 1279)
#define idsErrSecurityBadSigningPrint   (STR_FIRST + 1280)
#define idsSecurityLineSignPreProblem   (STR_FIRST + 1281)
#define idsSecurityLineEncExpired       (STR_FIRST + 1282)
#define idsSecurityLineSignDistrusted   (STR_FIRST + 1283)
#define idsSecurityLineSignExpired      (STR_FIRST + 1284)
#define idsSecurityLineListStr          (STR_FIRST + 1285)

#ifdef ATHENA_RTM_RELEASE
#error Need to remove beta1 strings
#else
// NYI strings for beta1 - pull these out before RTM!!
#define idsNYIGeneral                   (STR_FIRST + 1289)
#define idsNYITitle                     (STR_FIRST + 1290)
// NYI strings for beta1 - pull these out before RTM!!
#endif

#define idsViewLangMimeDBBad            (STR_FIRST + 1301)
#define idsIMAPViewInitFldrErr          (STR_FIRST + 1302)
#define idsIMAPViewInitFldrMgrErr       (STR_FIRST + 1303)
// standard warning -- reorder and die vvv
#define idsSecurityCertMissing          (STR_FIRST + 1305)
#define idsSecurityCertExpired          (STR_FIRST + 1306)
#define idsSecurityCertChainTooLong     (STR_FIRST + 1307)
#define idsSecurityCertNoIssuer         (STR_FIRST + 1308)
#define idsSecurityCertRevoked          (STR_FIRST + 1309)
#define idsSecurityCertNotTrusted       (STR_FIRST + 1310)
#define idsSecurityCertInvalid          (STR_FIRST + 1311)
#define idsSecurityCertError            (STR_FIRST + 1312)
#define idsSecurityCertNoPrint          (STR_FIRST + 1313)
#define idsSecurityCertUnknown          (STR_FIRST + 1314)
// standard warning -- reorder and die ^^^
#define idsErrFailedNavigate            (STR_FIRST + 1330)
#define idsAthenaStoreDir               (STR_FIRST + 1331)
#define idsIMAPMustBeConnectedFmt       (STR_FIRST + 1332)
#define idsDisconnecting                (STR_FIRST + 1333)
#define idsWrnSecurityNoCertForEnc      (STR_FIRST + 1334)
#define idsErrSecurityNoPrivateKey      (STR_FIRST + 1335)
#define idsErrSecurityNoChosenCert      (STR_FIRST + 1336)
#define idsErrSecurityNoCertForDecrypt  (STR_FIRST + 1338)
#define idsNYIMail                      (STR_FIRST + 1339)
#define idsIMAPNoInferiorsFmt           (STR_FIRST + 1343)
#define idsViewLanguageGeneralHelp      (STR_FIRST + 1344)
#define idsErrDuplicateAccount          (STR_FIRST + 1345)
#define idsErrRenameAccountFailed       (STR_FIRST + 1346)
#define idsSecurityLineSignUntrusted    (STR_FIRST + 1350)
#define idsCtxtAddToWab                 (STR_FIRST + 1351)
#define idsCtxtAddToFavorites           (STR_FIRST + 1352)
#define idsErrNewsServerTimeout         (STR_FIRST + 1353)
#define idsNNTPErrUnknownResponse       (STR_FIRST + 1354)
#define idsNNTPErrNewgroupsFailed       (STR_FIRST + 1355)
#define idsNNTPErrListFailed            (STR_FIRST + 1356)
#define idsNNTPErrListGroupFailed       (STR_FIRST + 1357)
#define idsNNTPErrGroupFailed           (STR_FIRST + 1358)
#define idsNNTPErrGroupNotFound         (STR_FIRST + 1359)
#define idsNNTPErrArticleFailed         (STR_FIRST + 1360)
#define idsNNTPErrHeadFailed            (STR_FIRST + 1361)
#define idsNNTPErrBodyFailed            (STR_FIRST + 1362)
#define idsNNTPErrPostFailed            (STR_FIRST + 1363)
#define idsNNTPErrNextFailed            (STR_FIRST + 1364)
#define idsNNTPErrDateFailed            (STR_FIRST + 1365)
#define idsNNTPErrHeadersFailed         (STR_FIRST + 1366)
#define idsNNTPErrXhdrFailed            (STR_FIRST + 1367)
#define idsDetail_ServerResponse        (STR_FIRST + 1368)
#define idsFavoritesFromOutlook         (STR_FIRST + 1369)
#define idsErrFavorites                 (STR_FIRST + 1370)
#define idsErrSendWebPageUrl            (STR_FIRST + 1371)
#define idsTasks                        (STR_FIRST + 1374)
#define idsErrors                       (STR_FIRST + 1375)
#define idsStatusCol                    (STR_FIRST + 1377)
#define idsErrCantFindHost              (STR_FIRST + 1378)
#define idsFmtTagGeneralHelp            (STR_FIRST + 1379)
#define idsHtmlNoFrames                 (STR_FIRST + 1380)
#define idsErrPostWithoutNewsgroup      (STR_FIRST + 1381)
#define idsNewsTaskPost                 (STR_FIRST + 1382)
#define idsStateExecuting               (STR_FIRST + 1384)
#define idsStateCompleted               (STR_FIRST + 1385)
#define idsStateFailed                  (STR_FIRST + 1386)
#define idsErrNewMsgsFailed             (STR_FIRST + 1387)
#define idsCheckingNewMsgsServer        (STR_FIRST + 1388)
#define idsCheckNewMsgsServer           (STR_FIRST + 1389)
#define idsChooseName                   (STR_FIRST + 1390)
#define idsVCFName                      (STR_FIRST + 1391)
#define idsRasErrorGeneralWithName      (STR_FIRST + 1392)
#define idsErrFindWAB                   (STR_FIRST + 1393)
#define idsErrAttachVCard               (STR_FIRST + 1394)
#define idsErrInsertVCard               (STR_FIRST + 1395)
#define idsNewsTaskPostError            (STR_FIRST + 1396)
#define idsSyncAccountFmt               (STR_FIRST + 1397)
#define idsDLHeaders                    (STR_FIRST + 1398)
#define idsDLHeadersAndMarked           (STR_FIRST + 1399)
#define idsDLNewMsgs                    (STR_FIRST + 1400)
#define idsDLNewMsgsAndMarked           (STR_FIRST + 1401)
#define idsDLAllMsgs                    (STR_FIRST + 1402)
#define idsDLMarkedMsgs                 (STR_FIRST + 1403)
#define idsSpoolerIdleErrors            (STR_FIRST + 1404)
#define idsSpoolerIdle                  (STR_FIRST + 1405)
#define idsStateWarnings                (STR_FIRST + 1406)
#define idsNewsTaskArticleError         (STR_FIRST + 1407)
#define idsForwardMessage               (STR_FIRST + 1408)
#define idsColPriority                  (STR_FIRST + 1409)
#define idsColAttach                    (STR_FIRST + 1410)
#define idsServerErrorNumber                        (STR_FIRST + 1411)
#define idsSocketErrorNumber                        (STR_FIRST + 1412)
#define idsOtherInformation                         (STR_FIRST + 1413)
#define IDS_IXP_E_TIMEOUT                           (STR_FIRST + 1414)
#define IDS_IXP_E_USER_CANCEL                       (STR_FIRST + 1415)
#define IDS_IXP_E_INVALID_ACCOUNT                   (STR_FIRST + 1416)    
#define IDS_IXP_E_WINSOCK_WSAVERNOTSUPPORTED        (STR_FIRST + 1417)
#define IDS_IXP_E_SOCKET_CONNECT_ERROR              (STR_FIRST + 1418)
#define IDS_IXP_E_SOCKET_INIT_ERROR                 (STR_FIRST + 1419)
#define IDS_IXP_E_SOCKET_WRITE_ERROR                (STR_FIRST + 1420)
#define IDS_IXP_E_SOCKET_READ_ERROR                 (STR_FIRST + 1421)
#define IDS_IXP_E_CONNECTION_DROPPED                (STR_FIRST + 1422)    
#define IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP         (STR_FIRST + 1423)
#define IDS_IXP_E_LOAD_SICILY_FAILED                (STR_FIRST + 1424)
#define IDS_IXP_E_INVALID_CERT_CN                   (STR_FIRST + 1425)
#define IDS_IXP_E_INVALID_CERT_DATE                 (STR_FIRST + 1426)
#define IDS_IXP_E_CONN                              (STR_FIRST + 1427)
#define IDS_IXP_E_CANT_FIND_HOST                    (STR_FIRST + 1428)
#define IDS_IXP_E_SICILY_LOGON_FAILED               (STR_FIRST + 1429)
#define IDS_IXP_E_FAILED_TO_CONNECT                 (STR_FIRST + 1430)
#define IDS_IXP_E_SMTP_RESPONSE_ERROR               (STR_FIRST + 1431)
#define IDS_IXP_E_SMTP_UNKNOWN_RESPONSE_CODE        (STR_FIRST + 1432)
#define IDS_E_OUTOFMEMORY                           (STR_FIRST + 1433)
#define IDS_IXP_E_UNKNOWN                           (STR_FIRST + 1434)
#define IDS_IXP_E_SMTP_REJECTED_SENDER              (STR_FIRST + 1435)
#define IDS_SP_E_SENDINGSPLITGROUP                  (STR_FIRST + 1436)
#define IDS_SP_E_SMTP_CANTOPENMESSAGE               (STR_FIRST + 1437)
#define IDS_SP_E_SMTP_CANTAUTOFORWARD               (STR_FIRST + 1438)
#define IDS_IXP_E_SMTP_NO_RECIPIENTS                (STR_FIRST + 1439)
#define IDS_IXP_E_SMTP_NO_SENDER                    (STR_FIRST + 1440)
#define IDS_IXP_E_SMTP_REJECTED_RECIPIENTS          (STR_FIRST + 1441)
#define IDS_SPS_SMTPEVENT                           (STR_FIRST + 1442)
#define IDS_SPS_POP3EVENT                           (STR_FIRST + 1443)
#define IDS_SPS_SMTPPROGRESS                        (STR_FIRST + 1444)
#define IDS_SPS_SMTPPROGRESS_SPLIT                  (STR_FIRST + 1445)
#define IDS_SPS_SMTPPROGGEN                         (STR_FIRST + 1446)
#define IDS_SPS_POP3CHECKING                        (STR_FIRST + 1447)
#define IDS_SPS_POP3STAT                            (STR_FIRST + 1448)
#define IDS_SPS_POP3DELE                            (STR_FIRST + 1449)
#define IDS_SPS_POP3UIDL_TOP                        (STR_FIRST + 1450)
#define IDS_SPS_POP3UIDL_UIDL                       (STR_FIRST + 1451)
#define IDS_SPS_PREDOWNRULES                        (STR_FIRST + 1452)
#define IDS_IXP_E_POP3_RESPONSE_ERROR               (STR_FIRST + 1453)
#define IDS_IXP_E_POP3_INVALID_USER_NAME            (STR_FIRST + 1454)
#define IDS_IXP_E_POP3_INVALID_PASSWORD             (STR_FIRST + 1455)
#define idsNNTPErrPasswordFailed                    (STR_FIRST + 1456)
#define idsStateCanceled                            (STR_FIRST + 1457)
#define idsSBCheckingNews                           (STR_FIRST + 1458)
#define idsSBSendingNews                            (STR_FIRST + 1459)
#define idsSBReceivingNews                          (STR_FIRST + 1460)
#define idsLogStartDownloadMarked                   (STR_FIRST + 1461)
#define idsTTSecurityCircSign           (STR_FIRST + 1462)
#define idsTTSecurityCircEnc            (STR_FIRST + 1463)
#define idsTTStampForReadnote           (STR_FIRST + 1464)
// standard warning -- reorder and die vvv
//NOTE: some of the Ok ids are referenced by offset only
#define OFFSET_SMIMEOK                  20
#define idsWrnSecurityMsgTamper         (STR_FIRST + 1465)
#define idsOkSecurityMsgTamper          (idsWrnSecurityMsgTamper + OFFSET_SMIMEOK)
#define idsUnkSecurityMsgTamper         (STR_FIRST + 1466)
#define idsWrnSecurityTrustNotTrusted   (STR_FIRST + 1467)
#define idsOkSecurityTrustNotTrusted    (idsWrnSecurityTrustNotTrusted + OFFSET_SMIMEOK)
#define idsUnkSecurityTrust             (STR_FIRST + 1468)
#ifdef N_NEST
#define idsWrnSigningValidity           (STR_FIRST + 1469)
#define idsOkSigningValidity            (idsWrnSigningValidity + OFFSET_SMIMEOK)
#endif
#define idsWrnSecurityTrustAddress      (STR_FIRST + 1470)
#define idsOkSecurityTrustAddress       (idsWrnSecurityTrustAddress + OFFSET_SMIMEOK)
#define idsWrnSecurityCertRevoked       (STR_FIRST + 1471)
#define idsOkSecurityCertRevoked        (idsWrnSecurityCertRevoked + OFFSET_SMIMEOK)
#define idsWrnSecurityOtherValidity     (STR_FIRST + 1472)
#define idsOkSecurityOtherValidity      (idsWrnSecurityOtherValidity + OFFSET_SMIMEOK)
#define idsWrnSecurityTrustExpired      (STR_FIRST + 1480)
#define idsOkSecurityTrustExpired       (idsWrnSecurityTrustExpired + OFFSET_SMIMEOK)
// standard warning -- reorder and die ^^^
#define idsAbortMessageLoad             (STR_FIRST + 1505)
#define idsConnNoDial                   (STR_FIRST + 1506)
#define idsRASWarnDidntDialConn         (STR_FIRST + 1507)

#define idsNonePicture                  (STR_FIRST + 1508)
#define idsStationery                   (STR_FIRST + 1509)
#define idsCaptionMail                  (STR_FIRST + 1510)
#define idsCaptionNews                  (STR_FIRST + 1511)
#define idsImageFileFilter              (STR_FIRST + 1512)
#define idsMoreStationery               (STR_FIRST + 1513)
#define idsErrNewStationery             (STR_FIRST + 1514)
#define idsHtmlFileFilter               (STR_FIRST + 1515)
#define idsErrVCardProperties           (STR_FIRST + 1516)
#define idsRSListGeneralHelp            (STR_FIRST + 1517)
#define idsTTVCardStamp                 (STR_FIRST + 1518)
#define idsChoosePicture                (STR_FIRST + 1519)
#define idsInvalidPicture               (STR_FIRST + 1520)
// begin tip of the day strings
#define IDS_TIP_FIRST_GENERAL           (STR_FIRST + 1521)
#define idsTipGen01                     (STR_FIRST + 1521)
#define idsTipGen02                     (STR_FIRST + 1522)
#define idsTipGen03                     (STR_FIRST + 1523)
#define idsTipGen04                     (STR_FIRST + 1524)
#define idsTipGen05                     (STR_FIRST + 1525)
#define idsTipGen06                     (STR_FIRST + 1526)
#define idsTipGen07                     (STR_FIRST + 1527)
#define idsTipGen08                     (STR_FIRST + 1528)
#define idsTipGen09                     (STR_FIRST + 1529)
#define idsTipGen10                     (STR_FIRST + 1530)
#define idsTipGen11                     (STR_FIRST + 1531)
#define idsTipGen12                     (STR_FIRST + 1532)
#define idsTipGen13                     (STR_FIRST + 1533)
#define idsTipGen14                     (STR_FIRST + 1534)
#define IDS_TIP_LAST_GENERAL            (STR_FIRST + 1534)
//
#define IDS_TIP_FIRST_POP               (STR_FIRST + 1535)
#define idsTipPop01                     (STR_FIRST + 1535)
#define idsTipPop02                     (STR_FIRST + 1536)
#define idsTipPop03                     (STR_FIRST + 1537)
#define idsTipPop04                     (STR_FIRST + 1538)
#define idsTipPop05                     (STR_FIRST + 1539)
#define idsTipPop06                     (STR_FIRST + 1540)
#define idsTipPop07                     (STR_FIRST + 1541)
#define idsTipPop08                     (STR_FIRST + 1542)
#define idsTipPop09                     (STR_FIRST + 1543)
#define idsTipPop10                     (STR_FIRST + 1544)
#define idsTipPop11                     (STR_FIRST + 1545)
#define IDS_TIP_LAST_POP                (STR_FIRST + 1545)
//
#define IDS_TIP_FIRST_NEWS              (STR_FIRST + 1546)
#define idsTipNews01                    (STR_FIRST + 1546)
#define idsTipNews02                    (STR_FIRST + 1547)
#define idsTipNews03                    (STR_FIRST + 1548)
#define idsTipNews04                    (STR_FIRST + 1549)
#define idsTipNews05                    (STR_FIRST + 1550)
#define idsTipNews06                    (STR_FIRST + 1551)
#define idsTipNews07                    (STR_FIRST + 1552)
#define idsTipNews08                    (STR_FIRST + 1553)
#define idsTipNews09                    (STR_FIRST + 1554)
#define idsTipNews10                    (STR_FIRST + 1555)
#define idsTipNews11                    (STR_FIRST + 1556)
#define IDS_TIP_LAST_NEWS               (STR_FIRST + 1556)
//
#define IDS_TIP_FIRST_IMAP              (STR_FIRST + 1557)
#define idsTipIMAP01                    (STR_FIRST + 1557)
#define idsTipIMAP02                    (STR_FIRST + 1558)
#define idsTipIMAP03                    (STR_FIRST + 1559)
#define idsTipIMAP04                    (STR_FIRST + 1560)
#define idsTipIMAP05                    (STR_FIRST + 1561)
#define idsTipIMAP06                    (STR_FIRST + 1562)
#define idsTipIMAP07                    (STR_FIRST + 1563)
#define IDS_TIP_LAST_IMAP               (STR_FIRST + 1563)
// end tip of the day strings

#define idsSendRecvOneAccount           (STR_FIRST + 1600)
#define idsSendRecvUsing                (STR_FIRST + 1601)
#define idsFPStatInbox                  (STR_FIRST + 1602)
#define idsFPStatDraft                  (STR_FIRST + 1603)
#define idsFPStatOutbox                 (STR_FIRST + 1604)
#define idsFPStatNews                   (STR_FIRST + 1605)
#define idsBold                         (STR_FIRST + 1606)
#define idsItalic                       (STR_FIRST + 1607)
#define idsComposeFontFace              (STR_FIRST + 1608)
#define IDS_SP_E_RETRFAILED             (STR_FIRST + 1609)
#define IDS_SPS_POP3TOTAL               (STR_FIRST + 1610)
#define IDS_SPS_POP3NEW                 (STR_FIRST + 1611)
#define IDS_IXP_E_SMTP_553_MAILBOX_NAME_SYNTAX (STR_FIRST + 1612) 
#define IDS_SPS_SMTPUSEDEFAULT          (STR_FIRST + 1613)
#define idsNNTPErrServerTimeout         (STR_FIRST + 1614)
#define idsPictureTitle                 (STR_FIRST + 1615)
#define idsErrNoSubscribedGroups        (STR_FIRST + 1616)
#define idsWarnErrorUnsentMail          (STR_FIRST + 1617)
#define idsClose                        (STR_FIRST + 1618)
#define idsSelectFolder                 (STR_FIRST + 1619)
#define idsApplyRulesCaption            (STR_FIRST + 1620)
#define idsLeftOnServerWarning          (STR_FIRST + 1621)
#define idsReplyForwardLoop             (STR_FIRST + 1622)
#define idsDeleteOnServerWarning        (STR_FIRST + 1623)
#define idsNotDefNewsClient             (STR_FIRST + 1624)
#define idsFontSample                   (STR_FIRST + 1625)
#define idsSelectStationery             (STR_FIRST + 1626)
#define idsShopMoreStationery           (STR_FIRST + 1627)
#define idsFontFolderLarge              (STR_FIRST + 1628)
#define idsFontFolderSmall              (STR_FIRST + 1629)
#define idsFontViewTextLarge            (STR_FIRST + 1630)
#define idsFontViewTextSmall            (STR_FIRST + 1631)
#define idsEmptyEmailWarning            (STR_FIRST + 1632)
#define idsIMAPUnsubSubscribeErrTitle   (STR_FIRST + 1633)
#define idsIMAPUnsubSubscribeErrText    (STR_FIRST + 1634)
#define idsIMAPSubscribeFailedFmt       (STR_FIRST + 1635)
#define idsIMAPUnsubscribeFailedFmt     (STR_FIRST + 1636)
#define idsIMAPSubscribeAllFailed       (STR_FIRST + 1637)
#define idsSubscribingIMAPFldrs         (STR_FIRST + 1638)
#define idsUnsubscribingIMAPFldrs       (STR_FIRST + 1639)
#define idsSubscribingAllIMAPFldrs      (STR_FIRST + 1640)
#define idsUnsubscribingAllIMAPFldrs    (STR_FIRST + 1641)
#define idsIMAPSubscribeCountFmt        (STR_FIRST + 1642)
#define idsIMAPUnsubscribeCountFmt      (STR_FIRST + 1643)
#define idsIMAPSubscribeErrors          (STR_FIRST + 1644)
#define idsIMAPUnsubscrRemovalErrorFmt  (STR_FIRST + 1645)
#define idsIMAPSubscrAddErrorFmt        (STR_FIRST + 1646)
#define idsIMAPSubscribeAllSureFmt      (STR_FIRST + 1647)
#define idsIMAPUnsubscribeAllSureFmt    (STR_FIRST + 1648)
#define idsAreYouSureContinue           (STR_FIRST + 1649)
#define idsSyncThisAccount              (STR_FIRST + 1650)
#define idsModerated                    (STR_FIRST + 1651)
#define idsBlocked                      (STR_FIRST + 1652)
#define idsNoPosting                    (STR_FIRST + 1653)
#define idsWindowLayout                 (STR_FIRST + 1654)
#define IDS_IXP_E_SMTP_552_STORAGE_OVERFLOW (STR_FIRST + 1655)
#define idsSigningCertProperties        (STR_FIRST + 1656)
#define idsRas_Dialing_Param            (STR_FIRST + 1657)
#define idsFormatK                      (STR_FIRST + 1658)
#define idsIMAPRules                    (STR_FIRST + 1659)
#define idsGoToFolderTitle              (STR_FIRST + 1660)
#define idsGoToFolderText               (STR_FIRST + 1661)
#define idsMicrosoft                    (STR_FIRST + 1662)
#define idsComposeFontStyle             (STR_FIRST + 1663)
#define idsSendLaterUsing               (STR_FIRST + 1664)
#define idsSendLaterOneAccount          (STR_FIRST + 1665)
#define idsConfirmResetServer           (STR_FIRST + 1666)
#define idsConfirmResetGroup            (STR_FIRST + 1667)
#define idsNotApplicable                (STR_FIRST + 1668)
#define idsIMAPPollUnreadFailuresFmt    (STR_FIRST + 1670)
#define idsIMAPPollUnreadIMAP4Fmt       (STR_FIRST + 1671)
#define idsLameStatus                   (STR_FIRST + 1672)
#define idsNoAccountsFound              (STR_FIRST + 1673)
#define idsErrSecurityCertDisappeared   (STR_FIRST + 1674)
#define idsErrSecuritySendExpiredSign   (STR_FIRST + 1675)
#define idsErrSecuritySendTrust         (STR_FIRST + 1676)
#define idsErrSecuritySendExpiredEnc    (STR_FIRST + 1677)
#define idsNoNewsAccountsFound          (STR_FIRST + 1679)

#define idsSpoolerTackTT                (STR_FIRST + 1678)
// Strings used in Simple MAPI - vsnatar
#define idsAttachedFiles                (STR_FIRST + 1700)
#define idsBlank                        (STR_FIRST + 1701)

#define idsIMAPFolderReadOnly           (STR_FIRST + 1702)
#define idsFolderPropStatusIMAP         (STR_FIRST + 1703)
#define idsFileExistWarning             (STR_FIRST + 1704)
#define idsIMAPDeleteFldrTitleFmt       (STR_FIRST + 1705)

#define idsThen                         (STR_FIRST + 1710)
#define idsRulesLocal1                  (STR_FIRST + 1711)
#define idsRulesLocal2                  (STR_FIRST + 1712)
#define idsRulesLocal3                  (STR_FIRST + 1713)

#define idsIMAPNoFldrsRefreshPrompt     (STR_FIRST + 1714)
#define idsIMAPDirtyFldrsRefreshPrompt  (STR_FIRST + 1715)
#define idsIMAPNewAcctRefreshPrompt     (STR_FIRST + 1716)
#define idsLogOffUser                   (STR_FIRST + 1717)
#define idsErrBadMHTMLLinks             (STR_FIRST + 1718)
#define idsAbortDownload                (STR_FIRST + 1719)
#define idsErrWorkingOffline            (STR_FIRST + 1720)
#define idsSyncCacheWithSvr             (STR_FIRST + 1721)
#define idsLogOffTitle                  (STR_FIRST + 1722)
#define idsLogOffPrompt                 (STR_FIRST + 1723)
#define idsIMAPSubscrAllMemory          (STR_FIRST + 1724)

#ifdef WIN16
#define idsOE16NotSupportNews           (STR_FIRST + 1725)
#define idsFileTooBig                   (STR_FIRST + 1726)
#endif

#define idsNewAthenaUser                (STR_FIRST + 1727)
#define idsStatusTipConnectedDUN        (STR_FIRST + 1728)
#define idsStatusTipWorkOffline         (STR_FIRST + 1729)
#define idsPickStationery               (STR_FIRST + 1730)
#define idsSearching                    (STR_FIRST + 1731)
#define idsWarnBoringStationery         (STR_FIRST + 1732)
#define idsWarnSMapi                    (STR_FIRST + 1733)
#define idsWelcomeFromDisplay           (STR_FIRST + 1734)
#define idsWelcomeFromEmail             (STR_FIRST + 1735)
#define idsOutlookNews                  (STR_FIRST + 1736)
#define idsNewsgroupsMenu               (STR_FIRST + 1737)
#define idsNewsgroupFiltersMenu         (STR_FIRST + 1738)
#define idsNotDefOutNewsClient          (STR_FIRST + 1739)
#define idsAlwaysCheckOutNews           (STR_FIRST + 1740)
#define idsApplyStationeryGeneralHelp   (STR_FIRST + 1741)
#define idsCantSaveIMAPMsgFmt           (STR_FIRST + 1742)
#define idsUploadingIMAPDraftFmt        (STR_FIRST + 1743)
#define idsIMAPNoDraftsFolder           (STR_FIRST + 1744)
#define idsIMAPNoSentItemsFolder        (STR_FIRST + 1745)
#define idsIMAPCreatingSpecialFldrFmt   (STR_FIRST + 1746)
#define idsAboutOutlookNewsTitle        (STR_FIRST + 1747)
#define idsIMAPUpldSentItemsEventFmt    (STR_FIRST + 1748)
#define idsIMAPUpldSentItemsFailureFmt  (STR_FIRST + 1749)
#define IDS_ERROR_PREFIX1               (STR_FIRST + 1750)
#define IDS_ERROR_CREATE_INSTMUTEX      (STR_FIRST + 1751)
#define IDS_ERROR_MIMEOLE_ALLOCATOR     (STR_FIRST + 1752)
#define IDS_ERROR_FIRST_TIME_ICW        (STR_FIRST + 1753)
#define IDS_ERROR_INITSTORE_DIRECTORY   (STR_FIRST + 1754)
#define IDS_ERROR_REGCREATE_ROOT        (STR_FIRST + 1755)
#define IDS_ERROR_CREATE_HDRHEAP        (STR_FIRST + 1756)
#define IDS_ERROR_REG_WNDCLASS          (STR_FIRST + 1757)
#define IDS_ERROR_CREATEWINDOW          (STR_FIRST + 1758)
#define IDS_ERROR_INIT_GOPTIONS         (STR_FIRST + 1759)
#define IDS_ERROR_OPTNOTIFY_REG         (STR_FIRST + 1760)
#define IDS_ERROR_INITSTORE             (STR_FIRST + 1761)
#define IDS_ERROR_ALLOC_SUBMAN          (STR_FIRST + 1762)
#define IDS_ERROR_CREATE_ACCTMAN        (STR_FIRST + 1763)
#define IDS_ERROR_ALLOC_MIGRATESRV      (STR_FIRST + 1764)
#define IDS_ERROR_INIT_MIGRATESRV       (STR_FIRST + 1765)
#define IDS_ERROR_ALLOC_ACCTADVISE      (STR_FIRST + 1766)
#define IDS_ERROR_INIT_ACCTADVISE       (STR_FIRST + 1767)
#define IDS_ERROR_INIT_ACCTMAN          (STR_FIRST + 1768)
#define IDS_ERROR_ADVISE_ACCTMAN        (STR_FIRST + 1769)
#define IDS_ERROR_ALLOC_CONMAN          (STR_FIRST + 1770)
#define IDS_ERROR_INIT_CONMAN           (STR_FIRST + 1771)
#define IDS_ERROR_CREATE_SPOOLER        (STR_FIRST + 1772)
#define IDS_ERROR_CREATE_FONTCACHE      (STR_FIRST + 1773)
#define IDS_ERROR_REASON1               (STR_FIRST + 1774)
#define IDS_ERROR_REASON2               (STR_FIRST + 1775)
#define IDS_ERROR_START_HELP            (STR_FIRST + 1776)
#define IDS_ERROR_UNKNOWN               (STR_FIRST + 1777)
#define IDS_ERROR_FILE_NOEXIST          (STR_FIRST + 1778)
#define idsOperationAborted             (STR_FIRST + 1779)
#define idsIMAPUpldSentItemsDeleteFail  (STR_FIRST + 1780)
#define idsIMAPUpldSentItemsMoveFail    (STR_FIRST + 1781)
#define idsConfirmChangeStoreLocation   (STR_FIRST + 1782)
#define idsCantMoveStoreToSubfolder     (STR_FIRST + 1783)
#define idsMoveStoreProgress            (STR_FIRST + 1784)
#define idsResNameEmailAddress          (STR_FIRST + 1786)
#define idsResNamePerInfo               (STR_FIRST + 1787)
#define idsResNameAddress               (STR_FIRST + 1788)
#define idsResNameBusInfo               (STR_FIRST + 1789)
#define idsResNameTitle                 (STR_FIRST + 1790)
#define idsResNameDept                  (STR_FIRST + 1791)
#define idsResNameOff                   (STR_FIRST + 1792)
#define idsResNameComp                  (STR_FIRST + 1793)
#define idsResNameNotes                 (STR_FIRST + 1794)
#define idsResNamePhone                 (STR_FIRST + 1795)
#define idsResNameFax                   (STR_FIRST + 1796)
#define idsResNameCellular              (STR_FIRST + 1797)
#define idsResNameWeb                   (STR_FIRST + 1798)
#define idsResNamePager                 (STR_FIRST + 1799)
#define idsSavedToLocalDraftsInstead    (STR_FIRST + 1800)
#define idsSaveNowUploadLater           (STR_FIRST + 1801)
#define idsSavedToIMAPDraftFmt          (STR_FIRST + 1802)
#define idsSpoolerUserCancel            (STR_FIRST + 1803)
#define idsGrpDlgEmtpyList              (STR_FIRST + 1804)
#define idsEmptyFolder                  (STR_FIRST + 1805)
#define idsEmptyFolderFilter            (STR_FIRST + 1806)
#define idsEmptyNewsgroup               (STR_FIRST + 1807)
#define idsEmptyNewsgroupFilter         (STR_FIRST + 1808)
#define idsNoFindResults                (STR_FIRST + 1809)
#define IDS_ERROR_PREFIX2               (STR_FIRST + 1810)
#define IDS_ERROR_GETPROCSTART          (STR_FIRST + 1811)
#define IDS_ERROR_MISSING_DLL           (STR_FIRST + 1812)
#define idsDefaultSignature             (STR_FIRST + 1813)
#define idsSigNameFmt                   (STR_FIRST + 1814)
#define IDS_SP_E_CANT_MOVETO_SENTITEMS  (STR_FIRST + 1815)
#define idsType                         (STR_FIRST + 1816)
#define idsMail                         (STR_FIRST + 1817)
#define idsNews                         (STR_FIRST + 1818)
#define idsSearchingNews                (STR_FIRST + 1819)
#define idsSearchingIMAP                (STR_FIRST + 1820)
#define idsUnreadText                   (STR_FIRST + 1821)
#define idsIMAPCloseFailed              (STR_FIRST + 1822)
#define idsPapFBarFont                  (STR_FIRST + 1823)
#define idsPapFBarText                  (STR_FIRST + 1824)
#define idsErrSelectOneColumn           (STR_FIRST + 1825)
#define idsWorkOffline                  (STR_FIRST + 1826)
#define idsConfigServer                 (STR_FIRST + 1827)
#define idsIMAPSearchSettingsFail       (STR_FIRST + 1828)
#define idsIMAPCouldNotConnectFmt       (STR_FIRST + 1829)
#define idsIMAPUploadSettingsFailFmt    (STR_FIRST + 1830)
#define idsIMAPDownloadSettingsFailFmt  (STR_FIRST + 1831)
#define idsIMAPDLSettingsTitle          (STR_FIRST + 1832)
#define idsIMAPULSettingsTitle          (STR_FIRST + 1833)
#define idsCouldNotSelectFldr           (STR_FIRST + 1834)
#define idsIMAPUploadingSettings        (STR_FIRST + 1835)
#define idsIMAPDownloadingSettings      (STR_FIRST + 1836)
#define idsIMAPSelectingSettingsFldr    (STR_FIRST + 1837)
#define idsIMAPSearchingForSettings     (STR_FIRST + 1838)
#define idsIMAPCreatingSettingsFldr     (STR_FIRST + 1839)
#define idsIMAPDeletingOldSettings      (STR_FIRST + 1840)
#define idsConfigSvrLogin               (STR_FIRST + 1841)
#define idsConfigServerAcct             (STR_FIRST + 1842)
#define idsConfigDataMsgText            (STR_FIRST + 1843)
#define idsColumnDlgTitle               (STR_FIRST + 1844)
#define idsMailSig                      (STR_FIRST + 1845)
#define idsNewsSig                      (STR_FIRST + 1846)
#define idsMigrateFolder                (STR_FIRST + 1847)
#define idsLocalStore                   (STR_FIRST + 1848)
//
// end string Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Menu Command IDs (commands, not MENU resources!)
//
//  NOTE: toolbar cmd ids for DefView must be between
//          0 and (SFVIDM_CLIENT_LAST-SFVIDM_CLIENT_LAST)!!!
// all the commands between IDM_FIRST and IDM_LAST have
// a tooltip string and/or a status bar string associated with them
#define IDM_FIRST                       100
#define idmNewMsg                       (IDM_FIRST + 0)  
#define idmNewContact                   (IDM_FIRST + 1)  
#define idmHelpAbout                    (IDM_FIRST + 2)  
#define idmPrint                        (IDM_FIRST + 3)  
#define idmCompactAll                   (IDM_FIRST + 4)
#define idmCloseFind                    (IDM_FIRST + 5)
#define idmOpenContainer                (IDM_FIRST + 6)
#define idmOpen                         (IDM_FIRST + 9)  
#define idmSaveAs                       (IDM_FIRST + 10) 
#define idmFind                         (IDM_FIRST + 11) 
#define idmRedo                         (IDM_FIRST + 12) 
#define idmHelpTopics                   (IDM_FIRST + 13) 
#define idmSaveAttach                   (IDM_FIRST + 15) 
#define idmProperties                   (IDM_FIRST + 16) 
#define idmUndo                         (IDM_FIRST + 17) 
#define idmCut                          (IDM_FIRST + 18) 
#define idmCopy                         (IDM_FIRST + 19) 
#define idmPaste                        (IDM_FIRST + 20) 
#define idmDelete                       (IDM_FIRST + 21) 
#define idmSelectAll                    (IDM_FIRST + 22) 
#define idmMarkRead                     (IDM_FIRST + 23) 
#define idmMarkUnread                   (IDM_FIRST + 24) 
#define idmMarkTopicRead                (IDM_FIRST + 25) 
#define idmMarkAllRead                  (IDM_FIRST + 26) 
#define idmMarkDownload                 (IDM_FIRST + 27) 
#define idmMarkTopicDownload            (IDM_FIRST + 28) 
#define idmViewDecrypt                  (IDM_FIRST + 35)
#define idmColumns                      (IDM_FIRST + 37)
#define idmPopupArrange                 (IDM_FIRST + 38)
#define idmNext                         (IDM_FIRST + 39)
#define idmPrevious                     (IDM_FIRST + 40)
#define idmNewArticle                   (IDM_FIRST + 41)
#define idmReply                        (IDM_FIRST + 42)
#define idmReplyAll                     (IDM_FIRST + 43)
#define idmReplyPost                    (IDM_FIRST + 44)
#define idmReplyMail                    (IDM_FIRST + 45)
#define idmForward                      (IDM_FIRST + 46)
#define idmGetNextHeaders               (IDM_FIRST + 47)
#define idmNextUnreadNewsgroup          (IDM_FIRST + 50)
#define idmNextUnreadArticle            (IDM_FIRST + 51)
#define idmSubscribeNews                (IDM_FIRST + 52)
#define idmDeliverMail                  (IDM_FIRST + 54)
#define idmGotoInbox                    (IDM_FIRST + 55)
#define idmMoveTo                       (IDM_FIRST + 57)
#define idmCopyTo                       (IDM_FIRST + 58)
#define idmSortAsc                      (IDM_FIRST + 60)
#define idmSortDesc                     (IDM_FIRST + 61)

#define idmFldrCreate                   (IDM_FIRST + 63)
#define idmFldrRename                   (IDM_FIRST + 64)
#define idmFldrEmpty                    (IDM_FIRST + 65)
#define idmFldrCreate2                  (IDM_FIRST + 66)
#define idmPrintNow                     (IDM_FIRST + 68)
                               
#define idmFmtFont                      (IDM_FIRST + 70)
#define idmFmtSize                      (IDM_FIRST + 71)
#define idmFmtColor                     (IDM_FIRST + 72)
#define idmFmtColorAuto                 (IDM_FIRST + 73)
#define idmFmtColor1                    (IDM_FIRST + 74)
#define idmFmtColor2                    (IDM_FIRST + 75)
#define idmFmtColor3                    (IDM_FIRST + 76)
#define idmFmtColor4                    (IDM_FIRST + 77)
#define idmFmtColor5                    (IDM_FIRST + 78)
#define idmFmtColor6                    (IDM_FIRST + 79)
#define idmFmtColor7                    (IDM_FIRST + 80)
#define idmFmtColor8                    (IDM_FIRST + 81)
#define idmFmtColor9                    (IDM_FIRST + 82)
#define idmFmtColor10                   (IDM_FIRST + 83)
#define idmFmtColor11                   (IDM_FIRST + 84)
#define idmFmtColor12                   (IDM_FIRST + 85)
#define idmFmtColor13                   (IDM_FIRST + 86)
#define idmFmtColor14                   (IDM_FIRST + 87)
#define idmFmtColor15                   (IDM_FIRST + 88)
#define idmFmtColor16                   (IDM_FIRST + 89)
#define idmFmtBold                      (IDM_FIRST + 90)
#define idmFmtItalic                    (IDM_FIRST + 91)
#define idmFmtUnderline                 (IDM_FIRST + 92)
#define idmFmtBullets                   (IDM_FIRST + 93)
#define idmFmtDecreaseIndent            (IDM_FIRST + 94)
#define idmFmtIncreaseIndent            (IDM_FIRST + 95)
#define idmFmtLeft                      (IDM_FIRST + 96)
#define idmFmtCenter                    (IDM_FIRST + 97)
#define idmFmtRight                     (IDM_FIRST + 98)
#define idmFmtFontDlg                   (IDM_FIRST + 101)
#define idmPriLow                       (IDM_FIRST + 102)
#define idmPriNormal                    (IDM_FIRST + 103)
#define idmPriHigh                      (IDM_FIRST + 104)
#define idmFmtParagraph                 (IDM_FIRST + 105)
#define idmSave                         (IDM_FIRST + 106)
#define idmSendMsg                      (IDM_FIRST + 107)
#define idmCheckNames                   (IDM_FIRST + 108)
#define idmPickRecipients               (IDM_FIRST + 109)
#define idmInsertFile                   (IDM_FIRST + 110)
#define idmToolbar                      (IDM_FIRST + 111)
#define idmFormatBar                    (IDM_FIRST + 112)
#define idmClose                        (IDM_FIRST + 113)
#define idmPopupPri                     (IDM_FIRST + 114)
#define idmPopupFormat                  (IDM_FIRST + 115)
#define idmAccelCycleBkColor            (IDM_FIRST + 117)
#define idmSubscribeGroup               (IDM_FIRST + 119)
#define idmConnect                      (IDM_FIRST + 120)
#define idmPopupPreview                 (IDM_FIRST + 126)
#define idmNextUnreadThread             (IDM_FIRST + 127)
#define idmSpelling                     (IDM_FIRST + 128)
#define idmGotoNewsgroup                (IDM_FIRST + 129)
#define idmCancelArticle                (IDM_FIRST + 130)
#define idmViewContacts                 (IDM_FIRST + 131)
#define idmPopupOffline                 (IDM_FIRST + 132)
#define idmFindText                     (IDM_FIRST + 133)
#define idmPostMsg                      (IDM_FIRST + 134)
#define idmPickGroups                   (IDM_FIRST + 135)
#define idmPopupImport                  (IDM_FIRST + 136)
#define idmPopupExport                  (IDM_FIRST + 137)
#define idmImportAddressBook            (IDM_FIRST + 138)
#define idmImportMessages               (IDM_FIRST + 139)
#define idmExportAddressBook            (IDM_FIRST + 140)
#define idmExportMessages               (IDM_FIRST + 141)
#define idmImportAccts                  (IDM_FIRST + 142)
#define idmThreadArticles               (IDM_FIRST + 149)
#define idmViewNewGroups                (IDM_FIRST + 152)
#define idmCombineAndDecode             (IDM_FIRST + 153)
#define idmInsertSig                    (IDM_FIRST + 154)
#define idmNotePopupInsert              (IDM_FIRST + 158)
#define idmForwardMsgAttach             (IDM_FIRST + 161)
#define idmExpandThread                 (IDM_FIRST + 162)
#define idmCollapseThread               (IDM_FIRST + 163)
#define idmSortToggle                   (IDM_FIRST + 164)
#define idmFldrCompact                  (IDM_FIRST + 165)
#define idmSaveAttachAll                (IDM_FIRST + 167)

// Ole Object Verbs
//
#define idmNoteOle_First                (IDM_FIRST + 168)
#define idmNoteOle_Last                 (IDM_FIRST + 200)
// brettm: reserved a block of extra verbs for ole objects
// please don't reassign these, without talking to me.

// AddrObject:
#define idmAddrObj_Props                (idmNoteOle_First)
#define idmAddrObj_AddToWAB             (idmNoteOle_First+1)
#define idmAddrObj_Find                 (idmNoteOle_First+2)
// End: Ole Object Verbs
//

#define idmFillPreview                  (IDM_FIRST + 201)
#define idmViewFullHeaders              (IDM_FIRST + 202)
#define idmSep1                         (IDM_FIRST + 203)
#define idmSep2                         (IDM_FIRST + 204)

// reserved block of cmds for add to WAB dynamic menu
#define idmAddRecipToWAB_First          (IDM_FIRST + 207)
#define idmAddRecipToWAB_Last           (IDM_FIRST + 230) 
// reserved block of cmds for add to WAB dynamic menu

#define idmPopupAddToWAB                (IDM_FIRST + 231)
#define idmAddSenderToWAB               (IDM_FIRST + 232)
#define idmReadme                       (IDM_FIRST + 233)
#define idmFindNext                     (IDM_FIRST + 234)


//-------------------------------------------------------
// Language Command Ids
#define idmLanguagePopup                (IDM_FIRST + 237)
#define idmUSASCII                      (IDM_FIRST + 238)
#define idmLangFirst                    idmUSASCII
#define idmWesternEuropean              (IDM_FIRST + 239)
#define idmCentralEuropeanISO           (IDM_FIRST + 240)
#define idmCentralEuropeanWindows       (IDM_FIRST + 241)
#define idmRussianKOI8R                 (IDM_FIRST + 242)
#define idmRussianWindows               (IDM_FIRST + 243)
#define idmBalticISO                    (IDM_FIRST + 244)
#define idmBalticWindows                (IDM_FIRST + 245)
#define idmGreekISO                     (IDM_FIRST + 246)
#define idmGreekWindows                 (IDM_FIRST + 247)
#define idmTurkishISO                   (IDM_FIRST + 248)
#define idmTurkishWindows               (IDM_FIRST + 249)
#define idmJapaneseJisAuto              (IDM_FIRST + 250)
#define idmJapaneseJis                  (IDM_FIRST + 251)
#define idmJapaneseSJisAuto             (IDM_FIRST + 252)
#define idmJapaneseSJis                 (IDM_FIRST + 253)
#define idmJapaneseEucAuto              (IDM_FIRST + 254)
#define idmJapaneseEuc                  (IDM_FIRST + 255)
#define idmSimpChineseCnGb              (IDM_FIRST + 256)
#define idmSimpChineseHzGb              (IDM_FIRST + 257)
#define idmSimpChineseGbk               (IDM_FIRST + 258)
#define idmTradChineseCnBig5            (IDM_FIRST + 259)
#define idmTradChineseBig5              (IDM_FIRST + 260)
#define idmKoreanKsc                    (IDM_FIRST + 261)
#define idmLangLast                     (IDM_FIRST + 280)
#define idmLanguage                     (IDM_FIRST + 281)
//-------------------------------------------------------

#define idmCleanUpFiles                 (IDM_FIRST + 282)
#define idmCustomizeToolbar             (IDM_FIRST + 283)
#define idmCoolbarTop                   (IDM_FIRST + 284)
#define idmCoolbarLeft                  (IDM_FIRST + 285)
#define idmCoolbarBottom                (IDM_FIRST + 286)
#define idmCoolbarRight                 (IDM_FIRST + 287)
#define idmPostAndDownload              (IDM_FIRST + 288)
#define idmMarkNewsgroups               (IDM_FIRST + 289)
#define idmMarkAllDownload              (IDM_FIRST + 290)
#define idmUnmark                       (IDM_FIRST + 291)
#define idmDisconnect                   (IDM_FIRST + 292)
#define idmGotoOutbox                   (IDM_FIRST + 293)
#define idmInboxRules                   (IDM_FIRST + 295)
#define idmReplyPostAndMail             (IDM_FIRST + 296)
#define idmPopupFmtAlign                (IDM_FIRST + 297)
#define idmFmtSettings                  (IDM_FIRST + 298)
#define idmFmtHTML                      (IDM_FIRST + 299)
#define idmFmtPlain                     (IDM_FIRST + 300)
#define idmIconsWithText                (IDM_FIRST + 301)
#define idmSaveMessage                  (IDM_FIRST + 303)
#define idmDebugCoolbar                 (IDM_FIRST + 304)
#define idmWebNewsFind                  (IDM_FIRST + 305)
#define idmStop                         (IDM_FIRST + 307)
#define idmHelpMSWeb                    (IDM_FIRST + 308)
#define idmHelpMSWebFree                (IDM_FIRST + 309)
#define idmHelpMSWebProductNews         (IDM_FIRST + 310)
#define idmHelpMSWebFaq                 (IDM_FIRST + 311)
#define idmHelpMSWebSupport             (IDM_FIRST + 312)
#define idmHelpMSWebFeedback            (IDM_FIRST + 313)
#define idmHelpMSWebBest                (IDM_FIRST + 314)
#define idmHelpMSWebSearch              (IDM_FIRST + 315)
#define idmHelpMSWebHome                (IDM_FIRST + 316)
#define idmHelpMSWebOutlook             (IDM_FIRST + 317)
#define idmHelpMSWebHotmail             (IDM_FIRST + 321)
#define idmHelpMSWebLast                (IDM_FIRST + 328)
#define idmViewNews                     (IDM_FIRST + 329)
#define idmViewMail                     (IDM_FIRST + 330)
#define idmBrowseWeb                    (IDM_FIRST + 331)
#define idmInsertText                   (IDM_FIRST + 332)
#define idmPopupFilter                  (IDM_FIRST + 338)
#define idmViewAllArticles              (IDM_FIRST + 339)
#define idmViewUnreadArticles           (IDM_FIRST + 340)
#define idmViewBodiedArticles           (IDM_FIRST + 341)
#define idmGroupFilters                 (IDM_FIRST + 342)
#define idmViewTipOfTheDay              (IDM_FIRST + 343)
#define idmNewsNewServer                (IDM_FIRST + 344)
#define idmNewsRemoveServer             (IDM_FIRST + 345)
#define idmNewsSetDefaultServer         (IDM_FIRST + 346)
#define idmAccounts                     (IDM_FIRST + 348)
#define idmGetNewHeaders                (IDM_FIRST + 349)
#define idmGetNewMsgs                   (IDM_FIRST + 350)
#define idmGetAllMsgs                   (IDM_FIRST + 351)
#define idmCatchUp                      (IDM_FIRST + 352)
#define idmGetMarkedMsgs                (IDM_FIRST + 353)
#define idmDigSign                      (IDM_FIRST + 360)
#define idmEncrypt                      (IDM_FIRST + 361)
#define idmViewFolders                  (IDM_FIRST + 362)
#define idmViewRefresh                  (IDM_FIRST + 365)
#define idmViewOptions                  (IDM_FIRST + 366)
#define idmGoBack                       (IDM_FIRST + 368)
#define idmGoForward                    (IDM_FIRST + 369)
#define idmGoUpOneLevel                 (IDM_FIRST + 370)
#define idmGoNextUnreadMsg              (IDM_FIRST + 371)
#define idmGoNextUnreadFolder           (IDM_FIRST + 372)
#define idmFavoritesAddToFavorites      (IDM_FIRST + 373)
#define idmFavoritesOrganizeFavorites   (IDM_FIRST + 374)
#define idmPopupGo                      (IDM_FIRST + 375)
#define idmPopupFavorites               (IDM_FIRST + 376)
#define idmLanguageDelay                (IDM_FIRST + 377)
#define idmSendImages                   (IDM_FIRST + 379)

// why are these in the 400s?
#define idmReceiveFrom                  (IDM_FIRST + 450)
#define idmSendOutbox                   (IDM_FIRST + 451)
#define idmMarkNewHeaderDownload        (IDM_FIRST + 452)
#define idmMarkAllMsgDownload           (IDM_FIRST + 453)
#define idmMarkNewMsgDownload           (IDM_FIRST + 454)
#define idmInsertImage                  (IDM_FIRST + 458)
#ifdef BETA2_MENU
#define idmInsertLink                   (IDM_FIRST + 459)
#endif
#define idmUnDelete                     (IDM_FIRST + 460)
#define idmExpunge                      (IDM_FIRST + 461)
#define idmViewDeletedArticles          (IDM_FIRST + 462)
#define idmFolders                      (IDM_FIRST + 463)
#define idmSubscribeFolder              (IDM_FIRST + 464)
#define idmDownloadAttach               (IDM_FIRST + 465)
#define idmStatusbar                    (IDM_FIRST + 466)
#define idmUnInsertLink                 (IDM_FIRST + 467)
#define idmRefreshFolders               (IDM_FIRST + 469)
#define idmViewFilteredArticles         (IDM_FIRST + 471)
#define idmSyncAll                      (IDM_FIRST + 472)
#define idmSyncSelected                 (IDM_FIRST + 473)
#define idmMarkDownloadMenu             (IDM_FIRST + 474)
#define idmFmtNumbers                   (IDM_FIRST + 475)
#define idmFmtInsertHLine               (IDM_FIRST + 476)
#define idmPopupFmtBkground             (IDM_FIRST + 480)
#define idmFmtBkgroundImage             (IDM_FIRST + 481)
#define idmPopupFmtBkgroundColor        (IDM_FIRST + 482)

#define idmBkColorAuto                  (IDM_FIRST + 490)
#define idmBkColor1                     (IDM_FIRST + 491)
#define idmBkColor2                     (IDM_FIRST + 492)
#define idmBkColor3                     (IDM_FIRST + 493)
#define idmBkColor4                     (IDM_FIRST + 494)
#define idmBkColor5                     (IDM_FIRST + 495)
#define idmBkColor6                     (IDM_FIRST + 496)
#define idmBkColor7                     (IDM_FIRST + 497)
#define idmBkColor8                     (IDM_FIRST + 498)
#define idmBkColor9                     (IDM_FIRST + 499)
#define idmBkColor10                    (IDM_FIRST + 500)
#define idmBkColor11                    (IDM_FIRST + 501)
#define idmBkColor12                    (IDM_FIRST + 502)
#define idmBkColor13                    (IDM_FIRST + 503)
#define idmBkColor14                    (IDM_FIRST + 504)
#define idmBkColor15                    (IDM_FIRST + 505)
#define idmBkColor16                    (IDM_FIRST + 506)
#define idmBodyViewSource               (IDM_FIRST + 507)
#define idmMarkAllHeaderDownload        (IDM_FIRST + 508)
#define idmPopupCompose                 (IDM_FIRST + 509)
#define idmPopupFolder                  (IDM_FIRST + 510)
#define idmPopupFonts                   (IDM_FIRST + 511)
#define idmPopupNew                     (IDM_FIRST + 512)
#define idmPopupNext                    (IDM_FIRST + 513)
#define idmPopupSynchronize             (IDM_FIRST + 514)
#define idmPopupToolbar                 (IDM_FIRST + 515)
#define idmPopupTools                   (IDM_FIRST + 516)
#define idmGotoMeeting                  (IDM_FIRST + 517)
#define idmViewNewWindow                (IDM_FIRST + 518)
#define idmFldrMove                     (IDM_FIRST + 519)
#define idmFldrCopy                     (IDM_FIRST + 520)
#define idmFldrDelete                   (IDM_FIRST + 521)
#define idmGotoChat                     (IDM_FIRST + 522)
#define idmFontSmallest                 (IDM_FIRST + 523)
#define idmFontSmaller                  (IDM_FIRST + 524)
#define idmFontMedium                   (IDM_FIRST + 525)    
#define idmFontLarger                   (IDM_FIRST + 526)
#define idmFontLargest                  (IDM_FIRST + 527)
#define idmGotoFolder                   (IDM_FIRST + 528)
#define idmGotoNews                     (IDM_FIRST + 529)
#ifdef BETA2_MENU
#define idmEditPicture                  (IDM_FIRST + 530)
#endif
#define idmEditLink                     (IDM_FIRST + 531)
#define idmTridentProps                 (IDM_FIRST + 532)
#define idmNewMsg2                      (IDM_FIRST + 533)  
#define idmNewArticle2                  (IDM_FIRST + 534)
#define idmPopupFile                    (IDM_FIRST + 535)
#define idmPopupEdit                    (IDM_FIRST + 536)
#define idmPopupView                    (IDM_FIRST + 537)
#define idmPopupHelp                    (IDM_FIRST + 538)
#define idmBodyViewMsgSource            (IDM_FIRST + 539)
#define idmCtxtAddToWab                 (IDM_FIRST + 541)
#define idmCtxtAddToFavorites           (IDM_FIRST + 542)
#define idmSendWebPage                  (IDM_FIRST + 543)
#define idmPopupFmtTag                  (IDM_FIRST + 544)
#define idmFmtTag                       (IDM_FIRST + 545)
#define idmViewReplyArticles            (IDM_FIRST + 546)
#define idmInsertVCard                  (IDM_FIRST + 547)
#define idmSyncAccount                  (IDM_FIRST + 548)
#define idmMarkThisNewsgroup            (IDM_FIRST + 549)
#define idmStationery                   (IDM_FIRST + 550)
#define idmFindPeople                   (IDM_FIRST + 551)
#define idmRSList0                      (IDM_FIRST + 552)
#define idmRSList1                      (IDM_FIRST + 553)
#define idmRSList2                      (IDM_FIRST + 554)
#define idmRSList3                      (IDM_FIRST + 555)
#define idmRSList4                      (IDM_FIRST + 556)
#define idmRSList5                      (IDM_FIRST + 557)
#define idmRSList6                      (IDM_FIRST + 558)
#define idmRSList7                      (IDM_FIRST + 559)
#define idmRSList8                      (IDM_FIRST + 560)
#define idmRSList9                      (IDM_FIRST + 561)
#define idmMoreStationery               (IDM_FIRST + 562)
#define idmNewPopup                     (IDM_FIRST + 563)
#define idmVCardDelete                  (IDM_FIRST + 564)
#define idmVCardProperties              (IDM_FIRST + 565)
#define idmGotoDraft                    (IDM_FIRST + 566)
#define idmSpoolerWarnings              (IDM_FIRST + 567)
#define idmSpoolerShow                  (IDM_FIRST + 568)
#define idmCloseBrowser                 (IDM_FIRST + 569)
#define idmSubscribeAllFldrs            (IDM_FIRST + 570)
#define idmUnsubscribeAllFldrs          (IDM_FIRST + 571)
#define idmUnsubscribeFolder            (IDM_FIRST + 572)
#define idmSendLater                    (IDM_FIRST + 574)
#define idmPostLater                    (IDM_FIRST + 575)
#define idmNoStationery                 (IDM_FIRST + 576)
#define idmSavePicture                  (IDM_FIRST + 577)
#define idmSendDefault                  (IDM_FIRST + 578)
#define idmPostDefault                  (IDM_FIRST + 579)
#define idmPaneSigning                  (IDM_FIRST + 580)
#define idmPaneEncryption               (IDM_FIRST + 581)
#define idmPanePaperclip                (IDM_FIRST + 582)
#define idmPaneVCard                    (IDM_FIRST + 583)
#define idmDSPViewProp                  (IDM_FIRST + 584)
#define idmDSPViewCert                  (IDM_FIRST + 585)
#define idmDSPTrust                     (IDM_FIRST + 586)
#define idmDSPHelp                      (IDM_FIRST + 587)
#define idmEPViewProp                   (IDM_FIRST + 588)
#define idmEPViewCert                   (IDM_FIRST + 589)
#define idmEPHelp                       (IDM_FIRST + 590)
#define idmLogOffUser                   (IDM_FIRST + 591)
#define idmWorkOffline                  (IDM_FIRST + 592)
#define idmIMAPDeliverMail              (IDM_FIRST + 593)
#define idmSaveBackground               (IDM_FIRST + 594)
#define idmSaveAsStationery             (IDM_FIRST + 595)
#define idmFmtApplyStationeryPopup      (IDM_FIRST + 596)
#define idmApplyMoreStationery          (IDM_FIRST + 597)
#define idmApplyNoStationery            (IDM_FIRST + 598)
#define idmApplyStationery0             (IDM_FIRST + 599)
#define idmApplyStationery1             (IDM_FIRST + 600)
#define idmApplyStationery2             (IDM_FIRST + 601)
#define idmApplyStationery3             (IDM_FIRST + 602)
#define idmApplyStationery4             (IDM_FIRST + 603)
#define idmApplyStationery5             (IDM_FIRST + 604)
#define idmApplyStationery6             (IDM_FIRST + 605)
#define idmApplyStationery7             (IDM_FIRST + 606)
#define idmApplyStationery8             (IDM_FIRST + 607)
#define idmApplyStationery9             (IDM_FIRST + 608)
#define idmImportNewsAcct               (IDM_FIRST + 609)
#define idmSetPriority                  (IDM_FIRST + 610)
#define idmClearSelection               (IDM_FIRST + 611)

// DO NOT CHANGE IDM_LAST unless you have a really
// good reason. when IDM_LAST changes, all the string ids
// change and the localizers get really upset because they
// have to re-localize everything.
#define IDM_LAST                       (IDM_FIRST + 2000)

// command ID's after IDM_LAST have no tooltip assoc.
#define idmAccelBold                   (IDM_LAST + 5)
#define idmAccelItalic                 (IDM_LAST + 6)
#define idmAccelUnderline              (IDM_LAST + 7)
#define idmAccelIncreaseIndent         (IDM_LAST + 8)
#define idmAccelDecreaseIndent         (IDM_LAST + 9)
#define idmAccelBullets                (IDM_LAST + 10)
#define idmAccelLeft                   (IDM_LAST + 11)
#define idmAccelCenter                 (IDM_LAST + 12)
#define idmAccelRight                  (IDM_LAST + 13)
#define idmAccelColor                  (IDM_LAST + 14)
#define idmAccelFont                   (IDM_LAST + 15)
#define idmAccelSize                   (IDM_LAST + 16)
#define idmAccelNextCtl                (IDM_LAST + 17)
#define idmAccelPrevCtl                (IDM_LAST + 18)

//AttachWell context menu's
#define idmAttCtxLI                    (IDM_LAST + 19)
#define idmAttCtxSI                    (IDM_LAST + 21)
#define idmAttCtxRemove                (IDM_LAST + 23)
#define idmAttCtxOpen                  (IDM_LAST + 24)
#define idmAttCtxQuickView             (IDM_LAST + 25)
#define idmAttCtxSave                  (IDM_LAST + 26)
#define idmAttCtxRename                (IDM_LAST + 27)
#define idmAttCtxPrint                 (IDM_LAST + 28)
#define idmAttCtxInsertFile            (IDM_LAST + 29)
#define idmAttCtxProps                 (IDM_LAST + 30)
#define idmAttCtxPopupView             (IDM_LAST + 31)
#define idmAttDragMove                 (IDM_LAST + 32)
#define idmAttDragCopy                 (IDM_LAST + 33)
#define idmAttDragLink                 (IDM_LAST + 34)

// reserve 50 id's for sort menus
#define idmSortMenuBase                 (IDM_LAST + 36)
#define idmSortMenuLast                 (idmSortMenuBase + 50)
#define idmSentItems                    (idmSortMenuLast +1)  // Justin told me to put this id here. So don't blame me!  Ann

// Send Using Account Ranges.... (Allowing up to 100 Send Accounts)
#define idmAccountMenuFirst            (idmSentItems + 1)
#define idmAccountMenuLast             (idmAccountMenuFirst + 100)

#define idmDebugMenuFirst               (idmAccountMenuLast + 1)
#define idmTridentTest1                 (idmDebugMenuFirst)
#define idmTridentTest2                 (idmDebugMenuFirst + 1)
#define idmTridentTest3                 (idmDebugMenuFirst + 2)
#define idmTridentTest4                 (idmDebugMenuFirst + 3)
#define idmTridentTest5                 (idmDebugMenuFirst + 4)
#define idmMessageSource                (idmDebugMenuFirst + 5)
#define idmAsyncTest                    (idmDebugMenuFirst + 6)
#define idmRangeTest                    (idmDebugMenuFirst + 7)
#define idmURLTest                      (idmDebugMenuFirst + 8)
#define idmUUENCODETest                 (idmDebugMenuFirst + 9)
#define idmIMAPTest                     (idmDebugMenuFirst + 10)
#define idmPropTreeTest                 (idmDebugMenuFirst + 11)
#define idmNewsNNTXTest                 (idmDebugMenuFirst + 12)
#define idmStoreTest                    (idmDebugMenuFirst + 13)
#define idmOfflineTest                  (idmDebugMenuFirst + 14)
#define idmSpoolerStart                 (idmDebugMenuFirst + 15)
#define idmUploadConfig                 (idmDebugMenuFirst + 16)
#define idmDebugMenuLast                (idmDebugMenuFirst + 16)

// reserve 50 id's for SaveAttachments menu
#define idmSaveAttachFirst              (idmTridentTest5 + 35)
#define idmSaveAttachLast               (idmSaveAttachFirst + 50)

#define CONNECT_MENU_BASE               (idmSaveAttachLast + 1)
#define CONNECT_MENU_LAST               (CONNECT_MENU_BASE + 100)

// reserve 50 id's for format bar style menu
#define idmFmtTagFirst                  (CONNECT_MENU_LAST + 1)
#define idmFmtTagLast                   (idmFmtTagFirst + 50)

// Reserve 100 for send later accounts
#define idmAccountLaterFirst            (idmFmtTagLast + 1)
#define idmAccountLaterLast             (idmAccountLaterFirst + 100)

// Reserve 100 for OE Extension
#define idmExtensionFirst               (idmAccountLaterLast + 1)
#define idmExtensionLast                (idmExtensionFirst + 100)

#define idmSignatureFirst               (idmExtensionLast + 1)
#define idmSignatureLast                (idmSignatureFirst + 100)

// ------------------------------------------------------

//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Bitmap Resource IDs
//
#define idbToolbarBtns                  1
#define idb16x16                        2
#define idb16x16st                      4
#define idbSplash                       5
#define idbFormatBar                    8
#define idbFormatBarFont                9
#define idbStamps                      11
#define idbBtns                        12
#define idbFolders                     16
#define idbHorzStrip                   17
#define idbSecurity                    19
#define idbFoldersLarge                20

// Don't change the order of these - SteveSer
#define idbCoolbar                     27
#define idbCoolbarHot                  28
#define idbOfflineHot                  30
// Don't change the order of these - SteveSer
 
#define idbBrand                       31
#define idbSBrand                      32
#define idbSpooler                     36
#define idbStatusBar                   37

// Don't change the order of these - SteveSer
#define idb256Coolbar                  38
#define idb256CoolbarHot               39
#define idbSmCoolbar                   40
#define idbSmCoolbarHot                41
// Don't change the order of these - SteveSer

// Don't change the order of these vvv (t-erikne)
#define idbPaneBar32                   42
#define idbPaneBar32Hot                43
#define idbPaneBar16                   44
#define idbPaneBar16Hot                45
// Don't change the order of these ^^^ (t-erikne)

#define idbPapLeft                     46
#define idbPapRight                    47

//
// END Bitmap Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Icon Resource IDs
//
#define idiMail                         2
#define idiMailNews                     idiMail
#define idiNews                         3
#define idiOEDocument                   5
#define idiPasswordKeys                 6
#define idiNewsServer                   7
#define idiNewsGroup                    8
#define idiFileAtt                      9
#define idiMessageAtt                  12
#define idiDefaultAtt                  13
#define idiMsgPropSent                 14
#define idiMsgPropUnSent               15
#define idiError                       16
#define idiUpArrow                     17
#define idiDownArrow                   18
#define idiArtPropPost                 19
#define idiArtPropUnpost               20
#define idiPhone                       21
#define idiNewMailNotify               23
#define idiPickRecip                   24
#define idiFolder                      25
#define idiNewsFolder                  27
#define idiDLNews                      42
#define idiSecure                      43
#define idiNoSecure                    44
#define idiSendReceive                 45
#define idiWindowLayout                46
#define idiToolbarLayout               47
#define idiPrePaneLayout               48
#define idiOfflineIcon                 49
#define idiPapLargeIcon                50
#define idiPapSmallIcon                51

//
// END Icon Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Animation Resource IDs
//
#define idanInbox                     1
#define idanOutbox                    2
#define idanMiniOut                   4
#define idanMiniIn                    5
#define idanDecode                    6
#define idanCompact                   7
#define idanDownloadNews              8
#define idanCopyMsgs                  9


//
// END Animation Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Dialog Resource IDs (DIALOG resource ids, not control ids!)
//
#define iddVersion                      1
#define iddSubscribe                    2
#define iddSubscribeOneServer           3
#define iddAdvSecurity                  4
#define iddPerformingRepair             5
#define iddAthenaDefault                6
#define iddStoreLocation                7
#define iddAdvSig                       8
#define iddAthPropSheet                 9
#define iddSortBy                      11
#define iddPassword                    16
#define iddInsertFile                  21 
#define iddFileExists                  24
#define iddFileExistsMult              25
#define iddSafeOpen                    26
#define iddRasLogon                    27
#define iddWebPage                     28
#define iddBkImage                     29

#define iddSpelling                    30
#define iddRangeTest                   39
#define iddPickGroup                   40
#define iddDownloadGroups              41
#define iddURLTest                     42
#define iddInboxRulesManager           43
#define iddInboxRulesEdit              44
#define iddNewFolder                   45
#define iddRasCloseConn                46

#define iddOpt_Security                47
#define iddOpt_Spelling                48
#define iddOpt_DialUp                  49
#define iddOpt_Read                    50
#define iddOpt_General                 51
#define iddOpt_Send                    52
#define iddOpt_Advanced                53
#define iddOpt_Signature               54

#define iddMsgProp_General             58
#define iddMsgProp_Details             60
#define iddMsgSource                   61
#define iddRasProgress                 62
#define iddDetailedError               63
#define iddOrderMessages               69
#define iddArtProp_General             74
#define iddStoreTest                   78
#define iddPlainRecipWarning           79

#define iddIMAPTest                    80

#define iddArticleCacheTest            81
#define iddAsyncTest                   83
#define iddCacheMan                    85
#define iddProgress                    87
#define iddFindMsg                     88
#define iddFindNNTPMsg                 89
#define iddNNTXTest                    90
#define iddCombineAndDecode            92
#define iddDownloadImapFldrs           94

#define iddMsgProp_Security_Msg        95
#define iddMsgProp_Security_WIP        96
#define iddMsgProp_Security_Sent       97
#define iddSecCerificateErr            98

#define iddIMAPSubscribe               99


// "don't show me again" dialogs
// kept in (dontshow.dlg)
// these dialogs are message-box style with a checkbox
// of id==idchkDontShowMeAgain
#define iddDSSendMail                 100
#define iddDSSendNews                 101
#define iddDSWarnDeleteThread         102
#define iddDSCancelNews               103
#define iddDSAskSubscribe             104
#define iddHTMLSettings               105
#define iddPlainSettings              106
#define iddDSPostInOutbox             107
#define iddDSSavedInSavedItems        108
#define iddDSErrHTMLInNewsIsBad       109
#define iddDSNoteLost                 110
#define iddFolderProp_General         115
#define iddGroupProp_General          116
#define iddDSDefSubList               117   //Bug# 6473 (v-snatar)

#define iddNewsProp_Cache             121
#define iddGroupFilterEdit            125
#define iddInetMailError              126
#define iddFindNewsMsg                128
#define iddFindIMAPMsg                129
#define iddInsertLink                 130
#define iddDSGroupFilters             131
#define iddDSTooMuchQuoted            132
#define iddCreateFolder               133
#define iddSelectFolder               134
#define iddImapUploadProgress         135
#define iddImapCopyProgress           136
#define iddImapDownloadProgress       137
#define iddTransportErrorDlg          138
#define iddSpoolerDlg                 140
#define iddFrameWarning               141
#define iddUpdateNewsgroup            142
#define iddGroupProp_Update           143
#define iddRasStartup                 144
#define iddStationery                 145
#define iddIntlSetting                146
#define iddCharsetConflict            147
#define iddCharsetChange              148
#define iddTimeout                    149
#define iddSelectStationery           150
#define iddViewLayout                 152
#define iddImapDeleteFldr             153

#ifdef WIN16
#define iddFontSettings               154
#endif
#define iddErrSecurityNoSigningCert   155
#define iddImapUploadDraft            156
#define iddDSIMAPDeletedMessagesWarning 158
#define iddColumns                    160

//
// END Dialog Resource IDs (DIALOG resource ids, not control ids!)
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Dialog Control IDs (control ids, not DIALOG resource ids!)
//
// These only need to be unique within a single dialog.
//

// universal dialog stuff
#define IDC_STATIC                      -1
#define idcStatic1                      3500
#define idcStatic2                      3501
#define idcStatic3                      3502
#define idcStatic4                      3503
#define idcStatic5                      3504
#define idchkDontShowMeAgain            3505

// charset conflict dialog
#define idcSendAsUnicode                100

// version dialog
#define idcVerFirst                     101
#define idcVerLast                      103
#define idcVerList                      104

// WebPage dialog
#define idTxtWebPage                    1000

// header and note controls
#define NOTE_FIRST                      1000
#define idREBody                        (NOTE_FIRST + 0)
#define idADTo                          (NOTE_FIRST + 1)
#define idADNewsgroups                  (NOTE_FIRST + 2)
#define idADCc                          (NOTE_FIRST + 3)
#define idTXTSubject                    (NOTE_FIRST + 4)
#define idADFrom                        (NOTE_FIRST + 5)
#define idbtnTo                         (NOTE_FIRST + 7)
#define idbtnCc                         (NOTE_FIRST + 8)
#define idtbNoteWnd                     (NOTE_FIRST + 9)
#define idTTWnd                         (NOTE_FIRST + 10)
#define idStamp                         (NOTE_FIRST + 11)
#define idAttach                        (NOTE_FIRST + 12)
#define idREFmtbar                      (NOTE_FIRST + 13)
#define idNoteToolbar                   (NOTE_FIRST + 14)
#define idcNoteHdr                      (NOTE_FIRST + 15)
#define idTXTDate                       (NOTE_FIRST + 16)
#define idAttNoteBody                   (NOTE_FIRST + 17)
#define idTXTFollowupTo                 (NOTE_FIRST + 18)
#define idADReplyTo                     (NOTE_FIRST + 19)
#define idTXTOrg                        (NOTE_FIRST + 20)
#define idTXTDistribution               (NOTE_FIRST + 21)
#define idTXTKeywords                   (NOTE_FIRST + 22)
#define idADApproved                    (NOTE_FIRST + 23)
#define idbtnFollowup                   (NOTE_FIRST + 24)
#define idbtnReplyTo                    (NOTE_FIRST + 25)
#define idADBCc                         (NOTE_FIRST + 26)
#define idbtnBCc                        (NOTE_FIRST + 27)
#define idSecurity                      (NOTE_FIRST + 28)
#define idStatusbar                     (NOTE_FIRST + 29)
#define idTxtBkImage                    (NOTE_FIRST + 30)
#define idTxtControl                    (NOTE_FIRST + 31)
#define idCheckSendPicture              (NOTE_FIRST + 32)
#define idBrowsePicture                 (NOTE_FIRST + 33)
#define idVCardStamp                    (NOTE_FIRST + 34)
#define idNoteRebar                     (NOTE_FIRST + 35)

// dialog
#define idbtnSendPlain              101
#define idbtnSendHTML               102

// Tools.Spelling dialog
#define PSB_Spell_Ignore            101
#define PSB_Spell_IgnoreAll         102
#define PSB_Spell_Change            103
#define PSB_Spell_ChangeAll         104
#define PSB_Spell_Add               105
#define PSB_Spell_Suggest           106
#define PSB_Spell_UndoLast          107
#define EDT_Spell_WrongWord         108
#define TXT_Spell_Error             109
#define PSB_Spell_Options           110
#define TXT_Spell_Suggest           111
#define LBX_Spell_Suggest           112
#define EDT_Spell_ChangeTo          113
#define TXT_Spell_ChangeTo          114

#define CHK_AlwaysSuggest           202
#define CHK_CheckSpellingOnSend     203
#define CHK_IgnoreUppercase         204
#define CHK_IgnoreNumbers           205
#define CHK_IgnoreDBCS              206
#define CHK_IgnoreOriginalMessage   207
#define CHK_IgnoreURL               208

#define idcSpellLanguages           209
#define idcViewDictionary           210

#define GRP_SpellOptions            511
#define GRP_SpellIgnore             512

#define idtxtFolderName             101

#define IDC_CAPTION                 1049
#define IDC_TREEVIEW                1050
#define IDC_NEWFOLDER_BTN           1051

#define IDE_URL                     1052

//Mail Options
// now stored in mail/mailopt.h

// Folder dialogs

// message property sheets:
// now stored in inc/mpropdlg.h

#define idcTxtSubject                   125
#define idcTxtBody                      126
#define idcAttachCheck                  127
#define idcTxtFrom                      132
#define idcTxtRecip                     151
#define idcDateFrom                     153
#define idcDateTo                       154
#define idcFindNow                      155
#define idcStop                         156    
#define idcReset                        157
#define idcFindCombo                    158
#define idcSubFolders                   159


// Certificate error dlg
#define idcCertList 1234
#define idGetDigitalIDs 1235

#ifdef WIN16

#define IDC_UNUSED                              1300
#define IDC_FONTS_SCRIPTS_GROUPBOX              1301
#define IDC_FONTS_CODE_PAGES_LIST               1302
#define IDC_FONTS_PROP_FONT_COMBO               1303
#define IDC_FONTS_FIXED_FONT_COMBO              1304
#define IDC_FONTS_MIME_FONT_COMBO               1305
#define IDC_FONTS_SIZE_FONT_COMBO               1306
#define IDC_FONTS_SETDEFAULT_BUTTON             1307
#define IDC_FONTS_DEFAULT_LANG_TEXT             1308

#endif

//
// END Dialog Control IDs (control ids, not DIALOG resource ids!)
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Menu Resource IDs (MENU resources, not commands!)
//
#define idmrMailContext                 4
#define idmrColumnSort                  5
#define idmrFindPopContext              6
#define idmrStampPriority               7
#define idmrCtxtEdit                    8
#define idmrCtxtReadonly                9
#define idmrMailReadNote                10
#define idmrMailSendNote                11
#define idmrCtxtWell                    12
#define idmrNewsContext                 13
#define idmrFind                        14
#define idmrAttCtxSend                  16 
#define idmrAttCtxRead                  17 
#define idmrAttCtxNoSel                 18 
#define idmrAttPopupDrapDrop            19 
#define idmrNewsReadNote                20
#define idmrNewsSendNote                21
#define idmrAddrObjCtx                  23
#define idmrCoolbarContext              24        
#define idmrNewsServerContext           29 
#define idmrNewsGroupContext            30
#define idmrIMAPSpecialContext          31 
#define idmrLocalFolderContext          32 
#define idmrIMAPContext                 34
#define idmrLocalFolder                 38
#define idmrNewsFolder                  39
#define idmrIMAPFolder                  40
#define idmrCommonFolder                41
#define idmrMailSpecialContext          42
#define idmrIMAPServerContext           43
#define idmrIMAPFolderContext           44
#define idmrRootContext                 45
#define idmrIMAPOfflineFolder           46
#define idmrIMAPOfflineServer           47
#define idmrIMAPSyncFolder              48
#define idmrIMAPSyncServer              49
#define idmrNewsOfflineFolder           50
#define idmrNewsOfflineServer           51
#define idmrNewsSyncFolder              52
#define idmrNewsSyncServer              53
#define idmrStampVCard                  54
#define idmrDigSigPopup                 55
#define idmrEncryptionPopup             56
#define idmrStationeryPopup             57
#define idmrFindNewsContext             58

//
// END Menu Resource IDs (MENU resources, not commands!)
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Cursor Resource IDs
//
#define idcurSplitHoriz                 2
#define idcurSplitVert                  3
#define idcurHand                       4
//
// END Cursor Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN RCDATA Resource IDs
//
#define IDR_FIRST                       1

//
// END RCDATA Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Accelerator Resource IDs
//
#define idacBrowser                     1
#define idacNewsView                    2
#define idacMailView                    3
#define idacMail_ReadNote               4
#define idacNews_ReadNote               5
#define idacMail_SendNote               6
#define idacNews_SendNote               7
#define idacFolderNews                  8
#define idacFolderMail                  9
#define idacIMAPView                    10
#define idacFind                        11


//
// END Accelerator Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN import/export ids.
//
#define STR_IMP_FIRST                   23000

#define iddExport                       23602
#define iddImpProgress                  23603
#define iddMigrate                      23605
#define iddSelectClient                 23606
#define iddLocation                     23607
#define iddSelectFolders                23608
#define iddAddressComplete              23609
#define iddSelectCommUser               23610
#define iddSelectAth16User              23611
#define iddProvideMailPath              23612

#define IDC_IMPORTALL_RADIO             (STR_IMP_FIRST + 1000)
#define IDC_SELECT_RADIO                (STR_IMP_FIRST + 1001)
#define IDC_IMPFOLDER_LISTVIEW          (STR_IMP_FIRST + 1002)
#define IDC_IMPFOLDER_EDIT              (STR_IMP_FIRST + 1003)
#define IDC_SELECTFOLDER_BUTTON         (STR_IMP_FIRST + 1004)
#define IDC_NEWIMPFOLDER_EDIT           (STR_IMP_FIRST + 1005)
#define IDC_SKIPFOLDER_BUTTON           (STR_IMP_FIRST + 1008)
#define IDC_ERROR_STATIC                (STR_IMP_FIRST + 1009)
#define IDC_IMPORT_COMBO                (STR_IMP_FIRST + 1010)
#define IDC_CMD_STATIC                  (STR_IMP_FIRST + 1011)
#define IDC_IMPORT_PROGRESS             (STR_IMP_FIRST + 1012)
#define IDC_FOLDER_STATIC               (STR_IMP_FIRST + 1013)
#define IDC_MESSAGE_STATIC              (STR_IMP_FIRST + 1014)
#define idcClientsListbox               (STR_IMP_FIRST + 1015)
#define idcMessagesCheck                (STR_IMP_FIRST + 1016)
#define idcAddrBookCheck                (STR_IMP_FIRST + 1017)
#define IDC_LOCATION_STATIC             (STR_IMP_FIRST + 1018)
#define IDC_LABEL                       (STR_IMP_FIRST + 1019)
#define IDC_USERLIST                    (STR_IMP_FIRST + 1020)
#define IDC_BUTT1                       (STR_IMP_FIRST + 1021)
#define IDC_EDT1                        (STR_IMP_FIRST + 1022)

#define IDB_IMPORT                      24023

#define idsOutOfMemory                  (STR_IMP_FIRST + 1)
#define idsNotEnoughDiskSpace           (STR_IMP_FIRST + 2)
#define idsImport                       (STR_IMP_FIRST + 3)
#define idsPerformExport                (STR_IMP_FIRST + 4)
#define idsExport                       (STR_IMP_FIRST + 5)
#define idsExportTitle                  (STR_IMP_FIRST + 6)
#define idsImportTitle                  (STR_IMP_FIRST + 7)
#define idsImportingFolderFmt           (STR_IMP_FIRST + 11)
#define idsExportingFolderFmt           (STR_IMP_FIRST + 12)
#define idsImportingMessageFmt          (STR_IMP_FIRST + 13)
#define idsExportError                  (STR_IMP_FIRST + 14)
#define idsMAPIStoreOpenError           (STR_IMP_FIRST + 15)
#define idsMAPIInitError                (STR_IMP_FIRST + 16)
#define idsAddressUnknownFmt            (STR_IMP_FIRST + 17)
#define idsFolderOpenFail               (STR_IMP_FIRST + 18)
#define idsFolderReadFail               (STR_IMP_FIRST + 19)
#define idsFolderImportErrorFmt         (STR_IMP_FIRST + 20)
#define idsOut                          (STR_IMP_FIRST + 22)
#define idsTrash                        (STR_IMP_FIRST + 23)
#define idsEudora                       (STR_IMP_FIRST + 25)
#define idsNetscape                     (STR_IMP_FIRST + 26)
#define idsImportABTitle                (STR_IMP_FIRST + 27)
#define idsImportAB                     (STR_IMP_FIRST + 28)
#define idsImportingABFmt               (STR_IMP_FIRST + 29)
#define idsBrowseFolderText             (STR_IMP_FIRST + 30)
#define idsLocationUnknown              (STR_IMP_FIRST + 31)
#define idsLocationInvalid              (STR_IMP_FIRST + 32)
#define idsCancelWizard                 (STR_IMP_FIRST + 33)
#define idsMsgsOrAddrs                  (STR_IMP_FIRST + 34)
#define idsABImportError                (STR_IMP_FIRST + 35)
#define idsExchange                     (STR_IMP_FIRST + 36)
#define idsCommunicator                 (STR_IMP_FIRST + 37)
#define idsMapiInitError                (STR_IMP_FIRST + 38)
#define idsNoMapiProfiles               (STR_IMP_FIRST + 39)
#define idsMapiImportFailed             (STR_IMP_FIRST + 40)
#define idsSelectFolders                (STR_IMP_FIRST + 41)


// END import/export ids.
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN window ids.
//

#define idwAttachWell   1000

// END window ids
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN indices into the toolbar button bitmap
//
enum {
    itbNewMsg = 0,
    itbPrint,
    itbCut,
    itbCopy,
    itbPaste,
    itbUndo,
    itbDelete,
    itbFind,
    itbGotoInbox,
    itbDeliverNowUsingAll,
    itbReply,
    itbReplyAll,
    itbForward,
    itbSend,
    itbSaveAs,
    itbPickRecipients,
    itbCheckNames,
    itbAttach,
    itbNext,
    itbPrevious,
    itbNextUnreadArticle,
    itbNextUnreadThread,
    itbNextUnreadSubscr,
    itbMarkAsRead,
    itbDisconnect,
    itbNewPost,
    itbMarkDownload,
    itbReplyByPost,
    itbConnect,
    itbMarkTopicRead,
    itbMarkAllRead,
    itbMarkTopicDownload,
    itbNextTopic,
    itbInsertSig,
    itbPostNow,
    itbViewContacts,
    itbEncrypted,
    itbSigned,
    itbSetPriority,
    ctbBtns
    };


// FormatBar stuff
enum 
    {
    itbFormattingTag,
    itbFormattingBold,
    itbFormattingItalic,
    itbFormattingUnderline,
    itbFormattingColor,
    itbFormattingNumbers,
    itbFormattingBullets,
    itbFormattingDecreaseIndent,
    itbFormattingIncreaseIndent,
    itbFormattingLeft,
    itbFormattingCenter,
    itbFormattingRight,
    itbFormattingInsertHLine,
    itbFormattingInsertLink,
    itbFormattingInsertImage,
    ctbFormatting
    };

// Folder bitmap stuff
// Do NOT move the first two entries beyond 14.
enum 
    {
    iNullBitmap = 0,
    iDisconnected,
    iFolderClosed,
    iInbox,
    iOutbox,
    iSendMail,
    iWastebasket,
    iFolderDraft,
    iNewsGroup,
    iNewsServer,
    iPostFolder,
    iUnsubGroup,
    iUnsubServer,
    iSortAsc,
    iSortDesc,
    iMailServer,
    iMailServerGrayed,
    iMailRoot,
    iInboxFull,
    iOutboxFull,
    iWastebasketFull,
    iFolderFull,
    iMailTrust,
    iFolderOpen,
    iFolderUnsub,
    iNewsSavedItems,
    iMailNews,
    iLDAPServer,
    iNewsGroupSync
    };
    
// Coolbar bitmaps
enum
    {    
    iCBBack = 0,
    iCBNext,
    iCBNewArticle,
    iCBReplyPost,
    iCBReplyAll,
    iCBForward,
    iCBPrint,
    iCBNewsgroup,
    iCBNewMessage,
    iCBReplyMail,
    iCBDeliverNow,
    iCBNextUnreadArt,
    iCBNextUnreadThread,
    iCBNextUnreadGroup,
    iCBDelete,
    iCBGotoInbox,
    iCBGotoOutbox,
    iCBGotoPosted,
    iCBGotoSentItems,
    iCBAddressBook,
    iCBSaveAs,
    iCBFind,
    iCBNextMsg,
    iCBPrevMsg,
    iCBMarkRead,
    iCBMarkThreadRead,
    iCBMarkAllRead,
    iCBMarkAsUnread,
    iCBStop,
    iCBRefresh,
    iCBHelp,
    iCBMarkDownload,
    iCBMarkThreadDownload,
    iCBMarkAllDownload,
    iCBCancelPost,
    iCBMailMarkUnRead,
    iCBMailMarkRead,
    iCBMarkNewsgroups,
    iCBCombineAndDecode,
    iCBPostAndDownload,
    iCBGetNext300Headers,
    iCBUnscramble,
    iCBUnmarkDownload,
    iCBReplyPostAndMail,
    iCBMoveTo,
    iCBCopyTo,
    iCBConnect,
    iCBDisconnect,
    iCBUpOneLevel,
    iCBShowHideTree,
    iCBLanguage,
    iCBDownloadAccount,
    iCBDownloadNewsgroup,
    iCBPurgeDeletedMessages,
    iCBWorkOffline,
    iCBCoolbarMax,
    };

enum {    
    iCBEncryption,
    iCBSigning,
    iCBBadEnc,
    iCBBadSign,
    iCBPaperclip,
    iCBVCard,
    };

// Folder State bitmap stuff
enum 
    {
    iDownloadHeaders = 0,
    iDownloadNew,
    iDownloadAll,
    iStateMax
    };

enum 
    {
    iColorMenu = 0,
    iColorCombo,
    iColorMax
    };
    
//
// END indices into the toolbar button bitmap
//
/////////////////////////////////////////////////////////////////////////////


#endif // __RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\baprop.cpp ===
// baprop.cpp
// WAB & Messenger integration to OE
// Created 06/23/98 by YST
//
//////////////////////////////////////////////////////////////////////

#include "pch.hxx"
#include "msoert.h"
#include "hotlinks.h"
#include "shlwapi.h"
#include "badata.h"
#include "baprop.h"
#include "bllist.h"
#include "baui.h"
#include "shlwapip.h"
// #include "demand.h"
// #include "mailnews.h"
// #include "menuutil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define MAX_SUMMARY_ID  13
#define Msgr_Index      0

extern ULONG MsgrPropTags[];
extern ULONG PR_MSGR_DEF_ID;

// static WCHAR szDefault[CCHMAX_STRINGRES];  // TEXT(" (default)");
// static WCHAR szPending[CCHMAX_STRINGRES];  // TEXT(" (Pending...)");

const LPWSTR szDomainSeparator = L"@";
const LPWSTR szSMTP = L"SMTP";

#define PROP_ERROR(prop) (PROP_TYPE(prop.ulPropTag) == PT_ERROR)
static int nDefault = -1;
static HFONT hBold = NULL;
static HFONT hNormal = NULL;
static CMsgrList *s_pMsgrList = NULL;

static SizedSPropTagArray(1, pTagProp)=
{
    1,
    {
        PR_EMAIL_ADDRESS,
    }
};

///$$/////////////////////////////////////////////////////////////////////////
//
// AddCBEmailItem - Adds an email address to the personal tab list view
//
// lpszAddrType can be NULL in which case a default one of type SMTP will be used
//
//////////////////////////////////////////////////////////////////////////////
void AddCBEmailItem(HWND    hWndCB,
                    LPWSTR  lpwszEmailAddress,
                    BOOL    fDefault,
                    LPWSTR lpwszPendName)
{
    WCHAR szBuf[CCHMAX_STRINGRES];
    WCHAR szTmp[CCHMAX_STRINGRES];
    LV_ITEMW lvi = {0};
    UINT nSim = 0;
    int index = -1;

    StrCpyNW(szTmp, lpwszEmailAddress, ARRAYSIZE(szTmp));

    // TCHAR *pch = StrStr(CharUpper(szTmp), szHotMail);
    // if(pch != NULL)
    nSim = lstrlenW(szTmp); //(UINT) (pch - szTmp + 1);

    Assert(nSim < CCHMAX_STRINGRES);

    if(nSim > 0)
    {
        if(nSim > ((UINT) (CCHMAX_STRINGRES  - 2)))
        {
            nSim = CCHMAX_STRINGRES - 2;
            StrCpyNW(szBuf, lpwszEmailAddress, nSim);
            szBuf[nSim] = L'\0';
        }
        else
            StrCpyNW(szBuf, szTmp, ARRAYSIZE(szBuf));

        if(fDefault)
        {

            if(s_pMsgrList)
            {
#ifdef LATER
                if(s_pMsgrList->FindAndDeleteUser(lpwszEmailAddress, FALSE /*fDelete*/) == S_OK)
                    StrCatBuff(szBuf, szDefault, ARRAYSIZE(szBuf));
                else if(!lstrcmpiW(lpwszPendName, lpwszEmailAddress))
                    StrCatBuff(szBuf, szPending, ARRAYSIZE(szBuf));
#endif //LATER
            }

        }

        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lvi.iImage = IMAGE_EMPTY;
        lvi.pszText = szBuf;
        lvi.cchTextMax = 256; //nSim;
        lvi.iItem = ListView_GetItemCount(hWndCB);
        lvi.iSubItem = 0;
        lvi.lParam = fDefault;

        index = ListView_InsertItem(hWndCB, &lvi);
        if(fDefault)
            nDefault = index;
    }
    return;
}

#ifdef LATER
const static HELPMAP g_rgCtxWabExt[] =
{
    {IDC_MSGR_ID_EDIT,              IDH_WAB_ONLINE_ADDNEW},
    {IDC_MSGR_ADD,                  IDH_WAB_ONLINE_ADD},
    {IDC_MSGR_BUTTON_SETDEFAULT,    IDH_WAB_ONLINE_SETAS},
    {IDC_SEND_INSTANT_MESSAGE,      IDH_WAB_ONLINE_SENDIM},
    {IDC_USER_NAME,                 IDH_WAB_ONLINE_LIST},
    {idcStatic1,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                    IDH_NEWS_COMM_GROUPBOX},
    {0,                             0}
};
#endif

INT_PTR CALLBACK WabExtDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
#ifdef LATER
    LPWABEXTDISPLAY lpWED = (LPWABEXTDISPLAY) GetWindowLongPtr(hDlg, DWLP_USER);
    DWORD dwError = 0;
    HIMAGELIST himl = NULL;

    switch (msg)
    {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGE * pps = (PROPSHEETPAGE *) lParam;
            LPWABEXTDISPLAY * lppWED = (LPWABEXTDISPLAY *) pps->lParam;
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
                // Add two columns to the listview
            LVCOLUMN lvc;
            RECT rc;
            HWND ctlList = GetDlgItem(hDlg, IDC_USER_NAME);

            s_pMsgrList = OE_OpenMsgrList();

            // one column
            lvc.mask = LVCF_FMT | LVCF_WIDTH;
            lvc.fmt = LVCFMT_LEFT;
            lvc.iSubItem = 0;

            GetWindowRect(ctlList,&rc);
            lvc.cx = rc.right - rc.left - 20; //TBD

            ListView_InsertColumn(ctlList, 0, &lvc);

            if(lppWED)
            {
                SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM)*lppWED);
                lpWED = *lppWED;
            }
            InitFonts();
            AthLoadString(idsBADefault, szDefault, ARRAYSIZE(szDefault));
            AthLoadString(idsBADispStatus, szPending, ARRAYSIZE(szPending));
            // ListView_SetExtendedListViewStyle(ctlList, LVS_EX_FULLROWSELECT);

            himl = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbAddrBookHot), 18, 0,
                               RGB(255, 0, 255), IMAGE_BITMAP,
                               LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);

            ListView_SetImageList(ctlList, himl, LVSIL_SMALL);

            AddAccountsToList(hDlg, lpWED);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),FALSE);
        }
        break;

    case WM_CONTEXTMENU:
    case WM_HELP:
        return OnContextHelp(hDlg, msg, wParam, lParam, g_rgCtxWabExt);
        break;

    case WM_COMMAND:
        {
            switch(HIWORD(wParam))		// Notification code
            {
            case EN_CHANGE:
                {
                    if(LOWORD(wParam) == IDC_MSGR_ID_EDIT)
                    {
                        if(GetWindowTextLength(GetDlgItem(hDlg, IDC_MSGR_ID_EDIT)) > 0)
                        {
                            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),TRUE);
                            SendMessage(GetParent(hDlg), DM_SETDEFID, IDC_MSGR_ADD, 0);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),FALSE);
                            SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
                        }
                    }
                    break;
                }
            }

            switch(LOWORD(wParam))		// commands
            {
            case IDC_MSGR_BUTTON_SETDEFAULT:
                SetAsDefault(hDlg, lpWED);
                break;

            case IDC_MSGR_ADD:
                AddMsgrId(hDlg, lpWED);
                break;

            case IDC_SEND_INSTANT_MESSAGE:
                WabSendIMsg(hDlg, lpWED);
                break;
            default:
                break;
            }
        }
        break;

    case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {

            case PSN_APPLY:
                ::SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, TRUE);
                DeleteFonts();
                if(s_pMsgrList)
                    OE_CloseMsgrList(s_pMsgrList);

                break;

            case PSN_SETACTIVE:
                ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_USER_NAME));
                AddAccountsToList(hDlg, lpWED);
                break;

            case PSN_KILLACTIVE:
                AddMsgrId(hDlg, lpWED);
                SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
                return 1;
                break;

            case PSN_RESET:
                SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
                DeleteFonts();
                if(s_pMsgrList)
                    OE_CloseMsgrList(s_pMsgrList);
                break;

            case LVN_ITEMCHANGED:
                {
                int nItem = ListView_GetNextItem(::GetDlgItem(hDlg, IDC_USER_NAME), -1, LVIS_SELECTED);
                if((nItem != nDefault) && (nItem > -1))
                    EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),TRUE);
                else
                    EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);

                if(WabIsItemOnline(hDlg, nItem))
                    EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
                else
                    EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
                }
                break;


            case NM_CUSTOMDRAW:
                switch(wParam)
                {
                case IDC_USER_NAME:
                    {
                        NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
                        NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                        if(pnmcd->dwDrawStage==CDDS_PREPAINT)
                        {
                            SetLastError(0);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
                            dwError = GetLastError();
                            return TRUE;
                        }
                        else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
                        {
                            if(pnmcd->lItemlParam)
                            {
                                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, hBold);
                                SetLastError(0);
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                                dwError = GetLastError();
                                return TRUE;
                            }
                            else
                            {
                                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, hNormal);
                                SetLastError(0);
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                                dwError = GetLastError();
                                return TRUE;
                            }
                        }
                        SetLastError(0);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                        dwError = GetLastError();
                        return TRUE;
                    }
                    break;
                default:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                    break;
                }
                break;
            }
        }
        break;
    }
#endif
    return FALSE;	
}

void AddAccountsToList(HWND hDlg, LPWABEXTDISPLAY lpWED, LPWSTR lpwszPendName)
{
#ifdef LATER
    // LPWABEXTDISPLAY lpWED = (LPWABEXTDISPLAY) GetWindowLongPtr(hDlg, DWLP_USER);
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG i = 0;
    LPSPropValue lpPropEmail = NULL;
    LPSPropValue lpPropAddrType = NULL;
    LPSPropValue lpPropMVEmail = NULL;
    LPSPropValue lpPropMVAddrType = NULL;
    LPSPropValue lpPropDefaultIndex = NULL;
    LPSPropValue lpMsgrDevId = NULL;
    HWND ctlList = GetDlgItem(hDlg, IDC_USER_NAME);
    Assert(ctlList);

    Assert(PR_MSGR_DEF_ID);
    nDefault = -1;

    if(!lpWED)
    {
        Assert(FALSE);
        return;
    }

    if(!HR_FAILED(lpWED->lpPropObj->GetProps(NULL, 0,
        &ulcPropCount,
        &lpPropArray)))
    {
        if(ulcPropCount && lpPropArray)
        {
            for(i = 0; i < ulcPropCount; i++)
            {
                switch(lpPropArray[i].ulPropTag)
                {
                case PR_EMAIL_ADDRESS:
                    lpPropEmail = &(lpPropArray[i]);
                    break;
                case PR_ADDRTYPE:
                    lpPropAddrType = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_EMAIL_ADDRESSES:
                    lpPropMVEmail = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_ADDRTYPES:
                    lpPropMVAddrType = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
                    lpPropDefaultIndex = &(lpPropArray[i]);
                    break;
                default:
                    if(lpPropArray[i].ulPropTag == PR_MSGR_DEF_ID)
                        lpMsgrDevId = &(lpPropArray[i]);
                    break;
                }
            }
            if(!lpPropEmail && !lpPropMVEmail)
                goto Error;

            if(lpPropMVEmail)
            {
                // we have a multiple emails
                //Assume, if this is present, so is MVAddrType, and defaultindex
                for(i = 0; i < lpPropMVEmail->Value.MVszW.cValues; i++)
                {
                    AddCBEmailItem(ctlList,
                                    lpPropMVEmail->Value.MVszW.lppszW[i],
                                    (lpMsgrDevId ?
                                    ((!lstrcmpiW(lpPropMVEmail->Value.MVszW.lppszW[i], lpMsgrDevId->Value.lpszW)) ? TRUE : FALSE) : FALSE), lpwszPendName);
                }
            }
            else
            {
                // we dont have multi-valued props yet - lets use the
                // single valued ones and tag a change so that the record is
                // updated ...
                AddCBEmailItem(ctlList,
                                    lpPropEmail->Value.lpszW,
                                    (lpMsgrDevId ?
                                    ((!lstrcmpiW(lpPropEmail->Value.lpszW, lpMsgrDevId->Value.lpszW)) ? TRUE : FALSE) : FALSE), lwpszPendName);
            }
        }
    }

Error:
    if(nDefault == -1)
    {
        if(ListView_GetItemCount(ctlList) > 0)            // We have as min 1 item
        {
            // Select default item
            ListView_SetItemState(ctlList, 0,
                        LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),TRUE);
            // Enable "SendInstant Message only when contact is Online
            if(WabIsItemOnline(hDlg, 0))
                EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
            else
                EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);
        }
    }
    else
    {
        // Select default item
        ListView_SetItemState(ctlList, nDefault,
                        LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);
            // Enable "SendInstant Message only when contact is Online
        if(WabIsItemOnline(hDlg, nDefault))
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
        else
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
    }

    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
#endif
    return;

}

// Set selected email address as default for Messenger
void SetAsDefault(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
#ifdef LATER
    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    TCHAR szName[CCHMAX_STRINGRES];
    Assert(ctlList);

    int iItem = ListView_GetNextItem(ctlList, -1, LVIS_SELECTED);
    if(iItem == -1)
        return;

    ListView_GetItemText(ctlList, iItem, 0,szName, CCHMAX_STRINGRES - 1);

    if(StrStr(CharUpper(szName), CharUpper(szDefault))) // already default
        return;

    SetDefaultID(szName, hDlg, lpWED);
#endif
}

// Add Messanger ID  to list
#define NOT_FOUND ((ULONG) -1)

void AddMsgrId(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
#ifdef LATER
    HWND hwndEdit = ::GetDlgItem(hDlg, IDC_MSGR_ID_EDIT);
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0;
    ULONG i = 0;

    ULONG nMVEmailAddress = NOT_FOUND, nMVAddrTypes = NOT_FOUND, nEmailAddress = NOT_FOUND;
    ULONG nAddrType = NOT_FOUND, nDefaultIndex = NOT_FOUND;
    TCHAR szName[CCHMAX_STRINGRES];
    HRESULT hr = S_OK;

    if(!::GetWindowText(hwndEdit, szName, CCHMAX_STRINGRES - 1))
        return;

    TCHAR *pch = NULL;
    if(!AsciiTrimSpaces(szName))
    {
        AthMessageBoxW(hDlg, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsBAErrExtChars),
               NULL, MB_OK | MB_ICONSTOP);
        ::SetWindowText(hwndEdit, "");
        ::SetFocus(hwndEdit);
        return;
    }

    int nLen = lstrlen(szName);
    if(nLen <= 0)
        goto exi;

    nLen = lstrlen(szSMTP);
    if(nLen <= 0)
        goto exi;

    // Create a return prop array to pass back to the WAB
    if(HR_FAILED(lpWED->lpPropObj->GetProps(NULL, 0,
        &ulcPropCount,
        &lpPropArray)))
        return;

    if(ulcPropCount && lpPropArray)
    {
        for(i = 0; i < ulcPropCount; i++)
        {
            switch(lpPropArray[i].ulPropTag)
            {
            case PR_EMAIL_ADDRESS:
                nEmailAddress = i;
                break;
            case PR_ADDRTYPE:
                nAddrType = i;
                break;
            case PR_CONTACT_EMAIL_ADDRESSES:
                nMVEmailAddress = i;
                break;
            case PR_CONTACT_ADDRTYPES:
                nMVAddrTypes = i;
                break;
            case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
                nDefaultIndex = i;
                break;
            }
        }

        // if no e-mail address, just add the given prop as e-mail address and in mv e-mail addresses
        if(nEmailAddress == NOT_FOUND)
        {
            SPropValue spv[5];

            spv[0].ulPropTag = PR_EMAIL_ADDRESS;
            spv[0].Value.lpszW = szName;

            spv[1].ulPropTag = PR_ADDRTYPE;
            spv[1].Value.lpszW = szSMTP;

            spv[2].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
            spv[2].Value.MVszW.cValues = 1;
            spv[2].Value.MVszW.lppszW = (WCHAR **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));

            if(spv[2].Value.MVszW.lppszW)
                spv[2].Value.MVszW.lppszW[0] = szName;

            spv[3].ulPropTag = PR_CONTACT_ADDRTYPES;
            spv[3].Value.MVszW.cValues = 1;
            spv[3].Value.MVszW.lppszW = (WCHAR **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));

            if(spv[3].Value.MVszW.lppszW)
                spv[3].Value.MVszW.lppszW[0] = szSMTP;

            spv[4].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            spv[4].Value.l = 0;

            hr = lpWED->lpPropObj->SetProps(5, (LPSPropValue)&spv, NULL);

            if(spv[2].Value.MVszW.lppszW)
                LocalFree(spv[2].Value.MVszW.lppszW);
            if(spv[3].Value.MVszW.lppszW)
                LocalFree(spv[3].Value.MVszW.lppszW);

        }
        else if(nMVEmailAddress == NOT_FOUND)
        {
            // we have an e-mail address but no contact-email-addresses
            // so we will need to create the contact e-mail addresses
            SPropValue spv[3];

            spv[0].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
            spv[0].Value.MVszW.cValues = 2;
            spv[0].Value.MVszW.lppszW = (WCHAR **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);

            if(spv[0].Value.MVszW.lppszW)
            {
                spv[0].Value.MVszW.lppszW[0] = lpPropArray[nEmailAddress].Value.lpszW;
                spv[0].Value.MVszW.lppszW[1] = szName;
            }

            spv[1].ulPropTag = PR_CONTACT_ADDRTYPES;
            spv[1].Value.MVszW.cValues = 2;
            spv[1].Value.MVszW.lppszW = (WCHAR **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);

            if(spv[1].Value.MVszW.lppszW)
            {
                spv[1].Value.MVszW.lppszW[0] = (nAddrType == NOT_FOUND) ? (LPTSTR)szSMTP : lpPropArray[nAddrType].Value.lpszW;
                spv[1].Value.MVszW.lppszW[1] = szSMTP;
            }

            spv[2].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            spv[2].Value.l = 0;

            hr = lpWED->lpPropObj->SetProps(3, (LPSPropValue)&spv, NULL);

            if(spv[0].Value.MVszW.lppszW)
                LocalFree(spv[0].Value.MVszW.lppszW);

            if(spv[1].Value.MVszW.lppszW)
                LocalFree(spv[1].Value.MVszW.lppszW);
        }
        else
        {
            // tag on the new props to the end of the existing contact_address_types
            if(HR_FAILED(hr = AddPropToMVPString(lpWED, lpPropArray,ulcPropCount, nMVEmailAddress, szName)))
                goto exi;

            if(HR_FAILED(hr = AddPropToMVPString(lpWED, lpPropArray, ulcPropCount, nMVAddrTypes, szSMTP)))
                goto exi;

            hr = lpWED->lpPropObj->SetProps(ulcPropCount, lpPropArray, NULL);
        }

        // Set this new data on the object
        //
        if(SUCCEEDED(hr))
        {
            lpWED->fDataChanged = TRUE;
            if(nDefault == -1)
                SetDefaultID(szName, hDlg, lpWED);
            else
            {
                // just refresh list, which will add buddy.6
                ListView_DeleteAllItems(::GetDlgItem(hDlg, IDC_USER_NAME));
                AddAccountsToList(hDlg, lpWED);
            }
            ::SetWindowText(hwndEdit, "");
        }
    }
exi:
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
#endif
}

    //Set default ID in WAB
void SetDefaultID(TCHAR *szName, HWND hDlg, LPWABEXTDISPLAY lpWED)
{
#ifdef LATER
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc = 0;

    if(s_pMsgrList)
    {
        s_pMsgrList->AddUser(szName); // Always ignore result
    }
    else
        return;

    // Create a return prop array to pass back to the WAB
    int nLen = lstrlen(szName);

    sc = lpWED->lpWABObject->AllocateBuffer(sizeof(SPropValue),
        (LPVOID *)&lpPropArray);
    if (sc!=S_OK)
        goto out;

    if(nLen)
    {
        lpPropArray[Msgr_Index].ulPropTag = MsgrPropTags[Msgr_Index];
        sc = lpWED->lpWABObject->AllocateMore(nLen+1, lpPropArray,
            (LPVOID *)&(lpPropArray[Msgr_Index].Value.lpszW));

        if (sc!=S_OK)
            goto out;

        StrCpyN(lpPropArray[Msgr_Index].Value.lpszW, szName, nLen +1);
    }
    // Set this new data on the object
    //
    if(HR_FAILED(lpWED->lpPropObj->SetProps( 1, lpPropArray, NULL)))
        goto out;

    lpWED->fDataChanged = TRUE;
    ListView_DeleteAllItems(::GetDlgItem(hDlg, IDC_USER_NAME));
    AddAccountsToList(hDlg, lpWED, szName);

out:
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
#endif
}


//$$//////////////////////////////////////////////////////////////////////////////
//
//  TrimSpaces - strips a string of leading and trailing blanks
//
//  szBuf - pointer to buffer containing the string we want to strip spaces off.
//  Also, check that characters are ASCII
//
////////////////////////////////////////////////////////////////////////////////
BOOL AsciiTrimSpaces(TCHAR * szBuf)
{
    register LPTSTR lpTemp = szBuf;
    DWORD cch = lstrlen(szBuf)+1;

    if(!szBuf || !lstrlen(szBuf))
        return FALSE;

    // Trim leading spaces
    while (IEIsSpace(lpTemp)) {
        lpTemp = CharNext(lpTemp);
    }

    if (lpTemp != szBuf) {
        // Leading spaces to trim
        StrCpyN(szBuf, lpTemp, cch);
        lpTemp = szBuf;
    }

    if (*lpTemp == '\0') {
        // empty string
        return(TRUE);
    }

    // Move to the end
    lpTemp += lstrlen(lpTemp);
    lpTemp--;

    // Walk backwards, triming spaces
    while (IEIsSpace(lpTemp) && lpTemp > szBuf) {
        *lpTemp = '\0';
        lpTemp = CharPrev(szBuf, lpTemp);
    }

   lpTemp = szBuf;

    while (*lpTemp)
    {
        // Internet addresses only allow pure ASCII.  No high bits!
        if (*lpTemp & 0x80)
           return(FALSE);
        lpTemp++;
    }

    return(TRUE);
}

/***************************************************************************

    Name      : AddPropToMVPString

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                cProps = number of props in lpaProps
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpszNew -> new data string

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array lpszW to the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPString(
  LPWABEXTDISPLAY lpWED,
  LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPWSTR lpszNew) {

#ifdef UNICODE
    SWStringArray UNALIGNED * lprgszOld = NULL; // old SString array
#else
    SWStringArray UNALIGNED * lprgszOld = NULL; // old SString array
#endif
    LPWSTR  *lppszNew = NULL;           // new prop array
    LPWSTR  *lppszOld = NULL;           // old prop array
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i = 0;
    ULONG cchNew;

    if (lpszNew) {
        cchNew = lstrlenW(lpszNew) + 1;
    } else {
        cchNew = 0;
    }

    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index])) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_TSTRING, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgszOld = &(lpaProps[index].Value.MVszW);
        lppszOld = lprgszOld->lppszW;

        cExisting = lprgszOld->cValues;
        cbMVP = cExisting * sizeof(LPTSTR);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(LPWSTR);    // room in the MVP for another string pointer


    // Allocate room for new MVP array
    if (sc = lpWED->lpWABObject->AllocateMore(cbMVP, lpaProps, (LPVOID *)&lppszNew)) {
        DebugTrace("AddPropToMVPString allocation (%u) failed %x\n", cbMVP, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lppszNew[i] = lppszOld[i];
    }

    // Add the new property value
    // Allocate room for it
    if (cchNew) {
        if (sc = lpWED->lpWABObject->AllocateMore(cchNew * sizeof(WCHAR), lpaProps, (LPVOID *)&(lppszNew[i]))) {
            DebugTrace("AddPropToMVPBin allocation (%u) failed %x\n", cchNew * sizeof(WCHAR), sc);
            hResult = ResultFromScode(sc);
            return(hResult);
        }
        StrCpyNW(lppszNew[i], lpszNew, cchNew);

        lpaProps[index].Value.MVszW.lppszW= lppszNew;
        lpaProps[index].Value.MVszW.cValues = cExisting + 1;

    } else {
        lppszNew[i] = NULL;
    }

    return(hResult);
}

// this function check if selected item is online
BOOL WabIsItemOnline(HWND hDlg, int nItem)
{
#ifdef LATER
    TCHAR szName[CCHMAX_STRINGRES];
    TCHAR *pch = NULL;

    if(nItem < 0)
        return(FALSE);

    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    Assert(ctlList);

    ListView_GetItemText(ctlList, nItem, 0,szName, CCHMAX_STRINGRES - 1);

    // Remove "(default)"
    pch = StrStr(szName, szDefault);
    if(pch != NULL)
        szName[pch - szName] = '\0';

    if(s_pMsgrList)
    {
        return(s_pMsgrList->IsContactOnline(szName, s_pMsgrList->GetFirstMsgrItem()));
    }
#endif
    return(FALSE);
}

// Send instant message to selected item
void WabSendIMsg(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
#ifdef LATER
    TCHAR szName[CCHMAX_STRINGRES];
    TCHAR *pch = NULL;

    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    Assert(ctlList);

    int iItem = ListView_GetNextItem(ctlList, -1, LVIS_SELECTED);
    if(iItem == -1)
        return;

    ListView_GetItemText(ctlList, iItem, 0,szName, CCHMAX_STRINGRES - 1);

    // Remove "(default)"

    pch = StrStr(szName, szDefault);
    if(pch != NULL)
        szName[pch - szName] = '\0';

    if(s_pMsgrList)
    {
        s_pMsgrList->SendInstMessage(szName);
    }
#endif
}

BOOL InitFonts(void)
{
    LOGFONT lf;

    // Create the font
    if(SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
    {
        if(!hNormal)
            hNormal = CreateFontIndirect(&lf);
        lf.lfWeight = (lf.lfWeight < 700) ? 700 : 1000;
        if(!hBold)
            hBold = CreateFontIndirect(&lf);

    }
    return(TRUE);
}

void DeleteFonts(void)
{
    if(hNormal)
    {
        DeleteObject(hNormal);
        hNormal = NULL;
    }
    if(hBold)
    {
        DeleteObject(hBold);
        hBold = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\blframe.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Author: Scott Roberts, Microsoft Developer Support - Internet Client SDK  
//
// Portions of this code were taken from the bandobj sample that comes
// with the Internet Client SDK for Internet Explorer 4.0x
//
// BLFrame.cpp : Contains DLLMain and standard COM object functions.
/////////////////////////////////////////////////////////////////////////////
#include "pch.hxx"

#include <shlwapi.h>
#include <shlwapip.h>

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwinx.cpp>

#include <ole2.h>
#include <comcat.h>
#include <olectl.h>
#include "ClsFact.h"
#include "resource.h"
#include "msoert.h"
#include "shared.h"
// #include "demand.h"

static const char c_szShlwapiDll[] = "shlwapi.dll";
static const char c_szDllGetVersion[] = "DllGetVersion";

// This part is only done once
// If you need to use the GUID in another file, just include Guid.h
//#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <shlguid.h>
#include "Guid.h"
//#pragma data_seg()

// HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName, BOOL fNT);
const TCHAR c_szBlCtlResDll[] =           "iecontlc.dll";

extern "C" BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID);
BOOL RegisterServer(CLSID, LPTSTR);
BOOL RegisterComCat(CLSID, CATID);
BOOL UnRegisterServer(CLSID);
BOOL UnRegisterComCat(CLSID, CATID);

HINSTANCE  g_hLocRes;
HINSTANCE  g_OrgInst = NULL;
LONG       g_cDllRefCount;
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_IEMsgAb, CIEMsgAb)
END_OBJECT_MAP()

typedef struct
{
    HKEY   hRootKey;
    LPTSTR szSubKey;  // TCHAR szSubKey[MAX_PATH];
    LPTSTR lpszValueName;
    LPTSTR szData;    // TCHAR szData[MAX_PATH];
    
} DOREGSTRUCT, *LPDOREGSTRUCT;

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);

HINSTANCE IELoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName, BOOL fNT)
{
    char szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, MAKEINTRESOURCE(377));
                    if (pfn != NULL)
                        hInst = pfn(szDllName, hInstCaller, (ML_CROSSCODEPAGE));
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if ((NULL == hInst) && (GetModuleFileName(hInstCaller, szPath, ARRAYSIZE(szPath))))
    {
        PathRemoveFileSpec(szPath);
        iEnd = lstrlen(szPath);
        szPath[iEnd++] = '\\';
        StrCpyN(&szPath[iEnd], szDllName, ARRAYSIZE(szPath)-iEnd);
        hInst = LoadLibrary(szPath);
    }

    AssertSz(hInst, "Failed to LoadLibrary Lang Dll");

    return(hInst);
}
// CComModule _Module;

IMalloc                *g_pMalloc=NULL;

extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        CoGetMalloc(1, &g_pMalloc);
        // Get Resources from Lang DLL
        g_OrgInst = hInstance;
        g_hLocRes = IELoadLangDll(hInstance, c_szBlCtlResDll, TRUE);
        if(g_hLocRes == NULL)
        {
            _ASSERT(FALSE);
            return FALSE;
        }
        _Module.Init(ObjectMap, hInstance);
        // InitDemandLoadedLibs();
        DisableThreadLibraryCalls(hInstance);
        break;
        
    case DLL_PROCESS_DETACH:
        // FreeDemandLoadedLibs();
        _Module.Term();
        SafeRelease(g_pMalloc);
        break;
    }
    
    return TRUE;
}                                 

STDAPI DllCanUnloadNow(void)
{
    return (g_cDllRefCount ? S_FALSE : S_OK);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    *ppv = NULL;
    HRESULT hr = E_FAIL;
    
    // If we don't support this classid, return the proper error code
    if (!IsEqualCLSID(rclsid, CLSID_BLHost) && !IsEqualCLSID(rclsid, CLSID_IEMsgAb) )
        return CLASS_E_CLASSNOTAVAILABLE;
    
    if(IsEqualCLSID(rclsid, CLSID_BLHost))
    {
        // Create a CClassFactory object and check it for validity
        CClassFactory* pClassFactory = new CClassFactory(rclsid);
        if (NULL == pClassFactory)
            return E_OUTOFMEMORY;
    
        // QI for the requested interface
        hr = pClassFactory->QueryInterface(riid, ppv);
    
        // Call Release to decement the ref count - creating the object set it to one 
        // and QueryInterface incremented it - since its being used externally (not by 
        // us), we only want the ref count to be 1
        pClassFactory->Release();
    }
    else if(IsEqualCLSID(rclsid, CLSID_IEMsgAb))
        return _Module.GetClassObject(rclsid, riid, ppv);

    return hr;
}

STDAPI DllRegisterServer(void)
{
    TCHAR szTitle[256];
    // Register the explorer bar object.
    if(!ANSI_AthLoadString(idsTitle, szTitle, ARRAYSIZE(szTitle)))
    {
        _ASSERT(FALSE);
        szTitle[0] = '\0';
    }

    if (!RegisterServer(CLSID_BLHost, szTitle))
        return SELFREG_E_CLASS;
    
    // Register the Component Categories for the explorer bar object.
    RegisterComCat(CLSID_BLHost, CATID_InfoBand); // ignore error in this case
    
    // registers IEMsgAb object, typelib and all interfaces in typelib
    _Module.RegisterServer(TRUE);
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    // Register the Component Categories for the explorer bar object.
    UnRegisterComCat(CLSID_BLHost, CATID_InfoBand); // ignore error in this case
    
    // Register the explorer bar object.
    if (!UnRegisterServer(CLSID_BLHost))
        return SELFREG_E_CLASS;
    
    _Module.UnregisterServer();
    return S_OK;
}

BOOL RegisterServer(CLSID clsid, LPTSTR lpszTitle)
{
    int     i;
    HKEY    hKey;
    LRESULT lResult;
    DWORD   dwDisp;
    TCHAR   szSubKey[MAX_PATH];
    TCHAR   szCLSID[MAX_PATH];
    TCHAR   szBlFrameCLSID[MAX_PATH];
    TCHAR   szModule[MAX_PATH];
    LPWSTR  pwsz;
    
    // Get the CLSID in string form
    StringFromIID(clsid, &pwsz);
    
    if (pwsz)
    {
#ifdef UNICODE
        StrCpyN(szBlFrameCLSID, pwsz, ARRAYSIZE(szBlFrameCLSID));
#else
        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szBlFrameCLSID,
            ARRAYSIZE(szBlFrameCLSID), NULL, NULL);
#endif
        
        // Free the string
        LPMALLOC pMalloc;
        
        CoGetMalloc(1, &pMalloc);
        pMalloc->Free(pwsz);
        
        pMalloc->Release();
    }
    
    // Get this app's path and file name
    GetModuleFileName(g_OrgInst, szModule, ARRAYSIZE(szModule));
    
    DOREGSTRUCT ClsidEntries[] =
    {
        HKEY_CLASSES_ROOT, TEXT("CLSID\\%s"),                 
            NULL, lpszTitle,
            HKEY_CLASSES_ROOT, TEXT("CLSID\\%s\\InprocServer32"), 
            NULL, szModule,
            HKEY_CLASSES_ROOT, TEXT("CLSID\\%s\\InprocServer32"),
            TEXT("ThreadingModel"), TEXT("Apartment"),
            NULL, NULL, NULL, NULL
    };
    
    // Register the CLSID entries
    for (i = 0; ClsidEntries[i].hRootKey; i++)
    {
        // Create the sub key string - for this case, insert
        // the file extension
        //
        wnsprintf(szSubKey, ARRAYSIZE(szSubKey), ClsidEntries[i].szSubKey, szBlFrameCLSID);
        
        lResult = RegCreateKeyEx(ClsidEntries[i].hRootKey, szSubKey, 
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_WRITE, NULL, &hKey, &dwDisp);
        
        if (ERROR_SUCCESS == lResult)
        {
            TCHAR szData[MAX_PATH];
            
            // If necessary, create the value string
            wnsprintf(szData, ARRAYSIZE(szData), ClsidEntries[i].szData, szModule);
            
            lResult = RegSetValueEx(hKey, ClsidEntries[i].lpszValueName, 
                0, REG_SZ, (LPBYTE)szData,
                lstrlen(szData) + 1);
            RegCloseKey(hKey);
            
            if (ERROR_SUCCESS != lResult)
                return FALSE;
        }
        else
        {
            return FALSE;
        }
    }
    
    // Create the Registry key entry and values for the
    // toolbar button.
    //
    StringFromIID(CLSID_BlFrameButton, &pwsz);
    
    if (!pwsz)
        return TRUE;
    
#ifdef UNICODE
    StrCpyN(szCLSID, pwsz, ARRAYSIZE(szCLSID));
#else
    WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szCLSID,
        ARRAYSIZE(szCLSID), NULL, NULL);
#endif
    
    // Free the string
    LPMALLOC pMalloc;
    
    CoGetMalloc(1, &pMalloc);
    pMalloc->Free(pwsz);
    pMalloc->Release();
    
    wnsprintf(szSubKey, ARRAYSIZE(szSubKey), "Software\\Microsoft\\Internet Explorer\\Extensions\\%s",
        szCLSID);
    
    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_WRITE, NULL, &hKey, &dwDisp);
    
    if (ERROR_SUCCESS == lResult)
    {
        TCHAR szData[MAX_PATH];
        
        // Create the value strings
        //
        // Register the explorer bar object.


        OSVERSIONINFO OSInfo;
        BOOL fWhistler = FALSE;
        OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        GetVersionEx(&OSInfo);
        if((OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (OSInfo.dwMajorVersion >= 5) && 
                    (OSInfo.dwMinorVersion >= 1))
            fWhistler = TRUE;

#ifdef NEED // Bug 28254
        StrCpyN(szData, "Yes", ARRAYSIZE(szData));
        RegSetValueEx(hKey, TEXT("Default Visible"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
#endif         
        TCHAR szPath[MAX_PATH];
        HMODULE hModule;
        
        hModule = GetModuleHandle(TEXT("iecont.dll"));
        GetModuleFileName(hModule, szPath, MAX_PATH);
        
        wnsprintf(szData, ARRAYSIZE(szData), "%s,%d", szPath, fWhistler ? IDI_WHISTICON : IDI_HOTICON);
        RegSetValueEx(hKey, TEXT("HotIcon"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
        wnsprintf(szData, ARRAYSIZE(szData), "%s,%d", szPath, fWhistler ? IDI_WHISTICON : IDI_ICON);
        RegSetValueEx(hKey, TEXT("Icon"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
        StrCpyN(szData, "{E0DD6CAB-2D10-11D2-8F1A-0000F87ABD16}", ARRAYSIZE(szData));
        RegSetValueEx(hKey, TEXT("CLSID"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
        wnsprintf(szData, ARRAYSIZE(szData), "%s", szBlFrameCLSID);
        RegSetValueEx(hKey, TEXT("BandCLSID"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
//        SHGetWebFolderFilePath(TEXT("iecontlc.dll"), szPath, ARRAYSIZE(szPath));
        wnsprintf(szData, ARRAYSIZE(szData), "@iecontlc.dll,-%d",idsButtontext);
        RegSetValueEx(hKey, TEXT("ButtonText"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
        wnsprintf(szData, ARRAYSIZE(szData), "@iecontlc.dll,-%d",idsTitle);
        RegSetValueEx(hKey, TEXT("MenuText"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
        RegCloseKey(hKey);
    }
    
    return TRUE;
}

BOOL RegisterComCat(CLSID clsid, CATID CatID)
{
    ICatRegister* pcr;
    HRESULT hr = S_OK ;
    
    CoInitialize(NULL);
    
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
        NULL,
        CLSCTX_INPROC_SERVER, 
        IID_ICatRegister,
        (LPVOID*)&pcr);
    
    if (SUCCEEDED(hr))
    {
        hr = pcr->RegisterClassImplCategories(clsid, 1, &CatID);
        pcr->Release();
    }
    
    CoUninitialize();
    
    return SUCCEEDED(hr);
}

BOOL UnRegisterServer(CLSID clsid)
{
    TCHAR   szSubKey[MAX_PATH];
    TCHAR   szCLSID[MAX_PATH];
    LPWSTR  pwsz;
    
    // Get the CLSID in string form
    StringFromIID(clsid, &pwsz);
    
    if (pwsz)
    {
#ifdef UNICODE
        StrCpyN(szCLSID, pwsz, ARRAYSIZE(szCLSID));
#else
        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szCLSID,
            ARRAYSIZE(szCLSID), NULL, NULL);
#endif
        
        // Free the string
        LPMALLOC pMalloc;
        
        CoGetMalloc(1, &pMalloc);
        
        pMalloc->Free(pwsz);
        pMalloc->Release();
    }
    
    DOREGSTRUCT ClsidEntries[] =
    {
        HKEY_CLASSES_ROOT, TEXT("CLSID\\%s\\InprocServer32"),
            NULL, NULL,
            //
            // Remove the "Implemented Categories" key, just in case 
            // UnRegisterClassImplCategories does not remove it
            // 
            HKEY_CLASSES_ROOT, TEXT("CLSID\\%s\\Implemented Categories"),
            NULL, NULL,
            HKEY_CLASSES_ROOT, TEXT("CLSID\\%s"), NULL, NULL,
            NULL, NULL, NULL, NULL
    };
    
    // Delete the CLSID entries
    for (int i = 0; ClsidEntries[i].hRootKey; i++)
    {
        wnsprintf(szSubKey, ARRAYSIZE(szSubKey), ClsidEntries[i].szSubKey, szCLSID);
        RegDeleteKey(ClsidEntries[i].hRootKey, szSubKey);
    }
    
    // Delete the button information
    //
    StringFromIID(CLSID_BlFrameButton, &pwsz);
    
    if (!pwsz)
        return TRUE;
    
#ifdef UNICODE
    StrCpyN(szCLSID, pwsz, ARRAYSIZE(szCLSID));
#else
    WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szCLSID,
        ARRAYSIZE(szCLSID), NULL, NULL);
#endif
    
    // Free the string
    LPMALLOC pMalloc;
    
    CoGetMalloc(1, &pMalloc);
    pMalloc->Free(pwsz);
    pMalloc->Release();
    
    wnsprintf(szSubKey, ARRAYSIZE(szSubKey), "Software\\Microsoft\\Internet Explorer\\Extensions\\%s", szCLSID);
    RegDeleteKey(HKEY_LOCAL_MACHINE, szSubKey);
    
    return TRUE;
}

BOOL UnRegisterComCat(CLSID clsid, CATID CatID)
{
    ICatRegister* pcr;
    HRESULT hr = S_OK ;
    
    CoInitialize(NULL);
    
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
        NULL,
        CLSCTX_INPROC_SERVER, 
        IID_ICatRegister,
        (LPVOID*)&pcr);
    
    if (SUCCEEDED(hr))
    {
        hr = pcr->UnRegisterClassImplCategories(clsid, 1, &CatID);
        pcr->Release();
    }
    
    CoUninitialize();
    
    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\blframe.h ===
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the BlFrame_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// BlFrame_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef BlFrame_EXPORTS
#define BlFrame_API __declspec(dllexport)
#else
#define BlFrame_API __declspec(dllimport)
#endif

// This class is exported from the BlFrame.dll
class CBlFrame
{
public:
	CBlFrame();
	// TODO: add your methods here.
};

BlFrame_API int fnBlFrame(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\blhost.h ===
/////////////////////////////////////////////////////////////////////////////
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Author: Scott Roberts, Microsoft Developer Support - Internet Client SDK  
//
// Portions of this code were taken from the bandobj sample that comes
// with the Internet Client SDK for Internet Explorer 4.0x
//
//
// BLHost.h - CBLHost declaration
/////////////////////////////////////////////////////////////////////////////

#ifndef __BLHost_h__
#define __BLHost_h__

#include <windows.h>
#include <shlobj.h>

// #include <stack>
// #include <string>
#include "baui.h"
// using namespace std;

#include "Globals.h"

#define EB_CLASS_NAME (TEXT("BLHostClass"))

#define MIN_SIZE_X   10
#define MIN_SIZE_Y   10

#define IDM_REFRESH       0
#define IDM_OPENINWINDOW  1
#define IDM_SEARCHMENU    WM_USER + 200
#define IDM_ONTHEINTERNET WM_USER + 202
#define IDM_FIRSTURL      WM_USER + 250
#define IDM_LASTURL       WM_USER + 260  // We allow 10 Urls in the menu.
// In Internet Explorer 5.0, there
// are only 5 stored in the registry.

class CBLHost : public IDeskBand, 
public IInputObject, 
public IObjectWithSite,
public IPersistStream,
public IContextMenu,
public IOleClientSite,
public IOleInPlaceSite,
public IOleControlSite,
public IOleCommandTarget,
public IDispatch
{
public:
    CBLHost();
    ~CBLHost();
    
protected:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID iid, void** ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(DWORD, Release)();
    
    // IOleWindow methods
    STDMETHOD(GetWindow)(HWND* phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);
    
    // IDockingWindow methods
    STDMETHOD(ShowDW)(BOOL fShow);
    STDMETHOD(CloseDW)(DWORD dwReserved);
    STDMETHOD(ResizeBorderDW)(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);
    
    // IDeskBand methods
    STDMETHOD(GetBandInfo)(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi);
    
    // IInputObject methods
    STDMETHOD(UIActivateIO)(BOOL fActivate, LPMSG lpMsg);
    STDMETHOD(HasFocusIO)(void);
    STDMETHOD(TranslateAcceleratorIO)(LPMSG lpMsg);
    
    // IObjectWithSite methods
    STDMETHOD(SetSite)(IUnknown* pUnkSite);
    STDMETHOD(GetSite)(REFIID riid, void** ppvSite);
    
    // IPersistStream methods
    STDMETHOD(GetClassID)(CLSID* pClassID);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(LPSTREAM pStm);
    STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSize);
    
    // IContextMenu methods
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT* pwReserved, LPSTR pszName, UINT cchMax);
    
    // IOleClientSite methods 
    STDMETHOD(SaveObject)();
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppmk);
    STDMETHOD(GetContainer)(LPOLECONTAINER* ppContainer);
    STDMETHOD(ShowObject)();
    STDMETHOD(OnShowWindow)(BOOL fShow);
    STDMETHOD(RequestNewObjectLayout)();
    
    // IOleInPlaceSite Methods
    STDMETHOD(CanInPlaceActivate)();
    STDMETHOD(OnInPlaceActivate)();
    STDMETHOD(OnUIActivate)();
    STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc,
        LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHOD(Scroll)(SIZE scrollExtent);
    STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
    STDMETHOD(OnInPlaceDeactivate)();
    STDMETHOD(DiscardUndoState)();
    STDMETHOD(DeactivateAndUndo)();
    STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect); 
    
    // IOleControlSite Methods
    STDMETHOD(OnControlInfoChanged)(void);
    STDMETHOD(LockInPlaceActive)(BOOL fLock);
    STDMETHOD(GetExtendedControl)(LPDISPATCH* ppDisp);
    STDMETHOD(TransformCoords)(POINTL* pPtlHimetric, POINTF* pPtfContainer, DWORD dwFlags);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, DWORD grfModifiers);
    STDMETHOD(OnFocus)(BOOL fGotFocus);
    STDMETHOD(ShowPropertyFrame)(void);

//IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID    *pguidCmdGroup, 
                                          ULONG         cCmds, 
                                          OLECMD        *prgCmds, 
                                          OLECMDTEXT    *pCmdText);

    HRESULT STDMETHODCALLTYPE Exec(const GUID   *pguidCmdGroup, 
                                    DWORD       nCmdID, 
                                    DWORD       nCmdExecOpt, 
                                    VARIANTARG  *pvaIn, 
                                    VARIANTARG  *pvaOut);
    // IDispatch Methods
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo);
    STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid,DISPID* rgDispId);
    STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pDispParams,
        VARIANT* pVarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr);
    
protected:
    LONG _cRef;
    
private:
    HWND                _hwndParent;     // HWND of the Parent
    HWND                m_hWnd;          // My HWND
    HWND                m_hwndContact;
    DWORD               _dwViewMode;
    DWORD               _dwBandID;
    DWORD               _dwWBCookie;
    HBRUSH              m_hbr3DFace;
    HBRUSH              m_hbrStaticText;
    HBRUSH              m_hbr3DHighFace;
    HFONT               m_hFont;
    HFONT               m_hBoldFont;
    HFONT               m_hUnderlineFont;
    UINT                m_cyTitleBar;
    UINT                m_TextHeight;
    BOOL                m_fHighlightIndicator;
    BOOL                m_fHighlightPressed;
    BOOL                m_fButtonPressed;
    BOOL                m_fButtonHighLight;
    BOOL                m_fViewMenuPressed;
    BOOL                m_fShowLoginPart;
    BOOL                m_fStateChange;
    RECT                m_rcTitleButton;
    RECT                m_rcTextButton;
    TCHAR               m_szTitleMenu[RESSTRMAX];
    TCHAR               m_szButtonText[RESSTRMAX];
    WCHAR               m_wszClickText[RESSTRMAX];
    WCHAR               m_wszAttemptText[RESSTRMAX];
    WCHAR               m_wszWaitText[RESSTRMAX];
    HWND                m_hWndLogin;
    HWND                m_hWndClick;
    COLORREF            m_clrLink;
    COLORREF            m_clrBack;
    BOOL                m_fStrsAdded;
    LONG_PTR            m_lStrOffset;
   
    // Interface pointers
    IUnknown*           m_pUnkSite; 
    IInputObjectSite*   _pSite;
    IIEMsgAb*           m_pIMsgrAB;
 
private:
    // Message Handlers
    LRESULT OnKillFocus(void);
    LRESULT OnSetFocus(void);
    LRESULT OnPaint(void);
    LRESULT OnSize(void);
    LRESULT OnDrawItem(WPARAM wParam, LPARAM lParam);
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnMouseMove(int x, int y, UINT keyFlags);
    void OnTimer(UINT wParam);
    void OnLButtonDown(int x, int y, UINT keyFlags);
    void OnLButtonUp(int x, int y, UINT keyFlags);
    void AddButtons(BOOL fAdd);
    void UpdateButtonArray(TBBUTTON *ptbDst, const TBBUTTON *ptbSrc, int ctb, LONG_PTR lStrOffset);

    // Helper Methods
    void FocusChange(BOOL);
    BOOL RegisterAndCreateWindow(void);
    void Cleanup(void);
    
    HRESULT GetConnectionPoint(LPUNKNOWN pUnk, REFIID riid, LPCONNECTIONPOINT* pCP);
    
public:
    LRESULT WndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
};


#endif   // __BLHost_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\bllist.cpp ===
// bllist.cpp : Implementation of the CMsgrList
// Messenger integration to OE
// Created 05/07/98 by YST
// 

#include "pch.hxx"
#include "bllist.h"
#include "basicim2.h"
#include "msoert.h"
#include "blobevnt.h"
#include <string.h>
#include "shlwapi.h" 
#include "shlwapip.h" 

static CMsgrList * sg_pMsgrList = NULL;     // global for buddy list

int const CCHMAX = 512;

CMsgrList::CMsgrList()
{
    m_pblInfRoot = NULL;
    m_pblInfLast = NULL;
    m_pWndLRoot = NULL;
    m_pWndLLast = NULL;
    m_nRef = 1;
    m_spMsgrObject = NULL;
    m_pMsgrObjectEvents = NULL;
    m_MsgrCookie = 0xffffffff;
}


CMsgrList::~CMsgrList()
{
    Assert(m_nRef == 0);

    if(m_pblInfRoot)
    {
        FreeMsgrInfoList(m_pblInfRoot);
        m_pblInfRoot = NULL;
        m_pblInfLast = NULL;
    }

    if(m_pWndLRoot)
        FreeWndList(m_pWndLRoot);

    if(m_pMsgrObjectEvents)
    {
        m_pMsgrObjectEvents->DelListOfBuddies();
        if (m_MsgrCookie != 0xffffffff && m_spMsgrObject != NULL)
            m_spMsgrObject->UnadviseOE(m_MsgrCookie);
        m_pMsgrObjectEvents->Release();
        m_pMsgrObjectEvents = NULL;
    }
}

void CMsgrList::Release()
{
    Assert(m_nRef > 0);

    m_nRef--;
    if(m_nRef == 0)
    {
        DelAllEntries(NULL);
        delete this;
        sg_pMsgrList = NULL;
    }
}

// Check and Init Msgr
HRESULT CMsgrList::CheckAndInitMsgr()
{
    if(m_pblInfRoot)
        return(S_OK);
    else
    {
        // Do Initialization again
        if(!m_pMsgrObjectEvents)
        {
            if(HrInitMsgr() == S_OK)
                return(FillList());
            else
                return S_FALSE;
        }
        else
            return(FillList());
    }
    return S_FALSE;         //???
}

// Free list of client UI window
void CMsgrList::FreeWndList(LPMWNDLIST pWndEntry)
{
    if(pWndEntry->pNext)
        FreeWndList(pWndEntry->pNext);
    
    MemFree(pWndEntry);
    pWndEntry = NULL;
}

// Free list buddies
void CMsgrList::FreeMsgrInfoList(LPMINFO pEntry)
{
    if(pEntry == NULL)
        return;
    if(pEntry->pNext)
        FreeMsgrInfoList(pEntry->pNext);

    MemFree(pEntry->pchMsgrName);
    MemFree(pEntry->pchID);
    MemFree(pEntry->pchHomePhone);
    MemFree(pEntry->pchWorkPhone);
    MemFree(pEntry->pchMobilePhone);
    MemFree(pEntry);
    pEntry = NULL;
}

// Remove buddy from list
void CMsgrList::RemoveMsgrInfoEntry(LPMINFO pEntry)
{
    if(m_pblInfLast == pEntry)
        m_pblInfLast = pEntry->pPrev;

    if(m_pblInfRoot == pEntry)
        m_pblInfRoot = pEntry->pNext;

    MemFree(pEntry->pchMsgrName);
    MemFree(pEntry->pchID);
    MemFree(pEntry->pchHomePhone);
    MemFree(pEntry->pchWorkPhone);
    MemFree(pEntry->pchMobilePhone);

    if(pEntry->pPrev)
        (pEntry->pPrev)->pNext = pEntry->pNext;

    if(pEntry->pNext)
        (pEntry->pNext)->pPrev = pEntry->pPrev;

    MemFree(pEntry);
    pEntry = NULL;
}

// Check that item is Online starting point for search is pEntry
BOOL CMsgrList::IsContactOnline(WCHAR *pchID, LPMINFO pEntry)
{
    if(!pEntry)
        return(FALSE);

    if(!lstrcmpiW(pEntry->pchID, pchID))
    {
        if((pEntry->nStatus != BIMSTATE_OFFLINE)  && (pEntry->nStatus != BIMSTATE_INVISIBLE))
            return(TRUE);
        else
            return(FALSE);
    }
    else if(pEntry->pNext)
        return(IsContactOnline(pchID, pEntry->pNext));
    else
        return(FALSE);
}

// Find entry with ID == szID and remove this from list
void CMsgrList::FindAndRemoveBlEntry(WCHAR *szID, LPMINFO pEntry)
{
    if(!pEntry)
        pEntry = m_pblInfRoot;

    if(!pEntry)
        return;

    if(!lstrcmpiW(pEntry->pchID, szID))
    {
        RemoveMsgrInfoEntry(pEntry);
    }
    else if(pEntry->pNext)
        FindAndRemoveBlEntry(szID, pEntry->pNext);
}

// Send message to all registred client UI windows
void CMsgrList::SendMsgToAllUIWnd(UINT msg, WPARAM wParam, LPARAM lParam, LPMWNDLIST pWndEntry)
{
    if(!pWndEntry)
        pWndEntry = m_pWndLRoot;

    if(!pWndEntry)
        return;

    if(pWndEntry->pNext)
        SendMsgToAllUIWnd(msg, wParam, lParam, pWndEntry->pNext);

    ::SendMessage(pWndEntry->hWndUI, msg, wParam, lParam);
}

// Add client Window to list
void CMsgrList::AddWndEntry(HWND hWnd)
{
    if(m_pWndLLast == NULL)
    {
        // Really first entry
        Assert(!m_pWndLRoot);
        if (!MemAlloc((LPVOID *) &m_pWndLLast, sizeof(MsgrWndList)))
            return;
        m_pWndLRoot = m_pWndLLast;
        m_pWndLLast->pPrev = NULL;
    }
    else 
    {
        if (!MemAlloc((LPVOID *) &(m_pWndLLast->pNext), sizeof(MsgrWndList)))
            return;
        (m_pWndLLast->pNext)->pPrev = m_pWndLLast;
        m_pWndLLast = m_pWndLLast->pNext;

    }
    
    m_pWndLLast->pNext = NULL;
    m_pWndLLast->hWndUI = hWnd;

}

// remove entry from WND list
void CMsgrList::RemoveWndEntry(LPMWNDLIST pWndEntry)
{
    if(m_pWndLLast == pWndEntry)
        m_pWndLLast = pWndEntry->pPrev;

    if(m_pWndLRoot == pWndEntry)
        m_pWndLRoot = pWndEntry->pNext;

    if(pWndEntry->pPrev)
        (pWndEntry->pPrev)->pNext = pWndEntry->pNext;

    if(pWndEntry->pNext)
        (pWndEntry->pNext)->pPrev = pWndEntry->pPrev;

    MemFree(pWndEntry);
    pWndEntry = NULL;

}

// Find entry and remove it from list
void CMsgrList::FindAndDelEntry(HWND hWnd, LPMWNDLIST pWndEntry)
{
    if(!pWndEntry)
        pWndEntry = m_pWndLRoot;

    if(!pWndEntry)
        return;

    if(pWndEntry->hWndUI == hWnd)
    {
        RemoveWndEntry(pWndEntry);
    }
    else if(pWndEntry->pNext)
        FindAndDelEntry(hWnd, pWndEntry->pNext);
}

void  CMsgrList::DelAllEntries(LPMWNDLIST pWndEntry)
{
    if(pWndEntry == NULL)
        pWndEntry = m_pWndLRoot;                

    if(pWndEntry == NULL)
        return;

    if(pWndEntry->pNext)
        DelAllEntries(pWndEntry->pNext);

    RemoveWndEntry(pWndEntry);
}

HRESULT CMsgrList::HrInitMsgr(void)
{
	//create the COM server and connect to it
	HRESULT hr = S_OK;
    
    Assert(m_pMsgrObjectEvents == NULL);

    m_spMsgrObject = NULL;
	hr = CoCreateInstance(CLSID_BasicIMObject, NULL,CLSCTX_LOCAL_SERVER, 
		                IID_IBasicIM, (LPVOID *)&m_spMsgrObject);
    if(FAILED(hr))
    {
        return(hr);
    }

    m_pMsgrObjectEvents = new CMsgrObjectEvents();
    if (m_pMsgrObjectEvents == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
	    hr = m_spMsgrObject->AdviseOE(m_pMsgrObjectEvents, &m_MsgrCookie);
        //We, of course, have to release m_pMsgrObjectEvents when we are finished with it
        if(FAILED(hr))
        {
            m_pMsgrObjectEvents->Release();
            m_pMsgrObjectEvents = NULL;
        }
        else 
            m_pMsgrObjectEvents->SetListOfBuddies(this);
    }

    return(hr);
}

// Set new buddy status (online/ofline/etc. and redraw list view entry)
HRESULT CMsgrList::EventUserStateChanged(IBasicIMUser * pUser)
{
    BSTR bstrID;
    HRESULT hr = pUser->get_LogonName(&bstrID);
    BOOL fFinded = FALSE;
    
    if (SUCCEEDED(hr))
    {
        BIMSTATE nState = BIMSTATE_UNKNOWN;
        if(SUCCEEDED(pUser->get_State(&nState)))
        {
            LPMINFO pInf = m_pblInfRoot;
            if(!pInf)
            {
                //                    MemFree(pszID);    
                SysFreeString(bstrID);
                return(hr);
            }
            
            // Find buddy in our list
            do
            {
                if(!lstrcmpiW(pInf->pchID, bstrID))
                {
                    fFinded = TRUE;
                    break;
                }
            } while ((pInf = pInf->pNext) != NULL);
            
            if(fFinded)
            {
                pInf->nStatus = nState;
                SendMsgToAllUIWnd(WM_USER_STATUS_CHANGED, (WPARAM) nState, (LPARAM) bstrID);
            }
        }
        
    }
    
    SysFreeString(bstrID);
    return(hr);
}

// Baddy was removed
HRESULT CMsgrList::EventUserRemoved(IBasicIMUser * pUser)
{
    BSTR bstrID;
    HRESULT hr = pUser->get_LogonName(&bstrID);
    
    if (SUCCEEDED(hr))
    {
        Assert(m_nRef > 0);  
        SendMsgToAllUIWnd(WM_USER_MUSER_REMOVED, (WPARAM) 0, (LPARAM) bstrID);
        FindAndRemoveBlEntry(bstrID);
    }
    
    SysFreeString(bstrID);
    return(hr);
}

// Event: buddy name was changed
// Add buddy to our list and send message to UI windows about this.
HRESULT CMsgrList::EventUserNameChanged(IBasicIMUser * pUser)
{
    BSTR bstrName;
    BSTR bstrID;
    BOOL fFinded = FALSE;
    
    HRESULT hr = pUser->get_LogonName(&bstrID);
    hr = pUser->get_FriendlyName(&bstrName);
    if (SUCCEEDED(hr))
    {
        LPMINFO pInf = m_pblInfRoot;
        
        // Find buddy in our list
        do
        {
            if(!lstrcmpiW(pInf->pchID, bstrID))
            {
                fFinded = TRUE;
                break;
            }
        } while ((pInf = pInf->pNext) != NULL);
        
        if(fFinded)
        {
            if(pInf->pchMsgrName)
                MemFree(pInf->pchMsgrName);       // Free prev name
            pInf->pchMsgrName = bstrName;
            SendMsgToAllUIWnd(WM_USER_NAME_CHANGED, (WPARAM) 0, (LPARAM) pInf);
        }
    }        

    SysFreeString(bstrName);
    SysFreeString(bstrID);
    return(hr);   
}

// Event: local state changed
HRESULT CMsgrList::EventLocalStateChanged(BIMSTATE State)
{
    SendMsgToAllUIWnd(WM_LOCAL_STATUS_CHANGED, (WPARAM) 0, (LPARAM) State);
    return(S_OK);
}

// Event: buddy was added
// Add buddy to our list and send message to UI windows about this.

HRESULT CMsgrList::EventUserAdded(IBasicIMUser * pUser)
{
    BSTR bstrName;
    BSTR bstrID;
    WCHAR wszHome[CCHMAX] = {0};
    WCHAR wszWork[CCHMAX] = {0};
    WCHAR wszMobile[CCHMAX] = {0};
    WCHAR *pH, *pW, *pM;
    
    HRESULT hr = pUser->get_LogonName(&bstrID);
    hr = pUser->get_FriendlyName(&bstrName);
    if (SUCCEEDED(hr))
    {
        BIMSTATE nState = BIMSTATE_UNKNOWN;
        if(SUCCEEDED(pUser->get_State(&nState)))
        {
            CComPtr<IBasicIMUser2> spUser2;

            if(SUCCEEDED(pUser->QueryInterface(IID_IBasicIMUser2, (void **) &spUser2)))
            {
                VARIANT var;
                var.vt = VT_BSTR;

                if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_HOME_PHONE_NUMBER, &var)))
                {
                    StrCpyNW(wszHome, var.bstrVal, CCHMAX - 1);
                    wszHome[CCHMAX - 1] = L'\0';
                    pH = wszHome;
                }
                else
                    pH = NULL;

                if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_WORK_PHONE_NUMBER, &var)))
                {
                    StrCpyNW(wszWork, var.bstrVal, CCHMAX - 1);
                    wszWork[CCHMAX - 1] = L'\0';
                    pW = wszWork;
                }
                else
                    pW = NULL;

                if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_MOBILE_PHONE_NUMBER, &var)))
                {
                    StrCpyNW(wszMobile, var.bstrVal, CCHMAX - 1);
                    wszMobile[CCHMAX - 1] = L'\0';
                    pM = wszMobile;
                }
                else
                    pM = NULL;
            }
            AddMsgrListEntry(bstrName, bstrID, nState,pH, pW, pM);
            SendMsgToAllUIWnd(WM_USER_MUSER_ADDED, (WPARAM) 0, (LPARAM) m_pblInfLast);
            
        }
    }
    SysFreeString(bstrName);
    SysFreeString(bstrID);
    return(hr);
}

HRESULT CMsgrList::EventLogoff()
{
    SendMsgToAllUIWnd(WM_MSGR_LOGOFF, (WPARAM) 0, (LPARAM) 0);
    FreeMsgrInfoList(m_pblInfRoot);
    m_pblInfRoot = NULL;
    m_pblInfLast = NULL;
    return(S_OK);
    
}

HRESULT CMsgrList::EventAppShutdown()
{
    SendMsgToAllUIWnd(WM_MSGR_SHUTDOWN, (WPARAM) 0, (LPARAM) 0);
    return(S_OK);   
}

HRESULT CMsgrList::EventLogonResult(long lResult)
{
    if(!m_pblInfRoot && SUCCEEDED(lResult))
        FillList();
    else if(SUCCEEDED(lResult))
    {
//        EnterCriticalSection(&g_csMsgrList);
        FreeMsgrInfoList(m_pblInfRoot);
        m_pblInfRoot = NULL;
        m_pblInfLast = NULL;
        FillList();
        // LeaveCriticalSection(&g_csMsgrList);
    }
    SendMsgToAllUIWnd(WM_MSGR_LOGRESULT, (WPARAM) 0, (LPARAM) lResult);
    return(S_OK);
}

// return number of buddies
long CMsgrList::GetCount()
{
    HRESULT hr = E_FAIL;
    long lCount = 0;
    CComPtr<IBasicIMUsers> spBuddies;

    if (!m_spMsgrObject)
        goto Exit;

    hr = m_spMsgrObject->get_ContactList(&spBuddies);
    if( FAILED(hr) )
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Buddies() failed, hr = %s"), g_GetErrorString(hr));
        Assert(FALSE);
        goto Exit;
    }

    //Iterate through the MsgrList make sure that the buddy we wish to remove is effectively in the list
    hr = spBuddies->get_Count(&lCount);
    Assert(SUCCEEDED(hr));
Exit:
    return(lCount);
}

HRESULT CMsgrList::FillList()
{
    long lCount = 0;
    IBasicIMUser* pUser = NULL;
    WCHAR wszHome[CCHMAX] = {0};
    WCHAR wszWork[CCHMAX] = {0};
    WCHAR wszMobile[CCHMAX] = {0};
    
    //process the Buddies list
    IBasicIMUsers *pBuddies = NULL;
    
    if(!m_spMsgrObject)
        return S_FALSE;
    
    HRESULT hr = m_spMsgrObject->get_ContactList(&pBuddies);
    if(FAILED(hr))
    {
FilErr:
    if(m_pMsgrObjectEvents)
    {
        m_pMsgrObjectEvents->DelListOfBuddies();
        if (m_MsgrCookie != 0xffffffff)
        {
            if (m_spMsgrObject)
                m_spMsgrObject->UnadviseOE(m_MsgrCookie);
            m_MsgrCookie = 0xffffffff;
        }
        m_pMsgrObjectEvents->Release();
        m_pMsgrObjectEvents = NULL;
    }
    return(hr);
    }
    
    //Check the current state (in case the client was already running and was 
    //not in the logoff state
    BIMSTATE lState = BIMSTATE_OFFLINE;
    if (m_spMsgrObject)
        hr = m_spMsgrObject->get_LocalState(&lState);
    
    if(FAILED(hr) /*|| lState == BIMSTATE_OFFLINE  !(lState == BIMSTATE_ONLINE || lState == BIMSTATE_BUSY || lState == BIMSTATE_INVISIBLE)*/)
    {
Err2:
    pBuddies->Release();
    pBuddies = NULL;
    goto FilErr;
    }
    else if(lState == BIMSTATE_OFFLINE)
    {
        if(FAILED(AutoLogon()))
            goto Err2;
    }
    
    if(!SUCCEEDED(pBuddies->get_Count(&lCount)))
        goto Err2;
    
    for (int i = 0; i < lCount; i++)
    {
        hr = pBuddies->Item(i, &pUser);
        if(SUCCEEDED(hr))
        {
            // EventUserAdded(pUser);
            BSTR bstrName;
            BSTR bstrID;
            
            hr = pUser->get_LogonName(&bstrID);
            hr = pUser->get_FriendlyName(&bstrName);
            if (SUCCEEDED(hr))
            {
                BIMSTATE nState = BIMSTATE_UNKNOWN;
                if(SUCCEEDED(pUser->get_State(&nState)))
                {
                    CComPtr<IBasicIMUser2> spUser2;
                    WCHAR *pH, *pW, *pM;
                    
                    if(SUCCEEDED(pUser->QueryInterface(IID_IBasicIMUser2, (void **) &spUser2)))
                    {
                        VARIANT var;
                        var.vt = VT_BSTR;
                        
                        if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_HOME_PHONE_NUMBER, &var)))
                        {
                            StrCpyNW(wszHome, var.bstrVal, CCHMAX - 1);
                            wszHome[CCHMAX - 1] = L'\0';
                            pH = wszHome;
                        }
                        else
                            pH = NULL;
                        
                        if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_WORK_PHONE_NUMBER, &var)))
                        {
                            StrCpyNW(wszWork, var.bstrVal, CCHMAX - 1);
                            wszWork[CCHMAX - 1] = L'\0';
                            pW = wszWork;
                        }
                        else
                            pW = NULL;
                        
                        if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_MOBILE_PHONE_NUMBER, &var)))
                        {
                            StrCpyNW(wszMobile, var.bstrVal, CCHMAX - 1);
                            wszMobile[CCHMAX - 1] = L'\0';
                            pM = wszMobile;
                        }
                        else
                            pM = NULL;
                    }
                    AddMsgrListEntry(bstrName, bstrID, nState,pH, pW, pM);
                }
            }
            SysFreeString(bstrName);
            SysFreeString(bstrID);
            pUser->Release();
        }
    }
    pBuddies->Release();
    return(S_OK);
}

// Add entry to list of buddies
void CMsgrList::AddMsgrListEntry(WCHAR *szName, WCHAR *szID, int nState, WCHAR *wszHomePhone, WCHAR *wszWorkPhone, WCHAR *wszMobilePhone)
{
    if(m_pblInfLast == NULL)
    {
        // Really first entry
        Assert(!m_pblInfRoot);
        if (!MemAlloc((LPVOID *) &m_pblInfLast, sizeof(oeMsgrInfo)))
            return;
        m_pblInfRoot = m_pblInfLast;
        m_pblInfLast->pPrev = NULL;
    }
    else 
    {
        if (!MemAlloc((LPVOID *) &(m_pblInfLast->pNext), sizeof(oeMsgrInfo)))
            return;
        (m_pblInfLast->pNext)->pPrev = m_pblInfLast;
        m_pblInfLast = m_pblInfLast->pNext;
        
    }
    
    m_pblInfLast->pNext = NULL;
    
    if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchMsgrName), (lstrlenW(szName) + 1)*sizeof(WCHAR)))
        return;
    StrCpyNW(m_pblInfLast->pchMsgrName, szName, lstrlenW(szName) + 1);
    
    if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchID), (lstrlenW(szID) + 1)*sizeof(WCHAR)))
        return;
    StrCpyNW(m_pblInfLast->pchID, szID, lstrlenW(szID) + 1);
    m_pblInfLast->nStatus = nState;
    
    if(wszHomePhone)
    {
        if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchHomePhone), (lstrlenW(wszHomePhone) + 1)*sizeof(WCHAR)))
            return;
        StrCpyNW(m_pblInfLast->pchHomePhone, wszHomePhone, lstrlenW(wszHomePhone) + 1);
    }
    else 
        m_pblInfLast->pchHomePhone = NULL;
    
    if(wszWorkPhone)
    {
        if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchWorkPhone), (lstrlenW(wszWorkPhone) + 1)*sizeof(WCHAR)))
            return;
        StrCpyNW(m_pblInfLast->pchWorkPhone, wszWorkPhone, lstrlenW(wszWorkPhone) + 1);
    }
    else 
        m_pblInfLast->pchWorkPhone = NULL;
    
    if(wszMobilePhone)
    {
        if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchMobilePhone), (lstrlenW(wszMobilePhone) + 1)*sizeof(WCHAR)))
            return;
        StrCpyNW(m_pblInfLast->pchMobilePhone, wszMobilePhone, lstrlenW(wszMobilePhone) + 1);
    }
    else 
        m_pblInfLast->pchMobilePhone = NULL;
    
}

// register ui window in list
void CMsgrList::RegisterUIWnd(HWND hWndUI)
{
    CheckAndInitMsgr();
    AddWndEntry(hWndUI);
}

// remove UI window from list
void CMsgrList::UnRegisterUIWnd(HWND hWndUI)
{
    if(hWndUI)
        FindAndDelEntry(hWndUI);
}

// This call Messenger UI for instant message.
HRESULT CMsgrList::SendInstMessage(WCHAR *pchID)
{
    Assert(m_spMsgrObject);
    BSTRING bstrName(pchID);
    VARIANT var;
    var.bstrVal = bstrName;
    var.vt = VT_BSTR;

    HRESULT hr = S_OK;
    if(m_spMsgrObject)
        hr = m_spMsgrObject->LaunchIMUI(var);

    return(hr);
}

HRESULT CMsgrList::AutoLogon()
{
    if(m_spMsgrObject)
    {
        // if(DwGetOption(OPT_BUDDYLIST_CHECK))
            m_spMsgrObject->AutoLogon();
    }
    else
        return(E_FAIL);

    return S_OK;

}

HRESULT CMsgrList::UserLogon()
{
    if(m_spMsgrObject)
        return(m_spMsgrObject->LaunchLogonUI());
    else
        return(S_FALSE);
}

// Logoff call
HRESULT CMsgrList::UserLogoff()
{
    if(!m_spMsgrObject)
        return E_UNEXPECTED;

    return(m_spMsgrObject->Logoff());
}

// Get/Set local states.
HRESULT CMsgrList::GetLocalState(BIMSTATE *pState)
{
    if(m_spMsgrObject && SUCCEEDED(m_spMsgrObject->get_LocalState(pState)))
        return(S_OK);
    else
        return(S_FALSE);
}

// Check name: this is local name?
BOOL CMsgrList::IsLocalName(WCHAR *pchName)
{
    CComBSTR cbstrID;
    HRESULT hr;
    BOOL fRes = FALSE;

    if(m_spMsgrObject)
    {
        hr = m_spMsgrObject->get_LocalLogonName(&cbstrID);
        if(FAILED(hr))
            return FALSE;
        if(!lstrcmpiW(pchName, (LPWSTR)cbstrID))
            fRes = TRUE;
    }

    return(fRes);    
}

// Check current state
BOOL CMsgrList::IsLocalOnline(void)
{
    BIMSTATE State;
    if(m_spMsgrObject && SUCCEEDED(m_spMsgrObject->get_LocalState(&State)))
    {
        switch(State)
        {
            case BIMSTATE_ONLINE:
            case BIMSTATE_INVISIBLE:
            case BIMSTATE_BUSY:
            case BIMSTATE_BE_RIGHT_BACK:
            case BIMSTATE_IDLE:
            case BIMSTATE_AWAY:
            case BIMSTATE_ON_THE_PHONE:
            case BIMSTATE_OUT_TO_LUNCH:
                return(TRUE);

            default:
                return(FALSE);
        }
    }
    return(FALSE);
}

HRESULT CMsgrList::SetLocalState(BIMSTATE State)
{
    if(m_spMsgrObject && State != BIMSTATE_UNKNOWN)
    {
        m_spMsgrObject->put_LocalState(State);
        return S_OK;                        
    }
    else
        return S_FALSE;
}

HRESULT CMsgrList::NewOnlineContact()
{
    if(m_spMsgrObject)
        return(m_spMsgrObject-> LaunchAddContactUI(NULL));
    else
        return(S_FALSE); 

}

HRESULT CMsgrList::LaunchOptionsUI(void)
{
    if(m_spMsgrObject)
        return(m_spMsgrObject-> LaunchOptionsUI());
    else
        return(S_FALSE); 
}


HRESULT CMsgrList::LaunchPhoneUI(WCHAR *Phone)
{
    BSTRING             bstrPhone(Phone);
    HRESULT hr = S_FALSE;
    if(m_spMsgrObject)
         hr = m_spMsgrObject->LaunchPhoneUI(bstrPhone);

    return(hr); 
}

//****************************************************************************
//
// void CMsgrList::DeleteUser
//
// This function finds
// the buddy to be removed in the MsgrList and then calls the Remove method.
//
//****************************************************************************

HRESULT CMsgrList::FindAndDeleteUser(WCHAR * pchID, BOOL fDelete) 
{
    USES_CONVERSION;

    HRESULT             hr = E_FAIL;
    INT                 i;
    LONG                lCount = 0;
    BOOL                bFound = FALSE;
    CComPtr<IBasicIMUser>  spUser;
    CComPtr<IBasicIMUsers> spBuddies;
    // BSTRING             bstrName(pchID);
    // get an interface pointer to the MsgrList, so we can call the method Remove after
    if (!m_spMsgrObject)
    {
        hr = E_FAIL;
        goto Exit;
    }
    hr = m_spMsgrObject->get_ContactList(&spBuddies);
    if( FAILED(hr) )
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Buddies() failed, hr = %s"), g_GetErrorString(hr));
        Assert(FALSE);
        goto Exit;
    }

    //Iterate through the MsgrList make sure that the buddy we wish to remove is effectively in the list
    hr = spBuddies->get_Count(&lCount);
    Assert(SUCCEEDED(hr));
    
    for(i = 0; ((i<lCount) && (!bFound)); i++)
    {
        CComBSTR    cbstrID;

        spUser.Release();
        hr = spBuddies->Item(i, &spUser);
        
        if (SUCCEEDED(hr))
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("Item : %i succeeded"), i);
            
            hr = spUser->get_LogonName(&cbstrID);
            Assert(SUCCEEDED(hr));
            if (lstrcmpiW((LPCWSTR) cbstrID, pchID) == 0)
                bFound = TRUE;

            if (bFound)
                break;
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("Item : %i failed, hr = %s"), i, g_GetErrorString(hr));
            Assert(FALSE);
        }
    }
    
    // if we found the buddy in the list
    if( bFound )
    {
        if(fDelete)
            //finally, make the request to remove the buddy to the MsgrList
            hr = spBuddies->Remove(spUser);
        else
            // just search
            hr = S_OK;
    }
    else // Not found
    
        hr = DISP_E_MEMBERNOTFOUND;
Exit:
//    SysFreeString(bstrName);
    return(hr);
}

HRESULT CMsgrList::AddUser(WCHAR * pchID) 
{
    CComPtr<IBasicIMUser>  spUser;
    CComPtr<IBasicIMUsers> spUsers;
    BSTRING             bstrName(pchID);

    HRESULT hr = FindAndDeleteUser(pchID, FALSE /*fDelete*/);
    if(hr != DISP_E_MEMBERNOTFOUND)
        return(hr);

    // if not found, add buddy

    // get an interface pointer to the MsgrList, so we can call the method Remove after
    if (!m_spMsgrObject)
        return E_FAIL;
    hr = m_spMsgrObject->LaunchAddContactUI(bstrName);

    return(hr);

}


// Global functions available for everybody

// Entrance to MsgrList
CMsgrList *OE_OpenMsgrList(void)
{
    // if(!sg_pMsgrList)     
//    {
        // this first call, create class
        CMsgrList *pMsgrList = new(CMsgrList);

        if(pMsgrList)
        {
            // Init of User List
            if(pMsgrList->HrInitMsgr() == S_OK)
            {
                if(pMsgrList->FillList() != S_OK)
                    goto ErrEx;
            }
            else
            {
ErrEx:
                pMsgrList->Release();
                return(NULL);
            }
        }

//    }
//    else
//        sg_pMsgrList->AddRef();

    // LeaveCriticalSection(&g_csMsgrList);

    return(pMsgrList);
}

// Close entrance to MsgrList
void    OE_CloseMsgrList(CMsgrList *pCMsgrList)
{
    // Assert(pCMsgrList == sg_pMsgrList);

    // EnterCriticalSection(&g_csMsgrList);
    pCMsgrList->EventLocalStateChanged(BIMSTATE_OFFLINE);
    pCMsgrList->Release();
    // LeaveCriticalSection(&g_csMsgrList);
}

HRESULT OE_Msgr_Logoff(void)
{
    BIMSTATE State;
    HRESULT hr = S_OK;
#ifdef LATER    
    if(!sg_pMsgrList)
    {
        // EnterCriticalSection(&g_csMsgrList);
        sg_pMsgrList = new(CMsgrList);
        // LeaveCriticalSection(&g_csMsgrList);

        if(!sg_pMsgrList)
            return(E_UNEXPECTED);

        // Init of User List
        if(FAILED(hr = sg_pMsgrList->HrInitMsgr()))
            goto logoff_end;

        else if(FAILED(hr = sg_pMsgrList->GetLocalState(&State)) || State == BIMSTATE_OFFLINE)
            goto logoff_end;
        else
            hr = sg_pMsgrList->UserLogoff();

    }
    else
    {
        return(sg_pMsgrList->UserLogoff());  // we cannot delete sg_pMsgrList in this case!
    }

logoff_end:
    if(sg_pMsgrList)
    {
        OE_CloseMsgrList(sg_pMsgrList);
    }
#endif
    return(hr);
}

HRESULT InstallMessenger(HWND hWnd)
{
    HRESULT         hr  = REGDB_E_CLASSNOTREG;
#ifdef LATER
	uCLSSPEC classpec;
    TCHAR szBuff[CCHMAX];
		
   	classpec.tyspec=TYSPEC_CLSID;
	classpec.tagged_union.clsid = CLSID_MessengerApp;
	
  	// See below for parameter definitions and return values
	hr = FaultInIEFeature(hWnd, &classpec, NULL, FIEF_FLAG_FORCE_JITUI);

	if (hr != S_OK) {
        if(hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            AthLoadString(idsJITErrDenied, szBuff, ARRAYSIZE(szBuff));
            AthMessageBox(hWnd, MAKEINTRESOURCE(idsAthena), szBuff,
                    NULL, MB_OK | MB_ICONSTOP);
        }
        else
        {
            AthLoadString(idsBAErrJITFail, szBuff, ARRAYSIZE(szBuff));
            MenuUtil_BuildMessengerString(szBuff);
            AthMessageBox(hWnd, MAKEINTRESOURCE(idsAthena), szBuff,
                    NULL, MB_OK | MB_ICONSTOP);
        }
		hr = REGDB_E_CLASSNOTREG;
	}
#else
    hr= S_OK;
#endif // LATER
        return hr;
}

#ifdef NEEDED
HRESULT OE_Msgr_Logon(void)
{
    if(!sg_pMsgrList)
        return S_FALSE;
    else
        return(sg_pMsgrList->UserLogon());

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\bllist.h ===
// bllist.h : Declaration of the CMsgrList
// Messenger integration to OE
// Created 05/07/98 by YST
// 
#ifndef __BLLIST_H_
#define __BLLIST_H_

#include "basicim2.h"
#include "blobevnt.h"

#define MAXNAME 256

// message for all Msgr client windows
#define WM_USER_STATUS_CHANGED      (WM_USER + 1)
#define WM_MSGR_LOGOFF              (WM_USER + 2)
#define WM_MSGR_LOGRESULT           (WM_USER + 3)
#define WM_USER_MUSER_REMOVED       (WM_USER + 4)
#define WM_USER_MUSER_ADDED         (WM_USER + 5)
#define WM_USER_NAME_CHANGED        (WM_USER + 6)
#define WM_LOCAL_STATUS_CHANGED     (WM_USER + 7)
#define WM_MSGR_SHUTDOWN            (WM_USER + 8)


typedef struct _tag_OEMsgrInfo
{
    WCHAR   * pchMsgrName;
    WCHAR   * pchID;
    WCHAR   * pchHomePhone;
    WCHAR   * pchWorkPhone;
    WCHAR   * pchMobilePhone;
    int     nStatus;
    struct _tag_OEMsgrInfo * pPrev;
    struct _tag_OEMsgrInfo * pNext;
} oeMsgrInfo;

typedef oeMsgrInfo * LPMINFO;

typedef struct _tag_MsgrWndList
{
    HWND hWndUI;
    struct _tag_MsgrWndList * pPrev;
    struct _tag_MsgrWndList * pNext;
} MsgrWndList;

typedef MsgrWndList * LPMWNDLIST;

class CMsgrList
{
public:

    CMsgrList();
    ~CMsgrList();

    void        AddWndEntry(HWND hWnd);
    void        FindAndDelEntry(HWND hWnd, LPMWNDLIST pWndEntry=NULL);
    LPMINFO     GetRootMsgrItem(void)    { return(m_pblInfRoot); }
    void        RegisterUIWnd(HWND hWndUI);
    void        UnRegisterUIWnd(HWND hWndUI);
    LPMINFO     GetFirstMsgrItem(void)                { CheckAndInitMsgr(); return (m_pblInfRoot); };
    LPMINFO     GetNextMsgrItem(LPMINFO pEntry)      { return(pEntry ? pEntry->pNext : NULL); }
    int         AddRef(void)                        { return(++m_nRef); }
    void        Release(void);                      /* { return(--m_nRef); } */
    HRESULT     CheckAndInitMsgr(void);
    HRESULT     SendInstMessage(WCHAR *pchID);
    HRESULT     EventUserStateChanged(IBasicIMUser * pUser);
    HRESULT     EventUserRemoved(IBasicIMUser * pUser);
    HRESULT     EventUserAdded(IBasicIMUser * pUser);
    HRESULT     EventUserNameChanged(IBasicIMUser * pUser);
    HRESULT     EventLocalStateChanged(BIMSTATE State);

    HRESULT     UserLogon(void);
    HRESULT     AutoLogon(void);
    HRESULT     GetLocalState(BIMSTATE *pState);
    HRESULT     SetLocalState(BIMSTATE State);
    HRESULT     EventLogoff(void);
    HRESULT     EventAppShutdown(void);
    HRESULT     EventLogonResult(long lResult);
    HRESULT     HrInitMsgr(void);
    HRESULT     FillList(void);
    HRESULT     UserLogoff(void);
    HRESULT     FindAndDeleteUser(WCHAR * pchID, BOOL fDelete);
    HRESULT     NewOnlineContact(void);
    HRESULT     LaunchOptionsUI(void);
    HRESULT     LaunchPhoneUI(WCHAR *Phone);
    HRESULT     AddUser(WCHAR * pchID);
    void        DelAllEntries(LPMWNDLIST pWndEntry);
    long        GetCount(void);
    BOOL        IsLocalOnline(void);
    BOOL        IsLocalName(WCHAR *pchName);
    BOOL        IsContactOnline(WCHAR *pchID, LPMINFO pEntry);

private:
    void        FreeWndList(LPMWNDLIST pWndEntry);
    void        FreeMsgrInfoList(LPMINFO pEntry);
    void        RemoveMsgrInfoEntry(LPMINFO pEntry);
    void        RemoveWndEntry(LPMWNDLIST pWndEntry);
    void        SendMsgToAllUIWnd(UINT msg, WPARAM wParam, LPARAM lParam, LPMWNDLIST pWndEntry=NULL);
    void        AddMsgrListEntry(WCHAR *szName, WCHAR *szID, int nState, WCHAR *wszHomePhone = NULL, WCHAR *wszWorkPhone = NULL, WCHAR *wszMobilePhone = NULL);
    void        FindAndRemoveBlEntry(WCHAR *szID, LPMINFO pEntry=NULL);

private:
    LPMINFO         m_pblInfRoot;
    LPMINFO         m_pblInfLast;
    LPMWNDLIST      m_pWndLRoot;
    LPMWNDLIST      m_pWndLLast;
    int             m_nRef;

    // Smart pointer
    CComPtr<IBasicIM>           m_spMsgrObject;
    CMsgrObjectEvents*          m_pMsgrObjectEvents;

    long            m_MsgrCookie;
};


// Global functions available for everybody
CMsgrList *   OE_OpenMsgrList(void);
void        OE_CloseMsgrList(CMsgrList *pCMsgrList);
HRESULT     OE_Msgr_Logoff(void);
HRESULT     InstallMessenger(HWND hWnd);

#ifdef NEEDED
HRESULT     OE_Msgr_Logon(void);
#endif // NEEDED

#endif // __BLLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\blobevnt.h ===
// File:       BLObEvn.h
// Messenger integration to OE
// Created 04/20/98 by YST
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//

#ifndef BLOBEVNT_H
#define BLOBEVNT_H

//****************************************************************************
//
// INCLUDES
//
//****************************************************************************

#include "clUtil.h"
#include "basicim2.h"

class CMsgrList;

//****************************************************************************
//
// DEFINES
//
//****************************************************************************


//****************************************************************************
//
// CLASS CMsgrObjectEvents
//
//****************************************************************************

class CMsgrObjectEvents :	public DBasicIMEvents, 
						public RefCount
{

//****************************************************************************
//
// METHODS
//
//****************************************************************************

public:

	// Constructor/Destructor

	CMsgrObjectEvents(); 
	virtual ~CMsgrObjectEvents();


	//****************************************************************************
	//
	// IUnknown methods declaration
	//
	//****************************************************************************

	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppvObject);


	//****************************************************************************
	//
	// IDispatch methods declaration
	//
	//****************************************************************************

	STDMETHOD (GetTypeInfoCount) (UINT* pCountTypeInfo);
	STDMETHOD (GetTypeInfo) ( UINT iTypeInfo,
							  LCID,          // This object does not support localization.
							  ITypeInfo** ppITypeInfo);
	STDMETHOD (GetIDsOfNames) (  const IID& iid,
								 OLECHAR** arrayNames,
								 UINT countNames,
								 LCID,          // Localization is not supported.
								 DISPID* arrayDispIDs);
	STDMETHOD (Invoke) ( DISPID dispidMember,
    									 const IID& iid,
	    								 LCID,          // Localization is not supported.
		    							 WORD wFlags,
										 DISPPARAMS* pDispParams,
										 VARIANT* pvarResult,
										 EXCEPINFO* pExcepInfo,
										 UINT* pArgErr);

    STDMETHOD (SetListOfBuddies) (CMsgrList *pList);
    STDMETHOD (DelListOfBuddies) (void);

private:
    CMsgrList * m_pMsgrList;
    IBasicIM  * m_pMsgr;
};


#endif //BLOBEVNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\blobevnt.cpp ===
//****************************************************************************
//
// BLObEvnt.cpp
// Messenger integration to OE
// Created 04/20/98 by YST
//
//  Copyright (c) Microsoft Corporation 1997-1998
//


#include "pch.hxx"
#include "MDispid.h"
#include "BLObEvnt.h"
// #include "demand.h"
#include "bllist.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define ASSERT _ASSERTE

#define STR_MAX     256

//****************************************************************************
//
// CLASS CMsgrObjectEvents
//
//****************************************************************************

//****************************************************************************
//
// Construction/Destruction
//
//****************************************************************************

CMsgrObjectEvents::CMsgrObjectEvents() 
{
    // m_pBlAbCtrl = NULL;
    // lLocalState = BIMSTATE_OFFLINE;
}

CMsgrObjectEvents::~CMsgrObjectEvents()
{

}


//****************************************************************************
//
// Methods from IUnknown
//
//****************************************************************************

//****************************************************************************
//
// STDMETHODIMP_(ULONG) CMsgrObjectEvents::AddRef()
//
// Purpose : increment the object's reference count,
// Entry   : None
// Exit    : current count
//
//****************************************************************************

STDMETHODIMP_ (ULONG) CMsgrObjectEvents::AddRef()
{
	return RefCount::AddRef();
}


//****************************************************************************
//
// STDMETHODIMP_(ULONG) CMsgrObjectEvents::Release()
//
// Purpose : decrement the object's reference count
// Entry   : None
// Exit    : returns new count
//
//****************************************************************************

STDMETHODIMP_ (ULONG) CMsgrObjectEvents::Release()
{
	return RefCount::Release();
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::QueryInterface(REFIID iid, LPVOID *ppv)
//
// returns a pointer to the requested interface on the same object
// Purpose: To retrieve a pointer to requested interface
// Entry  : iid -- GUID of requested interface
// Exit   : ppv -- pointer to requested interface (if one exists)
//          return value : HRESULT
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::QueryInterface (REFIID riid, LPVOID *ppv)
{
	*ppv = NULL;
	HRESULT hr = E_NOINTERFACE;

	if (riid == IID_IUnknown)
	 	*ppv = (LPVOID) this;
    else if (riid == DIID_DBasicIMEvents) 
    	*ppv = (LPVOID) this;
	else if (riid == IID_IDispatch) 
    	*ppv = (LPVOID) this;
              
    if (*ppv) 
    {
	 	((LPUNKNOWN)*ppv)->AddRef();
		hr = S_OK;
	}
	return hr;
}

//****************************************************************************
//
// IDispatch implementation
//
//****************************************************************************


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetTypeInfoCount(UINT* pcTypeInfo)
//
// Set pcTypeInfo to 0 because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetTypeInfoCount(UINT* pcTypeInfo)
{
//	g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfoCount call succeeded"));

	*pcTypeInfo = 0 ;
	return NOERROR ;
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetTypeInfo(
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetTypeInfo(
	UINT iTypeInfo,
	LCID,          // This object does not support localization.
	ITypeInfo** ppITypeInfo)
{    
	*ppITypeInfo = NULL ;

	if(iTypeInfo != 0)
	{
		// g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfo call failed -- bad iTypeInfo index"));

		return DISP_E_BADINDEX ; 
	}
	else
	{
		 //g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfo call succeeded"));

		return E_NOTIMPL;
	}
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetIDsOfNames(  
//												const IID& iid,
//												OLECHAR** arrayNames,
//												UINT countNames,
//												LCID,          // Localization is not supported.
//												DISPID* arrayDispIDs)
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetIDsOfNames(  
	const IID& iid,
	OLECHAR** arrayNames,
	UINT countNames,
	LCID,          // Localization is not supported.
	DISPID* arrayDispIDs)
{
	HRESULT hr;
	if (iid != IID_NULL)
	{
		// g_AddToLog(LOG_LEVEL_COM, _T("GetIDsOfNames call failed -- bad IID"));

		return DISP_E_UNKNOWNINTERFACE ;
	}

	// g_AddToLog(LOG_LEVEL_COM, _T("GetIDsOfNames call succeeded"));

	hr = E_NOTIMPL;

	return hr ;
}

// Set BLAB control for CMsgrObjectEvents
STDMETHODIMP CMsgrObjectEvents::SetListOfBuddies(CMsgrList *pList)
{
    m_pMsgrList = pList;
    return S_OK;

}

// Set BLAB control for CMsgrObjectEvents
STDMETHODIMP CMsgrObjectEvents::DelListOfBuddies()
{
    m_pMsgrList = NULL;
    return S_OK;

}

//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::Invoke(   
//										  DISPID dispidMember,
//										  const IID& iid,
//										  LCID,          // Localization is not supported.
//										  WORD wFlags,
//										  DISPPARAMS* pDispParams,
//										  VARIANT* pvarResult,
//										  EXCEPINFO* pExcepInfo,
//										  UINT* pArgErr)
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::Invoke(   
      DISPID dispidMember,
      const IID& iid,
      LCID,          // Localization is not supported.
      WORD wFlags,
      DISPPARAMS* pDispParams,
      VARIANT* pvarResult,
      EXCEPINFO* pExcepInfo,
      UINT* pArgErr)
{   
	// g_AddToLog(LOG_LEVEL_FUNCTIONS, _T("CMsgrObjectEvents::Invoke entered"));
	// g_AddToLog(LOG_LEVEL_NOTIFICATIONS, _T("Dispid passed : %s"), g_GetStringFromDISPID(dispidMember));
	
	HRESULT hr;

    HRESULT     hrRet;

    if (iid != IID_NULL)
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Invoke call failed -- bad IID"));
        return DISP_E_UNKNOWNINTERFACE ;
    }

    ::SetErrorInfo(0, NULL) ;


    BOOL                bRet = TRUE; //this variable is there for future use
    CComPtr<IBasicIMUser>   spUser;
    CComPtr<IBasicIMUsers> spBuddies;
        
    switch (dispidMember) 
    {
    case DISPID_ONLOGONRESULT:
        //we should only have one parameter, the result, and that it is a long
        ASSERT(pDispParams->cArgs == 1);
        ASSERT(pDispParams->rgvarg->vt == VT_I4);
        // g_AddToLog(LOG_LEVEL_NOTIFICATIONS, _T("Result passed : %s"), g_GetStringFromLogonResult(pDispParams->rgvarg->lVal));

        if(m_pMsgrList)
            bRet = m_pMsgrList->EventLogonResult(pDispParams->rgvarg->lVal);
        break;

    case DISPID_ONUSERFRIENDLYNAMECHANGERESULT :
        _ASSERTE(pDispParams->cArgs == 3);
        _ASSERTE(pDispParams->rgvarg[2].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_DISPATCH);

        //if(lLocalState >= BIMSTATE_LOCAL_FINDING_SERVER)
        //    break;

        hr = pDispParams->rgvarg[1].pdispVal->QueryInterface(IID_IBasicIMUser, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if(m_pMsgrList)
                bRet = m_pMsgrList->EventUserNameChanged(spUser);
        }

        break;

    case DISPID_ONLOGOFF:
        if(m_pMsgrList)
            bRet = m_pMsgrList->EventLogoff();
        break;
        
    case DISPID_ONAPPSHUTDOWN:
        if(m_pMsgrList)
            bRet = m_pMsgrList->EventAppShutdown();
        break;

    case DISPID_ONLISTADDRESULT:
        // we should have two parameter, HRESULT, and the pMsgrUser
        //

        // WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
        // The parameters are inversed. This means that the las parameter in the
        // prototype of the function is the first one in the array received, and so on

        _ASSERTE(pDispParams->cArgs == 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_DISPATCH);

        hrRet = V_I4(&pDispParams->rgvarg[1]);
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IBasicIMUser, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if( SUCCEEDED(hrRet) )
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was added sucessfully."));

                if(m_pMsgrList)
                    bRet = m_pMsgrList->EventUserAdded(spUser);
            }
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("QueryInterface for IID_IBasicIMUser failed"));
        }

        break;

    case DISPID_ONLISTREMOVERESULT:
        // we should have two parameter, HRESULT, and the pMsgrUser
        //
        _ASSERTE(pDispParams->cArgs == 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_DISPATCH);

        hrRet = V_I4(&pDispParams->rgvarg[1]);
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IBasicIMUser, (LPVOID *)&spUser);

        if (SUCCEEDED(hr))
        {
            if( SUCCEEDED(hrRet) )
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was removed sucessfully."));
                if(m_pMsgrList)
                    bRet = m_pMsgrList->EventUserRemoved(spUser);
            }
            else
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was not removed due to error %s."), g_GetErrorString(hrRet));
            }
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("QueryInterface for IID_IBasicIMUser failed"));
        }

        break;

    case DISPID_ONUSERSTATECHANGED:
        //we should only have two parameters, the previousState and the pMsgrUser 
        ASSERT(pDispParams->cArgs == 2);
        ASSERT(pDispParams->rgvarg[1].vt == VT_DISPATCH);
        ASSERT(pDispParams->rgvarg[0].vt == VT_I4);

        // if(lLocalState >= BIMSTATE_LOCAL_FINDING_SERVER)
        //    break;

        hr = pDispParams->rgvarg[1].pdispVal->QueryInterface(IID_IBasicIMUser, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if(m_pMsgrList)
                bRet = m_pMsgrList->EventUserStateChanged(spUser);
        }

        break;

    case DISPID_ONLOCALSTATECHANGERESULT:
        //we should only have two parameters, hr and the LocalState
#if 0
        _ASSERTE(pDispParams->cArgs >== 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_I4);
#endif // 0
        // lLocalState = pDispParams->rgvarg[0].lVal;
        if(m_pMsgrList)
            bRet = m_pMsgrList->EventLocalStateChanged(((BIMSTATE) pDispParams->rgvarg[0].lVal));
        break;
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\blhost.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//
// BLHost.cpp - CBLHost implementation
/////////////////////////////////////////////////////////////////////////////
#include "pch.hxx"
#include <shlobj.h>
#include <shlobjp.h>
#include <windowsx.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <ieguidp.h> 
#include <mshtml.h>
#include <mshtmdid.h>
#include <ExDispID.h>

#include "bactrl.h"
#include "baprop.h"
#include "baui.h"
#include "msoert.h"

#include "BLHost.h"
#include "hotlinks.h"
#include "Guid.h"
#include "resource.h"

// Insert your server name 
#define STARTUP_URL "http://localhost/BlFrame.htm"
#define SEARCH_PANE_INDICATOR "#_mysearch"

const int c_cxBorder     = 0;
const int c_cyBorder     = 0;
const int c_cxTextBorder = 4;
const int c_cyTextBorder = 2;
const int c_cyClose      = 3;
const int c_cySplit      = 4;
const int c_cxSplit      = 3;
const int c_cxTextSpace  = 1;
const int c_cxTriangle   = 14;
const int c_cyIEDelta    = 5;

// --------------------------------------------------------------------------------
// SAFECAST - Insures that a cast is valid, otherwise it won't compile
// --------------------------------------------------------------------------------
#define SAFECAST(_src, _type) (((_type)(_src)==(_src)?0:0), (_type)(_src))

LRESULT CALLBACK MainWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

HMENU LoadPopupMenu(UINT id);
HRESULT MenuUtil_EnablePopupMenu(HMENU hPopup, CIEMsgAb* pTarget);

static const TBBUTTON c_tbIECont[] =
{
    {  I_IMAGENONE, ID_CONT_FILE,       TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_WHOLEDROPDOWN | BTNS_SHOWTEXT, {0,0}, 0, 0 },
    {  I_IMAGENONE, ID_SHOWALLCONTACT, TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_DROPDOWN | BTNS_SHOWTEXT, {0, 0}, 0, 1}
};



CBLHost::CBLHost()
   : _cRef(1),
     _hwndParent(NULL),
     m_hWnd(NULL),
     m_hwndContact(NULL),
     _dwViewMode(0),
     _dwBandID(0),
     _dwWBCookie(0), 
     _pSite(NULL), 
     m_pUnkSite(NULL)
{
    HDC         hdc;

    InterlockedIncrement(&g_cDllRefCount);
    m_pIMsgrAB = NULL;
    m_hbr3DFace = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
    m_hbrStaticText = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    m_hbr3DHighFace = CreateSolidBrush(GetSysColor(COLOR_3DLIGHT));
    LOGFONT     lf;
    // Figure out which font to use
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, FALSE);

    // Create the fonts
    m_hFont = CreateFontIndirect(&lf);
    lf.lfWeight = FW_BOLD;
    m_hBoldFont = CreateFontIndirect(&lf);
    lf.lfUnderline = (BYTE) TRUE;
    m_hUnderlineFont = CreateFontIndirect(&lf);

    m_cyTitleBar = 32;
    m_fHighlightIndicator = FALSE;
    m_fHighlightPressed = FALSE;
    m_fButtonPressed = FALSE;
    m_fViewMenuPressed = FALSE;
    m_fButtonHighLight = FALSE;
    m_fShowLoginPart = FALSE;
    m_fStateChange = FALSE;
    m_TextHeight = 0;
    ZeroMemory(&m_rcTitleButton, sizeof(RECT));
    ZeroMemory(&m_rcTextButton, sizeof(RECT));
    m_hWndLogin = NULL;
    // m_hWndClick = NULL;
    m_fStrsAdded = FALSE;
    m_lStrOffset = 0;

    // Link colors
    if(!LookupLinkColors(&m_clrLink, NULL))
        m_clrLink = 0;
    if(!LookupLinkColors(NULL, &m_clrBack))
        m_clrBack = RGB(255, 255, 255);
}

CBLHost::~CBLHost()
{
   Cleanup();
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::QueryInterface()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
   *ppvObject= NULL;

   if (IsEqualIID(riid, IID_IUnknown))
   {
      *ppvObject = this;
   }
   else if (IsEqualIID(riid, IID_IOleWindow) || IsEqualIID(riid, IID_IDockingWindow))
   {
      *ppvObject = static_cast<IDockingWindow*>(this);
   }
   else if (IsEqualIID(riid, IID_IInputObject))
   {
      *ppvObject = static_cast<IInputObject*>(this);
   }   
   else if (IsEqualIID(riid, IID_IObjectWithSite))
   {
      *ppvObject = static_cast<IObjectWithSite*>(this);
   }   
   else if (IsEqualIID(riid, IID_IDeskBand))
   {
      *ppvObject = static_cast<IDeskBand*>(this);
   }   
   else if (IsEqualIID(riid, IID_IPersist))
   {
      *ppvObject = static_cast<IPersist*>(this);
   }   
   else if (IsEqualIID(riid, IID_IPersistStream))
   {
      *ppvObject = static_cast<IPersistStream*>(this);  
   }   
   else if (IsEqualIID(riid, IID_IContextMenu))
   {
      *ppvObject = static_cast<IContextMenu*>(this);
   }   
   else if (IsEqualIID(riid, IID_IOleClientSite))
   {
      *ppvObject = static_cast<IOleClientSite*>(this);
   }   
   else if (IsEqualIID(riid, IID_IOleInPlaceSite))
   {
      *ppvObject = static_cast<IOleInPlaceSite*>(this);
   }   
   else if (IsEqualIID(riid, IID_IOleControlSite))
   {
      *ppvObject = static_cast<IOleControlSite*>(this);
   }   
   else if (IsEqualIID(riid, IID_IOleCommandTarget))
   {
      *ppvObject = static_cast<IOleCommandTarget*>(this);
   }   
   else if (IsEqualIID(riid, IID_IDispatch) || IsEqualIID(riid, DIID_DWebBrowserEvents2))
   {
      *ppvObject = static_cast<IDispatch*>(this);
   }   

   if (*ppvObject)
   {
      static_cast<LPUNKNOWN>(*ppvObject)->AddRef();
      return S_OK;
   }

   return E_NOINTERFACE;
}                                             

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::AddRef()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CBLHost::AddRef()
{
   return (ULONG)InterlockedIncrement(&_cRef);
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::Release()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CBLHost::Release()
{
   if (0 == InterlockedDecrement(&_cRef))
   {
      delete this;
      return 0;
   }
   
   return (ULONG)_cRef;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleWindow Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetWindow()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetWindow(HWND *phwnd)
{
   *phwnd = m_hWnd;
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::ContextSensitiveHelp()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::ContextSensitiveHelp(BOOL fEnterMode)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IDockingWindow Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::ShowDW()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::ShowDW(BOOL fShow)
{
   if (m_hWnd)
   {
      //
      // Hide or show the window depending on
      // the value of the fShow parameter.
      //
      if (fShow)
         ShowWindow(m_hWnd, SW_SHOW);
      else
         ShowWindow(m_hWnd, SW_HIDE);
   }

   AddButtons(fShow);
   return S_OK;
}


void CBLHost::UpdateButtonArray(TBBUTTON *ptbDst, const TBBUTTON *ptbSrc, int ctb, LONG_PTR lStrOffset)
{
    memcpy(ptbDst, ptbSrc, ctb*sizeof(TBBUTTON));
    if (lStrOffset == -1)
    {
        // handle failure case
        for (int i = 0; i < ctb; i++)
            ptbDst[i].iString = 0;
    }
    else
    {
        for (int i = 0; i < ctb; i++)
            ptbDst[i].iString += lStrOffset;
    }
}

void CBLHost::AddButtons(BOOL fAdd)
{
    IExplorerToolbar* piet;

    _ASSERT(m_pUnkSite);

    if (SUCCEEDED(m_pUnkSite->QueryInterface(IID_IExplorerToolbar, (void**)&piet)))
    {
        if (fAdd)
        {
            piet->SetCommandTarget((IUnknown*)SAFECAST(this, IOleCommandTarget*), &CLSID_BLHost, 0);
            if (!m_fStrsAdded)
            {
                LONG_PTR   cbOffset;
                piet->AddString(&CLSID_BLHost, g_hLocRes, idsToolBar, &cbOffset);
                m_lStrOffset = cbOffset;
                m_fStrsAdded = TRUE;
            }
            // piet->SetImageList(&CGID_SearchBand, _himlNormal, _himlHot, NULL); // set image list
            TBBUTTON tbCont[ARRAYSIZE(c_tbIECont)];
            UpdateButtonArray(tbCont, c_tbIECont, ARRAYSIZE(c_tbIECont), m_lStrOffset);

            CIEMsgAb        *pMsgrAb = (CIEMsgAb *) m_pIMsgrAB;
            if(pMsgrAb && pMsgrAb->HideViewMenu())
                tbCont[1].fsState = TBSTATE_HIDDEN;

            piet->AddButtons(&CLSID_BLHost, ARRAYSIZE(tbCont), tbCont);
        }     
        else
            piet->SetCommandTarget(NULL, NULL, 0);

        piet->Release();
    }

}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::CloseDW()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::CloseDW(DWORD dwReserved)
{
   ShowDW(FALSE);

   if (IsWindow(m_hWnd))
      DestroyWindow(m_hWnd);

   m_hWnd = NULL;
   
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::ResizeBorderDW()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkToolbarSite,
                                            BOOL fReserved)
{
   // This method is never called for Band Objects.
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IInputObject Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::UIActivateIO()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
   _ASSERT(m_pIMsgrAB);

   HRESULT hr = E_FAIL;

   if (m_pIMsgrAB)
        hr = ((CIEMsgAb*) m_pIMsgrAB)->UIActivateIO(fActivate, lpMsg);

   return hr;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::HasFocusIO()
//   
//   If this window or one of its decendants has the focus, return S_OK. Return 
//   S_FALSE if we don't have the focus.
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::HasFocusIO(void)
{
   HWND hwnd = GetFocus();
   HWND hwndTmp;
   ((CIEMsgAb *) m_pIMsgrAB)->GetWindow(&hwndTmp);

   // See if the focus has been set to any of the children
   //
   while (hwnd && hwndTmp)
   {
      if (hwnd == hwndTmp)
         return S_OK;

      hwndTmp = ::GetWindow(hwndTmp, GW_CHILD);
   }

   return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::TranslateAcceleratorIO()
//   
//   If the accelerator is translated, return S_OK or S_FALSE otherwise.
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::TranslateAcceleratorIO(LPMSG pMsg)
{
   _RPT0(_CRT_WARN, "TranslateAcceleratorIO\n");

   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IObjectWithSite Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::SetSite()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::SetSite(IUnknown* pUnkSite)
{
    TEXTMETRIC  tm;
    HRESULT hr  = S_OK;
    CIEMsgAb        *pMsgrAb = NULL;

    // Assert(FALSE);
   // If punkSite is not NULL, a new site is being set.
   if (pUnkSite)
   {
      //
      // If a IInputObjectSite pointer is being held, release it.
      //
      if (_pSite)
      {
         _pSite->Release();
         _pSite = NULL;
      }

      if(m_pUnkSite)
         m_pUnkSite->Release();

      m_pUnkSite = pUnkSite;

      // Get the parent window.
      IOleWindow* pOleWindow;
   
      if (SUCCEEDED(pUnkSite->QueryInterface(IID_IOleWindow,
											            (LPVOID*)&pOleWindow)))
      {
         pOleWindow->GetWindow(&_hwndParent);
         pOleWindow->Release();
      }

      _ASSERT(_hwndParent);
      if (!_hwndParent)
         return E_FAIL;

      if (!RegisterAndCreateWindow())
         return E_FAIL;

      // Get and keep the IInputObjectSite pointer.

       hr = pUnkSite->QueryInterface(IID_IInputObjectSite,
											           (LPVOID*)&_pSite);
      _ASSERT(SUCCEEDED(hr));
      
      hr = CreateIEMsgAbCtrl(&m_pIMsgrAB);

/*            // Create and initialize the WebBrowser control that we are hosting.
      hr = CoCreateInstance(CLSID_MsgrAb, NULL, CLSCTX_INPROC,
                            IID_IMsgrAb, (LPVOID*)&m_pMsgrAB);

      // Get the rectangle of the client area*/

      _ASSERT(m_hWnd);

    // Get the metrics of this font
    HDC hdc = GetDC(m_hWnd);
    SelectFont(hdc, m_hFont);
    GetTextMetrics(hdc, &tm);

    if(!ANSI_AthLoadString(idsTitleMenu, m_szTitleMenu, ARRAYSIZE(m_szTitleMenu)))
        m_szTitleMenu[0] = '\0';

    if(!ANSI_AthLoadString(idsButtonText, m_szButtonText, ARRAYSIZE(m_szButtonText)))
        m_szButtonText[0] = '\0';

//    if(!AthLoadString(idsLoginText, m_szInstallText, ARRAYSIZE(m_szInstallText)))
//        m_szInstallText[0] = '\0';
    if(!AthLoadString(idsClickText, m_wszClickText, ARRAYSIZE(m_wszClickText)))
        m_wszClickText[0] = L'\0';
    if(!AthLoadString(idsAttemptText, m_wszAttemptText, ARRAYSIZE(m_wszAttemptText)))
        m_wszAttemptText[0] = L'\0';
    if(!AthLoadString(idsWaitText, m_wszWaitText, ARRAYSIZE(m_wszWaitText)))
        m_wszWaitText[0] = L'\0';

    // Calculate the height
    m_cyTitleBar = 0; //tm.tmHeight + (2 * c_cyBorder) + (2 * c_cyTextBorder) + c_cyIEDelta;
    m_TextHeight = tm.tmHeight;

    pMsgrAb = (CIEMsgAb *) m_pIMsgrAB;

// Calculate the height
    RECT rc = {2 * c_cxBorder, 2 * c_cyBorder, 0, m_cyTitleBar - c_cyBorder};
    SIZE s;
    GetTextExtentPoint32(hdc, m_szTitleMenu, lstrlen(m_szTitleMenu), &s);
    m_rcTitleButton = rc;
    m_rcTitleButton.right = c_cxTriangle  + (2 * c_cxTextBorder) + s.cx + (2 * c_cxBorder);

    RECT rcClient = { 0, 0, 0/*100*/, 0/*500*/ };

    GetClientRect(m_hWnd, &rcClient);
    m_hwndContact = pMsgrAb->CreateControlWindow(m_hWnd, rcClient);
    // m_pIMsgrAB->Release(); // CreateControl.. add reference

    // Calculate "Show All" button rect
    m_rcTextButton.left = m_rcTitleButton.right + c_cxTextSpace;
    m_rcTextButton.top = m_rcTitleButton.top; 
    m_rcTextButton.bottom = m_rcTitleButton.bottom; 
    GetTextExtentPoint32(hdc, m_szButtonText, lstrlen(m_szButtonText), &s);
    m_rcTextButton.right = c_cxTriangle + m_rcTextButton.left + (2 * c_cxTextBorder) + s.cx + (2 * c_cxBorder);


    m_hWndLogin = CreateWindow(_T("Button"), _T("_Login"), 
                                     WS_CHILD | WS_TABSTOP | WS_CLIPSIBLINGS |  BS_OWNERDRAW /*| ES_MULTILINE | ES_READONLY*/,
                                     0, 0, 0, 0, m_hWnd, (HMENU) ID_LOGIN_MESSENGER, g_hLocRes, NULL);
    SendMessage(m_hWndLogin, WM_SETFONT, (WPARAM) m_hUnderlineFont, MAKELPARAM(TRUE, 0));
/*     SendMessage(m_hWndLogin, WM_SETFONT, (WPARAM) m_hFont, MAKELPARAM(TRUE, 0));

    m_hWndClick = CreateWindow(_T("Button"), _T("_Click"), 
                                     WS_CHILD | WS_TABSTOP | WS_CLIPSIBLINGS | BS_OWNERDRAW,
                                     0, 0, 0, 0, m_hWnd, (HMENU) ID_LOGIN_MESSENGER, g_hLocRes, NULL);
    SendMessage(m_hWndClick, WM_SETFONT, (WPARAM) m_hUnderlineFont, MAKELPARAM(TRUE, 0)); */
    }
    if(pMsgrAb)
        hr = pMsgrAb->SetSite(pUnkSite);

   return hr;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetSite()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetSite(REFIID riid, void** ppvSite)
{
   *ppvSite = NULL;

   if (_pSite)
      return _pSite->QueryInterface(riid, ppvSite);
   return E_FAIL;
}

///////////////////////////////////////////////////////////////////////////
//
// IDeskBand implementation
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetBandInfo()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetBandInfo(DWORD dwBandID,
										 DWORD dwViewMode,
										 DESKBANDINFO* pdbi)
{
   if (pdbi)
   {
      _dwBandID = dwBandID;
      _dwViewMode = dwViewMode;

      if (pdbi->dwMask & DBIM_MINSIZE)
      {
         pdbi->ptMinSize.x = MIN_SIZE_X;
         pdbi->ptMinSize.y = MIN_SIZE_Y;
      }

      if (pdbi->dwMask & DBIM_MAXSIZE)
      {
         pdbi->ptMaxSize.x = -1;
         pdbi->ptMaxSize.y = -1;
      }

      if (pdbi->dwMask & DBIM_INTEGRAL)
      {
         pdbi->ptIntegral.x = 1;
         pdbi->ptIntegral.y = 1;
      }

      if (pdbi->dwMask & DBIM_ACTUAL)
      {
         pdbi->ptActual.x = 0;
         pdbi->ptActual.y = 0;
      }

      if (pdbi->dwMask & DBIM_TITLE)
      { 
        if(!AthLoadString(idsButtontext, pdbi->wszTitle, 256))
            pdbi->wszTitle[0] = L'\0';
      }

      if (pdbi->dwMask & DBIM_MODEFLAGS)
         pdbi->dwModeFlags = DBIMF_VARIABLEHEIGHT;
   
      if (pdbi->dwMask & DBIM_BKCOLOR)
      {
         // Use the default background color by removing this flag.
         pdbi->dwMask &= ~DBIM_BKCOLOR;
      }

      return S_OK;
   }

   return E_INVALIDARG;
}

///////////////////////////////////////////////////////////////////////////
//
// IPersistStream Methods
// 
// This is only supported to allow the desk band to be dropped on the 
// desktop and to prevent multiple instances of the desk band from showing 
// up in the context menu. This desk band doesn't actually persist any data.
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetClassID()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetClassID(LPCLSID pClassID)
{
   *pClassID = CLSID_BLHost;
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::IsDirty()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::IsDirty(void)
{
   return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::Load()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::Load(LPSTREAM pStream)
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::Save()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::Save(LPSTREAM pStream, BOOL fClearDirty)
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetSizeMax()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetSizeMax(ULARGE_INTEGER *pul)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IContextMenu Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::QueryContextMenu()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::QueryContextMenu(HMENU hmenu,
                                              UINT indexMenu, 
                                              UINT idCmdFirst,
                                              UINT idCmdLast, 
                                              UINT uFlags)
{
   if (!(CMF_DEFAULTONLY & uFlags))
   {
      InsertMenu(hmenu, indexMenu, MF_STRING | MF_BYPOSITION,
                 idCmdFirst + IDM_REFRESH, TEXT("&Refresh"));

      InsertMenu(hmenu, indexMenu + 1, MF_STRING | MF_BYPOSITION,
                 idCmdFirst + IDM_OPENINWINDOW, TEXT("&Open in Window"));

      return MAKE_HRESULT(SEVERITY_SUCCESS, 0,
                          USHORT(IDM_OPENINWINDOW + 1));
   }

   return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(0));
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::InvokeCommand()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetCommandString()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetCommandString(UINT_PTR idCmd, UINT uType, UINT* pwReserved,
                                              LPSTR pszName, UINT cchMax)
{
   HRESULT hr = E_INVALIDARG;

   switch(uType)
   {
      case GCS_HELPTEXT:
         switch(idCmd)
         {
            case IDM_REFRESH:
               StrCpyN(pszName, TEXT("Refreshes the search window"), cchMax);
               hr = NOERROR;
               break;

            case IDM_OPENINWINDOW:
               StrCpyN(pszName, TEXT("Open a new instance of the Internet Explorer window"), cchMax);
               hr = NOERROR;
               break;
         }

         break;
   
      case GCS_VERB:
         switch(idCmd)
         {
            case IDM_REFRESH:
               StrCpyN(pszName, TEXT("Refresh"), cchMax);
               hr = NOERROR;
               break;

            case IDM_OPENINWINDOW:
               StrCpyN(pszName, TEXT("Open in Window"), cchMax);
               hr = NOERROR;
               break;
         }

         break;
   
      case GCS_VALIDATE:
         hr = NOERROR;
         break;
   }

   return hr;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleClientSite Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::SaveObject()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::SaveObject()
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetMoniker()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppmk)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetContainer()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetContainer(LPOLECONTAINER* ppContainer)
{
    *ppContainer = NULL;       
    return E_NOINTERFACE;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::ShowObject()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::ShowObject()
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnShowWindow()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnShowWindow(BOOL fShow)
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::RequestNewObjectLayout()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::RequestNewObjectLayout()
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleInPlaceSite Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::CanInPlaceActivate()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::CanInPlaceActivate(void)
{
    return S_OK;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnInPlaceActivate()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnInPlaceActivate(void)
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnUIActivate()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnUIActivate(void)
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetWindowContext()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetWindowContext(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppIIPUIWin, 
                                              LPRECT lprcPosRect, LPRECT lprcClipRect,
                                              LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
   *ppFrame = NULL;
   *ppIIPUIWin = NULL;

   GetClientRect(m_hWnd, lprcPosRect);
   GetClientRect(m_hWnd, lprcClipRect);

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::Scroll()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::Scroll(SIZE scrollExtent)
{
    return E_NOTIMPL;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnUIDeactivate()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnUIDeactivate(BOOL fUndoable)
{
    
    return E_NOTIMPL;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnInPlaceDeactivate()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnInPlaceDeactivate(void)
{
    return E_NOTIMPL;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::DiscardUndoState()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::DiscardUndoState(void)
{
    return E_NOTIMPL;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::DeactivateAndUndo()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::DeactivateAndUndo(void)
{
    return E_NOTIMPL;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnPosRectChange()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnPosRectChange(LPCRECT lprcPosRect) 
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleControlSite Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnControlInfoChanged()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnControlInfoChanged(void)
{
   return E_NOTIMPL;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::LockInPlaceActive()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::LockInPlaceActive(BOOL fLock)
{
   return E_NOTIMPL;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetExtendedControl()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetExtendedControl(LPDISPATCH* ppDisp)
{
   return E_NOTIMPL;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::TransformCoords()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::TransformCoords(POINTL* pPtlHimetric, POINTF* pPtfContainer, DWORD dwFlags)
{
   return E_NOTIMPL;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::TranslateAccelerator()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::TranslateAccelerator(LPMSG lpMsg, DWORD grfModifiers)
{
   return E_NOTIMPL;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnFocus()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnFocus(BOOL fGotFocus)
{
   _RPT1(_CRT_WARN, "OnFocus: %s\n", fGotFocus ? "True" : "False");

   if (_pSite)
      _pSite->OnFocusChangeIS(static_cast<IInputObject*>(this), fGotFocus);

   return S_OK;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::ShowPropertyFrame()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::ShowPropertyFrame(void)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// Private Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetTypeInfoCount()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetTypeInfoCount(UINT* pctinfo)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetTypeInfo()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetIDsOfNames()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                                           LCID lcid,DISPID* rgDispId)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::Invoke()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
                                    DISPPARAMS* pDispParams, VARIANT* pVarResult,
                                    EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
   if (IID_NULL != riid)
      return DISP_E_UNKNOWNINTERFACE;

   if (!pDispParams)
      return DISP_E_PARAMNOTOPTIONAL;

   static bool sbIsAnchor = false;

   switch (dispIdMember)
   {
      //
      // The parameters for this DISPID:
      // [0]: New status bar text - VT_BSTR
      //
      case DISPID_STATUSTEXTCHANGE:
         if (pDispParams->cArgs && pDispParams->rgvarg[0].vt != VT_BSTR)
         {
            *puArgErr = 0;
            return DISP_E_TYPEMISMATCH;
         }

         break;

      default:
         return DISP_E_MEMBERNOTFOUND;
   }

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
// Private Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::WndProc()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK MainWndProc(HWND hWnd, UINT uMessage, 
                             WPARAM wParam, LPARAM lParam)
{
	if (uMessage == WM_NCCREATE)
	{
		LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
		SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)lpcs->lpCreateParams);
	}

	CBLHost* pThis = reinterpret_cast<CBLHost*>(
                                  GetWindowLongPtr(hWnd, GWLP_USERDATA));
	if (pThis)
		return pThis->WndProc(hWnd, uMessage, wParam, lParam);
	else
		return DefWindowProc(hWnd, uMessage, wParam, lParam);
}

LRESULT CBLHost::WndProc(HWND hWnd, UINT uMessage, 
                         WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
    case WM_NCCREATE:
        {
            // Set the window handle
            m_hWnd = hWnd;
        }
        break;
        
    case WM_PAINT:
        return OnPaint();
        
    case WM_MOUSEMOVE:
        return OnMouseMove(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        
    case WM_TIMER:
        OnTimer((UINT) wParam);
        return(0);
        
    case WM_LBUTTONDOWN:
        OnLButtonDown(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        return(0);

    case WM_LBUTTONUP:
        OnLButtonUp(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        return(0);

    case WM_COMMAND:
        return OnCommand(wParam, lParam);
        
    case WM_SETFOCUS:
        return OnSetFocus();
        
    case WM_KILLFOCUS:
        return OnKillFocus();
        
    case WM_DRAWITEM:
        return OnDrawItem(wParam, lParam);

    case WM_SIZE:
        return OnSize();
        
//    case WM_DESTROY:
        //
        // If you decided to implement the Open in Window context
        // menu item and you are using Internet Explorer 5,
        // be careful.  WM_DESTROY will get sent to the band for
        // each window.  You'll want to keep a count of the number
        // of windows open and only call Cleanup() if WM_DESTROY
        // is meant for the first window.
        //
        // Cleanup();
        
//        break;
    case WM_LOCAL_STATUS_CHANGED:
        m_fStateChange = TRUE;
        return OnSize();
    case WM_MSGR_LOGRESULT:
    case WM_MSGR_LOGOFF:
    case WM_MSGR_SHUTDOWN:
        m_fStateChange = FALSE;
        return OnSize();

        return 0;
    }
    return DefWindowProc(hWnd, uMessage, wParam, lParam);
}

LRESULT CBLHost::OnDrawItem(WPARAM wParam, LPARAM lParam)
{
    LPDRAWITEMSTRUCT pdis = (LPDRAWITEMSTRUCT) lParam;
    RECT rc = pdis->rcItem;
    WCHAR  wszStr[RESSTRMAX];
    HBRUSH hbr3DFace = NULL;
    
    StrCpyNW(wszStr, m_fStateChange ? m_wszWaitText : m_wszClickText, ARRAYSIZE(wszStr));

    hbr3DFace = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    FillRect(pdis->hDC, &(pdis->rcItem), hbr3DFace);
    SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
    DeleteObject(hbr3DFace);

    if(!m_fStateChange)
    {
        SetTextColor(pdis->hDC, m_clrLink);
        SelectFont(pdis->hDC, m_hUnderlineFont);
    }
    else
        SelectFont(pdis->hDC, m_hBoldFont);

    DrawTextW(pdis->hDC, wszStr, -1, &rc, DT_WORDBREAK | DT_VCENTER | DT_CENTER );
    return 0;
}


void CBLHost::OnLButtonUp(int x, int y, UINT keyFlags)
{
#if 0
    POINT pt = {x, y};

    if(PtInRect(&m_rcTextButton, pt))
    {
        ((CIEMsgAb*)m_pIMsgrAB)->Exec(NULL, ID_SHOWALLCONTACT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        m_fButtonPressed = FALSE;
        InvalidateRect(m_hWnd, &m_rcTextButton, TRUE);
    }
#endif
}

void CBLHost::OnLButtonDown(int x, int y, UINT keyFlags)
{
}
void CBLHost::OnTimer(UINT id)
{
#if 0
    // RECT rcClient;
    POINT pt;
    DWORD dw;

    dw = GetMessagePos();
    pt.x = LOWORD(dw);
    pt.y = HIWORD(dw);
    ScreenToClient(m_hWnd, &pt);

    if (id == IDT_PANETIMER)
    {
       // GetClientRect(m_hWnd, &rcClient);

        // No need to handle mouse in client area, OnMouseMove will catch this. We
		// only need to catch the mouse moving out of the client area.
		if (!(PtInRect(&m_rcTitleButton, pt) || PtInRect(&m_rcTextButton, pt)) && !m_fHighlightPressed)
		{
			KillTimer(m_hWnd, IDT_PANETIMER);
			m_fHighlightIndicator = FALSE;
            m_fButtonHighLight = FALSE;
            m_fButtonPressed = FALSE;
            InvalidateRect(m_hWnd, &m_rcTitleButton, TRUE);
            InvalidateRect(m_hWnd, &m_rcTextButton, TRUE);
		}
	}
#endif
}


LRESULT CBLHost::OnMouseMove(int x, int y, UINT keyFlags)
{
#if 0
    POINT pt = {x, y};

    if (m_fHighlightIndicator != PtInRect(&m_rcTitleButton, pt))
    {
        m_fHighlightIndicator = !m_fHighlightIndicator;
        if(m_fHighlightIndicator)
            m_fButtonHighLight = FALSE;

        InvalidateRect(m_hWnd, &m_rcTitleButton, TRUE);
        InvalidateRect(m_hWnd, &m_rcTextButton, TRUE);

        if (m_fHighlightIndicator)       
            SetTimer(m_hWnd, IDT_PANETIMER, ELAPSE_MOUSEOVERCHECK, NULL);
        else
            KillTimer(m_hWnd, IDT_PANETIMER);
    }
    else if (m_fButtonHighLight != PtInRect(&m_rcTextButton, pt))
    {
        m_fButtonHighLight = !m_fButtonHighLight;
        if(m_fButtonHighLight)
            m_fHighlightIndicator = FALSE;

        InvalidateRect(m_hWnd, &m_rcTextButton, TRUE);
        InvalidateRect(m_hWnd, &m_rcTitleButton, TRUE);

        if (m_fButtonHighLight)
            SetTimer(m_hWnd, IDT_PANETIMER, ELAPSE_MOUSEOVERCHECK, NULL);
        else
            KillTimer(m_hWnd, IDT_PANETIMER);
    }
#endif 
    return(S_OK);
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnPaint()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CBLHost::OnPaint(void)
{
    PAINTSTRUCT ps;
    
    // Start painting
    HDC hdc = BeginPaint(m_hWnd, &ps);
    SelectFont(hdc, m_hFont);   
    EndPaint(m_hWnd, &ps);  

    return 0;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnCommand()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CBLHost::OnCommand(WPARAM wParam, LPARAM lParam)
{
    _RPT0(_CRT_WARN, "CBLHost::OnCommand\n");
    UINT id = LOWORD(wParam); 

    if(id == ID_LOGIN_MESSENGER && !((CIEMsgAb*)m_pIMsgrAB)->IsMessengerInstalled())
    {
        // redirect browser pane
        IServiceProvider* psp;

        // if invoked from within a browser reuse it, else open a new browser
        HRESULT hres = IUnknown_QueryService(m_pUnkSite, SID_STopLevelBrowser, IID_IServiceProvider, (LPVOID*)&psp);
        if (SUCCEEDED(hres))
        {
            IWebBrowser2*     pwb2 = NULL;

            hres = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID*)&pwb2);
            psp->Release();
    
            if (SUCCEEDED(hres))
            {
                // we don't care about the error here
                VARIANT varEmpty = {0};

                pwb2->Navigate(L"http://www.microsoft.com/isapi/redir.dll?prd=ie&Plcid=0x0409&Pver=6.0&Clcid=0x0409&Ar=getmms", &varEmpty, &varEmpty, &varEmpty, &varEmpty);
                pwb2->Release();
            }
        }
        return(hres);
    }
    if((id == ID_LOGIN_MESSENGER) && m_fStateChange)
        return 0; // id = ID_LOGOFF_MESSENGER;

    if(m_pIMsgrAB)
        ((CIEMsgAb*)m_pIMsgrAB)->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
    return 0;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::FocusChange()
//   
///////////////////////////////////////////////////////////////////////////

void CBLHost::FocusChange(BOOL fFocus)
{
   _RPT1(_CRT_WARN, "FocusChange: %s\n", fFocus ? "True" : "False");

   // Inform the input object site that the focus has changed
   //
   if (_pSite)
      _pSite->OnFocusChangeIS(static_cast<IDockingWindow*>(this), fFocus);
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::SetFocus()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CBLHost::OnSetFocus(void)
{
   _RPT0(_CRT_WARN, "OnSetFocus\n");

   FocusChange(TRUE);
   return 0;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnKillFocus()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CBLHost::OnKillFocus(void)
{
   _RPT0(_CRT_WARN, "OnKillFocus\n");

   FocusChange(FALSE);
   return 0;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnSize()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CBLHost::OnSize(void)
{
    HRESULT hr = E_FAIL;
    
    if (m_pIMsgrAB)
    {
        RECT rcClient;
        HWND hWndTmp = NULL;
        GetClientRect(m_hWnd, &rcClient);
        
        CIEMsgAb        *pMsgrAb = (CIEMsgAb *) m_pIMsgrAB;
        if(pMsgrAb)
        {
            pMsgrAb->GetWindow(&hWndTmp);
            m_fShowLoginPart = !pMsgrAb->DontShowMessenger();
            
            if(m_fShowLoginPart && m_hWndLogin /* && m_hWndClick*/)
            {
                SetWindowPos(m_hWndLogin, NULL, rcClient.left, m_cyTitleBar, rcClient.right, 
                    m_TextHeight*2,
                    SWP_NOACTIVATE | SWP_NOZORDER);
                
                SendMessage(m_hWndLogin, WM_SETFONT, (WPARAM) m_hUnderlineFont, MAKELPARAM(TRUE, 0));
                SetWindowTextW(m_hWndLogin, m_fStateChange ? m_wszAttemptText : m_wszClickText);
                
                SetWindowPos(hWndTmp, NULL, 0, m_cyTitleBar + m_TextHeight*2, rcClient.right - rcClient.left, 
                    rcClient.bottom - rcClient.top - m_cyTitleBar - m_TextHeight*2, 
                    SWP_NOACTIVATE | SWP_NOZORDER);
                ShowWindow(m_hWndLogin, SW_SHOW);
                ShowWindow(hWndTmp, SW_SHOW);

            }
            else
            {
               
                if(m_hWndLogin)
                    ShowWindow(m_hWndLogin, SW_HIDE);
                
                
                SetWindowPos(hWndTmp, NULL, 0, m_cyTitleBar, rcClient.right - rcClient.left, 
                    rcClient.bottom - rcClient.top - m_cyTitleBar, 
                    SWP_NOACTIVATE | SWP_NOZORDER);
                ShowWindow(hWndTmp, SW_SHOW);
            }
        }
    }
    
    return hr;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::RegisterAndCreateWindow()
//   
///////////////////////////////////////////////////////////////////////////

BOOL CBLHost::RegisterAndCreateWindow(void)
{
    // If the window doesn't exist yet, create it now.
    if (!m_hWnd)
    {
        // Can't create a child window without a parent.
        if (!_hwndParent)
            return FALSE;
        
        // If the window class has not been registered, then do so.
        WNDCLASS wc;
        if (!GetClassInfo(g_hLocRes, EB_CLASS_NAME, &wc))
        {
            ZeroMemory(&wc, sizeof(wc));
            wc.style          = CS_HREDRAW | CS_VREDRAW | CS_GLOBALCLASS;
            wc.lpfnWndProc    = MainWndProc;
            wc.cbClsExtra     = 0;
            wc.cbWndExtra     = 0;
            wc.hInstance      = g_hLocRes;
            wc.hIcon          = NULL;
            wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
            wc.hbrBackground  = NULL;
            wc.lpszMenuName   = NULL;
            wc.lpszClassName  = EB_CLASS_NAME;
            
            if (!RegisterClass(&wc))
            {
                // If RegisterClass fails, CreateWindow below will fail.
            }
        }
        
        // RECT rc;
        // GetClientRect(m_hWnd, &rc);
        
        // Create the window. The WndProc will set m_hWnd.
        CreateWindowEx(0,
            EB_CLASS_NAME,
            NULL,
            WS_CHILD | WS_CLIPSIBLINGS, // No border
            0, // rc.left,
            0, // rc.top,
            0, // rc.right - rc.left,
            0, // rc.bottom - rc.top,
            _hwndParent,
            NULL,
            g_hLocRes,
            (LPVOID)this);
    }
    
    return (NULL != m_hWnd);
}

///////////////////////////////////////////////////////////////////////////
//
// CBLHost::GetConnectionPoint()
//
///////////////////////////////////////////////////////////////////////////

HRESULT CBLHost::GetConnectionPoint(LPUNKNOWN pUnk, REFIID riid, LPCONNECTIONPOINT* ppCP)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// CBLHost::Cleanup()
//
// Description: This method releases all interfaces we are holding onto.
//              This has to be done here because Internet Explorer is not
//              releasing all of our interfaces.  Therefore, our ref count
//              never reaches 0 and we never delete ourself.
//
///////////////////////////////////////////////////////////////////////////

void CBLHost::Cleanup(void)
{
    UnregisterClass(EB_CLASS_NAME, g_hLocRes);
    if (m_pIMsgrAB)
    {
        while(m_pIMsgrAB->Release() != 0)
            ;
//        m_pIMsgrAB->Release();
        //      m_pIMsgrAB = NULL;
    }

    if (m_hFont != 0)
        DeleteObject(m_hFont);

    if (m_hUnderlineFont != 0)
        DeleteObject(m_hUnderlineFont);

    if (m_hBoldFont != 0)
        DeleteObject(m_hBoldFont);

    if (m_hbr3DFace)
        DeleteObject(m_hbr3DFace);

    if (m_hbrStaticText)
        DeleteObject(m_hbrStaticText);

    if (m_hbr3DHighFace)
        DeleteObject(m_hbr3DHighFace);

/*    if (_pSite)
    {
        _pSite->Release();
        _pSite = NULL;
    }

    if(m_pUnkSite)
    {
        m_pUnkSite->Release();
        m_pUnkSite = NULL;
    } */

    InterlockedDecrement(&g_cDllRefCount);
}

HRESULT STDMETHODCALLTYPE CBLHost::QueryStatus(const GUID    *pguidCmdGroup, 
                                          ULONG         cCmds, 
                                          OLECMD        *prgCmds, 
                                          OLECMDTEXT    *pCmdText)
{

    prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CBLHost::Exec(const GUID   *pguidCmdGroup, 
                                    DWORD       nCmdID, 
                                    DWORD       nCmdExecOpt, 
                                    VARIANTARG  *pvaIn, 
                                    VARIANTARG  *pvaOut)
{
    UINT  id;
    HMENU hMenu = NULL; 
    POINT pt = {0, 0};

    if(pvaIn)
    {
        pt.x = GET_X_LPARAM(pvaIn->lVal);
        pt.y = GET_Y_LPARAM(pvaIn->lVal) - 2;
    }
    else
        return (S_OK);

    switch (nCmdID)
    {
    case ID_CONT_FILE:
        hMenu = LoadPopupMenu(IDR_BA_TITLE_POPUP);
        MenuUtil_EnablePopupMenu(hMenu, (CIEMsgAb*) m_pIMsgrAB);

        id = TrackPopupMenu(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                              pt.x, pt.y, 0, m_hWnd, NULL);
        if (id)
        {
            ((CIEMsgAb*)m_pIMsgrAB)->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        }

        UpdateWindow(m_hWnd);
        break;

    case ID_SHOWALLCONTACT:
        if(nCmdExecOpt != OLECMDEXECOPT_PROMPTUSER)
            ((CIEMsgAb*)m_pIMsgrAB)->Exec(NULL, ID_SHOWALLCONTACT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        else
        {

            hMenu = LoadPopupMenu(IDR_POPUP_VIEW);
            MenuUtil_EnablePopupMenu(hMenu, (CIEMsgAb*) m_pIMsgrAB);

            id = TrackPopupMenu(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                              pt.x, pt.y, 0, m_hWnd, NULL);
            if (id)
            {
                ((CIEMsgAb*)m_pIMsgrAB)->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
            }
            UpdateWindow(m_hWnd);
        }
        break;

    default:
        break;

    }

    if(hMenu)
    {
        BOOL bMenuDestroyed = DestroyMenu(hMenu);
        _ASSERT(bMenuDestroyed);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\clsfact.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Author: Scott Roberts, Microsoft Developer Support - Internet Client SDK  
//
// Portions of this code were taken from the bandobj sample that comes
// with the Internet Client SDK for Internet Explorer 4.0x
//
//
// ClsFact.cpp - CClassFactory Implementation
/////////////////////////////////////////////////////////////////////////////
#include "pch.hxx"
#include "ClsFact.h"
#include "Guid.h"

///////////////////////////////////////////////////////////////////////////
//
// IClassFactory Methods
//

CClassFactory::CClassFactory(CLSID clsid)
   : m_cRef(1),
     m_clsidObject(clsid)
     
{
   InterlockedIncrement(&g_cDllRefCount);
}

CClassFactory::~CClassFactory()
{
   InterlockedDecrement(&g_cDllRefCount);
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
   *ppvObject = NULL;

   if (IsEqualIID(riid, IID_IUnknown))
      *ppvObject = this;
   else if(IsEqualIID(riid, IID_IClassFactory))
      *ppvObject = static_cast<IClassFactory*>(this);

   if (*ppvObject)
   {
      static_cast<LPUNKNOWN>(*ppvObject)->AddRef();
      return S_OK;
   }

   return E_NOINTERFACE;
}                                             

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
   return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
   if (0 == InterlockedDecrement(&m_cRef))
   {
      delete this;
      return 0;
   }
   
   return m_cRef;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID* ppvObject)
{
   HRESULT hr = E_FAIL;
   LPVOID  pTemp = NULL;

   *ppvObject = NULL;

   if (pUnkOuter != NULL)
      return CLASS_E_NOAGGREGATION;

   // Create the proper object
   if (IsEqualCLSID(m_clsidObject, CLSID_BLHost))
   {
      CBLHost* pBLHost = new CBLHost();

      if (NULL == pBLHost)
         return E_OUTOFMEMORY;
   
      pTemp = pBLHost;
   }
  
   if (pTemp)
   {
      // QI for the requested interface
      hr = (static_cast<LPUNKNOWN>(pTemp))->QueryInterface(riid, ppvObject);

      // Call Release to decement the ref count
      (static_cast<LPUNKNOWN>(pTemp))->Release();
   }

   return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL)
{
   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\clsfact.h ===
/////////////////////////////////////////////////////////////////////////////
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Author: Scott Roberts, Microsoft Developer Support - Internet Client SDK  
//
// Portions of this code were taken from the bandobj sample that comes
// with the Internet Client SDK for Internet Explorer 4.0x
//
//
// ClsFact.h - CClassFactory declaration
/////////////////////////////////////////////////////////////////////////////

#ifndef __ClsFact_h__
#define __ClsFact_h__

#include <windows.h>
#include "Globals.h"
#include "blhost.h"

class CClassFactory : public IClassFactory
{
public:
   CClassFactory(CLSID);
   ~CClassFactory();

   //IUnknown methods
   STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObject);
   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();

   //IClassFactory methods
   STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID* ppvObject);
   STDMETHOD(LockServer)(BOOL fLock);

protected:
   LONG m_cRef;

private:
   CLSID m_clsidObject;
};

#endif   // __ClsFact_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\dispid.h ===
// Dispatch Ids

#ifndef __DISPID_H_
#define __DISPID_H_


#define DISPID_BLVIEW_BASE            1000

#define DISPID_BLVIEW_SERVER          (DISPID_BLVIEW_BASE + 1)
#define DISPID_BLVIEW_FOLDER          (DISPID_BLVIEW_BASE + 2)
#define DISPID_BLVIEW_CONNECT         (DISPID_BLVIEW_BASE + 3)
#define DISPID_BLVIEW_DISCONNECT      (DISPID_BLVIEW_BASE + 4)

#endif // __DISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\clutil.h ===
//****************************************************************************
//
//  BLClient sample for Microsoft Messenger SDK
//
//  Module:     BLClient.exe
//  File:       clUtil.h
//  Content:    Usefull clases for COM and Connection points
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#ifndef _CL_UTIL_H_
#define _CL_UTIL_H_

class CIEMsgAb;
#include <docobj.h>

//****************************************************************************
//
// CLASS RefCount
//
//****************************************************************************

class RefCount
{
private:
   LONG m_cRef;

public:
   RefCount();
   // Virtual destructor defers destruction to destructor of derived class.
   virtual ~RefCount();

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};



//****************************************************************************
//
// CLASS CNotify
//
// Notification sink
//
//****************************************************************************

class CNotify
{
private:
    DWORD  m_dwCookie;
	IUnknown * m_pUnk;
    IConnectionPoint           * m_pcnp;
    IConnectionPointContainer  * m_pcnpcnt;
public:
    CNotify(void);
    ~CNotify();

    HRESULT Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN);
    HRESULT Disconnect(void);

    IUnknown * GetPunk() {return m_pUnk;}
};



//****************************************************************************
//
// CLASS BSTRING
//
//****************************************************************************

class BSTRING
{
private:
	BSTR   m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#ifndef UNICODE
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // #ifndef UNICODE

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}
	inline LPBSTR GetLPBSTR(void);
};

BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		m_bstr = SysAllocString(lpcwString);
		// ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	// This function is intended to be used to set the BSTR value for
	// objects that are initialized to NULL.  It should not be called
	// on objects which already have a non-NULL BSTR.
	// ASSERT(NULL == m_bstr);

	return &m_bstr;
}



//****************************************************************************
//
// CLASS BTSTR
//
//****************************************************************************

class BTSTR
{
private:
	LPTSTR m_psz;

public:
	BTSTR(BSTR bstr);
	~BTSTR();

	// Cast to BSTR
	operator LPTSTR() {return (NULL == m_psz) ? TEXT("<null>") : m_psz;}
};

LPTSTR LPTSTRfromBstr(BSTR bstr);


#endif  // _CL_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\guid.h ===
/////////////////////////////////////////////////////////////////////////////
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Author: Scott Roberts, Microsoft Developer Support - Internet Client SDK  
//
// Portions of this code were taken from the bandobj sample that comes
// with the Internet Client SDK for Internet Explorer 4.0x
//
//
// Guid.h - Private GUID definition.
/////////////////////////////////////////////////////////////////////////////

#ifndef __Guid_h__
#define __Guid_h__

// {864B4D50-3B9A-11d2-B8DB-00C04FA3471C}
DEFINE_GUID(CLSID_BLHost, 
0x864b4d50, 0x3b9a, 0x11d2, 0xb8, 0xdb, 0x0, 0xc0, 0x4f, 0xa3, 0x47, 0x1c);

DEFINE_GUID(CLSID_BlFrameButton, 
0x9239E4EC, 0xC9A6, 0x11d2, 0xA8, 0x44, 0x00, 0xC0, 0x4F, 0x68, 0xD5, 0x38);


DEFINE_GUID(CLSID_MsgrAb,
0x233A9694,0x667E,0x11d1,0x9D,0xFB,0x00,0x60,0x97,0xD5,0x04,0x08);

DEFINE_GUID(IID_IMsgrAb,
0x233A9696,0x667E,0x11d1,0x9D,0xFB,0x00,0x60,0x97,0xD5,0x04,0x08);

#endif // __Guid_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\hotlinks.h ===
// =================================================================================
// H O T L I N K S . H
// =================================================================================
#ifndef __HOTLINKS_H
#define __HOTLINKS_H
#include <wab.h>
#include <wabapi.h>

// We will create a linked list of all selected entries that have an
// email address and then use that to create the recip list for sendmail
typedef struct _RecipList
{
    LPTSTR lpszName;
    LPTSTR lpszEmail;
    LPSBinary lpSB;
    struct _RecipList * lpNext;
} RECIPLIST, * LPRECIPLIST;


BOOL LookupLinkColors(LPCOLORREF pclrLink, LPCOLORREF pclrViewed);
BOOL CheckForOutlookExpress(LPTSTR szDllPath, DWORD cchDllPath);
LPRECIPLIST AddTeimToRecipList(LPRECIPLIST lpList, WCHAR *pszEmail, WCHAR *pszName, LPSBinary lpSB);
void FreeLPRecipList(LPRECIPLIST lpList);
HRESULT HrStartMailThread(HWND hWndParent, ULONG nRecipCount, LPRECIPLIST lpList, BOOL bUseOEForSendMail);
BOOL CheckForWAB(void);
HRESULT HrLoadPathWABEXE(LPWSTR szPath, ULONG cbPath);
DWORD DwGetOptions(void);
DWORD DwSetOptions(DWORD dwVal);
BOOL IEIsSpace(LPSTR psz);
BOOL IsTelInstalled(void);
DWORD DwGetMessStatus(void);
DWORD DwGetDisableMessenger(void);
DWORD DwSetDisableMessenger(DWORD dwVal);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\globals.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     globals.h
//
//  PURPOSE:    Defines any global constants that are interesting to the 
//              entire project.
//

#pragma once 

/////////////////////////////////////////////////////////////////////////////
// 
// Window Messages
//
extern HINSTANCE  g_hLocRes;
extern LONG       g_cDllRefCount;

#define WM_CREATEOBJECTS                (WM_USER + 1000)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\mdispid.h ===
#ifndef _MDISPID_H_
#define _MDISPID_H_

//
// Dispatch IDs for DMsgrObjectEvents Dispatch Events.
//
#define DISPID_ONLOGONRESULT                  100
#define DISPID_ONLOGOFF                       101
#define DISPID_ONLISTADDRESULT                102
#define DISPID_ONLISTREMOVERESULT             103
#define DISPID_ONMESSAGEPRIVACYCHANGERESULT   104
#define DISPID_ONPROMPTCHANGERESULT           105
#define DISPID_ONUSERFRIENDLYNAMECHANGERESULT 106
#define DISPID_ONUSERSTATECHANGED             107
#define DISPID_ONTEXTRECEIVED                 108
#define DISPID_ONLOCALFRIENDLYNAMECHANGERESULT 109
#define DISPID_ONLOCALSTATECHANGERESULT       110
#define DISPID_ONAPPINVITERECEIVED            111
#define DISPID_ONAPPINVITEACCEPTED            112
#define DISPID_ONAPPINVITECANCELLED           113
#define DISPID_ONSENDRESULT                   114
#define DISPID_ONNEWERCLIENTAVAILABLE         115
#define DISPID_ONFINDRESULT                   116
#define DISPID_ONINVITEMAILRESULT             117
#define DISPID_ONREQUESTURLRESULT             118
#define DISPID_ONSESSIONSTATECHANGE           119
#define DISPID_ONUSERJOIN                     120
#define DISPID_ONUSERLEAVE                    121
#define DISPID_ONNEWSESSIONREQUEST            122
#define DISPID_ONINVITEUSER                   123
#define DISPID_ONSERVICELOGOFF                124
#define DISPID_ONPRIMARYSERVICECHANGED        125
#define DISPID_ONAPPSHUTDOWN                  126
#define DISPID_ONUNREADEMAILCHANGED           127
#define DISPID_ONUSERDROPPED                  128
#define DISPID_ONREQUESTURLPOSTRESULT         129
#define DISPID_ONNEWERSITESAVAILABLE          130
#define DISPID_ONTRUSTCHANGED                 131
#define DISPID_ONFILETRANSFERINVITERECEIVED   132
#define DISPID_ONFILETRANSFERINVITEACCEPTED   133
#define DISPID_ONFILETRANSFERINVITECANCELLED  134
#define DISPID_ONFILETRANSFERCANCELLED        135
#define DISPID_ONFILETRANSFERSTATUSCHANGE     136
#define DISPID_ONSPMESSAGERECEIVED            137
#define DISPID_ONLOCALPROPERTYCHANGERESULT    141
#define DISPID_ONBUDDYPROPERTYCHANGERESULT    142
#define DISPID_ONNOTIFICATIONRECEIVED         143
	
//
// Dispatch IDs for DMessengerAppEvents Dispatch Events.
// (don't overlap DMsgrObjectEvents ids)
//
#define DISPID_ONBEFORELAUNCHIMUI           20000
#define DISPID_ONSHOWIMUI		            20001
#define DISPID_ONDESTROYIMUI                20002
#define DISPID_ONINDICATEMESSAGERECEIVED	20003
#define DISPID_ONSTATUSTEXT					20004
#define DISPID_ONTITLEBARTEXT				20005
#define DISPID_ONINFOBARTEXT				20006
#define DISPID_ONSENDENABLED				20007
#define DISPID_ONTRANSLATEACCELERATOR		20008
#define DISPID_ONFILETRANSFER				20009
#define DISPID_ONVOICESESSIONSTATE			20010
#define DISPID_ONVOICEVOLUMECHANGED		    20011
#define DISPID_ONMICROPHONEMUTE			    20012

//
// Dispatch IDs for IMsgrObject.
//
#define DISPID_CREATEUSER                     100
#define DISPID_LOGON                          104
#define DISPID_LOGOFF                         105
#define DISPID_GETLIST                        0x60020003
#define DISPID_LOCALLOGONNAME                 0x60020004
#define DISPID_LOCALFRIENDLYNAME              0x60020005
#define DISPID_LOCALSTATE                     0x60020006
#define DISPID_MESSAGEPRIVACY                 0x60020008
#define DISPID_PROMPT                         0x6002000a
#define DISPID_SENDAPPINVITE                  108
#define DISPID_SENDAPPINVITEACCEPT            109
#define DISPID_SENDAPPINVITECANCEL            110
#define DISPID_LOCALOPTION                    0x6002000f
#define DISPID_FINDUSER                       111
#define DISPID_SENDINVITEMAIL                 112
#define DISPID_REQUESTURL                     113
#define DISPID_IMSESSIONS                     0x60020014
#define DISPID_CREATEIMSESSIONS               114
#define DISPID_SESSIONREQUESTACCEPT           115
#define DISPID_SESSIONREQUESTCANCEL           116
#define DISPID_SERVICES                       0x60020018
#define DISPID_UNREADEMAIL                    0x60020019
#define DISPID_SENDFILETRANSFERINVITE         117
#define DISPID_SENDFILETRANSFERINVITEACCEPT   118
#define DISPID_SENDFILETRANSFERINVITECANCEL   119
#define DISPID_CANCELFILETRANSFER             120
#define DISPID_FILETRANSFERSTATUS             121


//
// Dispatch IDs for IMessengerApp.
//
#define DISPID_APPLICATION                    0x60020000
#define DISPID_PARENT                         0x60020001
#define DISPID_QUIT                           100
#define DISPID_NAME                           0x60020003
#define DISPID_FULLNAME                       0x60020004
#define DISPID_PATH                           0x60020005
#define DISPID_LAUNCHLOGONUI                  200
#define DISPID_LAUNCHOPTIONSUI                201
#define DISPID_LAUNCHADDCONTACTUI             202
#define DISPID_LAUNCHFINDCONTACTUI            203
#define DISPID_LAUNCHIMUI                     210
#define DISPID_IMWINDOWS                      0x6002000b
#define DISPID_TOOLBAR                        0x6002000c
#define DISPID_STATUSBAR                      0x6002000e
#define DISPID_STATUSTEXT                     0x60020010
#define DISPID_GETHWND                        0x60020012
#define DISPID_LEFT                           0x60020013
#define DISPID_TOP                            0x60020015
#define DISPID_WIDTH                          0x60020017
#define DISPID_HEIGHT                         0x60020019
#define DISPID_MSGS_VISIBLE                   0x6002001b
#define DISPID_AUTOLOGON                      222
#define DISPID_FIRSTTIMECREDENTIONS           0x6002001e
#define DISPID_CACHEDPASSWORD                 0x6002001f
#define DISPID_REQUESTURLPOST                 223
#define DISPID_MSGS_TASKBARICON               224

//
// Dispatch IDs for IMsgrUser.
//
#define DISPID_USERFRIENDLYNAME               0x60020000
#define DISPID_USEREMAILADDRESS               0x60020002
#define DISPID_USERSTATE                      0x60020003
#define DISPID_USERLOGONNAME                  0x60020004
#define DISPID_USERSENDTEXT                   101
#define DISPID_USERSERVICE                    0x60020006

//
// Dispatch IDs for IMsgrUsers.
//
#define DISPID_USERSCOUNT                     0x60020000
#define DISPID_USERSADD                       100
#define DISPID_USERSREMOVE                    101

//
// Dispatch IDs for IMsgrService.
//
#define DISPID_SERVICESERVICENAME             0x60020000
#define DISPID_SERVICELOGONNAME               0x60020001
#define DISPID_SERVICEFRIENDLYNAME            0x60020002
#define DISPID_SERVICECAPABILITIES            0x60020004
#define DISPID_SERVICESTATUS                  0x60020005
#define DISPID_SERVICELOGOFF                  0x60020006
#define DISPID_SERVICEFINDUSER                0x60020007
#define DISPID_SERVICESENDINVITEMAIL          0x60020008
#define DISPID_SERVICEREQUESTURL              0x60020009
#define DISPID_SERVICEPROFILEFIELD            0x6002000a

//
// Dispatch IDs for IMsgrServices.
//
#define DISPID_SERVICESPRIMARYSERVICE         0x60020000
#define DISPID_SERVICESCOUNT                  0x60020002

#endif // ! _MDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\clutil.cpp ===
//****************************************************************************
//
//  BLClient sample for Microsoft Messenger SDK
//
//  Module:     BLClient.exe
//  File:       clUtil.cpp
//  Content:    Usefull clases for COM and Connection points
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************


#include "pch.hxx"
#include "clUtil.h"
#include "msoert.h"
// #include <instance.h>
// #include "demand.h"


#define ASSERT _ASSERTE

//****************************************************************************
//
// CLASS RefCount
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

RefCount::RefCount(void)
{
    m_cRef = 1;
    
//    Assert(NULL != g_pInstance);
//    CoIncrementInit("RefCount::RefCount", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

//****************************************************************************
//
// Destructor
//
//****************************************************************************

RefCount::~RefCount(void)
{
//    CoDecrementInit("RefCount::RefCount", NULL);    
}


//****************************************************************************
//
// ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
//
//****************************************************************************

ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   ASSERT(m_cRef >= 0);

   InterlockedIncrement(&m_cRef);

   return (ULONG) m_cRef;
}


//****************************************************************************
//
// ULONG STDMETHODCALLTYPE RefCount::Release(void)
//
//****************************************************************************

ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
    if (0 == InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    ASSERT(m_cRef > 0);
    return (ULONG) m_cRef;
}


//****************************************************************************
//
// CLASS CNotify
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

CNotify::CNotify() :
    m_pcnpcnt(NULL),
    m_pcnp(NULL),
    m_dwCookie(0),
    m_pUnk(NULL)
{
}


//****************************************************************************
//
// destructor
//
//****************************************************************************

CNotify::~CNotify()
{
    Disconnect(); // Make sure we're disconnected
}


//****************************************************************************
//
// HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
//
// Connects the sink to the container
//
//****************************************************************************

HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
{
    HRESULT hr;

    ASSERT(0 == m_dwCookie);

    // Get the connection container
    hr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void **)&m_pcnpcnt);
    if (SUCCEEDED(hr))
    {
        // Find an appropriate connection point
        hr = m_pcnpcnt->FindConnectionPoint(riid, &m_pcnp);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != m_pcnp);
            // Connect the sink object
            hr = m_pcnp->Advise((IUnknown *)pUnkN, &m_dwCookie);
        }
    }

    if (FAILED(hr))
    {
        m_dwCookie = 0;
    }
    else
    {
        m_pUnk = pUnk; // keep around for caller
    }

    return hr;
}


//****************************************************************************
//
// HRESULT CNotify::Disconnect (void)
//
// Disconnects the sink from the container
//
//****************************************************************************

HRESULT CNotify::Disconnect (void)
{
    if (0 != m_dwCookie)
    {

        // Disconnect the sink object
        m_pcnp->Unadvise(m_dwCookie);
        m_dwCookie = 0;

        m_pcnp->Release();
        m_pcnp = NULL;

        m_pcnpcnt->Release();
        m_pcnpcnt = NULL;

        m_pUnk = NULL;
    }

    return S_OK;
}


//****************************************************************************
//
// CLASS BSTRING
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

// We don't support construction from an ANSI string in the Unicode build.
#ifndef UNICODE

BSTRING::BSTRING(LPCSTR lpcString)
{
    m_bstr = NULL;

    // Compute the length of the required BSTR, including the null
    int cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
    if (cWC <= 0)
        return;

    // Allocate the BSTR, including the null
    m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

    ASSERT(NULL != m_bstr);
    if (NULL == m_bstr)
    {
        return;
    }

    // Copy the string
    MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

    // Verify that the string is null terminated
    ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // #ifndef UNICODE


//****************************************************************************
//
// CLASS BTSTR
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

BTSTR::BTSTR(BSTR bstr)
{
    m_psz = LPTSTRfromBstr(bstr);
}


//****************************************************************************
//
// Destructor
//
//****************************************************************************

BTSTR::~BTSTR()
{
    if (NULL != m_psz)
        MemFree(m_psz);
}


//****************************************************************************
//
// LPTSTR LPTSTRfromBstr(BSTR bstr)
//
// Converts a BSTR to a LPTSTR
//
//****************************************************************************

LPTSTR LPTSTRfromBstr(BSTR bstr)
{
    if (NULL == bstr)
        return NULL;

    int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
    if (cch <= 0)
        return NULL;

    LPTSTR psz;

    if (!MemAlloc((void **)&psz, sizeof(TCHAR) * (cch+1)))
        return NULL;

#ifndef UNICODE
    WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, cch+1, NULL, NULL);
#else
    StrCpyN(psz, bstr, cch+1);
#endif

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\ourguid.h ===
/************
**  ATHGUID.H
**      Holds the GUIDs for Athena, including
**  those copied from Ren.
**
**  Author:  t-ErikN  (8/22/95)
*/

#ifndef __ATHGUID_H
#define __ATHGUID_H

#include "imnact.h"
#include <shlguidp.h>

////////////////////////////////////////////////////////////////////////
//
//  Athena CLSID
//
//  every OLE2 object class must have a unique CLSID (class id)
//  ours are: 
//  
//      Athena  {89292101-4755-11cf-9DC2-00AA006C2B84}
//      Mail    {89292102-4755-11cf-9DC2-00AA006C2B84}    
//      News    {89292103-4755-11cf-9DC2-00AA006C2B84}
//
//  you get a CLSID by running the guidgen application in the Win96 PDK
//
////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------------
// BA control 
// --------------------------------------------------------------------------------
// {233A9694-667E-11d1-9DFB-006097D50408}
DEFINE_GUID(CLSID_OEBAControl, 0x233a9694, 0x667e, 0x11d1, 0x9d, 0xfb, 0x00, 0x60, 0x97, 0xd5, 0x04, 0x08);

#endif // include //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\hotlinks.cpp ===
// =================================================================================
// L I N K S . C P P
// =================================================================================
#include "pch.hxx"
#include "resource.h"
#include "hotlinks.h"
#include <shlwapi.h>
#include <string.h>
#include "baui.h"
#include "clutil.h"
#include <mapi.h>
#include "msoert.h"

#ifndef CharSizeOf
#define CharSizeOf(x)	(sizeof(x) / sizeof(TCHAR))
#endif

// explicit implementation of CharSizeOf
#define CharSizeOf_A(x)	(sizeof(x) / sizeof(CHAR))
#define CharSizeOf_W(x)	(sizeof(x) / sizeof(WCHAR))

const LPTSTR szDefMailKey =  TEXT("Software\\Clients\\Mail");
const LPTSTR szDefContactsKey =  TEXT("Software\\Clients\\Contacts");
const LPTSTR szIEContactsArea =  TEXT("Software\\Microsoft\\Internet Explorer\\Bar\\Contacts");
const LPTSTR szDisableMessnegerArea =  TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Contacts");
const LPTSTR szPhoenixArea =  TEXT("tel\\shell\\open\\command");
const LPTSTR szOEDllPathKey =   TEXT("DllPath");
const LPTSTR szOEName =  TEXT("Outlook Express");
const LPTSTR szOutlookName = TEXT("Microsoft Outlook");
const LPTSTR szContactOptions = TEXT("Options");
const LPTSTR szContactDisabled = TEXT("Disabled");
const LPTSTR szUseIM = TEXT("Use_IM");
const LPTSTR szDisableIM = TEXT("Disable_IM");

// =================================================================================
// Globals
// =================================================================================
static COLORREF g_crLink = RGB(0,0,128);
static COLORREF g_crLinkVisited = RGB(128,0,0);

const TCHAR c_szIESettingsPath[] =        "Software\\Microsoft\\Internet Explorer\\Settings";
const TCHAR c_szLinkVisitedColorIE[] =    "Anchor Color Visited";
const TCHAR c_szLinkColorIE[] =           "Anchor Color";
const TCHAR c_szNSSettingsPath[] =        "Software\\Netscape\\Netscape Navigator\\Settings";
const TCHAR c_szLinkColorNS[] =           "Link Color";
const TCHAR c_szLinkVisitedColorNS[] =    "Followed Link Color";


typedef struct _MailParams
{
    HWND hWnd;
    ULONG nRecipCount;
    LPRECIPLIST lpList;
    BOOL bUseOEForSendMail;   // True means check and use OE before checking for Simple MAPI client
} MAIL_PARAMS, * LPMAIL_PARAMS;

/***************************************************************************

    Name      : LocalFreeAndNull

    Purpose   : Frees a local allocation and null's the pointer

    Parameters: lppv = pointer to LocalAlloc pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

***************************************************************************/
// void __fastcall LocalFreeAndNull(LPVOID * lppv) {
void __fastcall LocalFreeAndNull(LPVOID * lppv) {
    if (lppv && *lppv) {
        LocalFree(*lppv);
        *lppv = NULL;
    }
}

/*
-
-   LPCSTR ConvertWtoA(LPWSTR lpszW);
*
*   LocalAllocs a ANSI version of an LPWSTR
*
*   Caller is responsible for freeing
*/
LPSTR ConvertWtoA(LPCWSTR lpszW)
{
    int cch;
    LPSTR lpC = NULL;

    if ( !lpszW)
        goto ret;

//    cch = lstrlenW( lpszW ) + 1;

    cch = WideCharToMultiByte( CP_ACP, 0, lpszW, -1, NULL, 0, NULL, NULL );
    cch = cch + 1;

    if(lpC = (LPSTR) LocalAlloc(LMEM_ZEROINIT, cch))
    {
        WideCharToMultiByte( CP_ACP, 0, lpszW, -1, lpC, cch, NULL, NULL );
    }
ret:
    return lpC;
}

// --------------------------------------------------------------------------
// IEIsSpace
// --------------------------------------------------------------------------
BOOL IEIsSpace(LPSTR psz)
{
    WORD wType = 0;

    if (IsDBCSLeadByte(*psz))
        GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType);
    else
        GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType);
    return (wType & C1_SPACE);
}


// =============================================================================================
// StringTok - similiar to strtok
// =============================================================================================
BOOL FStringTok (LPCTSTR        lpcszString, 
                 ULONG          *piString, 
                 LPTSTR         lpcszTokens, 
                 TCHAR          *chToken, 
                 LPTSTR         lpszValue, 
                 ULONG          cbValueMax,
                 BOOL           fStripTrailingWhitespace)
{
    // Locals
    LPTSTR      lpszStringLoop, 
                lpszTokenLoop;
    ULONG       cbValue=0, 
                nLen=0,
                cCharsSinceSpace=0,
                iLastSpace=0;
    BOOL        fTokenFound = FALSE;

    // Check Params
    _ASSERT (lpcszString && piString && lpcszTokens/*, "These should have been checked."*/);

    // INit = better be on a dbcs boundary
    lpszStringLoop = (LPTSTR)(lpcszString + (*piString));

    // Loop current
    while (*lpszStringLoop)
    {
        // If DBCS Lead Byte, skip it, it will never match the type of tokens I'm looking for
        // Or, If an escape character, don't check delimiters
        if (IsDBCSLeadByte(*lpszStringLoop) || *lpszStringLoop == _T('\\'))
        {
            cCharsSinceSpace+=2;
            lpszStringLoop+=2;
            cbValue+=2;
            continue;
        }
        // Mark and remember last space
        if (cCharsSinceSpace && IEIsSpace(lpszStringLoop))
        {
            cCharsSinceSpace=0;
            iLastSpace=cbValue;
        }
        // Count number of characters since last space
        else
            cCharsSinceSpace++;

        // Look for a tokens
        lpszTokenLoop=lpcszTokens;
        while(*lpszTokenLoop)
        {
            // Token Match ?
            if (*lpszStringLoop == *lpszTokenLoop)
            {
                // Save the found token
                if (chToken)
                    *chToken = *lpszStringLoop;

                // Don't count this character as a charcter seen since last space
                cCharsSinceSpace--;

                // Were done
                fTokenFound = TRUE;
                goto done;
            }

            // Next Token
            lpszTokenLoop++;
        }

        // Next Char
        lpszStringLoop++;
        cbValue++;
    }

done:
    // If reached end of string, this is a default token
    if (*lpszStringLoop == _T('\0'))
    {
        if (chToken)
            *chToken = *lpszStringLoop;
        fTokenFound = TRUE;
    }

    // Copy value if token found
    if (fTokenFound)
    {
        if (lpszValue && cbValueMax > 0 && cbValue)
        {
            if (cbValue+1 <= cbValueMax)
            {
                StrCpyN (lpszValue, lpcszString + (*piString), cbValue+1);
                nLen = cbValue-1;
            }
            else
            {
                _ASSERT  (FALSE/*, "Buffer is too small."*/);
                StrCpyN (lpszValue, lpcszString + (*piString), cbValueMax);
                nLen = cbValueMax-1;
            }

            // Strip Trailing Whitespace ?
            if (fStripTrailingWhitespace && cCharsSinceSpace == 0)
            {
                *(lpszValue + iLastSpace) = _T('\0');
                nLen = iLastSpace - 1;
            }
        }

        // No Text
        else
        {
            if (lpszValue)
                *lpszValue = _T('\0');
            nLen = 0;
            cbValue = 0;
        }

        // Set new string index
        *piString += cbValue + 1;
    }
    // Return whether we found a token

    return fTokenFound;
}


// =================================================================================
// ParseLinkColorFromSz
// =================================================================================
VOID ParseLinkColorFromSz(LPTSTR lpszLinkColor, LPCOLORREF pcr)
{
    // Locals
    ULONG           iString = 0;
    TCHAR           chToken,
                    szColor[5];
    DWORD           dwR,
                    dwG,
                    dwB;

    // Red
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T(','))
        goto exit;
    dwR = StrToInt(szColor);

    // Green
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T(','))
        goto exit;
    dwG = StrToInt(szColor);

    // Blue
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T('\0'))
        goto exit;
    dwB = StrToInt(szColor);

    // Create color
    *pcr = RGB(dwR, dwG, dwB);

exit:
    // Done
    return;
}

// =================================================================================
// LookupLinkColors
// =================================================================================
BOOL LookupLinkColors(LPCOLORREF pclrLink, LPCOLORREF pclrViewed)
{
    // Locals
    HKEY        hReg=NULL;
    TCHAR       szLinkColor[255],
                szLinkVisitedColor[255];
    LONG        lResult;
    DWORD       cb;

    // Init
    *szLinkColor = _T('\0');
    *szLinkVisitedColor = _T('\0');

    // Look for IE's link color
    if (RegOpenKeyEx (HKEY_CURRENT_USER, (LPTSTR)c_szIESettingsPath, 0, KEY_ALL_ACCESS, &hReg) != ERROR_SUCCESS)
        goto tryns;

    // Query for value
    cb = sizeof (szLinkVisitedColor);
    RegQueryValueEx(hReg, (LPTSTR)c_szLinkVisitedColorIE, 0, NULL, (LPBYTE)szLinkVisitedColor, &cb);
    cb = sizeof (szLinkColor);
    lResult = RegQueryValueEx(hReg, (LPTSTR)c_szLinkColorIE, 0, NULL, (LPBYTE)szLinkColor, &cb);

    // Close Reg
    RegCloseKey(hReg);

    // Did we find it
    if (lResult == ERROR_SUCCESS)
        goto found;

tryns:
    // Try Netscape
    if (RegOpenKeyEx (HKEY_CURRENT_USER, (LPTSTR)c_szNSSettingsPath, 0, KEY_ALL_ACCESS, &hReg) != ERROR_SUCCESS)
        goto exit;

    // Query for value
    cb = sizeof (szLinkVisitedColor);
    RegQueryValueEx(hReg, (LPTSTR)c_szLinkVisitedColorNS, 0, NULL, (LPBYTE)szLinkVisitedColor, &cb);
    cb = sizeof (szLinkColor);
    lResult = RegQueryValueEx(hReg, (LPTSTR)c_szLinkColorNS, 0, NULL, (LPBYTE)szLinkColor, &cb);

    // Close Reg
    RegCloseKey(hReg);

    // Did we find it
    if (lResult == ERROR_SUCCESS)
        goto found;

    // Not Found
    goto exit;

found:

    // Parse Link
    ParseLinkColorFromSz(szLinkColor, &g_crLink);
    ParseLinkColorFromSz(szLinkVisitedColor, &g_crLinkVisited);
    
    if (pclrLink)
        *pclrLink = g_crLink;
    if (pclrViewed)    
        *pclrViewed = g_crLinkVisited;
    return (TRUE);

exit:
    // Done
    return (FALSE);
}

//$$///////////////////////////////////////////////////////////////////////
//
// CheckForWAB(void)
//
// return TRUE if default Contacts sectionselected as "Address Book" means WAB
// also We need to be sure that Microsoft Outlook is default email client, 
// if Microsoft Outlook selected as default Contacts
//////////////////////////////////////////////////////////////////////////

BOOL CheckForWAB(void)
{
    BOOL bRet = TRUE;
    HKEY hKeyContacts = NULL;
    DWORD dwErr     = 0;
    DWORD dwSize    = 0;
    DWORD dwType    = 0;
    TCHAR szBuf[MAX_PATH];

    // Open the key for default Contacts client
    // HKLM\Software\Clients\Contacts

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDefContactsKey, 0, KEY_READ, &hKeyContacts);
    if(dwErr != ERROR_SUCCESS)
    {
        // DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefContactsKey, dwErr);
        goto out;
    }

    dwSize = CharSizeOf(szBuf);         // Expect ERROR_MORE_DATA

    dwErr = RegQueryValueEx(hKeyContacts, NULL, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if(dwErr != ERROR_SUCCESS)
        goto out;

    if(!lstrcmpi(szBuf, szOutlookName))
    {
        // Yes its Microsoft Outlook
        bRet = FALSE;
    }
    else
        goto out;
#ifdef NEED
    RegCloseKey(hKeyContacts);
    
    // Check that default email is Microsoft Outlook too.

    // Open the key for default internet mail client
    // HKLM\Software\Clients\Mail

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDefMailKey, 0, KEY_READ, &hKeyContacts);
    if(dwErr != ERROR_SUCCESS)
    {
        // DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        bRet = TRUE;
        goto out;
    }

    dwSize = CharSizeOf(szBuf);         // Expect ERROR_MORE_DATA

    dwErr = RegQueryValueEx(    hKeyContacts, NULL, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if(dwErr != ERROR_SUCCESS)
    {
        bRet = TRUE;
        goto out;
    }

    if(lstrcmpi(szBuf, szOutlookName))
    {
        // Yes its not Microsoft Outlook
        bRet = TRUE;
    }
    
#endif // NEED
out:
    if(hKeyContacts)
        RegCloseKey(hKeyContacts);
    return(bRet);
}

//$$///////////////////////////////////////////////////////////////////////
//
// CheckForOutlookExpress
//
//  szDllPath - is a big enough buffer that will contain the path for
//      the OE dll ..
//
//////////////////////////////////////////////////////////////////////////
BOOL CheckForOutlookExpress(LPTSTR szDllPath, DWORD cchDllPath)
{
    HKEY hKeyMail   = NULL;
    HKEY hKeyOE     = NULL;
    DWORD dwErr     = 0;
    DWORD dwSize    = 0;
    TCHAR szBuf[MAX_PATH];
    TCHAR szPathExpand[MAX_PATH];
    DWORD dwType    = 0;
    BOOL bRet = FALSE;

    if (!szDllPath)
        goto out;

    szDllPath[0] = 0;
    szPathExpand[0] = 0;

    // Open the key for default internet mail client
    // HKLM\Software\Clients\Mail

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDefMailKey, 0, KEY_READ, &hKeyMail);
    if(dwErr != ERROR_SUCCESS)
    {
        // DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        goto out;
    }

    dwSize = CharSizeOf(szBuf);         // Expect ERROR_MORE_DATA

    dwErr = RegQueryValueEx(    hKeyMail, NULL, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if(dwErr != ERROR_SUCCESS)
    {
        goto out;
    }

    if(!lstrcmpi(szBuf, szOEName))
    {
        // Yes its outlook express ..
        bRet = TRUE;
    }

    //Get the DLL Path anyway whether this is the default key or not

    // Get the DLL Path
    dwErr = RegOpenKeyEx(hKeyMail, szOEName, 0, KEY_READ, &hKeyOE);
    if(dwErr != ERROR_SUCCESS)
    {
        // DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        goto out;
    }

    dwSize = ARRAYSIZE(szBuf);
    szBuf[0] = 0;

    dwErr = RegQueryValueEx(hKeyOE, szOEDllPathKey, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if (REG_EXPAND_SZ == dwType) 
    {
        ExpandEnvironmentStrings(szBuf, szPathExpand, ARRAYSIZE(szPathExpand));
        StrCpyN(szBuf, szPathExpand, ARRAYSIZE(szBuf));
    }


    if(dwErr != ERROR_SUCCESS)
    {
        goto out;
    }

    if(lstrlen(szBuf))
        StrCpyN(szDllPath, szBuf, cchDllPath);

out:
    if(hKeyOE)
        RegCloseKey(hKeyOE);
    if(hKeyMail)
        RegCloseKey(hKeyMail);
    return bRet;
}

//$$//////////////////////////////////////////////////////////////////////
//
//  HrSendMail - does the actual mail sending
//          Our first priority is to Outlook Express which currently has a
//          different code path than the regular MAPI client .. so we look
//          under HKLM\Software\Clients\Mail .. if the client is OE then
//          we just loadlibrary and getprocaddress for sendmail
//          If its not OE, then we call the mapi32.dll and load it ..
//          If both fail we will not be able to send mail ...
//
//          This function will free the lpList no matter what happens
//          so caller should not expect to reuse it (This is so we can
//          give the pointer to a seperate thread and not worry about it)
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrSendMail(HWND hWndParent, ULONG nRecipCount, LPRECIPLIST lpList, BOOL bUseOEForSendMail)
{
	HRESULT hr = E_FAIL;
    HINSTANCE hLibMapi = NULL;
    BOOL bIsOE = FALSE; // right now there is a different code path
                        // for OE vs other MAPI clients

    TCHAR szBuf[MAX_PATH];
    LPMAPISENDMAIL lpfnMAPISendMail = NULL;
    LHANDLE hMapiSession = 0;
    LPMAPILOGON lpfnMAPILogon = NULL;
    LPMAPILOGOFF lpfnMAPILogoff = NULL;

    LPBYTE      lpbName, lpbAddrType, lpbEmail;
    ULONG       ulMapiDataType;
    ULONG       cbEntryID = 0;
    LPENTRYID   lpEntryID = NULL;

    MapiMessage Msg = {0};
    MapiRecipDesc * lprecips = NULL;

    if(!nRecipCount)
    {
        hr = MAPI_W_ERRORS_RETURNED;
        goto out;
    }

    // Check if OutlookExpress is the default current client ..
    bIsOE = CheckForOutlookExpress(szBuf, ARRAYSIZE(szBuf));

    // Turn off all notifications for simple MAPI send mail, if the default
    // email client is Outlook.  This is necessary because Outlook changes the 
    // WAB MAPI allocation functions during simple MAPI and we don't want any
    // internal WAB functions using these allocators.
#ifdef LATER
    if (!bIsOE && !bUseOEForSendMail)
        vTurnOffAllNotifications();

    // if OE is the default client or OE launched this WAB, use OE for SendMail
    if(lstrlen(szBuf) && (bIsOE||bUseOEForSendMail))
    {
        hLibMapi = LoadLibrary(szBuf);
    }
    else
#endif
    {
        // Check if simple mapi is installed
        if(GetProfileInt( TEXT("mail"), TEXT("mapi"), 0) == 1)
            hLibMapi = LoadLibrary( TEXT("mapi32.dll"));
        
        if(!hLibMapi) // try loading the OE MAPI dll directly
        {
            // Load the path to the msimnui.dll
            CheckForOutlookExpress(szBuf, ARRAYSIZE(szBuf));
            if(lstrlen(szBuf))  // Load the dll directly - dont bother going through msoemapi.dll
                hLibMapi = LoadLibrary(szBuf);
        }
    }

    if(!hLibMapi)
    {
        _ASSERT(FALSE); // DebugPrintError(( TEXT("Could not load/find simple mapi\n")));
        hr = MAPI_E_NOT_FOUND;
        goto out;
    }
    else if(hLibMapi)
    {
        lpfnMAPILogon = (LPMAPILOGON) GetProcAddress (hLibMapi, "MAPILogon");
        lpfnMAPILogoff= (LPMAPILOGOFF)GetProcAddress (hLibMapi, "MAPILogoff");
        lpfnMAPISendMail = (LPMAPISENDMAIL) GetProcAddress (hLibMapi, "MAPISendMail");

        if(!lpfnMAPISendMail || !lpfnMAPILogon || !lpfnMAPILogoff)
        {
            _ASSERT(FALSE); // DebugPrintError(( TEXT("MAPI proc not found\n")));
            hr = MAPI_E_NOT_FOUND;
            goto out;
        }
        hr = lpfnMAPILogon( (ULONG_PTR)hWndParent, NULL,
                            NULL,              // No password needed.
                            0L,                // Use shared session.
                            0L,                // Reserved; must be 0.
                            &hMapiSession);       // Session handle.

        if(hr != SUCCESS_SUCCESS)
        {
            // DebugTrace( TEXT("MAPILogon failed\n"));
            // its possible the logon failed since there was no shared logon session
            // Try again to create a new session with UI
            hr = lpfnMAPILogon( (ULONG_PTR)hWndParent, NULL,
                                NULL,                               // No password needed.
                                MAPI_LOGON_UI | MAPI_NEW_SESSION,   // Use shared session.
                                0L,                // Reserved; must be 0.
                                &hMapiSession);    // Session handle.

            if(hr != SUCCESS_SUCCESS)
            {
                // DebugTrace( TEXT("MAPILogon failed\n"));
                goto out;
            }
        }
    }

    // Load the MAPI functions here ...
    //

    lprecips = (MapiRecipDesc *) LocalAlloc(LMEM_ZEROINIT, sizeof(MapiRecipDesc) * nRecipCount);
    {
        LPRECIPLIST lpTemp = lpList;
        ULONG count = 0;

        while(lpTemp)
        {
            lprecips[count].ulRecipClass = MAPI_TO;
            lprecips[count].lpszName = lpTemp->lpszName;
            lprecips[count].lpszAddress = lpTemp->lpszEmail;

#ifdef LATER
            // [PaulHi] 4/20/99  Raid 73455
            // Convert Unicode EID OneOff strings to ANSI
            if ( IsWABEntryID(lpTemp->lpSB->cb, (LPVOID)lpTemp->lpSB->lpb, 
                              &lpbName, &lpbAddrType, &lpbEmail, (LPVOID *)&ulMapiDataType, NULL) == WAB_ONEOFF )
            {
                if (ulMapiDataType & MAPI_UNICODE)
                {
                    hr = CreateWABEntryIDEx(
                        FALSE,              // Don't want Unicode EID strings
                        WAB_ONEOFF,         // EID type
                        (LPWSTR)lpbName,
                        (LPWSTR)lpbAddrType,
                        (LPWSTR)lpbEmail,
                        0,
                        0,
                        NULL,
                        &cbEntryID,
                        &lpEntryID);

                    if (FAILED(hr))
                        goto out;

                    lprecips[count].ulEIDSize = cbEntryID;
                    lprecips[count].lpEntryID = lpEntryID;
                }
                else
                {
                    lprecips[count].ulEIDSize = lpTemp->lpSB->cb;
                    lprecips[count].lpEntryID = (LPVOID)lpTemp->lpSB->lpb;
                }
            }
#endif // LATER
            lpTemp = lpTemp->lpNext;
            count++;
        }
    }

    Msg.nRecipCount = nRecipCount;
    Msg.lpRecips = lprecips;

    hr = lpfnMAPISendMail (hMapiSession, (ULONG_PTR)hWndParent,
                            &Msg,       // the message being sent
                            MAPI_DIALOG, // allow the user to edit the message
                            0L);         // reserved; must be 0
    if(hr != SUCCESS_SUCCESS)
        goto out;

    hr = S_OK;

out:

    if (lpEntryID)
        LocalFreeAndNull((void **)&lpEntryID);

    // The simple MAPI session should end after this
    if(hMapiSession && lpfnMAPILogoff)
        lpfnMAPILogoff(hMapiSession,0L,0L,0L);

    if(hLibMapi)
        FreeLibrary(hLibMapi);

#ifdef LATER
    // Turn all notifications back on and refresh the WAB UI (just in case)
    if (!bIsOE && !bUseOEForSendMail)
    {
        vTurnOnAllNotifications();
        if (lpIAB->hWndBrowse)
         PostMessage(lpIAB->hWndBrowse, WM_COMMAND, (WPARAM) IDM_VIEW_REFRESH, 0);
    }

    if(lprecips)
    {
        ULONG i = 0;
        for(i=0;i < nRecipCount;i++)
        {
            LocalFreeAndNull((void **)&lprecips[i].lpszName);
            LocalFreeAndNull((void **)&lprecips[i].lpszAddress);
        }

        LocalFree(lprecips);
    }
#endif
    
    // The one-off here was allocated before the simple MAPI session and so used
    // the default WAB allocators.
    if(lpList)
        FreeLPRecipList(lpList);

    switch(hr)
    {
    case S_OK:
    case MAPI_E_USER_CANCEL:
    case MAPI_E_USER_ABORT:
        break;
    case MAPI_W_ERRORS_RETURNED:
        _ASSERT(FALSE); // ShowMessageBox(hWndParent, idsSendMailToNoEmail, MB_ICONEXCLAMATION | MB_OK);
        break;
    case MAPI_E_NOT_FOUND:
        _ASSERT(FALSE); // ShowMessageBox(hWndParent, idsSendMailNoMapi, MB_ICONEXCLAMATION | MB_OK); 
        break;
    default:
        _ASSERT(FALSE); // ShowMessageBox(hWndParent, idsSendMailError, MB_ICONEXCLAMATION | MB_OK);
        break;
    }

    return hr;
}

//$$//////////////////////////////////////////////////////////////////////
//
// MailThreadProc - does the actual sendmail and cleans up
//
//////////////////////////////////////////////////////////////////////////
DWORD WINAPI MailThreadProc( LPVOID lpParam )
{
    LPMAIL_PARAMS lpMP = (LPMAIL_PARAMS) lpParam;
#ifdef LATER
    LPPTGDATA lpPTGData = GetThreadStoragePointer(); // Bug - if this new thread accesses the WAB we lose a hunka memory
                                                // So add this thing here ourselves and free it when this thread's work is done
#endif

    if(!lpMP)
        return 0;

    // DebugTrace( TEXT("Mail Thread ID = 0x%.8x\n"),GetCurrentThreadId());

    HrSendMail(lpMP->hWnd, lpMP->nRecipCount, lpMP->lpList, lpMP->bUseOEForSendMail);

    LocalFree(lpMP);

    return 0;
}

//$$//////////////////////////////////////////////////////////////////////
//
// HrStartMailThread
//
//  Starts a seperate thread to send mapi based mail from
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrStartMailThread(HWND hWndParent, ULONG nRecipCount, LPRECIPLIST lpList, BOOL bUseOEForSendMail)
{
    LPMAIL_PARAMS lpMP = NULL;
    HRESULT hr = E_FAIL;

    lpMP = (LPMAIL_PARAMS) LocalAlloc(LMEM_ZEROINIT, sizeof(MAIL_PARAMS));

    if(!lpMP)
        goto out;

    {
        HANDLE hThread = NULL;
        DWORD dwThreadID = 0;

        lpMP->hWnd = hWndParent;
        lpMP->nRecipCount = nRecipCount;
        lpMP->lpList = lpList;
        lpMP->bUseOEForSendMail = bUseOEForSendMail;

        hThread = CreateThread(
                                NULL,           // no security attributes
                                0,              // use default stack size
                                MailThreadProc,     // thread function
                                (LPVOID) lpMP,  // argument to thread function
                                0,              // use default creation flags
                                &dwThreadID);   // returns the thread identifier

        if(hThread == NULL)
            goto out;

        hr = S_OK;

        CloseHandle(hThread);
    }

out:
    if(HR_FAILED(hr))
    {
        _ASSERT(FALSE);
#ifdef LATER
        ShowMessageBox(hWndParent, idsSendMailError, MB_OK | MB_ICONEXCLAMATION);
#endif

        // we can assume that HrSendMail never got called so we should free lpList & lpMP
        if(lpMP)
            LocalFree(lpMP);

        if(lpList)
            FreeLPRecipList(lpList);

    }

    return hr;
}

//$$/////////////////////////////////////////////////////////////////////
//
// FreeLPRecipList
//
// Frees a linked list containing the above structures
//
/////////////////////////////////////////////////////////////////////////
void FreeLPRecipList(LPRECIPLIST lpList)
{
    if(lpList)
    {
        LPRECIPLIST lpTemp = lpList;
        while(lpTemp)
        {
            lpList = lpTemp->lpNext;
            if(lpTemp->lpszName)
                LocalFree(lpTemp->lpszName);
            if(lpTemp->lpszEmail)
                LocalFree(lpTemp->lpszEmail);
            if(lpTemp->lpSB)
                LocalFree(lpTemp->lpSB);

            LocalFree(lpTemp);
            lpTemp = lpList;
        }
    }
}

//$$/////////////////////////////////////////////////////////////////////
//
// FreeLPRecipList
//
// Frees a linked list containing the above structures
//
/////////////////////////////////////////////////////////////////////////
LPRECIPLIST AddTeimToRecipList(LPRECIPLIST lpList, WCHAR *pwszEmail, WCHAR *pwszName, LPSBinary lpSB)
{
    LPRECIPLIST lpTemp = NULL;

    lpTemp = (RECIPLIST*) LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPLIST));

    if(!lpTemp)
        return NULL;

    if(pwszEmail)
    {
        LPTSTR pszEmail = LPTSTRfromBstr(pwszEmail);

        if(pszEmail)
        {
            ULONG cchSize = lstrlenW(pwszEmail)+1;
            lpTemp->lpszEmail = (TCHAR *) LocalAlloc(LMEM_ZEROINIT, cchSize*sizeof(lpTemp->lpszEmail[0]));
            if(lpTemp->lpszEmail)
                StrCpyN(lpTemp->lpszEmail, pszEmail, cchSize);

            MemFree(pszEmail);
        }
    }

    if(pwszName)
    {

        LPTSTR pszName = LPTSTRfromBstr(pwszName);

        if(pszName)
        {
            ULONG cchSize = lstrlen(pszName)+1;
            lpTemp->lpszName = (TCHAR *) LocalAlloc(LMEM_ZEROINIT, cchSize*sizeof(lpTemp->lpszEmail[0]));
            if(lpTemp->lpszName)
                StrCpyN(lpTemp->lpszName, pszName, cchSize);

            MemFree(pszName);
        }
    }

    if(lpSB)
    {
        lpTemp->lpSB = (SBinary *) LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
        if(lpTemp->lpSB )
            *(lpTemp->lpSB) = *lpSB;
    }

    if(lpList)
        lpList->lpNext = lpTemp;

    return lpTemp;
}

const static TCHAR lpszWABDLLRegPathKey[] = TEXT("Software\\Microsoft\\WAB\\DLLPath");
const static TCHAR lpszWABEXERegPathKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wab.exe");
const static TCHAR lpszWABEXE[] = TEXT("wab.exe");

// =============================================================================
// HrLoadPathWABEXE - creaetd vikramm 5/14/97 - loads the registered path of the
// latest wab.exe
// szPath - pointer to a buffer
// cbPath - sizeof buffer
// =============================================================================
// ~~~~ @TODO dhaws Might need to convert this
HRESULT HrLoadPathWABEXE(LPWSTR szPath, ULONG cbPath)
{
    DWORD  dwType;
    ULONG  cbData = MAX_PATH;
    HKEY hKey;
    TCHAR szTmpPath[MAX_PATH];

    _ASSERT(szPath != NULL);
    _ASSERT(cbPath > 0);

    *szPath = '\0';

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszWABEXERegPathKey, 0, KEY_READ, &hKey))
        {
        SHQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szTmpPath, &cbData);
        RegCloseKey(hKey);
        }

    if(!lstrlen(szTmpPath))
    {
        if(!MultiByteToWideChar(GetACP(), 0, lpszWABEXE, -1, szPath, cbPath))
            return(E_FAIL);
    }
    else
    {
        if(!MultiByteToWideChar(GetACP(), 0, szTmpPath, -1, szPath, cbPath))
            return(E_FAIL);

    }
    return S_OK;
}

DWORD DwGetMessStatus(void)
{
    HKEY hKey;
    DWORD  dwType = 0;
    DWORD dwVal = 0;
    ULONG  cbData = sizeof(dwType);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDisableMessnegerArea, 0, KEY_READ, &hKey))
    {
        RegQueryValueEx(hKey, szUseIM, NULL, &dwType, (LPBYTE) &dwVal, &cbData);

        RegCloseKey(hKey);
    }

    return dwVal;
}

DWORD DwGetDisableMessenger(void)
{
    HKEY hKey;
    DWORD  dwType = 0;
    DWORD dwVal = 0;
    ULONG  cbData = sizeof(dwType);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szIEContactsArea, 0, KEY_READ, &hKey))
    {
        RegQueryValueEx(hKey, szDisableIM, NULL, &dwType, (LPBYTE) &dwVal, &cbData);

        RegCloseKey(hKey);
    }

    return dwVal;
}

DWORD DwSetDisableMessenger(DWORD dwVal)
{
    HKEY hKey;
    ULONG  cbData = sizeof(DWORD);

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szIEContactsArea, 0, NULL, 0, 
                KEY_ALL_ACCESS, NULL, &hKey, NULL))
    {
        RegSetValueEx(hKey, szDisableIM, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);
        RegCloseKey(hKey);
    }
    return dwVal;
}

DWORD DwGetOptions(void)
{
    HKEY hKey;
    DWORD  dwType = 0;
    DWORD dwVal = 0;
    ULONG  cbData = sizeof(dwType);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szIEContactsArea, 0, KEY_READ, &hKey))
    {
        RegQueryValueEx(hKey, szContactOptions, NULL, &dwType, (LPBYTE) &dwVal, &cbData);

        RegCloseKey(hKey);
    }

    return dwVal;
}

DWORD DwSetOptions(DWORD dwVal)
{
    HKEY hKey;
    ULONG  cbData = sizeof(DWORD);

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szIEContactsArea, 0, NULL, 0, 
                KEY_ALL_ACCESS, NULL, &hKey, NULL))
    {
        RegSetValueEx(hKey, szContactOptions, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);
        RegCloseKey(hKey);
    }
    return dwVal;
}

BOOL IsTelInstalled(void)
{
    HKEY hKey;
    BOOL fRet = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szPhoenixArea, 0, KEY_READ, &hKey))
    {
        RegCloseKey(hKey);
        fRet = TRUE;
    }
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	WebBand.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "pch.hxx"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msoectrl.rc
//
#define IDI_ICON                        104
#define IDI_HOTICON                     105
#define IDI_WHISTICON                   106
//
#define IDR_BLVIEW                      101
#define IDR_MAINMENU                    202
#define IDI_MAINICON                    203
#define ID_HELP_ABOUT                   204

// Bitmaps 
#define IDB_FACE                        240

// Command IDs for buttons
#define IDM_SEND                        225
#define IDM_ADD                         226

#define IDR_BA_DRAGDROP_POPUP               109
#define IDR_BA_POPUP                        108
#define IDR_BA_TITLE_POPUP                  110
#define IDR_POPUP_VIEW                      111

/////////////////////////////////////////////////////////////////////////////
// BEGIN SEPARATOR IDs
//

#define SEP_FIRST                           30000
#define SEP_MESSENGER                       (SEP_FIRST + 4)
#define SEP_PHONE                           (SEP_FIRST + 5)

/////////////////////////////////////////////////////////////////////////////
// BEGIN COMMAND IDs
//
#define ID_FIRST                            40000
#define ID_POPUP_NEW_ACCOUNT                (ID_FIRST + 31)
#define ID_PROPERTIES                       (ID_FIRST + 122)
#define ID_DELETE                           (ID_FIRST + 128)
#define ID_FIND_PEOPLE                      (ID_FIRST + 134)
#define ID_NEW_MSG_DEFAULT                  (ID_FIRST + 170)
#define ID_SEND_MESSAGE                     (ID_FIRST + 171)
#define ID_ADDRESS_BOOK                     (ID_FIRST + 199)
#define ID_SAVE                             (ID_FIRST + 227)
#define ID_SAVE_ALL_ADDRESSES               (ID_FIRST + 266)
#define ID_CANCEL                           (ID_FIRST + 267)
#define ID_SEND_INSTANT_MESSAGE             (ID_FIRST + 268)
#define ID_NEW_CONTACT                      (ID_FIRST + 270)
#define ID_ADD_ADDRESS_BOOK                 (ID_FIRST + 271)
#define ID_NEW_HOTMAIL_ACCOUNT              (ID_FIRST + 327)
#define ID_NEW_ATT_ACCOUNT                  (ID_FIRST + 328)
#define ID_NEW_GROUP                        (ID_FIRST + 330)
#define ID_SEND_INSTANT_MESSAGE2            (ID_FIRST + 331)
#define ID_DELETE_CONTACT                   (ID_FIRST + 435)
#define ID_NEW_ONLINE_CONTACT               (ID_FIRST + 456)
#define ID_SORT_BY_NAME                     (ID_FIRST + 457)
#define ID_SORT_BY_STATUS                   (ID_FIRST + 458)
#define ID_SET_ONLINE_CONTACT               (ID_FIRST + 476)
#define ID_LOGIN                            (ID_FIRST + 477)
#define ID_SEND                             (ID_FIRST + 478)
#define ID_CALL                             (ID_FIRST + 479)
#define ID_STATUS                           (ID_FIRST + 480)
#define ID_SHOWALLCONTACT                   (ID_FIRST + 481)
#define ID_SHOW_IM                          (ID_FIRST + 482)
#define ID_HIDE_IM                          (ID_FIRST + 483)

#define ID_DIAL_PHONE_NUMBER                (ID_FIRST + 600)
#define ID_HOME_PHONE                       (ID_FIRST + 601)
#define ID_WORK_PHONE                       (ID_FIRST + 602)
#define ID_MOBILE_PHONE                     (ID_FIRST + 603)
#define ID_IP_PHONE                         (ID_FIRST + 604)

#define ID_DIAL_PHONE_LAST                  (ID_FIRST + 699)

#define ID_VIEW_FILTER_LAST                 (ID_FIRST + 5000)

#define ID_NEW_ACCT_FIRST                   (ID_VIEW_FILTER_LAST + 1)
#define ID_NEW_ACCT_LAST                    (ID_NEW_ACCT_FIRST + 20)

#define ID_MESSENGER_FIRST                  (ID_NEW_ACCT_LAST + 1)
#define ID_POPUP_MESSENGER                  ID_MESSENGER_FIRST
#define ID_POPUP_MESSENGER_STATUS           (ID_MESSENGER_FIRST + 1)
#define ID_LOGIN_MESSENGER                  (ID_MESSENGER_FIRST + 2)
#define ID_MESSENGER_ONLINE                 (ID_MESSENGER_FIRST + 3)
#define ID_MESSENGER_INVISIBLE              (ID_MESSENGER_FIRST + 4)
#define ID_MESSENGER_BUSY                   (ID_MESSENGER_FIRST + 5)
#define ID_MESSENGER_BACK                   (ID_MESSENGER_FIRST + 6)
#define ID_MESSENGER_AWAY                   (ID_MESSENGER_FIRST + 7)
#define ID_MESSENGER_ON_PHONE               (ID_MESSENGER_FIRST + 8)
#define ID_MESSENGER_LUNCH                  (ID_MESSENGER_FIRST + 9)
#define ID_MESSENGER_OPTIONS                (ID_MESSENGER_FIRST + 10)
#define ID_LOGOFF_MESSENGER                 (ID_MESSENGER_FIRST + 11)
#define ID_MESSENGER_LAST                   (ID_MESSENGER_FIRST + 20)
#define ID_VIEW_ONLINE                      (ID_MESSENGER_FIRST + 22)
#define ID_VIEW_ONANDOFFLINE                (ID_MESSENGER_FIRST + 23)
#define ID_VIEW_ALL                         (ID_MESSENGER_FIRST + 24)
#define ID_CONT_FILE                        (ID_MESSENGER_FIRST + 25)
 
//
// END COMMAND IDs
/////////////////////////////////////////////////////////////////////////////

// BL control strings
#define STR_FIRST                       4203
#define idsAthena                       (STR_FIRST + 8)
#define idsAthenaMail                   idsAthena
#define idsChooseName                   (STR_FIRST + 1390)

#define idsBADelBLEntry                 (STR_FIRST + 1924)
#define idsBADelBLABEntry               (STR_FIRST + 1925)
#define idsBADelABEntry                 (STR_FIRST + 1926)
#define idsBADelMultiple                (STR_FIRST + 1927)
#define idsBAErrExtChars                (STR_FIRST + 1928)
// #define idsBAErrNotHotmail              (STR_FIRST + 1929) // Not used anymore
#define idsWABExtTitle                  (STR_FIRST + 1930)
#define idsBAErrJITFail                 (STR_FIRST + 1931)

#define idsBADefault                    (STR_FIRST + 1940)

#define idsServiceName                  (STR_FIRST + 1979)

#define idsBADispStatus                 (STR_FIRST + 2006)
#define idsBAEmail                      (STR_FIRST + 2007)
#define idsBAIMsg                       (STR_FIRST + 2008)
#define idsBAOnline                     (STR_FIRST + 2009)
#define idsBAInvisible                  (STR_FIRST + 2010)
#define idsBABusy                       (STR_FIRST + 2011)
#define idsBABack                       (STR_FIRST + 2012)
#define idsBAAway                       (STR_FIRST + 2013)
#define idsBAOnPhone                    (STR_FIRST + 2014)
#define idsBALunch                      (STR_FIRST + 2015)
#define idsBAOffline                    (STR_FIRST + 2016)
#define idsBAIdle                       (STR_FIRST + 2017)
#define idsTitleMenu                    (STR_FIRST + 2018)
#define idsButtonText                   (STR_FIRST + 2019)
#define idsWabNotFound                  (STR_FIRST + 2020)
#define idsTelFail                      (STR_FIRST + 2021)

// Strings PArt II 
#define idsMsgrEmptyList                (STR_FIRST + 2477)
#define idsInstallText                  (STR_FIRST + 2478)
#define idsClickText                    (STR_FIRST + 2479)
#define idsAttemptText                  (STR_FIRST + 2480)
#define idsWaitText                     (STR_FIRST + 2481)
#define idsHome                         (STR_FIRST + 2482)
#define idsWork                         (STR_FIRST + 2483)
#define idsMobile                       (STR_FIRST + 2484)
#define idsIPPhone                      (STR_FIRST + 2485)
#define idsLeftBr                       (STR_FIRST + 2486)
#define idsRightBr                      (STR_FIRST + 2487)
#define idsTitle                        (STR_FIRST + 2488)
#define idsButtontext                   (STR_FIRST + 2489)
#define idsMSNEmptyList                 (STR_FIRST + 2490)
#define idsToolBar                      (STR_FIRST + 2491)


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Bitmap Resource IDs
//
#define idbAddrBookHot                 47

// BL Dialogs
#define iddWabExt                     182

// Strings
#define IDS_PROJNAME                    300
#define IDS_ADDBUDDY                    301
#define IDS_SENDMSG                     302

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        500
#define _APS_NEXT_COMMAND_VALUE         32783
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\iecont\resdll\makefile.inc ===
BLCTL_RC_DEPENDS = ..\blctl.rc \
		   ..\blctl.ico \
		   ..\blframe.ico \
		   ..\blframehot.ico \
		   ..\abhot.bmp \
		   ..\face.bmp

..\blctl.rc : $(O)\bactrl.tlb 

$O\blctl.res : $(BLCTL_RC_DEPENDS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\abimport.h ===
#ifndef _INC_ABIMPORT_H
#define _INC_ABIMPORT_H

HRESULT HrImportAB(HWND hWndParent, LPTSTR lpszfnImport);

#endif // _INC_ABIMPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDBCS_DIVIDE
WIN32_IE_VERSION=0x0500

INCLUDES=\
     $(R); \
     $(R)\pch; \
     $(ATHROOT)\mailnews\inc; \
     $(ATHROOT)\mailnews\inc\$(O); \
     $(ATHROOT)\msoeres; \
     $(ATHROOT)\mailnews\common; \
     $(ATHROOT)\mailnews\extinc; \
     $(BASEDIR)\private\windows\inc; \
     $(ATHROOT)\directdb\inc; \
     $(ATHROOT)\directdb\inc\$(O); \
     $(INCLUDES)

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

#PRECOMPILED_INCLUDE=$(R)\pch.hxx
PRECOMPILED_CXX=1

PRECOMPILED_OPTION=/Yupch.hxx /Fp$R\pch\$(_OBJ_DIR)\*\pch.pch
PRECOMPILED_TARGET=$(R)\pch\$(_OBJ_DIR)\*\pch.pch

#PRECOMPILED_OPTION=/Yupch.hxx /Fppch.pch
#PRECOMPILED_TARGET=pch.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\comconv.h ===
#ifndef _INC_COMCONV_H
#define _INC_COMCONV_H

enum
    {
    NETSCAPE = 1,
    EUDORA,
	COMMUNICATOR
    };

BOOL ValidStoreDirectory(char *szPath, int program);
HRESULT GetClientDir(char *szDir, int cch, int program);
HRESULT DispDialog(HWND hwnd, char *pathname, int cch);
BOOL GetStorePath(char *szProfile, char *szStorePath, DWORD cchStorePath);

#endif // _INC_COMCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\comconv.cpp ===
#include "pch.hxx"
#include <iert.h>
#include <mapi.h>
#include <mapix.h>
#include <impapi.h>
#include <newimp.h>
#include "import.h"
#include "comconv.h"
#include "strconst.h"
#include "demand.h"

extern HRESULT GetCommunicatorDirectory(char *szUser, char *szDir, int cch);

int BrowseCallbackProc(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData);
BOOL GetVersion(TCHAR *szFile, DWORD *pdwHigh, DWORD *pdwLow);

HRESULT DispDialog(HWND hwnd, TCHAR *pathname, int cch)
    {
    BROWSEINFO browse;
    BOOL fRet;
    TCHAR szBuffer[CCHMAX_STRINGRES], szPath[MAX_PATH];
    LPITEMIDLIST lpitemid;

    Assert(cch >= MAX_PATH);

    LoadString(g_hInstImp, idsBrowseFolderText, szBuffer, ARRAYSIZE(szBuffer));

    browse.hwndOwner = hwnd;      
    browse.pidlRoot = NULL; 
    browse.pszDisplayName = szPath;
    browse.lpszTitle = szBuffer;        
    browse.ulFlags = BIF_RETURNONLYFSDIRS | BIF_DONTGOBELOWDOMAIN;           
    browse.lpfn = BrowseCallbackProc;
    browse.lParam = (*pathname != 0) ? (LPARAM)pathname : NULL;

	if ((lpitemid = SHBrowseForFolder(&browse)) == NULL)
		return(S_FALSE);
	
    Assert(lpitemid != NULL);

    fRet = SHGetPathFromIDList(lpitemid, szPath);
    SHFree(lpitemid);
    if (!fRet)
		return(E_FAIL);
	
    StrCpyN(pathname, szPath, cch);

	return(S_OK);
    }

int BrowseCallbackProc(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
    {
    if (msg == BFFM_INITIALIZED && lpData != NULL)
        SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);

    return(0);
    }


HRESULT GetClientDir(char *szDir, int cch, int program)
{
	HKEY hkResult;
    DWORD cb, dwMs, dwLs, dwType;
    HRESULT hr;
    char sz[MAX_PATH * 2], szExpanded[MAX_PATH*2], *szT, *pszTok;

    Assert(cch >= MAX_PATH);
    Assert(program == EUDORA || program == NETSCAPE || program == COMMUNICATOR);

    hr = E_FAIL;
    pszTok = sz;

	switch(program)
	{
		case EUDORA:
			{
				if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szEudoraCommand, 0, KEY_QUERY_VALUE, &hkResult))
				{
					cb = sizeof(sz);
                    if (ERROR_SUCCESS == RegQueryValueEx(hkResult, c_szCurrent, NULL, &dwType, (LPBYTE)sz, &cb))
					{
						if (REG_EXPAND_SZ == dwType)
                        {
                            ExpandEnvironmentStrings(sz, szExpanded, ARRAYSIZE(szExpanded));
                            pszTok = szExpanded;
                        }
                        
                        // TODO: check if user is running version 4 or higher...
						szT = StrTokEx(&pszTok, c_szSpace);
						if (szT != NULL && GetVersion(szT, &dwMs, &dwLs) && dwMs <= 0x00040000)
						{
                            szT = StrTokEx(&pszTok, c_szSpace);
							if (szT != NULL)
							{
						
                                StrCpyN(szDir, szT, cch);
								hr = S_OK;
							}
						}
					}
					RegCloseKey(hkResult);
				}
				break;
			}

		case NETSCAPE:
			{
				if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szNetscapeKey, 0, KEY_QUERY_VALUE, &hkResult))
				{
					cb = cch;
                    if (ERROR_SUCCESS == RegQueryValueEx(hkResult, c_szMailDirectory, NULL, &dwType, (LPBYTE)szDir, &cb))
					{
						if (REG_EXPAND_SZ == dwType)
                        {
                            ExpandEnvironmentStrings(szDir, szExpanded, ARRAYSIZE(szExpanded));
                            StrCpyN(szDir, szExpanded, cch);
                        }
                        
                        // TODO: check if user is running version 4 or higher...
						hr = S_OK;
					}
					RegCloseKey(hkResult);
				}
				if (hr != S_OK)
				{
					// try to find 16-bit nscp
					cb = GetProfileString(c_szNetscape, c_szIni, c_szEmpty, sz, ARRAYSIZE(sz));
					if (cb > 0)
					{
						cb = GetPrivateProfileString(c_szMail, c_szMailDirectory, c_szEmpty, szDir, cch, sz);
						if (cb > 0)
							hr = S_OK;
					}
				}
				break;
			}
    
		case COMMUNICATOR:
            hr = GetCommunicatorDirectory(NULL, szDir, cch);
            break;

		default:
			//We NEVER come here
			break;
	}
    return(hr);
}

BOOL ValidStoreDirectory(TCHAR *szPath, int program)
    {
    int cch;
    HANDLE hnd;
    TCHAR *szValid, sz[MAX_PATH];
    WIN32_FIND_DATA data;

    StrCpyN(sz, szPath, ARRAYSIZE(sz));
    cch = lstrlen(sz);
    Assert(cch > 0);
    if (sz[cch - 1] != '\\')
        {
        sz[cch] = '\\';
        cch++;
        sz[cch] = 0;
        }
    
    szValid = (program == EUDORA ? (TCHAR *)c_szDescmapPce : (TCHAR *)c_szSnmExt);
    StrCpyN(&sz[cch], szValid, ARRAYSIZE(sz)-cch);

    hnd = FindFirstFile(sz, &data);
    if (hnd != INVALID_HANDLE_VALUE)
        FindClose(hnd);

    return(hnd == INVALID_HANDLE_VALUE ? FALSE : TRUE);
    }

BOOL GetVersion(TCHAR *szFile, DWORD *pdwHigh, DWORD *pdwLow)
    {
    BOOL fRet;
    LPSTR lpInfo;
    UINT uLen;
    DWORD dwVerInfoSize, dwVerHnd;
    VS_FIXEDFILEINFO *pinfo;

    Assert(szFile != NULL);
    Assert(pdwHigh != NULL);
    Assert(pdwLow != NULL);

    fRet = FALSE;

	if (dwVerInfoSize = GetFileVersionInfoSize(szFile, &dwVerHnd))
        {
        if (MemAlloc((void **)&lpInfo, dwVerInfoSize))
            {
			if (GetFileVersionInfo(szFile, dwVerHnd, dwVerInfoSize, lpInfo))
                {
                if (VerQueryValue(lpInfo, "\\", (LPVOID *)&pinfo, &uLen) && 
                    uLen == sizeof(VS_FIXEDFILEINFO))
                    {
                    *pdwHigh = pinfo->dwProductVersionMS;
                    *pdwLow = pinfo->dwProductVersionLS;
                    fRet = TRUE;
                    }
                }

            MemFree(lpInfo);
            }
        }

    return(fRet);
    }


BOOL GetStorePath(char *szProfile, char *szStorePath, DWORD cchStorePath)
{
	char	szTemp[MAX_PATH * 2];
	char	szDirpath[250];
	char	szLine[1000];
	char	szCompare[1000];
	int		nLine					=	0;
	int		nPosition				=	0;
	HANDLE	hJSHandle				=	NULL;
	HANDLE	hJSFile					=	NULL;
	ULONG	cbJSFile				=	0;

	BYTE	*pBegin					=	NULL, 
			*pCurr					=	NULL, 
			*pEnd					=	NULL;
			
	BOOL	bFoundEntry				=	FALSE;

	StrCpyN(szTemp, szProfile, ARRAYSIZE(szTemp));
	StrCatBuff(szTemp, c_szScriptFile, ARRAYSIZE(szTemp));

	hJSHandle = CreateFile( szTemp, GENERIC_READ, FILE_SHARE_READ, NULL, 
							OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

	if(hJSHandle == INVALID_HANDLE_VALUE)
		return FALSE;

	cbJSFile = GetFileSize(hJSHandle, NULL);

	hJSFile = CreateFileMapping(hJSHandle, NULL, PAGE_READONLY, 0, 0, NULL);

	if(hJSFile == NULL)
    {
        CloseHandle(hJSHandle);        
        return FALSE;
    }

	pBegin = (BYTE *)MapViewOfFile( hJSFile, FILE_MAP_READ, 0, 0, 0);

	if(pBegin == NULL)
    {
        CloseHandle(hJSHandle);
        CloseHandle(hJSFile);
        return FALSE;
    }

	pCurr = pBegin;
	pEnd = pCurr + cbJSFile;
	
	while (pCurr < pEnd)
	{
		szLine[nLine] = *pCurr; //keep storing here. will be used for comparing later. 
		if((pCurr[0] == 0x0D) && (pCurr[1] == 0x0A))
		{
			if(nLine > lstrlen(c_szUserPref))
			{
				StrCpyN(szCompare, szLine, (int)(min(lstrlen(c_szUserPref) + 1, ARRAYSIZE(szCompare))));
				if(lstrcmp(szCompare, c_szUserPref) == 0)//Found a UserPref for "mail.directory"!
				{
					//Extract the Mail Store directory.
					nPosition	=	lstrlen(c_szUserPref);
					
					while (((szLine[nPosition] == '"')||(szLine[nPosition] == ' ')||(szLine[nPosition] == ',')) &&(nPosition < nLine))
						nPosition++;
					StrCpyN(szDirpath, &szLine[nPosition], (int)(min(nLine - nPosition, ARRAYSIZE(szDirpath))));

					//Now trim the trailing edge!!!

					nPosition	=	lstrlen(szDirpath) - 1;
					while((szDirpath[nPosition] == '"') || (szDirpath[nPosition] == ')')||(szDirpath[nPosition] == ';')) 
					{
						szDirpath[nPosition] = '\0';
						nPosition	=	lstrlen(szDirpath) - 1;
					}
					// Now replace the double backslashes that Netscape uses 
					// in the JaveScript files, with a single backslash.

					nPosition++; // this now indicates the actual length of the string.

					int nPos = 0;
					for (int nCount = 0; (nCount < nPosition) && (nPos < (int)cchStorePath); nCount++)
					{
						if ((szDirpath[nCount - 1] == '\\') && (szDirpath[nCount] == '\\'))
							nCount++;
						szStorePath[nPos] = szDirpath[nCount];
						nPos++;
					}
					bFoundEntry = TRUE;
					break;
				}
			}
			nLine = -1; //the nLine++ that follows will make nLine zero.
			pCurr++;
		}
		pCurr++;
		nLine++;
	}

    if(hJSHandle != INVALID_HANDLE_VALUE)
        CloseHandle(hJSHandle);

    if(pBegin)
        UnmapViewOfFile(pBegin);

    if(hJSFile)
        CloseHandle(hJSFile);

	if(bFoundEntry)
		return TRUE;
	else
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\abimport.cpp ===
/*
*
* ABImport.c - Code for calling WABIMP.dll to import
*           Netscape and Eudora files into WAB
*
* Assumes this will be compiled with wab32.lib, else need to
* loadlibrary("wab32.dll") and call GetProcAddress("WABOpen");
*
* Exported functions:
*   HrImportNetscapeAB() - Imports Netscape AB into WAB
*   HrImportEudoraAB() - Imports Eudora AB into WAB
*
* Rough cut - vikramm 4/3/97
*
*/

#include "pch.hxx"
#include <wab.h>
#include <wabmig.h>
#include "abimport.h"
#include <impapi.h>
#include <newimp.h>
#include "import.h"
#include "strconst.h"

HRESULT HrImportAB(HWND hWndParent, LPTSTR lpszfnImport);

static CImpProgress *g_pProgress = NULL;
static TCHAR g_szABFmt[CCHMAX_STRINGRES];

/*
*
* ProgressCallback
*
* This is the call back function that updates the progress bar
*
* In the function below, IDC_Progress is the ID of the progress
* bar that will be updated and IDC_MEssage is the ID of the
* static that will display text returned from the WABImp.Dll
* Replace these 2 ids with your own ids...
*
*/
HRESULT ProgressCallback(HWND hwnd, LPWAB_PROGRESS lpProgress)
    {
    TCHAR sz[CCHMAX_STRINGRES];

    Assert(g_pProgress != NULL);

    if (lpProgress->denominator)
        {
        if (lpProgress->numerator == 0)
            {
            g_pProgress->Reset();
            g_pProgress->AdjustMax(lpProgress->denominator);
            }

        wnsprintf(sz, ARRAYSIZE(sz), g_szABFmt, lpProgress->numerator + 1, lpProgress->denominator);
        g_pProgress->SetMsg(sz, IDC_MESSAGE_STATIC);

        g_pProgress->HrUpdate(1);
        }

    return(S_OK);
    }


// ===========================================================================
// HrLoadLibraryWabDLL -
// ===========================================================================
HINSTANCE LoadLibraryWabDLL (VOID)
{
    TCHAR  szDll[MAX_PATH];
    TCHAR  szExpand[MAX_PATH];
    LPTSTR psz;
    DWORD  dwType = 0;
    HKEY hKey;
    ULONG  cbData = sizeof(szDll);
    
    *szDll = '\0';

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszWABDLLRegPathKey, 0, KEY_READ, &hKey))
        {
        if (ERROR_SUCCESS == RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szDll, &cbData))
            if (REG_EXPAND_SZ == dwType)
                {
                ExpandEnvironmentStrings(szDll, szExpand, ARRAYSIZE(szExpand));
                psz = szExpand;
                }
            else
                psz = szDll;

        RegCloseKey(hKey);
        }

    if(!lstrlen(psz))
        StrCpyN(psz, WAB_DLL_NAME, MAX_PATH);

    return(LoadLibrary(psz));
}


/*
*
*
* HrImportAB
*
* Calls the relevant DLL proc and imports corresponding AB
*
*/
HRESULT HrImportAB(HWND hWndParent, LPTSTR lpszfnImport)
{
    TCHAR sz[CCHMAX_STRINGRES];
    HINSTANCE hinstWabDll;
    LPWABOPEN lpfnWABOpen;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBookWAB = NULL;

    HRESULT hResult;
    BOOL fFinished = FALSE;
    LPWAB_IMPORT lpfnWABImport = NULL;
    HINSTANCE hinstImportDll = NULL;
    WAB_IMPORT_OPTIONS ImportOptions;

    ZeroMemory(&ImportOptions, sizeof(WAB_IMPORT_OPTIONS));

    hinstWabDll = LoadLibraryWabDLL();

    if (hinstWabDll == NULL)
        return(MAPI_E_NOT_INITIALIZED);

    lpfnWABOpen = (LPWABOPEN)GetProcAddress(hinstWabDll, szWabOpen);
    if (lpfnWABOpen == NULL)
        {
        hResult = MAPI_E_NOT_INITIALIZED;
        goto out;
        }

    hinstImportDll = LoadLibrary(szImportDll);

    if(!hinstImportDll)
    {
        hResult = MAPI_E_NOT_INITIALIZED;
        goto out;
    }

    if (! (lpfnWABImport = (LPWAB_IMPORT) GetProcAddress(hinstImportDll,lpszfnImport)))
    {
        hResult = MAPI_E_NOT_INITIALIZED;
        goto out;
    }

    // Flags that can be passed to the WABImp DLL
    //
    ImportOptions.fNoErrors = FALSE; // Display Pop up errors
    ImportOptions.ReplaceOption = WAB_REPLACE_PROMPT; //Prompt user before replacing contacts


    if(hResult = lpfnWABOpen(&lpAdrBookWAB, &lpWABObject, NULL, 0))
        goto out;

    g_pProgress = new CImpProgress;
    if (g_pProgress == NULL)
        {
        hResult = E_OUTOFMEMORY;
        goto out;
        }

    g_pProgress->Init(hWndParent, FALSE);

    LoadString(g_hInstImp, idsImportingABFmt, g_szABFmt, ARRAYSIZE(g_szABFmt));

    LoadString(g_hInstImp, idsImportABTitle, sz, ARRAYSIZE(sz));
    g_pProgress->SetTitle(sz);

    LoadString(g_hInstImp, idsImportAB, sz, ARRAYSIZE(sz));
    g_pProgress->SetMsg(sz, IDC_FOLDER_STATIC);

    g_pProgress->Show(0);

    hResult = lpfnWABImport(hWndParent,
                              lpAdrBookWAB,
                              lpWABObject,
                              (LPWAB_PROGRESS_CALLBACK)&ProgressCallback,
                              &ImportOptions);
    if (hResult == MAPI_E_USER_CANCEL)
    {
        hResult = hrUserCancel;
    }
    else if (FAILED(hResult))
    {
        ImpMessageBox( hWndParent,
                    MAKEINTRESOURCE(idsImportTitle),
                    MAKEINTRESOURCE(idsABImportError),
                    NULL,
                    MB_OK | MB_ICONEXCLAMATION );
    }

out:
    if (g_pProgress != NULL)
        {
        g_pProgress->Release();
        g_pProgress = NULL;
        }

    if (lpAdrBookWAB)
        lpAdrBookWAB->Release();

    if (lpWABObject)
        lpWABObject->Release();

    if(hinstImportDll)
        FreeLibrary(hinstImportDll);

    FreeLibrary(hinstImportDll);

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\dllmain.h ===
// --------------------------------------------------------------------------------
// Dllmain.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __DLLMAIN_H
#define __DLLMAIN_H

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern CRITICAL_SECTION     g_csDllMain;
extern LONG                 g_cRef;
extern LONG                 g_cLock;
extern HINSTANCE            g_hInstImp;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
ULONG DllAddRef(void);
ULONG DllRelease(void);

#include "demand.h"

#endif // __DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\dllmain.cpp ===
#include "pch.hxx"
#define DEFINE_STRING_CONSTANTS
#include <commctrl.h>
#include "dllmain.h"
#include "shared.h"
#include "strconst.h"
#include "demand.h"

#define ICC_FLAGS (ICC_LISTVIEW_CLASSES|ICC_PROGRESS_CLASS|ICC_NATIVEFNTCTL_CLASS)

// --------------------------------------------------------------------------------
// Globals - Object count and lock count
// --------------------------------------------------------------------------------
CRITICAL_SECTION    g_csDllMain = {0};
LONG                g_cRef = 0;
LONG                g_cLock = 0;
HINSTANCE           g_hInstImp = NULL;
LPMALLOC            g_pMalloc = NULL;

SYSTEM_INFO                     g_SystemInfo={0};
OSVERSIONINFO					g_OSInfo={0};
BOOL                g_fAttached = FALSE;

inline BOOL fIsNT5()        { return((g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_OSInfo.dwMajorVersion >= 5)); }

// --------------------------------------------------------------------------------
// Debug Globals
// --------------------------------------------------------------------------------
#ifdef DEBUG
DWORD               dwDOUTLevel=0;
DWORD               dwDOUTLMod=0;
DWORD               dwDOUTLModLevel=0;
#endif

static HINSTANCE s_hInst = NULL;

// --------------------------------------------------------------------------------
// InitGlobalVars
// --------------------------------------------------------------------------------
void InitGlobalVars(void)
{
    INITCOMMONCONTROLSEX    icex = { sizeof(icex), ICC_FLAGS };

    // Initialize Global Critical Sections
    InitializeCriticalSection(&g_csDllMain);
    g_fAttached = TRUE;

	// Create OLE Task Memory Allocator
	CoGetMalloc(1, &g_pMalloc);
	Assert(g_pMalloc);

    // Initialize Demand-loaded Libs
    InitDemandLoadedLibs();

    InitCommonControlsEx(&icex);
}

// --------------------------------------------------------------------------------
// FreeGlobalVars
// --------------------------------------------------------------------------------
void FreeGlobalVars(void)
{   
    // Free libraries that demand.cpp loaded
    FreeDemandLoadedLibs();

    // Release Global Memory allocator
	SafeRelease(g_pMalloc);

	// Delete Global Critical Sections
    g_fAttached = FALSE;
    DeleteCriticalSection(&g_csDllMain);
}

// --------------------------------------------------------------------------------
// Dll Entry Point
// --------------------------------------------------------------------------------
int APIENTRY DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Handle Attach - detach reason
    switch (dwReason)                 
    {
    case DLL_PROCESS_ATTACH:
	    // Set global instance handle

        s_hInst = hInst;

        // Initialize Global Variables
		InitGlobalVars();
	    
        g_hInstImp = LoadLangDll(s_hInst, c_szOEResDll, fIsNT5());

        // No Thread Attach Stuff
        // SideAssert(DisableThreadLibraryCalls(hInst));

		// Done
        break;

    case DLL_PROCESS_DETACH:
		// Free Global Variables
		FreeGlobalVars();

        // Done
	    break;
    }

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    InterlockedIncrement(&g_cRef);
    return g_cRef;
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    InterlockedDecrement(&g_cRef);
    return g_cRef;
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;

    if(!g_fAttached)    // critacal sections was deleted (or not created): we defently can be unloaded
        return S_OK;

    EnterCriticalSection(&g_csDllMain);
    DebugTrace("DllCanUnloadNow: %s - Reference Count: %d, LockServer Count: %d\n", __FILE__, g_cRef, g_cLock);
    hr = (0 == g_cRef && 0 == g_cLock) ? S_OK : S_FALSE;
    LeaveCriticalSection(&g_csDllMain);
    return hr;
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr;
    hr = CallRegInstall(s_hInst, s_hInst, c_szReg, NULL);
    return(hr);
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    hr = CallRegInstall(s_hInst, s_hInst, c_szUnReg, NULL);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\export.cpp ===
#include "pch.hxx"
#include <mapi.h>
#include <mapix.h>
#include <newimp.h>
#include <impapi.h>
#include "import.h"
#include <imnapi.h>
#include <mapiconv.h>
#include "strconst.h"

ASSERTDATA

static IMAPISession *s_pmapiExp = NULL;

PFNEXPGETFIRSTIMSG      g_pExpGetFirstImsg = 0;
PFNEXPGETNEXTIMSG       g_pExpGetNextImsg = 0;
PFNEXPGETIMSGCLOSE      g_pExpGetImsgClose = 0;
PFNEXPGETFOLDERLIST     g_pExpGetFolderList = 0;
PFNEXPFREEFOLDERLIST    g_pExpFreeFolderList = 0;
PFNFREEIMSG             g_pFreeImsg = 0;

#undef ExpGetFirstImsg
#undef ExpGetNextImsg
#undef ExpGetImsgClose
#undef ExpGetFolderList
#undef ExpFreeFolderList
#undef FreeImsg

#define ExpGetFirstImsg     (*g_pExpGetFirstImsg)
#define ExpGetNextImsg      (*g_pExpGetNextImsg)
#define ExpGetImsgClose     (*g_pExpGetImsgClose)
#define ExpGetFolderList    (*g_pExpGetFolderList)
#define ExpFreeFolderList   (*g_pExpFreeFolderList)
#define FreeImsg            (*g_pFreeImsg)

INT_PTR CALLBACK ExportDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL PerformExport(HWND hwnd, IMPFOLDERNODE **ppnode, int cnode, IMPFOLDERNODE *plist);
HRESULT ExportFolder(TCHAR *szName, LPMAPIFOLDER pfldr, HANDLE hfolder, ULONG cMsg, CImpProgress *pProg);
HRESULT GetExportFolders(HWND hwndList, BOOL fSel, IMPFOLDERNODE ***pplist, int *pcnode);
HRESULT HrGetFolder(LPMAPIFOLDER lpParent, LPSTR szName, LPMAPIFOLDER *lplpFldr, BOOL *pfDidCreate);
INT_PTR CALLBACK ExportProgressDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

HRESULT ExportMessages(HWND hwnd)
    {
    HRESULT hr;
    int iret;
    BOOL fInit;
    HMODULE hinst;
    IMPFOLDERNODE *plist;

    hr = E_FAIL;
    fInit = FALSE;

    hinst = LoadLibrary(c_szMainDll);
    if (hinst != NULL)
        {
        g_pExpGetFirstImsg = (PFNEXPGETFIRSTIMSG)GetProcAddress(hinst, MAKEINTRESOURCE(9));
        g_pExpGetNextImsg = (PFNEXPGETNEXTIMSG)GetProcAddress(hinst, MAKEINTRESOURCE(10));
        g_pExpGetImsgClose = (PFNEXPGETIMSGCLOSE)GetProcAddress(hinst, MAKEINTRESOURCE(11));
        g_pExpGetFolderList = (PFNEXPGETFOLDERLIST)GetProcAddress(hinst, MAKEINTRESOURCE(12));
        g_pExpFreeFolderList = (PFNEXPFREEFOLDERLIST)GetProcAddress(hinst, MAKEINTRESOURCE(13));
        g_pFreeImsg = (PFNFREEIMSG)GetProcAddress(hinst, MAKEINTRESOURCE(14));
        if (g_pExpGetFirstImsg != NULL &&
            g_pExpGetNextImsg != NULL &&
            g_pExpGetImsgClose != NULL &&
            g_pExpGetFolderList != NULL &&
            g_pExpFreeFolderList != NULL &&
            g_pFreeImsg != NULL)
            {
            fInit = TRUE;

            iret = (int) ImpMessageBox(hwnd, MAKEINTRESOURCE(idsExportTitle),
                            MAKEINTRESOURCE(idsPerformExport), NULL, MB_OKCANCEL | MB_ICONINFORMATION);
            if (iret == IDOK)
                {
                hr = ExchInit();
                if (SUCCEEDED(hr))
                    {
                    Assert(s_pmapiExp == NULL);
                    hr = MapiLogon(hwnd, &s_pmapiExp);
                    if (hr == S_OK)
                        {
                        Assert(s_pmapiExp != NULL);

                        hr = ExpGetFolderList(&plist);
                        if (SUCCEEDED(hr))
                            {
                            iret = (int) DialogBoxParam(g_hInstImp, MAKEINTRESOURCE(iddExport), hwnd,
                                                    ExportDlgProc, (LPARAM)plist);

                            ExpFreeFolderList(plist);
                            }

                        s_pmapiExp->Logoff(NULL, 0, 0);
                        s_pmapiExp = NULL;
                        }

                    ExchDeinit();
                    }
                else if (hr == MAPI_E_USER_CANCEL)
                    {
                    hr = S_OK;
                    }
                else
                    {
                    ImpMessageBox(hwnd, MAKEINTRESOURCE(idsExportTitle),
                        MAKEINTRESOURCE(idsExportError), MAKEINTRESOURCE(idsMAPIInitError),
                        MB_OK | MB_ICONSTOP);
                    }
                }
            else if (iret == IDCANCEL)
                {
                hr = S_OK;
                }
            }

        FreeLibrary(hinst);
        }

    if (!fInit)
    {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsExportTitle),
            MAKEINTRESOURCE(idsExportError), MAKEINTRESOURCE(idsMapiInitError),
            MB_OK | MB_ICONSTOP);
    }

    return(hr);
    }

INT_PTR CALLBACK ExportDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
    int id, cnode;
    BOOL fRet;
    HWND hwndList;
    HRESULT hr;
    IMPFOLDERNODE *plist, **ppnode;
    TCHAR sz[256];
    HCURSOR hcur = 0;

    fRet = TRUE;
    hwndList = GetDlgItem(hwnd, IDC_IMPFOLDER_LISTVIEW);
    plist = (IMPFOLDERNODE *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (msg)
        {
        case WM_INITDIALOG:
            plist = (IMPFOLDERNODE *)lParam;
            Assert(plist != NULL);
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)plist);

            InitListViewImages(hwndList);
            FillFolderListview(hwndList, plist, NULL);

            SendDlgItemMessage(hwnd, IDC_IMPORTALL_RADIO, BM_SETCHECK, BST_CHECKED, 0);
            EnableWindow(GetDlgItem(hwnd, IDC_IMPFOLDER_LISTVIEW), FALSE);
            break;

        case WM_COMMAND:
            id = LOWORD(wParam);

            switch (id)
                {
                case IDOK:
                    fRet = (BST_CHECKED == SendDlgItemMessage(hwnd, IDC_SELECT_RADIO, BM_GETCHECK, 0, 0));

                    plist = (IMPFOLDERNODE *)GetWindowLongPtr(hwnd, DWLP_USER);
                    Assert(plist != NULL);

                    hr = GetExportFolders(hwndList, fRet, &ppnode, &cnode);
                    if (SUCCEEDED(hr) && cnode > 0)
                        {
                        hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
                        
                        fRet = PerformExport(hwnd, ppnode, cnode, plist);

                        if (ppnode != NULL)
                            MemFree(ppnode);

                        SetCursor(hcur);
                        }

                    // fall through...

                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    break;

                case IDC_IMPORTALL_RADIO:
                case IDC_SELECT_RADIO:
                    if (HIWORD(wParam) == BN_CLICKED)
                        EnableWindow(hwndList, id == IDC_SELECT_RADIO);
                    break;
                }
            break;

        default:
            fRet = FALSE;
            break;
        }

    return(fRet);
    }

void ReleaseMapiFolders(IMPFOLDERNODE *plist)
    {
    while (plist != NULL)
        {
        if (plist->dwReserved != NULL)
            {
            ((LPMAPIFOLDER)plist->dwReserved)->Release();
            plist->dwReserved = NULL;
            }
        if (plist->pchild != NULL)
            ReleaseMapiFolders(plist->pchild);
        plist = plist->pnext;
        }
    }

BOOL PerformExport(HWND hwnd, IMPFOLDERNODE **ppnode, int cnode, IMPFOLDERNODE *plist)
    {
    CImpProgress *pProg;
    IMPFOLDERNODE *pnode, *pnodeT;
    int inode;
    LPMAPICONTAINER pcont;
    LPMAPIFOLDER pfldrRoot, pfldrParent, pfldr;
    HRESULT hr;

    Assert(cnode > 0);
    Assert(ppnode != NULL);
    Assert(plist != NULL);

    pProg = new CImpProgress;
    if (pProg == NULL)
        {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsExportTitle),
            MAKEINTRESOURCE(idsExportError), MAKEINTRESOURCE(idsMemory),
            MB_OK | MB_ICONSTOP);

        return(FALSE);
        }

    Assert(s_pmapiExp != NULL);
    pcont = OpenDefaultStoreContainer(hwnd, s_pmapiExp);
    if (pcont == NULL)
        {
        hr = E_OUTOFMEMORY;
        }
    else
        {
        hr = pcont->QueryInterface(IID_IMAPIFolder, (void **)&pfldrRoot);
        pcont->Release();
        }

    if (FAILED(hr))
        {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsExportTitle),
            MAKEINTRESOURCE(idsExportError), MAKEINTRESOURCE(idsMAPIStoreOpenError),
            MB_OK | MB_ICONSTOP);

        return(FALSE);
        }

    pProg->Init(hwnd, TRUE);
    pProg->SetTitle(MAKEINTRESOURCE(idsExportTitle));

    for (inode = 0; inode < cnode; inode++)
        {
        pnode = ppnode[inode];
        Assert(pnode != NULL);

        pfldrParent = NULL;
        pnodeT = pnode->pparent;
        while (pnodeT != NULL)
            {
            if (pnodeT->dwReserved != NULL)
                {
                pfldrParent = (LPMAPIFOLDER)pnodeT->dwReserved;
                break;
                }
            pnodeT = pnodeT->pparent;
            }
        if (pfldrParent == NULL)
            {
            pfldrParent = pfldrRoot;
            ReleaseMapiFolders(plist);
            }

        hr = HrGetFolder(pfldrParent, pnode->szName, &pfldr, NULL);
        if (!FAILED(hr))
            hr = ExportFolder(pnode->szName, pfldr, (HANDLE)pnode->lparam, pnode->cMsg, pProg);

        if(hr == hrUserCancel)
            break;

        Assert(pnode->dwReserved == NULL);
        pnode->dwReserved = (DWORD_PTR)pfldr;
        }

    pProg->Release();

    ReleaseMapiFolders(plist);
    pfldrRoot->Release();

    return(TRUE);
    }

HRESULT GetExportFolders(HWND hwndList, BOOL fSel, IMPFOLDERNODE ***pplist, int *pcnode)
    {
    int cSel, ili;
    IMPFOLDERNODE **ppnode, **ppnodeT;
    LV_ITEM lvi;

    Assert(pplist != NULL);
    Assert(pcnode != NULL);

    *pplist = NULL;
    *pcnode = 0;

    cSel = (int) SendMessage(hwndList, (fSel ? LVM_GETSELECTEDCOUNT : LVM_GETITEMCOUNT), 0, 0);
    if (cSel == 0)
        return(S_OK);

    if (!MemAlloc((void **)&ppnode, sizeof(IMPFOLDERNODE *) * cSel))
        return(E_OUTOFMEMORY);
    ppnodeT = ppnode;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;

    cSel = 0;
    ili = -1;
    while (-1 != (ili = ListView_GetNextItem(hwndList, ili, fSel ? LVNI_SELECTED : 0)))
        {
        lvi.iItem = ili;
        if (ListView_GetItem(hwndList, &lvi))
            {
            Assert(lvi.lParam != 0);

            *ppnodeT = (IMPFOLDERNODE *)lvi.lParam;
            cSel++;
            ppnodeT++;
            }
        }

    *pplist = ppnode;
    *pcnode = cSel;

    return(S_OK);
    }

HRESULT HrGetFolder(LPMAPIFOLDER lpParent, LPSTR szName, LPMAPIFOLDER *lplpFldr, BOOL *pfDidCreate)
    {
    SPropValue   pv;
    HRESULT      hr;
    SRestriction sr;
    LPMAPITABLE  lpTable = NULL;
    SizedSPropTagArray(3, ptaFindFldr) = 
        { 3, { PR_ENTRYID,
               PR_DISPLAY_NAME,
               PR_STATUS} };


    pv.ulPropTag = PR_DISPLAY_NAME;
    pv.Value.lpszA = szName;

    *lplpFldr = NULL; // in case we fail

    if (FAILED(hr = lpParent->GetHierarchyTable(0, &lpTable)))
        goto cleanup;

    // Set the table's columns to include PR_MODULE_CLASS so FindRow will work.
    if (HR_FAILED(hr=lpTable->SetColumns((LPSPropTagArray)&ptaFindFldr, 0)))
        {
        // Fn might (?) fail if container is an address book
        // so this might need to change...
        DOUTL(2, "HrGetContainer: SetColumns failed.");
        goto cleanup;
        }

    // Find the container.  If it's not there, then we need to create it

    if (pfDidCreate)
        *pfDidCreate = FALSE;  // default value

    sr.rt = RES_PROPERTY;
    sr.res.resProperty.relop = RELOP_EQ;
    sr.res.resProperty.ulPropTag = pv.ulPropTag;
    sr.res.resProperty.lpProp = &pv;

    if (FAILED(hr = lpTable->FindRow(&sr, BOOKMARK_BEGINNING, 0)))
        {   // folder needs to be created
        hr = lpParent->CreateFolder(FOLDER_GENERIC, szName, NULL, NULL, 0, lplpFldr);
        if (pfDidCreate && SUCCEEDED(hr))
            *pfDidCreate = TRUE;          // a new folder was created
        }
    else
        {
        LPSRowSet       lpRowSet = NULL;
        LPSPropValue    lpProp;
        ULONG           ulObjType;

        if (!FAILED(hr = lpTable->QueryRows(1, TBL_NOADVANCE, &lpRowSet)) && lpRowSet->cRows)
            {
            if (lpProp = PvalFind(lpRowSet->aRow, PR_ENTRYID))
                hr = lpParent->OpenEntry(lpProp->Value.bin.cb, 
                                         (LPENTRYID)lpProp->Value.bin.lpb, 
                                         NULL,
                                         MAPI_MODIFY,
                                         &ulObjType,
                                         (LPUNKNOWN FAR *)lplpFldr);
            }

        FreeSRowSet(lpRowSet);
        }

cleanup:
    if (lpTable)
        lpTable->Release();
    return hr;        
    }

HRESULT ExportFolder(TCHAR *szName, LPMAPIFOLDER pfldr, HANDLE hfolder, ULONG cMsg, CImpProgress *pProg)
    {
    HRESULT hr;
    HANDLE hnd;
    IMSG imsg;
    LPMESSAGE pmsg;
    ULONG iMsg;
    TCHAR sz[128], szT[256];

    LoadString(g_hInstImp, idsExportingFolderFmt, sz, ARRAYSIZE(sz));
    wnsprintf(szT, ARRAYSIZE(szT), sz, szName);

    LoadString(g_hInstImp, idsImportingMessageFmt, sz, ARRAYSIZE(sz));

    iMsg = 0;

    hr = ExpGetFirstImsg(hfolder, &imsg, &hnd);
    while (hr == S_OK)
        {
        if (iMsg == 0)
            {
            pProg->SetMsg(szT, IDC_FOLDER_STATIC);
            pProg->Show(0);

            pProg->Reset();
            pProg->AdjustMax(cMsg);
            }

        wnsprintf(szT, ARRAYSIZE(szT), sz, iMsg + 1, cMsg);
        pProg->SetMsg(szT, IDC_MESSAGE_STATIC);

        hr = pfldr->CreateMessage(NULL, 0, &pmsg);
        if (!FAILED(hr))
            {
            hr = HrImsgToMapi(&imsg, pmsg);

            pmsg->Release();
            }

        FreeImsg(&imsg);

        hr = ExpGetNextImsg(&imsg, hnd);
        if (hr != S_OK)
            break;

        iMsg++;
        hr = pProg->HrUpdate(1);
        }

    ExpGetImsgClose(hnd);

    if (hr == S_FALSE)
        hr = S_OK;

    return(hr);
    }

#define IDT_PROGRESS_DELAY  (WM_USER + 1)

CImpProgress::CImpProgress ()
{
    DOUT ("CImpProgress::CImpProgress");
    m_cRef = 1;
    m_cMax = 0;
    m_cPerCur = 0;
    m_hwndProgress = NULL;
    m_hwndDlg = NULL;
    m_hwndOwner = NULL;
    m_fCanCancel = FALSE;
    m_fHasCancel = FALSE;
}

// =====================================================================================
// CImpProgress::~CImpProgress
// =====================================================================================
CImpProgress::~CImpProgress ()
{
    DOUT ("CImpProgress::~CImpProgress");
    Close();
}

// =====================================================================================
// CImpProgress::AddRef
// =====================================================================================
ULONG CImpProgress::AddRef ()
{
    ++m_cRef;
    DOUT ("CImpProgress::AddRef () Ref Count=%d", m_cRef);
    return m_cRef;
}

// =====================================================================================
// CImpProgress::AddRef
// =====================================================================================
ULONG CImpProgress::Release ()
{
    ULONG ulCount = --m_cRef;
    DOUT ("CImpProgress::Release () Ref Count=%d", ulCount);
    if (!ulCount)
        delete this;
    return ulCount;
}

// =====================================================================================
// CImpProgress::Init
// =====================================================================================
VOID CImpProgress::Init (HWND      hwndParent, BOOL      fCanCancel)
{
    Assert(m_hwndDlg == NULL);

    // Set Max and cur
    m_fCanCancel = fCanCancel;

    // Save Parent
    m_hwndOwner = hwndParent;

    // Disable Parent
    EnableWindow (m_hwndOwner, FALSE);

    // Create Dialog
    m_hwndDlg = CreateDialogParam (g_hInstImp, MAKEINTRESOURCE (iddImpProgress),
                    hwndParent, ProgressDlgProc, (LPARAM)this);
}

// =====================================================================================
// CImpProgress::Close
// =====================================================================================
VOID CImpProgress::Close (VOID)
{
    // If we have a window
    if (m_hwndDlg)
    {
        // Enable parent
        if (m_hwndOwner)
            EnableWindow (m_hwndOwner, TRUE);

        // Destroy it
        DestroyWindow (m_hwndDlg);

        // NULL
        m_hwndDlg = NULL;
    }
}

// =====================================================================================
// CImpProgress::Show
// =====================================================================================
VOID CImpProgress::Show (DWORD dwDelaySeconds)
{
    // If we have a window
    if (m_hwndDlg)
    {
        // Show the window if now delay
        if (dwDelaySeconds == 0)
            ShowWindow (m_hwndDlg, SW_SHOWNORMAL);
        else
            SetTimer(m_hwndDlg, IDT_PROGRESS_DELAY, dwDelaySeconds * 1000, NULL);
    }
}

// =====================================================================================
// CImpProgress::Hide
// =====================================================================================
VOID CImpProgress::Hide (VOID)
{
    // If we have a window
    if (m_hwndDlg)
    {
        // Hide it
        ShowWindow (m_hwndDlg, SW_HIDE);
    }
}

// =====================================================================================
// CImpProgress::SetMsg
// =====================================================================================
VOID CImpProgress::SetMsg(LPTSTR lpszMsg, int id)
{
    TCHAR sz[CCHMAX_STRINGRES];

    if (m_hwndDlg && lpszMsg)
        {
        if (IS_INTRESOURCE(lpszMsg))
            {
            LoadString(g_hInstImp, PtrToUlong(lpszMsg), sz, sizeof(sz) / sizeof(TCHAR));
            lpszMsg = sz;
            }

        SetWindowText (GetDlgItem (m_hwndDlg, id), lpszMsg);
        }
}

// =====================================================================================
// CImpProgress::SetTitle
// =====================================================================================
VOID CImpProgress::SetTitle(LPTSTR lpszTitle)
{
    TCHAR sz[CCHMAX_STRINGRES];

    if (m_hwndDlg && lpszTitle)
        {
        if (IS_INTRESOURCE(lpszTitle))
            {
            LoadString(g_hInstImp, PtrToUlong(lpszTitle), sz, sizeof(sz) / sizeof(TCHAR));
            lpszTitle = sz;
            }

        SetWindowText (m_hwndDlg, lpszTitle);
        }
}

// =====================================================================================
// CImpProgress::AdjustMax
// =====================================================================================
VOID CImpProgress::AdjustMax(ULONG cNewMax)
{
    // Set Max
    m_cMax = cNewMax;

    // If 0
    if (m_cMax == 0)
    {
        SendMessage (m_hwndProgress, PBM_SETPOS, 0, 0);
        ShowWindow(m_hwndProgress, SW_HIDE);
        return;
    }
    else
        ShowWindow(m_hwndProgress, SW_SHOWNORMAL);

    // If cur is now larget than max ?
    if (m_cCur > m_cMax)
        m_cCur = m_cMax;

    // Compute percent
    m_cPerCur = (m_cCur * 100 / m_cMax);

    // Update status
    SendMessage (m_hwndProgress, PBM_SETPOS, m_cPerCur, 0);

    // msgpump to process user moving window, or pressing cancel... :)
    MSG msg;
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

VOID CImpProgress::Reset()
{
    m_cCur = 0;
    m_cPerCur = 0;

    // Update status
    SendMessage (m_hwndProgress, PBM_SETPOS, 0, 0);
}

// =====================================================================================
// CImpProgress::HrUpdate
// =====================================================================================
HRESULT CImpProgress::HrUpdate (ULONG cInc)
{
    // No max
    if (m_cMax) 
    {
        // Increment m_cCur
        m_cCur += cInc;
        
        // If cur is now larget than max ?
        if (m_cCur > m_cMax)
            m_cCur = m_cMax;
        
        // Compute percent
        ULONG cPer = (m_cCur * 100 / m_cMax);
        
        // Step percent
        if (cPer > m_cPerCur)
        {
            // Set percur
            m_cPerCur = cPer;
            
            // Update status
            SendMessage (m_hwndProgress, PBM_SETPOS, m_cPerCur, 0);
            
            // msgpump to process user moving window, or pressing cancel... :)
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    
    // Still pump some messages, call may not want to do this too often
    else
    {
        // msgpump to process user moving window, or pressing cancel... :)
        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    // Done
    return m_fHasCancel ? hrUserCancel : S_OK;
}

// =====================================================================================
// CImpProgress::ProgressDlgProc
// =====================================================================================
INT_PTR CALLBACK CImpProgress::ProgressDlgProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    CImpProgress *lpProgress = (CImpProgress *)GetWndThisPtr(hwnd);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        lpProgress = (CImpProgress *)lParam;
        if (!lpProgress)
        {
            Assert (FALSE);
            return 1;
        }
        lpProgress->m_hwndProgress = GetDlgItem (hwnd, IDC_IMPORT_PROGRESS);
        if (lpProgress->m_cMax == 0)
            ShowWindow(lpProgress->m_hwndProgress, SW_HIDE);

        // Show the cancel button if m_fCanCancel is true.
        if(lpProgress->m_fCanCancel)
            ShowWindow(GetDlgItem(hwnd, IDCANCEL), SW_SHOWNORMAL);

        SetWndThisPtr (hwnd, lpProgress);
        return 1;

    case WM_TIMER:
        if (wParam == IDT_PROGRESS_DELAY)
        {
            KillTimer(hwnd, IDT_PROGRESS_DELAY);
            if (lpProgress->m_cPerCur < 80)
            {
                lpProgress->m_cMax -= lpProgress->m_cCur;
                lpProgress->Reset();
                ShowWindow(hwnd, SW_SHOWNORMAL);
            }
        }
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            if (lpProgress)
            {
                EnableWindow ((HWND)lParam, FALSE);
                lpProgress->m_fHasCancel = TRUE;
            }
            return 1;
        }
        break;

    case WM_DESTROY:
        KillTimer(hwnd, IDT_PROGRESS_DELAY);
        SetWndThisPtr (hwnd, NULL);
        break;
    }

    // Done
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\factory.cpp ===
// --------------------------------------------------------------------------------
// Factory.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "factory.h"
#include <newimp.h>
#include <eudrimp.h>
#include <commimp.h>
#include <mapiconv.h>
#include <netsimp.h>
#include <Impath16.h>
#include <oe4imp.h>

// --------------------------------------------------------------------------------
// Global Object Info Table
// --------------------------------------------------------------------------------
static CClassFactory g_rgFactory[] = {
	CClassFactory(&CLSID_COE4Import,	        0,	(PFCREATEINSTANCE)COE4Import_CreateInstance),
	CClassFactory(&CLSID_CIMN1Import,	        0,	(PFCREATEINSTANCE)COE4Import_CreateInstance),
    CClassFactory(&CLSID_CAthena16Import,		0,	(PFCREATEINSTANCE)CAthena16Import_CreateInstance),
    CClassFactory(&CLSID_CEudoraImport,			0,	(PFCREATEINSTANCE)CEudoraImport_CreateInstance),
    CClassFactory(&CLSID_CExchImport,			0,	(PFCREATEINSTANCE)CExchImport_CreateInstance),
    CClassFactory(&CLSID_CNetscapeImport,		0,	(PFCREATEINSTANCE)CNetscapeImport_CreateInstance),
	CClassFactory(&CLSID_CCommunicatorImport,	0,	(PFCREATEINSTANCE)CCommunicatorImport_CreateInstance),
};

// --------------------------------------------------------------------------------
// DllGetClassObject
// --------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // No memory allocator
    if (NULL == g_pMalloc)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            CHECKHR(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, no class
    hr = TrapError(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::CClassFactory
// --------------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

// --------------------------------------------------------------------------------
// CClassFactory::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // Invalid Arg
    if (NULL == ppvObj)
        return TrapError(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TrapError(E_NOINTERFACE);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    DllAddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CClassFactory::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    DllAddRef();
    return 2;
}

// --------------------------------------------------------------------------------
// CClassFactory::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    DllRelease();
    return 1;
}

// --------------------------------------------------------------------------------
// CClassFactory::CreateInstance
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Bad param
    if (ppvObj == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter)
        return TrapError(CLASS_E_NOAGGREGATION);

    // No memory allocator
    if (NULL == g_pMalloc)
        return TrapError(E_OUTOFMEMORY);

    // Create the object...
    CHECKHR(hr = CreateObjectInstance(pUnkOuter, &pObject));

    // Get the interface requested from pObj
    CHECKHR(hr = pObject->QueryInterface(riid, ppvObj));
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::LockServer
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}

//#ifdef DEAD
HRESULT CAthena16Import_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CAthena16Import *pNew = new CAthena16Import;
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return S_OK;
}
//#endif // DEAD

HRESULT CEudoraImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CEudoraImport *pNew = new CEudoraImport;    
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return S_OK;
}

HRESULT CExchImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CExchImport *pNew = new CExchImport;    
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return S_OK;
}

HRESULT CNetscapeImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CNetscapeImport *pNew = new CNetscapeImport;    
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return S_OK;
}

HRESULT CCommunicatorImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CCommunicatorImport *pNew = new CCommunicatorImport;    
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\newdel.cpp ===
// --------------------------------------------------------------------------------
// Override new  and delete operator
// --------------------------------------------------------------------------------
#include "pch.hxx"

// --------------------------------------------------------------------------------
// Override new operator
// --------------------------------------------------------------------------------
void * __cdecl operator new(UINT cb )
{
    LPVOID  lpv = 0;

    lpv = CoTaskMemAlloc(cb);
#ifdef DEBUG
    if (lpv)
        memset(lpv, 0xca, cb);
#endif // DEBUG
    return lpv;
}

// --------------------------------------------------------------------------------
// Override delete operator
// --------------------------------------------------------------------------------
#ifndef WIN16
void __cdecl operator delete(LPVOID pv )
#else
void __cdecl operator delete(VOID *pv )
#endif
{
    CoTaskMemFree(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\import.h ===
#ifndef _INC_IMPORT_H
#define _INC_IMPORT_H

interface IMAPISession;
#include "resource.h"
#include "impdlg.h" 

extern HINSTANCE        g_hInstImp;

HRESULT ExchInit(void);
void ExchDeinit(void);
HRESULT MapiLogon(HWND hwnd, IMAPISession **ppmapi);

LPMAPICONTAINER OpenDefaultStoreContainer(HWND hwnd, IMAPISession *pmapi);
LPSPropValue PvalFind(LPSRow prw, ULONG ulPropTag);
void FreeSRowSet(LPSRowSet prws);

void ImpErrorMessage(HWND hwnd, LPTSTR szTitle, LPTSTR szError, HRESULT hrDetail);
int ImpMessageBox(HWND hwndOwner, LPTSTR szTitle, LPTSTR sz1, LPTSTR sz2, UINT fuStyle);

void InitListViewImages(HWND hwnd);
void FillFolderListview(HWND hwnd, IMPFOLDERNODE *plist, DWORD_PTR dwReserved);

class CImpProgress
    {
    private:
        ULONG       m_cRef;
        ULONG       m_cMax;
        ULONG       m_cCur;
        ULONG       m_cPerCur;
        HWND        m_hwndProgress;
        HWND        m_hwndDlg;
        HWND        m_hwndOwner;
        BOOL        m_fCanCancel;
        BOOL        m_fHasCancel;

    public:
        CImpProgress ();
        ~CImpProgress ();

        ULONG AddRef ();
        ULONG Release ();

        VOID SetMsg(LPTSTR lpszMsg, int id);
        VOID SetTitle(LPTSTR lpszTitle);
        VOID Show (DWORD dwDelaySeconds=0);
        VOID Hide (VOID);
        VOID Close (VOID);
        VOID AdjustMax(ULONG cNewMax);
        VOID Reset(VOID);
        HRESULT HrUpdate (ULONG cInc);
        static INT_PTR CALLBACK ProgressDlgProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

        VOID Init (HWND hwndParent, BOOL fCanCancel);
    };

#define WM_POSTSETFOCUS (WM_USER + 1)
#define WM_ENABLENEXT   (WM_USER + 2)

typedef struct tagIMPWIZINFO IMPWIZINFO;

INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK MigrateInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK MigrateOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK MigModeInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK MigModeOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK MigIncInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK MigIncOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK ClientInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK ClientOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK LocationInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK LocationOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);
BOOL CALLBACK LocationCmdProc(IMPWIZINFO *,HWND,WPARAM,LPARAM);

BOOL CALLBACK FolderInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK FolderOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK AddressOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK CongratInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK CongratOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

typedef BOOL (CALLBACK* INITPROC)(IMPWIZINFO *,HWND,BOOL);
typedef BOOL (CALLBACK* OKPROC)(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);
typedef BOOL (CALLBACK* CMDPROC)(IMPWIZINFO *,HWND,WPARAM,LPARAM);

typedef struct tagPAGEINFO
    {
    UINT        uDlgID;
    UINT        uHdrID;
    
    // handler procedures for each page-- any of these can be
    // NULL in which case the default behavior is used
    INITPROC    InitProc;
    OKPROC      OKProc;
    CMDPROC     CmdProc;
    } PAGEINFO;

#define NUM_WIZARD_PAGES    8

typedef struct tagMIGRATEINFO
    {
    CLSID clsid;
    UINT idDisplay;
    char *szfnImport;
    } MIGRATEINFO;

#define PAGE_LOCATION   0x0001
#define PAGE_FOLDERS    0x0002
#define PAGE_MODE       0x0004
#define PAGE_ALL        0x0007

typedef struct tagIMPWIZINFO
    {
    IMailImporter *pImporter;

    BOOL dwReload;

    BOOL fMigrate;
    BOOL fMessages;
    BOOL fAddresses;
    MIGRATEINFO *pMigrate;
    UINT cMigrate;
    UINT iMigrate;

    CLSID *pClsid;
    UINT cClsid;
    UINT iClsid;

    BOOL fLocation;
    char szDir[MAX_PATH];
    IMPFOLDERNODE *pList;
    char szClient[CCHMAX_STRINGRES];

    UINT cPagesCompleted;
    UINT idCurrentPage;
    UINT rgHistory[NUM_WIZARD_PAGES];

    IMailImport *pImport;
    } IMPWIZINFO;

typedef struct tagINITWIZINFO
    {
    const PAGEINFO *pPageInfo;
    IMPWIZINFO *pWizInfo;
    } INITWIZINFO;

#endif // _INC_IMPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\factory.h ===
// --------------------------------------------------------------------------------
// Factory.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __FACTORY_H
#define __FACTORY_H

class CClassFactory; // Forward

// --------------------------------------------------------------------------------
// Object Creation Prototypes
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);
#define CreateObjectInstance (*m_pfCreateInstance)

#define SAFECAST(_src, _type) (((_type)(_src)==(_src)?0:0), (_type)(_src))

// --------------------------------------------------------------------------------
// InetComm ClassFactory
// --------------------------------------------------------------------------------
class CClassFactory : public IClassFactory
    {
    public:
        CLSID const        *m_pclsid;
        DWORD               m_dwFlags;
        PFCREATEINSTANCE    m_pfCreateInstance;

        // Construction
        CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IClassFactory members
        STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
        STDMETHODIMP LockServer(BOOL);

        // CClassFactory Members
        void SetObjectIndex(ULONG iObjIndex);
    };

// --------------------------------------------------------------------------------
// Object Creators
// --------------------------------------------------------------------------------
HRESULT CAthena16Import_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT CEudoraImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT CExchImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT CNetscapeImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT CCommunicatorImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);

#endif // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\import.cpp ===
#include "pch.hxx"
#include <prsht.h>
#include <mapi.h>
#include <mapix.h>
#include <comconv.h>
#include "abimport.h"

#define INITGUID
#include <ole2.h>
#include <initguid.h>
#include "newimp.h"
#include <impapi.h>
#include "import.h"
#include <eudrimp.h>
#include <mapiconv.h>
#include <netsimp.h>	//Netscape
#include <commimp.h>	//Communicator
#include <ImpAth16.h>
#include <oe4imp.h>
#include "strconst.h"
#include "demand.h"

ASSERTDATA

#define IDD_NEXT    0x3024

class CFolderImportProg : public IFolderImport
    {
    private:
        ULONG               m_cRef;
        IFolderImport       *m_pImportEx;
        UINT                m_iMsg;
        UINT                m_cMsg;
        CImpProgress        *m_pProgress;
        TCHAR               m_szFldrFmt[CCHMAX_STRINGRES];
        TCHAR               m_szMsgFmt[CCHMAX_STRINGRES];
        TCHAR               m_szFolder[MAX_PATH];

    public:
        CFolderImportProg(void);
        ~CFolderImportProg(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        HRESULT Initialize(HWND hwnd);
        void SetFolder(IFolderImport *pImport, TCHAR *szName, UINT cMsg);
        void ReleaseFolder(void);
        HRESULT UpdateProgress(void);

        STDMETHODIMP SetMessageCount(ULONG cMsg);
        STDMETHODIMP ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach);
        STDMETHODIMP ImportMessage(IMSG *pimsg);
    };

HRESULT GetFolderList(IMailImport *pMailImp, IMPFOLDERNODE **pplist);
void FreeFolderList(IMPFOLDERNODE *plist);
HRESULT ImportFolders(HWND hwnd, IMailImporter *pImporter, IMailImport *pMailImp, IMPFOLDERNODE *plist, CFolderImportProg *pImpProg);
HRESULT DoImportWizard(HWND hwnd, IMPWIZINFO *pinfo);

CFolderImportProg::CFolderImportProg()
    {
    m_cRef = 1;
    m_pImportEx = NULL;
    // m_iMsg
    // m_cMsg
    m_pProgress = NULL;
    // m_szFldrFmt
    // m_szMsgFmt
    // m_szFolder
    }

CFolderImportProg::~CFolderImportProg()
    {
    if (m_pImportEx != NULL)
        m_pImportEx->Release();
    if (m_pProgress != NULL)
        m_pProgress->Release();
    }

ULONG CFolderImportProg::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CFolderImportProg::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CFolderImportProg::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IFolderImport == riid)
		*ppv = (IFolderImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CFolderImportProg::Initialize(HWND hwnd)
    {
    LoadString(g_hInstImp, idsImportingFolderFmt, m_szFldrFmt, ARRAYSIZE(m_szFldrFmt));
    LoadString(g_hInstImp, idsImportingMessageFmt, m_szMsgFmt, ARRAYSIZE(m_szMsgFmt));

    m_pProgress = new CImpProgress;
    if (m_pProgress == NULL)
        return(E_OUTOFMEMORY);

    m_pProgress->Init(hwnd, TRUE);

    return(S_OK);
    }

void CFolderImportProg::SetFolder(IFolderImport *pImport, TCHAR *szName, UINT cMsg)
    {
    Assert(pImport != NULL);
    Assert(m_pImportEx == NULL);

    m_pImportEx = pImport;
    m_pImportEx->AddRef();

    m_iMsg = 0;
    m_cMsg = cMsg;

    lstrcpyn(m_szFolder, szName, ARRAYSIZE(m_szFolder));
    }

void CFolderImportProg::ReleaseFolder()
    {
    Assert(m_pImportEx != NULL);
    m_pImportEx->Release();
    m_pImportEx = NULL;
    }

HRESULT CFolderImportProg::SetMessageCount(ULONG cMsg)
    {
    m_cMsg = cMsg;

    return(m_pImportEx->SetMessageCount(cMsg));
    }

HRESULT CFolderImportProg::UpdateProgress()
    {
    TCHAR sz[CCHMAX_STRINGRES + MAX_PATH];

    if (m_iMsg == 0)
        {
        wnsprintf(sz, ARRAYSIZE(sz), m_szFldrFmt, m_szFolder);

        m_pProgress->SetMsg(sz, IDC_FOLDER_STATIC);
        m_pProgress->Show(0);

        m_pProgress->Reset();
        m_pProgress->AdjustMax(m_cMsg);
        }

    m_iMsg++;

    wnsprintf(sz, ARRAYSIZE(sz), m_szMsgFmt, m_iMsg, m_cMsg);
    m_pProgress->SetMsg(sz, IDC_MESSAGE_STATIC);

    return(m_pProgress->HrUpdate(1));
    }

HRESULT CFolderImportProg::ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach)
    {
    HRESULT hr;
    
    hr = UpdateProgress();

    if (hr != hrUserCancel)
        hr = m_pImportEx->ImportMessage(type, dwState, pstm, rgszAttach, cAttach);

    return(hr);
    }

HRESULT CFolderImportProg::ImportMessage(IMSG *pimsg)
    {
    HRESULT hr;
    
    hr = UpdateProgress();

    if (hr != hrUserCancel)
        hr = m_pImportEx->ImportMessage(pimsg);

    return(hr);
    }

void PerformImport(HWND hwnd, IMailImporter *pImporter, DWORD dwFlags)
    {
    IMPWIZINFO wizinfo;
    HRESULT hr;

    Assert(dwFlags == 0);

    ZeroMemory(&wizinfo, sizeof(IMPWIZINFO));
    wizinfo.pImporter = pImporter;

    hr = DoImportWizard(hwnd, &wizinfo);

    if (wizinfo.pClsid != NULL)
        MemFree(wizinfo.pClsid);

    if (wizinfo.pList != NULL)
        FreeFolderList(wizinfo.pList);

    if (wizinfo.pImport != NULL)
        wizinfo.pImport->Release();

    ExchDeinit();
    }

IMPFOLDERNODE *InsertFolderNode(IMPFOLDERNODE *plist, IMPFOLDERNODE *pnode)
    {
    BOOL fNodeNormal, fCurrNormal;
    IMPFOLDERNODE *pprev, *pcurr;

    Assert(pnode != NULL);
    pnode->pnext = NULL;

    if (plist == NULL)
        return(pnode);

    pprev = NULL;
    pcurr = plist;
    while (pcurr != NULL)
        {
        fNodeNormal = pnode->type == FOLDER_TYPE_NORMAL;
        fCurrNormal = pcurr->type == FOLDER_TYPE_NORMAL;

        if (!fNodeNormal &&
            fCurrNormal)
            break;

        if (fNodeNormal == fCurrNormal &&
            lstrcmpi(pnode->szName, pcurr->szName) <= 0)
            break;

        pprev = pcurr;
        pcurr = pcurr->pnext;
        }

    if (pcurr == NULL)
        {
        // insert at end of list
        Assert(pprev != NULL);
        pprev->pnext = pnode;
        }
    else if (pprev == NULL)
        {
        // insert at beginning of list
        pnode->pnext = plist;
        plist = pnode;
        }
    else
        {
        pprev->pnext = pnode;
        pnode->pnext = pcurr;
        }

    return(plist);
    }

HRESULT GetSubFolderList(IMailImport *pMailImp, IMPFOLDERNODE *pparent, DWORD_PTR dwCookie, IMPFOLDERNODE **pplist)
    {
    HRESULT hr;
    TCHAR *sz;
    IMPORTFOLDER folder;
    IEnumFOLDERS *pEnum;
    IMPFOLDERNODE *pnode, *plist;

    Assert(pMailImp != NULL);
    Assert(pplist != NULL);

    *pplist = NULL;
    plist = NULL;
    pEnum = NULL;

    hr = pMailImp->EnumerateFolders(dwCookie, &pEnum);
    if (FAILED(hr))
        return(hr);
    else if (hr == S_FALSE)
        return(S_OK);

    Assert(pEnum != NULL);

    while (S_OK == (hr = pEnum->Next(&folder)))
        {
        if (!MemAlloc((void **)&pnode, sizeof(IMPFOLDERNODE) + MAX_PATH * sizeof(TCHAR)))
            {
            hr = E_OUTOFMEMORY;
            break;
            }
        ZeroMemory(pnode, sizeof(IMPFOLDERNODE));
        sz = (TCHAR *)((BYTE *)pnode + sizeof(IMPFOLDERNODE));

        pnode->pparent = pparent;
        pnode->depth = (pparent != NULL) ? (pparent->depth + 1) : 0;
        pnode->szName = sz;
        pnode->type = folder.type;
        StrCpyN(sz, folder.szName, MAX_PATH);
        pnode->lparam = (LPARAM)folder.dwCookie;

        plist = InsertFolderNode(plist, pnode);

        if (folder.fSubFolders > 0)
            {
            hr = GetSubFolderList(pMailImp, pnode, folder.dwCookie, &pnode->pchild);
            if (FAILED(hr))
                break;
            }
        }

    if (hr == S_FALSE)
        hr = S_OK;

    pEnum->Release();

    *pplist = plist;

    return(hr);
    }

HRESULT GetFolderList(IMailImport *pMailImp, IMPFOLDERNODE **pplist)
    {
    IMPFOLDERNODE *plist;
    HRESULT hr;

    Assert(pMailImp != NULL);
    Assert(pplist != NULL);

    plist = NULL;

    hr = GetSubFolderList(pMailImp, NULL, COOKIE_ROOT, &plist);
    if (FAILED(hr))
        {
        FreeFolderList(plist);
        plist = NULL;
        }

    *pplist = plist;

    return(hr);
    }

void FreeFolderList(IMPFOLDERNODE *plist)
    {
    IMPFOLDERNODE *pnode;

    while (plist != NULL)
        {
        if (plist->pchild != NULL)
            FreeFolderList(plist->pchild);
        pnode = plist;
        plist = plist->pnext;
        MemFree(pnode);
        }
    }

void FillFolderListview(HWND hwnd, IMPFOLDERNODE *plist, DWORD_PTR dwReserved)
    {
    LV_ITEM lvi;
    int iret;

    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_INDENT;
    lvi.iSubItem = 0;

    for ( ; plist != NULL; plist = plist->pnext)
        {
        plist->dwReserved = dwReserved;

        lvi.pszText = plist->szName;
        lvi.lParam = (LPARAM)plist;
        lvi.iIndent = plist->depth;
        if (plist->type >= CFOLDERTYPE)
            lvi.iImage = iFolderClosed;
        else
            lvi.iImage = (int)plist->type + iFolderClosed;
        lvi.iItem = ListView_GetItemCount(hwnd);

        iret = ListView_InsertItem(hwnd, &lvi);
        Assert(iret != -1);

        if (plist->pchild != NULL)
            FillFolderListview(hwnd, plist->pchild, dwReserved);
        }
    }

void InitListViewImages(HWND hwnd)
    {
    HBITMAP hbm;
    HIMAGELIST himl;
    LV_COLUMN lvc;
    RECT rc;

    GetWindowRect(hwnd, &rc);

    lvc.mask = LVCF_TEXT | LVCF_WIDTH;
    lvc.pszText = (TCHAR *)c_szEmpty;
    lvc.cx = rc.right - rc.left - 2 * GetSystemMetrics(SM_CXEDGE) - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 0;
    ListView_InsertColumn(hwnd, 0, &lvc);

    himl = ImageList_Create(16, 16, ILC_MASK, CFOLDERTYPE, 0);

    if (himl != NULL)
        {
        hbm = LoadBitmap(g_hInstImp, MAKEINTRESOURCE(idbFolders));
        Assert(hbm != NULL);

        ImageList_AddMasked(himl, hbm, RGB(255, 0, 255));

        DeleteObject((HGDIOBJ)hbm);

        ListView_SetImageList(hwnd, himl, LVSIL_SMALL);
        }
    }

HRESULT ImportFolders(HWND hwnd, IMailImporter *pImporter, IMailImport *pMailImp, IMPFOLDERNODE *plist, CFolderImportProg *pImpProg)
    {
    HRESULT hr;
    DWORD_PTR dwParent;
    TCHAR szFmt[CCHMAX_STRINGRES], szError[CCHMAX_STRINGRES];
    IMPFOLDERNODE *pnode, *pnodeT;
    IFolderImport *pFldrImp;

    Assert(pImporter != NULL);
    Assert(pMailImp != NULL);
    Assert(plist != NULL);
    Assert(pImpProg != NULL);

    pnode = plist;
    while (pnode != NULL)
        {
        if (pnode->fImport)
            {
            dwParent = COOKIE_ROOT;
            pnodeT = pnode->pparent;
            while (pnodeT != NULL)
                {
                if (pnodeT->fImport)
                    {
                    dwParent = pnodeT->dwReserved;
                    break;
                    }
                pnodeT = pnodeT->pparent;
                }

            hr = pImporter->OpenFolder(dwParent, pnode->szName, pnode->type, 0, &pFldrImp, &pnode->dwReserved);
            if (hr == E_OUTOFMEMORY || hr == hrDiskFull)
                return(hr);
            else if (SUCCEEDED(hr))
                {
                Assert(pFldrImp != NULL);

                pImpProg->SetFolder(pFldrImp, pnode->szName, pnode->cMsg);

                hr = pMailImp->ImportFolder((DWORD)pnode->lparam, pImpProg);

                pImpProg->ReleaseFolder();
                pFldrImp->Release();

                if (hr == E_OUTOFMEMORY || hr == hrDiskFull || hr == hrUserCancel)
                    return(hr);
                else if (FAILED(hr))
                    {
                    // display an error, but keep trying to import the other folders
                    LoadString(g_hInstImp, idsFolderImportErrorFmt, szFmt, ARRAYSIZE(szFmt));
                    wnsprintf(szError, ARRAYSIZE(szError), szFmt, pnode->szName);
                    ImpErrorMessage(hwnd, MAKEINTRESOURCE(idsImportTitle), szError, hr);
                    }
                }
            }

        if (pnode->pchild != NULL)
            {
            hr = ImportFolders(hwnd, pImporter, pMailImp, pnode->pchild, pImpProg);
            if (hr == E_OUTOFMEMORY || hr == hrDiskFull || hr == hrUserCancel)
                return(hr);
            }

        pnode = pnode->pnext;
        }

    return(S_OK);
    }

void ImpErrorMessage(HWND hwnd, LPTSTR szTitle, LPTSTR szError, HRESULT hrDetail)
    {
    LPTSTR szDetail;

    Assert(FAILED(hrDetail));

    switch (hrDetail)
        {
        case E_OUTOFMEMORY:
            szDetail = MAKEINTRESOURCE(idsMemory);
            break;

        case hrDiskFull:
            szDetail = MAKEINTRESOURCE(idsDiskFull);
            break;

        case hrNoProfilesFound:
        case hrMapiInitFail:
            szDetail = MAKEINTRESOURCE(idsMAPIInitError);
            break;

        case hrFolderOpenFail:
            szDetail = MAKEINTRESOURCE(idsFolderOpenFail);
            break;

        case hrFolderReadFail:
            szDetail = MAKEINTRESOURCE(idsFolderReadFail);
            break;

        default:
            szDetail = MAKEINTRESOURCE(idsGenericError);
            break;
        }

    ImpMessageBox(hwnd, szTitle, szError, szDetail, MB_OK | MB_ICONEXCLAMATION);
    }

int ImpMessageBox(HWND hwndOwner, LPTSTR szTitle, LPTSTR sz1, LPTSTR sz2, UINT fuStyle)
    {
    TCHAR rgchTitle[CCHMAX_STRINGRES];
    TCHAR rgchText[2 * CCHMAX_STRINGRES + 2];
    LPTSTR szText;
    int cch;

    Assert(sz1);
    Assert(szTitle != NULL);

    if (IS_INTRESOURCE(szTitle))
        {
        // its a string resource id
        cch = LoadString(g_hInstImp, PtrToUlong(szTitle), rgchTitle, CCHMAX_STRINGRES);
        if (cch == 0)
            return(0);

        szTitle = rgchTitle;
        }

    if (!(IS_INTRESOURCE(sz1)))
        {
        // its a pointer to a string
        Assert(lstrlen(sz1) < CCHMAX_STRINGRES);
        if (NULL == StrCpyN(rgchText, sz1, ARRAYSIZE(rgchText)))
            return(0);

        cch = lstrlen(rgchText);
        }
    else
        {
        // its a string resource id
        cch = LoadString(g_hInstImp, PtrToUlong(sz1), rgchText, 2 * CCHMAX_STRINGRES);
        if (cch == 0)
            return(0);
        }

    if (sz2)
        {
        //$$REVIEW is this right??
        //$$REVIEW will this work with both ANSI/UNICODE?

        // there's another string that we need to append to the
        // first string...
        szText = &rgchText[cch];
        *szText = *c_szNewline;

        szText++;
        *szText = *c_szNewline;
        szText++;

        cch = ARRAYSIZE(rgchText) - (int)(szText - rgchText);

        if (!(IS_INTRESOURCE(sz2)))
            {
            // its a pointer to a string
            Assert(lstrlen(sz2) < CCHMAX_STRINGRES);
            if (NULL == StrCpyN(szText, sz2, cch))
                return(0);
            }
        else
            {
            Assert((2 * CCHMAX_STRINGRES - (szText - rgchText)) > 0);
            if (0 == LoadString(g_hInstImp, PtrToUlong(sz2), szText, cch))
                return(0);
            }
        }

    return(MessageBox(hwndOwner, rgchText, szTitle, MB_SETFOREGROUND | fuStyle));
    }

int AutoDetectClients(MIGRATEINFO *pinfo, int cinfo)
    {
    TCHAR szDir[MAX_PATH];

    Assert(pinfo != NULL);
    Assert(cinfo >= 2);

    cinfo = 0;

    if (SUCCEEDED(GetClientDir(szDir, ARRAYSIZE(szDir), EUDORA)))
        {
        pinfo->clsid = CLSID_CEudoraImport;
        pinfo->idDisplay = idsEudora;
        pinfo->szfnImport = (TCHAR *)szEudoraImportEntryPt;
        cinfo++;
        pinfo++;
        }

    if (SUCCEEDED(GetClientDir(szDir, ARRAYSIZE(szDir), NETSCAPE)))
        {
        pinfo->clsid = CLSID_CNetscapeImport;
        pinfo->idDisplay = idsNetscape;
        pinfo->szfnImport = (TCHAR *)szNetscapeImportEntryPt;
        cinfo++;
        pinfo++;
        }

    if (SUCCEEDED(GetClientDir(szDir, ARRAYSIZE(szDir), COMMUNICATOR)))
        {
        pinfo->clsid = CLSID_CCommunicatorImport;
        pinfo->idDisplay = idsCommunicator;
        pinfo->szfnImport = (TCHAR *)szMessengerImportEntryPt;
        cinfo++;
        pinfo++;
        }

    if (SUCCEEDED(ExchInit()) && SUCCEEDED(MapiLogon(NULL, NULL)))
        {
        pinfo->clsid = CLSID_CExchImport;
        pinfo->idDisplay = idsExchange;
        pinfo->szfnImport = (TCHAR *)szPABImportEntryPt;
        cinfo++;
        pinfo++;
        }

    return(cinfo);
    }

HRESULT PerformMigration(HWND hwnd, IMailImporter *pImporter, DWORD dwFlags)
    {
    HRESULT hr;
    MIGRATEINFO info[4];
    IMPWIZINFO wizinfo;

    Assert(pImporter != NULL);

    hr = S_OK;

    ZeroMemory(&wizinfo, sizeof(IMPWIZINFO));
    wizinfo.pImporter = pImporter;

    wizinfo.cMigrate = AutoDetectClients(info, ARRAYSIZE(info));
    if (wizinfo.cMigrate > 0)
        {
        wizinfo.pMigrate = info;
        wizinfo.fMigrate = TRUE;

        hr = DoImportWizard(hwnd, &wizinfo);
        }

    if (wizinfo.pClsid != NULL)
        MemFree(wizinfo.pClsid);

    if (wizinfo.pList != NULL)
        FreeFolderList(wizinfo.pList);

    if (wizinfo.pImport != NULL)
        wizinfo.pImport->Release();

    ExchDeinit();

    return(hr);
    }

int CALLBACK PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    DLGTEMPLATE *pDlg;

    if (uMsg == PSCB_PRECREATE)
    {
        pDlg = (DLGTEMPLATE *)lParam;
        
        if (!!(pDlg->style & DS_CONTEXTHELP))
            pDlg->style &= ~DS_CONTEXTHELP;
    }

    return(0);
}

const static PAGEINFO g_rgPageInfo[NUM_WIZARD_PAGES] =
{
	{ iddMigrate,           idsMigrate,         MigrateInitProc,    MigrateOKProc,       NULL },
	{ iddMigrateMode,       idsMigrate,         MigModeInitProc,    MigModeOKProc,       NULL },
	{ iddMigrateIncomplete, idsMigIncomplete,   MigIncInitProc,     MigIncOKProc,        NULL },
	{ iddSelectClient,      idsSelectClient,    ClientInitProc,     ClientOKProc,        NULL },
	{ iddLocation,          idsLocation,        LocationInitProc,   LocationOKProc,      LocationCmdProc },
	{ iddSelectFolders,     idsSelectFoldersHdr,FolderInitProc,     FolderOKProc,        NULL },
	{ iddAddressComplete,   idsAddressComplete, NULL,               AddressOKProc,       NULL },
    { iddCongratulations,   idsCongratulations, CongratInitProc,    CongratOKProc,       NULL }
};

HRESULT DoImportWizard(HWND hwnd, IMPWIZINFO *pinfo)
    {
    int nPageIndex, cPages, iRet;
	PROPSHEETPAGE psPage;
	PROPSHEETHEADER psHeader;
	HRESULT hr;
    char sz[CCHMAX_STRINGRES];
    HPROPSHEETPAGE rgPage[NUM_WIZARD_PAGES];
    INITWIZINFO rgInit[NUM_WIZARD_PAGES];

    Assert(pinfo != NULL);

	ZeroMemory(&psPage, sizeof(PROPSHEETPAGE));
	ZeroMemory(&psHeader, sizeof(PROPSHEETHEADER));

	psPage.dwSize = sizeof(psPage);
	psPage.dwFlags = PSP_DEFAULT | PSP_USEHEADERTITLE;
	psPage.hInstance = g_hInstImp;
	psPage.pfnDlgProc = GenDlgProc;

    hr = S_OK;

    cPages = 0;

	// create a property sheet page for each page in the wizard
    for (nPageIndex = pinfo->fMigrate ? 0 : 3; nPageIndex < NUM_WIZARD_PAGES; nPageIndex++)
	    {
        rgInit[cPages].pPageInfo = &g_rgPageInfo[nPageIndex];
        rgInit[cPages].pWizInfo = pinfo;
		psPage.lParam = (LPARAM)&rgInit[cPages];
		psPage.pszTemplate = MAKEINTRESOURCE(g_rgPageInfo[nPageIndex].uDlgID);
        LoadString(g_hInstImp, g_rgPageInfo[nPageIndex].uHdrID, sz, ARRAYSIZE(sz));
        psPage.pszHeaderTitle = sz;

		rgPage[cPages] = CreatePropertySheetPage(&psPage);
		if (rgPage[cPages] == NULL)
            {
            hr = E_FAIL;
            break;
            }
        cPages++;
		}

    if (!FAILED(hr))
        {
        psHeader.dwSize = sizeof(PROPSHEETHEADER);
        psHeader.dwFlags = PSH_WIZARD97 | PSH_HEADER | PSH_WATERMARK | PSH_USECALLBACK;
        psHeader.hwndParent = hwnd;
        psHeader.hInstance = g_hInstImp;
        psHeader.nPages = cPages;
        psHeader.phpage = rgPage;
        psHeader.pszbmWatermark = MAKEINTRESOURCE(idbGlobe);
        psHeader.pszbmHeader = 0;
        psHeader.pfnCallback = PropSheetProc;

        iRet = (int) PropertySheet(&psHeader);
        if (iRet == -1)
            hr = E_FAIL;
        else if (iRet == 0)
            hr = S_FALSE;
        else
            hr = S_OK;
        }
    else
        {
	    for (nPageIndex = 0; nPageIndex < cPages; nPageIndex++)
	        {
            if (rgPage[nPageIndex] != NULL)
		        DestroyPropertySheetPage(rgPage[nPageIndex]);
	        }
        }

	return(hr);
    }

/*******************************************************************

  NAME:    GenDlgProc

  SYNOPSIS:  Generic dialog proc for all wizard pages

  NOTES:    This dialog proc provides the following default behavior:
          init:    back and next buttons enabled
          next btn:  switches to page following current page
          back btn:  switches to previous page
          cancel btn: prompts user to confirm, and cancels the wizard
          dlg ctrl:   does nothing (in response to WM_COMMANDs)
        Wizard pages can specify their own handler functions
        (in the PageInfo table) to override default behavior for
        any of the above actions.

********************************************************************/
INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    INITWIZINFO *pInit;
    IMPWIZINFO *pWizInfo;
    BOOL fRet, fKeepHistory, fCancel;
    HWND hwndParent;
    LPPROPSHEETPAGE lpsp;
    const PAGEINFO *pPageInfo;
    NMHDR *lpnm;
    NMLISTVIEW *lpnmlv;
    UINT idPage;

    fRet = TRUE;
    hwndParent = GetParent(hDlg);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // get propsheet page struct passed in
            lpsp = (LPPROPSHEETPAGE)lParam;
            Assert(lpsp != NULL);

            // fetch our private page info from propsheet struct
            pInit = (INITWIZINFO *)lpsp->lParam;
            Assert(pInit != NULL);

            pWizInfo = pInit->pWizInfo;
            Assert(pWizInfo != NULL);
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pWizInfo);

            pPageInfo = pInit->pPageInfo;
            Assert(pPageInfo != NULL);
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pPageInfo);

            // initialize 'back' and 'next' wizard buttons, if
            // page wants something different it can fix in init proc below
            PropSheet_SetWizButtons(hwndParent, PSWIZB_NEXT | PSWIZB_BACK);

            // call init proc for this page if one is specified
            if (pPageInfo->InitProc != NULL)
                {
                if (!pPageInfo->InitProc(pWizInfo, hDlg, TRUE))
                    {
                    // send a 'cancel' message to ourselves
                    // TODO: handle this
                    Assert(FALSE);
                    }
                }
            break;

        case WM_ENABLENEXT:
            EnableWindow(GetDlgItem(GetParent(hDlg), IDD_NEXT), (BOOL)wParam);
            break;

        case WM_POSTSETFOCUS:
            SetFocus((HWND)wParam);
            break;

        case WM_NOTIFY:
            pWizInfo = (IMPWIZINFO *)GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(pWizInfo != NULL);

            pPageInfo = (const PAGEINFO *)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            Assert(pPageInfo != NULL);

            lpnm = (NMHDR *)lParam;

            switch (lpnm->code)
                {
                case PSN_SETACTIVE:
                    // initialize 'back' and 'next' wizard buttons, if
                    // page wants something different it can fix in init proc below
                    PropSheet_SetWizButtons(hwndParent, PSWIZB_NEXT | PSWIZB_BACK);

                    // call init proc for this page if one is specified
                    if (pPageInfo->InitProc != NULL)
                        {
                        // TODO: what about the return value for this????
                        pPageInfo->InitProc(pWizInfo, hDlg, FALSE);
                        }

                    pWizInfo->idCurrentPage = pPageInfo->uDlgID;
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    Assert((ULONG)pWizInfo->idCurrentPage == pPageInfo->uDlgID);

                    fKeepHistory = TRUE;
                    idPage = 0;

                    Assert(pPageInfo->OKProc != NULL) ;

                    if (!pPageInfo->OKProc(pWizInfo, hDlg, (lpnm->code != PSN_WIZBACK), &idPage, &fKeepHistory))
                        {
                        // stay on this page
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                        }

                    if (lpnm->code != PSN_WIZBACK)
                        {
                        // 'next' pressed
                        Assert(pWizInfo->cPagesCompleted < NUM_WIZARD_PAGES);

                        // save the current page index in the page history,
                        // unless this page told us not to when we called
                        // its OK proc above
                        if (fKeepHistory)
                            {
                            pWizInfo->rgHistory[pWizInfo->cPagesCompleted] = pWizInfo->idCurrentPage;
                            pWizInfo->cPagesCompleted++;
                            }
                        }
                    else
                        {
                        // 'back' pressed
                        Assert(pWizInfo->cPagesCompleted > 0);

                        // get the last page from the history list
                        pWizInfo->cPagesCompleted--;
                        idPage = pWizInfo->rgHistory[pWizInfo->cPagesCompleted];
                        }

                    // set next page, only if 'next' or 'back' button was pressed
                    if (lpnm->code != PSN_WIZFINISH)
                        {
                        // tell the prop sheet mgr what the next page to display is
                        Assert(idPage != 0);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, idPage);
                        }
                    break;

                case PSN_QUERYCANCEL:
                    if (IDNO == ImpMessageBox(hDlg, MAKEINTRESOURCE(idsImportTitle), MAKEINTRESOURCE(idsCancelWizard), NULL, MB_YESNO|MB_ICONEXCLAMATION |MB_DEFBUTTON2))
                        {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        }
                    break;

                case LVN_ITEMCHANGED:
                    if (lpnm->idFrom == IDC_IMPFOLDER_LISTVIEW &&
                        ((NMLISTVIEW *)lpnm)->iItem != -1)
                    {
                        SendDlgItemMessage(hDlg, IDC_IMPORTALL_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
                        SendDlgItemMessage(hDlg, IDC_SELECT_RADIO, BM_SETCHECK, BST_CHECKED, 0);
                    }
                    break;
                }
            break;

        case WM_COMMAND:
            pWizInfo = (IMPWIZINFO *)GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(pWizInfo != NULL);

            pPageInfo = (const PAGEINFO *)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            Assert(pPageInfo != NULL);

            // if this page has a command handler proc, call it
            if (pPageInfo->CmdProc != NULL)
                {
                pPageInfo->CmdProc(pWizInfo, hDlg, wParam, lParam);
                }
            break;

        default:
            fRet = FALSE;
            break;
        }

    return(fRet);
    }

BOOL CALLBACK MigrateInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
{
    HWND hwnd;
    TCHAR sz[CCHMAX_STRINGRES];
    UINT idx, i;

    Assert(pInfo != NULL);

    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);

    if (fFirstInit)
    {
        pInfo->iMigrate = -1;

        SendDlgItemMessage(hDlg, IDC_IMPORT_RADIO, BM_SETCHECK, BST_CHECKED, 0);

        hwnd = GetDlgItem(hDlg, idcClientsListbox);

        Assert(pInfo->cMigrate > 0);
        for (i = 0; i < pInfo->cMigrate; i++)
        {
            LoadString(g_hInstImp, pInfo->pMigrate[i].idDisplay, sz, ARRAYSIZE(sz));
            idx = (int) SendMessage(hwnd, LB_ADDSTRING, 0, (LPARAM)sz);
            SendMessage(hwnd, LB_SETITEMDATA, (WPARAM)idx, (LPARAM)i);
        }
        SendMessage(hwnd, LB_SETCURSEL, 0, 0);
    }

    return(TRUE);
}

BOOL CALLBACK MigrateOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *fKeepHistory)
{
    UINT idx;
    HWND hwnd;
    HRESULT hr;
    IMPFOLDERNODE *pnode;
    IMailImport *pMailImp;

    Assert(pInfo != NULL);

    if (fForward)
    {
        if (SendDlgItemMessage(hDlg, IDC_NO_IMPORT_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
        {
            *puNextPage = iddMigrateIncomplete;
            return(TRUE);
        }

        hwnd = GetDlgItem(hDlg, idcClientsListbox);

        idx = (int) SendMessage(hwnd, LB_GETCURSEL, 0, 0);

        if (SendMessage(hwnd, LB_GETTEXTLEN, idx, 0) < CCHMAX_STRINGRES)
            SendMessage(hwnd, LB_GETTEXT, idx, (LPARAM)pInfo->szClient);  // save selected client name
        else
            *pInfo->szClient = 0;

        idx = (int) SendMessage(hwnd, LB_GETITEMDATA, (WPARAM)idx, 0);

        if (idx != pInfo->iMigrate)
        {
            pInfo->dwReload = PAGE_ALL;

            pInfo->iMigrate = idx;
            if (pInfo->pImport != NULL)
            {
                pInfo->pImport->Release();
                pInfo->pImport = NULL;
            }
        }

        *puNextPage = iddMigrateMode;
    }

    return(TRUE);
}

BOOL CALLBACK MigModeInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
    {
    HWND hwnd;
    TCHAR sz[CCHMAX_STRINGRES];
    UINT idx, i;

    Assert(pInfo != NULL);

    if (fFirstInit || !!(pInfo->dwReload & PAGE_MODE))
        {
        SendDlgItemMessage(hDlg, IDC_MSGS_AB_RADIO, BM_SETCHECK, BST_CHECKED, 0);
        SendDlgItemMessage(hDlg, IDC_MSGS_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
        SendDlgItemMessage(hDlg, IDC_AB_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);

        pInfo->dwReload &= ~PAGE_MODE;
        }

    return(TRUE);
    }

BOOL CALLBACK MigModeOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *fKeepHistory)
{
    HWND hwnd;
    HRESULT hr;
    IMPFOLDERNODE *pnode;
    IMailImport *pMailImp;

    Assert(pInfo != NULL);

    if (fForward)
    {
        if (SendDlgItemMessage(hDlg, IDC_MSGS_AB_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
        {
            pInfo->fMessages = TRUE;
            pInfo->fAddresses = TRUE;
        }
        else if (SendDlgItemMessage(hDlg, IDC_MSGS_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
        {
            pInfo->fMessages = TRUE;
            pInfo->fAddresses = FALSE;
        }
        else
        {
            pInfo->fMessages = FALSE;
            pInfo->fAddresses = TRUE;
        }
        
        pMailImp = NULL;

        if (!pInfo->fMessages)
        {
            if (pInfo->pImport != NULL)
            {
                pInfo->pImport->Release();
                pInfo->pImport = NULL;
            }

            *puNextPage = iddAddressComplete;
        }
        else if (pInfo->pImport == NULL)
        {
            hr = CoCreateInstance(pInfo->pMigrate[pInfo->iMigrate].clsid, NULL, CLSCTX_INPROC_SERVER, IID_IMailImport, (void **)&pMailImp);
            if (SUCCEEDED(hr))
            {
                Assert(pMailImp != NULL);

                hr = pMailImp->InitializeImport(GetParent(hDlg));
                if (hr == S_OK)
                {
                    hr = pMailImp->GetDirectory(pInfo->szDir, ARRAYSIZE(pInfo->szDir));
                    if (hr == S_FALSE)
                    {
                        hr = GetFolderList(pMailImp, &pnode);
                        if (FAILED(hr) || pnode == NULL)
                        {
                            // TODO: error message
                            pMailImp->Release();
                            return(FALSE);
                        }

                        if (pInfo->pList != NULL)
                            FreeFolderList(pInfo->pList);
                        pInfo->pList = pnode;

                        pInfo->fLocation = FALSE;
                    }
                    else
                    {
                        pInfo->fLocation = TRUE;
                    }
                }
                else
                {
                    pMailImp->Release();
                    return(FALSE);
                }

                pInfo->dwReload = PAGE_LOCATION | PAGE_FOLDERS;

                pInfo->pImport = pMailImp;

                *puNextPage = pInfo->fLocation ? iddLocation : iddSelectFolders;
            }
        }
        else
        {
            *puNextPage = pInfo->fLocation ? iddLocation : iddSelectFolders;
        }
    }

    return(TRUE);
}

BOOL CALLBACK MigIncInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
{
    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH | PSWIZB_BACK);
    
    return(TRUE);
}

BOOL CALLBACK MigIncOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory)
{
    return(TRUE);
}

#define CCLSIDBUF   16

void InitListView(HWND hwndList, IMPWIZINFO *pinfo)
    {
    DWORD dwIndex, dwGuid, dwName;
    TCHAR szName[MAX_PATH], szGuid[MAX_PATH], szDisp[16];
    HKEY hkey, hkeyT;
    HRESULT hr;
    FILETIME ft;
    UINT i, index, iClsid;
    LPWSTR pwszCLSID;

    Assert(pinfo != NULL);
    Assert(pinfo->pClsid == NULL);

    iClsid = 0;
    pinfo->cClsid = CCLSIDBUF;

    if (!MemAlloc((void **)&pinfo->pClsid, sizeof(CLSID) * pinfo->cClsid))
        return;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegImport,
                            0, KEY_READ, &hkey))
        {
        dwIndex = 0;

        dwGuid = ARRAYSIZE(szGuid);
        while (ERROR_SUCCESS == RegEnumKeyEx(hkey, dwIndex, szGuid, &dwGuid,
                                    NULL, NULL, NULL, &ft))
            {
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szGuid, 0, KEY_READ, &hkeyT))
                {
                for (i = 1; i <= 9; i++)
                    {
                    wnsprintf(szDisp, ARRAYSIZE(szDisp), c_szDispFmt, i);
                    dwName = sizeof(szName);
                    if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, szDisp, NULL, NULL,
                                            (LPBYTE)szName, &dwName))
                        {
                        Assert(iClsid < pinfo->cClsid);
                        index = (int) SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)szName);
                        SendMessage(hwndList, LB_SETITEMDATA, (WPARAM)index, (LPARAM)iClsid);

                        // We should be doing something different here. If PszToUnicode fails,
                        // it fails because of low memory. This is an error condition, not an assert.
                        pwszCLSID = PszToUnicode(CP_ACP, szGuid);
                        Assert(pwszCLSID != NULL);

                        hr = CLSIDFromString(pwszCLSID, &pinfo->pClsid[iClsid]);
                        Assert(!FAILED(hr));

                        MemFree(pwszCLSID);

                        iClsid++;
                        }
                    else
                        {
                        break;
                        }
                    }

                RegCloseKey(hkeyT);
                }

            dwIndex++;
            dwGuid = ARRAYSIZE(szGuid);
            }

        RegCloseKey(hkey);
        }

    SendMessage(hwndList, LB_SETCURSEL, 0, 0);
    }

BOOL CALLBACK ClientInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
    {
    Assert(pInfo != NULL);

    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);

    if (fFirstInit)
        {
        pInfo->iClsid = -1;

        InitListView(GetDlgItem(hDlg, idcClientsListbox), pInfo);
        }

    return(TRUE);
    }

BOOL CALLBACK ClientOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *fKeepHistory)
    {
    UINT i;
    HWND hwnd;
    HRESULT hr;
    IMPFOLDERNODE *pnode;
    IMailImport *pMailImp;

    Assert(pInfo != NULL);

    if (fForward)
        {
        pInfo->fMessages = TRUE;
        pInfo->fAddresses = FALSE;

        hwnd = GetDlgItem(hDlg, idcClientsListbox);

        i = (int) SendMessage(hwnd, LB_GETCURSEL, 0, 0);

        if (SendMessage(hwnd, LB_GETTEXTLEN, i, 0) < CCHMAX_STRINGRES)
            SendMessage(hwnd, LB_GETTEXT, i, (LPARAM)pInfo->szClient);  // save selected client name
        else
            *pInfo->szClient = 0;

        i = (int) SendMessage(hwnd, LB_GETITEMDATA, (WPARAM)i, 0);

        Assert(((int) i) >= 0 && i < pInfo->cClsid);

        if (i != pInfo->iClsid)
            {
            hr = CoCreateInstance(pInfo->pClsid[i], NULL, CLSCTX_INPROC_SERVER, IID_IMailImport, (void **)&pMailImp);
            if (FAILED(hr))
                {
                // TODO: error message
                return(FALSE);
                }

            Assert(pMailImp != NULL);

            hr = pMailImp->InitializeImport(GetParent(hDlg));
            if (hr == S_OK)
                {
                hr = pMailImp->GetDirectory(pInfo->szDir, ARRAYSIZE(pInfo->szDir));
                if (hr == S_FALSE)
                    {
                    hr = GetFolderList(pMailImp, &pnode);
                    if (FAILED(hr) || pnode == NULL)
                        {
                        // TODO: error message
                        pMailImp->Release();
                        return(FALSE);
                        }

                    if (pInfo->pList != NULL)
                        FreeFolderList(pInfo->pList);
                    pInfo->pList = pnode;

                    pInfo->fLocation = FALSE;
                    }
                else
                    {
                    pInfo->fLocation = TRUE;
                    }
                }
            else
                {
                pMailImp->Release();
                return(FALSE);
                }

            pInfo->dwReload = PAGE_ALL;

            if (pInfo->pImport != NULL)
                pInfo->pImport->Release();

            pInfo->iClsid = i;
            pInfo->pImport = pMailImp;
            }

        *puNextPage = pInfo->fLocation ? iddLocation : iddSelectFolders;
        }

    return(TRUE);
    }

BOOL CALLBACK LocationInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
    {
    HWND hwnd;
    DWORD cbSize;
    TCHAR sz[CCHMAX_STRINGRES];

    Assert(pInfo != NULL);
    
    hwnd = GetDlgItem(hDlg, IDC_IMPFOLDER_EDIT);

    if (fFirstInit || !!(pInfo->dwReload & PAGE_LOCATION))
        {
        if (*pInfo->szDir == 0)
            {
            LoadString(g_hInstImp, idsLocationUnknown, sz, ARRAYSIZE(sz));
            SetDlgItemText(hDlg, IDC_LOCATION_STATIC, sz);
            }

        if (pInfo->pList != NULL)
            {
            FreeFolderList(pInfo->pList);
            pInfo->pList = NULL;
            }

        SetWindowText(hwnd, pInfo->szDir);

        pInfo->dwReload &= ~PAGE_LOCATION;
        }

    cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));
    UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
    PostMessage(hDlg, WM_ENABLENEXT, (WPARAM)(cbSize != 0), 0);

    return(TRUE);
    }

BOOL CALLBACK LocationOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory)
    {
    IMPFOLDERNODE *pnode;
    HRESULT hr;
    TCHAR sz[MAX_PATH];

    Assert(pInfo != NULL);

    if (fForward)
        {
        GetDlgItemText(hDlg, IDC_IMPFOLDER_EDIT, sz, ARRAYSIZE(sz));

        if (*sz == 0)
            {
            ImpMessageBox(hDlg, MAKEINTRESOURCE(idsImportTitle),
                MAKEINTRESOURCE(idsLocationInvalid), NULL,
                MB_OK | MB_ICONSTOP);

            return(FALSE);
            }

        if (0 != lstrcmpi(sz, pInfo->szDir) || pInfo->pList == NULL)
            {
            hr = pInfo->pImport->SetDirectory(sz);
            if (hr == S_FALSE)
                {
                ImpMessageBox(hDlg, MAKEINTRESOURCE(idsImportTitle),
                    MAKEINTRESOURCE(idsLocationInvalid), NULL,
                    MB_OK | MB_ICONSTOP);

                return(FALSE);
                }

            Assert(hr == S_OK);

            pnode = NULL;
            hr = GetFolderList(pInfo->pImport, &pnode);
            if (FAILED(hr) || pnode == NULL)
                {
                ImpMessageBox(hDlg, MAKEINTRESOURCE(idsImportTitle),
                    MAKEINTRESOURCE(idsLocationInvalid), NULL,
                    MB_OK | MB_ICONSTOP);

                return(FALSE);
                }

            pInfo->dwReload |= PAGE_FOLDERS;

            if (pInfo->pList != NULL)
                FreeFolderList(pInfo->pList);

            pInfo->pList = pnode;
            StrCpyN(pInfo->szDir, sz, ARRAYSIZE(pInfo->szDir));
            }

        *puNextPage = iddSelectFolders;
        }

    return(TRUE);
    }

BOOL CALLBACK LocationCmdProc(IMPWIZINFO *pInfo, HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    DWORD cbSize;
    char szDir[MAX_PATH];
    
    Assert(pInfo != NULL);
    
    if (LOWORD(wParam) == IDC_SELECTFOLDER_BUTTON)
    {
        GetDlgItemText(hDlg, IDC_IMPFOLDER_EDIT, szDir, ARRAYSIZE(szDir));
        
        hr = DispDialog(hDlg, szDir, ARRAYSIZE(szDir));
        if (hr == S_OK)
        {
            cbSize = lstrlen(szDir);
            UlStripWhitespace(szDir, TRUE, TRUE, &cbSize);
            SetDlgItemText(hDlg, IDC_IMPFOLDER_EDIT, szDir);
            EnableWindow(GetDlgItem(GetParent(hDlg), IDD_NEXT), (cbSize != 0));
        }
    }
    
    return(TRUE);
}

BOOL CALLBACK FolderInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
    {
    HWND hwndList;

    Assert(pInfo != NULL);
    Assert(pInfo->pList != NULL);

    if (fFirstInit || !!(pInfo->dwReload & PAGE_FOLDERS))
        {
        Assert(pInfo->pList != NULL);

        SendDlgItemMessage(hDlg, IDC_IMPORTALL_RADIO, BM_SETCHECK, BST_CHECKED, 0);
        SendDlgItemMessage(hDlg, IDC_SELECT_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);

        hwndList = GetDlgItem(hDlg, IDC_IMPFOLDER_LISTVIEW);

        if (fFirstInit)
            InitListViewImages(hwndList);

        ListView_DeleteAllItems(hwndList);
        FillFolderListview(hwndList, pInfo->pList, (DWORD_PTR)INVALID_FOLDER_HANDLE);

        pInfo->dwReload &= ~PAGE_FOLDERS;
        }

    return(TRUE);
    }

BOOL CALLBACK FolderOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory)
    {
    BOOL fSel;
    LV_ITEM lvi;
    int ili;
    IMPFOLDERNODE *pnode;
    HWND hwndList;
    CFolderImportProg *pImpProg;
    HRESULT hr;

    Assert(pInfo != NULL);

    if (fForward)
        {
        fSel = (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_SELECT_RADIO, BM_GETCHECK, 0, 0));
        hwndList = GetDlgItem(hDlg, IDC_IMPFOLDER_LISTVIEW);

        if (fSel && 0 == SendMessage(hwndList, LVM_GETSELECTEDCOUNT, 0, 0))
            {
            ImpMessageBox(hDlg, MAKEINTRESOURCE(idsImportTitle),
                MAKEINTRESOURCE(idsSelectFolders), NULL,
                MB_OK | MB_ICONSTOP);

            return(FALSE);
            }

        lvi.mask = LVIF_PARAM;
        lvi.iSubItem = 0;

        ili = -1;

        // First clear all state from possible previous imports. Bug; #
        if(fSel)
            {
            while (-1 != (ili = ListView_GetNextItem(hwndList, ili, 0)))
                {
                lvi.iItem = ili;
                ListView_GetItem(hwndList, &lvi);

                pnode = (IMPFOLDERNODE *)lvi.lParam;
                Assert(pnode != NULL);
                pnode->fImport = FALSE;
                }
            }

        ili = -1;
        while (-1 != (ili = ListView_GetNextItem(hwndList, ili, fSel ? LVNI_SELECTED : 0)))
            {
            lvi.iItem = ili;
            ListView_GetItem(hwndList, &lvi);

            pnode = (IMPFOLDERNODE *)lvi.lParam;
            Assert(pnode != NULL);
            pnode->fImport = TRUE;
            }

        // TODO: error handling...

        pImpProg = new CFolderImportProg;
        if (pImpProg == NULL)
            {
            hr = E_OUTOFMEMORY;
            }
        else
            {
            hr = pImpProg->Initialize(GetParent(hDlg));
            if (!FAILED(hr))
                {
                Assert(pInfo->fMessages || pInfo->fAddresses);
                if (pInfo->fMessages)
                    {
                    hr = ImportFolders(hDlg, pInfo->pImporter, pInfo->pImport, pInfo->pList, pImpProg);
                    if (hr == hrUserCancel)
                        goto FoldDone;
                    else if (FAILED(hr))
                        ImpErrorMessage(hDlg, MAKEINTRESOURCE(idsImportTitle), MAKEINTRESOURCE(idsErrImport), hr);
                    }

                if (pInfo->fAddresses)
                    {
                    Assert(pInfo->pMigrate != NULL);
                    if (pInfo->pMigrate[pInfo->iMigrate].szfnImport != NULL)
                        HrImportAB(hDlg, pInfo->pMigrate[pInfo->iMigrate].szfnImport);
                    }
                }

FoldDone:
            pImpProg->Release();

            *puNextPage = iddCongratulations;
            }
        }

    return(TRUE);
    }

BOOL CALLBACK AddressOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory)
    {
    CFolderImportProg *pImpProg;
    HRESULT hr;

    Assert(pInfo != NULL);
    Assert(!pInfo->fMessages && pInfo->fAddresses);

    if (fForward)
        {
        // TODO: error handling...

        pImpProg = new CFolderImportProg;
        if (pImpProg == NULL)
            {
            hr = E_OUTOFMEMORY;
            }
        else
            {
            hr = pImpProg->Initialize(hDlg);
            if (!FAILED(hr))
                {
                Assert(pInfo->pMigrate != NULL);
                HrImportAB(hDlg, pInfo->pMigrate[pInfo->iMigrate].szfnImport);
                }

            pImpProg->Release();

            *puNextPage = iddCongratulations;
            }
        }

    return(TRUE);
    }

BOOL CALLBACK CongratInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
{
    TCHAR sz[CCHMAX_STRINGRES*2];
    TCHAR szFmt[CCHMAX_STRINGRES];
    
    LoadString(g_hInstImp, idsCongratStr, szFmt, ARRAYSIZE(szFmt));
    wnsprintf(sz, ARRAYSIZE(sz), szFmt, pInfo->szClient);
    SetDlgItemText(hDlg, idcStatic1, sz);
    
    if (fFirstInit)
    {
        if (!pInfo->fMigrate)
            ShowWindow(GetDlgItem(hDlg, idcStatic2), SW_HIDE);
    }

    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);
    PropSheet_CancelToClose(GetParent(hDlg));
    
    return(TRUE);
}

BOOL CALLBACK CongratOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory)
{
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\newdel.h ===
// --------------------------------------------------------------------------------
// Override new  and delete operator
// --------------------------------------------------------------------------------
#ifndef __NEWDEL_
#define __NEWDEL_

#ifdef DEBUG
extern ULONG    g_cObjectNew;
extern ULONG    g_cObjectDel;
#endif

#endif // __NEWDEL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\dll\makefile.inc ===
$(O)\imnimp.res : $(O)\selfreg.inf

..\selfreg.src : ..\reg.src ..\strings.src

$(O)\selfreg.inx : ..\selfreg.src
    cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\athena16\impath16.h ===
#ifndef _INC_ATHENAIMP_H
#define _INC_ATHENAIMP_H

// {B7AAC060-2638-11d1-83A9-00C04FBD7C09}
DEFINE_GUID(CLSID_CAthena16Import, 0xb7aac060, 0x2638, 0x11d1, 0x83, 0xa9, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

#define ATH_HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, n)
#define HR_FIRST 0x1000 // Put at the bottom

#define hrNoMessages 780
#define hrMemory                                E_OUTOFMEMORY
#define hrCorruptMessage                        ATH_HR_E(HR_FIRST + 42)
#define hrReadFile                              ATH_HR_E(HR_FIRST + 30)


typedef struct tagzMsgHeader
{
	char ver;
	ULONG TotalMessages;
	ULONG ulTotalUnread;
}MsgHeader;

class CAthena16FOLDERS : public IEnumFOLDERS
    {
    private:
        ULONG			m_cRef;
        EUDORANODE*	m_plist;
        EUDORANODE*	m_pnext;

    public:
        CAthena16FOLDERS(EUDORANODE *plist);
        ~CAthena16FOLDERS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP Next(IMPORTFOLDER *pfldr);
        STDMETHODIMP Reset(void);
    };

class CAthena16Import : public IMailImport
    {
    private:
        ULONG			m_cRef;
        EUDORANODE		*m_plist;
        BOOL			m_bDraft;
        char			m_szUser[MAX_PATH];
		char			m_szIniFile[MAX_PATH];
	

    public:
        CAthena16Import(void);
        ~CAthena16Import(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP InitializeImport(HWND hwnd);
        STDMETHODIMP GetDirectory(char *szDir, UINT cch);
        STDMETHODIMP SetDirectory(char *szDir);
        STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
        STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);
		
		//class member functions

		HRESULT GetUserDir(char *szDir, UINT cch);


    };

INT_PTR CALLBACK SelectAth16UserDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT GetAthSubFolderList(LPTSTR szInstallPath, EUDORANODE **ppList, EUDORANODE *);
void GetNewRecurseFolder(LPTSTR szInstallPath, DWORD cchInstallPath, LPTSTR szDir, LPTSTR szInstallNewPath);
HRESULT ProcessMessages(LPSTR szFileName, DWORD cchFileName, IFolderImport *pImport);
long GetMessageCount(HANDLE hFile);
HRESULT ProcessMsgList(HANDLE hFile,LPTSTR szPath, IFolderImport* pImport);
HRESULT GetMsgFileName(LPCSTR szmsgbuffer, char *szfilename, DWORD cchFileName);
HANDLE OpenMsgFile(LPTSTR szFileName,DWORD cchFileName);
HRESULT	GetFileinBuffer(HANDLE hnd,LPTSTR *szBuffer);
HRESULT	ProcessSingleMessage(LPTSTR szBuffer, DWORD dwFlags, IFolderImport* pImport);
HRESULT ParseMsgBuffer(LPTSTR szmsgbuffer,LPTSTR szPath, IFolderImport* pImport);
int GetNumUsers(char *szFile, char *szUser, DWORD cchUser);
HRESULT	GetMessageFlag(char *szmsgbuffer, LPDWORD pdwFlags);

#endif // _INC_ATHENAIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\eudora\eudrimp.h ===
#ifndef _INC_EUDRIMP_H
#define _INC_EUDRIMP_H

// {0A522730-A626-11D0-8D60-00C04FD6202B}
DEFINE_GUID(CLSID_CEudoraImport, 0x0A522730L, 0xA626, 0x11D0, 0x8D, 0x60, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

#define MBX_FILE    1
#define FOL_FILE    2

typedef struct tagEUDORANODE
    {
    struct tagEUDORANODE *pnext;
    struct tagEUDORANODE *pchild;
    struct tagEUDORANODE *pparent;

    int depth;
    IMPORTFOLDERTYPE type;
    int iFileType;  // mbx or fol
    TCHAR szName[MAX_PATH];

    TCHAR szFile[MAX_PATH];     // mbx file or fol directory
    } EUDORANODE;

class CEudoraEnumFOLDERS : public IEnumFOLDERS
    {
    private:
        ULONG           m_cRef;
        EUDORANODE      *m_plist;
        EUDORANODE      *m_pnext;

    public:
        CEudoraEnumFOLDERS(EUDORANODE *plist);
        ~CEudoraEnumFOLDERS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP Next(IMPORTFOLDER *pfldr);
        STDMETHODIMP Reset(void);
    };

class CEudoraImport : public IMailImport
    {
    private:
        ULONG           m_cRef;
        EUDORANODE      *m_plist;

    public:
        CEudoraImport(void);
        ~CEudoraImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP InitializeImport(HWND hwnd);
        STDMETHODIMP GetDirectory(char *szDir, UINT cch);
        STDMETHODIMP SetDirectory(char *szDir);
        STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
        STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);
    };

void EudoraFreeFolderList(EUDORANODE *pnode);

#endif // _INC_EUDRIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\strconst.h ===
/*
*    strconst.h
*    
*    History:
*      Feb '98: Created.
*    
*    Copyright (C) Microsoft Corp. 1998
*
*   Non-localizeable strings for use by the importer
*/

#ifndef _STRCONST_H
#define _STRCONST_H

#ifndef WIN16
#ifdef DEFINE_STRING_CONSTANTS
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y
#else
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif
#endif

//  ----------------------------------- FILES ------------------------------------
//  ********* DLLS
STR_GLOBAL(szImportDll,                 "wabimp.dll");
STR_GLOBAL(c_szMainDll,		            "msoe.dll");


//  ********* Program specific Reg, INI and File info
//  -- OE
STR_GLOBAL(c_szRegImport,		        "Software\\Microsoft\\Outlook Express\\Import");

//  -- WAB
STR_GLOBAL(lpszWABDLLRegPathKey,		"Software\\Microsoft\\WAB\\DLLPath");

//  -- Navigator
STR_GLOBAL(c_szNetscapeKey,		        "SOFTWARE\\Netscape\\Netscape Navigator\\Mail");
STR_GLOBAL(c_szMailDirectory,		    "Mail Directory");
STR_GLOBAL(c_szSnmExt,		            "*.snm");
STR_GLOBAL(c_szNetscape,		        "Netscape");
STR_GLOBAL(c_szIni,		                "ini");
STR_GLOBAL(c_szMail,		            "Mail");
STR_GLOBAL(c_szScriptFile,		        "\\prefs.js");
STR_GLOBAL(c_szUserPref,		        "user_pref(\"mail.directory\"");

//  -- Eudora
STR_GLOBAL(c_szEudoraKey,		        "SOFTWARE\\Microsoft\\windows\\CurrentVersion\\App Paths\\Eudora.exe");
STR_GLOBAL(c_szEudoraCommand,		    "SOFTWARE\\Qualcomm\\Eudora\\CommandLine");
STR_GLOBAL(c_szCurrent,		            "current");
STR_GLOBAL(c_szDescmapPce,		        "descmap.pce");

//  -- function names
STR_GLOBAL(szWabOpen,                   "WABOpen");
STR_GLOBAL(szNetscapeImportEntryPt,     "NetscapeImport");
STR_GLOBAL(szEudoraImportEntryPt,       "EudoraImport");
STR_GLOBAL(szPABImportEntryPt,          "PABImport");
STR_GLOBAL(szMessengerImportEntryPt,    "MessengerImport");

//  ********* General Strings
STR_GLOBAL(c_szSpace,		            " ");
STR_GLOBAL(c_szEmpty,		            "");
STR_GLOBAL(c_szNewline,		            "\n");
STR_GLOBAL(c_szDispFmt,		            "Display%1d");
STR_GLOBAL(c_szMicrosoftOutlook,        "Microsoft Outlook");
STR_GLOBAL(c_szRegOutlook,              "Software\\Clients\\Mail\\Microsoft Outlook");
STR_GLOBAL(c_szRegMail,                 "Software\\Clients\\Mail");

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\exchange\exchimp.cpp ===
#include "pch.hxx"
#include <mapi.h>
#include <mapix.h>
#include <imnapi.h>
#include <newimp.h>
#include <impapi.h>
#include <import.h>
#include "mapiconv.h"
#include <dllmain.h>
#include <shlwapi.h>
#include <strconst.h>

#define INITGUID
#define USES_IID_IMessage
#define USES_IID_IMAPIFolder

#include <ole2.h>
#include <initguid.h>
#include <MAPIGUID.H>

ASSERTDATA

static const TCHAR c_szMapi32Dll[] = TEXT("mapi32.dll");

const static TCHAR szMAPILogonEx[] = TEXT("MAPILogonEx");
const static TCHAR szMAPIInitialize[] = TEXT("MAPIInitialize");
const static TCHAR szMAPIUninitialize[] = TEXT("MAPIUninitialize");
const static TCHAR szMAPIFreeBuffer[] = TEXT("MAPIFreeBuffer");
const static TCHAR szMAPIAllocateBuffer[] = TEXT("MAPIAllocateBuffer");
const static TCHAR szMAPIAllocateMore[] = TEXT("MAPIAllocateMore");
const static TCHAR szMAPIAdminProfiles[] = TEXT("MAPIAdminProfiles");
const static TCHAR szFreeProws[] = TEXT("FreeProws@4");
const static TCHAR szHrQueryAllRows[] = TEXT("HrQueryAllRows@24");
const static TCHAR szWrapCompressedRTFStream[] = TEXT("WrapCompressedRTFStream");

static char g_szDefClient[MAX_PATH];

HMODULE g_hlibMAPI = NULL;

LPMAPILOGONEX lpMAPILogonEx = NULL;
LPMAPIINITIALIZE lpMAPIInitialize = NULL;
LPMAPIUNINITIALIZE lpMAPIUninitialize = NULL;
LPMAPIFREEBUFFER lpMAPIFreeBuffer = NULL;
LPMAPIALLOCATEBUFFER lpMAPIAllocateBuffer = NULL;
LPMAPIALLOCATEMORE lpMAPIAllocateMore = NULL;
LPMAPIADMINPROFILES lpMAPIAdminProfiles = NULL;
LPFREEPROWS lpFreeProws = NULL;
LPHRQUERYALLROWS lpHrQueryAllRows = NULL;
LPWRAPCOMPRESSEDRTFSTREAM lpWrapCompressedRTFStream = NULL;

HRESULT GetSubFolderList(LPMAPICONTAINER pcont, IMPFOLDERNODE **ppnode, IMPFOLDERNODE *pparent);
HRESULT ExchGetFolderList(HWND hwnd, IMAPISession *pmapi, IMPFOLDERNODE **pplist);
void ExchFreeFolderList(IMPFOLDERNODE *pnode);
VOID ExchFreeImsg(LPIMSG lpImsg);

static BOOL g_fMapiInit = FALSE;

CExchImport::CExchImport()
    {
    DllAddRef();

    m_cRef = 1;
    m_plist = NULL;
    m_pmapi = NULL;
    }

CExchImport::~CExchImport()
    {
    if (m_plist != NULL)
        ExchFreeFolderList(m_plist);

    if (m_pmapi != NULL)
        {
        m_pmapi->Logoff(NULL, 0, 0);
        SideAssert(0 == m_pmapi->Release());
        }

    DllRelease();
    }

ULONG CExchImport::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CExchImport::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CExchImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IMailImport == riid)
		*ppv = (IMailImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CExchImport::InitializeImport(HWND hwnd)
    {
    HRESULT hr;

    if (SUCCEEDED(hr = ExchInit()) && S_OK == (hr = MapiLogon(hwnd, &m_pmapi)))
        {
        Assert(m_pmapi != NULL);
        hr = ExchGetFolderList(hwnd, m_pmapi, &m_plist);
        }

    if (hr == hrMapiInitFail)
        {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsImportTitle),
            MAKEINTRESOURCE(idsMapiImportFailed), MAKEINTRESOURCE(idsMapiInitError),
            MB_OK | MB_ICONSTOP);
        }
    else if (hr == hrNoProfilesFound)
        {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsImportTitle),
            MAKEINTRESOURCE(idsMapiImportFailed), MAKEINTRESOURCE(idsNoMapiProfiles),
            MB_OK | MB_ICONSTOP);
        }
    else if (FAILED(hr) && hr != MAPI_E_USER_CANCEL)
        {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsImportTitle),
            MAKEINTRESOURCE(idsMapiImportFailed), MAKEINTRESOURCE(idsGenericError),
            MB_OK | MB_ICONSTOP);
        }

    return(hr);
    }

HRESULT CExchImport::GetDirectory(char *szDir, UINT cch)
    {
	return(S_FALSE);
    }

HRESULT CExchImport::SetDirectory(char *szDir)
    {
    Assert(FALSE);

	return(E_FAIL);
    }

HRESULT CExchImport::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
    {
    CExchEnumFOLDERS *pEnum;
    IMPFOLDERNODE *pnode;

    Assert(ppEnum != NULL);
    *ppEnum = NULL;

    if (dwCookie == COOKIE_ROOT)
        pnode = m_plist;
    else
        pnode = ((IMPFOLDERNODE *)dwCookie)->pchild;

    if (pnode == NULL)
        return(S_FALSE);

    pEnum = new CExchEnumFOLDERS(pnode);
    if (pEnum == NULL)
        return(E_OUTOFMEMORY);

    *ppEnum = pEnum;

    return(S_OK);
    }

static SizedSPropTagArray(1, s_taMessage) = 
    {
        1,
        {
        PR_ENTRYID,
        }
    };

STDMETHODIMP CExchImport::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
    {
    IMPFOLDERNODE *pnode;
    HRESULT hr;
    IMSG imsg;
    LPMAPITABLE ptbl;
    LPMAPICONTAINER pcont;
    ULONG cRow, i, ulObjType;
    LPSRow lprw;
    LPSPropValue lpProp;
    LPSRowSet prset;
    LPMESSAGE pmsg;

    Assert(pImport != NULL);

    pnode = (IMPFOLDERNODE *)dwCookie;
    Assert(pnode != NULL);

    hr = E_FAIL;

    pcont = (LPMAPICONTAINER)pnode->lparam;

    Assert(pcont != NULL);

    hr = pcont->GetContentsTable(0, &ptbl);
    if (FAILED(hr))
        {
        Assert(FALSE);
        return(hr);
        }

    if (!FAILED(hr = ptbl->SetColumns((LPSPropTagArray)&s_taMessage, 0)) &&
        !FAILED(hr = ptbl->GetRowCount(0, &cRow)) &&
        cRow > 0)
        {
        pImport->SetMessageCount(cRow);

        while (TRUE)
            {
            if(hr == hrUserCancel)
                break;
            if (cRow == 0)
                {
                hr = S_OK;
                break;
                }
            hr = ptbl->QueryRows(cRow, 0, &prset);
            if (FAILED(hr))
                break;
            if (prset->cRows == 0)
                {
                FreeSRowSet(prset);
                break;
                }

            for (i = 0, lprw = prset->aRow; i < prset->cRows; i++, lprw++)
                {
                if(hr == hrUserCancel)
                    break;

                lpProp = lprw->lpProps;
                Assert(lpProp->ulPropTag == PR_ENTRYID);

                hr = pcont->OpenEntry(lpProp->Value.bin.cb,
                        (LPENTRYID)lpProp->Value.bin.lpb, NULL, MAPI_BEST_ACCESS,
                        &ulObjType, (LPUNKNOWN *)&pmsg);
                Assert(!FAILED(hr));
                if (!FAILED(hr))
                    {
                    hr = HrMapiToImsg(pmsg, &imsg);
                    Assert(!FAILED(hr));
                    if (!FAILED(hr))
                        {
                        hr = pImport->ImportMessage(&imsg);

                        ExchFreeImsg(&imsg);
                        }

                    pmsg->Release();
                    }
                }

            Assert(prset->cRows <= cRow);
            cRow -= prset->cRows;

            FreeSRowSet(prset);
            }
        }

    ptbl->Release();

    return(hr);
    }

CExchEnumFOLDERS::CExchEnumFOLDERS(IMPFOLDERNODE *plist)
    {
    Assert(plist != NULL);

    m_cRef = 1;
    m_plist = plist;
    m_pnext = plist;
    }

CExchEnumFOLDERS::~CExchEnumFOLDERS()
    {

    }

ULONG CExchEnumFOLDERS::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CExchEnumFOLDERS::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CExchEnumFOLDERS::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IEnumFOLDERS == riid)
		*ppv = (IEnumFOLDERS *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CExchEnumFOLDERS::Next(IMPORTFOLDER *pfldr)
    {
    Assert(pfldr != NULL);

    if (m_pnext == NULL)
        return(S_FALSE);

    ZeroMemory(pfldr, sizeof(IMPORTFOLDER));
    pfldr->dwCookie = (DWORD_PTR)m_pnext;
    StrCpyN(pfldr->szName, m_pnext->szName, ARRAYSIZE(pfldr->szName));
    // pfldr->type = 0;
    pfldr->fSubFolders = (m_pnext->pchild != NULL);

    m_pnext = m_pnext->pnext;

    return(S_OK);
    }

HRESULT CExchEnumFOLDERS::Reset()
    {
    m_pnext = m_plist;

    return(S_OK);
    }

HRESULT ExchInit(void)
    {
    HRESULT hr;
    DWORD cb, type;
    char sz[MAX_PATH];

    if (g_fMapiInit)
        return(S_OK);

    Assert(g_hlibMAPI == NULL);

    g_hlibMAPI = LoadLibrary(c_szMapi32Dll);
    if (g_hlibMAPI == NULL)
        return(hrMapiInitFail);

    lpMAPILogonEx = (LPMAPILOGONEX)GetProcAddress(g_hlibMAPI, szMAPILogonEx);
    lpMAPIInitialize = (LPMAPIINITIALIZE)GetProcAddress(g_hlibMAPI, szMAPIInitialize);
    lpMAPIUninitialize = (LPMAPIUNINITIALIZE)GetProcAddress(g_hlibMAPI, szMAPIUninitialize);
    lpMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(g_hlibMAPI, szMAPIFreeBuffer);
    lpMAPIAllocateBuffer = (LPMAPIALLOCATEBUFFER)GetProcAddress(g_hlibMAPI, szMAPIAllocateBuffer);
    lpMAPIAllocateMore = (LPMAPIALLOCATEMORE)GetProcAddress(g_hlibMAPI, szMAPIAllocateMore);
    lpMAPIAdminProfiles = (LPMAPIADMINPROFILES)GetProcAddress(g_hlibMAPI, szMAPIAdminProfiles);
    lpFreeProws = (LPFREEPROWS)GetProcAddress(g_hlibMAPI, szFreeProws);
    lpHrQueryAllRows = (LPHRQUERYALLROWS)GetProcAddress(g_hlibMAPI, szHrQueryAllRows);
    lpWrapCompressedRTFStream = (LPWRAPCOMPRESSEDRTFSTREAM)GetProcAddress(g_hlibMAPI, szWrapCompressedRTFStream);

    if (lpMAPILogonEx == NULL ||
        lpMAPIInitialize == NULL ||
        lpMAPIUninitialize == NULL ||
        lpMAPIFreeBuffer == NULL ||
        lpFreeProws == NULL ||
        lpHrQueryAllRows == NULL ||
        lpWrapCompressedRTFStream == NULL ||
        lpMAPIAllocateBuffer == NULL || 
        lpMAPIAllocateMore == NULL)
        {
        hr = hrMapiInitFail;
        }
    else
        {
        *g_szDefClient = 0;
        cb = sizeof(sz);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegOutlook, NULL, &type, (LPBYTE)sz, &cb))
        {
            cb = sizeof(g_szDefClient);
            if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegMail, NULL, &type, (LPBYTE)g_szDefClient, &cb))
            {
                if (0 != lstrcmpi(g_szDefClient, c_szMicrosoftOutlook))
                {
                    if (ERROR_SUCCESS != SHSetValue(HKEY_LOCAL_MACHINE, c_szRegMail, NULL, REG_SZ, (LPBYTE)c_szMicrosoftOutlook, lstrlen(c_szMicrosoftOutlook) + 1))
                        *g_szDefClient = 0;
                }
                else
                {
                    *g_szDefClient = 0;
                }
            }
        }

        hr = lpMAPIInitialize(NULL);
        }

    if (SUCCEEDED(hr))
        {
        g_fMapiInit = TRUE;
        }
    else
        {
        FreeLibrary(g_hlibMAPI);
        g_hlibMAPI = NULL;
        }

    return(hr);
    }

void ExchDeinit()
    {
    if (g_fMapiInit)
        {
        Assert(g_hlibMAPI != NULL);

        lpMAPIUninitialize();

        FreeLibrary(g_hlibMAPI);
        g_hlibMAPI = NULL;

        if (*g_szDefClient != 0)
        {
            SHSetValue(HKEY_LOCAL_MACHINE, c_szRegMail, NULL, REG_SZ, (LPBYTE)g_szDefClient, lstrlen(g_szDefClient) + 1);
            *g_szDefClient = 0;
        }

        g_fMapiInit = FALSE;
        }
    }

HRESULT MapiLogon(HWND hwnd, IMAPISession **ppmapi)
    {
    HRESULT hr;
    LPPROFADMIN lpAdmin;
    LPMAPITABLE lpTable = NULL;
    ULONG ulCount = NULL;

    Assert(g_fMapiInit);
    
    if (ppmapi != NULL)
        *ppmapi = NULL;

    if (!FAILED(hr = lpMAPIAdminProfiles(0, &lpAdmin)))
        {
        Assert(lpAdmin != NULL);

        if (FAILED(hr = lpAdmin->GetProfileTable(0, &lpTable)) ||
            FAILED(hr = lpTable->GetRowCount(0, &ulCount))     || 
            !ulCount)
            {
            // could not find a valid profile

            hr = hrNoProfilesFound;
            }
        else
            {
            if (ppmapi != NULL)
                hr = lpMAPILogonEx((ULONG_PTR)hwnd, NULL, NULL, MAPI_EXTENDED | MAPI_LOGON_UI | MAPI_ALLOW_OTHERS, ppmapi);
            else
                hr = S_OK;
            }

        if (lpTable != NULL)
            lpTable->Release();

        lpAdmin->Release();
        }

    return(hr);
    }

HRESULT ExchGetFolderList(HWND hwnd, IMAPISession *pmapi, IMPFOLDERNODE **pplist)
    {
    HRESULT hr;
    LPMAPICONTAINER pcont;
    IMPFOLDERNODE *plist;

    Assert(g_fMapiInit);
    Assert(pmapi != NULL);

    hr = E_FAIL;

    pcont = OpenDefaultStoreContainer(hwnd, pmapi);
    if (pcont != NULL)
        {
        plist = NULL;

        hr = GetSubFolderList(pcont, &plist, NULL);
        Assert(!FAILED(hr));
        Assert(plist != NULL);

        *pplist = plist;

        pcont->Release();
        }

    return(hr);
    }

void ExchFreeFolderList(IMPFOLDERNODE *pnode)
    {
    Assert(pnode != NULL);

    if (pnode->pchild != NULL)
        ExchFreeFolderList(pnode->pchild);

    if (pnode->pnext != NULL)
        ExchFreeFolderList(pnode->pnext);

    if (pnode->szName != NULL)
        MemFree(pnode->szName);

    if (pnode->lparam != NULL)
        ((LPMAPICONTAINER)pnode->lparam)->Release();

    MemFree(pnode);
    }

LPMAPICONTAINER OpenDefaultStoreContainer(HWND hwnd, IMAPISession *pmapi)
    {
    HRESULT         hr;
    LPMDB           pmdb;
    LPMAPITABLE     ptbl;
    LPSRowSet       lpsrw;
    LPSRow          prw;
    ULONG           cStores,
                    cRows;
    LPSPropValue    ppvDefStore;
    LPENTRYID lpEID;
    ULONG cbEID, ulObjType, ulValues;
    LPMAPICONTAINER pcont;
    LPSPropValue lpPropsIPM = NULL;
    ULONG ulPropTags[2] = {1, PR_IPM_SUBTREE_ENTRYID};
    SizedSPropTagArray(4, pta) = 
        { 4, {PR_DEFAULT_STORE, PR_ENTRYID, PR_OBJECT_TYPE, PR_RESOURCE_FLAGS}};

    Assert(hwnd != NULL);
    Assert(pmapi != NULL);

    pmdb = NULL;
    ptbl = NULL;
    lpsrw = NULL;
    pcont = NULL;

    hr = pmapi->GetMsgStoresTable(0, &ptbl);
    if (HR_FAILED(hr))
        goto error;

    hr = lpHrQueryAllRows(ptbl,(LPSPropTagArray)&pta, NULL, NULL, 0, &lpsrw);
    if (HR_FAILED(hr))
        goto error;

    cRows = lpsrw->cRows;
    prw = &lpsrw->aRow[0];

    cStores = 0;
    ppvDefStore = NULL;

    while (cRows--)
        {
        if (prw->lpProps[2].ulPropTag == PR_OBJECT_TYPE && prw->lpProps[2].Value.l == MAPI_STORE)
            {
            if (prw->lpProps[3].ulPropTag != PR_RESOURCE_FLAGS ||
                !(prw->lpProps[3].Value.l & STATUS_NO_DEFAULT_STORE))
                cStores++;
            }

        if( prw->lpProps[0].ulPropTag == PR_DEFAULT_STORE && 
            prw->lpProps[0].Value.b)
            ppvDefStore=prw->lpProps;

        prw++;
        }

    if (!ppvDefStore || ppvDefStore[1].ulPropTag != PR_ENTRYID)
        goto error;
       
    hr = pmapi->OpenMsgStore((ULONG_PTR)hwnd, ppvDefStore[1].Value.bin.cb,
                (LPENTRYID)ppvDefStore[1].Value.bin.lpb,
                NULL, MAPI_BEST_ACCESS, &pmdb);
    if (!HR_FAILED(hr))
        {
        // Get the IPM_SUBTREE from the ROOT
        if (!FAILED(hr = pmdb->GetProps((LPSPropTagArray)&ulPropTags, 0, &ulValues, &lpPropsIPM)))
            {
            cbEID = lpPropsIPM->Value.bin.cb;
            lpEID = (LPENTRYID)lpPropsIPM->Value.bin.lpb;

            hr = pmdb->OpenEntry(cbEID, lpEID, NULL, MAPI_BEST_ACCESS,
                                    &ulObjType, (LPUNKNOWN *)&pcont);
        
            lpMAPIFreeBuffer(lpPropsIPM);
            }
        }

error:
    if (lpsrw != NULL)
        FreeSRowSet(lpsrw);
    if (ptbl != NULL)
        ptbl->Release();
    if (pmdb != NULL)
        pmdb->Release();

    return(pcont);
    }

/*
 *      FreeSRowSet
 *
 *      Purpose:
 *              Frees an SRowSet structure and the rows therein
 *
 *      Parameters:
 *              LPSRowSet               The row set to free
 */
void FreeSRowSet(LPSRowSet prws)
    {
    ULONG irw;

    if (!prws)
        return;

    // Free each row
    for (irw = 0; irw < prws->cRows; irw++)
        lpMAPIFreeBuffer(prws->aRow[irw].lpProps);

    // Free the top level structure
    lpMAPIFreeBuffer(prws);
    }

static SizedSPropTagArray(5, s_taFolder) = 
    {
        5,
        {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_SUBFOLDERS,
        PR_OBJECT_TYPE,
        PR_CONTENT_COUNT
        }
    };

enum
    {
    iDISPLAY_NAME = 0,
    iENTRYID,
    iSUBFOLDERS,
    iOBJECT_TYPE,
    iCONTENT_COUNT
    };

HRESULT GetSubFolderList(LPMAPICONTAINER pcont, IMPFOLDERNODE **ppnode, IMPFOLDERNODE *pparent)
    {
    HRESULT hr;
    IMPFOLDERNODE *pnode, *pnew, *plast;
    ULONG i, cRow, ulObj;
    int cb;
    LPSRow lprw;
    LPSPropValue lpProp;
    LPMAPITABLE ptbl;
    LPSRowSet prset;

    *ppnode = NULL;

    hr = pcont->GetHierarchyTable(0, &ptbl);
    if (FAILED(hr))
        return(hr);

    pnode = NULL;

    if (!FAILED(hr = ptbl->SetColumns((LPSPropTagArray)&s_taFolder, 0)) &&
        !FAILED(hr = ptbl->GetRowCount(0, &cRow)) &&
        cRow > 0)
        {
        while (TRUE)
            {
            if (cRow == 0)
                {
                hr = S_OK;
                break;
                }
            hr = ptbl->QueryRows(cRow, 0, &prset);
            if (FAILED(hr))
                break;
            if (prset->cRows == 0)
                {
                FreeSRowSet(prset);
                break;
                }

            for (i = 0, lprw = prset->aRow; i < prset->cRows; i++, lprw++)
                {
                if (!MemAlloc((void **)&pnew, sizeof(IMPFOLDERNODE)))
                    break;
                ZeroMemory(pnew, sizeof(IMPFOLDERNODE));

                lpProp = &lprw->lpProps[iENTRYID];
                Assert(lpProp->ulPropTag == PR_ENTRYID);
                hr = pcont->OpenEntry(lpProp->Value.bin.cb, (LPENTRYID)lpProp->Value.bin.lpb, NULL,
                                        MAPI_BEST_ACCESS, &ulObj, (LPUNKNOWN *)&pnew->lparam);
                if (FAILED(hr))
                    {
                    MemFree(pnew);
                    continue;
                    }

                lpProp = &lprw->lpProps[iCONTENT_COUNT];
                Assert(lpProp->ulPropTag == PR_CONTENT_COUNT);
                pnew->cMsg = lpProp->Value.l;

                lpProp = &lprw->lpProps[iDISPLAY_NAME];
                Assert(lpProp->ulPropTag == PR_DISPLAY_NAME);
                cb = (lstrlen(lpProp->Value.LPSZ) + 1) * sizeof(TCHAR);
                if (!MemAlloc((void **)&pnew->szName, cb))
                    break;
                StrCpyN(pnew->szName, lpProp->Value.LPSZ, cb / sizeof(TCHAR));

                pnew->depth = (pparent != NULL) ? pparent->depth + 1 : 0;

                pnew->pparent = pparent;

                if (pnode == NULL)
                    pnode = pnew;
                else
                    plast->pnext = pnew;

                plast = pnew;

                lpProp = &lprw->lpProps[iSUBFOLDERS];
                Assert(lpProp->ulPropTag == PR_SUBFOLDERS);
                if (lpProp->Value.b)
                    {
                    hr = GetSubFolderList((LPMAPICONTAINER)pnew->lparam, &pnew->pchild, pnew);
                    Assert(!FAILED(hr));
                    }
                }

            Assert(prset->cRows <= cRow);
            cRow -= prset->cRows;

            FreeSRowSet(prset);
            }
        }

    ptbl->Release();

    *ppnode = pnode;

    return(hr);
    }

LPSPropValue PvalFind(LPSRow prw, ULONG ulPropTag)
    {
    UINT            ival = 0;
    LPSPropValue    pval = NULL;

    if(!prw)
        return NULL;

    ival = (UINT) prw->cValues;
    pval = prw->lpProps;
    while (ival--)
        {
        if (pval->ulPropTag == ulPropTag)
            return pval;
        ++pval;
        }
    return NULL;
    }

VOID ExchFreeImsg (LPIMSG lpImsg)
{
    // Locals
    ULONG           i;

    // Nothing
    if (lpImsg == NULL)
        return;

    // Free Stuff
    if (lpImsg->lpszSubject)
        MemFree(lpImsg->lpszSubject);
    lpImsg->lpszSubject = NULL;

    if (lpImsg->lpstmBody)
        lpImsg->lpstmBody->Release ();
    lpImsg->lpstmBody = NULL;

    if (lpImsg->lpstmHtml)
        lpImsg->lpstmHtml->Release ();
    lpImsg->lpstmHtml = NULL;

    // Walk Address list
    for (i=0; i<lpImsg->cAddress; i++)
    {
        if (lpImsg->lpIaddr[i].lpszAddress)
            MemFree(lpImsg->lpIaddr[i].lpszAddress);
        lpImsg->lpIaddr[i].lpszAddress = NULL;

        if (lpImsg->lpIaddr[i].lpszDisplay)
            MemFree(lpImsg->lpIaddr[i].lpszDisplay);
        lpImsg->lpIaddr[i].lpszDisplay = NULL;
    }

    // Free Address list
    if (lpImsg->lpIaddr)
        MemFree(lpImsg->lpIaddr);
    lpImsg->lpIaddr = NULL;

    // Walk Attachment list
    for (i=0; i<lpImsg->cAttach; i++)
    {
        if (lpImsg->lpIatt[i].lpszFileName)
            MemFree(lpImsg->lpIatt[i].lpszFileName);
        lpImsg->lpIatt[i].lpszFileName = NULL;

        if (lpImsg->lpIatt[i].lpszPathName)
            MemFree(lpImsg->lpIatt[i].lpszPathName);
        lpImsg->lpIatt[i].lpszPathName = NULL;

        if (lpImsg->lpIatt[i].lpszExt)
            MemFree(lpImsg->lpIatt[i].lpszExt);
        lpImsg->lpIatt[i].lpszExt = NULL;

        if (lpImsg->lpIatt[i].lpImsg)
        {
            ExchFreeImsg (lpImsg->lpIatt[i].lpImsg);
            MemFree(lpImsg->lpIatt[i].lpImsg);
            lpImsg->lpIatt[i].lpImsg = NULL;
        }

        if (lpImsg->lpIatt[i].lpstmAtt)
            lpImsg->lpIatt[i].lpstmAtt->Release ();
        lpImsg->lpIatt[i].lpstmAtt = NULL;
    }

    // Free the att list
    if (lpImsg->lpIatt)
        MemFree(lpImsg->lpIatt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\athena16\impath16.cpp ===
#include "pch.hxx"
#include "impapi.h"
#include "comconv.h"
#include <newimp.h>
#include <..\Eudora\eudrimp.h>
#include <ImpAth16.h>
#include <mapi.h>
#include <mapix.h>
#include <import.h>
#include <dllmain.h>
#include <imnapi.h>
#include <commdlg.h>
#include <strconst.h>

ASSERTDATA

typedef struct tagSELATH16INFO
    {
    char szFile[MAX_PATH];
    char szUser[MAX_PATH];
    } SELATH16INFO;

INT_PTR CALLBACK ProvideIniPathProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT GetIniFilePath(SELATH16INFO *pSelAth, HWND hwnd);

static const char g_Athena16Mail[] = "c:\\Athena16\\Mail\\Mail.ini";
static const char c_szUsers[] = "Users";
static const char c_szPathFileFmt[] = "%s\\%s";
static const char c_szAsterisk[] = "*";
static const char c_szDot[] = ".";
static const char c_szDotDot[] = "..";
static const char c_szFoldersDir[] = "\\Folders";
static const char c_szMsgListFile[] = "\\msg_list";

CAthena16Import::CAthena16Import()
{
    DllAddRef();
	
    m_cRef = 1;
    m_plist = NULL;
    *m_szUser = 0;
}

CAthena16Import::~CAthena16Import()
{
    if (m_plist != NULL)
		EudoraFreeFolderList(m_plist);
	
    DllRelease();
}

ULONG CAthena16Import::AddRef()
{
    m_cRef++;
	
    return(m_cRef);
}

ULONG CAthena16Import::Release()
{
    ULONG cRef;
	
    cRef = --m_cRef;
    if (cRef == 0)
        delete this;
	
    return(cRef);
}

HRESULT CAthena16Import::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT hr = S_OK;
	
    if (ppv == NULL)
        return(E_INVALIDARG);
	
    *ppv = NULL;
	
	if (IID_IMailImport == riid)
		*ppv = (IMailImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;
	
    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
	
    return(hr);
}


HRESULT CAthena16Import::InitializeImport(HWND hwnd)
{
//	Only if the default path to the mail.ini file is 
//	incorrect prompt the user!!!

    HRESULT			hr = S_FALSE;
    int  			iRet;
	SELATH16INFO	sa;

    ZeroMemory(&sa, sizeof(sa));

	hr = GetIniFilePath(&sa, hwnd);

	StrCpyN(m_szIniFile, sa.szFile, ARRAYSIZE(m_szIniFile));

	if (GetNumUsers(sa.szFile, sa.szUser, ARRAYSIZE(sa.szUser)) > 1)
	{
		iRet = (int) DialogBoxParam(g_hInstImp, MAKEINTRESOURCE(iddSelectAth16User), hwnd, SelectAth16UserDlgProc, (LPARAM)&sa);
	    if (iRet == IDCANCEL)
			hr = S_FALSE;
		else if (iRet == IDOK)
			StrCpyN(m_szUser, sa.szUser, ARRAYSIZE(m_szUser));
		else
			hr = E_FAIL;
	}
    else
        {
        StrCpyN(m_szUser, sa.szUser, ARRAYSIZE(m_szUser));
        }
        
	return(hr);
}

INT_PTR CALLBACK SelectAth16UserDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
    HWND hwndT;
    WORD id;
    DWORD cb;
    char sz[MAX_PATH];
    SELATH16INFO *psa;
    int index;
	TCHAR szSections[1000];
	TCHAR szUserName[256];
	int nCount		= 0;
	int nOldStop	= 0;
	int nLength		= 0;


    switch (msg)
        {
        case WM_INITDIALOG:
            Assert(lParam != NULL);
            psa = (SELATH16INFO *)lParam;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)psa);

            hwndT = GetDlgItem(hwnd, IDC_USERLIST);

            // fill list
            cb = sizeof(sz);
			if(GetPrivateProfileString(c_szUsers, NULL, c_szEmpty, szSections, 1000, psa->szFile) != NULL)
			{
				StrCpyN(szUserName, (const char*)&szSections[nCount], ARRAYSIZE(szUserName)); // Copies the string up to the first NULL
				nLength = lstrlen(szUserName);
				do
				{
					SendMessage(hwndT, LB_ADDSTRING, 0, (LPARAM)szUserName);
					nCount += (nLength + 1);
					StrCpyN(szUserName, (const char*)&szSections[nCount], ARRAYSIZE(szUserName)); // Copies the string up to the first NULL
					nLength = lstrlen(szUserName);
				}while(nLength);
			}
				
            SendMessage(hwndT, LB_SETCURSEL, 0, 0);
            return(TRUE);

        case WM_COMMAND:
            id = LOWORD(wParam);
            switch (id)
                {
                case IDOK:
                    psa = (SELATH16INFO *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                    Assert(psa != NULL);

                    hwndT = GetDlgItem(hwnd, IDC_USERLIST);
                    index = (int) SendMessage(hwndT, LB_GETCURSEL, 0, 0);
                    Assert(index >= 0);
                    SendMessage(hwndT, LB_GETTEXT, (WPARAM)index, (LPARAM)psa->szUser);

                    // fall through

                case IDCANCEL:
                    EndDialog(hwnd, id);
                    return(TRUE);
                }
            break;
        }

    return(FALSE);
    }

HRESULT CAthena16Import::GetDirectory(char *szDir, UINT cch)
{
	HRESULT hr = S_FALSE;
	
    Assert(szDir != NULL);

	if (*m_szUser != 0)
		hr = GetUserDir(szDir, cch);
	if (FAILED(hr))
		  *szDir = 0;
	return(S_OK);
}

HRESULT CAthena16Import::GetUserDir(char *szDir, UINT cch)
{
	HRESULT hr;
	Assert(lstrlen(m_szUser));

	if(GetPrivateProfileString(c_szUsers, m_szUser, c_szEmpty, szDir, cch, m_szIniFile) != NULL)
	{
		StrCatBuff(szDir, c_szFoldersDir,cch);
		hr = S_OK;
	}
	else
		hr = S_FALSE;
	return hr;
}

HRESULT CAthena16Import::SetDirectory(char *szDir)
{
    HRESULT hr;
	
    Assert(szDir != NULL);
	
	// CAN WE DO SOMETHING TO VALIDATE THIS MAIL DIRECTORY!!!
	
	if (m_plist != NULL)
	{
        EudoraFreeFolderList(m_plist);
		m_plist = NULL;
	}
	
	hr=GetAthSubFolderList(szDir, &m_plist, NULL);
	
	return(hr);
}

HRESULT CAthena16Import::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
{
    CAthena16FOLDERS *pEnum;
    EUDORANODE *pnode;

    Assert(ppEnum != NULL);
    *ppEnum = NULL;
	
    if (dwCookie == COOKIE_ROOT)
        pnode = m_plist;
    else
        pnode = ((EUDORANODE *)dwCookie)->pchild;
	
    if (pnode == NULL)
        return(S_FALSE);
	
    pEnum = new CAthena16FOLDERS(pnode);
    if (pEnum == NULL)
        return(E_OUTOFMEMORY);
	
    *ppEnum = pEnum;
	
    return(S_OK);
}

STDMETHODIMP CAthena16Import::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
{
	HRESULT hr=S_OK;
	EUDORANODE* pNode = NULL;
	
	pNode  = (EUDORANODE*)dwCookie;
	hr=ProcessMessages(pNode->szFile, ARRAYSIZE(pNode->szFile), pImport);
	return hr;
}

CAthena16FOLDERS::CAthena16FOLDERS(EUDORANODE *plist)
{
    Assert(plist != NULL);
	
    m_cRef = 1;
    m_plist = plist;
    m_pnext = plist;
}

CAthena16FOLDERS::~CAthena16FOLDERS()
{
	
}

ULONG CAthena16FOLDERS::AddRef()
{
    m_cRef++;
	
    return(m_cRef);
}

ULONG CAthena16FOLDERS::Release()
{
    ULONG cRef;
	
    cRef = --m_cRef;
    if (cRef == 0)
        delete this;
	
    return(cRef);
}

HRESULT CAthena16FOLDERS::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT hr = S_OK;
	
    if (ppv == NULL)
        return(E_INVALIDARG);
	
    *ppv = NULL;
	
	if (IID_IEnumFOLDERS == riid)
		*ppv = (IEnumFOLDERS *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;
	
    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
	
    return(hr);
}

HRESULT CAthena16FOLDERS::Next(IMPORTFOLDER *pfldr)
{
    Assert(pfldr != NULL);
	
    if (m_pnext == NULL)
        return(S_FALSE);
	
    ZeroMemory(pfldr, sizeof(IMPORTFOLDER));
    pfldr->dwCookie = (DWORD_PTR)m_pnext;
    StrCpyN(pfldr->szName, m_pnext->szName, ARRAYSIZE(pfldr->szName));
    pfldr->type = m_pnext->type;
    pfldr->fSubFolders = (m_pnext->pchild != NULL);
	
    m_pnext = m_pnext->pnext;
	
    return(S_OK);
}

HRESULT CAthena16FOLDERS::Reset()
{
    m_pnext = m_plist;
	
    return(S_OK);
}


HRESULT GetAthSubFolderList(LPTSTR szInstallPath, EUDORANODE **ppList, EUDORANODE *pParent)
{
	HRESULT hr= S_OK;
	EUDORANODE *pNode=NULL,
		*pNew=NULL,
		*pLast=NULL;
    EUDORANODE *pPrevious=NULL;
	
	EUDORANODE *ptemp=NULL;
	BOOL Flag=TRUE;
	BOOL child=TRUE;
	TCHAR szInstallPathNew[MAX_PATH];
	TCHAR szInstallPathCur[MAX_PATH];
	
	WIN32_FIND_DATA fFindData;
	HANDLE hnd=NULL;
	
    wnsprintf(szInstallPathCur, ARRAYSIZE(szInstallPathCur), c_szPathFileFmt, szInstallPath, c_szAsterisk);
	
	hnd = FindFirstFile(szInstallPathCur, &fFindData); 
	if (hnd == INVALID_HANDLE_VALUE)
        return(E_FAIL);
	
	do {
		if((fFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		{
			if(!lstrcmpi(fFindData.cFileName, c_szDot) || !lstrcmpi(fFindData.cFileName, c_szDotDot))
				continue;// Do not process the system dirs!
			
		    if (!MemAlloc((void **)&pNew, sizeof(EUDORANODE)))
				goto err;
			ZeroMemory(pNew, sizeof(EUDORANODE));
			StrCpyN(pNew->szName, fFindData.cFileName, ARRAYSIZE(pNew->szName));

            wnsprintf(szInstallPathNew, ARRAYSIZE(szInstallPathNew), c_szPathFileFmt, szInstallPath, fFindData.cFileName);

			StrCpyN(pNew->szFile, szInstallPathNew, ARRAYSIZE(pNew->szFile));
			
			pNew->pparent=  pParent;
			
			pNew->depth = (pParent != NULL) ? pParent->depth + 1 : 0;
			
			if(pNode == NULL)
				pNode = pNew;
			
			pLast = pNew;

			if(Flag)
				pPrevious=pNew;
			else
			{
				if(pPrevious)
				{
					pPrevious->pnext=pNew;
					pPrevious=pNew;
				}
			}
			
			if(child)
			{
				if(pParent)
					pParent->pchild=pNew;
				child=FALSE;
			}

			GetAthSubFolderList(szInstallPathNew, &pNew->pchild,pNew);
			Flag = FALSE;
		}
		
	}while(FindNextFile(hnd, &fFindData));
	*ppList = pNode;

err:	
	if(hnd)
		FindClose(hnd);
	hnd=NULL;
	return hr;
}

HRESULT ProcessMessages(LPSTR szFileName, DWORD cchFileName, IFolderImport *pImport)
{
	HANDLE hFile=NULL;
	long uCount=0;
	long i=0;
	HRESULT hr=S_OK;
	TCHAR szpath[MAX_PATH];
	ULONG cError=0;
	
	StrCpyN(szpath, szFileName, cchFileName);
	
	StrCatBuff(szFileName,c_szMsgListFile, cchFileName);
	
	hFile = CreateFile(szFileName, 
		GENERIC_READ,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (INVALID_HANDLE_VALUE == hFile)
        return(hrNoMessages);
	
	uCount = GetMessageCount(hFile);
	
	if (uCount > 0)
	    {
        pImport->SetMessageCount(uCount);

	    for (i = 0; i < uCount; i++)
	        {	
		    hr = ProcessMsgList(hFile, szpath, pImport);
		    if (hr == hrMemory || hr == hrUserCancel)
			    break;
		    if (hr != S_OK)
			    cError++;
	        }
        }
	
    CloseHandle(hFile);
	if ((cError) && SUCCEEDED(hr))
		hr = hrCorruptMessage;

	return(hr);
}

/******************************************************************************
*  FUNCTION NAME:GetMessageCount
*
*  PURPOSE:To Get a count of number of messages inside a folder.
*
*  PARAMETERS:
*
*     IN:	Handle of the msg_list(index) file.
*
*     OUT:	
*
*  RETURNS:  LONG value which contains number of messages in a folder.
******************************************************************************/

long GetMessageCount(HANDLE hFile)
{
	MsgHeader msg;
	ULONG ulRead;
	
	if(!ReadFile(hFile, &msg.ver, 1,&ulRead,NULL))
		return(0);
	
	if(!ReadFile(hFile, &msg.TotalMessages, 4,&ulRead,NULL))
		return(0);
	if(!ReadFile(hFile, &msg.ulTotalUnread, 4,&ulRead,NULL))
		return(0);
	return(msg.TotalMessages);
	
}


/******************************************************************************
*  FUNCTION NAME:ProcessMsgList
*
*  PURPOSE:To Get the Athena16 Folders List
*
*  PARAMETERS:
*
*     IN:	Handle of the msg_list(index) file, Handle and Current folder path. 
*
*     OUT:	 
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT ProcessMsgList(HANDLE hFile, LPSTR szPath, IFolderImport* pImport)
{
	DWORD msgheader = 0;
	ULONG ulRead;
	LPSTR szmsgbuffer;
	HRESULT hResult = S_FALSE;
	
	if (!ReadFile(hFile, &msgheader, 2, &ulRead, NULL))
		return(0);
	
    if (!MemAlloc((void **)&szmsgbuffer, msgheader + 1))
        return(E_OUTOFMEMORY);
	
	if (!ReadFile(hFile, (LPVOID)szmsgbuffer, msgheader, &ulRead, NULL))
        {
        hResult = hrReadFile;
        }
    else
        {
	    szmsgbuffer[msgheader] = 0;
	    
	    hResult = ParseMsgBuffer(szmsgbuffer, szPath, pImport);
        }
	
    MemFree(szmsgbuffer);
	
	return(hResult);
}

/******************************************************************************
*  FUNCTION NAME:ParseMsgBuffer
*
*  PURPOSE:To Get the Athena16 Folders List
*
*  PARAMETERS:
*
*     IN:	Handle,current folder path,buffer which contains the msg_list file.
*
*     OUT:	 
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT ParseMsgBuffer(LPSTR szmsgbuffer, LPSTR szPath, IFolderImport *pImport)
{
    char szfilename[MAX_PATH];
    char temp[MAX_PATH];
    HRESULT hResult = S_OK;
    DWORD dwFlags = 0;	

    GetMsgFileName(szmsgbuffer, szfilename, ARRAYSIZE(szfilename));
    if (szmsgbuffer[9] == 'N')
        dwFlags = MSG_STATE_UNREAD;

    wnsprintf(temp, ARRAYSIZE(temp), c_szPathFileFmt, szPath, szfilename);

    hResult = ProcessSingleMessage(temp, dwFlags, pImport);

    return(hResult);
}

HRESULT	ProcessSingleMessage(LPTSTR szFilePath, DWORD dwFlags, IFolderImport* pImport)
{
	LPSTREAM lpstm = NULL;
	ULONG ulFileSize, cbMsg;
	ULONG ulRead;
    HANDLE mapMsg, hMsg;
	BYTE *pByteBuffer = NULL;
	HRESULT hResult = S_FALSE;

	hMsg = CreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hMsg == INVALID_HANDLE_VALUE)
        return(S_FALSE);

    cbMsg = GetFileSize(hMsg, NULL);
    if (cbMsg > 0)
        {
        mapMsg = CreateFileMapping(hMsg, NULL, PAGE_READONLY, 0, 0, NULL);
        if (mapMsg != NULL)
            {
            pByteBuffer = (BYTE *)MapViewOfFile(mapMsg, FILE_MAP_READ, 0, 0, 0);
            if (pByteBuffer != NULL)
                {
	            hResult = HrByteToStream(&lpstm, (LPBYTE)pByteBuffer, cbMsg);
                if (SUCCEEDED(hResult))
                    {
		            Assert(lpstm != NULL);

                    hResult = pImport->ImportMessage(MSG_TYPE_MAIL, dwFlags, lpstm, NULL, 0);
                    lpstm->Release();
                    }

                UnmapViewOfFile(pByteBuffer);
                }

            CloseHandle(mapMsg);
            }
        }

	CloseHandle(hMsg);

	return(hResult);
}

/******************************************************************************
*  FUNCTION NAME:GetMsgFileName
*
*  PURPOSE:Get the file name of each message from msg_list file.
*
*  PARAMETERS:
*
*     IN:	buffer which contains msg_list file
*
*     OUT:	File name of a message file.
*
*  RETURNS:  HRESULT
******************************************************************************/


HRESULT GetMsgFileName(LPCSTR szmsgbuffer, char *szfilename, DWORD cchFileName)
{
	ULONG i, ul;
	
	StrCpyN(szfilename, szmsgbuffer, cchFileName);
	szfilename[10] = 0;

	ul = lstrlen(szfilename);
    Assert(ul == 10);

    Assert(szfilename[8] == 0x01);
    szfilename[9] = szfilename[9] & 0x7f; // turn off the highbit which is used to indicate attachment
    if (szfilename[9] == ' ')
        szfilename[8] = 0;
    else
        szfilename[8] = '.';
        
	return(S_OK);
}

int GetNumUsers(char *szFile, char *szUser, DWORD cchUser)
{
	TCHAR szSections[1000];
	int nCount = 0;
	int nLoop  = 0;
	
	if (GetPrivateProfileString(c_szUsers, NULL, c_szEmpty, szSections, ARRAYSIZE(szSections), szFile) > 0)
	{
        StrCpyN(szUser, szSections, cchUser);

		while (nLoop < ARRAYSIZE(szSections))
		{
			if(szSections[nLoop] == 0)
			{
				if(szSections[nLoop+1] == 0)
				{
					nCount++;
					return nCount;
				}
				else
					nCount++;
			}
			nLoop++;
		}
	}
	return nCount;
}

HRESULT GetIniFilePath(SELATH16INFO *pSelAth, HWND hwnd)
{
	int 		nRet	= 0;
	HRESULT		hr;
	WIN32_FIND_DATA pWinFind;

	if(FindFirstFile(g_Athena16Mail, &pWinFind) == INVALID_HANDLE_VALUE)
	{
		nRet = (int) DialogBoxParam(g_hInstImp, MAKEINTRESOURCE(iddProvideMailPath), hwnd, ProvideIniPathProc, (LPARAM)pSelAth);
		if (nRet == IDCANCEL)
			hr = S_FALSE;
		else if (nRet == IDOK)
			hr = S_OK;
		else
			hr = E_FAIL;
	}
	else
	{
		StrCpyN(pSelAth->szFile, g_Athena16Mail, ARRAYSIZE(pSelAth->szFile));
		hr = S_OK;
	}

	return hr;
}

INT_PTR CALLBACK ProvideIniPathProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndT;
    WORD id;
    SELATH16INFO *psa;
    int nCount = 0;
	WIN32_FIND_DATA pWinFind;
    OPENFILENAME    ofn;
	TCHAR			szFilter[CCHMAX_STRINGRES];
	TCHAR           szFile[MAX_PATH];
    int nLen, i = 0;

    switch (uMsg)
        {
        case WM_INITDIALOG:
            Assert(lParam != NULL);
            psa = (SELATH16INFO *)lParam;
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)psa);
	        return(TRUE);

        case WM_COMMAND:
            id = LOWORD(wParam);
            switch (id)
                {
                case IDOK:
                    psa = (SELATH16INFO *)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                    Assert(psa != NULL);

                    hwndT = GetDlgItem(hwndDlg, IDC_EDT1);
                    nCount = (int) SendMessage(hwndT, WM_GETTEXT, MAX_PATH, (LPARAM)psa->szFile);
					if(nCount)
					{
						//Make sure that the file is valid
						if(FindFirstFile(psa->szFile, &pWinFind) != INVALID_HANDLE_VALUE)
						{
							EndDialog(hwndDlg, id);
							return TRUE;
						}
					}
					//No file was selected. Do not end the dialog. Put up a messagebox asking the user to slect a valid file.
					ImpMessageBox(hwndDlg, MAKEINTRESOURCE(idsImportTitle), MAKEINTRESOURCE(idsErrorMailIni), NULL, MB_OK | MB_ICONSTOP);
					return TRUE;

                    // fall through

                case IDCANCEL:
                    EndDialog(hwndDlg, id);
                    return(TRUE);

				case IDC_BUTT1:
						*szFile = 0;

						// replace the '|' characters in the filter string with nulls.
						nCount = 0;
						nLen = LoadString(g_hInstImp, idsFilterMailIni, szFilter, ARRAYSIZE(szFilter));
						while (i < nLen)
						{
							if (szFilter[i] == '|')
							{
								szFilter[i] = '\0';
								nCount++;
							}
							i++;
						}

						ZeroMemory (&ofn, sizeof(ofn));
						ofn.lStructSize = sizeof(ofn);
						ofn.hwndOwner = hwndDlg;
						ofn.lpstrFilter = szFilter;
						ofn.nFilterIndex = 1;
						ofn.lpstrFile = szFile;
						ofn.nMaxFile = sizeof(szFile);
						ofn.Flags = OFN_NOCHANGEDIR | OFN_NOREADONLYRETURN | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

						if(GetOpenFileName(&ofn))
						{
                            hwndT = GetDlgItem(hwndDlg, IDC_EDT1);
		                    SendMessage(hwndT, WM_SETTEXT, MAX_PATH, (LPARAM)szFile);
						}
						return TRUE;
                }
            break;
        }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\eudora\eudrimp.cpp ===
#include "pch.hxx"
#include "impapi.h"
#include "comconv.h"
#include <newimp.h>
#include "eudrimp.h"
#include <mapi.h>
#include <mapix.h>
#include <import.h>
#include <dllmain.h>
#include <shlwapi.h>

ASSERTDATA

HRESULT GetEudoraSubfolders(EUDORANODE *pparent, TCHAR *pdir, EUDORANODE **pplist);
HRESULT ProcessEudoraMsg(const BYTE *cMsgEntry, LPCSTR szBuffer1, ULONG uMsgSize, IFolderImport *pImport);
HRESULT FixEudoraMessage(LPCSTR szBuffer, ULONG uSize, BOOL fAttach, char **pszBufferNew, ULONG *puSizeNew, TCHAR ***prgszAttach, DWORD *pcAttach);
HRESULT FixSentItemDate(LPCSTR szBuffer, ULONG uMsgSize, char **szNewBuffer, ULONG *uNewMsgSize);
LPCSTR GetMultipartContentTypeHeader(LPCSTR szBuffer, LPCSTR szEnd, LPCSTR *pNext);
LPCSTR GetBody(LPCSTR szBuffer, ULONG uSize);
HRESULT FormatDate(LPCSTR szFromLine, char *szRecHdr, int cchMax);

CEudoraImport::CEudoraImport()
    {
    DllAddRef();

    m_cRef = 1;
    m_plist = NULL;
    }

CEudoraImport::~CEudoraImport()
    {
    if (m_plist != NULL)
        EudoraFreeFolderList(m_plist);

    DllRelease();
    }

ULONG CEudoraImport::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CEudoraImport::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CEudoraImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IMailImport == riid)
		*ppv = (IMailImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CEudoraImport::InitializeImport(HWND hwnd)
    {
	return(S_OK);
    }

HRESULT CEudoraImport::GetDirectory(char *szDir, UINT cch)
    {
	HRESULT hr;

    Assert(szDir != NULL);

    hr = GetClientDir(szDir, cch, EUDORA);
    if (FAILED(hr))
        *szDir = 0;

	return(S_OK);
    }

HRESULT CEudoraImport::SetDirectory(char *szDir)
    {
    HRESULT hr;

    Assert(szDir != NULL);
    
    if (!ValidStoreDirectory(szDir, EUDORA))
        return(S_FALSE);

    if (m_plist != NULL)
        {
        EudoraFreeFolderList(m_plist);
        m_plist = NULL;
        }

    hr = GetEudoraSubfolders(NULL, szDir, &m_plist);
	
    if (m_plist == NULL)
        hr = E_FAIL;

	return(hr);
    }

HRESULT CEudoraImport::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
    {
    CEudoraEnumFOLDERS *pEnum;
    EUDORANODE *pnode;

    Assert(ppEnum != NULL);
    *ppEnum = NULL;

    if (dwCookie == COOKIE_ROOT)
        pnode = m_plist;
    else
        pnode = ((EUDORANODE *)dwCookie)->pchild;

    if (pnode == NULL)
        return(S_FALSE);

    pEnum = new CEudoraEnumFOLDERS(pnode);
    if (pEnum == NULL)
        return(E_OUTOFMEMORY);

    *ppEnum = pEnum;

    return(S_OK);
    }

STDMETHODIMP CEudoraImport::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
    {
    EUDORANODE *pnode;
    HRESULT hr;
	TCHAR cTocFile[MAX_PATH];
    BYTE *pToc, *pEnd, *pT, *pLast, *pMbx, *pNextMsg, *pEndMbx;
	ULONG i, lMsgs, cbToc, cbMbx, uMsgSize, uOffset;
    HANDLE mapToc, mapMbx;
	HANDLE hToc, hMbx;

    Assert(pImport != NULL);

    pnode = (EUDORANODE *)dwCookie;
    Assert(pnode != NULL);

	// check if it is a folder, folder does not contain any messages
	if (pnode->iFileType == FOL_FILE)
		return(S_OK);
	Assert(pnode->iFileType == MBX_FILE);

    hr = E_FAIL;
    pToc = NULL;
    mapToc = NULL;
    pMbx = NULL;
    mapMbx = NULL;

	StrCpyN(cTocFile, pnode->szFile, ARRAYSIZE(cTocFile));
    cTocFile[lstrlen(cTocFile) - 3] = TEXT('\0');
	StrCatBuff(cTocFile, "toc", ARRAYSIZE(cTocFile));

	hMbx = CreateFile(pnode->szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hMbx == INVALID_HANDLE_VALUE)
		return(hrFolderOpenFail);

    cbMbx = GetFileSize(hMbx, NULL);
    if (cbMbx == 0)
        {
        // no messages, so no point in continuing
        CloseHandle(hMbx);
        return(S_OK);
        }

	hToc = CreateFile(cTocFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hToc == INVALID_HANDLE_VALUE)
        {
        CloseHandle(hMbx);
        return(hrFolderOpenFail);
        }

    cbToc = GetFileSize(hToc, NULL);
    if (cbToc < 104)
        {
        // the .toc file header is 104 bytes in size, so anything less
        // than this is bogus or doesn't have messages anyway, so no point
        // in continuing
        goto DoneImport;
        }

    mapToc = CreateFileMapping(hToc, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapToc == NULL)
        goto DoneImport;

    pToc = (BYTE *)MapViewOfFile(mapToc, FILE_MAP_READ, 0, 0, 0);
    if (pToc == NULL)
        goto DoneImport;

    pEnd = pToc + cbToc;

    // .toc file contains first x chars of folder name NULL terminated
    // x is usually 31 chars but we've seen cases where it is 28
    // we'll require there to be at least first 24 chars of folder name
    // because this is our only .toc file validation
    pT = &pToc[8];
    for (i = 0; i < 31; i++)
        {
        if (pT[i] == 0)
            {
            if (pnode->szName[i] == 0 || i >= 24)
                break;
            else
                goto DoneImport;
            }
        else if (pnode->szName[i] == 0 || (BYTE)pT[i] != (BYTE)pnode->szName[i])
            {
            // this is a bogus .snm file
            goto DoneImport;
            }
        }

    // # of messages in the folder
	lMsgs = (unsigned long)pToc[102] +
            (unsigned long)pToc[103] * 256;
	if (lMsgs == 0)
        {
        hr = S_OK;
        goto DoneImport;
        }

    mapMbx = CreateFileMapping(hMbx, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapMbx == NULL)
        goto DoneImport;

    pMbx = (BYTE *)MapViewOfFile(mapMbx, FILE_MAP_READ, 0, 0, 0);
    if (pMbx == NULL)
        goto DoneImport;

    pEndMbx = pMbx + cbMbx;

    pImport->SetMessageCount(lMsgs);

    pT = &pToc[104];
    pLast = pMbx;
	for (i = 0; i < lMsgs; i++)
	    {
        if (pT + 218 > pEnd)
            break;

	    uOffset = (unsigned long)pT[0] +
                    (unsigned long)pT[1] * 256 +
                    (unsigned long)pT[2] * 65536 +
                    (unsigned long)pT[3] * 16777216;
        uMsgSize = (unsigned long)pT[4] +
                    (unsigned long)pT[5] * 256 +
                    (unsigned long)pT[6] * 65536 +
                    (unsigned long)pT[7] * 16777216;

        pNextMsg = pMbx + uOffset;

        if (pNextMsg + uMsgSize > pEndMbx)
            {
            // probably not a good idea to read past the end of the message file...
            break;
            }

		hr = ProcessEudoraMsg(pT, (LPCSTR)pNextMsg, uMsgSize, pImport);
        if (hr == E_OUTOFMEMORY || hr == hrDiskFull || hr == hrUserCancel)
            goto DoneImport;

        pLast = pNextMsg + uMsgSize;

        pT += 218;
	    }

    hr = S_OK;

DoneImport:
    if (pToc != NULL)
        UnmapViewOfFile(pToc);
    if (mapToc != NULL)
        CloseHandle(mapToc);

    if (pMbx != NULL)
        UnmapViewOfFile(pMbx);
    if (mapMbx != NULL)
        CloseHandle(mapMbx);

	CloseHandle(hToc);
	CloseHandle(hMbx);

	return(hr);
    }

CEudoraEnumFOLDERS::CEudoraEnumFOLDERS(EUDORANODE *plist)
    {
    Assert(plist != NULL);

    m_cRef = 1;
    m_plist = plist;
    m_pnext = plist;
    }

CEudoraEnumFOLDERS::~CEudoraEnumFOLDERS()
    {

    }

ULONG CEudoraEnumFOLDERS::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CEudoraEnumFOLDERS::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CEudoraEnumFOLDERS::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IEnumFOLDERS == riid)
		*ppv = (IEnumFOLDERS *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CEudoraEnumFOLDERS::Next(IMPORTFOLDER *pfldr)
    {
    Assert(pfldr != NULL);

    if (m_pnext == NULL)
        return(S_FALSE);

    ZeroMemory(pfldr, sizeof(IMPORTFOLDER));
    pfldr->dwCookie = (DWORD_PTR)m_pnext;
    StrCpyN(pfldr->szName, m_pnext->szName, ARRAYSIZE(pfldr->szName));
    pfldr->type = m_pnext->type;
    pfldr->fSubFolders = (m_pnext->pchild != NULL);

    m_pnext = m_pnext->pnext;

    return(S_OK);
    }

HRESULT CEudoraEnumFOLDERS::Reset()
    {
    m_pnext = m_plist;

    return(S_OK);
    }

void EudoraFreeFolderList(EUDORANODE *plist)
    {
    EUDORANODE *pnode;

    while (plist != NULL)
        {
        if (plist->pchild != NULL)
            EudoraFreeFolderList(plist->pchild);
        pnode = plist;
        plist = plist->pnext;
        MemFree(pnode);
        }
    }

const static char c_szInMbx[] = "In.mbx";
const static char c_szTrashMbx[] = "Trash.mbx";

typedef struct tagEUDORASPECIAL
    {
    const char *szFile;
    IMPORTFOLDERTYPE type;
    } EUDORASPECIAL;

const static EUDORASPECIAL c_rges[] =
    {
        {c_szInMbx, FOLDER_TYPE_INBOX},
        {c_szTrashMbx, FOLDER_TYPE_DELETED}
    };

BYTE *GetEudoraFolderInfo(EUDORANODE *pnode, TCHAR *pdir, BYTE *pcurr, BYTE *pend)
    {
    char *pT, *szFile;
    int i, cch;
    const EUDORASPECIAL *pes;
    BOOL fFound;

    Assert(pnode != NULL);
    Assert(pdir != NULL);
    Assert(pcurr != NULL);
    Assert(pend != NULL);
    Assert((DWORD_PTR)pcurr < (DWORD_PTR)pend);

    // get folder name
    pT = pnode->szName;
    fFound = FALSE;
    while (pcurr < pend)
        {
        if (*pcurr == ',')
            {
            fFound = TRUE;
            *pT = 0;
            pcurr++;
            break;
            }

        *pT = *pcurr;
        pT++;
        pcurr++;
        }

    if (!fFound)
        return(NULL);

    // get folder file
    // get folder file
    StrCpyN(pnode->szFile, pdir, ARRAYSIZE(pnode->szFile));
    cch = lstrlen(pnode->szFile);
    if (pnode->szFile[cch - 1] != '\\')
        {
        pnode->szFile[cch] = '\\';
        cch++;
        pnode->szFile[cch] = 0;
        }
    pT = &pnode->szFile[cch];
    szFile = pT;
    fFound = FALSE;
    while (pcurr < pend)
        {
        if (*pcurr == ',')
            {
            fFound = TRUE;
            *pT = 0;
            pcurr++;
            break;
            }

        *pT = *pcurr;
        pT++;
        pcurr++;
        }

    if (!fFound)
        return(NULL);

    // determine the file type
    cch = lstrlen(pnode->szFile);
    Assert(cch > 3);
    pT = &pnode->szFile[cch - 4];
    Assert(*pT == '.');
    if (*pT != '.')
        return(NULL);
    pT++;
    if (0 == lstrcmpi(pT, "fol"))
        pnode->iFileType = FOL_FILE;
    else if (0 == lstrcmpi(pT, "mbx"))
        pnode->iFileType = MBX_FILE;
    else
        return(NULL);

    if (pnode->iFileType == MBX_FILE &&
        pcurr < pend &&
        *pcurr == 'S')
        {
        // it's a special mailbox
        pes = c_rges;
        for (i = 0; i < ARRAYSIZE(c_rges); i++)
            {
            if (0 == lstrcmpi(szFile, pes->szFile))
                {
                pnode->type = pes->type;
                break;
                }

            pes++;
            }
        }

    // go to the end of the line
    fFound = FALSE;
    while (pcurr < (pend - 1))
        {
        if (*pcurr == 0x0d && *(pcurr + 1) == 0x0a)
            {
            fFound = TRUE;
            pcurr += 2;
            break;
            }

        pcurr++;
        }

    return(fFound ? pcurr : NULL);
    }

const static TCHAR c_szDescMap[] = TEXT("descmap.pce");

HRESULT GetEudoraSubfolders(EUDORANODE *pparent, TCHAR *pdir, EUDORANODE **pplist)
    {
    int cch;
    DWORD cbPce;
	HANDLE filePce, mapPce;
    BYTE *pPce, *pcurr, *pend;
	TCHAR path[MAX_PATH];
	EUDORANODE *plist, *pnode;

    Assert(pplist != NULL);
    Assert(pdir != NULL);

    *pplist = NULL;
    plist = NULL;

    StrCpyN(path, pdir, ARRAYSIZE(path));
    cch = lstrlen(path);
    if (path[cch - 1] != '\\')
        {
        path[cch] = '\\';
        cch++;
        path[cch] = 0;
        }
    StrCatBuff(path, c_szDescMap, ARRAYSIZE(path));

    filePce = CreateFile(path, GENERIC_READ, FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, 0, NULL);
    if (filePce == INVALID_HANDLE_VALUE)
        {
        // although this failed, lets try to continue
        return(S_OK);
        }

    cbPce = GetFileSize(filePce, NULL);

    mapPce = CreateFileMapping(filePce, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapPce != NULL)
        {
        pPce = (BYTE *)MapViewOfFile(mapPce, FILE_MAP_READ, 0, 0, 0);
        if (pPce != NULL)
            {
            pcurr = pPce;
            pend = pPce + cbPce;

            while (pcurr < pend)
                {
                if (!MemAlloc((void **)&pnode, sizeof(EUDORANODE)))
                    break;
                ZeroMemory(pnode, sizeof(EUDORANODE));

                pcurr = GetEudoraFolderInfo(pnode, pdir, pcurr, pend);
                if (pcurr == NULL)
                    {
                    // an error occurred and we can't recover
                    // so we'll just exit and try to carry on with what we have
                    MemFree(pnode);
                    break;
                    }

                if (plist == NULL)
                    {
                    plist = pnode;
                    }
                else
                    {
                    pnode->pnext = plist;
                    plist = pnode;
                    }

                pnode->pparent = pparent;
                pnode->depth = (pparent == NULL ? 0 : (pparent->depth + 1));

                if (pnode->iFileType == FOL_FILE)
                    GetEudoraSubfolders(pnode, pnode->szFile, &pnode->pchild);
                }

            UnmapViewOfFile(pPce);
            }

        CloseHandle(mapPce);
        }

    CloseHandle(filePce);

    *pplist = plist;

    return(S_OK);
    }

HRESULT ProcessEudoraMsg(const BYTE *cMsgEntry, LPCSTR szBuffer1, ULONG uMsgSize, IFolderImport *pImport)
{
    HRESULT hr;
    BOOL fAttach;
    TCHAR **rgszAttach;
	ULONG uMsgSize2;
    DWORD dw, dwState, cAttach;
    BYTE pri;
	LPSTR szBuffer2 = NULL;
    LPSTR szBuffer3 = NULL;
	LPSTREAM lpstm = NULL;

    Assert(cMsgEntry != NULL);
    Assert(pImport != NULL);

	fAttach = !!(cMsgEntry[15] & 0x80);

    // 0 = unread
    // 1 = read
    // 2 = replied
    // 3 = forwarded
    // 4 = redirected
    // 5 = unsendable
    // 6 = sendable
    // 7 = queued
    // 8 = sent
    // 9 = unsent
    dwState = 0;
	switch (cMsgEntry[12])
	    {
        case 0:
            dwState |= MSG_STATE_UNREAD;
            break;

        case 5:
		case 6:
        case 9:
            dwState |= MSG_STATE_UNSENT;
			break;

		case 7:
            dwState |= MSG_STATE_SUBMITTED;
			break;
    	}

    pri = cMsgEntry[16];
    if (pri <= 2)
        dwState |= MSG_PRI_HIGH;
    else if (pri > 3)
        dwState |= MSG_PRI_LOW;
    else
        dwState |= MSG_PRI_NORMAL;

    hr = FixEudoraMessage(szBuffer1, uMsgSize, fAttach, (char **)&szBuffer2, &uMsgSize2, &rgszAttach, &cAttach);
    if (hr == S_OK)
        {
        Assert(szBuffer2 != NULL);
        szBuffer1 = szBuffer2;
        uMsgSize = uMsgSize2;
        }
    else if (FAILED(hr))
        {
        return(hr);
        }

    hr = FixSentItemDate(szBuffer1, uMsgSize, (char **)&szBuffer3, &uMsgSize2);
    if (hr == S_OK)
    {
        Assert(szBuffer3 != NULL);
        szBuffer1 = szBuffer3;
        uMsgSize = uMsgSize2;
    }

    if (SUCCEEDED(hr))
    {
#ifdef DEBUG
        if (cAttach > 0)
            Assert(rgszAttach != NULL);
        else
            Assert(rgszAttach == NULL);
#endif // DEBUG

        hr = HrByteToStream(&lpstm, (LPBYTE)szBuffer1, uMsgSize);
        if (SUCCEEDED(hr))
        {
            Assert(lpstm != NULL);

            hr = pImport->ImportMessage(MSG_TYPE_MAIL, dwState, lpstm, (const TCHAR **)rgszAttach, cAttach);

            lpstm->Release();
        }
    }

    if (szBuffer2 != NULL)
        MemFree(szBuffer2);

    if (szBuffer3 != NULL)
        MemFree(szBuffer3);

    if (cAttach > 0)
    {
        for (dw = 0; dw < cAttach; dw++)
            MemFree(rgszAttach[dw]);

        MemFree(rgszAttach);
    }

    return(hr);
}

LPCSTR GetNextMessageLine(LPCSTR sz, LPCSTR szEnd, BOOL fHeader)
    {
    Assert(sz != NULL);
    Assert(szEnd != NULL);

    if (fHeader && *sz == 0x0d && *(sz + 1) == 0x0a)
        {
        // no more headers
        return(NULL);
        }

    while (sz < (szEnd - 1))
        {
        if (*sz == 0x0d && *(sz + 1) == 0x0a)
            {
            sz += 2;
            return(sz);
            }
        else
            {
            sz++;
            }
        }

    return(NULL);
    }

#define FileExists(_szFile)     (GetFileAttributes(_szFile) != 0xffffffff)

// Attachment Converted: "<file>"\r\n (quotes are optional)
static const char c_szAttConv[] = "Attachment Converted: ";

LPCSTR GetNextAttachment(LPCSTR szBuffer, LPCSTR szEnd, LPCSTR *ppNextLine, LPSTR szAtt)
    {
    int cb;
    LPCSTR sz, szNext, szFile;

    Assert(szBuffer != NULL);
    Assert(szEnd != NULL);
    Assert(ppNextLine != NULL);
    Assert(szAtt != NULL);

    *ppNextLine = NULL;
    sz = szBuffer;

    while (sz != NULL)
        {
        if ((sz + ARRAYSIZE(c_szAttConv)) >= szEnd)
            break;

        if (0 == memcmp(sz, c_szAttConv, ARRAYSIZE(c_szAttConv) - 1))
            {
            szFile = sz + (ARRAYSIZE(c_szAttConv) - 1);
            if (*szFile == '"')
                szFile++;

            szNext = GetNextMessageLine(sz, szEnd, FALSE);
            if (szNext == NULL)
                return(NULL);

            // copy attachment file name
            Assert((DWORD_PTR)szNext > (DWORD_PTR)szFile);
            cb = (int) (szNext - szFile);
            // we're not interested in the CRLF
            cb -= 2;
            if (cb > 0 && cb < MAX_PATH)
                {
                CopyMemory(szAtt, szFile, cb);
                if (szAtt[cb - 1] == '"')
                    cb--;
                szAtt[cb] = 0;

                if (FileExists(szAtt))
                    {
                    *ppNextLine = szNext;
                    return(sz);
                    }
                }
            }

        sz = GetNextMessageLine(sz, szEnd, FALSE);
        }

    return(NULL);
    }

#define CATTACH     16

static const char c_szContentType[] = "Content-Type:";
static const char c_szMultipart[] = "multipart";
static const char c_szTextPlain[] = "text/plain\r\n";
static const char c_szTextHtml[] = "text/html\r\n";
static const char c_szTextEnriched[] = "text/enriched\r\n";
static const char c_szXhtml[] = "<x-html>";
static const char c_szRich[] = "<x-rich>";
static const char c_szCRLF[] = "\r\n";

enum {
    TEXT_PLAIN = 0,
    TEXT_HTML,
    TEXT_RICH
    };

HRESULT FixEudoraMessage(LPCSTR szBuffer, ULONG uSize, BOOL fAttach, char **pszBufferNew, ULONG *puSizeNew, TCHAR ***prgszAttach, DWORD *pcAttach)
    {
    ULONG cb;
    DWORD cAttach, cAttachBuf;
    char *szAttach, **rgszAttach, *szBufferNew, *pT;
    char szBody[16];
    int text;
    LPCSTR szType, pContentType, pBody, pNext;

    Assert(szBuffer != NULL);
    Assert(pszBufferNew != NULL);
    Assert(puSizeNew != NULL);
    Assert(prgszAttach != NULL);
    Assert(pcAttach != NULL);

    *pszBufferNew = NULL;
    *prgszAttach = NULL;
    *pcAttach = 0;
    cAttach = 0;
    cAttachBuf = 0;
    rgszAttach = NULL;
    text = TEXT_PLAIN;

    pBody = GetBody(szBuffer, uSize);
    if (pBody == NULL)
        return(S_FALSE);

    pContentType = GetMultipartContentTypeHeader(szBuffer, pBody, &pNext);
    if (pContentType == NULL && !fAttach)
        return(S_FALSE);

    CopyMemory(szBody, pBody, ARRAYSIZE(c_szXhtml) - 1);
    szBody[ARRAYSIZE(c_szXhtml) - 1] = 0;
    if (0 == lstrcmpi(szBody, c_szXhtml))
        text = TEXT_HTML;
    else if (0 == lstrcmpi(szBody, c_szRich))
        text = TEXT_RICH;

    if (!MemAlloc((void **)&szBufferNew, uSize + 1))
		return(E_OUTOFMEMORY);
    pT = szBufferNew;

    if (pContentType != NULL)
        {
        // copy everything before content type header
        cb = (ULONG) (pContentType - szBuffer);
        CopyMemory(szBufferNew, szBuffer, cb);

        // write new content type header
        pT += cb;
        if (text == TEXT_HTML)
            szType = c_szTextHtml;
        else if (text == TEXT_RICH)
            szType = c_szTextEnriched;
        else
            {
            Assert(text == TEXT_PLAIN);
            szType = c_szTextPlain;
            }
        cb = lstrlen(szType);
        CopyMemory(pT, szType, cb);
        pT += cb;

        // copy remainder of headers
        if (pNext != NULL)
            {
            Assert((ULONG_PTR)pBody > (ULONG_PTR)pNext);
            cb = (ULONG)(pBody - pNext);
            CopyMemory(pT, pNext, cb);
            pT += cb;
            }
        else
            {
            // in case there was no other header following the content type header
            CopyMemory(pT, c_szCRLF, 2);
            pT += 2;
            }
        }
    else
        {
        Assert(fAttach);
        Assert((ULONG_PTR)pBody > (ULONG_PTR)szBuffer);
        cb = (ULONG)(pBody - szBuffer);
        CopyMemory(pT, szBuffer, cb);
        pT += cb;
        }

    if (fAttach)
        {
        LPCSTR pCurr, pAtt, pNextLine, pEnd;
        char szAtt[MAX_PATH];

        pCurr = pBody;
        pEnd = szBuffer + uSize;
        while (TRUE)
            {
            pAtt = GetNextAttachment(pCurr, pEnd, &pNextLine, szAtt);
            if (pAtt == NULL)
                {
                // we're at the end of the message
                // copy whatever remains from the original buffer to the new buffer
                cb = uSize - (ULONG) (pCurr - szBuffer);
                CopyMemory(pT, pCurr, cb);
                pT += cb;

                break;
                }

            if (cAttach == cAttachBuf)
                {
                if (!MemRealloc((void **)&rgszAttach, (cAttachBuf + CATTACH) * sizeof(TCHAR *)))
                    {
                    if (rgszAttach != NULL)
                        MemFree(rgszAttach);
                    MemFree(szBufferNew);
                    return(E_OUTOFMEMORY);
                    }
                cAttachBuf += CATTACH;
                }

            Assert(rgszAttach != NULL);
            if (!MemAlloc((void **)&szAttach, MAX_PATH * sizeof(TCHAR)))
                {
                MemFree(rgszAttach);
                MemFree(szBufferNew);
                return(E_OUTOFMEMORY);
                }
            StrCpyN(szAttach, szAtt, MAX_PATH);
            rgszAttach[cAttach] = szAttach;
            cAttach++;

            if (pCurr != pAtt)
                {
                cb = (ULONG)(pAtt - pCurr);
                CopyMemory(pT, pCurr, cb);
                pT += cb;
                }

            if (pNextLine >= pEnd)
                break;

            pCurr = pNextLine;
            }
        }
    else
        {
        // just copy body into new buffer
        cb = uSize - (ULONG)(pBody - szBuffer);
        CopyMemory(pT, pBody, cb);
        pT += cb;
        }

    *pT = 0;
    *pszBufferNew = szBufferNew;
    *puSizeNew = (ULONG)(pT - szBufferNew);

    *prgszAttach = rgszAttach;
    *pcAttach = cAttach;

    return(S_OK);
    }

LPCSTR GetMultipartContentTypeHeader(LPCSTR szBuffer, LPCSTR szEnd, LPCSTR *pNext)
    {
    LPCSTR sz, szT;

    Assert(szBuffer != NULL);
    Assert(szEnd != NULL);
    Assert(pNext != NULL);

    *pNext = NULL;
    sz = szBuffer;

    while (sz != NULL)
        {
        if (0 == StrCmpNI(sz, c_szContentType, lstrlen(c_szContentType)))
            {
            sz += lstrlen(c_szContentType);
            if (*sz == 0x20)
                sz++;

            if (0 == StrCmpNI(sz, c_szMultipart, lstrlen(c_szMultipart)))
                {
                szT = sz;
                // find the next header line
                do {
                    szT = GetNextMessageLine(szT, szEnd, TRUE);
                    if (szT == NULL)
                        break;
                    }
                while (*szT == 0x09 || *szT == 0x20);

                *pNext = szT;
                return(sz);
                }

            break;
            }

        sz = GetNextMessageLine(sz, szEnd, TRUE);
        }

    return(NULL);
    }

LPCSTR GetBody(LPCSTR szBuffer, ULONG uSize)
    {
    LPCSTR sz, szEnd;

    Assert(szBuffer != NULL);
    Assert(uSize > 0);
    sz = szBuffer;
    szEnd = szBuffer + uSize;

    while (sz != NULL)
        {
        if (*sz == 0x0d && *(sz + 1) == 0x0a)
            {
            sz += 2;
            break;
            }

        sz = GetNextMessageLine(sz, szEnd, TRUE);
        }

    return(sz);
    }

static const char c_szRecHdr[] = "Received:";
static const char c_szFromHdr[] = "From ???@??? ";
static const char c_szIRecHdr[] = "Received:  ; ";

HRESULT FixSentItemDate(LPCSTR szBuffer, ULONG uMsgSize, char **pszNewBuffer, ULONG *puNewMsgSize)
{
    HRESULT hr;
    int cch;
    BOOL fReceived;
    LPCSTR pBody, pHeader;
    char *szNew, szFrom[80], szReceived[80];

    Assert(lstrlen(c_szFromHdr) == lstrlen(c_szFromHdr));

    Assert(szBuffer != NULL);
    Assert(pszNewBuffer != NULL);
    Assert(puNewMsgSize != NULL);

    *pszNewBuffer = NULL;

    pHeader = szBuffer;
    pBody = GetBody(szBuffer, uMsgSize);
    if (pBody == NULL)
        return(S_FALSE);

    if (0 != StrCmpNI(pHeader, c_szFromHdr, lstrlen(c_szFromHdr)))
        return(S_FALSE);
    pHeader = GetNextMessageLine(pHeader, pBody, TRUE);
    if (pHeader == NULL)
        return(S_FALSE);

    cch = (int)(pHeader - szBuffer);
    if (cch >= ARRAYSIZE(szFrom))
        return(S_FALSE);
    StrCpyN(szFrom, szBuffer, cch - 1);

    fReceived = FALSE;

    while (pHeader != NULL)
    {
        if (0 == StrCmpNI(pHeader, c_szRecHdr, lstrlen(c_szRecHdr)))
        {
            fReceived = TRUE;
            break;
        }

        pHeader = GetNextMessageLine(pHeader, pBody, TRUE);
    }

    if (!fReceived)
    {
        FormatDate(szFrom, szReceived, ARRAYSIZE(szReceived));
        cch = lstrlen(szReceived);

        if (!MemAlloc((void **)&szNew, uMsgSize + cch))
            return(S_FALSE);

        CopyMemory(szNew, szReceived, cch);
        CopyMemory(&szNew[cch], szBuffer, uMsgSize);

        *pszNewBuffer = szNew;
        *puNewMsgSize = uMsgSize + cch;

        return(S_OK);
    }

    return(S_FALSE);
}

static const char c_szRecFmt[] = "%s ; %s %c%02d%02d\r\n";

HRESULT FormatDate(LPCSTR szFromLine, char *szRecHdr, int cchMax)
{
    DWORD dwTimeZoneId;
    TIME_ZONE_INFORMATION tzi;
    LONG lTZBias, lTZHour, lTZMinute;
    char cTZSign;

    Assert(szFromLine != NULL);
    Assert(szRecHdr != NULL);

    dwTimeZoneId = GetTimeZoneInformation(&tzi);
    switch (dwTimeZoneId)
    {
        case TIME_ZONE_ID_STANDARD:
            lTZBias = tzi.Bias + tzi.StandardBias;
            break;

        case TIME_ZONE_ID_DAYLIGHT:
            lTZBias = tzi.Bias + tzi.DaylightBias;
            break;

        case TIME_ZONE_ID_UNKNOWN:
        default:
            lTZBias = 0;   // $$BUG:  what's supposed to happen here?
            break;
    }

    lTZHour   = lTZBias / 60;
    lTZMinute = lTZBias % 60;
    cTZSign     = (lTZHour < 0) ? '+' : '-';

    szFromLine += lstrlen(c_szFromHdr);
    wnsprintf(szRecHdr, cchMax, c_szRecFmt,
                c_szRecHdr, szFromLine, cTZSign, abs(lTZHour), abs(lTZMinute));

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\exchange\mapiconv.h ===
// =====================================================================================
// MAPI IMessage to IMN message
// =====================================================================================
#ifndef __MAPICONV_H
#define __MAPICONV_H

// {0A522732-A626-11D0-8D60-00C04FD6202B}
DEFINE_GUID(CLSID_CExchImport, 0x0A522732L, 0xA626, 0x11D0, 0x8D, 0x60, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

#include "MAPI.H"
#include "MAPIX.H"

typedef struct tagIMPFOLDERNODE IMPFOLDERNODE;

typedef void (STDAPICALLTYPE FREEPROWS)(LPSRowSet lpRows);
typedef FREEPROWS FAR *LPFREEPROWS;

typedef HRESULT (STDAPICALLTYPE HRQUERYALLROWS)(LPMAPITABLE lpTable, 
                        LPSPropTagArray lpPropTags,
                        LPSRestriction lpRestriction,
                        LPSSortOrderSet lpSortOrderSet,
                        LONG crowsMax,
                        LPSRowSet FAR *lppRows);
typedef HRQUERYALLROWS FAR *LPHRQUERYALLROWS;

typedef HRESULT (STDAPICALLTYPE WRAPCOMPRESSEDRTFSTREAM)(LPSTREAM lpCompressedRTFStream,
                        ULONG ulFlags,
                        LPSTREAM FAR * lpUncompressedRTFStream);
typedef WRAPCOMPRESSEDRTFSTREAM FAR *LPWRAPCOMPRESSEDRTFSTREAM;

extern HMODULE g_hlibMAPI;

extern LPMAPILOGONEX        lpMAPILogonEx;
extern LPMAPIINITIALIZE     lpMAPIInitialize;
extern LPMAPIUNINITIALIZE   lpMAPIUninitialize;
extern LPMAPIALLOCATEBUFFER lpMAPIAllocateBuffer;
extern LPMAPIALLOCATEMORE   lpMAPIAllocateMore;
extern LPMAPIFREEBUFFER     lpMAPIFreeBuffer;
extern LPFREEPROWS          lpFreeProws;
extern LPHRQUERYALLROWS     lpHrQueryAllRows;
extern LPWRAPCOMPRESSEDRTFSTREAM lpWrapCompressedRTFStream;

typedef struct IMSG IMSG, *LPIMSG;

HRESULT HrMapiToImsg(LPMESSAGE lpMessage, LPIMSG lpImsg);
HRESULT HrImsgToMapi(LPIMSG lpImsg, LPMESSAGE lpMessage);

class CExchEnumFOLDERS : public IEnumFOLDERS
    {
    private:
        ULONG           m_cRef;
        IMPFOLDERNODE   *m_plist;
        IMPFOLDERNODE   *m_pnext;

    public:
        CExchEnumFOLDERS(IMPFOLDERNODE *plist);
        ~CExchEnumFOLDERS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP Next(IMPORTFOLDER *pfldr);
        STDMETHODIMP Reset(void);
    };

class CExchImport : public IMailImport
    {
    private:
        ULONG           m_cRef;
        IMPFOLDERNODE   *m_plist;
        IMAPISession    *m_pmapi;

    public:
        CExchImport(void);
        ~CExchImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP InitializeImport(HWND hwnd);
        STDMETHODIMP GetDirectory(char *szDir, UINT cch);
        STDMETHODIMP SetDirectory(char *szDir);
        STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
        STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);
    };

#endif // __MAPICONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\exchange\mapiconv.cpp ===
// =====================================================================================
// m a p c o n v . c p p
// conver a MAPI message to and from an RFC 822/RFC 1521 (mime) internet message
// =====================================================================================
#include "pch.hxx"
#include <newimp.h>
#include "Imnapi.h"
#include "Mapiconv.h"
#include <impapi.h>
#include <import.h>
#include "demand.h"

LPSTR  MapiStringDup (LPCTSTR lpcsz, LPVOID lpobj);

HRESULT HrImsgRecipToMapiRecip(LPMESSAGE lpMessage, LPIMSG lpImsg);
HRESULT HrImsgAttachToMapiAttach(LPMESSAGE lpMessage, LPIMSG lpImsg);

// =====================================================================================
// MAPI Message Properties that I want
// =====================================================================================
#define PR_BODY_HTML    PROP_TAG( PT_TSTRING,	0x1013)

enum 
{ 
    colSenderAddrType,
    colSenderName,
    colSenderEMail,
    colDelegateAddrType,
    colDelegateName,
    colDelegateEMail,
    colSubject, 
    colReceiveTime,
    colSendTime,
    colPriority,
    colFlags,
    colLast1
};

SizedSPropTagArray (colLast1, sptMessageProps) = 
{ 
	colLast1, 
	{
        PR_SENDER_ADDRTYPE,
        PR_SENDER_NAME,
        PR_SENDER_EMAIL_ADDRESS,
        PR_SENT_REPRESENTING_ADDRTYPE,
        PR_SENT_REPRESENTING_NAME,
        PR_SENT_REPRESENTING_EMAIL_ADDRESS,
        PR_SUBJECT,
        PR_MESSAGE_DELIVERY_TIME,
        PR_CLIENT_SUBMIT_TIME,
        PR_IMPORTANCE,
        PR_MESSAGE_FLAGS
    }
};

// =====================================================================================
// MAPI Recip Props
// =====================================================================================
enum 
{ 
    colRecipAddrType,
    colRecipName,
    colRecipAddress,
    colRecipType,
    colLast2
};

SizedSPropTagArray (colLast2, sptRecipProps) = 
{ 
	colLast2, 
	{
        PR_ADDRTYPE,
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_RECIPIENT_TYPE
    }
};

// =====================================================================================
// MAPI Attachment Props
// =====================================================================================
enum 
{ 
    colAttMethod,
    colAttNum,
    colAttLongFilename,
    colAttPathname,
    colAttTag,
    colAttFilename,
    colAttExtension,
    colAttSize,
    colLast3
};

SizedSPropTagArray (colLast3, sptAttProps) = 
{ 
	colLast3, 
	{
        PR_ATTACH_METHOD,
        PR_ATTACH_NUM,
        PR_ATTACH_LONG_FILENAME,
        PR_ATTACH_PATHNAME,
        PR_ATTACH_TAG,
        PR_ATTACH_FILENAME,
        PR_ATTACH_EXTENSION,
        PR_ATTACH_SIZE
    }
};

char *GetRecipAddress(LPSPropValue ppropAddr, LPSPropValue ppropType)
    {
    char *sz, *szT;

    sz = NULL;

    if (PROP_TYPE(ppropAddr->ulPropTag) != PT_ERROR &&
        PROP_TYPE(ppropType->ulPropTag) != PT_ERROR)
        {
        szT = ppropType->Value.lpszA;

        if (lstrcmp(szT, "SMTP") == 0 || lstrcmp(szT, "MSNINET") == 0)
            {
            sz = PszDup(ppropAddr->Value.lpszA);
            }
        else if (lstrcmp(szT, "MSN") == 0 || lstrcmp(szT, "MSNLIST") == 0)
            {
            szT = ppropAddr->Value.lpszA;
            DWORD cch = lstrlen(szT) + 16;
            if (MemAlloc((void **)&sz, cch*sizeof(sz[0])))
                {
                StrCpyN(sz, szT, cch);
                StrCatBuff(sz, "@msn.com", cch);
                }
            }
        }

    return(sz);
    }

// =====================================================================================
// HrMapiToImsg
// =====================================================================================
HRESULT HrMapiToImsg (LPMESSAGE lpMessage, LPIMSG lpImsg)
{
    // Locals
    LPSPropValue    ppropAddr, ppropType, ppropName;
    TCHAR           szUnk[128];
    int             cchUnk;
    TCHAR           *sz, *szT;
    HRESULT         hr;
    ULONG           cProp, i;
	LPSPropValue	lpMsgPropValue = NULL;
    LPSRowSet       lpRecipRows = NULL, lpAttRows = NULL;
    LPMAPITABLE     lptblRecip = NULL, lptblAtt = NULL;
    LPATTACH        lpAttach = NULL;
    LPMESSAGE       lpMsgAtt = NULL;
    LPSTREAM        lpstmBody = NULL;

    cchUnk = LoadString(g_hInstImp, idsAddressUnknownFmt, szUnk, ARRAYSIZE(szUnk));

    // Zero init
    ZeroMemory (lpImsg, sizeof (IMSG));

    // Get the propsw
    hr = lpMessage->GetProps ((LPSPropTagArray)&sptMessageProps, 0, &cProp, &lpMsgPropValue);
    if (FAILED (hr))
        goto exit;

    // Subject
    if (PROP_TYPE(lpMsgPropValue[colSubject].ulPropTag) != PT_ERROR)
        lpImsg->lpszSubject = PszDup(lpMsgPropValue[colSubject].Value.lpszA);

    // Body
    if (SUCCEEDED(lpMessage->OpenProperty(PR_BODY_HTML, (LPIID)&IID_IStream, 0, 0, (LPUNKNOWN *)&lpstmBody)))
        {
        if (SUCCEEDED(hr = CreateStreamOnHFile (NULL, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &lpImsg->lpstmHtml)))
            hr = HrCopyStream(lpstmBody, lpImsg->lpstmHtml, NULL);

        lpstmBody->Release();
        lpstmBody = NULL;

        if (FAILED(hr))
            goto exit;
        }
    else if (SUCCEEDED(lpMessage->OpenProperty(PR_BODY, (LPIID)&IID_IStream, 0, 0, (LPUNKNOWN *)&lpstmBody)))
        {
        if (SUCCEEDED(hr = CreateStreamOnHFile (NULL, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &lpImsg->lpstmBody)))
            hr = HrCopyStream(lpstmBody, lpImsg->lpstmBody, NULL);

        lpstmBody->Release();
        lpstmBody = NULL;
        
        if (FAILED(hr))
            goto exit;
        }

    // Send Time
    if (PROP_TYPE(lpMsgPropValue[colSendTime].ulPropTag) != PT_ERROR)
        CopyMemory(&lpImsg->ftSend, &lpMsgPropValue[colSendTime].Value.ft, sizeof (FILETIME));

    // Receive Time
    if (PROP_TYPE(lpMsgPropValue[colReceiveTime].ulPropTag) != PT_ERROR)
        CopyMemory(&lpImsg->ftReceive, &lpMsgPropValue[colReceiveTime].Value.ft, sizeof (FILETIME));

    // Priority
    lpImsg->wPriority = PRI_NORMAL;
    if (PROP_TYPE(lpMsgPropValue[colPriority].ulPropTag) != PT_ERROR)
    {
        switch (lpMsgPropValue[colPriority].Value.l)
        {
        case IMPORTANCE_LOW:
            lpImsg->wPriority = PRI_LOW;
            break;

        case IMPORTANCE_HIGH:
            lpImsg->wPriority = PRI_HIGH;
            break;

        case IMPORTANCE_NORMAL:
        default:
            lpImsg->wPriority = PRI_NORMAL;
            break;
       }
    }

    // message flags
    if (PROP_TYPE(lpMsgPropValue[colFlags].ulPropTag) != PT_ERROR)
        lpImsg->uFlags = lpMsgPropValue[colFlags].Value.ul;

    // Get the recipient table
    hr = lpMessage->GetRecipientTable (0, &lptblRecip);
    if (FAILED (hr))
        goto exit;

    // Get all the rows of the recipient table
    hr = lpHrQueryAllRows (lptblRecip, (LPSPropTagArray)&sptRecipProps, NULL, NULL, 0, &lpRecipRows);
    if (FAILED (hr))
        goto exit;

    // Allocate Recipient Array
    lpImsg->cAddress = lpRecipRows->cRows + 1;
    if (!MemAlloc((void **)&lpImsg->lpIaddr, sizeof (IADDRINFO) * lpImsg->cAddress))
        {
        hr = E_OUTOFMEMORY;
        goto exit;
        }
    ZeroMemory(lpImsg->lpIaddr, sizeof (IADDRINFO) * lpImsg->cAddress);

    ppropAddr = &lpMsgPropValue[colDelegateEMail];
    ppropType = &lpMsgPropValue[colDelegateAddrType];
    ppropName = &lpMsgPropValue[colDelegateName];

    if (PROP_TYPE(ppropAddr->ulPropTag) == PT_ERROR ||
        PROP_TYPE(ppropType->ulPropTag) == PT_ERROR)
    {
        ppropAddr = &lpMsgPropValue[colSenderEMail];
        ppropType = &lpMsgPropValue[colSenderAddrType];
        ppropName = &lpMsgPropValue[colSenderName];
    }

    // Originator of the message "From: "
    lpImsg->lpIaddr[0].dwType = IADDR_FROM;
    lpImsg->lpIaddr[0].lpszAddress = GetRecipAddress(ppropAddr, ppropType);

    if (PROP_TYPE(ppropName->ulPropTag) != PT_ERROR)
        {
        szT = ppropName->Value.lpszA;
        if (lpImsg->lpIaddr[0].lpszAddress != NULL)
            {
            sz = PszDup(szT);
            }
        else
            {
            lpImsg->lpIaddr[0].lpszAddress = PszDup(szT);
            DWORD cchSz = lstrlen(szT) + cchUnk;
            if (!MemAlloc((void **)&sz, cchSz*sizeof(sz[0])))
                {
                hr = E_OUTOFMEMORY;
                goto exit;
                }
            wnsprintf(sz, cchSz, szUnk, szT);
            }

        lpImsg->lpIaddr[0].lpszDisplay = sz;
        }
    
    // Add in the rest of the recipients
	for (i=0; i<lpRecipRows->cRows; i++)
	    {	
        Assert (i+1 < lpImsg->cAddress);

        if (PROP_TYPE(lpRecipRows->aRow[i].lpProps[colRecipType].ulPropTag) != PT_ERROR)
            {
            switch (lpRecipRows->aRow[i].lpProps[colRecipType].Value.ul)
                {
                case MAPI_TO:
                case 0x10000000: /* MAPI_P1: */
                    lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
                    break;

                case MAPI_ORIG:
                    lpImsg->lpIaddr[i+1].dwType = IADDR_FROM;
                    break;

                case MAPI_CC:
                    lpImsg->lpIaddr[i+1].dwType = IADDR_CC;
                    break;

                case MAPI_BCC:
                    lpImsg->lpIaddr[i+1].dwType = IADDR_BCC;
                    break;

                default:
                    Assert (FALSE);
                    lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
                    break;
                }
            }
        else
            {
            lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
            }
        
        lpImsg->lpIaddr[i+1].lpszAddress = GetRecipAddress(&lpRecipRows->aRow[i].lpProps[colRecipAddress], &lpRecipRows->aRow[i].lpProps[colRecipAddrType]);

        if (PROP_TYPE(lpRecipRows->aRow[i].lpProps[colRecipName].ulPropTag) != PT_ERROR)
            {
            szT = lpRecipRows->aRow[i].lpProps[colRecipName].Value.lpszA;
            if (lpImsg->lpIaddr[i + 1].lpszAddress != NULL)
                {
                sz = PszDup(szT);
                }
            else
                {
                lpImsg->lpIaddr[i+1].lpszAddress = PszDup(szT);
                DWORD cchSz = lstrlen(szT) + cchUnk;
                if (!MemAlloc((void **)&sz, cchSz*sizeof(sz[0])))
                    {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                    }
                wnsprintf(sz, cchSz, szUnk, szT);
                }

            lpImsg->lpIaddr[i + 1].lpszDisplay = sz;
            }
	    }

    // Free Rows
    if (lpRecipRows)
        lpFreeProws (lpRecipRows);
    lpRecipRows = NULL;

    // Attachments
    hr = lpMessage->GetAttachmentTable (0, &lptblAtt);
    if (FAILED (hr))
        goto exit;

    // Get all the rows of the recipient table
    hr = lpHrQueryAllRows (lptblAtt, (LPSPropTagArray)&sptAttProps, NULL, NULL, 0, &lpAttRows);
    if (FAILED (hr))
        goto exit;

    // Allocate files list
    if (lpAttRows->cRows == 0)
        goto exit;

    // Allocate memory
    lpImsg->cAttach = lpAttRows->cRows;
    if (!MemAlloc((void **)&lpImsg->lpIatt, sizeof (IATTINFO) * lpImsg->cAttach))
        {
        hr = E_OUTOFMEMORY;
        goto exit;
        }

    // Zero init
    ZeroMemory (lpImsg->lpIatt, sizeof (IATTINFO) * lpImsg->cAttach);

    // Walk the rows
	for (i=0; i<lpAttRows->cRows; i++)
	{	
        if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttMethod].ulPropTag) != PT_ERROR &&
            PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttNum].ulPropTag) != PT_ERROR)
        {
            // Basic Properties
            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttPathname].ulPropTag) != PT_ERROR)
                {
                sz = lpAttRows->aRow[i].lpProps[colAttPathname].Value.lpszA;
                if (!FIsEmpty(sz))
                    lpImsg->lpIatt[i].lpszPathName = PszDup(sz);
                }

            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttFilename].ulPropTag) != PT_ERROR)
                {
                sz = lpAttRows->aRow[i].lpProps[colAttFilename].Value.lpszA;
                if (!FIsEmpty(sz))
                    lpImsg->lpIatt[i].lpszFileName = PszDup(sz);
                }

            if (lpImsg->lpIatt[i].lpszFileName == NULL &&
                PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttLongFilename].ulPropTag) != PT_ERROR)
                {
                sz = lpAttRows->aRow[i].lpProps[colAttLongFilename].Value.lpszA;
                if (!FIsEmpty(sz))
                    lpImsg->lpIatt[i].lpszFileName = PszDup(sz);
                }

            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttExtension].ulPropTag) != PT_ERROR)
                {
                sz = lpAttRows->aRow[i].lpProps[colAttExtension].Value.lpszA;
                if (!FIsEmpty(sz))
                    lpImsg->lpIatt[i].lpszExt = PszDup(sz);
                }

            // Open the attachment
            hr = lpMessage->OpenAttach (lpAttRows->aRow[i].lpProps[colAttNum].Value.l, NULL, MAPI_BEST_ACCESS, &lpAttach);
            if (FAILED (hr))
            {
                lpImsg->lpIatt[i].fError = TRUE;
                continue;
            }

            // Handle the attachment method
            switch (lpAttRows->aRow[i].lpProps[colAttMethod].Value.ul)
            {
            case NO_ATTACHMENT:
                lpImsg->lpIatt[i].dwType = 0;
                lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_BY_REF_RESOLVE:
            case ATTACH_BY_VALUE:
                lpImsg->lpIatt[i].dwType = IATT_FILE;
                hr = lpAttach->OpenProperty (PR_ATTACH_DATA_BIN, (LPIID)&IID_IStream, 0, 0, (LPUNKNOWN *)&lpImsg->lpIatt[i].lpstmAtt);
                if (FAILED (hr))
                    lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_BY_REF_ONLY:
            case ATTACH_BY_REFERENCE:
                lpImsg->lpIatt[i].dwType = IATT_FILE;
                hr = CreateStreamOnHFile (lpImsg->lpIatt[i].lpszPathName, GENERIC_READ,  FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, &lpImsg->lpIatt[i].lpstmAtt);
                if (FAILED (hr))
                    lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_EMBEDDED_MSG:
                lpImsg->lpIatt[i].dwType = IATT_MSG;
                hr = lpAttach->OpenProperty (PR_ATTACH_DATA_OBJ, (LPIID)&IID_IMessage, 0, 0, (LPUNKNOWN *)&lpMsgAtt);
                if (FAILED (hr) || lpMsgAtt == NULL)
                    lpImsg->lpIatt[i].fError = TRUE;
                else
                {
                    if (!MemAlloc((void **)&lpImsg->lpIatt[i].lpImsg, sizeof (IMSG)))
                        lpImsg->lpIatt[i].fError = TRUE;
                    else
                    {
                        hr = HrMapiToImsg (lpMsgAtt, lpImsg->lpIatt[i].lpImsg);
                        if (FAILED (hr))
                            lpImsg->lpIatt[i].fError = TRUE;
                    }    
                    lpMsgAtt->Release ();
                    lpMsgAtt = NULL;
                }
                break;

            case ATTACH_OLE:
            default:
                lpImsg->lpIatt[i].dwType = IATT_OLE;
                lpImsg->lpIatt[i].fError = TRUE;
                break;
            }

            // Free Attachment
            if (lpAttach)
                lpAttach->Release ();
            lpAttach = NULL;
        }
    }

    hr = S_OK;

exit:
    // Cleanup
    if (lpAttach)
        lpAttach->Release ();
    if (lptblAtt)
        lptblAtt->Release ();
    if (lpAttRows)
        lpFreeProws (lpAttRows);
    if (lpRecipRows)
        lpFreeProws (lpRecipRows);
    if (lpMsgPropValue)
        lpMAPIFreeBuffer (lpMsgPropValue);
    if (lptblRecip)
        lptblRecip->Release ();
    if (lpMsgAtt)
        lpMsgAtt->Release ();
    if (lpstmBody)
        lpstmBody->Release ();

    // Done
    return hr;
}

// =====================================================================================
//
// HrImsgToMapi: lpImsg => lpMessage
//
// assumes lpMessage is initialized.
// 
// =====================================================================================
HRESULT HrImsgToMapi(LPIMSG lpImsg, LPMESSAGE lpMessage)
{
    // Locals
    LPSTREAM        lpstmBody;
    HRESULT         hr = S_OK;
    ULONG           i, cProp;
	LPSPropValue	lpMsgPropValue = NULL;
    ULONG           cPropMax = 13;

    /*
        properties to copy:

        PR_SENDER_ADDRTYPE,
        PR_SENDER_NAME,
        PR_SENDER_EMAIL_ADDRESS,
        PR_SUBJECT,
        PR_MESSAGE_DELIVERY_TIME,
        PR_IMPORTANCE,
        PR_MESSAGE_FLAGS
        PR_MESSAGE_CLASS
        PR_SENT_REPRESENTING_NAME,
        PR_SENT_REPRESENTING_EMAIL_ADDRESS,
        PR_SENT_REPRESENTING_ADDRTYPE,
    */

    Assert(lpMessage != NULL);

    // create the propvalue array
    hr = lpMAPIAllocateBuffer(cPropMax*sizeof(SPropValue), (LPVOID FAR*)&lpMsgPropValue);
    if (FAILED(hr))
        goto exit;

    ZeroMemory(lpMsgPropValue, cPropMax*sizeof(SPropValue));
    cProp = 0;
    
    lpMsgPropValue[cProp].Value.lpszA = MapiStringDup("IPM.Note", lpMsgPropValue);
    lpMsgPropValue[cProp].ulPropTag = PR_MESSAGE_CLASS;
    cProp++;

    // Subject
    if (lpImsg->lpszSubject)
        {
        lpMsgPropValue[cProp].Value.lpszA = MapiStringDup(lpImsg->lpszSubject, lpMsgPropValue);
        lpMsgPropValue[cProp].ulPropTag = PR_SUBJECT;
        cProp++;
        Assert(cProp <= cPropMax);
        }

    // Send Time
    CopyMemory(&lpMsgPropValue[cProp].Value.ft, &lpImsg->ftSend, sizeof (FILETIME));
    lpMsgPropValue[cProp].ulPropTag = PR_CLIENT_SUBMIT_TIME;
    cProp++;
    Assert(cProp <= cPropMax);

    // Receive Time
    CopyMemory(&lpMsgPropValue[cProp].Value.ft, &lpImsg->ftReceive, sizeof (FILETIME));
    lpMsgPropValue[cProp].ulPropTag = PR_MESSAGE_DELIVERY_TIME;
    cProp++;
    Assert(cProp <= cPropMax);

    // Priority
    lpMsgPropValue[cProp].ulPropTag = PR_IMPORTANCE;
    switch (lpImsg->wPriority)
    {
    case PRI_HIGH:
        lpMsgPropValue[cProp].Value.l = IMPORTANCE_HIGH;
        break;

    case PRI_LOW:
        lpMsgPropValue[cProp].Value.l = IMPORTANCE_LOW;
        break;

    case PRI_NORMAL:
    default:
        lpMsgPropValue[cProp].Value.l = IMPORTANCE_NORMAL;
        break;
    }
    cProp++;
    Assert(cProp <= cPropMax);

    // Message flags
    lpMsgPropValue[cProp].ulPropTag = PR_MESSAGE_FLAGS;
    lpMsgPropValue[cProp].Value.ul  = lpImsg->uFlags;
    cProp++;
    Assert(cProp <= cPropMax);

    // recipients
    if (FAILED(hr = HrImsgRecipToMapiRecip(lpMessage, lpImsg)))
        goto exit;

    // sender information
    for (i = 0; i < lpImsg->cAddress; i++)
        {
        Assert(lpImsg->lpIaddr != NULL);

        if (lpImsg->lpIaddr[i].dwType == IADDR_FROM)
            {
            Assert(lpImsg->lpIaddr[i].lpszAddress);
            Assert(lpImsg->lpIaddr[i].lpszDisplay);

            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup(lpImsg->lpIaddr[i].lpszDisplay, lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENDER_NAME;
            cProp++;
            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup(lpImsg->lpIaddr[i].lpszDisplay, lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENT_REPRESENTING_NAME;
            cProp++;
            Assert(cProp <= cPropMax);

            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup(lpImsg->lpIaddr[i].lpszAddress, lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENDER_EMAIL_ADDRESS;
            cProp++;
            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup(lpImsg->lpIaddr[i].lpszAddress, lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENT_REPRESENTING_EMAIL_ADDRESS;
            cProp++;
            Assert(cProp <= cPropMax);

            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup("SMTP", lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENDER_ADDRTYPE;
            cProp++;
            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup("SMTP", lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENT_REPRESENTING_ADDRTYPE;
            cProp++;
            Assert(cProp <= cPropMax);

            break;
            }
        }

    // attachment information
    if (FAILED(hr = HrImsgAttachToMapiAttach(lpMessage, lpImsg)))
        goto exit;

    // save changes
    if (FAILED(hr = lpMessage->SetProps(cProp, lpMsgPropValue, NULL)))
        goto exit;

    // Body
    if (lpImsg->lpstmHtml &&
        SUCCEEDED(lpMessage->OpenProperty(PR_BODY_HTML, (LPIID)&IID_IStream, 0, MAPI_CREATE | MAPI_MODIFY, (LPUNKNOWN *)&lpstmBody)))
        {
        hr = HrCopyStream(lpImsg->lpstmHtml, lpstmBody, NULL);

        lpstmBody->Release();

        if (FAILED(hr))
            goto exit;
        }

    if (lpImsg->lpstmBody &&
        SUCCEEDED(lpMessage->OpenProperty(PR_BODY, (LPIID)&IID_IStream, 0, MAPI_CREATE | MAPI_MODIFY, (LPUNKNOWN *)&lpstmBody)))
        {
        hr = HrCopyStream(lpImsg->lpstmBody, lpstmBody, NULL);

        lpstmBody->Release();
        
        if (FAILED(hr))
            goto exit;
        }

    if (FAILED(hr = lpMessage->SaveChanges(0)))
        goto exit;

exit:
    if (lpMsgPropValue)
        lpMAPIFreeBuffer (lpMsgPropValue);

    return hr;
}

HRESULT HrImsgAttachToMapiAttach(LPMESSAGE lpMessage, LPIMSG lpImsg)
{
    ULONG           i, iAttach;
    HRESULT         hr = S_OK;

    if (!lpMessage || !lpImsg)
        return E_FAIL;

    if (lpImsg->cAttach == 0)
        return S_OK;

    if (!lpImsg->lpIatt)
        return E_FAIL;

    /*
    attachment properties and indices:

    colAttMethod,
    colAttNum,
    colAttLongFilename,
    colAttPathname,
    colAttTag,
    colAttFilename,
    colAttExtension,
    colAttSize,
    colLast3

    PR_ATTACH_METHOD,
    PR_ATTACH_NUM,
    PR_ATTACH_LONG_FILENAME,
    PR_ATTACH_PATHNAME,
    PR_ATTACH_TAG,
    PR_ATTACH_FILENAME,
    PR_ATTACH_EXTENSION,
    PR_ATTACH_SIZE
    */

    for (i=0; i<lpImsg->cAttach; i++)
        {
        LPSPropValue    rgPropVals = 0;
        ULONG           cb = 0, cProp = 0;
        HRESULT         hropen;
        LPMESSAGE       lpmsg = NULL;
        LPSTREAM        lpstm = 0;
        LPIATTINFO      lpiatt = (LPIATTINFO)&(lpImsg->lpIatt[i]);
        LPATTACH        lpAttach = 0;
        Assert(lpiatt);

        if (lpiatt->fError)
            continue;

        if (FAILED(lpMessage->CreateAttach(NULL, NULL, &iAttach, &lpAttach)))
            goto cleanup;

        if (FAILED(lpMAPIAllocateBuffer(sizeof(SPropValue)*colLast3, (LPVOID*)&rgPropVals)))
            goto cleanup;

        ZeroMemory(rgPropVals, sizeof(SPropValue)*colLast3);

        if (lpiatt->lpszPathName)
            {
            rgPropVals[cProp].ulPropTag   = PR_ATTACH_PATHNAME;
            rgPropVals[cProp].Value.lpszA = MapiStringDup(lpiatt->lpszPathName, rgPropVals);
            cProp++;
            }

        if (lpiatt->lpszFileName)
            {
            rgPropVals[cProp].ulPropTag   = PR_ATTACH_FILENAME;
            rgPropVals[cProp].Value.lpszA = MapiStringDup(lpiatt->lpszFileName, rgPropVals);
            cProp++;
            }

        if (lpiatt->lpszExt)
            {
            rgPropVals[cProp].ulPropTag    = PR_ATTACH_EXTENSION;
            rgPropVals[cProp].Value.lpszA  = MapiStringDup(lpiatt->lpszExt, rgPropVals);
            cProp++;
            }

        switch(lpiatt->dwType)
            {
            case IATT_FILE:
                rgPropVals[cProp].ulPropTag = PR_OBJECT_TYPE;
                rgPropVals[cProp].Value.ul = MAPI_ATTACH;
                cProp++;

                rgPropVals[cProp].ulPropTag = PR_ATTACH_METHOD;
                rgPropVals[cProp].Value.ul = ATTACH_BY_VALUE;
                cProp++;

                hropen = lpAttach->OpenProperty(PR_ATTACH_DATA_BIN, (LPIID)&IID_IStream,
                                                STGM_WRITE, MAPI_MODIFY | MAPI_CREATE,
                                                (LPUNKNOWN *)&lpstm); 
                if (!FAILED(hropen))
                    {
                    Assert(lpstm != NULL);

                    if (!FAILED(HrCopyStream(lpiatt->lpstmAtt, lpstm, &cb)))
                        lpstm->Commit(0);

                    lpstm->Release();
                    lpstm=0;
                    }
                break;

            case IATT_MSG:
                rgPropVals[cProp].ulPropTag = PR_OBJECT_TYPE;
                rgPropVals[cProp].Value.ul = MAPI_MESSAGE;
                cProp++;

                rgPropVals[cProp].ulPropTag = PR_ATTACH_METHOD;
                rgPropVals[cProp].Value.ul = ATTACH_EMBEDDED_MSG;
                cProp++;

                hropen = lpAttach->OpenProperty(PR_ATTACH_DATA_OBJ, (LPIID)&IID_IMessage,
                                                0, MAPI_MODIFY | MAPI_CREATE,
                                                (LPUNKNOWN *)&lpmsg); 
                if (!FAILED(hropen))
                    {
                    Assert(lpmsg != NULL);

                    HrImsgToMapi(lpiatt->lpImsg, lpmsg);

                    lpmsg->Release();
                    lpmsg = NULL;
                    }
                break;

            default:
                AssertSz(FALSE, "Unexpected attachment type!");
                break;
            }

        // need to set the property
        hr = lpAttach->SetProps(cProp, rgPropVals, NULL);
        if (FAILED(hr))
            goto cleanup;
        hr = lpAttach->SaveChanges(0);
        if (FAILED(hr))
            goto cleanup;

cleanup:
        if (rgPropVals)
            {
            lpMAPIFreeBuffer(rgPropVals);
            rgPropVals = 0;
            }

        if (lpAttach)
            {
            lpAttach->Release();
            lpAttach = 0;
            }
        }

    return hr;
}

// =====================================================================================
// 
// HrImsgRecipToMapiRecip:
// 
// =====================================================================================
HRESULT HrImsgRecipToMapiRecip(LPMESSAGE lpMessage, LPIMSG lpImsg)
{
    LPADRENTRY      lpadrentry;
    ULONG           cb, i;
    LPADRLIST       lpadrlist = 0;
    LPSPropValue    rgPropVals = 0;
    HRESULT         hr = E_FAIL;
               
    if (lpImsg == NULL)
        return(E_FAIL);

    if (lpImsg->cAddress == 0)
        return(S_OK);

    if (lpMessage == NULL || lpImsg->lpIaddr == NULL)
        return(E_FAIL);

    cb = sizeof(ADRLIST) + lpImsg->cAddress * sizeof(ADRENTRY);
    if (FAILED(lpMAPIAllocateBuffer(cb, (LPVOID*)&lpadrlist)))
        return(E_OUTOFMEMORY);

    ZeroMemory(lpadrlist, cb);

    // enumerate through the recipient list
    for (i = 0; i < lpImsg->cAddress; i++)
        {
        if (lpImsg->lpIaddr[i].dwType == IADDR_FROM)
            continue;

        lpadrentry = (LPADRENTRY)&(lpadrlist->aEntries[lpadrlist->cEntries]);

        // this memory is freed by lpMessage
        if (FAILED(lpMAPIAllocateBuffer(sizeof(SPropValue) * colLast2, (LPVOID *)&rgPropVals)))
            {
            hr = E_OUTOFMEMORY;
            goto exit;
            }

        lpadrentry->cValues    = 0;
        lpadrentry->rgPropVals = rgPropVals;
        lpadrlist->cEntries++;

        rgPropVals[colRecipAddrType].ulPropTag   = PR_ADDRTYPE;
        rgPropVals[colRecipAddrType].Value.lpszA = MapiStringDup("SMTP", rgPropVals);
        lpadrentry->cValues++;
        Assert(lpadrentry->cValues <= colLast2);

        rgPropVals[colRecipName].ulPropTag       = PR_DISPLAY_NAME;
        rgPropVals[colRecipName].Value.lpszA     = MapiStringDup(lpImsg->lpIaddr[i].lpszDisplay, rgPropVals);
        lpadrentry->cValues++;
        Assert(lpadrentry->cValues <= colLast2);

        rgPropVals[colRecipAddress].ulPropTag    = PR_EMAIL_ADDRESS;
        rgPropVals[colRecipAddress].Value.lpszA  = MapiStringDup(lpImsg->lpIaddr[i].lpszAddress, rgPropVals);
        lpadrentry->cValues++;
        Assert(lpadrentry->cValues <= colLast2);

        rgPropVals[colRecipType].ulPropTag       = PR_RECIPIENT_TYPE;
        switch(lpImsg->lpIaddr[i].dwType)
            {
            case IADDR_FROM:
                rgPropVals[colRecipType].Value.ul = MAPI_ORIG;
                break;

            case IADDR_CC:
                rgPropVals[colRecipType].Value.ul = MAPI_CC;
                break;

            case IADDR_BCC:
                rgPropVals[colRecipType].Value.ul = MAPI_BCC;
                break;

            case IADDR_TO:
            default:
                rgPropVals[colRecipType].Value.ul = MAPI_TO;       
                break;
            }
        lpadrentry->cValues++;
        Assert(lpadrentry->cValues <= colLast2);

        // reset the variable so we don't free up on exit
        rgPropVals = 0;
        }

    hr = lpMessage->ModifyRecipients(MODRECIP_ADD, lpadrlist);
        
exit:
    // Free the buffers
    for (i = 0; i < lpadrlist->cEntries; i++)
        lpMAPIFreeBuffer(lpadrlist->aEntries[i].rgPropVals);
    lpMAPIFreeBuffer(lpadrlist);

    return(hr);
    }

LPSTR  MapiStringDup (LPCTSTR lpcsz, LPVOID lpobj)
{
    LPSTR       lpszDup = NULL;

    if (lpcsz == NULL)
        return NULL;

    INT nLen = lstrlen (lpcsz) + 1;

    if (lpobj)
        {
        if (FAILED(lpMAPIAllocateMore(nLen*sizeof(TCHAR), lpobj, (LPVOID FAR*)&lpszDup)))
            return NULL;
        }
    else
        {
        if (FAILED(lpMAPIAllocateBuffer(nLen*sizeof(TCHAR), (LPVOID FAR*)&lpszDup)))
            return NULL;
        }

    CopyMemory (lpszDup, lpcsz, nLen*sizeof(TCHAR));

    return lpszDup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\netscape\commimp.h ===
#ifndef _INC_COMMSIMP_H
#define _INC_COMMSIMP_H

// {1198A2C0-0940-11d1-838F-00C04FBD7C09}
DEFINE_GUID(CLSID_CCommunicatorImport, 0x1198a2c0, 0x940, 0x11d1, 0x83, 0x8f, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

#define SNM_FILE    1
#define SNM_DRAFT   2

#define hrExceptionalCase                 -1
#define hrOSInfoNotFound				 500
#define hrWin32platform					 501

class CCommunicatorEnumFOLDERS : public IEnumFOLDERS
    {
    private:
        ULONG		m_cRef;
        EUDORANODE*	m_plist;
        EUDORANODE*	m_pnext;

    public:
        CCommunicatorEnumFOLDERS(EUDORANODE *plist);
        ~CCommunicatorEnumFOLDERS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP Next(IMPORTFOLDER *pfldr);
        STDMETHODIMP Reset(void);
    };

class CCommunicatorImport : public IMailImport
    {
    private:
        ULONG           m_cRef;
        EUDORANODE   *m_plist;
        char        m_szUser[MAX_PATH];
        BOOL            m_bDraft;

    public:
        CCommunicatorImport(void);
        ~CCommunicatorImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP InitializeImport(HWND hwnd);
        STDMETHODIMP GetDirectory(char *szDir, UINT cch);
        STDMETHODIMP SetDirectory(char *szDir);
        STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
        STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);

		// class member functions

		HRESULT ProcessBlocks(BYTE* pSnm, ULONG cbSnm,
							  BYTE* pMsg, ULONG cbMsg,
							  int nLayer, ULONG Offset,
							  IFolderImport *pImport);

		HRESULT ProcessMessages(BYTE* pSnm, ULONG cbSnm,
								BYTE* pMsg, ULONG cbMsg,
								ULONG NewOffset,
								IFolderImport* pImport);
		
		ULONG GetPrimaryOffset(BYTE* pSnm, ULONG cbSnm);

		ULONG GetOffset(BYTE* pSnm, ULONG cbSnm, ULONG Offset, int nElement);
    };

#endif // _INC_COMMSIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\pch\empty.cxx ===
#include <pch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\netscape\netsimp.h ===
#ifndef _INC_NETSIMP_H
#define _INC_NETSIMP_H

// {0A522733-A626-11D0-8D60-00C04FD6202B}
DEFINE_GUID(CLSID_CNetscapeImport, 0x0A522733L, 0xA626, 0x11D0, 0x8D, 0x60, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

#define hrExceptionalCase                 -1
#define hrOSInfoNotFound				 500
#define hrWin32platform					 501

class CNetscapeEnumFOLDERS : public IEnumFOLDERS
    {
    private:
        ULONG           m_cRef;
        EUDORANODE   *m_plist;
        EUDORANODE   *m_pnext;

    public:
        CNetscapeEnumFOLDERS(EUDORANODE *plist);
        ~CNetscapeEnumFOLDERS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP Next(IMPORTFOLDER *pfldr);
        STDMETHODIMP Reset(void);
    };

class CNetscapeImport : public IMailImport
    {
    private:
        ULONG           m_cRef;
        EUDORANODE   *m_plist;

    public:
        CNetscapeImport(void);
        ~CNetscapeImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP InitializeImport(HWND hwnd);
        STDMETHODIMP GetDirectory(char *szDir, UINT cch);
        STDMETHODIMP SetDirectory(char *szDir);
        STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
        STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);
    };

#endif // _INC_NETSIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\netscape\commimp.cpp ===
#include "pch.hxx"
#include "impapi.h"
#include "comconv.h"
#include <newimp.h>
#include <eudrimp.h>
#include "commimp.h"
#include <mapi.h>
#include <mapix.h>
#include <import.h>
#include <dllmain.h>

ASSERTDATA

HRESULT FindSnm(EUDORANODE *pParent, EUDORANODE **pplist, TCHAR *npath);
INT_PTR CALLBACK SelectCommUserDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT GetCommunicatorDirectory(char *szUser, char *szDir, int cch);

const static char c_szSnmExt[] = "\\*.snm";
const static char c_szSnmHeader[] = "# Netscape folder cache"; //used for avoiding processing Netscape 3.0 SNM files
const static char c_szDrafts[] = "Drafts";
const static char c_szUnsent[] = "Unsent Messages";
const static char c_szSent[] = "Sent";

CCommunicatorImport::CCommunicatorImport()
    {
    DllAddRef();

    m_cRef = 1;
    m_plist = NULL;
    *m_szUser = 0;
    }

CCommunicatorImport::~CCommunicatorImport()
    {
    if (m_plist != NULL)
        EudoraFreeFolderList(m_plist);

    DllRelease();
    }

ULONG CCommunicatorImport::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CCommunicatorImport::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CCommunicatorImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IMailImport == riid)
		*ppv = (IMailImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

typedef struct tagSELCOMMINFO
    {
    char szUser[MAX_PATH];
    HKEY hkey;
    } SELCOMMINFO;

const static char c_szRegNscp[] = "Software\\Netscape\\Netscape Navigator\\Users";

HRESULT CCommunicatorImport::InitializeImport(HWND hwnd)
    {
    DWORD cUsers;
    int iRet;
    HKEY hkey;
    HRESULT hr;
    SELCOMMINFO si;

    hr = S_OK;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegNscp, 0, KEY_ALL_ACCESS, &hkey))
        {
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey, NULL, NULL, 0, &cUsers, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
            {
            if (cUsers > 1)
                {
                si.hkey = hkey;

                iRet = (int) DialogBoxParam(g_hInstImp, MAKEINTRESOURCE(iddSelectCommUser), hwnd, SelectCommUserDlgProc, (LPARAM)&si);
                if (iRet == IDCANCEL)
                    hr = S_FALSE;
                else if (iRet == IDOK)
                    StrCpyN(m_szUser, si.szUser, ARRAYSIZE(m_szUser));
                else
                    hr = E_FAIL;
                }
            }

        RegCloseKey(hkey);
        }

	return(hr);
    }

INT_PTR CALLBACK SelectCommUserDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
    HWND hwndT;
    WORD id;
    DWORD iSubKey, cb;
    char sz[MAX_PATH];
    SELCOMMINFO *psi;
    int index;

    switch (msg)
        {
        case WM_INITDIALOG:
            Assert(lParam != NULL);
            psi = (SELCOMMINFO *)lParam;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)psi);

            hwndT = GetDlgItem(hwnd, IDC_USERLIST);

            // fill list
            iSubKey = 0;
            cb = sizeof(sz);
            while (ERROR_SUCCESS == RegEnumKeyEx(psi->hkey, iSubKey, sz, &cb, NULL, NULL, NULL, NULL))
                {
                SendMessage(hwndT, LB_ADDSTRING, 0, (LPARAM)sz);
                iSubKey++;
                cb = sizeof(sz);
                }

            SendMessage(hwndT, LB_SETCURSEL, 0, 0);
            return(TRUE);

        case WM_COMMAND:
            id = LOWORD(wParam);
            switch (id)
                {
                case IDOK:
                    psi = (SELCOMMINFO *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                    Assert(psi != NULL);

                    hwndT = GetDlgItem(hwnd, IDC_USERLIST);
                    index = (int) SendMessage(hwndT, LB_GETCURSEL, 0, 0);
                    Assert(index >= 0);
                    if (SendMessage(hwndT, LB_GETTEXTLEN, (WPARAM)index, 0) < ARRAYSIZE(psi->szUser))
                        SendMessage(hwndT, LB_GETTEXT, (WPARAM)index, (LPARAM)psi->szUser);

                    // fall through

                case IDCANCEL:
                    EndDialog(hwnd, id);
                    return(TRUE);
                }
            break;
        }

    return(FALSE);
    }

const static char c_szCommunicatorKey[] = "SOFTWARE\\Netscape\\Netscape Navigator\\Users";
const static char c_szCurrentUser[] = "CurrentUser";
const static char c_szDirRoot[] = "DirRoot";
const static char c_szMailDir[] = "\\Mail";

HRESULT GetCommunicatorDirectory(char *szUser, char *szDir, int cch)
    {
    char sz[MAX_PATH], szTemp[MAX_PATH], szExpanded[MAX_PATH], *psz;
    HKEY hkResult, hkResult1;
    LONG lRes;
    DWORD cb, dwType;
    HRESULT hr;

    hr = E_FAIL;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szCommunicatorKey, 0, KEY_QUERY_VALUE, &hkResult))
        {
        if (szUser == NULL)
            {
            cb = sizeof(sz);
            lRes = RegQueryValueEx(hkResult, c_szCurrentUser, NULL, NULL, (LPBYTE)sz, &cb);
            szUser = sz;
            }
        else
            {
            Assert(*szUser != 0);
            lRes = ERROR_SUCCESS;
            }

        if (lRes == ERROR_SUCCESS)
            {
            cb = sizeof(szTemp);
            if (ERROR_SUCCESS == RegOpenKeyEx(hkResult, szUser, 0, KEY_QUERY_VALUE, &hkResult1))
                {
                if (ERROR_SUCCESS == RegQueryValueEx(hkResult1, c_szDirRoot, NULL, &dwType, (LPBYTE)szTemp, &cb))
                    {
                    if (REG_EXPAND_SZ == dwType)
                    {
                        ZeroMemory(szExpanded, ARRAYSIZE(szExpanded));
                        ExpandEnvironmentStrings(szTemp, szExpanded, ARRAYSIZE(szExpanded));
                        psz = szExpanded;
                    }
                    else
                        psz = szTemp;
                    
                    if (!GetStorePath(psz, szDir, cch))
                        {
                        StrCpyN(szDir, psz, cch);
                        StrCatBuff(szDir, c_szMailDir, cch);
                        }

                    hr = S_OK;
                    }

                RegCloseKey(hkResult1);
                }
            }

        RegCloseKey(hkResult);
        }

    return(hr);
    }

HRESULT CCommunicatorImport::GetDirectory(char *szDir, UINT cch)
    {
	HRESULT hr;

    Assert(szDir != NULL);

    hr = GetCommunicatorDirectory(*m_szUser != 0 ? m_szUser : NULL, szDir, cch);
    if (FAILED(hr))
        *szDir = 0;

	return(S_OK);
    }

HRESULT CCommunicatorImport::SetDirectory(char *szDir)
    {
    HRESULT hr;

    Assert(szDir != NULL);

    if (!ValidStoreDirectory(szDir, NETSCAPE))
        return(S_FALSE);

    if (m_plist != NULL)
        {
        EudoraFreeFolderList(m_plist);
        m_plist = NULL;
        }

    hr = FindSnm(NULL, &m_plist, szDir);

	return(hr);
    }

HRESULT CCommunicatorImport::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
    {
    CCommunicatorEnumFOLDERS *pEnum;
    EUDORANODE *pnode;

    Assert(ppEnum != NULL);
    *ppEnum = NULL;

    if (dwCookie == COOKIE_ROOT)
        pnode = m_plist;
    else
        pnode = ((EUDORANODE *)dwCookie)->pchild;

    if (pnode == NULL)
        return(S_FALSE);

    pEnum = new CCommunicatorEnumFOLDERS(pnode);
    if (pEnum == NULL)
        return(E_OUTOFMEMORY);

    *ppEnum = pEnum;

    return(S_OK);
    }

STDMETHODIMP CCommunicatorImport::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
    {
    char szHdr[64];
    EUDORANODE *pnode;
    HRESULT hr = E_FAIL;
	TCHAR cMsgFile[MAX_PATH];
    BYTE *pSnm, *pMsg, *pEnd, *pEndMsg, *pT, *pNextMsg, *pLast;
	ULONG i, lMsgs, lTotalMsgs, lNumNulls, cbMsg, cbSnm, cExtra, uOffset, uMsgSize, cMsgImp;
	ULONG	lRoof		=	32;
	ULONG	Offset		=	0;
	int nNumLevels		=	1;
    HANDLE mapSnm, mapMsg, hSnm, hMsg;

    Assert(pImport != NULL);

    pnode = (EUDORANODE *)dwCookie;
    Assert(pnode != NULL);

	if (pnode->iFileType == SNM_DRAFT)
        m_bDraft = TRUE;
    else
        m_bDraft = FALSE;

	Assert((pnode->iFileType == SNM_FILE ) || (pnode->iFileType == SNM_DRAFT));

    hr = E_FAIL;
    pSnm = NULL;
    mapSnm = NULL;
    pMsg = NULL;
    mapMsg = NULL;

	StrCpyN(cMsgFile, pnode->szFile, ARRAYSIZE(cMsgFile));
	cMsgFile[(lstrlen(cMsgFile)) - 4] = 0;

	hMsg = CreateFile(cMsgFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hMsg == INVALID_HANDLE_VALUE)
		return(hrFolderOpenFail);

    cbMsg = GetFileSize(hMsg, NULL);
    if (cbMsg == 0)
        {
        CloseHandle(hMsg);
        return(S_OK);
        }

	hSnm = CreateFile(pnode->szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hSnm == INVALID_HANDLE_VALUE)
        {
        CloseHandle(hMsg);
        return(hrFolderOpenFail);
        }

    cbSnm = GetFileSize(hSnm, NULL);
    if (cbSnm < 2560)
        {
        // the .snm file header is 2560 bytes in size, so anything less
        // than this is bogus or doesn't have messages anyway, so no point
        // in continuing
        goto DoneImport;
        }

    mapSnm = CreateFileMapping(hSnm, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapSnm == NULL)
        goto DoneImport;

    pSnm = (BYTE *)MapViewOfFile(mapSnm, FILE_MAP_READ, 0, 0, 0);
    if (pSnm == NULL)
        goto DoneImport;

    pEnd = pSnm + cbSnm;

//	Do something else to verify the genuineness of the SNM file (like 
//	comparing the two separately stored values of "total # of messages").

//  1) Confirm that this is not a NS 3.0 SNM file.

    CopyMemory(szHdr, pSnm, ARRAYSIZE(c_szSnmHeader) - 1);
    szHdr[ARRAYSIZE(c_szSnmHeader) - 1] = 0;
    if (0 == lstrcmp(szHdr, c_szSnmHeader))
        {
        // this is a Version 3.0 SNM file
        goto DoneImport;
        }

//  2) Do someting else!!! We need to verify as much as possible or we'll 
//     end up hanging.

    mapMsg = CreateFileMapping(hMsg, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapMsg == NULL)
        goto DoneImport;

    pMsg = (BYTE *)MapViewOfFile(mapMsg, FILE_MAP_READ, 0, 0, 0);
    if (pMsg == NULL)
        goto DoneImport;

    pEndMsg = pMsg + cbMsg;

//	Get the total number of messages in the SNM file
	lTotalMsgs	=	GetOffset(pSnm, cbSnm, 400, 0); //408 - 8 as we add 8 in GetOffset

    cMsgImp = 0;
    pLast = pMsg;

    pImport->SetMessageCount(lTotalMsgs);

    if (lTotalMsgs > 0)
	{
		Offset	=	(ULONG)GetPrimaryOffset(pSnm, cbSnm);
		//	Find the number of 'Levels'
		if(Offset < cbSnm)
		{
			while(lRoof < lTotalMsgs)
			{
				lRoof *= 32;
				nNumLevels++;
			}
			hr  = ProcessBlocks(pSnm, cbSnm, pMsg, cbMsg, nNumLevels, Offset, pImport);
		}
	}

DoneImport:
    if (pSnm != NULL)
        UnmapViewOfFile(pSnm);
    if (mapSnm != NULL)
        CloseHandle(mapSnm);
    if (pMsg != NULL)
        UnmapViewOfFile(pMsg);
    if (mapMsg != NULL)
        CloseHandle(mapMsg);

	CloseHandle(hSnm);
	CloseHandle(hMsg);

	return(hr);
    }

HRESULT CCommunicatorImport::ProcessBlocks(BYTE* pSnm, ULONG cbSnm, 
										   BYTE* pMsg, ULONG cbMsg, 
										   int nLayer, ULONG Offset,
										   IFolderImport *pImport)
{
	HRESULT hr = S_OK;
	HRESULT hr1 = E_FAIL;
	Assert(Offset + 7 < cbSnm);
	int		nNumLoops	=	(int)pSnm[Offset + 7];
	ULONG	NewOffset	=	0;

	for(int nElement = 0; nElement < nNumLoops; nElement++)
	{
        if(hr != hrUserCancel)
        {
            if(nLayer == 1)
            {
                NewOffset	=	GetOffset(pSnm, cbSnm, Offset, 2*nElement); 
                // We use 2*nElement above to access elements 8 bytes apart.
                hr1 = ProcessMessages(pSnm,cbSnm, pMsg, cbMsg, NewOffset, pImport);
                if(FAILED(hr1))
                    hr = E_FAIL;
                if(hr1 == hrUserCancel)
                    return hr1;
            }
            else
            {
                NewOffset	=	GetOffset(pSnm, cbSnm, Offset, nElement);
                hr = ProcessBlocks(pSnm, cbSnm, pMsg, cbMsg, nLayer - 1, NewOffset, pImport);
            }
        }
        else
            return(hrUserCancel);
	}
	return(hr);
}

ULONG CCommunicatorImport::GetPrimaryOffset(BYTE* pSnm, ULONG cbSnm)
{
	return GetOffset(pSnm, cbSnm, 416, 0); //424 - 8 as we add 8 in GetOffset
}

ULONG CCommunicatorImport::GetOffset(BYTE* pSnm, ULONG cbSnm, ULONG Offset, int nElement)
{
	Assert (3 + Offset + (4*(nElement + 2)) < cbSnm); // One common check point!!!
	ULONG result = 0;

	result	=	(ULONG)pSnm[0 + Offset + (4*(nElement + 2))]*16777216 + 
				(ULONG)pSnm[1 + Offset + (4*(nElement + 2))]*65536 + 
				(ULONG)pSnm[2 + Offset + (4*(nElement + 2))]*256 + 
				(ULONG)pSnm[3 + Offset + (4*(nElement + 2))];
	return result;
}

HRESULT CCommunicatorImport::ProcessMessages(BYTE* pSnm, ULONG cbSnm,
											 BYTE* pMsg, ULONG cbMsg,
											 ULONG NewOffset,
											 IFolderImport* pImport)
{
	ULONG	    lMsgOffset	=	0;
	ULONG	    uMsgSize	=	0;
	HRESULT     hr			=	E_FAIL;
	LPSTREAM    lpstm       =   NULL;
    int         nPriority   =   1;
    DWORD       dwFlags     =   0;

   	nPriority	=	(int)*(pSnm + NewOffset + 47);

    switch(nPriority)
    {
    case 1:
    case 4:
        dwFlags |= MSG_PRI_NORMAL;
        break;

    case 2:
    case 3:
        dwFlags |= MSG_PRI_LOW;
        break;

    case 5:
    case 6:
        dwFlags |= MSG_PRI_HIGH;
        break;

    default:
        dwFlags |= MSG_PRI_NORMAL;
        break;
    }

	lMsgOffset	=	GetOffset(pSnm, cbSnm, NewOffset + 18, 0);			//26 - 8 as we add 8 in GetOffset
	uMsgSize	=	GetOffset(pSnm, cbSnm, NewOffset + 40, 0);	//48 - 8 as we add 8 in GetOffset

	Assert(lMsgOffset + uMsgSize <= cbMsg);
    Assert(pImport != NULL);
	
    hr = HrByteToStream(&lpstm, pMsg + lMsgOffset, uMsgSize);
    if (SUCCEEDED(hr))
        {
        Assert(lpstm != NULL);
        // 0x01 == read
	    if (((pSnm + NewOffset) != NULL) && (0 == ((pSnm + NewOffset)[45] & 0x01)))
	        dwFlags |= MSG_STATE_UNREAD;
        if(m_bDraft)
            dwFlags |= MSG_STATE_UNSENT;

        hr = pImport->ImportMessage(MSG_TYPE_MAIL, dwFlags, lpstm, NULL, 0);
        lpstm->Release();
        }
	return hr;
}

CCommunicatorEnumFOLDERS::CCommunicatorEnumFOLDERS(EUDORANODE *plist)
    {
    Assert(plist != NULL);

    m_cRef = 1;
    m_plist = plist;
    m_pnext = plist;
    }

CCommunicatorEnumFOLDERS::~CCommunicatorEnumFOLDERS()
    {

    }

ULONG CCommunicatorEnumFOLDERS::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CCommunicatorEnumFOLDERS::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CCommunicatorEnumFOLDERS::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IEnumFOLDERS == riid)
		*ppv = (IEnumFOLDERS *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CCommunicatorEnumFOLDERS::Next(IMPORTFOLDER *pfldr)
    {
    Assert(pfldr != NULL);

    if (m_pnext == NULL)
        return(S_FALSE);

    ZeroMemory(pfldr, sizeof(IMPORTFOLDER));
    pfldr->dwCookie = (DWORD_PTR)m_pnext;

    // To map Netscape's "Sent" folder to OE's "Sent Items" - Bug 2688.
    if (m_pnext->type != FOLDER_TYPE_SENT)
        StrCpyN(pfldr->szName, m_pnext->szName, ARRAYSIZE(pfldr->szName));
    else
        StrCpyN(pfldr->szName, "Sent Items", ARRAYSIZE(pfldr->szName));

    pfldr->type = m_pnext->type;
    pfldr->fSubFolders = (m_pnext->pchild != NULL);

    m_pnext = m_pnext->pnext;

    return(S_OK);
    }

HRESULT CCommunicatorEnumFOLDERS::Reset()
    {
    m_pnext = m_plist;

    return(S_OK);
    }

 /*******************************************************************
 *  FUNCTION NAME:FindSnm
 *
 *  PURPOSE:To Get the Snm files in a folder
 *
 *  PARAMETERS:
 *
 *     IN:parent EUDORANODE ,previously processed EUDORANODE
 *
 *     OUT:	Pointer to the first node in the tree
 *
 *  RETURNS: TRUE or FALSE
 *******************************************************************/

HRESULT FindSnm(EUDORANODE *pparent, EUDORANODE **pplist,TCHAR *npath)
{
    HRESULT hr;
    HANDLE h1, h2;
	TCHAR path[MAX_PATH], path1[MAX_PATH], szInbox[CCHMAX_STRINGRES], szTrash[CCHMAX_STRINGRES];
    TCHAR szNewPath[MAX_PATH];
	WIN32_FIND_DATA	FindFileData;
	WIN32_FIND_DATA	SbdFileData;
	EUDORANODE *newp, *newp1, *last = NULL, *plist = NULL;
		
    Assert(pplist != NULL);
    Assert(npath != NULL);

    *pplist = NULL;

    StrCpyN(path, npath, ARRAYSIZE(path));
    StrCatBuff(path, c_szSnmExt, ARRAYSIZE(path));
	
	h1 = FindFirstFile(path, &FindFileData);
	if (h1 == INVALID_HANDLE_VALUE)
		return(S_OK);
	
    hr = E_OUTOFMEMORY;

    LoadString(g_hInstImp, idsInbox, szInbox, ARRAYSIZE(szInbox));
    LoadString(g_hInstImp, idsTrash, szTrash, ARRAYSIZE(szTrash));

    do
	{
	    if (!MemAlloc((void **)&newp, sizeof(EUDORANODE)))
		    goto err;
	    ZeroMemory(newp, sizeof(EUDORANODE));

	    if (plist == NULL)
            {
            Assert(last == NULL);
            plist = newp;
            }
        else
            {
            last->pnext = newp;
            }
	    last = newp;

	    StrCpyN(newp->szName, FindFileData.cFileName, ARRAYSIZE(newp->szName));

        wnsprintf(newp->szFile, ARRAYSIZE(newp->szFile), "%s\\%s", npath, newp->szName);

        newp->szName[(lstrlen(newp->szName)) - 4] = 0;    

        if (0 == lstrcmpi(newp->szName, szInbox))
            newp->type = FOLDER_TYPE_INBOX;
        else if (0 == lstrcmpi(newp->szName, szTrash))
            newp->type = FOLDER_TYPE_DELETED;
        else if(0 == lstrcmpi(newp->szName, c_szSent)) //c_szSent need not be localised as per my investigation - v-sramas.
            newp->type = FOLDER_TYPE_SENT;

		newp->pparent = pparent;
		newp->depth = (pparent == NULL ? 0 : (pparent->depth + 1));
        
        // This following will be used later to set the flag of 
        // a message so that it is editable (MSG_STATE_UNSENT).
        if ((0 == lstrcmpi(newp->szName, c_szDrafts)) ||(0 == lstrcmpi(newp->szName, c_szUnsent)))
            newp->iFileType = SNM_DRAFT;
        else
            newp->iFileType = SNM_FILE;

		// Search for a corresponding .SBD folder - file now.

	    wnsprintf(path1, ARRAYSIZE(path1), "%s", newp->szFile);
        path1[(lstrlen(path1)) - 3] = 0;
		StrCatBuff(path1, "sbd", ARRAYSIZE(path1));
		
		h2 = FindFirstFile(path1, &SbdFileData);

		if (h2 != INVALID_HANDLE_VALUE)
		{
			//Recurse here
            wnsprintf(szNewPath, ARRAYSIZE(szNewPath), "%s\\%s", npath, SbdFileData.cFileName);
			FindSnm(newp, &newp->pchild, szNewPath);
		}
	}
    while (FindNextFile(h1, &FindFileData));

    hr = S_OK;

err:
    FindClose(h1);
	
    if (FAILED(hr) && plist != NULL)
        {
        EudoraFreeFolderList(plist);
        plist = NULL;
        }
        
    *pplist = plist;

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\netscape\netsimp.cpp ===
#include "pch.hxx"
#include "impapi.h"
#include "comconv.h"
#include <newimp.h>
#include <eudrimp.h>
#include "netsimp.h"
#include <mapi.h>
#include <mapix.h>
#include <import.h>
#include <dllmain.h>

ASSERTDATA

HRESULT FindSnm(EUDORANODE **pplist, TCHAR *npath);
HRESULT ProcessMsg(BYTE *cMsgEntry, BYTE *pMsg, ULONG uMsgSize, IFolderImport *pImport);

CNetscapeImport::CNetscapeImport()
    {
    DllAddRef();

    m_cRef = 1;
    m_plist = NULL;
    }

CNetscapeImport::~CNetscapeImport()
    {
    if (m_plist != NULL)
        EudoraFreeFolderList(m_plist);

    DllRelease();
    }

ULONG CNetscapeImport::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CNetscapeImport::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CNetscapeImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IMailImport == riid)
		*ppv = (IMailImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CNetscapeImport::InitializeImport(HWND hwnd)
    {
	return(S_OK);
    }

HRESULT CNetscapeImport::GetDirectory(char *szDir, UINT cch)
    {
	HRESULT hr;

    Assert(szDir != NULL);

    hr = GetClientDir(szDir, cch, NETSCAPE);
    if (FAILED(hr))
        *szDir = 0;

	return(S_OK);
    }

HRESULT CNetscapeImport::SetDirectory(char *szDir)
    {
    HRESULT hr;

    Assert(szDir != NULL);

    if (!ValidStoreDirectory(szDir, NETSCAPE))
        return(S_FALSE);

    if (m_plist != NULL)
        {
        EudoraFreeFolderList(m_plist);
        m_plist = NULL;
        }

    hr = FindSnm(&m_plist, szDir);

	return(hr);
    }

HRESULT CNetscapeImport::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
    {
    CNetscapeEnumFOLDERS *pEnum;
    EUDORANODE *pnode;

    Assert(ppEnum != NULL);
    *ppEnum = NULL;

    if (dwCookie == COOKIE_ROOT)
        pnode = m_plist;
    else
        pnode = ((EUDORANODE *)dwCookie)->pchild;

    if (pnode == NULL)
        return(S_FALSE);

    pEnum = new CNetscapeEnumFOLDERS(pnode);
    if (pEnum == NULL)
        return(E_OUTOFMEMORY);

    *ppEnum = pEnum;

    return(S_OK);
    }

// From - dow mmm dd hh:mm:ss yyyy/r/n
const static char c_szNscpSep[] = "From - aaa aaa nn nn:nn:nn nnnn";
#define CCH_NETSCAPE_SEP    (ARRAYSIZE(c_szNscpSep) + 1) // we want CRLF at end of line

inline BOOL IsNetscapeMessage(BYTE *pMsg, BYTE *pEnd)
    {
    const char *pSep;
    int i;

    if (pMsg + CCH_NETSCAPE_SEP > pEnd)
        return(FALSE);

    pSep = c_szNscpSep;
    for (i = 0; i < (CCH_NETSCAPE_SEP - 2); i++)
        {
        if (*pSep == 'a')
            {
            if (!((*pMsg >= 'A' && *pMsg <= 'Z') ||
                (*pMsg >= 'a' && *pMsg <= 'z')))
                return(FALSE);
            }
        else if (*pSep == 'n')
            {
            if (!(*pMsg >= '0' && *pMsg <= '9'))
                return(FALSE);
            }
        else
            {
            if (*pSep != (char)*pMsg)
                return(FALSE);
            }

        pSep++;
        pMsg++;
        }

    if (*pMsg != 0x0d ||
        *(pMsg + 1) != 0x0a)
        return(FALSE);

    return(TRUE);
    }

BYTE *GetNextNetscapeMessage(BYTE *pCurr, BYTE *pEnd)
    {
    BYTE *pT;

    while (pCurr < (pEnd - 1))
        {
        if (*pCurr == 0x0d && *(pCurr + 1) == 0x0a)
            {
            pT = pCurr + 2;
            if (pT == pEnd)
                return(pT);
            else if (IsNetscapeMessage(pT, pEnd))
                return(pT);
            }

        pCurr++;
        }

    return(NULL);
    }

const static char c_szSnmHeader[] = "# Netscape folder cache";

STDMETHODIMP CNetscapeImport::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
    {
    char szHdr[64];
    EUDORANODE *pnode;
    HRESULT hr;
	TCHAR cMsgFile[MAX_PATH];
    BYTE *pSnm, *pMsg, *pEnd, *pEndMsg, *pT, *pNextMsg, *pLast;
	ULONG i, lMsgs, lTotalMsgs, lNumNulls, cbMsg, cbSnm, cExtra, uOffset, uMsgSize, cMsgImp;
    HANDLE mapSnm, mapMsg, hSnm, hMsg;

    Assert(pImport != NULL);

    pnode = (EUDORANODE *)dwCookie;
    Assert(pnode != NULL);

    hr = E_FAIL;
    pSnm = NULL;
    mapSnm = NULL;
    pMsg = NULL;
    mapMsg = NULL;

	StrCpyN(cMsgFile, pnode->szFile, ARRAYSIZE(cMsgFile));
	cMsgFile[(lstrlen(cMsgFile)) - 4] = 0;

	hMsg = CreateFile(cMsgFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hMsg == INVALID_HANDLE_VALUE)
		return(hrFolderOpenFail);

    cbMsg = GetFileSize(hMsg, NULL);
    if (cbMsg == 0)
        {
        CloseHandle(hMsg);
        return(S_OK);
        }

	hSnm = CreateFile(pnode->szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hSnm == INVALID_HANDLE_VALUE)
        {
        CloseHandle(hMsg);
        return(hrFolderOpenFail);
        }

    cbSnm = GetFileSize(hSnm, NULL);
    if (cbSnm < 59)
        {
        // the .snm file header is 59 bytes in size, so anything less
        // than this is bogus or doesn't have messages anyway, so no point
        // in continuing
        goto DoneImport;
        }

    mapSnm = CreateFileMapping(hSnm, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapSnm == NULL)
        goto DoneImport;

    pSnm = (BYTE *)MapViewOfFile(mapSnm, FILE_MAP_READ, 0, 0, 0);
    if (pSnm == NULL)
        goto DoneImport;

    pEnd = pSnm + cbSnm;

    CopyMemory(szHdr, pSnm, ARRAYSIZE(c_szSnmHeader) - 1);
    szHdr[ARRAYSIZE(c_szSnmHeader) - 1] = 0;
    if (0 != lstrcmp(szHdr, c_szSnmHeader))
        {
        // this is a bogus .snm file
        goto DoneImport;
        }

    mapMsg = CreateFileMapping(hMsg, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapMsg == NULL)
        goto DoneImport;

    pMsg = (BYTE *)MapViewOfFile(mapMsg, FILE_MAP_READ, 0, 0, 0);
    if (pMsg == NULL)
        goto DoneImport;

    pEndMsg = pMsg + cbMsg;

	// get the number of messages

    // # of messages in the .snm file
	lTotalMsgs = (unsigned long)pSnm[44] +
            (unsigned long)pSnm[43] * 256 +
            (unsigned long)pSnm[42] * 65536 +
            (unsigned long)pSnm[41] * 16777216;

    // # of non-deleted messages in the folder
    // this number may be larger than lTotalMsgs since messages
    // may exist in the folder that have no headers
	lMsgs = (unsigned long)pSnm[48] +
            (unsigned long)pSnm[47] * 256 +
            (unsigned long)pSnm[46] * 65536 +
            (unsigned long)pSnm[45] * 16777216;
	if (lMsgs == 0)
        {
        hr = S_OK;
        goto DoneImport;
        }

    cMsgImp = 0;
    pLast = pMsg;

    pImport->SetMessageCount(lMsgs);

    if (lTotalMsgs > 0)
        {
        // find the end of the string table
        lNumNulls = (unsigned long)pSnm[58] +
                    (unsigned long)pSnm[57] * 256;
        Assert(lNumNulls > 2);

        pT = pSnm + 59;
        while (pT < pEnd && lNumNulls != 0)
            {
            if (*pT == 0)
                lNumNulls--;
            pT++;
            }

        if (lNumNulls != 0)
            goto DoneImport;

        Assert(*(pT - 1) == 0 && *pT == 0);

	    for (i = 0; i < lTotalMsgs; i++)
	        {
            if (pT + 30 > pEnd)
                {
                // probably not a good idea to read past the end of the header file...
                hr = S_OK;
                goto DoneImport;
                }

	        uOffset = (unsigned long)pT[17] +
                    (unsigned long)pT[16] * 256 +
                    (unsigned long)pT[15] * 65536 +
                    (unsigned long)pT[14] * 16777216;

            uMsgSize = (unsigned long)pT[21] +
                    (unsigned long)pT[20] * 256 +
                    (unsigned long)pT[19] * 65536 +
                    (unsigned long)pT[18] * 16777216;

            pNextMsg = pMsg + uOffset;
            Assert(pNextMsg == pLast);

            if (pNextMsg + uMsgSize > pEndMsg)
                {
                // probably not a good idea to read past the end of the message file...
                hr = S_OK;
                goto DoneImport;
                }

	        if (0 == (pT[13] & 8))
                {
                // this is not a deleted message so lets import it

                cMsgImp++;
    		    hr = ProcessMsg(pT, pNextMsg, uMsgSize, pImport);
                if (hr == E_OUTOFMEMORY || hr == hrDiskFull || hr == hrUserCancel)
                    goto DoneImport;
                }

            pLast = pNextMsg + uMsgSize;

            // set pointer to next header
    	    cExtra = (unsigned long)pT[29] +
                (unsigned long)pT[28] * 256;
            pT += (30 + cExtra * 2);
	        }
        }

    // now import the messages that don't have headers yet...
    while (pLast < pEndMsg && cMsgImp < lMsgs)
        {
        pNextMsg = GetNextNetscapeMessage(pLast, pEndMsg);
        if (pNextMsg == NULL)
            break;

        uMsgSize = (ULONG)(pNextMsg - pLast);
        cMsgImp++;
        hr = ProcessMsg(NULL, pLast, uMsgSize, pImport);
        if (hr == E_OUTOFMEMORY || hr == hrDiskFull || hr == hrUserCancel)
            goto DoneImport;

        pLast = pNextMsg;
        }

    hr = S_OK;

DoneImport:
    if (pSnm != NULL)
        UnmapViewOfFile(pSnm);
    if (mapSnm != NULL)
        CloseHandle(mapSnm);
    if (pMsg != NULL)
        UnmapViewOfFile(pMsg);
    if (mapMsg != NULL)
        CloseHandle(mapMsg);

	CloseHandle(hSnm);
	CloseHandle(hMsg);

	return(hr);
    }

CNetscapeEnumFOLDERS::CNetscapeEnumFOLDERS(EUDORANODE *plist)
    {
    Assert(plist != NULL);

    m_cRef = 1;
    m_plist = plist;
    m_pnext = plist;
    }

CNetscapeEnumFOLDERS::~CNetscapeEnumFOLDERS()
    {

    }

ULONG CNetscapeEnumFOLDERS::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CNetscapeEnumFOLDERS::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CNetscapeEnumFOLDERS::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IEnumFOLDERS == riid)
		*ppv = (IEnumFOLDERS *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CNetscapeEnumFOLDERS::Next(IMPORTFOLDER *pfldr)
    {
    Assert(pfldr != NULL);

    if (m_pnext == NULL)
        return(S_FALSE);

    ZeroMemory(pfldr, sizeof(IMPORTFOLDER));
    pfldr->dwCookie = (DWORD_PTR)m_pnext;
    StrCpyN(pfldr->szName, m_pnext->szName, ARRAYSIZE(pfldr->szName));
    pfldr->type = m_pnext->type;
    pfldr->fSubFolders = (m_pnext->pchild != NULL);

    m_pnext = m_pnext->pnext;

    return(S_OK);
    }

HRESULT CNetscapeEnumFOLDERS::Reset()
    {
    m_pnext = m_plist;

    return(S_OK);
    }

 /*******************************************************************
 *  FUNCTION NAME:FindSnm
 *
 *  PURPOSE:To Get the Snm files in a folder
 *
 *  PARAMETERS:
 *
 *     IN:parent EUDORANODE ,previously processed EUDORANODE
 *
 *     OUT:	Pointer to the first node in the tree
 *
 *  RETURNS: TRUE or FALSE
 *******************************************************************/

HRESULT FindSnm(EUDORANODE **pplist,TCHAR *npath)
    {
    HRESULT hr;
    HANDLE h1;
	TCHAR path[MAX_PATH], szInbox[CCHMAX_STRINGRES], szTrash[CCHMAX_STRINGRES];
	WIN32_FIND_DATA	FindFileData;
	EUDORANODE *newp, *last = NULL, *plist = NULL;
		
    Assert(pplist != NULL);
    Assert(npath != NULL);

    *pplist = NULL;

    wnsprintf(path, ARRAYSIZE(path), "%s\\*.snm", npath);
	
	h1 = FindFirstFile(path, &FindFileData);
	if (h1 == INVALID_HANDLE_VALUE)
		return(S_OK);
	
    hr = E_OUTOFMEMORY;

    LoadString(g_hInstImp, idsInbox, szInbox, ARRAYSIZE(szInbox));
    LoadString(g_hInstImp, idsTrash, szTrash, ARRAYSIZE(szTrash));

    do
        {
	    if (!MemAlloc((void **)&newp, sizeof(EUDORANODE)))
		    goto err;
	    ZeroMemory(newp, sizeof(EUDORANODE));

	    if (plist == NULL)
            {
            Assert(last == NULL);
            plist = newp;
            }
        else
            {
            last->pnext = newp;
            }
	    last = newp;

	    StrCpyN(newp->szName, FindFileData.cFileName, ARRAYSIZE(newp->szName));

        wnsprintf(newp->szFile, ARRAYSIZE(newp->szFile), "%s\\%s", npath, newp->szName);

        newp->szName[(lstrlen(newp->szName)) - 4] = 0;    

        if (0 == lstrcmpi(newp->szName, szInbox))
            newp->type = FOLDER_TYPE_INBOX;
        else if (0 == lstrcmpi(newp->szName, szTrash))
            newp->type = FOLDER_TYPE_DELETED;
        }
    while (FindNextFile(h1, &FindFileData));

    hr = S_OK;

err:
    FindClose(h1);
	
    if (FAILED(hr) && plist != NULL)
        {
        EudoraFreeFolderList(plist);
        plist = NULL;
        }
        
    *pplist = plist;

    return(hr);
    }

HRESULT ProcessMsg(BYTE *cMsgEntry, BYTE *pMsg, ULONG uMsgSize, IFolderImport *pImport)
    {
    HRESULT hr;
    DWORD dw;
	LPSTREAM  lpstm = NULL;

    Assert(pImport != NULL);

    hr = HrByteToStream(&lpstm, pMsg, uMsgSize);
    if (SUCCEEDED(hr))
        {
        Assert(lpstm != NULL);

        dw = 0;
        // 0x01 == read
        // 0x10 == newly downloaded
	    if (cMsgEntry != NULL &&
            0 == (cMsgEntry[13] & 0x01))
	        dw |= MSG_STATE_UNREAD;

        hr = pImport->ImportMessage(MSG_TYPE_MAIL, dw, lpstm, NULL, 0);

        lpstm->Release();
        }

    return(hr);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\oe4\oe4imp.h ===
//--------------------------------------------------------------------------
// OE4Imp.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include <newimp.h>

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
typedef struct tagIMPFOLDERNODE IMPFOLDERNODE;
typedef struct tagFLDINFO *LPFLDINFO;

//--------------------------------------------------------------------------
// {BCE9E2E7-1FDD-11d2-9A79-00C04FA309D4}
//--------------------------------------------------------------------------
DEFINE_GUID(CLSID_COE4Import, 0xbce9e2e7, 0x1fdd, 0x11d2, 0x9a, 0x79, 0x0, 0xc0, 0x4f, 0xa3, 0x9, 0xd4);

//--------------------------------------------------------------------------
// {B977CB11-1FF5-11d2-9A7A-00C04FA309D4}
//--------------------------------------------------------------------------
DEFINE_GUID(CLSID_CIMN1Import, 0xb977cb11, 0x1ff5, 0x11d2, 0x9a, 0x7a, 0x0, 0xc0, 0x4f, 0xa3, 0x9, 0xd4);

//--------------------------------------------------------------------------
// COE4EnumFolders
//--------------------------------------------------------------------------
class COE4EnumFolders : public IEnumFOLDERS
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    COE4EnumFolders(IMPFOLDERNODE *plist);
    ~COE4EnumFolders(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IEnumFOLDERS Members
    //----------------------------------------------------------------------
    STDMETHODIMP Next(IMPORTFOLDER *pfldr);
    STDMETHODIMP Reset(void);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG            m_cRef;
    IMPFOLDERNODE  *m_pList;
    IMPFOLDERNODE  *m_pNext;
};

//--------------------------------------------------------------------------
// COE4Import
//--------------------------------------------------------------------------
class COE4Import : public IMailImport
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    COE4Import(void);
    ~COE4Import(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMailImport Members
    //----------------------------------------------------------------------
    STDMETHODIMP InitializeImport(HWND hwnd);
    STDMETHODIMP GetDirectory(LPSTR pszDir, UINT cch);
    STDMETHODIMP SetDirectory(LPSTR pszDir);
    STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
    STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _BuildFolderHierarchy(DWORD cDepth, DWORD idParent, IMPFOLDERNODE *pParent, DWORD cFolders, LPFLDINFO prgFolder);
    HRESULT _EnumerateV1Folders(void);
    void _FreeFolderList(IMPFOLDERNODE *pNode);
    void _Cleanup(void);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG            m_cRef;
    CHAR            m_szDirectory[MAX_PATH];
    DWORD           m_cFolders;
    LPFLDINFO       m_prgFolder;
    IMPFOLDERNODE  *m_pList;
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
COE4Import_CreateInstance(IUnknown *pUnkOuter, IUnknown **ppUnknown);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\athena16.h ===
/*****************************************************************************\
*                                                                             *
* Athena16.h                                                                  *
*                                                                             *
\*****************************************************************************/

#ifndef ATHENA16_H
#define ATHENA16_H

#define SECURITY_WIN16

/*----------------------------------------------------------------------------
*  Note that we don't want to use a single line comment before the warning is
*   disabled.
*
*   Microsoft Windows
*   Copyright (C) Microsoft Corporation, 1992 - 1994.
*
*   File:       w4warn.h
*
*   Contents:   #pragmas to adjust warning levels.
*
*---------------------------------------------------------------------------*/

/*
 *   Level 4 warnings to suppress.
 */

#ifdef __WATCOMC__
#pragma warning 442 9
#pragma warning 604 9
#pragma warning 583 9
#pragma warning 594 9

#pragma warning 379 9	// 'delete' expression will invoke a non-virtual destructor
#pragma warning 387 9   // expression is useful only for its side effects
#pragma warning 354	4	// unsigned or pointer expression is always >= 0
#pragma warning 389 4	// integral value may be truncated during assignment
#pragma warning 4	4	// base class XXX does not have a virtual destructor
#pragma warning 13	4	// unreachable code
#pragma warning 628 4	// expression is not meaningful
#pragma warning 627 9   // text following pre-processor directive (comment after endif)

#pragma warning 188	5	// base class is inherited with private access. basically means base
						// class access hasn't been specified on the class definiton.

#pragma off(unreferenced)

#endif 

#include "x16menu.h"

#ifndef WIN16_INETCOMM
#define _IMNXPORT_
#define _IMNACCT_
#define _MIMEOLE_
#endif // WIN16_INETCOM

#ifdef __cplusplus
extern "C"{
#endif

/*****************************************************************************\
*                                                                             *
*  From rpc.h(INC16) - It should be in "ocidl.h" of the INC16.
*                                                                             *
\*****************************************************************************/

#ifdef __WATCOMC__
#define __RPC_FAR  __far
#define __RPC_API  __far __pascal
#define __RPC_USER __pascal 
#define __RPC_STUB __far __pascal 
#define RPC_ENTRY  __pascal __far

typedef void __near * I_RPC_HANDLE;
#else

#define __RPC_FAR  __far
#define __RPC_API  __far __pascal
#define __RPC_USER __far __pascal __export
#define __RPC_STUB __far __pascal __export
#define RPC_ENTRY  __pascal __export __far

typedef void _near * I_RPC_HANDLE;
#endif


/*****************************************************************************\
*                                                                             *
*  From Winver.h(INC32)
*                                                                             *
\*****************************************************************************/

#if 0
/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */

#define GetFileVersionInfoSize  GetFileVersionInfoSizeA

/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */

#define GetFileVersionInfo  GetFileVersionInfoA

BOOL
APIENTRY
VerQueryValueA(
        const LPVOID pBlock,
        LPSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );

#define VerQueryValue  VerQueryValueA
#endif


/*****************************************************************************\
*                                                                             *
*  From winbase.h (INC32)
*                                                                             *
\*****************************************************************************/
typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;          // Obsolete field...do not use
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        };
    };
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;

LPVOID
WINAPI
VirtualAlloc(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );

BOOL
WINAPI
VirtualFree(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD dwFreeType
    );

VOID
WINAPI
GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    );

#if 0    // Now WIN16 has this
typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR   cFileName[ MAX_PATH ];
    CHAR   cAlternateFileName[ 14 ];
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
#endif //0

#define FILE_FLAG_DELETE_ON_CLOSE       0x04000000

typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

//
// dwCreationFlag values
//
#define CREATE_DEFAULT_ERROR_MODE   0x04000000

// File attributes.
BOOL
WINAPI
SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    );
BOOL
WINAPI
SetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );
#ifdef UNICODE
#define SetFileAttributes  SetFileAttributesW
#else
#define SetFileAttributes  SetFileAttributesA
#endif // !UNICODE

///////////////////////////////////////////////////////////////
//                                                           //
//      Win Certificate API and Structures                   //
//                                                           //
///////////////////////////////////////////////////////////////

//
// Structures
//

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1
#endif

#if 0 // Now BASETYPS has this
typedef struct _WIN_CERTIFICATE {
    DWORD       dwLength;
    WORD        wRevision;
    WORD        wCertificateType;   // WIN_CERT_TYPE_xxx
    BYTE        bCertificate[ANYSIZE_ARRAY];
} WIN_CERTIFICATE, *LPWIN_CERTIFICATE;
#endif




/* Heap related APIs.
 *
 * HeapCreate and HeapDestroy does nothing.
 * HeapAlloc and HeapFree use GlobalAlloc, GlobalLock and GlobalFree.
 *
 */
#define HeapCreate(a,b,c) ((HANDLE)1)
#define HeapDestroy(a) ((BOOL)1)

#define HeapAlloc OE16HeapAlloc
#define HeapFree OE16HeapFree

LPVOID
WINAPI
OE16HeapAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    DWORD dwBytes
    );

LPVOID
WINAPI
HeapReAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem,
    DWORD dwBytes
    );

BOOL
WINAPI
OE16HeapFree(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    );


DWORD
WINAPI
HeapSize(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );

DWORD
WINAPI
GetShortPathNameA(
    LPCSTR lpszLongPath,
    LPSTR  lpszShortPath,
    DWORD    cchBuffer
    );

#define GetShortPathName  GetShortPathNameA

VOID
WINAPI
SetLastError(
    DWORD dwErrCode
    );

#ifdef RUN16_WIN16X
LONG
WINAPI
CompareFileTime(
    CONST FILETIME *lpFileTime1,
    CONST FILETIME *lpFileTime2
    );
#endif //RUN16_WIN16X

typedef struct _STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;

typedef STARTUPINFOA STARTUPINFO;

UINT
WINAPI
GetDriveTypeA(
    LPCSTR lpRootPathName
    );

#define GetDriveType  GetDriveTypeA

BOOL
WINAPI
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#define CreateDirectory  CreateDirectoryA

DWORD
WINAPI
GetEnvironmentVariableA(
    LPCSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    );

#define GetEnvironmentVariable  GetEnvironmentVariableA

/* DUP???
BOOL
WINAPI
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

#define CreateDirectory  CreateDirectoryA
*/

BOOL
WINAPI
GetComputerNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    );

#define GetComputerName  GetComputerNameA

BOOL
WINAPI
GetUserNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    );

#define GetUserName  GetUserNameA

typedef OSVERSIONINFOA OSVERSIONINFO;

HANDLE
WINAPI
CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );

#define CreateFileMapping  CreateFileMappingA

// flProtect -- defined in sdk\inc\winnt.h
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     

LPVOID
WINAPI
MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap
    );

// dwDesiredAccess -- defined in sdk\inc\winnt.h
#define SECTION_MAP_WRITE   0x0002
#define SECTION_MAP_READ    0x0004
#define FILE_MAP_WRITE      SECTION_MAP_WRITE
#define FILE_MAP_READ       SECTION_MAP_READ

BOOL
WINAPI
UnmapViewOfFile(
    LPCVOID lpBaseAddress
    );


/*****************************************************************************\
*                                                                             *
*  OE16 File mapping object related function prototype
*                                                                             *
\*****************************************************************************/

LPVOID
WINAPI
OE16CreateFileMapping(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );

LPVOID
WINAPI
OE16MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap
    );

BOOL
WINAPI
OE16UnmapViewOfFile(
    LPCVOID lpBaseAddress
    );

BOOL
WINAPI
OE16CloseFileMapping(
    LPVOID lpObject
    );

/*****************************************************************************\
*                                                                             *
*  ???
*                                                                             *
\*****************************************************************************/
BOOL
WINAPI
GetDiskFreeSpaceA(
    LPCSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );
#define GetDiskFreeSpace  GetDiskFreeSpaceA

#define TIME_ZONE_ID_UNKNOWN  0
#define TIME_ZONE_ID_STANDARD 1
#define TIME_ZONE_ID_DAYLIGHT 2

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, FAR* LPTIME_ZONE_INFORMATION;

DWORD
WINAPI
GetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );

BOOL
WINAPI
IsTextUnicode(
    CONST LPVOID lpBuffer,
    int cb,
    LPINT lpi
    );

VOID
WINAPI
GetSystemTimeAsFileTime(
    LPFILETIME lpSystemTimeAsFileTime
    );

DWORD
WINAPI
ExpandEnvironmentStrings(
    LPCSTR lpSrc,
    LPSTR lpDst,
    DWORD nSize
    );

/*****************************************************************************\
*                                                                             *
*  OE16 Thread related function prototype and re-define
*                                                                             *
\*****************************************************************************/

// We don't support following APIs in Win16
#undef CreateSemaphore
#undef CreateSemaphoreA
#undef ReleaseSemaphore
#undef CreateMutex
#undef CreateMutexA
#undef WaitForMultipleObjects

#define CreateSemaphore(a,b,c,d) ((HANDLE)1)
#define CreateSemaphoreA(a,b,c,d) ((HANDLE)1)
#define ReleaseSemaphore(a,b,c) ((BOOL)1)
#define CreateMutex(a,b,c) ((HANDLE)1)
#define CreateMutexA(a,b,c) ((HANDLE)1)
#define WaitForMultipleObjects(a,b,c,d) ((DWORD)WAIT_OBJECT_0)

// Because of the following line in sdk\inc\objidl.h,
// we can't use "#define ReleaseMutex(a), ((BOOL)1)".
//
// virtual HRESULT STDMETHODCALLTYPE ReleaseMutex( void) = 0;
//
#undef ReleaseMutex
#define ReleaseMutex OE16ReleaseMutex

BOOL
WINAPI
OE16ReleaseMutex(
    HANDLE hMutex
    );

// We don't need following APIs in Win16
#undef InitializeCriticalSection
#undef EnterCriticalSection
#undef LeaveCriticalSection
#undef DeleteCriticalSection

#define InitializeCriticalSection(a)
#define EnterCriticalSection(a)
#define LeaveCriticalSection(a)
#define DeleteCriticalSection(a)

// We support following Event APIs in Win16.
//CreateEvent, SetEvent, ResetEvent, PulseEvent

// We suppot WFSO for event and Thread. Since OE32 has a call
// for Mutex and Semaphore, we will have private WFSO in OE16.

#undef  WaitForSingleObject
#define WaitForSingleObject(a,b) ((DWORD)WAIT_OBJECT_0)

// We have a define in common.h
//#define WaitForSingleObject_16 w16WaitForSingleObject

// WIN16FF - Should we ignore process APIs as well??? - WJPark
BOOL
WINAPI
CreateProcessA(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

#define CreateProcess  CreateProcessA


#if 0
/*****************************************************************************\
*                                                                             *
*  From sspi.h(INC32)
*                                                                             *
\*****************************************************************************/

typedef HRESULT SECURITY_STATUS;

//
// Okay, security specific types:
//

typedef struct _SecHandle
{
    unsigned long dwLower;
    unsigned long dwUpper;
} SecHandle, __far * PSecHandle;

typedef SecHandle CredHandle;
typedef PSecHandle PCredHandle;

typedef SecHandle CtxtHandle;
typedef PSecHandle PCtxtHandle;

//
//  InitializeSecurityContext Requirement and return flags:
//

#define ISC_REQ_DELEGATE                0x00000001
#define ISC_REQ_MUTUAL_AUTH             0x00000002
#define ISC_REQ_REPLAY_DETECT           0x00000004
#define ISC_REQ_SEQUENCE_DETECT         0x00000008
#define ISC_REQ_CONFIDENTIALITY         0x00000010
#define ISC_REQ_USE_SESSION_KEY         0x00000020
#define ISC_REQ_PROMPT_FOR_CREDS        0x00000040
#define ISC_REQ_USE_SUPPLIED_CREDS      0x00000080
#define ISC_REQ_ALLOCATE_MEMORY         0x00000100
#define ISC_REQ_USE_DCE_STYLE           0x00000200
#define ISC_REQ_DATAGRAM                0x00000400
#define ISC_REQ_CONNECTION              0x00000800
#define ISC_REQ_CALL_LEVEL              0x00001000
#define ISC_REQ_EXTENDED_ERROR          0x00004000
#define ISC_REQ_STREAM                  0x00008000
#define ISC_REQ_INTEGRITY               0x00010000
#define ISC_REQ_IDENTIFY                0x00020000

#define ISC_RET_DELEGATE                0x00000001
#define ISC_RET_MUTUAL_AUTH             0x00000002
#define ISC_RET_REPLAY_DETECT           0x00000004
#define ISC_RET_SEQUENCE_DETECT         0x00000008
#define ISC_RET_CONFIDENTIALITY         0x00000010
#define ISC_RET_USE_SESSION_KEY         0x00000020
#define ISC_RET_USED_COLLECTED_CREDS    0x00000040
#define ISC_RET_USED_SUPPLIED_CREDS     0x00000080
#define ISC_RET_ALLOCATED_MEMORY        0x00000100
#define ISC_RET_USED_DCE_STYLE          0x00000200
#define ISC_RET_DATAGRAM                0x00000400
#define ISC_RET_CONNECTION              0x00000800
#define ISC_RET_INTERMEDIATE_RETURN     0x00001000
#define ISC_RET_CALL_LEVEL              0x00002000
#define ISC_RET_EXTENDED_ERROR          0x00004000
#define ISC_RET_STREAM                  0x00008000
#define ISC_RET_INTEGRITY               0x00010000
#define ISC_RET_IDENTIFY                0x00020000

#define ASC_REQ_DELEGATE                0x00000001
#define ASC_REQ_MUTUAL_AUTH             0x00000002
#define ASC_REQ_REPLAY_DETECT           0x00000004
#define ASC_REQ_SEQUENCE_DETECT         0x00000008
#define ASC_REQ_CONFIDENTIALITY         0x00000010
#define ASC_REQ_USE_SESSION_KEY         0x00000020
#define ASC_REQ_ALLOCATE_MEMORY         0x00000100
#define ASC_REQ_USE_DCE_STYLE           0x00000200
#define ASC_REQ_DATAGRAM                0x00000400
#define ASC_REQ_CONNECTION              0x00000800
#define ASC_REQ_CALL_LEVEL              0x00001000
#define ASC_REQ_EXTENDED_ERROR          0x00008000
#define ASC_REQ_STREAM                  0x00010000
#define ASC_REQ_INTEGRITY               0x00020000
#define ASC_REQ_LICENSING               0x00040000


#define ASC_RET_DELEGATE                0x00000001
#define ASC_RET_MUTUAL_AUTH             0x00000002
#define ASC_RET_REPLAY_DETECT           0x00000004
#define ASC_RET_SEQUENCE_DETECT         0x00000008
#define ASC_RET_CONFIDENTIALITY         0x00000010
#define ASC_RET_USE_SESSION_KEY         0x00000020
#define ASC_RET_ALLOCATED_MEMORY        0x00000100
#define ASC_RET_USED_DCE_STYLE          0x00000200
#define ASC_RET_DATAGRAM                0x00000400
#define ASC_RET_CONNECTION              0x00000800
#define ASC_RET_CALL_LEVEL              0x00002000 // skipped 1000 to be like ISC_
#define ASC_RET_THIRD_LEG_FAILED        0x00004000
#define ASC_RET_EXTENDED_ERROR          0x00008000
#define ASC_RET_STREAM                  0x00010000
#define ASC_RET_INTEGRITY               0x00020000
#define ASC_RET_LICENSING               0x00040000

#endif

/*****************************************************************************\
*                                                                             *
*  From shlobj.h(INC32)
*                                                                             *
\*****************************************************************************/

#ifdef _SHLOBJ_H_

#ifndef INITGUID
#include <shlguid.h>
#endif /* !INITGUID */

//===========================================================================
//
// IShellLink Interface
//
//===========================================================================

#if 0    // Now SHLOBJ has this
#define IShellLink      IShellLinkA

// IShellLink::Resolve fFlags
typedef enum {
    SLR_NO_UI           = 0x0001,
    SLR_ANY_MATCH       = 0x0002,
    SLR_UPDATE          = 0x0004,
} SLR_FLAGS;

// IShellLink::GetPath fFlags
typedef enum {
    SLGP_SHORTPATH      = 0x0001,
    SLGP_UNCPRIORITY    = 0x0002,
    SLGP_RAWPATH        = 0x0004,
} SLGP_FLAGS;

#undef  INTERFACE
#define INTERFACE   IShellLinkA

DECLARE_INTERFACE_(IShellLinkA, IUnknown)       // sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(GetPath)(THIS_ LPSTR pszFile, int cchMaxPath, WIN32_FIND_DATAA *pfd, DWORD fFlags) PURE;

    STDMETHOD(GetIDList)(THIS_ LPITEMIDLIST * ppidl) PURE;
    STDMETHOD(SetIDList)(THIS_ LPCITEMIDLIST pidl) PURE;

    STDMETHOD(GetDescription)(THIS_ LPSTR pszName, int cchMaxName) PURE;
    STDMETHOD(SetDescription)(THIS_ LPCSTR pszName) PURE;

    STDMETHOD(GetWorkingDirectory)(THIS_ LPSTR pszDir, int cchMaxPath) PURE;
    STDMETHOD(SetWorkingDirectory)(THIS_ LPCSTR pszDir) PURE;

    STDMETHOD(GetArguments)(THIS_ LPSTR pszArgs, int cchMaxPath) PURE;
    STDMETHOD(SetArguments)(THIS_ LPCSTR pszArgs) PURE;

    STDMETHOD(GetHotkey)(THIS_ WORD *pwHotkey) PURE;
    STDMETHOD(SetHotkey)(THIS_ WORD wHotkey) PURE;

    STDMETHOD(GetShowCmd)(THIS_ int *piShowCmd) PURE;
    STDMETHOD(SetShowCmd)(THIS_ int iShowCmd) PURE;

    STDMETHOD(GetIconLocation)(THIS_ LPSTR pszIconPath, int cchIconPath, int *piIcon) PURE;
    STDMETHOD(SetIconLocation)(THIS_ LPCSTR pszIconPath, int iIcon) PURE;

    STDMETHOD(SetRelativePath)(THIS_ LPCSTR pszPathRel, DWORD dwReserved) PURE;

    STDMETHOD(Resolve)(THIS_ HWND hwnd, DWORD fFlags) PURE;

    STDMETHOD(SetPath)(THIS_ LPCSTR pszFile) PURE;
};
#endif //0

//-------------------------------------------------------------------------
//
// SHGetPathFromIDList
//
//  This function assumes the size of the buffer (MAX_PATH). The pidl
// should point to a file system object.
//
//-------------------------------------------------------------------------

BOOL WINAPI SHGetPathFromIDListA(LPCITEMIDLIST pidl, LPSTR pszPath);

#define SHGetPathFromIDList SHGetPathFromIDListA


#if 0    // Now SHLOBJ has this
typedef int (CALLBACK* BFFCALLBACK)(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

typedef struct _browseinfoA {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPSTR        pszDisplayName;// Return display name of item selected.
    LPCSTR       lpszTitle;      // text to go in the banner over the tree.
    UINT         ulFlags;       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM      lParam;         // extra info that's passed back in callbacks

    int          iImage;      // output var: where to return the Image index.
} BROWSEINFOA, *PBROWSEINFOA, *LPBROWSEINFOA;

#define BROWSEINFO      BROWSEINFOA

// Browsing for directory.
#define BIF_RETURNONLYFSDIRS   0x0001  // For finding a folder to start document searching
#define BIF_DONTGOBELOWDOMAIN  0x0002  // For starting the Find Computer
#define BIF_STATUSTEXT         0x0004
#define BIF_RETURNFSANCESTORS  0x0008
#define BIF_EDITBOX            0x0010

// message from browser
#define BFFM_INITIALIZED        1
#define BFFM_SELCHANGED         2

// messages to browser
#define BFFM_ENABLEOK           (WM_USER + 101)
#define BFFM_SETSELECTIONA      (WM_USER + 102)

#define BFFM_SETSELECTION   BFFM_SETSELECTIONA
#endif //0

//
// format of CF_HDROP and CF_PRINTERS, in the HDROP case the data that follows
// is a double null terinated list of file names, for printers they are printer
// friendly names
//
#if 0    // Now SHLOBJ has this
typedef struct _DROPFILES {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point (client coords)
   BOOL fNC;                           // is it on NonClient area
                                       // and pt is in screen coords
   BOOL fWide;                         // WIDE character switch
} DROPFILES, FAR * LPDROPFILES;
#endif //0

#undef  INTERFACE
#define INTERFACE   IShellToolbarSite

DECLARE_INTERFACE_(IShellToolbarSite, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellToolbarSite methods ***
    STDMETHOD(GetBorderST) (THIS_ IUnknown* punkSrc, LPRECT prcBorder) PURE;
    STDMETHOD(RequestBorderSpaceST) (THIS_ IUnknown* punkSrc, LPCBORDERWIDTHS pbw) PURE;
    STDMETHOD(SetBorderSpaceST) (THIS_ IUnknown* punkSrc, LPCBORDERWIDTHS pbw) PURE;
    STDMETHOD(OnFocusChangeST) (THIS_ IUnknown* punkSrc, BOOL fSetFocus) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellToolbarFrame

#define STFRF_NORMAL            0x0000
#define STFRF_DELETECONFIGDATA  0x0001

DECLARE_INTERFACE_(IShellToolbarFrame, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellToolbarFrame methods ***
    STDMETHOD(AddToolbar) (THIS_ IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwReserved) PURE;
    STDMETHOD(RemoveToolbar) (THIS_ IUnknown* punkSrc, DWORD dwRemoveFlags) PURE;
    STDMETHOD(FindToolbar) (THIS_ LPCWSTR pwszItem, REFIID riid, LPVOID* ppvObj) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellToolbar

DECLARE_INTERFACE_(IShellToolbar, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellToolbar methods ***
    STDMETHOD(SetToolbarSite) (THIS_ IUnknown* punkSite) PURE;
    STDMETHOD(ShowST)         (THIS_ BOOL fShow) PURE;
    STDMETHOD(CloseST)        (THIS_ DWORD dwReserved) PURE;
    STDMETHOD(ResizeBorderST) (THIS_ LPCRECT   prcBorder,
                                     IUnknown* punkToolbarSite,
                                     BOOL      fReserved) PURE;
    STDMETHOD(TranslateAcceleratorST) (THIS_ LPMSG lpmsg) PURE;
    STDMETHOD(HasFocus)       (THIS) PURE;
};

#if 0    // Now SHLOBJ has this
// GetIconLocation() input flags

#define GIL_OPENICON     0x0001      // allows containers to specify an "open" look
#define GIL_FORSHELL     0x0002      // icon is to be displayed in a ShellFolder
#define GIL_ASYNC        0x0020      // this is an async extract, return E_ASYNC

// GetIconLocation() return flags

#define GIL_SIMULATEDOC  0x0001      // simulate this document icon for this
#define GIL_PERINSTANCE  0x0002      // icons from this class are per instance (each file has its own)
#define GIL_PERCLASS     0x0004      // icons from this class per class (shared for all files of this type)
#define GIL_NOTFILENAME  0x0008      // location is not a filename, must call ::ExtractIcon
#define GIL_DONTCACHE    0x0010      // this icon should not be cached

#undef  INTERFACE
#define INTERFACE   IExtractIconA

DECLARE_INTERFACE_(IExtractIconA, IUnknown)     // exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPSTR  szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                           LPCSTR pszFile,
                           UINT   nIconIndex,
                           HICON   *phiconLarge,
                           HICON   *phiconSmall,
                           UINT    nIconSize) PURE;
};

typedef IExtractIconA * LPEXTRACTICONA;

#undef  INTERFACE
#define INTERFACE   IExtractIconW

DECLARE_INTERFACE_(IExtractIconW, IUnknown)     // exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPWSTR szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                           LPCWSTR pszFile,
                           UINT   nIconIndex,
                           HICON   *phiconLarge,
                           HICON   *phiconSmall,
                           UINT    nIconSize) PURE;
};

typedef IExtractIconW * LPEXTRACTICONW;

#ifdef UNICODE
#define IExtractIcon        IExtractIconW
#define IExtractIconVtbl    IExtractIconWVtbl
#define LPEXTRACTICON       LPEXTRACTICONW
#else
#define IExtractIcon        IExtractIconA
#define IExtractIconVtbl    IExtractIconAVtbl
#define LPEXTRACTICON       LPEXTRACTICONA
#endif
#endif //0

#if 0    // Now SHLOBJ has this
//==========================================================================
//
// IShellBrowser/IShellView/IShellFolder interface
//
//  These three interfaces are used when the shell communicates with
// name space extensions. The shell (explorer) provides IShellBrowser
// interface, and extensions implements IShellFolder and IShellView
// interfaces.
//
//==========================================================================


//--------------------------------------------------------------------------
//
// Command/menuitem IDs
//
//  The explorer dispatches WM_COMMAND messages based on the range of
// command/menuitem IDs. All the IDs of menuitems that the view (right
// pane) inserts must be in FCIDM_SHVIEWFIRST/LAST (otherwise, the explorer
// won't dispatch them). The view should not deal with any menuitems
// in FCIDM_BROWSERFIRST/LAST (otherwise, it won't work with the future
// version of the shell).
//
//  FCIDM_SHVIEWFIRST/LAST      for the right pane (IShellView)
//  FCIDM_BROWSERFIRST/LAST     for the explorer frame (IShellBrowser)
//  FCIDM_GLOBAL/LAST           for the explorer's submenu IDs
//
//--------------------------------------------------------------------------

#define FCIDM_SHVIEWFIRST           0x0000
#define FCIDM_SHVIEWLAST            0x7fff
#define FCIDM_BROWSERFIRST          0xa000
#define FCIDM_BROWSERLAST           0xbf00
#define FCIDM_GLOBALFIRST           0x8000
#define FCIDM_GLOBALLAST            0x9fff

//
// Global submenu IDs and separator IDs
//
#define FCIDM_MENU_FILE             (FCIDM_GLOBALFIRST+0x0000)
#define FCIDM_MENU_EDIT             (FCIDM_GLOBALFIRST+0x0040)
#define FCIDM_MENU_VIEW             (FCIDM_GLOBALFIRST+0x0080)
#define FCIDM_MENU_VIEW_SEP_OPTIONS (FCIDM_GLOBALFIRST+0x0081)
#define FCIDM_MENU_TOOLS            (FCIDM_GLOBALFIRST+0x00c0)
#define FCIDM_MENU_TOOLS_SEP_GOTO   (FCIDM_GLOBALFIRST+0x00c1)
#define FCIDM_MENU_HELP             (FCIDM_GLOBALFIRST+0x0100)
#define FCIDM_MENU_FIND             (FCIDM_GLOBALFIRST+0x0140)
#define FCIDM_MENU_EXPLORE          (FCIDM_GLOBALFIRST+0x0150)
#define FCIDM_MENU_FAVORITES        (FCIDM_GLOBALFIRST+0x0170)

//--------------------------------------------------------------------------
// control IDs known to the view
//--------------------------------------------------------------------------

#define FCIDM_TOOLBAR      (FCIDM_BROWSERFIRST + 0)
#define FCIDM_STATUS       (FCIDM_BROWSERFIRST + 1)


//--------------------------------------------------------------------------
//
// FOLDERSETTINGS
//
//  FOLDERSETTINGS is a data structure that explorer passes from one folder
// view to another, when the user is browsing. It calls ISV::GetCurrentInfo
// member to get the current settings and pass it to ISV::CreateViewWindow
// to allow the next folder view "inherit" it. These settings assumes a
// particular UI (which the shell's folder view has), and shell extensions
// may or may not use those settings.
//
//--------------------------------------------------------------------------

typedef LPBYTE LPVIEWSETTINGS;

// NB Bitfields.
// FWF_DESKTOP implies FWF_TRANSPARENT/NOCLIENTEDGE/NOSCROLL
typedef enum
    {
    FWF_AUTOARRANGE =       0x0001,
    FWF_ABBREVIATEDNAMES =  0x0002,
    FWF_SNAPTOGRID =        0x0004,
    FWF_OWNERDATA =         0x0008,
    FWF_BESTFITWINDOW =     0x0010,
    FWF_DESKTOP =           0x0020,
    FWF_SINGLESEL =         0x0040,
    FWF_NOSUBFOLDERS =      0x0080,
    FWF_TRANSPARENT  =      0x0100,
    FWF_NOCLIENTEDGE =      0x0200,
    FWF_NOSCROLL     =      0x0400,
    FWF_ALIGNLEFT    =      0x0800,
    FWF_NOICONS      =      0x1000,
    FWF_SINGLECLICKACTIVATE=0x8000  // TEMPORARY -- NO UI FOR THIS
    } FOLDERFLAGS;

typedef enum
    {
    FVM_ICON =              1,
    FVM_SMALLICON =         2,
    FVM_LIST =              3,
    FVM_DETAILS =           4,
    } FOLDERVIEWMODE;

typedef struct
    {
    UINT ViewMode;       // View mode (FOLDERVIEWMODE values)
    UINT fFlags;         // View options (FOLDERFLAGS bits)
    } FOLDERSETTINGS, *LPFOLDERSETTINGS;

typedef const FOLDERSETTINGS * LPCFOLDERSETTINGS;


//--------------------------------------------------------------------------
//
// Interface:   IShellBrowser
//
//  IShellBrowser interface is the interface that is provided by the shell
// explorer/folder frame window. When it creates the "contents pane" of
// a shell folder (which provides IShellFolder interface), it calls its
// CreateViewObject member function to create an IShellView object. Then,
// it calls its CreateViewWindow member to create the "contents pane"
// window. The pointer to the IShellBrowser interface is passed to
// the IShellView object as a parameter to this CreateViewWindow member
// function call.
//
//    +--------------------------+  <-- Explorer window
//    | [] Explorer              |
//    |--------------------------+       IShellBrowser
//    | File Edit View ..        |
//    |--------------------------|
//    |        |                 |
//    |        |              <-------- Content pane
//    |        |                 |
//    |        |                 |       IShellView
//    |        |                 |
//    |        |                 |
//    +--------------------------+
//
//
//
// [Member functions]
//
//
// IShellBrowser::GetWindow(phwnd)
//
//   Inherited from IOleWindow::GetWindow.
//
//
// IShellBrowser::ContextSensitiveHelp(fEnterMode)
//
//   Inherited from IOleWindow::ContextSensitiveHelp.
//
//
// IShellBrowser::InsertMenusSB(hmenuShared, lpMenuWidths)
//
//   Similar to the IOleInPlaceFrame::InsertMenus. The explorer will put
//  "File" and "Edit" pulldown in the File menu group, "View" and "Tools"
//  in the Container menu group and "Help" in the Window menu group. Each
//  pulldown menu will have a uniqu ID, FCIDM_MENU_FILE/EDIT/VIEW/TOOLS/HELP.
//  The view is allowed to insert menuitems into those sub-menus by those
//  IDs must be between FCIDM_SHVIEWFIRST and FCIDM_SHVIEWLAST.
//
//
// IShellBrowser::SetMenuSB(hmenuShared, holemenu, hwndActiveObject)
//
//   Similar to the IOleInPlaceFrame::SetMenu. The explorer ignores the
//  holemenu parameter (reserved for future enhancement)  and performs
//  menu-dispatch based on the menuitem IDs (see the description above).
//  It is important to note that the explorer will add different
//  set of menuitems depending on whether the view has a focus or not.
//  Therefore, it is very important to call ISB::OnViewWindowActivate
//  whenever the view window (or its children) gets the focus.
//
//
// IShellBrowser::RemoveMenusSB(hmenuShared)
//
//   Same as the IOleInPlaceFrame::RemoveMenus.
//
//
// IShellBrowser::SetStatusTextSB(lpszStatusText)
//
//   Same as the IOleInPlaceFrame::SetStatusText. It is also possible to
//  send messages directly to the status window via SendControlMsg.
//
//
// IShellBrowser::EnableModelessSB(fEnable)
//
//   Same as the IOleInPlaceFrame::EnableModeless.
//
//
// IShellBrowser::TranslateAcceleratorSB(lpmsg, wID)
//
//   Same as the IOleInPlaceFrame::TranslateAccelerator, but will be
//  never called because we don't support EXEs (i.e., the explorer has
//  the message loop). This member function is defined here for possible
//  future enhancement.
//
//
// IShellBrowser::BrowseObject(pidl, wFlags)
//
//   The view calls this member to let shell explorer browse to another
//  folder. The pidl and wFlags specifies the folder to be browsed.
//
//  Following three flags specifies whether it creates another window or not.
//   SBSP_SAMEBROWSER  -- Browse to another folder with the same window.
//   SBSP_NEWBROWSER   -- Creates another window for the specified folder.
//   SBSP_DEFBROWSER   -- Default behavior (respects the view option).
//
//  Following three flags specifies open, explore, or default mode. These   .
//  are ignored if SBSP_SAMEBROWSER or (SBSP_DEFBROWSER && (single window   .
//  browser || explorer)).                                                  .
//   SBSP_OPENMODE     -- Use a normal folder window
//   SBSP_EXPLOREMODE  -- Use an explorer window
//   SBSP_DEFMODE      -- Use the same as the current window
//
//  Following three flags specifies the pidl.
//   SBSP_ABSOLUTE -- pidl is an absolute pidl (relative from desktop)
//   SBSP_RELATIVE -- pidl is relative from the current folder.
//   SBSP_PARENT   -- Browse the parent folder (ignores the pidl)
//   SBSP_NAVIGATEBACK    -- Navigate back (ignores the pidl)
//   SBSP_NAVIGATEFORWARD -- Navigate forward (ignores the pidl)
//
//
// IShellBrowser::GetViewStateStream(grfMode, ppstm)
//
//   The browser returns an IStream interface as the storage for view
//  specific state information.
//
//   grfMode -- Specifies the read/write access (STGM_READ/WRITE/READWRITE)
//   ppstm   -- Specifies the LPSTREAM variable to be filled.
//
//
// IShellBrowser::GetControlWindow(id, phwnd)
//
//   The shell view may call this member function to get the window handle
//  of Explorer controls (toolbar or status winodw -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::SendControlMsg(id, uMsg, wParam, lParam, pret)
//
//   The shell view calls this member function to send control messages to
//  one of Explorer controls (toolbar or status window -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::QueryActiveShellView(IShellView * ppshv)
//
//   This member returns currently activated (displayed) shellview object.
//  A shellview never need to call this member function.
//
//
// IShellBrowser::OnViewWindowActive(pshv)
//
//   The shell view window calls this member function when the view window
//  (or one of its children) got the focus. It MUST call this member before
//  calling IShellBrowser::InsertMenus, because it will insert different
//  set of menu items depending on whether the view has the focus or not.
//
//
// IShellBrowser::SetToolbarItems(lpButtons, nButtons, uFlags)
//
//   The view calls this function to add toolbar items to the exporer's
//  toolbar. "lpButtons" and "nButtons" specifies the array of toolbar
//  items. "uFlags" must be one of FCT_MERGE, FCT_CONFIGABLE, FCT_ADDTOEND.
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   IShellBrowser

//
// Values for wFlags parameter of ISB::BrowseObject() member.
//
#define SBSP_DEFBROWSER         0x0000
#define SBSP_SAMEBROWSER        0x0001
#define SBSP_NEWBROWSER         0x0002

#define SBSP_DEFMODE            0x0000
#define SBSP_OPENMODE           0x0010
#define SBSP_EXPLOREMODE        0x0020

#define SBSP_ABSOLUTE           0x0000
#define SBSP_RELATIVE           0x1000
#define SBSP_PARENT             0x2000
#define SBSP_NAVIGATEBACK       0x4000
#define SBSP_NAVIGATEFORWARD    0x8000

#define SBSP_ALLOW_AUTONAVIGATE 0x10000

#define SBSP_INITIATEDBYHLINKFRAME        0x80000000
#define SBSP_REDIRECT                     0x40000000

//
// Values for id parameter of ISB::GetWindow/SendControlMsg members.
//
// WARNING:
//  Any shell extensions which sends messages to those control windows
// might not work in the future version of windows. If you really need
// to send messages to them, (1) don't assume that those control window
// always exist (i.e. GetControlWindow may fail) and (2) verify the window
// class of the window before sending any messages.
//
#define FCW_STATUS      0x0001
#define FCW_TOOLBAR     0x0002
#define FCW_TREE        0x0003
#define FCW_INTERNETBAR 0x0006

//
// Values for uFlags paremeter of ISB::SetToolbarItems member.
//
#define FCT_MERGE       0x0001
#define FCT_CONFIGABLE  0x0002
#define FCT_ADDTOEND    0x0004


DECLARE_INTERFACE_(IShellBrowser, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB) (THIS_ HMENU hmenuShared,
                                LPOLEMENUGROUPWIDTHS lpMenuWidths) PURE;
    STDMETHOD(SetMenuSB) (THIS_ HMENU hmenuShared, HOLEMENU holemenuReserved,
                HWND hwndActiveObject) PURE;
    STDMETHOD(RemoveMenusSB) (THIS_ HMENU hmenuShared) PURE;
    STDMETHOD(SetStatusTextSB) (THIS_ LPCOLESTR lpszStatusText) PURE;
    STDMETHOD(EnableModelessSB) (THIS_ BOOL fEnable) PURE;
    STDMETHOD(TranslateAcceleratorSB) (THIS_ LPMSG lpmsg, WORD wID) PURE;

    // *** IShellBrowser methods ***
    STDMETHOD(BrowseObject)(THIS_ LPCITEMIDLIST pidl, UINT wFlags) PURE;
    STDMETHOD(GetViewStateStream)(THIS_ DWORD grfMode,
                LPSTREAM  *ppStrm) PURE;
    STDMETHOD(GetControlWindow)(THIS_ UINT id, HWND * lphwnd) PURE;
    STDMETHOD(SendControlMsg)(THIS_ UINT id, UINT uMsg, WPARAM wParam,
                LPARAM lParam, LRESULT * pret) PURE;
    STDMETHOD(QueryActiveShellView)(THIS_ struct IShellView ** ppshv) PURE;
    STDMETHOD(OnViewWindowActive)(THIS_ struct IShellView * ppshv) PURE;
    STDMETHOD(SetToolbarItems)(THIS_ LPTBBUTTON lpButtons, UINT nButtons,
                UINT uFlags) PURE;
};
#define __IShellBrowser_INTERFACE_DEFINED__

typedef IShellBrowser * LPSHELLBROWSER;

enum {
    SBSC_HIDE = 0,
    SBSC_SHOW = 1,
    SBSC_TOGGLE = 2,
    SBSC_QUERY =  3
};

enum {
        SBO_DEFAULT = 0 ,
        SBO_NOBROWSERPAGES = 1
};
#endif //0

#if 0 // Now SHLOBJP has this
// CGID_Explorer Command Target IDs
enum {
    SBCMDID_ENABLESHOWTREE          = 0,
    SBCMDID_SHOWCONTROL             = 1,        // variant vt_i4 = loword = FCW_ * hiword = SBSC_*
    SBCMDID_CANCELNAVIGATION        = 2,        // cancel last navigation
    SBCMDID_MAYSAVECHANGES          = 3,        // about to close and may save changes
    SBCMDID_SETHLINKFRAME           = 4,        // variant vt_i4 = phlinkframe
    SBCMDID_ENABLESTOP              = 5,        // variant vt_bool = fEnable
    SBCMDID_OPTIONS                 = 6,        // the view.options page
    SBCMDID_EXPLORER                = 7,        // are you explorer.exe?
    SBCMDID_ADDTOFAVORITES          = 8,
    SBCMDID_ACTIVEOBJECTMENUS       = 9,
    SBCMDID_MAYSAVEVIEWSTATE        = 10,       // Should we save view stream
    SBCMDID_DOFAVORITESMENU         = 11,       // popup the favorites menu
    SBCMDID_DOMAILMENU              = 12,       // popup the mail menu
    SBCMDID_GETADDRESSBARTEXT       = 13,       // get user-typed text
    SBCMDID_ASYNCNAVIGATION         = 14,       // do an async navigation
    SBCMDID_SEARCHBAR               = 15,       // toggle SearchBar browserbar
    SBCMDID_FLUSHOBJECTCACHE        = 16,       // flush object cache
    SBCMDID_CREATESHORTCUT          = 17,       // create a shortcut
};
#endif


#if 0    // Now SHLOBJ has this

//
// uState values for IShellView::UIActivate
//
typedef enum {
    SVUIA_DEACTIVATE       = 0,
    SVUIA_ACTIVATE_NOFOCUS = 1,
    SVUIA_ACTIVATE_FOCUS   = 2,
    SVUIA_INPLACEACTIVATE  = 3          // new flag for IShellView2
} SVUIA_STATUS;

DECLARE_INTERFACE_(IShellView, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellView methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;
#ifdef _FIX_ENABLEMODELESS_CONFLICT
    STDMETHOD(EnableModelessSV) (THIS_ BOOL fEnable) PURE;
#else
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
#endif
    STDMETHOD(UIActivate) (THIS_ UINT uState) PURE;
    STDMETHOD(Refresh) (THIS) PURE;

    STDMETHOD(CreateViewWindow)(THIS_ IShellView  *lpPrevView,
                    LPCFOLDERSETTINGS lpfs, IShellBrowser  * psb,
                    RECT * prcView, HWND  *phWnd) PURE;
    STDMETHOD(DestroyViewWindow)(THIS) PURE;
    STDMETHOD(GetCurrentInfo)(THIS_ LPFOLDERSETTINGS lpfs) PURE;
    STDMETHOD(AddPropertySheetPages)(THIS_ DWORD dwReserved,
                    LPFNADDPROPSHEETPAGE lpfn, LPARAM lparam) PURE;
    STDMETHOD(SaveViewState)(THIS) PURE;
    STDMETHOD(SelectItem)(THIS_ LPCITEMIDLIST pidlItem, UINT uFlags) PURE;
    STDMETHOD(GetItemObject)(THIS_ UINT uItem, REFIID riid,
                    LPVOID *ppv) PURE;
};

typedef IShellView *    LPSHELLVIEW;
#endif //0

#define CFSTR_FILEDESCRIPTORA   TEXT("FileGroupDescriptor")     // CF_FILEGROUPDESCRIPTORA
#define CFSTR_FILECONTENTS      TEXT("FileContents")            // CF_FILECONTENTS

#if 0    // Now SHLOBJ has this
//
// FILEDESCRIPTOR.dwFlags field indicate which fields are to be used
//
typedef enum {
    FD_CLSID            = 0x0001,
    FD_SIZEPOINT        = 0x0002,
    FD_ATTRIBUTES       = 0x0004,
    FD_CREATETIME       = 0x0008,
    FD_ACCESSTIME       = 0x0010,
    FD_WRITESTIME       = 0x0020,
    FD_FILESIZE         = 0x0040,
    FD_LINKUI           = 0x8000,       // 'link' UI is prefered
} FD_FLAGS;

typedef struct _FILEDESCRIPTORA { // fod
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    CHAR   cFileName[ MAX_PATH ];
} FILEDESCRIPTORA, *LPFILEDESCRIPTORA;

#define FILEDESCRIPTOR      FILEDESCRIPTORA
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORA

//
// format of CF_FILEGROUPDESCRIPTOR
//
typedef struct _FILEGROUPDESCRIPTORA { // fgd
     UINT cItems;
     FILEDESCRIPTORA fgd[1];
} FILEGROUPDESCRIPTORA, * LPFILEGROUPDESCRIPTORA;

#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORA
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORA
#endif //0

#endif //_SHLOBJ_H_

/*****************************************************************************\
*                                                                             *
*  From shlobjp.h(private\windows\inc)
*                                                                             *
\*****************************************************************************/

#if 0 // Now SHLOBJP has this
void   WINAPI SHFree(LPVOID pv);
#endif


/*****************************************************************************
 *
 *  From wtypes.h(INC16)
 *
 *****************************************************************************/

typedef unsigned short VARTYPE;

typedef LONG SCODE;

/* 0 == FALSE, -1 == TRUE */
typedef short VARIANT_BOOL;

#ifndef _LPCOLORREF_DEFINED
#define _LPCOLORREF_DEFINED
typedef DWORD __RPC_FAR *LPCOLORREF;

#endif // !_LPCOLORREF_DEFINED


/*****************************************************************************\
 *
 *  From objidl.h(INC32) and it should be added into "objidl.h"(INC16) file.
 *
\*****************************************************************************/

//#ifdef __objidl_h__

/*****************************************************************************\
*                                                                             *
*  From imm.h(INC32)
*                                                                             *
\*****************************************************************************/

typedef UINT FAR *LPUINT;


/*****************************************************************************\
*                                                                             *
*  From comctlie.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/

#ifdef _INC_COMCTLIE

#define EM_SETLIMITTEXT         EM_LIMITTEXT

// From winuser.h
#define IMAGE_BITMAP 0
#define IMAGE_ICON          1
#define IMAGE_CURSOR        2

#define     ImageList_LoadBitmap(hi, lpbmp, cx, cGrow, crMask) ImageList_LoadImage(hi, lpbmp, cx, cGrow, crMask, IMAGE_BITMAP, 0)

#if 0    // Now COMCTLIE has this
typedef struct {
    HKEY hkr;
    LPCSTR pszSubKey;
    LPCSTR pszValueName;
} TBSAVEPARAMS;
#endif

#define PNM_FINDITEM    LPNMLVFINDITEM

#define PNM_ODSTATECHANGE   LPNMLVODSTATECHANGE


#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG


#define ACM_OPENA               (WM_USER+100)

#define ACM_OPEN                ACM_OPENA

#define ACM_PLAY                (WM_USER+101)
#define ACM_STOP                (WM_USER+102)


#define ACN_START               1
#define ACN_STOP                2

#define Animate_Open(hwnd, szName)          (BOOL)SNDMSG(hwnd, ACM_OPEN, 0, (LPARAM)(LPTSTR)(szName))
#define Animate_Play(hwnd, from, to, rep)   (BOOL)SNDMSG(hwnd, ACM_PLAY, (WPARAM)(UINT)(rep), (LPARAM)MAKELONG(from, to))
#define Animate_Stop(hwnd)                  (BOOL)SNDMSG(hwnd, ACM_STOP, 0, 0)
#define Animate_Close(hwnd)                 Animate_Open(hwnd, NULL)

#if 0    // Now COMCTLIE has this

#define CBEN_FIRST              (0U-800U)       // combo box ex
#define CBEN_LAST               (0U-830U)


////////////////////  ComboBoxEx ////////////////////////////////


#define WC_COMBOBOXEXW         L"ComboBoxEx32"
#define WC_COMBOBOXEXA         "ComboBoxEx32"

#ifdef UNICODE
#define WC_COMBOBOXEX          WC_COMBOBOXEXW
#else
#define WC_COMBOBOXEX          WC_COMBOBOXEXA
#endif


#define CBEIF_TEXT              0x00000001
#define CBEIF_IMAGE             0x00000002
#define CBEIF_SELECTEDIMAGE     0x00000004
#define CBEIF_OVERLAY           0x00000008
#define CBEIF_INDENT            0x00000010
#define CBEIF_LPARAM            0x00000020

#define CBEIF_DI_SETITEM        0x10000000

typedef struct tagCOMBOBOXEXITEMA
{
    UINT mask;
    int iItem;
    LPSTR pszText;
    int cchTextMax;
    int iImage;
    int iSelectedImage;
    int iOverlay;
    int iIndent;
    LPARAM lParam;
} COMBOBOXEXITEMA, *PCOMBOBOXEXITEMA;
typedef COMBOBOXEXITEMA CONST *PCCOMBOEXITEMA;

typedef struct tagCOMBOBOXEXITEMW
{
    UINT mask;
    int iItem;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
    int iSelectedImage;
    int iOverlay;
    int iIndent;
    LPARAM lParam;
} COMBOBOXEXITEMW, *PCOMBOBOXEXITEMW;
typedef COMBOBOXEXITEMW CONST *PCCOMBOEXITEMW;

#ifdef UNICODE
#define COMBOBOXEXITEM            COMBOBOXEXITEMW
#define PCOMBOBOXEXITEM           PCOMBOBOXEXITEMW
#define PCCOMBOBOXEXITEM          PCCOMBOBOXEXITEMW
#else
#define COMBOBOXEXITEM            COMBOBOXEXITEMA
#define PCOMBOBOXEXITEM           PCOMBOBOXEXITEMA
#define PCCOMBOBOXEXITEM          PCCOMBOBOXEXITEMA
#endif

#define CBEM_INSERTITEMA        (WM_USER + 1)
#define CBEM_SETIMAGELIST       (WM_USER + 2)
#define CBEM_GETIMAGELIST       (WM_USER + 3)
#define CBEM_GETITEMA           (WM_USER + 4)
#define CBEM_SETITEMA           (WM_USER + 5)
#define CBEM_DELETEITEM         CB_DELETESTRING
#define CBEM_GETCOMBOCONTROL    (WM_USER + 6)
#define CBEM_GETEDITCONTROL     (WM_USER + 7)
#if (_WIN32_IE >= 0x0400)
#define CBEM_SETEXSTYLE         (WM_USER + 8)  // use  SETEXTENDEDSTYLE instead
#define CBEM_SETEXTENDEDSTYLE   (WM_USER + 14)   // lparam == new style, wParam (optional) == mask
#define CBEM_GETEXSTYLE         (WM_USER + 9) // use GETEXTENDEDSTYLE instead
#define CBEM_GETEXTENDEDSTYLE   (WM_USER + 9)
#else
#define CBEM_SETEXSTYLE         (WM_USER + 8)
#define CBEM_GETEXSTYLE         (WM_USER + 9)
#endif
#define CBEM_HASEDITCHANGED     (WM_USER + 10)
#define CBEM_INSERTITEMW        (WM_USER + 11)
#define CBEM_SETITEMW           (WM_USER + 12)
#define CBEM_GETITEMW           (WM_USER + 13)

#ifdef UNICODE
#define CBEM_INSERTITEM         CBEM_INSERTITEMW
#define CBEM_SETITEM            CBEM_SETITEMW
#define CBEM_GETITEM            CBEM_GETITEMW
#else
#define CBEM_INSERTITEM         CBEM_INSERTITEMA
#define CBEM_SETITEM            CBEM_SETITEMA
#define CBEM_GETITEM            CBEM_GETITEMA
#endif

#define CBES_EX_NOEDITIMAGE          0x00000001
#define CBES_EX_NOEDITIMAGEINDENT    0x00000002
#define CBES_EX_PATHWORDBREAKPROC    0x00000004
#if (_WIN32_IE >= 0x0400)
#define CBES_EX_NOSIZELIMIT          0x00000008
#define CBES_EX_CASESENSITIVE        0x00000010

typedef struct {
    NMHDR hdr;
    COMBOBOXEXITEMA ceItem;
} NMCOMBOBOXEXA, *PNMCOMBOBOXEXA;

typedef struct {
    NMHDR hdr;
    COMBOBOXEXITEMW ceItem;
} NMCOMBOBOXEXW, *PNMCOMBOBOXEXW;

#ifdef UNICODE
#define NMCOMBOBOXEX            NMCOMBOBOXEXW
#define PNMCOMBOBOXEX           PNMCOMBOBOXEXW
#define CBEN_GETDISPINFO CBEN_GETDISPINFOW
#else
#define NMCOMBOBOXEX            NMCOMBOBOXEXA
#define PNMCOMBOBOXEX           PNMCOMBOBOXEXA
#define CBEN_GETDISPINFO CBEN_GETDISPINFOA
#endif

#else
typedef struct {
    NMHDR hdr;
    COMBOBOXEXITEM ceItem;
} NMCOMBOBOXEX, *PNMCOMBOBOXEX;

#define CBEN_GETDISPINFO         (CBEN_FIRST - 0)

#endif      // _WIN32_IE

#define CBEN_GETDISPINFOA        (CBEN_FIRST - 0)
#define CBEN_INSERTITEM         (CBEN_FIRST - 1)
#define CBEN_DELETEITEM         (CBEN_FIRST - 2)
#define CBEN_BEGINEDIT          (CBEN_FIRST - 4)
#define CBEN_ENDEDITA            (CBEN_FIRST - 5)
#define CBEN_ENDEDITW            (CBEN_FIRST - 6)
#define CBEN_GETDISPINFOW        (CBEN_FIRST - 7)

        // lParam specifies why the endedit is happening
#ifdef UNICODE
#define CBEN_ENDEDIT CBEN_ENDEDITW
#else
#define CBEN_ENDEDIT CBEN_ENDEDITA
#endif

#define CBENF_KILLFOCUS         1
#define CBENF_RETURN            2
#define CBENF_ESCAPE            3
#define CBENF_DROPDOWN          4

#define CBEMAXSTRLEN 260

#endif //0

#if 0
#define TTN_NEEDTEXTW      TTN_NEEDTEXT
#endif

// Copied from ..\inc\commctrl.h
#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG

#if 0    // Now COMCTLIE has this

#define DTN_FIRST               (0U-760U)       // datetimepick
#define DTN_LAST                (0U-799U)

#define DTN_DATETIMECHANGE  (DTN_FIRST + 1) // the systemtime has changed
typedef struct tagNMDATETIMECHANGE
{
    NMHDR       nmhdr;
    DWORD       dwFlags;    // GDT_VALID or GDT_NONE
    SYSTEMTIME  st;         // valid iff dwFlags==GDT_VALID
} NMDATETIMECHANGE, FAR * LPNMDATETIMECHANGE;

#define GDT_ERROR    -1
#define GDT_VALID    0
#define GDT_NONE     1

#define DTM_FIRST        0x1000

#define DTM_GETSYSTEMTIME   (DTM_FIRST + 1)
#define DateTime_GetSystemtime(hdp, pst)    (DWORD)SNDMSG(hdp, DTM_GETSYSTEMTIME, 0, (LPARAM)(pst))

#define DTM_SETSYSTEMTIME   (DTM_FIRST + 2)
#define DateTime_SetSystemtime(hdp, gd, pst)    (BOOL)SNDMSG(hdp, DTM_SETSYSTEMTIME, (LPARAM)(gd), (LPARAM)(pst))

#endif //0

#define TCS_BOTTOM   0     // 0x0002 - Not supported in Win16
#endif //_INC_COMCTLIE

/*****************************************************************************\
*                                                                             *
*  From wingdi.h(INC32)
*                                                                             *
\*****************************************************************************/

#define GB2312_CHARSET          134
#define JOHAB_CHARSET           130
#define HEBREW_CHARSET          177
#define ARABIC_CHARSET          178
#define GREEK_CHARSET           161
#define TURKISH_CHARSET         162
#define VIETNAMESE_CHARSET      163
#define THAI_CHARSET            222
#define EASTEUROPE_CHARSET      238
#define RUSSIAN_CHARSET         204

#define MAC_CHARSET             77
#define BALTIC_CHARSET          186

//LOGFONGA is defined as LOGFONT in Win16x.h
#undef  LOGFONTA

typedef struct tagLOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    CHAR      lfFaceName[LF_FACESIZE];
} LOGFONTA, *PLOGFONTA, NEAR *NPLOGFONTA, FAR *LPLOGFONTA;

typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[LF_FULLFACESIZE];
    BYTE        elfStyle[LF_FACESIZE];
    BYTE        elfScript[LF_FACESIZE];
} ENUMLOGFONTEXA, FAR *LPENUMLOGFONTEXA;

typedef ENUMLOGFONTEXA ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX;


typedef struct tagNEWTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA, NEAR *NPNEWTEXTMETRICA, FAR *LPNEWTEXTMETRICA;

typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE,FAR *LPFONTSIGNATURE;

typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXA;

typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;


typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO, NEAR *NPCHARSETINFO, FAR *LPCHARSETINFO;

#define TCI_SRCCHARSET  1
#define TCI_SRCCODEPAGE 2
#define TCI_SRCFONTSIG  3

BOOL WINAPI TranslateCharsetInfo( DWORD FAR *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);

#ifdef GetObject
#undef GetObject
#undef DeleteObject
#undef StretchBlt
#endif

#define GetTextExtentPoint32     GetTextExtentPoint

/*****************************************************************************\
*                                                                             *
*  From winuser.h - It should be in the (win16x.h)INC16
*                                                                             *
\*****************************************************************************/

/*
 * lParam of WM_COPYDATA message points to...
 */
typedef struct tagCOPYDATASTRUCT {
    DWORD dwData;
    DWORD cbData;
    PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;

#define WM_COPYDATA                     0x004A
#define WM_HELP                         0x0053

#define WM_CTLCOLORSTATIC               0x0138

#define RegisterWindowMessageA  RegisterWindowMessage

#define SendDlgItemMessageA SendDlgItemMessage
/*
 * WM_SETICON / WM_GETICON Type Codes
 */
#define ICON_SMALL          0
#define ICON_BIG            1

/*
 * Predefined Clipboard Formats
 */
#define CF_HDROP            15

//#define WS_EX_CONTROLPARENT     0x00010000L
#define WS_EX_CONTROLPARENT     0x00000000L  // this is not valid on Win16

#define WM_GETICON                      0x007F
#define WM_SETICON                      0x0080
#define WM_WININICHANGE                 0x001A
#define WM_SETTINGCHANGE                WM_WININICHANGE


#define SM_CXEDGE               45
#define SM_CYEDGE               46

#define LR_DEFAULTCOLOR     0x0000
#define LR_LOADFROMFILE     0x0010
#define LR_LOADTRANSPARENT  0x0020
#define LR_DEFAULTSIZE      0x0040
#define LR_LOADMAP3DCOLORS  0x1000
#define LR_CREATEDIBSECTION 0x2000

BOOL
WINAPI
EnumThreadWindows(
    DWORD dwThreadId,
    WNDENUMPROC lpfn,
    LPARAM lParam);

typedef struct tagNONCLIENTMETRICSA
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONT lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONT lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONT lfMenuFont;
    LOGFONT lfStatusFont;
    LOGFONT lfMessageFont;
}   NONCLIENTMETRICSA, *PNONCLIENTMETRICSA, FAR* LPNONCLIENTMETRICSA;

typedef NONCLIENTMETRICSA NONCLIENTMETRICS;


int
WINAPI
DrawTextEx(
    HDC hdc,
    LPCSTR lpsz,
    int cb,
    LPRECT lprc,
    UINT fuFormat,
    LPVOID lpDTP );

#define DI_MASK         0x0001
#define DI_IMAGE        0x0002
#define DI_NORMAL       0x0003
#define DI_DEFAULTSIZE  0x0008

BOOL
WINAPI
DrawIconEx(
    HDC hdc,
    int xLeft,
    int yTop,
    HICON hIcon,
    int cxWidth,
    int cyWidth,
    UINT istepIfAniCur,
    HBRUSH hbrFlickerFreeDraw,
    UINT diFlags );


HANDLE
WINAPI
LoadImageA(
    HINSTANCE,
    LPCSTR,
    UINT,
    int,
    int,
    UINT);

#define LoadImage  LoadImageA

BOOL
WINAPI
PostThreadMessageA(
    DWORD idThread,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

#define PostThreadMessage  PostThreadMessageA

#define BN_SETFOCUS         6
#define BN_KILLFOCUS        7

#define BM_GETIMAGE        0x00F6
#define BM_SETIMAGE        0x00F7

#define BST_UNCHECKED      0x0000
//#define BST_CHECKED        0x0001    // defined in WIN16X
#define BST_INDETERMINATE  0x0002
#define BST_PUSHED         0x0004
#define BST_FOCUS          0x0008

typedef struct tagTPMPARAMS
{
    UINT    cbSize;     /* Size of structure */
    RECT    rcExclude;  /* Screen coordinates of rectangle to exclude when positioning */
}   TPMPARAMS;
typedef TPMPARAMS FAR *LPTPMPARAMS;

BOOL
WINAPI
TrackPopupMenuEx(
    HMENU hMenu,
    UINT fuFlags,
    int x,
    int y,
    HWND hwnd,
    LPTPMPARAMS lptpm);

/*
 * Flags for TrackPopupMenu
 */
#define MB_SETFOREGROUND            0     // 0x00010000L - Not supported in Win16
#define MB_DEFAULT_DESKTOP_ONLY     0x00020000L

#define TPM_TOPALIGN        0x0000L
#define TPM_VCENTERALIGN    0x0010L
#define TPM_BOTTOMALIGN     0x0020L

#define TPM_HORIZONTAL      0x0000L     /* Horz alignment matters more */
#define TPM_VERTICAL        0x0040L     /* Vert alignment matters more */
#define TPM_NONOTIFY        0x0080L     /* Don't send any notification msgs */
#define TPM_RETURNCMD       0x0100L

#define DS_SETFOREGROUND    0x0200L     // Not supported in Win16
#define DS_3DLOOK           0x0004L     // Not supported in Win16
#define DS_CONTROL          0x0400L     // Not supported in Win16
#define DS_CENTER           0x0800L     // Not supported in Win16
#define DS_CONTEXTHELP      0x2000L     // Not supported in Win16

#define SS_BITMAP           0x0000000EL // Not supported in Win16
#define SS_ETCHEDHORZ       0x00000010L // Not supported in Win16
#define SS_NOTIFY           0x00000100L // Not supported in Win16
#define SS_CENTERIMAGE      0x00000200L // Not supported in Win16
#define SS_REALSIZEIMAGE    0x00000800L // Not supported in Win16
#define SS_SUNKEN           0x00001000L // Not supported in Win16

#define BS_ICON         0     // 0x00000040L - Not supported in Win16
#define BS_PUSHLIKE     0     // 0x00001000L - Not supported in Win16
#define BS_MULTILINE    0     // 0x00002000L - Not supported in Win16

#define ES_NUMBER       0     // 0x2000L - Not supported in Win16

#ifndef NOWINMESSAGES
/*
 * Static Control Mesages
 */
// #define STM_SETICON         0x0170
// #define STM_GETICON         0x0171
#if(WINVER >= 0x0400)
#define STM_SETIMAGE        0x0172
#define STM_GETIMAGE        0x0173
#define STN_CLICKED         0
#define STN_DBLCLK          1
#define STN_ENABLE          2
#define STN_DISABLE         3
#endif /* WINVER >= 0x0400 */
#define STM_MSGMAX          0x0174
#endif /* !NOWINMESSAGES */

#define HELP_FINDER       0x000b

#ifndef NOWINSTYLES

// begin_r_winuser

/*
 * Scroll Bar Styles
 */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L
#define SBS_SIZEGRIP                0x0010L

// end_r_winuser

//#define CharNextA  AnsiNext    // defined in WIN16X
#define CharNextW  AnsiNext

#endif /* !NOWINSTYLES */

/*****************************************************************************\
*                                                                             *
*  From winnls.h(INC32) - It should be in the (win16x.h)INC16
*                                                                             *
\*****************************************************************************/

//
//  String Length Maximums.
//
#define MAX_LEADBYTES             12          // 5 ranges, 2 bytes ea., 0 term.
#define MAX_DEFAULTCHAR           2           // single or double byte

#define GetDateFormat GetDateFormatA
#define GetTimeFormat GetTimeFormatA

//
//  CP Info.
//

typedef struct _cpinfo {
    UINT    MaxCharSize;                    // max length (in bytes) of a char
    BYTE    DefaultChar[MAX_DEFAULTCHAR];   // default character
    BYTE    LeadByte[MAX_LEADBYTES];        // lead byte ranges
} CPINFO, *LPCPINFO;

BOOL
WINAPI
IsValidCodePage(
    UINT  CodePage);

BOOL
WINAPI
GetCPInfo(
    UINT      CodePage,
    LPCPINFO  lpCPInfo);

BOOL
WINAPI
IsDBCSLeadByteEx(
    UINT  CodePage,
    BYTE  TestChar);

//
//  MBCS and Unicode Translation Flags.
//
#define MB_PRECOMPOSED            0x00000001  // use precomposed chars
#define MB_COMPOSITE              0x00000002  // use composite chars
#define MB_USEGLYPHCHARS          0x00000004  // use glyph chars, not ctrl chars
#define MB_ERR_INVALID_CHARS      0x00000008  // error for invalid chars

#define WC_COMPOSITECHECK         0x00000200  // convert composite to precomposed
#define WC_DISCARDNS              0x00000010  // discard non-spacing chars
#define WC_SEPCHARS               0x00000020  // generate separate chars
#define WC_DEFAULTCHAR            0x00000040  // replace w/ default char

/*****************************************************************************\
*                                                                             *
*  From wincrypt.h(INC32)
*                                                                             *
\*****************************************************************************/

#define _WIN32_WINNT  0x0400     // temp until we got 16bit wincrypt.h
#define WINADVAPI                // temp until we got 16bit wincrypt.h
#define _CRYPT32_
#include "wincrypt.h"


/*****************************************************************************\
*                                                                             *
*  From icwcfg.h(INC32)
*                                                                             *
\*****************************************************************************/

//
// defines
//

// ICW registry settings

// HKEY_CURRENT_USER
#define ICW_REGPATHSETTINGS     "Software\\Microsoft\\Internet Connection Wizard"
#define ICW_REGKEYCOMPLETED     "Completed"

// Maximum field lengths
#define ICW_MAX_ACCTNAME        256
#define ICW_MAX_PASSWORD        256     // PWLEN
#define ICW_MAX_LOGONNAME       256     // UNLEN
#define ICW_MAX_SERVERNAME      64
#define ICW_MAX_RASNAME         256     // RAS_MaxEntryName
#define ICW_MAX_EMAILNAME       64
#define ICW_MAX_EMAILADDR       128

// Bit-mapped flags

// CheckConnectionWizard input flags
#define ICW_CHECKSTATUS         0x0001

#define ICW_LAUNCHFULL          0x0100
#define ICW_LAUNCHMANUAL        0x0200

// CheckConnectionWizard output flags
#define ICW_FULLPRESENT         0x0001
#define ICW_MANUALPRESENT       0x0002
#define ICW_ALREADYRUN          0x0004

#define ICW_LAUNCHEDFULL        0x0100
#define ICW_LAUNCHEDMANUAL      0x0200

// InetCreateMailNewsAccount input flags
#define ICW_USEDEFAULTS         0x0001

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

//
// type definitions
//
typedef enum tagICW_ACCTTYPE
{
	ICW_ACCTMAIL = 0,
	ICW_ACCTNEWS = ICW_ACCTMAIL + 1
} ICW_ACCTTYPE;

typedef struct tagIMNACCTINFO
{
	DWORD dwSize;                                                           // sizeof(MAILNEWSINFO) for versioning
	CHAR szAccountName[ICW_MAX_ACCTNAME + 1];       // Name of Account
	DWORD dwConnectionType;                                         // RAS Connection Type
												// 0 = LAN Connection
												// 1 = Manual Connection
												// 2 = RAS Dialup Connect
	CHAR szPassword[ICW_MAX_PASSWORD + 1];          // Password
	CHAR szUserName[ICW_MAX_LOGONNAME + 1];         // User name (name of logged-on user, if any)
	BOOL fUseSicily;                                                        // Use sicily authentication (FALSE)
	CHAR szNNTPServer[ICW_MAX_SERVERNAME + 1];      // NNTP server name
	CHAR szPOP3Server[ICW_MAX_SERVERNAME + 1];      // POP3 server name
	CHAR szSMTPServer[ICW_MAX_SERVERNAME + 1];      // SMTP server name
	CHAR szIMAPServer[ICW_MAX_SERVERNAME + 1];      // IMAP server name
	CHAR szConnectoid[ICW_MAX_RASNAME + 1];         // RAS Connection Name
	CHAR szDisplayName[ICW_MAX_EMAILNAME + 1];      // Users display name used for sending mail
	CHAR szEmailAddress[ICW_MAX_EMAILADDR + 1];     // Users email address
} IMNACCTINFO;

//
// external function typedefs
//
//typedef HRESULT (WINAPI *PFNCHECKCONNECTIONWIZARD) (DWORD, LPDWORD);
typedef HRESULT (WINAPI *PFNINETCREATEMAILNEWSACCOUNT) (HWND, ICW_ACCTTYPE, IMNACCTINFO*, DWORD);

#ifdef __cplusplus
}
#endif // __cplusplus


/*****************************************************************************\
*                                                                             *
*  From winerror.h(INC16) - winerror.h file should be included from INC16.
*                                                                             *
\*****************************************************************************/

#ifdef RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) _sc
#else // RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
#endif // RC_INVOKED


//
// MessageId: ERROR_PATH_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the path specified.
//
#define ERROR_PATH_NOT_FOUND             3L

//
// MessageId: ERROR_INVALID_DATA
//
// MessageText:
//
//  The data is invalid.
//
#define ERROR_INVALID_DATA               13L

//
// MessageId: ERROR_TOO_MANY_NAMES
//
// MessageText:
//
//  The name limit for the local computer network
//  adapter card was exceeded.
//
#define ERROR_TOO_MANY_NAMES             68L

//
// MessageId: ERROR_FILE_EXISTS
//
// MessageText:
//
//  The file exists.
//
#define ERROR_FILE_EXISTS                80L

//
// MessageId: ERROR_DISK_FULL
//
// MessageText:
//
//  There is not enough space on the disk.
//
#define ERROR_DISK_FULL                  112L

//
// MessageId: ERROR_ALREADY_EXISTS
//
// MessageText:
//
//  Cannot create a file when that file already exists.
//
#define ERROR_ALREADY_EXISTS             183L

//
// MessageId: ERROR_MORE_DATA
//
// MessageText:
//
//  More data is available.
//
#define ERROR_MORE_DATA                  234L    // dderror

//
// MessageId: ERROR_INVALID_FLAGS
//
// MessageText:
//
//  Invalid flags.
//
#define ERROR_INVALID_FLAGS              1004L

//
// MessageId: ERROR_NO_UNICODE_TRANSLATION
//
// MessageText:
//
//  No mapping for the Unicode character exists in the target multi-byte code page.
//
#define ERROR_NO_UNICODE_TRANSLATION     1113L

//
// MessageId: ERROR_CLASS_ALREADY_EXISTS
//
// MessageText:
//
//  Class already exists.
//
#define ERROR_CLASS_ALREADY_EXISTS       1410L

//
// MessageId: NTE_BAD_DATA
//
// MessageText:
//
//  Bad Data.
//
#define NTE_BAD_DATA                     _HRESULT_TYPEDEF_(0x80090005L)

//
// MessageId: NTE_BAD_SIGNATURE
//
// MessageText:
//
//  Invalid Signature.
//
#define NTE_BAD_SIGNATURE                _HRESULT_TYPEDEF_(0x80090006L)

//
// MessageId: NTE_BAD_ALGID
//
// MessageText:
//
//  Invalid algorithm specified.
//
#define NTE_BAD_ALGID                    _HRESULT_TYPEDEF_(0x80090008L)

//
// MessageId: NTE_EXISTS
//
// MessageText:
//
//  Object already exists.
//
#define NTE_EXISTS                       _HRESULT_TYPEDEF_(0x8009000FL)

//
// MessageId: NTE_FAIL
//
// MessageText:
//
//  An internal error occurred.
//
#define NTE_FAIL                         _HRESULT_TYPEDEF_(0x80090020L)

//
// MessageId: CRYPT_E_MSG_ERROR
//
// MessageText:
//
//  An error was encountered doing a cryptographic message operation.
//
#define CRYPT_E_MSG_ERROR                _HRESULT_TYPEDEF_(0x80091001L)

//
// MessageId: CRYPT_E_HASH_VALUE
//
// MessageText:
//
//  The hash value is not correct.
//
#define CRYPT_E_HASH_VALUE               _HRESULT_TYPEDEF_(0x80091007L)

//
// MessageId: CRYPT_E_SIGNER_NOT_FOUND
//
// MessageText:
//
//  The original signer is not found.
//
#define CRYPT_E_SIGNER_NOT_FOUND         _HRESULT_TYPEDEF_(0x8009100EL)

//
// MessageId: CRYPT_E_STREAM_MSG_NOT_READY
//
// MessageText:
//
//  The steamed message is note yet able to return the requested data.
//
#define CRYPT_E_STREAM_MSG_NOT_READY     _HRESULT_TYPEDEF_(0x80091010L)

//
// MessageId: CRYPT_E_NOT_FOUND
//
// MessageText:
//
//  The object or property wasn't found
//
#define CRYPT_E_NOT_FOUND                _HRESULT_TYPEDEF_(0x80092004L)

// MessageId: CRYPT_E_EXISTS
//
// MessageText:
//
//  The object or property already exists
//
#define CRYPT_E_EXISTS                   _HRESULT_TYPEDEF_(0x80092005L)

//
// MessageId: CRYPT_E_SELF_SIGNED
//
// MessageText:
//
//  The specified certificate is self signed.
//
#define CRYPT_E_SELF_SIGNED              _HRESULT_TYPEDEF_(0x80092007L)

//
//
// MessageId: CRYPT_E_NO_KEY_PROPERTY
//
// MessageText:
//
//  The certificate doesn't have a private key property
//
#define CRYPT_E_NO_KEY_PROPERTY          _HRESULT_TYPEDEF_(0x8009200BL)


// MessageId: CRYPT_E_NO_DECRYPT_CERT
//
// MessageText:
//
//  No certificate was found having a private key property to use for decrypting.
//
#define CRYPT_E_NO_DECRYPT_CERT          _HRESULT_TYPEDEF_(0x8009200CL)

//
// MessageId: ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
//  An attempt was made to perform an initialization operation when
//  initialization has already been completed.
//
#define ERROR_ALREADY_INITIALIZED        1247L

/*****************************************************************************\
*                                                                             *
*  From winreg.h(INC32)
*                                                                             *
\*****************************************************************************/
#if 0
LONG
APIENTRY
RegEnumValueA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

#define RegEnumValue  RegEnumValueA
#endif

#define STANDARD_RIGHTS_WRITE            (READ_CONTROL)


/*****************************************************************************\
*                                                                             *
*  From mmsystem.h(INC32)
*                                                                             *
\*****************************************************************************/

typedef UINT FAR   *LPUINT;


/*****************************************************************************\
*                                                                             *
*  From shellapi.h(INC32)
*                                                                             *
\*****************************************************************************/

#if 0    // Started to use SHELLAPI
typedef struct _SHFILEINFOA
{
        HICON       hIcon;                      // out: icon
        int         iIcon;                      // out: icon index
        DWORD       dwAttributes;               // out: SFGAO_ flags
        CHAR        szDisplayName[MAX_PATH];    // out: display name (or path)
        CHAR        szTypeName[80];             // out: type name
} SHFILEINFOA;

typedef SHFILEINFOA SHFILEINFO;

#define SHGFI_ICON              0x000000100     // get icon
#define SHGFI_DISPLAYNAME       0x000000200     // get display name
#define SHGFI_TYPENAME          0x000000400     // get type name
#define SHGFI_ATTRIBUTES        0x000000800     // get attributes
#define SHGFI_ICONLOCATION      0x000001000     // get icon location
#define SHGFI_EXETYPE           0x000002000     // return exe type
#define SHGFI_SYSICONINDEX      0x000004000     // get system icon index
#define SHGFI_LINKOVERLAY       0x000008000     // put a link overlay on icon
#define SHGFI_SELECTED          0x000010000     // show icon in selected state
#define SHGFI_LARGEICON         0x000000000     // get large icon
#define SHGFI_SMALLICON         0x000000001     // get small icon
#define SHGFI_OPENICON          0x000000002     // get open icon
#define SHGFI_SHELLICONSIZE     0x000000004     // get shell size icon
#define SHGFI_PIDL              0x000000008     // pszPath is a pidl
#define SHGFI_USEFILEATTRIBUTES 0x000000010     // use passed dwFileAttribute

DWORD WINAPI SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA FAR *psfi, UINT cbFileInfo, UINT uFlags);
#define SHGetFileInfo  SHGetFileInfoA

////
//// Tray notification definitions
////

typedef struct _NOTIFYICONDATAA {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
        CHAR   szTip[64];
} NOTIFYICONDATAA, *PNOTIFYICONDATAA;
typedef struct _NOTIFYICONDATAW {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
        WCHAR  szTip[64];
} NOTIFYICONDATAW, *PNOTIFYICONDATAW;
#ifdef UNICODE
typedef NOTIFYICONDATAW NOTIFYICONDATA;
typedef PNOTIFYICONDATAW PNOTIFYICONDATA;
#else
typedef NOTIFYICONDATAA NOTIFYICONDATA;
typedef PNOTIFYICONDATAA PNOTIFYICONDATA;
#endif // UNICODE


#define NIM_ADD         0x00000000
#define NIM_MODIFY      0x00000001
#define NIM_DELETE      0x00000002

#define NIF_MESSAGE     0x00000001
#define NIF_ICON        0x00000002
#define NIF_TIP         0x00000004

BOOL WINAPI Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData);
BOOL WINAPI Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData);
#ifdef UNICODE
#define Shell_NotifyIcon  Shell_NotifyIconW
#else
#define Shell_NotifyIcon  Shell_NotifyIconA
#endif // !UNICODE

////
//// End Tray Notification Icons
////

////
////  Begin ShellExecuteEx and family
////









/* ShellExecute() and ShellExecuteEx() error codes */

/* regular WinExec() codes */
#define SE_ERR_FNF              2       // file not found
#define SE_ERR_PNF              3       // path not found
#define SE_ERR_ACCESSDENIED     5       // access denied
#define SE_ERR_OOM              8       // out of memory
#define SE_ERR_DLLNOTFOUND              32

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE                    26
#define SE_ERR_ASSOCINCOMPLETE          27
#define SE_ERR_DDETIMEOUT               28
#define SE_ERR_DDEFAIL                  29
#define SE_ERR_DDEBUSY                  30
#define SE_ERR_NOASSOC                  31

// Note CLASSKEY overrides CLASSNAME
#define SEE_MASK_CLASSNAME      0x00000001
#define SEE_MASK_CLASSKEY       0x00000003
// Note INVOKEIDLIST overrides IDLIST
#define SEE_MASK_IDLIST         0x00000004
#define SEE_MASK_INVOKEIDLIST   0x0000000c
#define SEE_MASK_ICON           0x00000010
#define SEE_MASK_HOTKEY         0x00000020
#define SEE_MASK_NOCLOSEPROCESS 0x00000040
#define SEE_MASK_CONNECTNETDRV  0x00000080
#define SEE_MASK_FLAG_DDEWAIT   0x00000100
#define SEE_MASK_DOENVSUBST     0x00000200
#define SEE_MASK_FLAG_NO_UI     0x00000400
#define SEE_MASK_UNICODE        0x00004000
#define SEE_MASK_NO_CONSOLE     0x00008000
#define SEE_MASK_ASYNCOK        0x00100000
#define SEE_MASK_HMONITOR       0x00200000

typedef struct _SHELLEXECUTEINFOA
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCSTR   lpVerb;
        LPCSTR   lpFile;
        LPCSTR   lpParameters;
        LPCSTR   lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCSTR   lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        union {
        HANDLE hIcon;
        HANDLE hMonitor;
        };
        HANDLE hProcess;
} SHELLEXECUTEINFOA, FAR *LPSHELLEXECUTEINFOA;
typedef struct _SHELLEXECUTEINFOW
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCWSTR  lpVerb;
        LPCWSTR  lpFile;
        LPCWSTR  lpParameters;
        LPCWSTR  lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCWSTR  lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        union {
        HANDLE hIcon;
        HANDLE hMonitor;
        };
        HANDLE hProcess;
} SHELLEXECUTEINFOW, FAR *LPSHELLEXECUTEINFOW;
#ifdef UNICODE
typedef SHELLEXECUTEINFOW SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOW LPSHELLEXECUTEINFO;
#else
typedef SHELLEXECUTEINFOA SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOA LPSHELLEXECUTEINFO;
#endif // UNICODE

BOOL WINAPI ShellExecuteExA(LPSHELLEXECUTEINFOA lpExecInfo);
BOOL WINAPI ShellExecuteExW(LPSHELLEXECUTEINFOW lpExecInfo);
#ifdef UNICODE
#define ShellExecuteEx  ShellExecuteExW
#else
#define ShellExecuteEx  ShellExecuteExA
#endif // !UNICODE
////
////  End ShellExecuteEx and family
////
#endif //0

/*****************************************************************************\
*                                                                             *
*  From windowsx.h(INC32)
*                                                                             *
\*****************************************************************************/

/* void Cls_OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos) */
#define HANDLE_WM_CONTEXTMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define HANDLE_WM_CTLCOLORSTATIC(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)(lParam), CTLCOLOR_STATIC)

typedef MINMAXINFO FAR * LPMINMAXINFO;

typedef MINMAXINFO FAR * LPMINMAXINFO;

typedef WCHAR  PWCHAR;

#if 0    // Now WINDEF has this
#define DECLSPEC_IMPORT
#endif

#define GetPrivateProfileIntA        GetPrivateProfileInt
#define lstrcmpA                     lstrcmp
#define lstrcmpW                     lstrcmp
#define lstrcmpiA                    lstrcmpi
#define LoadStringA                  LoadString

/*****************************************************************************\
*                                                                             *
*  From commdlg.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/
#define OFN_NONETWORKBUTTON          0x00020000
#define OFN_EXPLORER             0   // 0x00080000 - Not available on Win16
#define OFN_NODEREFERENCELINKS   0   // 0x00100000 - Not available on Win16

typedef UINT (CALLBACK *LPOFNHOOKPROC)( HWND, UINT, WPARAM, LPARAM );

#define CF_NOVERTFONTS       0   // 0x01000000L - Not available on Win16

#define CDM_FIRST       (WM_USER + 100)
#define CDM_LAST        (WM_USER + 200)

// lParam = pointer to a string
// wParam = ID of control to change
// return = not used
#define CDM_SETCONTROLTEXT      (CDM_FIRST + 0x0004)
#define CommDlg_OpenSave_SetControlText(_hdlg, _id, _text) \
        (void)SNDMSG(_hdlg, CDM_SETCONTROLTEXT, (WPARAM)_id, (LPARAM)(LPSTR)_text)

/*****************************************************************************\
*                                                                             *
*  From ntregapi.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/
//
// Key creation/open disposition
//

#define REG_CREATED_NEW_KEY         (0x00000001L)   // New Registry Key created
#define REG_OPENED_EXISTING_KEY     (0x00000002L)   // Existing Key opened

/*****************************************************************************\
*                                                                             *
*  From ntregapi.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/
#if 0
typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;
#endif

#if 0    // Now WINERROR has this
/*****************************************************************************\
*                                                                             *
*  From compobj.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/

#define CO_E_NOT_SUPPORTED          (CO_E_FIRST + 0x10)
#endif

/*****************************************************************************\
*                                                                             *
*  From mbstring.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/
/***
* mbstring.h - MBCS string manipulation macros and functions
*
*	Copyright (c) 1990-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains macros and function declarations for the MBCS
*	string manipulation functions.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBSTRING
#define _INC_MBSTRING

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647	/* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif


#if 0
#ifndef _VA_LIST_DEFINED
#ifdef	_M_ALPHA
typedef struct {
	char *a0;	/* pointer to first homed integer argument */
	int offset;	/* byte offset of next parameter */
} va_list;
#else
typedef char *	va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
	char *_ptr;
	int   _cnt;
	char *_base;
	int   _flag;
	int   _file;
	int   _charbuf;
	int   _bufsiz;
	char *_tmpfname;
	};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif
#endif

/*
 * MBCS - Multi-Byte Character Set
 */

#ifndef _MBSTRING_DEFINED

/* function prototypes */

_CRTIMP unsigned int __cdecl _mbbtombc(unsigned int);
_CRTIMP int __cdecl _mbbtype(unsigned char, int);
_CRTIMP unsigned int __cdecl _mbctombb(unsigned int);
_CRTIMP int __cdecl _mbsbtype(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbschr(const unsigned char *, unsigned int);
_CRTIMP int __cdecl _mbscmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbscoll(const unsigned char *, const unsigned char *);
_CRTIMP size_t __cdecl _mbscspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdec(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdup(const unsigned char *);
_CRTIMP int __cdecl _mbsicmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbsicoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsinc(const unsigned char *);
_CRTIMP size_t __cdecl _mbslen(const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbslwr(unsigned char *);
_CRTIMP int __cdecl _mbsnbcmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnbcnt(const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbsncat(unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnccnt(const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsncpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned int __cdecl _mbsnextc (const unsigned char *);
_CRTIMP int __cdecl _mbsnicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsninc(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbspbrk(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsrchr(const unsigned char *, unsigned int);
_CRTIMP unsigned char * __cdecl _mbsrev(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsset(unsigned char *, unsigned int);
_CRTIMP size_t __cdecl _mbsspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsspnp(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsstr(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbstok(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsupr(unsigned char *);

_CRTIMP size_t __cdecl _mbclen(const unsigned char *);
#define _mbccmp(_cpc1, _cpc2) _mbsncmp((_cpc1),(_cpc2),1)

/* character routines */

_CRTIMP int __cdecl _ismbcalnum(unsigned int);
_CRTIMP int __cdecl _ismbcalpha(unsigned int);
_CRTIMP int __cdecl _ismbcdigit(unsigned int);
_CRTIMP int __cdecl _ismbcgraph(unsigned int);
_CRTIMP int __cdecl _ismbclegal(unsigned int);
_CRTIMP int __cdecl _ismbclower(unsigned int);
_CRTIMP int __cdecl _ismbcprint(unsigned int);
_CRTIMP int __cdecl _ismbcpunct(unsigned int);
_CRTIMP int __cdecl _ismbcspace(unsigned int);
_CRTIMP int __cdecl _ismbcupper(unsigned int);

_CRTIMP unsigned int __cdecl _mbctolower(unsigned int);
_CRTIMP unsigned int __cdecl _mbctoupper(unsigned int);

#define _MBSTRING_DEFINED
#endif

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead( unsigned int );
_CRTIMP int __cdecl _ismbbtrail( unsigned int );
_CRTIMP int __cdecl _ismbslead( const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail( const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

/*  Kanji specific prototypes.	*/

_CRTIMP int __cdecl _ismbchira(unsigned int);
_CRTIMP int __cdecl _ismbckata(unsigned int);
_CRTIMP int __cdecl _ismbcsymbol(unsigned int);
_CRTIMP int __cdecl _ismbcl0(unsigned int);
_CRTIMP int __cdecl _ismbcl1(unsigned int);
_CRTIMP int __cdecl _ismbcl2(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjistojms(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjmstojis(unsigned int);
_CRTIMP unsigned int __cdecl _mbctohira(unsigned int);
_CRTIMP unsigned int __cdecl _mbctokata(unsigned int);

#ifdef __cplusplus
}
#endif

#ifdef _MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#endif	/* _INC_MBSTRING */


/*****************************************************************************\
*                                                                             *
*  From winnt.h(INC32)
*                                                                             *
\*****************************************************************************/

#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_DECOMMIT         0x4000     
#define MEM_RELEASE          0x8000     


struct WNDMSGPARAM16
{
   LPARAM  wParam;
   LPARAM  lParam;
};


/*****************************************************************************\
*                                                                             *
*  From shlwapi.h - shlwapi.h in INC16 is not feasible for us
*                                                                             *
\*****************************************************************************/

#ifdef __cplusplus
}
#endif //__cplusplus


/*****************************************************************************\
*                                                                             *
*  From iehelpid - iehelpid.h from INC which is not in INC16
*                                                                             *
\*****************************************************************************/

//CERTIFICATE PROPERTIES DIALOG BOX
#define IDH_CERTVWPROP_GEN_FINEPRINT          50228
#define IDH_CERTVWPROP_DET_ISSUER_CERT        50229
#define IDH_CERTVWPROP_DET_FRIENDLY           50230
#define IDH_CERTVWPROP_DET_STATUS             50231
#define IDH_CERTVWPROP_TRUST_PURPOSE          50232
#define IDH_CERTVWPROP_TRUST_HIERAR           50233
#define IDH_CERTVWPROP_TRUST_VIEWCERT         50234
#define IDH_CERTVWPROP_TRUST_INHERIT          50235
#define IDH_CERTVWPROP_TRUST_EXPLICIT_TRUST   50236
#define IDH_CERTVWPROP_TRUST_EXPLICIT_DISTRUST 50237
#define IDH_CERTVWPROP_ADV_FIELD              50238
#define IDH_CERTVWPROP_ADV_DETAILS            50239



#endif // ATHENA16_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\import\oe4\oe4imp.cpp ===
//--------------------------------------------------------------------------
// OE4Imp.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "oe4imp.h"
#include "structs.h"
#include "migerror.h"
#include <shared.h>
#include <impapi.h>
#include <shlwapi.h>
#include "dllmain.h"
#include "resource.h"

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
static const char c_szMail[] = "mail";
static const char c_szFoldersNch[] = "folders.nch";
static const char c_szEmpty[] = "";

// --------------------------------------------------------------------------------
// MSG_xxx flags
// --------------------------------------------------------------------------------
#define MSG_DELETED                  0x0001
#define MSG_UNREAD                   0x0002
#define MSG_SUBMITTED                0x0004
#define MSG_UNSENT                   0x0008
#define MSG_RECEIVED                 0x0010
#define MSG_NEWSMSG                  0x0020
#define MSG_NOSECUI                  0x0040
#define MSG_VOICEMAIL                0x0080
#define MSG_REPLIED                  0x0100
#define MSG_FORWARDED                0x0200
#define MSG_RCPTSENT                 0x0400
#define MSG_FLAGGED                  0x0800
#define MSG_LAST                     0x0200
#define MSG_EXTERNAL_FLAGS           0x00fe
#define MSG_FLAGS                    0x000f

//--------------------------------------------------------------------------
// COE4Import_CreateInstance
//--------------------------------------------------------------------------
COE4Import_CreateInstance(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Trace
    TraceCall("COE4Import_CreateInstance");

    // Initialize
    *ppUnknown = NULL;

    // Create me
    COE4Import *pNew = new COE4Import();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// GetRecordBlock
// --------------------------------------------------------------------------------
HRESULT GetRecordBlock(LPMEMORYFILE pFile, DWORD faRecord, LPRECORDBLOCKV5B1 *ppRecord,
    LPBYTE *ppbData, BOOL *pfContinue)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("GetRecordBlock");

    // Bad Length
    if (faRecord + sizeof(RECORDBLOCKV5B1) > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Cast the Record
    (*ppRecord) = (LPRECORDBLOCKV5B1)((LPBYTE)pFile->pView + faRecord);

    // Invalid Record Signature
    if (faRecord != (*ppRecord)->faRecord)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_BADRECORDSIGNATURE);
        goto exit;
    }

    // Bad Length
    if (faRecord + (*ppRecord)->cbRecord > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Set pbData
    *ppbData = (LPBYTE)((LPBYTE)(*ppRecord) + sizeof(RECORDBLOCKV5B1));

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// COE4Import::COE4Import
//--------------------------------------------------------------------------
COE4Import::COE4Import(void)
{
    TraceCall("COE4Import::COE4Import");
    m_cRef = 1;
    m_pList = NULL;
    *m_szDirectory = '\0';
    m_cFolders = 0;
    m_prgFolder = NULL;
}

//--------------------------------------------------------------------------
// COE4Import::~COE4Import
//--------------------------------------------------------------------------
COE4Import::~COE4Import(void)
{
    TraceCall("COE4Import::~COE4Import");
    _Cleanup();
}

//--------------------------------------------------------------------------
// COE4Import::_FreeFolderList
//--------------------------------------------------------------------------
void COE4Import::_Cleanup(void)
{
    _FreeFolderList(m_pList);
    m_pList = NULL;
    SafeMemFree(m_prgFolder);
    m_cFolders = 0;
}

//--------------------------------------------------------------------------
// COE4Import::_FreeFolderList
//--------------------------------------------------------------------------
void COE4Import::_FreeFolderList(IMPFOLDERNODE *pNode)
{
    // Locals
    IMPFOLDERNODE *pNext;
    IMPFOLDERNODE *pCurrent=pNode;

    // Loop
    while (pCurrent)
    {
        // Save next
        pNext = pCurrent->pnext;

        // Free Children ?
        if (pCurrent->pchild)
        {
            // Free
            _FreeFolderList(pCurrent->pchild);
        }

        // Free szName
        g_pMalloc->Free(pCurrent->szName);

        // Free pCurrent
        g_pMalloc->Free(pCurrent);

        // Set Current
        pCurrent = pNext;
    }
}

//--------------------------------------------------------------------------
// COE4Import::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COE4Import::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMailImport == riid)
        *ppv = (IMailImport *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE4Import::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE4Import::AddRef(void)
{
    TraceCall("COE4Import::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// COE4Import::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE4Import::Release(void)
{
    TraceCall("COE4Import::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// COE4Import::InitializeImport
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::InitializeImport(HWND hwnd)
{
    // Let Importer Ask for the Directory
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE4Import::GetDirectory
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::GetDirectory(LPSTR pszDir, UINT cch)
{
    // Locals
    HKEY        hKey=NULL;
    DWORD       dwType;
    DWORD       cb=cch;

    // Try to query the OE4 store root...
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Outlook Express", 0, KEY_READ, &hKey))
    {
        // Try to read the value
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, "Store Root", NULL, &dwType, (LPBYTE)pszDir, &cb))
            goto exit;
    }

    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    // Try V1
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Internet Mail and News", 0, KEY_READ, &hKey))
    {
        // Query the Store Root
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, "Store Root", NULL, &dwType, (LPBYTE)pszDir, &cb))
            goto exit;
    }

    // Null It Out
    *pszDir = '\0';

exit:
    // Close the Key
    if (hKey)
        RegCloseKey(hKey);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE4Import::SetDirectory
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::SetDirectory(LPSTR pszDir)
{
    // Trace
    TraceCall("COE4Import::SetDirectory");

    // Save the Directory
    StrCpyN(m_szDirectory, pszDir, ARRAYSIZE(m_szDirectory));

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE4Import::_EnumerateV1Folders
//--------------------------------------------------------------------------
HRESULT COE4Import::_EnumerateV1Folders(void)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szRes[255];
    CHAR                szMbxPath[MAX_PATH + MAX_PATH];
    CHAR                szSearch[MAX_PATH + MAX_PATH];
    WIN32_FIND_DATA     fd;
    HANDLE              hFind=INVALID_HANDLE_VALUE;
    DWORD               cAllocated=0;
    LPFLDINFO           pFolder;
    DWORD               i;
    MEMORYFILE          MbxFile={0};
    LPMBXFILEHEADER     pMbxHeader;

    // Trace
    TraceCall("COE4Import::_EnumerateV1Folders");

    // Do we have a sub dir
    wnsprintf(szSearch, ARRAYSIZE(szSearch), "%s\\*.mbx", m_szDirectory);

    // Find first file
    hFind = FindFirstFile(szSearch, &fd);

    // Did we find something
    if (INVALID_HANDLE_VALUE == hFind)
        goto exit;

    // Loop for ever
    while(1)
    {
        // If this is not a directory
        if (FALSE == ISFLAGSET(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        {
            // Open the file
            IF_FAILEXIT(hr = MakeFilePath(m_szDirectory, fd.cFileName, c_szEmpty, szMbxPath, ARRAYSIZE(szMbxPath)));

            // Open the memory file
            if (SUCCEEDED(OpenMemoryFile(szMbxPath, &MbxFile)))
            {
                // Allocate
                if (m_cFolders + 1 > cAllocated)
                {
                    // Reallocate
                    IF_FAILEXIT(hr = HrRealloc((LPVOID *)&m_prgFolder, (cAllocated + 10) * sizeof(FLDINFO)));

                    // Set cAllocated
                    cAllocated += 10;
                }

                // Readability
                pFolder = &m_prgFolder[m_cFolders];

                // Zero this node
                ZeroMemory(pFolder, sizeof(FLDINFO));

                // Copy the filename
                StrCpyN(pFolder->szFile, fd.cFileName, ARRAYSIZE(pFolder->szFile));

                // Strip the Extension Off
                PathRemoveExtensionA(pFolder->szFile);

                // Copy the folder name
                StrCpyN(pFolder->szFolder, pFolder->szFile, ARRAYSIZE(pFolder->szFolder));

                // Set Special
                pFolder->tySpecial = (FOLDER_TYPE_NORMAL - 1);

                // Loop through special folder
                for (i=FOLDER_TYPE_INBOX; i<CFOLDERTYPE; i++)
                {
                    // Load the Special Folder Name
                    LoadString(g_hInstImp, idsInbox + (i - 1), szRes, ARRAYSIZE(szRes));

                    // Compare with szFile
                    if (lstrcmpi(pFolder->szFolder, szRes) == 0)
                    {
                        // Copy the Folder Name
                        pFolder->tySpecial = (i - 1);

                        // Done
                        break;
                    }
                }

                // Read the Mbx File Header
                pMbxHeader = (LPMBXFILEHEADER)(MbxFile.pView);

                // Get the message Count so progress will work nicely
                pFolder->cMessages = pMbxHeader->cMsg;

                // Close the memory file
                CloseMemoryFile(&MbxFile);

                // Increment m_cFolders
                m_cFolders++;
            }
        }

        // Find the Next File
        if (!FindNextFile(hFind, &fd))
            break;
    }

exit:
    // Cleanup
    if (hFind)
        FindClose(hFind);
    CloseMemoryFile(&MbxFile);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE4Import::EnumerateFolders
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cchDir;
    MEMORYFILE          File={0};
    LPTABLEHEADERV5B1   pHeader;
    LPBYTE              pbData;
    DWORD               faRecord;
    LPFLDINFO           pFolder;
    LPRECORDBLOCKV5B1   pRecord;
    BOOL                fContinue;
    COE4EnumFolders    *pEnum=NULL;
    CHAR                szFilePath[MAX_PATH + MAX_PATH];
    IMPFOLDERNODE      *pList;
    IMPFOLDERNODE      *pNode=(IMPFOLDERNODE *)dwCookie;

    // Trace
    TraceCall("COE4Import::EnumerateFolders");

    // Invalid Args
    Assert(ppEnum);

    // No folders yet ?
    if (COOKIE_ROOT == dwCookie)
    {
        // Reset...
        _Cleanup();

        // Append \Mail onto m_szDirectory
        cchDir = lstrlen(m_szDirectory);

        // Is there enough room
        if (cchDir + lstrlen(c_szMail) + 2 >= ARRAYSIZE(m_szDirectory))
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Need a Wack ?
        PathAddBackslash(m_szDirectory);

        // Append \\mail
        StrCatBuff(m_szDirectory, c_szMail, ARRAYSIZE(m_szDirectory));

        // Make Path to folders.nch file
        IF_FAILEXIT(hr = MakeFilePath(m_szDirectory, c_szFoldersNch, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

        // If the folders.nch file doesn't exist, just try to enumerate the 
        if (FALSE == PathFileExists(szFilePath))
        {
            // EnumerateV1Folders
            IF_FAILEXIT(hr = _EnumerateV1Folders());
        }

        // Otherwise, crack the folders.nch file
        else
        {
            // Open the Folders file
            IF_FAILEXIT(hr = OpenMemoryFile(szFilePath, &File));

            // Validate Version
            pHeader = (LPTABLEHEADERV5B1)File.pView;

            // Check the Signature...
            if (File.cbSize < sizeof(TABLEHEADERV5B1) || OBJECTDB_SIGNATURE != pHeader->dwSignature || OBJECTDB_VERSION_PRE_V5 != pHeader->wMajorVersion)
            {
                hr = TraceResult(E_FAIL);
                goto exit;
            }

            // Allocate Folder Array
            IF_NULLEXIT(m_prgFolder = (LPFLDINFO)ZeroAllocate(sizeof(FLDINFO) * pHeader->cRecords));

            // Initialize faRecord to start
            faRecord = pHeader->faFirstRecord;

            // While we have a record
            while(faRecord)
            {
                // Readability
                pFolder = &m_prgFolder[m_cFolders];

                // Get the Record
                IF_FAILEXIT(hr = GetRecordBlock(&File, faRecord, &pRecord, &pbData, &fContinue));

                // DWORD - hFolder
                CopyMemory(&pFolder->idFolder, pbData, sizeof(pFolder->idFolder));
                pbData += sizeof(pFolder->idFolder);

                // CHAR(MAX_FOLDER_NAME) - szFolder
                CopyMemory(pFolder->szFolder, pbData, sizeof(pFolder->szFolder));
                pbData += sizeof(pFolder->szFolder);

                // CHAR(260) - szFile
                CopyMemory(pFolder->szFile, pbData, sizeof(pFolder->szFile));
                pbData += sizeof(pFolder->szFile);

                // DWORD - idParent
                CopyMemory(&pFolder->idParent, pbData, sizeof(pFolder->idParent));
                pbData += sizeof(pFolder->idParent);

                // DWORD - idChild
                CopyMemory(&pFolder->idChild, pbData, sizeof(pFolder->idChild));
                pbData += sizeof(pFolder->idChild);

                // DWORD - idSibling
                CopyMemory(&pFolder->idSibling, pbData, sizeof(pFolder->idSibling));
                pbData += sizeof(pFolder->idSibling);

                // DWORD - tySpecial
                CopyMemory(&pFolder->tySpecial, pbData, sizeof(pFolder->tySpecial));
                pbData += sizeof(pFolder->tySpecial);

                // DWORD - cChildren
                CopyMemory(&pFolder->cChildren, pbData, sizeof(pFolder->cChildren));
                pbData += sizeof(pFolder->cChildren);

                // DWORD - cMessages
                CopyMemory(&pFolder->cMessages, pbData, sizeof(pFolder->cMessages));
                pbData += sizeof(pFolder->cMessages);

                // DWORD - cUnread
                CopyMemory(&pFolder->cUnread, pbData, sizeof(pFolder->cUnread));
                pbData += sizeof(pFolder->cUnread);

                // DWORD - cbTotal
                CopyMemory(&pFolder->cbTotal, pbData, sizeof(pFolder->cbTotal));
                pbData += sizeof(pFolder->cbTotal);

                // DWORD - cbUsed
                CopyMemory(&pFolder->cbUsed, pbData, sizeof(pFolder->cbUsed));
                pbData += sizeof(pFolder->cbUsed);

                // DWORD - bHierarchy
                CopyMemory(&pFolder->bHierarchy, pbData, sizeof(pFolder->bHierarchy));
                pbData += sizeof(pFolder->bHierarchy);

                // DWORD - dwImapFlags
                CopyMemory(&pFolder->dwImapFlags, pbData, sizeof(pFolder->dwImapFlags));
                pbData += sizeof(DWORD);

                // BLOB - bListStamp
                CopyMemory(&pFolder->bListStamp, pbData, sizeof(pFolder->bListStamp));
                pbData += sizeof(BYTE);

                // DWORD - bReserved[3]
                pbData += (3 * sizeof(BYTE));

                // DWORD - rgbReserved
                pbData += 40;

                // Increment Count
                m_cFolders++;

                // Goto the Next Record
                faRecord = pRecord->faNext;
            }
        }

        // Build Import Folder Hierarchy
        IF_FAILEXIT(hr = _BuildFolderHierarchy(0, 0, NULL, m_cFolders, m_prgFolder));
    }

    // Not Folders ?
    else if (NULL == m_prgFolder)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // What should I 
    if (dwCookie == COOKIE_ROOT)
        pList = m_pList;
    else
        pList = pNode->pchild;

    // Create Folder Enumerator
    IF_NULLEXIT(pEnum = new COE4EnumFolders(pList));

    // Return Enumerator
    *ppEnum = (IEnumFOLDERS *)pEnum;

    // Don't Free
    pEnum = NULL;

exit:
    // Cleanup
    SafeRelease(pEnum);
    CloseMemoryFile(&File);
    
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE4Import::_BuildFolderHierarchy
//--------------------------------------------------------------------------
HRESULT COE4Import::_BuildFolderHierarchy(DWORD cDepth, DWORD idParent,
    IMPFOLDERNODE *pParent, DWORD cFolders, LPFLDINFO prgFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    IMPFOLDERNODE  *pPrevious=NULL;
    IMPFOLDERNODE  *pNode;

    // Trace
    TraceCall("COE4Import::_BuildFolderHierarchy");

    // Walk through prgFolder and find items with parent of idParent
    for (i=0; i<cFolders; i++)
    {
        // Correct Parent ?
        if (idParent == prgFolder[i].idParent)
        {
            // Allocate the Root
            IF_NULLEXIT(pNode = (IMPFOLDERNODE *)ZeroAllocate(sizeof(IMPFOLDERNODE)));

            // Set Parent
            pNode->pparent = pParent;

            // Set Depth
            pNode->depth = cDepth;

            // Copy name
            IF_NULLEXIT(pNode->szName = PszDupA(prgFolder[i].szFolder));

            // Count of Messages
            pNode->cMsg = prgFolder[i].cMessages;

            // Set Type
            pNode->type = (IMPORTFOLDERTYPE)(prgFolder[i].tySpecial + 1);

            // Set lParam
            pNode->lparam = i;

            // Link pNode into List
            if (pPrevious)
                pPrevious->pnext = pNode;
            else if (pParent)
                pParent->pchild = pNode;
            else
            {
                Assert(NULL == m_pList);
                m_pList = pNode;
            }

            // Set pPrevious
            pPrevious = pNode;

            // Has Children ?
            if (prgFolder[i].cChildren)
            {
                // Enumerate Children
                IF_FAILEXIT(hr = _BuildFolderHierarchy(cDepth + 1, prgFolder[i].idFolder, pNode, cFolders, prgFolder));
            }
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE4Import::ImportFolder
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szIdxPath[MAX_PATH + MAX_PATH];
    CHAR                szMbxPath[MAX_PATH + MAX_PATH];
    MEMORYFILE          IdxFile={0};
    MEMORYFILE          MbxFile={0};
    LPBYTE              pbStream;
    LPMBXFILEHEADER     pMbxHeader;
    LPIDXFILEHEADER     pIdxHeader;
    DWORD               faIdxRead;
    LPIDXMESSAGEHEADER  pIdxMessage;
    LPMBXMESSAGEHEADER  pMbxMessage;
    DWORD               cMessages=0;
    DWORD               dwMsgState;
    DWORD               i;
    DWORD               cb;
    CByteStream        *pStream=NULL;
    IMPFOLDERNODE      *pNode=(IMPFOLDERNODE *)dwCookie;
    LPFLDINFO           pFolder;

    // Trace
    TraceCall("COE4Import::ImportFolder");

    // Set pFolder
    pFolder = &m_prgFolder[pNode->lparam];

    // .idx path
    IF_FAILEXIT(hr = MakeFilePath(m_szDirectory, pFolder->szFile, ".idx", szIdxPath, ARRAYSIZE(szIdxPath)));

    // .mbx path
    IF_FAILEXIT(hr = MakeFilePath(m_szDirectory, pFolder->szFile, ".mbx", szMbxPath, ARRAYSIZE(szMbxPath)));

    // Open the memory file
    IF_FAILEXIT(hr = OpenMemoryFile(szIdxPath, &IdxFile));

    // Open the memory file
    IF_FAILEXIT(hr = OpenMemoryFile(szMbxPath, &MbxFile));

    // Read the Mbx File Header
    pMbxHeader = (LPMBXFILEHEADER)(MbxFile.pView);

    // Read the Idx File Header
    pIdxHeader = (LPIDXFILEHEADER)(IdxFile.pView);

    // Validate the Version of th idx file
    if (pIdxHeader->ver != CACHEFILE_VER || pIdxHeader->dwMagic != CACHEFILE_MAGIC)
    {
        hr = TraceResult(MIGRATE_E_INVALIDIDXHEADER);
        goto exit;
    }

    // Setup faIdxRead
    faIdxRead = sizeof(IDXFILEHEADER);

    // Set Message Count
    pImport->SetMessageCount(pIdxHeader->cMsg);

    // Prepare to Loop
    for (i=0; i<pIdxHeader->cMsg; i++)
    {
        // Done
        if (faIdxRead >= IdxFile.cbSize)
            break;

        // Read an idx message header
        pIdxMessage = (LPIDXMESSAGEHEADER)((LPBYTE)IdxFile.pView + faIdxRead);

        // If this message is not marked as deleted...
        if (ISFLAGSET(pIdxMessage->dwState, MSG_DELETED))
            goto NextMessage;

        // Initialize State
        dwMsgState = 0;

        // Fixup the Flags
        if (ISFLAGSET(pIdxMessage->dwState, MSG_UNREAD))
            FLAGSET(dwMsgState, MSG_STATE_UNREAD);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_UNSENT))
            FLAGSET(dwMsgState, MSG_STATE_UNSENT);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_SUBMITTED))
            FLAGSET(dwMsgState, MSG_STATE_SUBMITTED);

        // Bad
        if (pIdxMessage->dwOffset > MbxFile.cbSize)
            goto NextMessage;

        // Lets read the message header in the mbx file to validate the msgids
        pMbxMessage = (LPMBXMESSAGEHEADER)((LPBYTE)MbxFile.pView + pIdxMessage->dwOffset);

        // Validate the Message Ids
        if (pMbxMessage->msgid != pIdxMessage->msgid)
            goto NextMessage;

        // Check for magic
        if (pMbxMessage->dwMagic != MSGHDR_MAGIC)
            goto NextMessage;

        // Get the stream pointer
        pbStream = (LPBYTE)((LPBYTE)MbxFile.pView + (pIdxMessage->dwOffset + sizeof(MBXMESSAGEHEADER)));

        // New byte Stream
        IF_NULLEXIT(pStream = new CByteStream(pbStream, pMbxMessage->dwBodySize));

        // Import the message
        IF_FAILEXIT(hr = pImport->ImportMessage(MSG_TYPE_MAIL, dwMsgState, pStream, NULL, 0));

        // Count
        cMessages++;

NextMessage:
        // Cleanup
        if (pStream)
        {
            pStream->AcquireBytes(&cb, &pbStream, ACQ_DISPLACE);
            pStream->Release();
            pStream = NULL;
        }

        // Goto Next Header
        Assert(pIdxMessage);

        // Update faIdxRead
        faIdxRead += pIdxMessage->dwSize;
    }

exit:
    // Cleanup
    if (pStream)
    {
        pStream->AcquireBytes(&cb, &pbStream, ACQ_DISPLACE);
        pStream->Release();
        pStream = NULL;
    }

    CloseMemoryFile(&IdxFile);
    CloseMemoryFile(&MbxFile);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// COE4EnumFolders::COE4EnumFolders
//--------------------------------------------------------------------------
COE4EnumFolders::COE4EnumFolders(IMPFOLDERNODE *pList)
{
    TraceCall("COE4EnumFolders::COE4EnumFolders");
    m_cRef = 1;
    m_pList = pList;
    m_pNext = pList;
}

//--------------------------------------------------------------------------
// COE4EnumFolders::COE4EnumFolders
//--------------------------------------------------------------------------
COE4EnumFolders::~COE4EnumFolders(void)
{
    TraceCall("COE4EnumFolders::~COE4EnumFolders");
}

//--------------------------------------------------------------------------
// COE4EnumFolders::COE4EnumFolders
//--------------------------------------------------------------------------
STDMETHODIMP COE4EnumFolders::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COE4EnumFolders::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IEnumFOLDERS == riid)
        *ppv = (IEnumFOLDERS *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE4EnumFolders::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE4EnumFolders::AddRef(void)
{
    TraceCall("COE4EnumFolders::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// COE4EnumFolders::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE4EnumFolders::Release(void)
{
    TraceCall("COE4EnumFolders::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// COE4EnumFolders::Next
//--------------------------------------------------------------------------
STDMETHODIMP COE4EnumFolders::Next(IMPORTFOLDER *pFolder)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("COE4EnumFolders::Next");

    // Invalid Args
    Assert(pFolder != NULL);

    // Done
    if (NULL == m_pNext)
        return(S_FALSE);

    // Zero
    ZeroMemory(pFolder, sizeof(IMPORTFOLDER));

    // Store pNext into dwCookie
    pFolder->dwCookie = (DWORD_PTR)m_pNext;

    // Copy Folder Name
    StrCpyN(pFolder->szName, m_pNext->szName, ARRAYSIZE(pFolder->szName));

    // Copy Type
    pFolder->type = m_pNext->type;

    // Has Sub Folders ?
    pFolder->fSubFolders = (m_pNext->pchild != NULL);

    // Goto Next
    m_pNext = m_pNext->pnext;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE4EnumFolders::Reset
//--------------------------------------------------------------------------
STDMETHODIMP COE4EnumFolders::Reset(void)
{
    // Trace
    TraceCall("COE4EnumFolders::Reset");

    // Reset
    m_pNext = m_pList;

    // Done
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\atlwinx.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWIN_H__
	#error atlwin.cpp requires atlwin.h to be included first
#endif

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// CWindow

HWND CWindow::GetDescendantWindow(int nID) const
{
	_ASSERTE(::IsWindow(m_hWnd));

	// GetDlgItem recursive (return first found)
	// breadth-first for 1 level, then depth-first for next level

	// use GetDlgItem since it is a fast USER function
	HWND hWndChild, hWndTmp;
	CWindow wnd;
	if((hWndChild = ::GetDlgItem(m_hWnd, nID)) != NULL)
	{
		if(::GetTopWindow(hWndChild) != NULL)
		{
			// children with the same ID as their parent have priority
			wnd.Attach(hWndChild);
			hWndTmp = wnd.GetDescendantWindow(nID);
			if(hWndTmp != NULL)
				return hWndTmp;
		}
		return hWndChild;
	}

	// walk each child
	for(hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
		hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
	{
		wnd.Attach(hWndChild);
		hWndTmp = wnd.GetDescendantWindow(nID);
		if(hWndTmp != NULL)
			return hWndTmp;
	}

	return NULL;    // not found
}

void CWindow::SendMessageToDescendants(UINT message, WPARAM wParam/*= 0*/, LPARAM lParam/*= 0*/, BOOL bDeep/* = TRUE*/)
{
	CWindow wnd;
	for(HWND hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
		hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
	{
		::SendMessage(hWndChild, message, wParam, lParam);

		if(bDeep && ::GetTopWindow(hWndChild) != NULL)
		{
			// send to child windows after parent
			wnd.Attach(hWndChild);
			wnd.SendMessageToDescendants(message, wParam, lParam, bDeep);
		}
	}
}

BOOL CWindow::CenterWindow(HWND hWndCenter/* = NULL*/)
{
	_ASSERTE(::IsWindow(m_hWnd));

	// determine owner window to center against
	DWORD dwStyle = GetStyle();
	if(hWndCenter == NULL)
	{
		if(dwStyle & WS_CHILD)
			hWndCenter = ::GetParent(m_hWnd);
		else
			hWndCenter = ::GetWindow(m_hWnd, GW_OWNER);
	}

	// get coordinates of the window relative to its parent
	RECT rcDlg;
	::GetWindowRect(m_hWnd, &rcDlg);
	RECT rcArea;
	RECT rcCenter;
	HWND hWndParent;
	if(!(dwStyle & WS_CHILD))
	{
		// don't center against invisible or minimized windows
		if(hWndCenter != NULL)
		{
			DWORD dwStyle = ::GetWindowLong(hWndCenter, GWL_STYLE);
			if(!(dwStyle & WS_VISIBLE) || (dwStyle & WS_MINIMIZE))
				hWndCenter = NULL;
		}

		// center within screen coordinates
		::SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);

		if(hWndCenter == NULL)
			rcCenter = rcArea;
		else
			::GetWindowRect(hWndCenter, &rcCenter);
	}
	else
	{
		// center within parent client coordinates
		hWndParent = ::GetParent(m_hWnd);
		_ASSERTE(::IsWindow(hWndParent));

		::GetClientRect(hWndParent, &rcArea);
		_ASSERTE(::IsWindow(hWndCenter));
		::GetClientRect(hWndCenter, &rcCenter);
		::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
	}

	int DlgWidth = rcDlg.right - rcDlg.left;
	int DlgHeight = rcDlg.bottom - rcDlg.top;

	// find dialog's upper left based on rcCenter
	int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
	int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

	// if the dialog is outside the screen, move it inside
	if(xLeft < rcArea.left)
		xLeft = rcArea.left;
	else if(xLeft + DlgWidth > rcArea.right)
		xLeft = rcArea.right - DlgWidth;

	if(yTop < rcArea.top)
		yTop = rcArea.top;
	else if(yTop + DlgHeight > rcArea.bottom)
		yTop = rcArea.bottom - DlgHeight;

	// map screen coordinates to child coordinates
	return ::SetWindowPos(m_hWnd, NULL, xLeft, yTop, -1, -1,
		SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

BOOL CWindow::ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	_ASSERTE(::IsWindow(m_hWnd));

	DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_STYLE);
	DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
	if(dwStyle == dwNewStyle)
		return FALSE;

	::SetWindowLong(m_hWnd, GWL_STYLE, dwNewStyle);
	if(nFlags != 0)
	{
		::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
			SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
	}

	return TRUE;
}

BOOL CWindow::ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	_ASSERTE(::IsWindow(m_hWnd));

	DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
	DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
	if(dwStyle == dwNewStyle)
		return FALSE;

	::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwNewStyle);
	if(nFlags != 0)
	{
		::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
			SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
	}

	return TRUE;
}

BOOL CWindow::GetWindowText(BSTR& bstrText)
{
	USES_CONVERSION;
	_ASSERTE(::IsWindow(m_hWnd));

	int nLen = ::GetWindowTextLength(m_hWnd);
	if(nLen == 0)
		return FALSE;

	LPTSTR lpszText = (LPTSTR)_alloca((nLen+1)*sizeof(TCHAR));

	if(!::GetWindowText(m_hWnd, lpszText, nLen+1))
		return FALSE;

	bstrText = ::SysAllocString(T2OLE(lpszText));

	return (bstrText != NULL) ? TRUE : FALSE;
}

HWND CWindow::GetTopLevelParent() const
{
	_ASSERTE(::IsWindow(m_hWnd));

	HWND hWndParent = m_hWnd;
	HWND hWndTmp;
	while((hWndTmp = ::GetParent(hWndParent)) != NULL)
		hWndParent = hWndTmp;

	return hWndParent;
}

HWND CWindow::GetTopLevelWindow() const
{
	_ASSERTE(::IsWindow(m_hWnd));

	HWND hWndParent = m_hWnd;
	HWND hWndTmp = hWndParent;

	while(hWndTmp != NULL)
	{
		hWndTmp = (::GetWindowLong(hWndParent, GWL_STYLE) & WS_CHILD) ? ::GetParent(hWndParent) : ::GetWindow(hWndParent, GW_OWNER);
		hWndParent = hWndTmp;
	}

	return hWndParent;
}

/////////////////////////////////////////////////////////////////////////////
// CDynamicChain

CDynamicChain::~CDynamicChain()
{
	if(m_pChainEntry != NULL)
	{
		for(int i = 0; i < m_nEntries; i++)
		{
			if(m_pChainEntry[i] != NULL)
				delete m_pChainEntry[i];
		}

		delete [] m_pChainEntry;
	}
}

BOOL CDynamicChain::SetChainEntry(DWORD dwChainID, CMessageMap* pObject, DWORD dwMsgMapID /* = 0 */)
{
// first search for an existing entry

	for(int i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] != NULL && m_pChainEntry[i]->m_dwChainID == dwChainID)
		{
			m_pChainEntry[i]->m_pObject = pObject;
			m_pChainEntry[i]->m_dwMsgMapID = dwMsgMapID;
			return TRUE;
		}
	}

// create a new one

	ATL_CHAIN_ENTRY* pEntry = NULL;
	ATLTRY(pEntry = new ATL_CHAIN_ENTRY);

	if(pEntry == NULL)
		return FALSE;

// search for an empty one

	for(i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] == NULL)
		{
			m_pChainEntry[i] = pEntry;
			return TRUE;
		}
	}

// add a new one

	ATL_CHAIN_ENTRY** ppNew = NULL;
	ATLTRY(ppNew = new ATL_CHAIN_ENTRY*[m_nEntries + 1]);

	if(ppNew == NULL)
	{
		delete pEntry;
		return FALSE;
	}

	pEntry->m_dwChainID = dwChainID;
	pEntry->m_pObject = pObject;
	pEntry->m_dwMsgMapID = dwMsgMapID;

	if(m_pChainEntry != NULL)
	{
		memcpy(ppNew, m_pChainEntry, m_nEntries * sizeof(ATL_CHAIN_ENTRY*));
		delete [] m_pChainEntry;
	}

	m_pChainEntry = ppNew;

	m_pChainEntry[m_nEntries] = pEntry;

	m_nEntries++;

	return TRUE;
}

BOOL CDynamicChain::RemoveChainEntry(DWORD dwChainID)
{
	for(int i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] != NULL && m_pChainEntry[i]->m_dwChainID == dwChainID)
		{
			delete m_pChainEntry[i];
			m_pChainEntry[i] = NULL;
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CDynamicChain::CallChain(DWORD dwChainID, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult)
{
	for(int i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] != NULL && m_pChainEntry[i]->m_dwChainID == dwChainID)
			return (m_pChainEntry[i]->m_pObject)->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, m_pChainEntry[i]->m_dwMsgMapID);
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CWndClassInfo

ATOM CWndClassInfo::Register(WNDPROC* pProc)
{
	if (m_atom == 0)
	{
		::EnterCriticalSection(&_Module.m_csWindowCreate);
		__try 
		{
			if(m_atom == 0)
			{
				HINSTANCE hInst = _Module.GetModuleInstance();
				if (m_lpszOrigName != NULL)
				{
					_ASSERTE(pProc != NULL);
					LPCTSTR lpsz = m_wc.lpszClassName;
					WNDPROC proc = m_wc.lpfnWndProc;

					WNDCLASSEX wc;
					wc.cbSize = sizeof(WNDCLASSEX);
					if(!::GetClassInfoEx(NULL, m_lpszOrigName, &wc))
					{
						::LeaveCriticalSection(&_Module.m_csWindowCreate);
						return 0;
					}
					memcpy(&m_wc, &wc, sizeof(WNDCLASSEX));
					pWndProc = m_wc.lpfnWndProc;
					m_wc.lpszClassName = lpsz;
					m_wc.lpfnWndProc = proc;
				}
				else
				{
					m_wc.hCursor = ::LoadCursor(m_bSystemCursor ? NULL : hInst,
						m_lpszCursorID);
				}

				m_wc.hInstance = hInst;
				m_wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes
				if (m_wc.lpszClassName == NULL)
				{
#ifdef _WIN64       // %p isn't available on Win2k/Win9x
                                        wnsprintf(m_szAutoName, sizeof(m_szAutoName)/sizeof(m_szAutoName[0]), _T("ATL:%p"), &m_wc);
#else
                                        wnsprintf(m_szAutoName, sizeof(m_szAutoName)/sizeof(m_szAutoName[0]), _T("ATL:%8.8X"), PtrToUlong(&m_wc));
#endif
					m_wc.lpszClassName = m_szAutoName;
				}
				WNDCLASSEX wcTemp;
				memcpy(&wcTemp, &m_wc, sizeof(WNDCLASSEX));
				m_atom = (ATOM) ::GetClassInfoEx(m_wc.hInstance, m_wc.lpszClassName, &wcTemp);
				if (m_atom == 0)
					m_atom = ::RegisterClassEx(&m_wc);
			}
		}
		__finally 
		{
			::LeaveCriticalSection(&_Module.m_csWindowCreate);
		}
	}

	if (m_lpszOrigName != NULL)
	{
		_ASSERTE(pProc != NULL);
		_ASSERTE(pWndProc != NULL);
		*pProc = pWndProc;
	}
	return m_atom;
}

/////////////////////////////////////////////////////////////////////////////
// CWindowImpl

LRESULT CALLBACK CWindowImplBase::StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBase* pT = (CWindowImplBase*)_Module.ExtractCreateWndData();
	_ASSERTE(pT != NULL);
	pT->m_hWnd = hWnd;
	pT->m_thunk.Init(WindowProc, pT);
	WNDPROC pProc = (WNDPROC)(pT->m_thunk.thunk.pThunk);
	::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	// if somebody has subclassed us already we can't do anything,
	// so discard return value from SetWindowLong
	return pProc(hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK CWindowImplBase::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBase* pT = (CWindowImplBase*)hWnd;
	LRESULT lRes;
	BOOL bRet = pT->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, 0);
	if(uMsg == WM_NCDESTROY)
	{
		pT->m_hWnd = NULL;
		return 0;
	}
	if(bRet)
		return lRes;
	return pT->DefWindowProc(uMsg, wParam, lParam);
}

#ifdef _WIN64
static LONG g_nNextWindowID;  // Intentionally left uninitialized.
#endif

HWND CWindowImplBase::Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
		DWORD dwStyle, DWORD dwExStyle, UINT_PTR nID, ATOM atom)
{
	_ASSERTE(m_hWnd == NULL);

	if(atom == 0)
		return NULL;

	_Module.AddCreateWndData(&m_thunk.cd, this);

	if(nID == 0 && (dwStyle & WS_CHILD))
   {
#ifdef _WIN64
      nID = InterlockedIncrement( &g_nNextWindowID );
      nID |= 0x80000000;  // Make sure the ID isn't zero
#else
      nID = (UINT)this;
#endif
   }

	HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)(LONG_PTR)MAKELONG(atom, 0), szWindowName,
		dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left,
		rcPos.bottom - rcPos.top, hWndParent, (HMENU)nID,
		_Module.GetModuleInstance(), NULL);

	_ASSERTE(m_hWnd == hWnd);

	return hWnd;
}

BOOL CWindowImplBase::SubclassWindow(HWND hWnd)
{
	_ASSERTE(m_hWnd == NULL);
	_ASSERTE(::IsWindow(hWnd));
	m_thunk.Init(WindowProc, this);
	WNDPROC pProc = (WNDPROC)(m_thunk.thunk.pThunk);
	WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	if(pfnWndProc == NULL)
		return FALSE;
	m_pfnSuperWindowProc = pfnWndProc;
	m_hWnd = hWnd;
	return TRUE;
}

HWND CWindowImplBase::UnsubclassWindow()
{
	_ASSERTE(m_hWnd != NULL);

	if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
		return NULL;

	m_pfnSuperWindowProc = ::DefWindowProc;

	HWND hWnd = m_hWnd;
	m_hWnd = NULL;

	return hWnd;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogImplBase

INT_PTR CALLBACK CDialogImplBase::StartDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CDialogImplBase* pT = (CDialogImplBase*)_Module.ExtractCreateWndData();
	_ASSERTE(pT != NULL);
	pT->m_hWnd = hWnd;
	pT->m_thunk.Init((WNDPROC)DialogProc, pT);
	WNDPROC pProc = (WNDPROC)(pT->m_thunk.thunk.pThunk);
	::SetWindowLongPtr(hWnd, DWLP_DLGPROC, (LONG_PTR)pProc);
	// check if somebody has subclassed us already since we don't hold onto it
	ATLTRACE(_T("Subclassing through a hook discarded.\n"));
	return pProc(hWnd, uMsg, wParam, lParam);
}

INT_PTR CALLBACK CDialogImplBase::DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CDialogImplBase* pT = (CDialogImplBase*)hWnd;
	LRESULT lRes;
	if(pT->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, 0))
	{
		switch (uMsg)
		{
		case WM_COMPAREITEM:
		case WM_VKEYTOITEM:
		case WM_CHARTOITEM:
		case WM_INITDIALOG:
		case WM_QUERYDRAGICON:
		case WM_CTLCOLORMSGBOX:
		case WM_CTLCOLOREDIT:
		case WM_CTLCOLORLISTBOX:
		case WM_CTLCOLORBTN:
		case WM_CTLCOLORDLG:
		case WM_CTLCOLORSCROLLBAR:
		case WM_CTLCOLORSTATIC:
			return lRes;
			break;
		}
		if (lRes != 0)
			::SetWindowLongPtr(pT->m_hWnd, DWLP_MSGRESULT, lRes);
		return TRUE;
	}
	return FALSE;
}

BOOL CDialogImplBase::EndDialog(int nRetCode)
{
	_ASSERTE(m_hWnd);
	return ::EndDialog(m_hWnd, nRetCode);
}

/////////////////////////////////////////////////////////////////////////////
// CContainedWindow

LRESULT CALLBACK CContainedWindow::StartWindowProc(HWND hWnd, UINT uMsg,
	WPARAM wParam, LPARAM lParam)
{
	CContainedWindow* pThis = (CContainedWindow*)_Module.ExtractCreateWndData();
	_ASSERTE(pThis != NULL);
	pThis->m_hWnd = hWnd;
	pThis->m_thunk.Init(pThis->WindowProc, pThis);
	WNDPROC pProc = (WNDPROC)(pThis->m_thunk.thunk.pThunk);
	::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	// check if somebody has subclassed us already since we don't hold onto it
	ATLTRACE(_T("Subclassing through a hook discarded.\n"));
	return pProc(hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK CContainedWindow::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	CContainedWindow* pT = (CContainedWindow*)hWnd;
	_ASSERTE(pT->m_hWnd != NULL);
	_ASSERTE(pT->m_pObject != NULL);

	LRESULT lRes;
	BOOL bRet = pT->m_pObject->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, pT->m_dwMsgMapID);
	if(uMsg == WM_NCDESTROY)
	{
		pT->m_hWnd = NULL;
		return 0;
	}
	if(bRet)
		return lRes;
	return pT->DefWindowProc(uMsg, wParam, lParam);
}

ATOM CContainedWindow::RegisterWndSuperclass()
{
	ATOM atom = 0;
	DWORD cchBuff = lstrlen(m_lpszClassName) + 14;
	LPTSTR szBuff = (LPTSTR)_alloca(cchBuff * sizeof(TCHAR));

	WNDCLASSEX wc;
	wc.cbSize = sizeof(WNDCLASSEX);

	if(::GetClassInfoEx(NULL, m_lpszClassName, &wc))
	{
		m_pfnSuperWindowProc = wc.lpfnWndProc;

		wnsprintf(szBuff, cchBuff, _T("ATL:%s"), m_lpszClassName);

		WNDCLASSEX wc1;
		wc1.cbSize = sizeof(WNDCLASSEX);
		atom = (ATOM)::GetClassInfoEx(_Module.GetModuleInstance(), szBuff, &wc1);

		if(atom == 0)   // register class
		{
			wc.lpszClassName = szBuff;
			wc.lpfnWndProc = StartWindowProc;
			wc.hInstance = _Module.GetModuleInstance();
			wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes

			atom = ::RegisterClassEx(&wc);
		}
	}

	return atom;
}

HWND CContainedWindow::Create(HWND hWndParent, RECT& rcPos,
	LPCTSTR szWindowName, DWORD dwStyle, DWORD dwExStyle, UINT nID)
{
	_ASSERTE(m_hWnd == NULL);

	ATOM atom = RegisterWndSuperclass();
	if(atom == 0)
		return NULL;

	_Module.AddCreateWndData(&m_thunk.cd, this);

	if(nID == 0 && (dwStyle & WS_CHILD))
   {
#ifdef _WIN64
      nID = InterlockedIncrement( &g_nNextWindowID );
      nID |= 0x80000000;  // Make sure the ID isn't zero
#else
      nID = (UINT)this;
#endif
   }

	HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)(LONG_PTR)MAKELONG(atom, 0), szWindowName,
							dwStyle,
							rcPos.left, rcPos.top,
							rcPos.right - rcPos.left,
							rcPos.bottom - rcPos.top,
							hWndParent, (HMENU)(DWORD_PTR)nID,
							_Module.GetModuleInstance(), this);

	_ASSERTE(m_hWnd == hWnd);
	return hWnd;
}

BOOL CContainedWindow::SubclassWindow(HWND hWnd)
{
	_ASSERTE(m_hWnd == NULL);
	_ASSERTE(::IsWindow(hWnd));

	m_thunk.Init(WindowProc, this);
	WNDPROC pProc = (WNDPROC)m_thunk.thunk.pThunk;
   WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	if(pfnWndProc == NULL)
		return FALSE;
	m_pfnSuperWindowProc = pfnWndProc;
	m_hWnd = hWnd;
	return TRUE;
}

HWND CContainedWindow::UnsubclassWindow()
{
	_ASSERTE(m_hWnd != NULL);

   if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
		return NULL;
	m_pfnSuperWindowProc = ::DefWindowProc;

	HWND hWnd = m_hWnd;
	m_hWnd = NULL;

	return hWnd;
}

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

///////////////////////////////////////////////////////////////////////////////
//All Global stuff goes below this line
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\capiutil.h ===
#ifndef __CAPIUTIL_H
#define __CAPIUTIL_H
#include <msoert.h>
#endif // __CAPIUTIL_H

/*
**  c a p i u t i l . h
**   
**  Purpose:
**      A few helper functions for the crypt32 utilities
**
**  History
**      5/22/97: (t-erikne) Created.
**   
**    Copyright (C) Microsoft Corp. 1997.
*/

#ifndef __WINCRYPT_H__
#define _CRYPT32_
#include <wincrypt.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\bytestm.h ===
// --------------------------------------------------------------------------------
// Bytestm.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __BYTESTM_H
#define __BYTESTM_H

// -----------------------------------------------------------------------------
// Acquire Byte Stream Data Types
// -----------------------------------------------------------------------------
typedef enum tagACQUIRETYPE {
    ACQ_COPY,           // Don't reset the object (CByteStream will free m_pbData)
    ACQ_DISPLACE        // ResetObject after acquire, the caller owns the bits
} ACQUIRETYPE;

// -----------------------------------------------------------------------------
// CByteStream
// -----------------------------------------------------------------------------
class CByteStream : public IStream
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CByteStream(LPBYTE pb=NULL, ULONG cb=0);
    ~CByteStream(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
    STDMETHODIMP Read(LPVOID, ULONG, ULONG *);
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
    STDMETHODIMP Stat(STATSTG *, DWORD);
    STDMETHODIMP Write(const void *, ULONG, ULONG *);
    STDMETHODIMP SetSize(ULARGE_INTEGER);
    STDMETHODIMP Commit(DWORD) { return S_OK; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *) { return E_NOTIMPL; }
    STDMETHODIMP Revert(void) { return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *) { return E_NOTIMPL; }

    // -------------------------------------------------------------------------
    // CByteStream Methods
    // -------------------------------------------------------------------------
    void AcquireBytes(ULONG *pcb, LPBYTE *ppb, ACQUIRETYPE actype);
    HRESULT HrAcquireStringA(ULONG *pcch, LPSTR *ppszStringA, ACQUIRETYPE actype);
    HRESULT HrAcquireStringW(ULONG *pcch, LPWSTR *ppszStringW, ACQUIRETYPE actype);

private:
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    void ResetObject(void);
    HRESULT _HrGrowBuffer(ULONG cbNeeded, ULONG cbExtra);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    ULONG            m_cRef;                // Reference count
    ULONG            m_cbData;              // Number of valid bytes in m_pbData
    ULONG            m_cbAlloc;             // Current allocated size of m_pbData
    ULONG            m_iData;               // Current data index
    LPBYTE           m_pbData;              // Pointer to data buffer
};

#endif // __BYTESTM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\badstrfunctions.h ===
/*****************************************************************************\
    FILE: BadStrFunctions.cpp

    DESCRIPTION:
        These header file will map string functions that tend to cause Buffer
    OverFlow bugs to warning messages that offer better functions.

    BryanSt 1/13/2002 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2002-2002. All rights reserved.
\*****************************************************************************/

#ifndef BADSTRFUNCTIONS_H
#define BADSTRFUNCTIONS_H



#undef wsprintf
#undef wsprintfA
#undef wsprintfW

#define wsprintf          USE_wnsprintf_INSTEADOF_wsprintf_SECURITY_BUG
#define wsprintfA         USE_wnsprintfA_INSTEADOF_wsprintfA_SECURITY_BUG
#define wsprintfW         USE_wnsprintfW_INSTEADOF_wsprintfW_SECURITY_BUG

#undef sprintf
#undef sprintfA
#undef sprintfW

#define sprintf           USE_UNDERSCOREsprintf_INSTEADOF_sprintf_SECURITY_BUG
#define sprintfA          USE_UNDERSCOREsprintfA_INSTEADOF_sprintfA_SECURITY_BUG
#define sprintfW          USE_UNDERSCOREsprintfW_INSTEADOF_sprintfW_SECURITY_BUG

#undef wvsprintf
#undef wvsprintfA
#undef wvsprintfW

#define wvsprintf           USE_wvnsprintf_INSTEADOF_wvsprintf_SECURITY_BUG
#define wvsprintfA          USE_wvnsprintfA_INSTEADOF_wvsprintfA_SECURITY_BUG
#define wvsprintfW          USE_wvnsprintfW_INSTEADOF_wvsprintfW_SECURITY_BUG

#undef vsprintf
#undef _vstprintf
#undef vswprintf

#define vsprintf           USE_wvnsprintf_INSTEADOF_vsnprintf_SECURITY_BUG
#define _vstprintf         USE_wvnsprintf_INSTEADOF_vsntprintf_SECURITY_BUG
#define vswprintf          USE_wvnsprintf_INSTEADOF_vsnwprintf_SECURITY_BUG

// Over time, we want to enable these:
#undef strcpy
#undef strcpyA
#undef strcpyW
#undef lstrcpy
#undef lstrcpyA
#undef lstrcpyW

#undef wcscpy
#undef _tcscpy
#undef _ftcscpy
#undef _mbscpy
#undef _mbccpy
#undef _mbsnbcpy
#undef _mbsncpy
#undef _tccpy

#define strcpy            USE_StrCpyN_INSTEADOF_strcpy_SECURITY_BUG
#define strcpyA           USE_StrCpyNA_INSTEADOF_strcpyA_SECURITY_BUG
#define strcpyW           USE_StrCpyNW_INSTEADOF_strcpyW_SECURITY_BUG
#define lstrcpy           USE_StrCpyN_INSTEADOF_lstrcpy_SECURITY_BUG
#define lstrcpyA          USE_StrCpyNA_INSTEADOF_lstrcpyA_SECURITY_BUG
#define lstrcpyW          USE_StrCpyNW_INSTEADOF_lstrcpyW_SECURITY_BUG

#define wcscpy            USE_StrCpyNW_INSTEADOF_wcscpy_SECURITY_BUG
#define _tcscpy           USE_StrCpyNW_INSTEADOF_tcscpy_SECURITY_BUG
#define _ftcscpy          USE_StrCpyNW_INSTEADOF_ftcscpy_SECURITY_BUG
#define _mbscpy           USE_StrCpyNW_INSTEADOF__mbscpy_SECURITY_BUG
#define _mbccpy           USE_StrCpyNW_INSTEADOF__mbccpy_SECURITY_BUG
#define _mbsnbcpy         USE_StrCpyNW_INSTEADOF__mbsnbcpy_SECURITY_BUG
#define _mbsncpy          USE_StrCpyNW_INSTEADOF__mbsncpy_SECURITY_BUG
#define _tccpy            USE_StrCpyNW_INSTEADOF__tccpy_SECURITY_BUG

/*
#undef strcat
#undef strcatA
#undef strcatW
#undef lstrcat
#undef lstrcatA
#undef lstrcatW
*/
#undef wcscat
#undef _tcscat
#undef _ftcscat
#undef _mbscat
#undef _mbsnbcat
#undef _mbsncat

/*
#define strcat            USE_StrCatBuff_INSTEADOF_strcat_SECURITY_BUG
#define strcatA           USE_StrCatBuffA_INSTEADOF_strcatA_SECURITY_BUG
#define strcatW           USE_StrCatBuffW_INSTEADOF_strcatW_SECURITY_BUG
#define lstrcat           USE_StrCatBuff_INSTEADOF_lstrcat_SECURITY_BUG
#define lstrcatA          USE_StrCatBuffA_INSTEADOF_lstrcatA_SECURITY_BUG
#define lstrcatW          USE_StrCatBuffW_INSTEADOF_lstrcatW_SECURITY_BUG
*/

#define wcscat            USE_StrCatBuffW_INSTEADOF_wcscat_SECURITY_BUG
#define _tcscat           USE_StrCatBuff_INSTEADOF__tcscat_SECURITY_BUG
#define _ftcscat          USE_StrCatBuff_INSTEADOF__ftcscat_SECURITY_BUG
#define _mbscat           USE_StrCatBuff_INSTEADOF__mbscat_SECURITY_BUG
#define _mbsnbcat         USE_StrCatBuff_INSTEADOF__mbsnbcat_SECURITY_BUG
#define _mbsncat          USE_StrCatBuff_INSTEADOF__mbsncat_SECURITY_BUG



#undef _makepath
#undef _tmakepath
#undef _wmakepath
#undef _fullpath
#undef _tfullpath
#undef _wfullpath
#undef _wsplitpath
#undef _tsplitpath

#define _makepath         USE_PathAppend_INSTEADOF_makepath_SECURITY_BUG
#define _tmakepath        USE_PathAppend_INSTEADOF_tmakepath_SECURITY_BUG
#define _wmakepath        USE_PathAppend_INSTEADOF_wmakepath_SECURITY_BUG
#define _fullpath         USE_PathAppend_INSTEADOF_fullpath_SECURITY_BUG
#define _tfullpath        USE_PathAppend_INSTEADOF_tfullpath_SECURITY_BUG
#define _wfullpath        USE_PathAppend_INSTEADOF_wfullpath_SECURITY_BUG
#define _wsplitpath       USE_PathAppend_INSTEADOF_wsplitpath_SECURITY_BUG
#define _tsplitpath       USE_PathAppend_INSTEADOF__tsplitpath_SECURITY_BUG



#endif // BADSTRFUNCTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\bmapi.h ===
#include <wtypes.h>
//#include <oaidl.h>
#include <oleauto.h>
#include <mapi.h>

// Structures and Functions used by BMAPI and VB2C

#define RECIPIENT   	((USHORT)0x0001)
#define FILE        	((USHORT)0x0002)
#define MESSAGE     	((USHORT)0x0004)
#define USESAFEARRAY	((USHORT)0x1000)

#if defined (WIN32)
#ifndef BMAPI_ENTRY                         		 // PFP
  #define BMAPI_ENTRY  ULONG FAR PASCAL    // define BMAPI_ENTRY  PFP
#endif                                      		 // PFP
#else
#ifndef BMAPI_ENTRY                         		 // PFP
  #define BMAPI_ENTRY  ULONG __export FAR PASCAL    // define BMAPI_ENTRY  PFP
#endif                                      		 // PFP
#endif

#ifndef LHANDLE
  #define LHANDLE ULONG
#endif

#ifndef ERR
  #define ERR 	USHORT
#endif


//-----------------------------------------------------------------------
// WIN32 definitions of 32 bit VB interface function support
//-----------------------------------------------------------------------
typedef struct
{
	ULONG	ulReserved;
	BSTR 	bstrSubject;
	BSTR 	bstrNoteText;
	BSTR 	bstrMessageType;
	BSTR 	bstrDate;
	BSTR 	bstrConversationID;
	ULONG 	flFlags;
	ULONG 	nRecipCount;
	ULONG 	nFileCount;
} VB_Message,FAR *lpVB_Message;

typedef VB_Message VB_MESSAGE;
typedef VB_Message FAR *LPVB_MESSAGE;


typedef struct
{
	ULONG 	ulReserved;
	ULONG 	ulRecipClass;
	BSTR 	bstrName;
	BSTR 	bstrAddress;
	ULONG 	ulEIDSize;
	BSTR 	bstrEID;
} VB_Recip,FAR *lpVB_Recip;

typedef VB_Recip VB_RECIPIENT;
typedef VB_Recip FAR *LPVB_RECIPIENT;


typedef struct
{
	ULONG 	ulReserved;
	ULONG 	flFlags;
	ULONG 	nPosition;
	BSTR 	bstrPathName;
	BSTR 	bstrFileName;
	BSTR 	bstrFileType;
} VB_File, FAR *lpVB_File;

/*

// OLEAUT32.DLL loadlib and getprocaddress support

// WINOLEAUTAPI_(void) SysFreeString(BSTR);
typedef VOID (STDAPICALLTYPE *LPFNSYSFREESTRING)
	( BSTR bstr );

// WINOLEAUTAPI_(unsigned int) SysStringByteLen(BSTR bstr);
typedef UINT (STDAPICALLTYPE *LPFNSYSSTRINGBYTELEN)
	(BSTR bstr);

// WINOLEAUTAPI_(BSTR) SysAllocString(const OLECHAR FAR*);
typedef BSTR (STDAPICALLTYPE *LPFNSYSALLOCSTRING)
	(const OLECHAR * szwString);

// WINOLEAUTAPI_(int)  SysReAllocString(BSTR FAR*, const OLECHAR FAR*);
typedef INT (STDAPICALLTYPE *LPFNSYSREALLOCSTRING)
	(BSTR * lpBstr, const OLECHAR * szwString);

// WINOLEAUTAPI_(unsigned int) SysStringLen(BSTR);
typedef UINT (STDAPICALLTYPE *LPFNSYSSTRINGLEN)
	(BSTR bstr);

// WINOLEAUTAPI SafeArrayAccessData(SAFEARRAY FAR* psa, void HUGEP* FAR* ppvData);
typedef HRESULT (STDAPICALLTYPE *LPFNSAFEARRAYACCESSDATA)
	(struct tagSAFEARRAY *psa, void **ppvData);

// WINOLEAUTAPI SafeArrayUnaccessData(SAFEARRAY FAR* psa);
typedef HRESULT (STDAPICALLTYPE *LPFNSAFEARRAYUNACCESSDATA)
	(struct tagSAFEARRAY *psa);

extern LPFNSYSFREESTRING 			lpfnSysFreeString;
extern LPFNSYSSTRINGBYTELEN 		lpfnSysStringByteLen;
extern LPFNSYSALLOCSTRING			lpfnSysAllocString;
extern LPFNSYSREALLOCSTRING			lpfnSysReAllocString;
extern LPFNSYSSTRINGLEN				lpfnSysStringLen;
extern LPFNSAFEARRAYACCESSDATA		lpfnSafeArrayAccessData;
extern LPFNSAFEARRAYUNACCESSDATA	lpfnSafeArrayUnaccessData;

#undef SysFreeString
#undef SysStringByteLen
#undef SysAllocString
#undef SysReAllocString
#undef SysStringLen
#undef SafeArrayAccessData
#undef SafeArrayUnaccessData
  

#define SysFreeString			(*lpfnSysFreeString)
#define SysStringByteLen 		(*lpfnSysStringByteLen)
#define SysAllocString			(*lpfnSysAllocString)
#define SysReAllocString		(*lpfnSysReAllocString)
#define SysStringLen			(*lpfnSysStringLen)
#define SafeArrayAccessData		(*lpfnSafeArrayAccessData)
#define SafeArrayUnaccessData	(*lpfnSafeArrayUnaccessData)
  
    */



typedef VB_File 			VB_FILE;
typedef VB_File FAR *		LPVB_FILE;

typedef MapiMessage 		VB_MAPI_MESSAGE;
typedef MapiMessage FAR *	LPMAPI_MESSAGE;
typedef LPMAPI_MESSAGE FAR *LPPMAPI_MESSAGE;


typedef MapiRecipDesc 		MAPI_RECIPIENT;
typedef MapiRecipDesc FAR *	LPMAPI_RECIPIENT;
typedef LPMAPI_RECIPIENT FAR *LPPMAPI_RECIPIENT;

typedef MapiFileDesc 		MAPI_FILE;
typedef MapiFileDesc FAR *	LPMAPI_FILE;
typedef LPMAPI_FILE FAR *	LPPMAPI_FILE;

typedef HANDLE FAR *		LPHANDLE;

typedef VB_File 			VB_FILE;
typedef VB_File FAR * 		LPVB_FILE;

typedef MapiMessage 		VB_MAPI_MESSAGE;
typedef MapiMessage FAR *	LPMAPI_MESSAGE;
typedef LPMAPI_MESSAGE FAR *LPPMAPI_MESSAGE;


typedef MapiRecipDesc 		MAPI_RECIPIENT;
typedef MapiRecipDesc FAR *	LPMAPI_RECIPIENT;
typedef LPMAPI_RECIPIENT FAR *LPPMAPI_RECIPIENT;

typedef MapiFileDesc 		MAPI_FILE;
typedef MapiFileDesc FAR *	LPMAPI_FILE;
typedef LPMAPI_FILE FAR *	LPPMAPI_FILE;

typedef HANDLE FAR *		LPHANDLE;
typedef LPHANDLE FAR *		LPPHANDLE;

/*
#if defined WIN32




//-----------------------------------------------------------------------
// WIN32 definitions of 32 bit VB interface functions
//-----------------------------------------------------------------------
BMAPI_ENTRY BMAPISendMail (LHANDLE 			hSession,
                           ULONG 			ulUIParam,
                           LPVB_MESSAGE 	lpM,
                           LPSAFEARRAY *    lppsaRecips,
                           LPSAFEARRAY * 	lppsaFiles,
                           ULONG 			flFlags,
                           ULONG 			ulReserved);

BMAPI_ENTRY BMAPIFindNext(LHANDLE 	hSession,
                          ULONG 	ulUIParam,
                          BSTR * 	bstrType,
                          BSTR * 	bstrSeed,
                          ULONG 	flFlags,
                          ULONG 	ulReserved,
                          BSTR * 	lpbstrId);

BMAPI_ENTRY BMAPIReadMail (LPULONG 	lpulMessage,
                           LPULONG 	nRecips,
                           LPULONG 	nFiles,
                           LHANDLE 	hSession,
                           ULONG 	ulUIParam,
                           BSTR * 	lpbstrID,
                           ULONG 	flFlags,
                           ULONG 	ulReserved);

BMAPI_ENTRY BMAPIGetReadMail(ULONG 			lpMessage,
                             LPVB_MESSAGE 	lpvbMessage,
                             LPSAFEARRAY *  lppsaRecips,
                             LPSAFEARRAY *	lppsaFiles,
                             LPVB_RECIPIENT	lpvbOrig);

BMAPI_ENTRY BMAPISaveMail( LHANDLE 			hSession,
                           ULONG 			ulUIParam,
                           LPVB_MESSAGE 	lpM,
                           LPSAFEARRAY * 	lppsaRecips,
                           LPSAFEARRAY *	lppsaFiles,
                           ULONG 			flFlags,
                           ULONG 			ulReserved,
                           BSTR * 			lpbstrID);

BMAPI_ENTRY BMAPIAddress (LPULONG 			lpulRecip,
                          LHANDLE 			hSession,
                          ULONG 			ulUIParam,
                          BSTR * 			lpbstrCaption,
                          ULONG 			ulEditFields,
                          BSTR * 			lpbstrLabel,
                          LPULONG 			lpulRecipients,
                          LPSAFEARRAY * 	lppsaRecip,		// LPVB_RECIPIENT
                          ULONG 			ulFlags,
                          ULONG 			ulReserved);

BMAPI_ENTRY BMAPIGetAddress (ULONG			ulRecipientData,
                             ULONG 			count,
                             LPSAFEARRAY *	lppsaRecips);

BMAPI_ENTRY BMAPIDetails (LHANDLE 			hSession,
                          ULONG 			ulUIParam,
                          LPVB_RECIPIENT	lpVB,
                          ULONG 			ulFlags,
                          ULONG 			ulReserved);

BMAPI_ENTRY BMAPIResolveName (LHANDLE			hSession,
                              ULONG 			ulUIParam,
                              BSTR  			bstrMapiName,
                              ULONG 			ulFlags,
                              ULONG 			ulReserved,
                              LPVB_RECIPIENT 	lpVB);
*/

typedef ULONG (FAR PASCAL BMAPISENDMAIL)(
    LHANDLE 		hSession,
    ULONG 			ulUIParam,
    LPVB_MESSAGE 	lpM,
    LPSAFEARRAY *    lppsaRecips,
    LPSAFEARRAY * 	lppsaFiles,
    ULONG 			flFlags,
    ULONG 			ulReserved
);
typedef BMAPISENDMAIL FAR *LPBMAPISENDMAIL;
BMAPISENDMAIL BMAPISendMail;


typedef ULONG (FAR PASCAL BMAPIFINDNEXT)(
    LHANDLE hSession,
    ULONG 	ulUIParam,
    BSTR * 	bstrType,
    BSTR * 	bstrSeed,
    ULONG 	flFlags,
    ULONG 	ulReserved,
    BSTR * 	lpbstrId
);
typedef BMAPIFINDNEXT FAR *LPBMAPIFINDNEXT;
BMAPIFINDNEXT BMAPIFindNext;


typedef ULONG (FAR PASCAL BMAPIREADMAIL)(
    LPULONG     lpulMessage,
    LPULONG     nRecips,
    LPULONG     nFiles,
    LHANDLE     hSession,
    ULONG 	    ulUIParam,
    BSTR * 	    lpbstrID,
    ULONG 	    flFlags,
    ULONG 	    ulReserved
);
typedef BMAPIREADMAIL FAR *LPBMAPIREADMAIL;
BMAPIREADMAIL BMAPIReadMail;


typedef ULONG (FAR PASCAL BMAPIGETREADMAIL)(
    ULONG 			lpMessage,
    LPVB_MESSAGE 	lpvbMessage,
    LPSAFEARRAY *  lppsaRecips,
    LPSAFEARRAY *	lppsaFiles,
    LPVB_RECIPIENT	lpvbOrig    
);
typedef BMAPIGETREADMAIL FAR *LPBMAPIGETREADMAIL;
BMAPIGETREADMAIL BMAPIGetReadMail;


typedef ULONG (FAR PASCAL BMAPISAVEMAIL)(
    LHANDLE 			hSession,
    ULONG 			    ulUIParam,
    LPVB_MESSAGE 	    lpM,
    LPSAFEARRAY * 	    lppsaRecips,
    LPSAFEARRAY *	    lppsaFiles,
    ULONG 			    flFlags,
    ULONG 			    ulReserved,
    BSTR * 			    lpbstrID
);
typedef BMAPISAVEMAIL FAR *LPBMAPISAVEMAIL;
BMAPISAVEMAIL BMAPISaveMail;


typedef ULONG (FAR PASCAL BMAPIADDRESS)(
    LPULONG 			lpulRecip,
    LHANDLE 			hSession,
    ULONG 			    ulUIParam,
    BSTR * 			    lpbstrCaption,
    ULONG 			    ulEditFields,
    BSTR * 			    lpbstrLabel,
    LPULONG 			lpulRecipients,
    LPSAFEARRAY * 	    lppsaRecip,		// LPVB_RECIPIENT
    ULONG 			    ulFlags,
    ULONG 			    ulReserved
);
typedef BMAPIADDRESS FAR *LPBMAPIADDRESS;
BMAPIADDRESS BMAPIAddress;


typedef ULONG (FAR PASCAL BMAPIGETADDRESS)(
    ULONG			ulRecipientData,
    ULONG 			count,
    LPSAFEARRAY *	lppsaRecips
);
typedef BMAPIGETADDRESS FAR *LPBMAPIGETADDRESS;
BMAPIGETADDRESS BMAPIGetAddress;


typedef ULONG (FAR PASCAL BMAPIDETAILS)(
    LHANDLE 			hSession,
    ULONG 			ulUIParam,
    LPVB_RECIPIENT	lpVB,
    ULONG 			ulFlags,
    ULONG 			ulReserved
);
typedef BMAPIDETAILS FAR *LPBMAPIDETAILS;
BMAPIDETAILS BMAPIDetails;


typedef ULONG (FAR PASCAL BMAPIRESOLVENAME)(
    LHANDLE			hSession,
    ULONG 			ulUIParam,
    BSTR  			bstrMapiName,
    ULONG 			ulFlags,
    ULONG 			ulReserved,
    LPVB_RECIPIENT 	lpVB
);
typedef BMAPIRESOLVENAME FAR *LPBMAPIRESOLVENAME;
BMAPIRESOLVENAME BMAPIResolveName;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\envcid.h ===
#ifndef _ENVCID_H
#define _ENVCID_H

#define MSOEENVCMDID_SEND                   1
#define MSOEENVCMDID_CHECKNAMES             2
#define MSOEENVCMDID_AUTOCOMPLETE           4
#define MSOEENVCMDID_SETACTION              5
#define MSOEENVCMDID_ADDALLONTO             6
#define MSOEENVCMDID_PRIORITY               7
#define MSOEENVCMDID_DIRTY                  8
#define MSOEENVCMDID_VCARD                  9
#define MSOEENVCMDID_NEWS                   10
#define MSOEENVCMDID_SETACCOUNT             11
#define MSOEENVCMDID_SELECTRECIPIENTS       12
#define MSOEENVCMDID_PICKNEWSGROUPS         13
#define MSOEENVCMDID_ADDSENDER              14
#define MSOEENVCMDID_DIGSIGN                15
#define MSOEENVCMDID_ENCRYPT                16
#define MSOEENVCMDID_VIEWCONTACTS           17
#define MSOEENVCMDID_ATTACHFILE             18
#define MSOEENVCMDID_FOCUSTO                19
#define MSOEENVCMDID_FOCUSCC                20
#define MSOEENVCMDID_FOCUSSUBJ              21

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\demand.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

//
// IF YOU #INCLUDE A FILE HERE YOU PROBABLY ARE CONFUSED.
// THIS FILE IS INCLUDED BY LOTS OF PEOPLE.  THINK THRICE
// BEFORE #INCLUDING *ANYTHING* HERE.  MAKE GOOD USE
// OF FORWARD REFS INSTEAD.
//

#define USE_CRITSEC

#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return;     \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;			\
        extern TYP_##name VAR_##name;                   

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;			\
        extern TYP_##name VAR_##name;

#endif // IMPLEMENT_LOADER_FUNCTIONS

extern HINSTANCE g_hInst;

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// CRYPT32.DLL

#define _CRYPT32_

BOOL DemandLoadCrypt32(void);

extern  BOOL    g_FSupportV3;
BOOL IsSMIME3Supported(void);

typedef void *HCERTSTORE;
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;
typedef ULONG_PTR HCRYPTPROV;
typedef struct _CERT_INFO *PCERT_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCERT_NAME_INFO;
typedef void *HCRYPTMSG;
typedef struct _CMSG_STREAM_INFO *PCMSG_STREAM_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCCERT_NAME_INFO;

LOADER_FUNCTION( DWORD, CertRDNValueToStrA,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPTSTR pszValueString, DWORD cszValueString),
    (dwValueType, pValue, pszValueString, cszValueString),
    NULL, Crypt32)
#define CertRDNValueToStrA VAR_CertRDNValueToStrA

LOADER_FUNCTION( BOOL, CertAddCertificateContextToStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext),
    (hCertStore, pCertContext, dwAddDisposition, ppStoreContext),
    FALSE, Crypt32)
#define CertAddCertificateContextToStore VAR_CertAddCertificateContextToStore

LOADER_FUNCTION( BOOL, CertAddEncodedCertificateToStore,
    (HCERTSTORE hCertStore,
     DWORD dwCertEncodingType,
     BYTE *pbCertEncoded,
     DWORD cbCertEncoded,
     DWORD dwAddDisposition,
     PCCERT_CONTEXT *ppStoreContext),
    (hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppStoreContext),
    FALSE, Crypt32)
#define CertAddEncodedCertificateToStore VAR_CertAddEncodedCertificateToStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertEnumCertificatesInStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, pPrevCertContext),
    NULL, Crypt32)
#define CertEnumCertificatesInStore VAR_CertEnumCertificatesInStore

LOADER_FUNCTION( BOOL, CryptDecodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObject VAR_CryptDecodeObject

LOADER_FUNCTION( BOOL, CryptEncodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void * pvStructInfo, BYTE * pbEncoded, DWORD * pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObject VAR_CryptEncodeObject

LOADER_FUNCTION( BOOL, CryptDecodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObjectEx VAR_CryptDecodeObjectEx

LOADER_FUNCTION( BOOL, CryptEncodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void * pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void * pbEncoded, DWORD * pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObjectEx VAR_CryptEncodeObjectEx


LOADER_FUNCTION(PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName),
    (pszObjId, pName),
    NULL, Crypt32)
#define CertFindRDNAttr VAR_CertFindRDNAttr

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    TRUE, Crypt32)  // return success since GLE() is meaningless
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext),
    NULL, Crypt32)
#define CertFindCertificateInStore VAR_CertFindCertificateInStore

LOADER_FUNCTION( LONG, CertVerifyTimeValidity,
    (LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo),
    (pTimeToVerify, pCertInfo),
    1, Crypt32)
#define CertVerifyTimeValidity VAR_CertVerifyTimeValidity

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

LOADER_FUNCTION( BOOL, CertCompareCertificateName,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2),
    (dwCertEncodingType, pCertName1, pCertName2),
    FALSE, Crypt32)
#define CertCompareCertificateName VAR_CertCompareCertificateName

LOADER_FUNCTION( BOOL, CertCompareIntegerBlob,
    (PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2),
    (pInt1, pInt2),
    FALSE, Crypt32)
#define CertCompareIntegerBlob VAR_CertCompareIntegerBlob

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv, DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( HCERTSTORE, CertDuplicateStore,
    (HCERTSTORE hCertStore),
    (hCertStore),
    NULL, Crypt32)
#define CertDuplicateStore VAR_CertDuplicateStore

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( BOOL, CertControlStore,
    (
        HCERTSTORE hCertStore,
        DWORD dwFlags,
        DWORD dwCtrlType,
        void const *pvCtrlPara
    ),
    (
        hCertStore,
        dwFlags,
        dwCtrlType,
        pvCtrlPara
    ),
    FALSE, Crypt32)
#define CertControlStore VAR_CertControlStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetSubjectCertificateFromStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId),
    (hCertStore, dwCertEncodingType, pCertId),
    NULL, Crypt32)
#define CertGetSubjectCertificateFromStore VAR_CertGetSubjectCertificateFromStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetIssuerCertificateFromStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags),
    (hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags),
    NULL, Crypt32)
#define CertGetIssuerCertificateFromStore VAR_CertGetIssuerCertificateFromStore

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToEncode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, void const *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToEncode VAR_CryptMsgOpenToEncode

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToDecode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToDecode VAR_CryptMsgOpenToDecode

LOADER_FUNCTION( BOOL, CryptMsgUpdate,
    (HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal),
    (hCryptMsg, pbData, cbData, fFinal),
    FALSE, Crypt32)
#define CryptMsgUpdate VAR_CryptMsgUpdate

LOADER_FUNCTION( BOOL, CryptMsgGetParam,
    (HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData),
    (hCryptMsg, dwParamType, dwIndex, pvData, pcbData),
    FALSE, Crypt32)
#define CryptMsgGetParam VAR_CryptMsgGetParam

LOADER_FUNCTION( BOOL, CryptMsgControl,
    (HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, void const *pvCtrlPara),
    (hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara),
    FALSE, Crypt32)
#define CryptMsgControl VAR_CryptMsgControl

LOADER_FUNCTION( BOOL, CryptMsgClose,
    (HCRYPTMSG hCryptMsg),
    (hCryptMsg),
    TRUE, Crypt32)  // return success since GLE() is meaningless
#define CryptMsgClose VAR_CryptMsgClose

LOADER_FUNCTION( BOOL, CertAddEncodedCRLToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext),
    (hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext),
    FALSE, Crypt32)
#define CertAddEncodedCRLToStore VAR_CertAddEncodedCRLToStore

LOADER_FUNCTION( PCCRL_CONTEXT, CertEnumCRLsInStore,
    (HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext),
    (hCertStore, pPrevCrlContext),
    NULL, Crypt32)
#define CertEnumCRLsInStore VAR_CertEnumCRLsInStore

LOADER_FUNCTION( PCERT_EXTENSION, CertFindExtension,
    (LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[]),
    (pszObjId, cExtensions, rgExtensions),
    NULL, Crypt32)
#define CertFindExtension VAR_CertFindExtension

LOADER_FUNCTION( PCERT_CONTEXT, CertCreateCertificateContext,
    (DWORD dwCertEncodingType, const BYTE * pbCertEncoded, DWORD cbCertEncoded),
    (dwCertEncodingType, pbCertEncoded, cbCertEncoded),
    NULL, Crypt32)
#define CertCreateCertificateContext VAR_CertCreateCertificateContext

LOADER_FUNCTION( DWORD, CertNameToStrA,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType,
    LPSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz),
    NULL, Crypt32)
#define CertNameToStrA VAR_CertNameToStrA

LOADER_FUNCTION( BOOL, CertGetEnhancedKeyUsage,
    (PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage,
     DWORD *pcbUsage),
    (pCertContext, dwFlags, pUsage, pcbUsage),
    FALSE, Crypt32)
#define CertGetEnhancedKeyUsage VAR_CertGetEnhancedKeyUsage

LOADER_FUNCTION( DWORD, CertAddStoreToCollection,
    (HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags,
     DWORD dwPriority),
    (hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority),
    NULL, Crypt32)
#define CertAddStoreToCollection VAR_CertAddStoreToCollection

LOADER_FUNCTION( BOOL, CertSetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData),
    (pCertContext, dwPropId, dwFlags, pvData),
    NULL, Crypt32)
#define CertSetCertificateContextProperty VAR_CertSetCertificateContextProperty

LOADER_FUNCTION( BOOL, CertVerifySubjectCertificateContext,
    (PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags),
    (pSubject, pIssuer, pdwFlags),
    FALSE, Crypt32)
#define CertVerifySubjectCertificateContext VAR_CertVerifySubjectCertificateContext

LOADER_FUNCTION_VOID( void, CertFreeCertificateChain,
    (PCCERT_CHAIN_CONTEXT pChainContext),
    (pChainContext),
    Crypt32)
#define CertFreeCertificateChain VAR_CertFreeCertificateChain

LOADER_FUNCTION( BOOL, CertGetCertificateChain,
    (HCERTCHAINENGINE hChainEngine, PCCERT_CONTEXT pCertContext, LPFILETIME pTime, HCERTSTORE hAdditionalStore, 
     PCERT_CHAIN_PARA pChainPara, DWORD dwFlags, LPVOID pvReserved, PCCERT_CHAIN_CONTEXT* ppChainContext),
    (hChainEngine, pCertContext, pTime, hAdditionalStore, pChainPara, dwFlags, pvReserved, ppChainContext),
    FALSE, Crypt32)
#define CertGetCertificateChain VAR_CertGetCertificateChain

LOADER_FUNCTION( BOOL, CertVerifyCertificateChainPolicy,
    (LPCSTR pszPolicyOID, PCCERT_CHAIN_CONTEXT pChainContext, PCERT_CHAIN_POLICY_PARA pPolicyPara, PCERT_CHAIN_POLICY_STATUS pPolicyStatus),
    (pszPolicyOID, pChainContext, pPolicyPara, pPolicyStatus),
    FALSE, Crypt32)
#define CertVerifyCertificateChainPolicy VAR_CertVerifyCertificateChainPolicy

/////////////////////////////////////
// CRYPTDLG.DLL

#define _CRYPTDLG_

// Old cert dialogs
typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A *PCERT_VIEWPROPERTIES_STRUCT_A;
typedef struct tagCSSA *PCERT_SELECT_STRUCT_A;

BOOL DemandLoadCryptDlg();

LOADER_FUNCTION( BOOL, CertViewPropertiesA,
    (PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo),
    (pCertViewInfo),
    FALSE, CryptDlg)
#define CertViewPropertiesA VAR_CertViewPropertiesA

LOADER_FUNCTION( DWORD, GetFriendlyNameOfCertA,
    (PCCERT_CONTEXT pccert, LPSTR pchBuffer, DWORD cchBuffer),
    (pccert, pchBuffer, cchBuffer),
    0, CryptDlg)
#define GetFriendlyNameOfCertA VAR_GetFriendlyNameOfCertA

LOADER_FUNCTION( BOOL, CertSelectCertificateA,
    (PCERT_SELECT_STRUCT_A pCertSelectInfo),
    (pCertSelectInfo),
    FALSE, CryptDlg)
#define CertSelectCertificateA VAR_CertSelectCertificateA

/////////////////////////////////////
// WINTRUST.DLL

BOOL DemandLoadWinTrust();

LOADER_FUNCTION( LONG, WinVerifyTrust,
    (HWND hwnd, GUID *ActionID, LPVOID ActionData),
    (hwnd, ActionID, ActionData),
    0, WinTrust)
#define WinVerifyTrust VAR_WinVerifyTrust

/////////////////////////////////////
// WININET.DLL

#include <wininet.h>

#define _WININET_

typedef struct _INTERNET_CACHE_ENTRY_INFOA INTERNET_CACHE_ENTRY_INFOA;

BOOL DemandLoadWinINET();

LOADER_FUNCTION( BOOL, RetrieveUrlCacheEntryFileA,
    (LPCSTR  lpszUrlName, INTERNET_CACHE_ENTRY_INFOA *lpCacheEntryInfo, LPDWORD lpdwCacheEntryInfoBufferSize, DWORD dwReserved),
    (lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize, dwReserved),
    FALSE, WinINET)
#define RetrieveUrlCacheEntryFileA VAR_RetrieveUrlCacheEntryFileA

LOADER_FUNCTION( BOOL, CommitUrlCacheEntryA,
    (LPCSTR lpszUrlName, LPCSTR lpszLocalFileName, FILETIME ExpireTime, FILETIME LastModifiedTime, DWORD CacheEntryType, LPBYTE lpHeaderInfo,
     DWORD dwHeaderSize, LPCSTR lpszFileExtension, LPCSTR lpszOriginalUrl),
    (lpszUrlName, lpszLocalFileName, ExpireTime, LastModifiedTime, CacheEntryType, lpHeaderInfo,
     dwHeaderSize, lpszFileExtension, lpszOriginalUrl),
    FALSE, WinINET)
#define CommitUrlCacheEntryA VAR_CommitUrlCacheEntryA

LOADER_FUNCTION( BOOL, CreateUrlCacheEntryA,
    (LPCSTR lpszUrlName, DWORD dwExpectedFileSize, LPCSTR lpszFileExtension, LPSTR lpszFileName, DWORD dwReserved),
    (lpszUrlName, dwExpectedFileSize, lpszFileExtension, lpszFileName, dwReserved),
    FALSE, WinINET)
#define CreateUrlCacheEntryA VAR_CreateUrlCacheEntryA
    
LOADER_FUNCTION( BOOL, DeleteUrlCacheEntryA,
    (LPCSTR lpszUrlName),
    (lpszUrlName),
    FALSE, WinINET)
#define DeleteUrlCacheEntryA VAR_DeleteUrlCacheEntryA

LOADER_FUNCTION( BOOL, UnlockUrlCacheEntryFileA,
    (LPCSTR  lpszUrlName, DWORD dwRes),
    (lpszUrlName, dwRes),
    FALSE, WinINET)
#define UnlockUrlCacheEntryFileA VAR_UnlockUrlCacheEntryFileA

LOADER_FUNCTION( BOOL, InternetQueryOptionA,
    (HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufferLength),
    (hInternet, dwOption, lpBuffer, lpdwBufferLength),
    NULL, WinINET)
#define InternetQueryOptionA VAR_InternetQueryOptionA

LOADER_FUNCTION( BOOL, InternetSetOptionA,
    (HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength),
    (hInternet, dwOption, lpBuffer, dwBufferLength),
    NULL, WinINET)
#define InternetSetOptionA VAR_InternetSetOptionA

LOADER_FUNCTION( BOOL, InternetDialA,
    (HWND hwndParent, LPSTR lpszConnectoid, DWORD dwFlags, DWORD_PTR *lpdwConnection, DWORD dwReserved),
    (hwndParent, lpszConnectoid, dwFlags, lpdwConnection, dwReserved),
    NULL, WinINET)
#define InternetDialA VAR_InternetDialA

LOADER_FUNCTION( BOOL, InternetHangUp,
    (DWORD_PTR dwConnection, DWORD dwReserved),
    (dwConnection, dwReserved),
    NULL, WinINET)
#define InternetHangUp VAR_InternetHangUp

LOADER_FUNCTION(BOOL, InternetGetConnectedStateExA, 
                (LPDWORD dwFlags,  LPTSTR szconn, DWORD size, DWORD reserved),
                (dwFlags, szconn, size, reserved),
                FALSE, WinINET)
#define InternetGetConnectedStateExA  VAR_InternetGetConnectedStateExA

LOADER_FUNCTION(BOOL, InternetCombineUrlA, 
                (LPCSTR lpszBaseUrl, LPCSTR lpszRelativeUrl, LPSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags),
                (lpszBaseUrl, lpszRelativeUrl, lpszBuffer, lpdwBufferLength, dwFlags),
                FALSE, WinINET)
#define InternetCombineUrlA  VAR_InternetCombineUrlA

LOADER_FUNCTION(BOOL, InternetCrackUrlA, 
                (LPCSTR lpszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTS lpUrlComponents),
                (lpszUrl, dwUrlLength, dwFlags, lpUrlComponents),
                FALSE, WinINET)
#define InternetCrackUrlA  VAR_InternetCrackUrlA

LOADER_FUNCTION(BOOL, InternetCloseHandle, 
                (HINTERNET hInternet),
                (hInternet),
                FALSE, WinINET)
#define   InternetCloseHandle   VAR_InternetCloseHandle

LOADER_FUNCTION(BOOL, InternetReadFile, 
                (HINTERNET hInternet, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead),
                (hInternet, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead),
                FALSE, WinINET)
#define   InternetReadFile   VAR_InternetReadFile

LOADER_FUNCTION(HINTERNET, InternetConnectA, 
                (HINTERNET hInternet, LPCSTR lpszServerName, INTERNET_PORT nServerPort,
                            LPCSTR lpszUserName,LPCSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext),
                (hInternet, lpszServerName, nServerPort, lpszUserName, lpszPassword, dwService, dwFlags, dwContext),
                NULL, WinINET)
#define   InternetConnectA   VAR_InternetConnectA

LOADER_FUNCTION(HINTERNET, InternetOpenA, 
                (LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags),
                (lpszAgent, dwAccessType, lpszProxy, lpszProxyBypass, dwFlags),
                NULL, WinINET)
#define   InternetOpenA   VAR_InternetOpenA

LOADER_FUNCTION(INTERNET_STATUS_CALLBACK, InternetSetStatusCallbackA,
                (HINTERNET hInternet, INTERNET_STATUS_CALLBACK lpfnInternetCallback),
                (hInternet, lpfnInternetCallback),
                NULL, WinINET)
#define   InternetSetStatusCallbackA   VAR_InternetSetStatusCallbackA

LOADER_FUNCTION(BOOL, HttpQueryInfoA, 
                (HINTERNET hRequest, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex),
                (hRequest, dwInfoLevel, lpBuffer, lpdwBufferLength, lpdwIndex),
                FALSE, WinINET)
#define   HttpQueryInfoA   VAR_HttpQueryInfoA

LOADER_FUNCTION(HINTERNET, HttpOpenRequestA, 
                (HINTERNET hConnect, LPCSTR lpszVerb, LPCSTR lpszObjectName, LPCSTR lpszVersion,
                            LPCSTR lpszReferrer, LPCSTR FAR * lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext),
                ( hConnect, lpszVerb, lpszObjectName, lpszVersion, lpszReferrer, lplpszAcceptTypes, dwFlags, dwContext),
                NULL, WinINET)
#define   HttpOpenRequestA   VAR_HttpOpenRequestA

LOADER_FUNCTION(BOOL, HttpAddRequestHeadersA, 
                (HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwModifiers),
                (hRequest, lpszHeaders, dwHeadersLength, dwModifiers),
                FALSE, WinINET)
#define   HttpAddRequestHeadersA   VAR_HttpAddRequestHeadersA

LOADER_FUNCTION(BOOL, HttpSendRequestA, 
                (HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength),
                (hRequest, lpszHeaders, dwHeadersLength, lpOptional, dwOptionalLength),
                FALSE, WinINET)
#define   HttpSendRequestA   VAR_HttpSendRequestA

LOADER_FUNCTION(BOOL, InternetWriteFile, 
                (HINTERNET hFile, LPCVOID lpBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD lpdwNumberOfBytesWritten),
                (hFile, lpBuffer, dwNumberOfBytesToWrite, lpdwNumberOfBytesWritten),
                FALSE, WinINET)
#define   InternetWriteFile   VAR_InternetWriteFile

LOADER_FUNCTION(BOOL, HttpEndRequestA, 
                (HINTERNET hRequest, LPINTERNET_BUFFERSA lpBuffersOut, DWORD dwFlags, DWORD_PTR dwContext),
                (hRequest, lpBuffersOut, dwFlags, dwContext),
                FALSE, WinINET)
#define   HttpEndRequestA   VAR_HttpEndRequestA

LOADER_FUNCTION(BOOL, HttpSendRequestExA, 
                (HINTERNET hRequest, LPINTERNET_BUFFERSA lpBuffersIn,
                                LPINTERNET_BUFFERSA lpBuffersOut, DWORD dwFlags, DWORD_PTR dwContext),
                (hRequest, lpBuffersIn, lpBuffersOut, dwFlags, dwContext),
                FALSE, WinINET)
#define   HttpSendRequestExA   VAR_HttpSendRequestExA

/////////////////////////////////////
// SHELL32.DLL

#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>

BOOL DemandLoadSHELL32();

LOADER_FUNCTION(BOOL, SHFree, // Actually a void
   (LPVOID lpv),
   (lpv),
   FALSE, SHELL32)
#define SHFree VAR_SHFree

LOADER_FUNCTION(BOOL, SHGetPathFromIDListA,
    (LPCITEMIDLIST pidl, LPSTR pszPath),
    (pidl, pszPath),
    FALSE, SHELL32)
#define SHGetPathFromIDListA VAR_SHGetPathFromIDListA

LOADER_FUNCTION(BOOL, SHGetPathFromIDListW,
    (LPCITEMIDLIST pidl, LPWSTR pwszPath),
    (pidl, pwszPath),
    FALSE, SHELL32)
#define SHGetPathFromIDListW VAR_SHGetPathFromIDListW

LOADER_FUNCTION(HRESULT, SHGetSpecialFolderLocation,
    (HWND hwndOwner, int nFolder, LPITEMIDLIST * ppidl),
    (hwndOwner, nFolder, ppidl),
    E_FAIL, SHELL32)
#define SHGetSpecialFolderLocation VAR_SHGetSpecialFolderLocation

LOADER_FUNCTION(LPITEMIDLIST, SHBrowseForFolderA,
    (LPBROWSEINFOA lpbi),
    (lpbi),
    NULL, SHELL32)
#define SHBrowseForFolderA VAR_SHBrowseForFolderA

LOADER_FUNCTION(LPITEMIDLIST, SHBrowseForFolderW,
    (LPBROWSEINFOW lpbi),
    (lpbi),
    NULL, SHELL32)
#define SHBrowseForFolderW VAR_SHBrowseForFolderW

LOADER_FUNCTION(HRESULT, SHSetUnreadMailCountW,
    (LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand),
    (pszMailAddress, dwCount, pszShellExecuteCommand),
    NULL, SHELL32)
#define SHSetUnreadMailCountW VAR_SHSetUnreadMailCountW

LOADER_FUNCTION(HINSTANCE, ShellExecuteA,
    (HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd),
    (hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd),
    NULL, SHELL32)
#define ShellExecuteA VAR_ShellExecuteA

LOADER_FUNCTION(BOOL, ShellExecuteExA,
    (LPSHELLEXECUTEINFOA lpExecInfo),
    (lpExecInfo),
    FALSE, SHELL32)
#define ShellExecuteExA VAR_ShellExecuteExA

LOADER_FUNCTION(UINT, DragQueryFileA,
    (HDROP hDrop, UINT iFile, LPSTR lpszFile, UINT cb),
    (hDrop, iFile, lpszFile, cb),
    0, SHELL32)
#define DragQueryFileA VAR_DragQueryFileA

LOADER_FUNCTION(DWORD, SHGetFileInfoA,
    (LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA FAR *psfi, UINT cbFileInfo, UINT uFlags),
    (pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags),
    0, SHELL32)
#define SHGetFileInfoA VAR_SHGetFileInfoA

LOADER_FUNCTION(BOOL, Shell_NotifyIconA,
    (DWORD dwMessage, PNOTIFYICONDATAA lpData),
    (dwMessage, lpData),
    FALSE, SHELL32)
#define Shell_NotifyIconA VAR_Shell_NotifyIconA

LOADER_FUNCTION(int, SHFileOperationA,
    (LPSHFILEOPSTRUCTA lpfo),
    (lpfo),
    -1, SHELL32)
#define SHFileOperationA VAR_SHFileOperationA

LOADER_FUNCTION(HICON, ExtractIconA,
    (HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex),
    (hInst, lpszExeFileName, nIconIndex),
    NULL, SHELL32)
#define ExtractIconA VAR_ExtractIconA

/////////////////////////////////////
// COMDLG32.DLL

#include <commdlg.h>

BOOL DemandLoadCOMDLG32();

LOADER_FUNCTION(BOOL, GetSaveFileNameA,
    (LPOPENFILENAME pof),
    (pof),
    FALSE, COMDLG32)
#define GetSaveFileNameA VAR_GetSaveFileNameA

LOADER_FUNCTION(BOOL, GetOpenFileNameA,
    (LPOPENFILENAME pof),
    (pof),
    FALSE, COMDLG32)
#define GetOpenFileNameA VAR_GetOpenFileNameA

LOADER_FUNCTION(BOOL, ChooseFontA,
    (LPCHOOSEFONT pcf),
    (pcf),
    FALSE, COMDLG32)
#define ChooseFontA VAR_ChooseFontA

/////////////////////////////////////
// VERSION.DLL

BOOL DemandLoadVERSION();

LOADER_FUNCTION(BOOL, VerQueryValueA,
    (const LPVOID pBlock, LPSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen),
    (pBlock, lpSubBlock, lplpBuffer, puLen),
    FALSE, VERSION)
#define VerQueryValueA VAR_VerQueryValueA

LOADER_FUNCTION(BOOL, GetFileVersionInfoA,
    (PSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData),
    (lptstrFilename, dwHandle, dwLen, lpData),
    FALSE, VERSION)
#define GetFileVersionInfoA VAR_GetFileVersionInfoA

LOADER_FUNCTION(DWORD, GetFileVersionInfoSizeA,
    (LPSTR lptstrFilename, LPDWORD lpdwHandle),
    (lptstrFilename, lpdwHandle),
    0, VERSION)
#define GetFileVersionInfoSizeA VAR_GetFileVersionInfoSizeA

/////////////////////////////////////
// URLMON.DLL

BOOL DemandLoadURLMON();

LOADER_FUNCTION(HRESULT, CreateURLMoniker,
    (LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR *ppmk),
    (pMkCtx, szURL, ppmk),
    E_FAIL, URLMON)
#define CreateURLMoniker VAR_CreateURLMoniker

LOADER_FUNCTION(HRESULT, URLOpenBlockingStreamA,
    (LPUNKNOWN pUnk,LPCSTR pURL,LPSTREAM* ppstm,DWORD i,LPBINDSTATUSCALLBACK p),
    (pUnk, pURL, ppstm, i, p),
    E_FAIL, URLMON)
#define URLOpenBlockingStreamA VAR_URLOpenBlockingStreamA

LOADER_FUNCTION(HRESULT, FindMimeFromData,
    (LPBC pBC, LPCWSTR pwzUrl, LPVOID pBuffer, DWORD cbSize, LPCWSTR pwzMimeProposed, DWORD dwMimeFlags, LPWSTR *ppwzMimeOut, DWORD dwReserved),
    (pBC, pwzUrl, pBuffer, cbSize, pwzMimeProposed, dwMimeFlags, ppwzMimeOut, dwReserved),
    E_FAIL, URLMON)
#define FindMimeFromData VAR_FindMimeFromData

LOADER_FUNCTION( HRESULT, CoInternetCombineUrl,
    (LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved),
    (pwzBaseUrl, pwzRelativeUrl, dwCombineFlags, pszResult, cchResult, pcchResult, dwReserved),
    E_FAIL, URLMON)
#define CoInternetCombineUrl VAR_CoInternetCombineUrl

LOADER_FUNCTION( HRESULT, RegisterBindStatusCallback,
    (LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved),
    (pBC, pBSCb, ppBSCBPrev, dwReserved),
    E_FAIL, URLMON)
#define RegisterBindStatusCallback VAR_RegisterBindStatusCallback

LOADER_FUNCTION( HRESULT, RevokeBindStatusCallback,
    (LPBC pBC, IBindStatusCallback *pBSCb),
    (pBC, pBSCb),
    E_FAIL, URLMON)
#define RevokeBindStatusCallback VAR_RevokeBindStatusCallback

LOADER_FUNCTION( HRESULT, FaultInIEFeature,
    (HWND hwnd,     uCLSSPEC    *classpec, QUERYCONTEXT *pQuery, DWORD dwFlags),
    (hwnd, classpec, pQuery, dwFlags),
    E_FAIL, URLMON)
#define FaultInIEFeature VAR_FaultInIEFeature

LOADER_FUNCTION( HRESULT, CoInternetGetSecurityUrl,
    (LPCWSTR pwzUrl, LPWSTR  *ppwzSecUrl, PSUACTION  psuAction, DWORD   dwReserved),
    (pwzUrl, ppwzSecUrl, psuAction, dwReserved),
    E_FAIL, URLMON)
#define CoInternetGetSecurityUrl VAR_CoInternetGetSecurityUrl

LOADER_FUNCTION( HRESULT, ObtainUserAgentString,
    (DWORD dwOption, LPSTR pszUAOut, DWORD* cbSize),
    (dwOption, pszUAOut, cbSize),
    E_FAIL, URLMON)
#define ObtainUserAgentString VAR_ObtainUserAgentString

LOADER_FUNCTION( HRESULT, CoInternetCreateSecurityManager,
    (IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved),
    (pSP, ppSM, dwReserved),
    E_FAIL, URLMON)
#define CoInternetCreateSecurityManager VAR_CoInternetCreateSecurityManager

/////////////////////////////////////
// MLANG.DLL

#include <mlang.h>

BOOL DemandLoadMLANG(void);

LOADER_FUNCTION( HRESULT, IsConvertINetStringAvailable,
    (DWORD dwSrcEncoding, DWORD dwDstEncoding),
    (dwSrcEncoding, dwDstEncoding),
    S_FALSE, MLANG)
#define IsConvertINetStringAvailable VAR_IsConvertINetStringAvailable

LOADER_FUNCTION( HRESULT, ConvertINetString,
    (LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize),
    (lpdwMode, dwSrcEncoding, dwDstEncoding, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize),
    E_FAIL, MLANG)
#define ConvertINetString VAR_ConvertINetString

/////////////////////////////////////
// SHDOCVW.DLL

#include <shlobjp.h>
BOOL DemandLoadSHDOCVW();

LOADER_FUNCTION(HRESULT, AddUrlToFavorites,
    (HWND hwnd, LPWSTR pszUrlW, LPWSTR pszTitleW, BOOL fDisplayUI),
    (hwnd, pszUrlW, pszTitleW, fDisplayUI),
    E_FAIL, SHDOCVW)
#define AddUrlToFavorites VAR_AddUrlToFavorites

LOADER_FUNCTION(long, SetQueryNetSessionCount,
    (enum SessionOp Op),
    (Op),
    0, SHDOCVW)
#define SetQueryNetSessionCount VAR_SetQueryNetSessionCount

LOADER_FUNCTION_VOID(void, SetShellOfflineState,
    (BOOL fPutOfflineState),
    (fPutOfflineState),
    SHDOCVW)
#define SetShellOfflineState    VAR_SetShellOfflineState


/////////////////////////////////////
// INETCPL.CPL

BOOL DemandLoadINETCPL();

LOADER_FUNCTION(int, OpenFontsDialog,
    (HWND hwnd, LPCSTR lpszKey),
    (hwnd, lpszKey),
    0, INETCPL)
#define OpenFontsDialog VAR_OpenFontsDialog

LOADER_FUNCTION(BOOL, LaunchConnectionDialog,
    (HWND   hwnd),
    (hwnd),
    FALSE,  INETCPL)
#define LaunchConnectionDialog VAR_LaunchConnectionDialog

/////////////////////////////////////
// MSO9.DLL
#include "msoci.h"
BOOL DemandLoadMSO9();

LOADER_FUNCTION(BOOL, MsoFGetComponentManager,
    (IMsoComponentManager **ppicm),
    (ppicm),
    FALSE, MSO9)
#define MsoFGetComponentManager VAR_MsoFGetComponentManager

/////////////////////////////////////
// WINMM.DLL


BOOL DemandLoadWinMM();

LOADER_FUNCTION(BOOL, sndPlaySoundA,
    (LPCSTR pszSound, UINT fuSound),
    (pszSound, fuSound),
    FALSE, WinMM)
#define sndPlaySoundA VAR_sndPlaySoundA

/////////////////////////////////////
// WSOCK32.DLL

#include <winsock.h>

typedef struct WSAData FAR * LPWSADATA;
typedef unsigned int    u_int;
typedef unsigned short  u_short;
#ifdef _WIN64
typedef UINT_PTR		SOCKET;
#else
typedef u_int           SOCKET;
#endif	// _WIN64

BOOL DemandLoadWSOCK32();

LOADER_FUNCTION( int, WSAStartup,
    (WORD wVersionRequired, LPWSADATA lpWSAData),
    (wVersionRequired, lpWSAData),
    WSAVERNOTSUPPORTED, WSOCK32)
#define WSAStartup VAR_WSAStartup

LOADER_FUNCTION( int, WSACleanup,
    (void),
    (),
    SOCKET_ERROR, WSOCK32)
#define WSACleanup VAR_WSACleanup

LOADER_FUNCTION( int, WSAGetLastError,
    (void),
    (),
    0, WSOCK32)
#define WSAGetLastError VAR_WSAGetLastError

LOADER_FUNCTION( int, gethostname,
    (char FAR * name, int namelen),
    (name, namelen),
    SOCKET_ERROR, WSOCK32)
#define gethostname VAR_gethostname

LOADER_FUNCTION( struct hostent FAR *, gethostbyname,
    (const char FAR * name),
    (name),
    NULL, WSOCK32)
#define gethostbyname VAR_gethostbyname

LOADER_FUNCTION( HANDLE, WSAAsyncGetHostByName,
    (HWND hWnd, u_int wMsg, const char FAR * name, char FAR * buf, int buflen),
    (hWnd, wMsg, name, buf, buflen),
    0, WSOCK32)
#define WSAAsyncGetHostByName VAR_WSAAsyncGetHostByName

LOADER_FUNCTION( unsigned long, inet_addr,
    (const char FAR * cp),
    (cp),
    INADDR_NONE, WSOCK32)
#define inet_addr VAR_inet_addr

LOADER_FUNCTION( u_short, htons,
    (u_short hostshort),
    (hostshort),
    0, WSOCK32)
#define htons VAR_htons

LOADER_FUNCTION( int, WSACancelAsyncRequest,
    (HANDLE hAsyncTaskHandle),
    (hAsyncTaskHandle),
    SOCKET_ERROR, WSOCK32)
#define WSACancelAsyncRequest VAR_WSACancelAsyncRequest

LOADER_FUNCTION( int, send,
    (SOCKET s, const char FAR * buf, int len, int flags),
    (s, buf, len, flags),
    SOCKET_ERROR, WSOCK32)
#define send VAR_send

LOADER_FUNCTION( int, connect,
    (SOCKET s, const struct sockaddr FAR *name, int namelen),
    (s, name, namelen),
    SOCKET_ERROR, WSOCK32)
#define connect VAR_connect

LOADER_FUNCTION( int, WSAAsyncSelect,
    (SOCKET s, HWND hWnd, u_int wMsg, long lEvent),
    (s, hWnd, wMsg, lEvent),
    SOCKET_ERROR, WSOCK32)
#define WSAAsyncSelect VAR_WSAAsyncSelect

LOADER_FUNCTION( SOCKET, socket,
    (int af, int type, int protocol),
    (af, type, protocol),
    INVALID_SOCKET, WSOCK32)
#define socket VAR_socket

LOADER_FUNCTION( char FAR *, inet_ntoa,
    (struct in_addr in),
    (in),
    NULL, WSOCK32)
#define inet_ntoa VAR_inet_ntoa

LOADER_FUNCTION( int, closesocket,
    (SOCKET s),
    (s),
    SOCKET_ERROR, WSOCK32)
#define closesocket VAR_closesocket

LOADER_FUNCTION( int, recv,
    (SOCKET s, char FAR * buf, int len, int flags),
    (s, buf, len, flags),
    SOCKET_ERROR, WSOCK32)
#define recv VAR_recv

/////////////////////////////////////
// PSTOREC.DLL

#ifndef __IEnumPStoreProviders_FWD_DEFINED__
    #define __IEnumPStoreProviders_FWD_DEFINED__
    typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif 	/* __IEnumPStoreProviders_FWD_DEFINED__ */
#ifndef __IPStore_FWD_DEFINED__
    #define __IPStore_FWD_DEFINED__
    typedef interface IPStore IPStore;
#endif 	/* __IPStore_FWD_DEFINED__ */
typedef GUID PST_PROVIDERID;

BOOL DemandLoadPStoreC();

LOADER_FUNCTION( HRESULT, PStoreCreateInstance,
    (IPStore __RPC_FAR *__RPC_FAR *ppProvider, PST_PROVIDERID __RPC_FAR *pProviderID, void __RPC_FAR *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags),
    E_FAIL, PStoreC)
#define PStoreCreateInstance VAR_PStoreCreateInstance

/////////////////////////////////////
// RICHED32.DLL
// note: special case as we don't use any riched functions but need to LoadLibrary it.

BOOL DemandLoadRichEdit();

/////////////////////////////////////
// RAS.DLL
#include <ras.h>
#include <raserror.h>

extern BOOL DemandLoadRAS(void);

LOADER_FUNCTION( DWORD, RasEnumEntriesA,
    (LPSTR reserved, LPSTR lpszPhoneBook, LPRASENTRYNAMEA lpEntry, LPDWORD lpcb, LPDWORD lpcEntries),
    (reserved, lpszPhoneBook, lpEntry, lpcb, lpcEntries),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasEnumEntriesA VAR_RasEnumEntriesA

LOADER_FUNCTION( DWORD, RasEditPhonebookEntryA,
    (HWND hwnd, LPSTR lpszPhoneBook, LPSTR lpszEntryName),
    (hwnd, lpszPhoneBook, lpszEntryName),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasEditPhonebookEntryA VAR_RasEditPhonebookEntryA

LOADER_FUNCTION( DWORD, RasCreatePhonebookEntryA,
    (HWND hwnd, LPSTR lpszPhoneBook),
    (hwnd, lpszPhoneBook),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasCreatePhonebookEntryA VAR_RasCreatePhonebookEntryA

/////////////////////////////////////
// ADVAPI32.DLL

#ifndef ALGIDDEF
    #define ALGIDDEF
    typedef unsigned int ALG_ID;
#endif
typedef ULONG_PTR HCRYPTKEY;

BOOL DemandLoadAdvApi32(void);

LOADER_FUNCTION( BOOL, CryptAcquireContextW,
    (HCRYPTPROV *phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextW VAR_CryptAcquireContextW

LOADER_FUNCTION( BOOL, CryptContextAddRef,
    (HCRYPTPROV hProv, DWORD * pdwReserved, DWORD dwFlags),
    (hProv, pdwReserved, dwFlags),
    FALSE, AdvApi32)
#define CryptContextAddRef VAR_CryptContextAddRef

LOADER_FUNCTION( BOOL, CryptDuplicateKey,
    (HCRYPTKEY hkey, DWORD * pdwReserved, DWORD dwFlags, HCRYPTKEY * phKey),
    (hkey, pdwReserved, dwFlags, phKey),
    FALSE, AdvApi32)
#define CryptDuplicateKey VAR_CryptDuplicateKey

BOOL MY_CryptContextAddRef(HCRYPTPROV hProv, DWORD * pdwReserved, DWORD dwFlags);
BOOL MY_CryptDuplicateKey(HCRYPTKEY hkey, DWORD * pdwReserved, DWORD dwFlags, HCRYPTKEY * phKey);

HINSTANCE DemandLoadShlWapi(void);

/////////////////////////////////////
// CRYPTUI.DLL

#ifndef _CRYPTUI_YST
#define _CRYPTUI_YST
typedef struct _CRYPTUI_CERT_MGR_STRUCT
{
    DWORD                       dwSize;                     // REQUIRED
    HWND                        hwndParent;                 // OPTIONAL
    DWORD                       dwFlags;                    // OPTIONAL
    LPCWSTR                     pwszTitle;                   // OPTIONAL
    LPCSTR                      pszInitUsageOID;            // OPTIONAL
}CRYPTUI_CERT_MGR_STRUCT, *PCRYPTUI_CERT_MGR_STRUCT;

typedef const CRYPTUI_CERT_MGR_STRUCT *PCCRYPTUI_CERT_MGR_STRUCT;
#endif 

BOOL DemandLoadCryptUI();

LOADER_FUNCTION(BOOL, CryptUIDlgCertMgr,
    (PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr),
    (pCryptUICertMgr),
    0, CryptUI)
#define CryptUIDlgCertMgr VAR_CryptUIDlgCertMgr


/////////////////////////////////////
// MSI.DLL
// Windows Installer (DARWIN) - Used primarily for speller

#include <msi.h>

BOOL DemandLoadMSI();

LOADER_FUNCTION(UINT, MsiEnumComponentQualifiersA,
    (LPCSTR szComponent, DWORD iIndex, LPSTR lpQualifierBuf, DWORD *pcchQualifierBuf, LPSTR lpApplicationDataBuf, DWORD *pcchApplicationDataBuf),
    (       szComponent,       iIndex,       lpQualifierBuf,        pcchQualifierBuf,       lpApplicationDataBuf,        pcchApplicationDataBuf),
    ERROR_UNKNOWN_COMPONENT, MSI)
#define MsiEnumComponentQualifiersA VAR_MsiEnumComponentQualifiersA

LOADER_FUNCTION(UINT, MsiProvideQualifiedComponentA,
    (LPCSTR szCategory, LPCSTR szQualifier, DWORD dwInstallMode, LPSTR lpPathBuf, DWORD *pcchPathBuf),
    (       szCategory,        szQualifier,       dwInstallMode,       lpPathBuf,        pcchPathBuf),
    ERROR_UNKNOWN_COMPONENT, MSI)
#define MsiProvideQualifiedComponentA VAR_MsiProvideQualifiedComponentA

LOADER_FUNCTION(INSTALLSTATE, MsiLocateComponentA,
    (LPCSTR szComponent, LPSTR lpPathBuf, DWORD *pcchBuf),
    (       szComponent,       lpPathBuf,        pcchBuf),
    INSTALLSTATE_UNKNOWN, MSI)
#define MsiLocateComponentA VAR_MsiLocateComponentA

LOADER_FUNCTION(INSTALLUILEVEL, MsiSetInternalUI,
    (INSTALLUILEVEL dwUILevel, HWND *phwnd),
    (               dwUILevel,       phwnd),
    INSTALLUILEVEL_NOCHANGE, MSI)
#define MsiSetInternalUI VAR_MsiSetInternalUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\envguid.h ===
#ifndef _ENVGUID_H
#define _ENVGUID_H

// {A08AF898-C2A3-11d1-BE23-00C04FA31009}
DEFINE_GUID(CLSID_OEEnvelope, 0xa08af898, 0xc2a3, 0x11d1, 0xbe, 0x23, 0x0, 0xc0, 0x4f, 0xa3, 0x10, 0x9);
//{42F07860-4692-11d1-82D3-00C04FD9753F}
DEFINE_GUID(CGID_Envelope, 0x42f07860, 0x4692, 0x11d1, 0x82, 0xd3, 0x0, 0xc0,0x4f, 0xd9, 0x75, 0x3f);
// {00067298-0000-0000-C000-000000000046}
DEFINE_GUID(IID_IMsoEnvelope, 0x00067298, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
// {0006729A-0000-0000-C0000-00000000046}
DEFINE_GUID(IID_IMsoEnvelopeHost, 0x0006729A, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
// {00067299-0000-0000-C000-000000000046}
DEFINE_GUID(IID_IMsoEnvelopeSite, 0x00067299, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

// {000C0601-0000-0000-C000-000000000046}
DEFINE_GUID(IID_IMsoComponentManager, 0x000C0601, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
// {000C0600-0000-0000-C000-000000000046}
DEFINE_GUID(IID_IMsoComponent, 0x000C0600, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

DEFINE_GUID(CLSID_GWEnvelopeHost, 0x00000000, 0x7bc4, 0x11d1, 0xbd, 0xfa, 0x0, 0xc0, 0x4f, 0xa3, 0x10, 0x9);

// {8CC497C0-A1DF-11ce-8098-00AA0047BE5D} Taken from tom.h
DEFINE_GUID(IID_ITextDocument, 0x8CC497C0, 0xA1DF, 0x11ce, 0x80, 0x98, 0x00, 0xAA, 0x00, 0x47, 0xBE, 0x5D);
DEFINE_GUID(IID_ITextServices, 0x8d33f740, 0xcf58, 0x11ce, 0xa8, 0x9d, 0x00, 0xaa, 0x00, 0x6c, 0xad, 0xc5);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\error.h ===
//=================================================================================
// Thor Errors - HRESULTS that map to string resource Ids
// =================================================================================
#ifndef __ERROR_H
#define __ERROR_H

#ifndef S_TRUE
#define S_TRUE  S_OK
#endif

// =================================================================================
// Makes an Error HRESULT
// =================================================================================
#define ATH_HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, n)

// =================================================================================
// Makes a Success HRESULT
// =================================================================================
#define ATH_HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, n)

// =================================================================================
// Computes the String Resource Id of the HRESULT
// =================================================================================
#define HR_CODE(hr) (INT)(hr & 0xffff)

// =================================================================================
// HRESULT_BASE - Increment off of this base number if not using a resource string
// =================================================================================
// moved from 100 to 1000 to avoid conflicts with mimeole (t-erikne)
#define HR_FIRST 0x1000 // Put at the bottom

// =================================================================================
// HRESULTS - General
// =================================================================================
#define hrRasInitFailure                        ATH_HR_E(idshrRasInitFailure)
#define hrRasDialFailure                        ATH_HR_E(idshrRasDialFailure)
#define hrRasServerNotFound                     ATH_HR_E(idshrRasServerNotFound)
#define hrGetDialParamsFailed                   ATH_HR_E(idshrGetDialParamsFailed)
#define hrRasPasswordExpired                    ATH_HR_E(idshrRasPasswordExpired)
#define hrSetDialParamsFailed                   ATH_HR_E(idshrSetDialParamsFailed)
#define hrSicilyLogonFailed                     ATH_HR_E(idsErrSicilyLogonFailed)
#define hrFailedToLoadSicily                    ATH_HR_E(idsErrSicilyFailedToLoad)

// =================================================================================
// Non-String based HRESULTS
// =================================================================================
#define hrMemory                                E_OUTOFMEMORY
#define hrCharsetSyntax                         ATH_HR_E(HR_FIRST + 1)
#define hrCreateFile                            ATH_HR_E(HR_FIRST + 2)
#define hrLoadLibraryFailed                     ATH_HR_E(HR_FIRST + 3)
#define hrGetProcAddressFailed                  ATH_HR_E(HR_FIRST + 4)
#define hrCharSetDllGetDispatchTable            ATH_HR_E(HR_FIRST + 5)
#define hrFolderIsLocked                        ATH_HR_E(HR_FIRST + 6)
#define hrInvalidMimeMessage                    ATH_HR_E(HR_FIRST + 7)
#define hrCntListOutofSync                      ATH_HR_E(HR_FIRST + 8)
#define hrWriteFileFailed                       ATH_HR_E(HR_FIRST + 9)
#define hrUserCancel                            ATH_HR_E(HR_FIRST + 10)
#define hrInvalidParameter                      ATH_HR_E(HR_FIRST + 11)
#define hrBufferTooShort                        ATH_HR_E(HR_FIRST + 13)
#define hrIncompleteHeader                      ATH_HR_E(HR_FIRST + 14)
#define hrErrSplitMsg                           ATH_HR_E(HR_FIRST + 15)
#define hrInvalidAccount                        ATH_HR_E(HR_FIRST + 16)
#define hrInvalidPassword                       ATH_HR_E(HR_FIRST + 17)
#define hrPOP3ErrorResponse                     ATH_HR_E(HR_FIRST + 18)
#define hrSMTPRecipientsRejected                ATH_HR_E(HR_FIRST + 19)
#define hrWSAStartupFailed                      ATH_HR_E(HR_FIRST + 20)
#define hrWSAVerNotSupported                    ATH_HR_E(HR_FIRST + 21)
#define hrNoRecipients                          ATH_HR_E(HR_FIRST + 22)
#define hrNoSender                              ATH_HR_E(HR_FIRST + 23)
#define hrEmptySenderAddress                    ATH_HR_E(HR_FIRST + 24)
#define hrEmptyRecipientAddress                 ATH_HR_E(HR_FIRST + 25)
#define hrSMTPInvalidResponseCode               ATH_HR_E(HR_FIRST + 26)
#define hrXPNotOpen                             ATH_HR_E(HR_FIRST + 27)
#define hrInvalidMsgIndex                       ATH_HR_E(HR_FIRST + 28)
#define hrSetFilePointer                        ATH_HR_E(HR_FIRST + 29)
#define hrReadFile                              ATH_HR_E(HR_FIRST + 30)
#define hrWriteFile                             ATH_HR_E(HR_FIRST + 31)
#define hrDuplicateUidl                         ATH_HR_E(HR_FIRST + 32)
#define hrCantDeleteSpecialFolder               ATH_HR_E(HR_FIRST + 33)
#define hrCantRenameSpecialFolder               ATH_HR_E(HR_FIRST + 34)
#define hrFolderNameConflict                    ATH_HR_E(HR_FIRST + 35)
#define hrFileNameConflict                      ATH_HR_E(HR_FIRST + 36)
#define hrPasswordNotFound                      ATH_HR_E(HR_FIRST + 37)
#define hrBusy                                  ATH_HR_E(HR_FIRST + 38)
#define hrUnresolvedNames                       ATH_HR_E(HR_FIRST + 39)
#define hrUidlNotSupported                      ATH_HR_E(HR_FIRST + 40)
#define hrNoServers                             ATH_HR_E(HR_FIRST + 41)

// keep these in this order and contiguous
#define hrCorruptMessage                        ATH_HR_E(HR_FIRST + 42)
#define hrCorruptFolder                         ATH_HR_E(HR_FIRST + 43)
#define hrFolderDeleted                         ATH_HR_E(HR_FIRST + 44)
#define hrBlobVersionChanged                    ATH_HR_E(HR_FIRST + 45)
#define hrFolderDeletedIndex                    ATH_HR_E(HR_FIRST + 46)
// keep these in this order and contiguous

#define hrGeneralProtocolError                  ATH_HR_E(HR_FIRST + 50)
#define hrSMTP500SyntaxError                    ATH_HR_E(HR_FIRST + 51)
#define hrSMTP501ParameterSyntax                ATH_HR_E(HR_FIRST + 52)
#define hrSMTP502CommandNotImpl                 ATH_HR_E(HR_FIRST + 53)
#define hrSMTP503CommandSeq                     ATH_HR_E(HR_FIRST + 54)
#define hrSMTP504CommandParamNotImpl            ATH_HR_E(HR_FIRST + 55)
#define hrSMTP421NotAvailable                   ATH_HR_E(HR_FIRST + 56)
#define hrSMTP450MailboxBusy                    ATH_HR_E(HR_FIRST + 57)
#define hrSMTP550MailboxNotFound                ATH_HR_E(HR_FIRST + 58)
#define hrSMTP451ErrorProcessing                ATH_HR_E(HR_FIRST + 59)
#define hrSMTP551UserNotLocal                   ATH_HR_E(HR_FIRST + 60)
#define hrSMTP452NoSystemStorage                ATH_HR_E(HR_FIRST + 61)
#define hrSMTP552StorageOverflow                ATH_HR_E(HR_FIRST + 62)
#define hrSMTP553MailboxNameSyntax              ATH_HR_E(HR_FIRST + 63)
#define hrSMTP554TransactionFailed              ATH_HR_E(HR_FIRST + 64)
#define hrSMTPNotRecognized                     ATH_HR_E(HR_FIRST + 65)
#define hrSMTP211SystemStatus                   ATH_HR_S(HR_FIRST + 66)
#define hrSMTP214HelpMessage                    ATH_HR_S(HR_FIRST + 67)
#define hrSMTP220Ready                          ATH_HR_S(HR_FIRST + 68)
#define hrSMTP221Closing                        ATH_HR_S(HR_FIRST + 69)
#define hrSMTP250MailActionOkay                 ATH_HR_S(HR_FIRST + 70)
#define hrSMTP251ForwardingMail                 ATH_HR_S(HR_FIRST + 71)
#define hrSMTP354StartMailInput                 ATH_HR_S(HR_FIRST + 72)
#define hrNotConnected                          ATH_HR_E(HR_FIRST + 73)
#define hrDroppedConn                           ATH_HR_E(HR_FIRST + 74)
#define hrBtreeCorrupt                          ATH_HR_E(HR_FIRST + 75)
#define hrDisableOption                         ATH_HR_E(HR_FIRST + 76)
#define hrFolderIsInUseByOther                  ATH_HR_E(HR_FIRST + 77)
#define hrUnableToLoadWab32Dll                  ATH_HR_E(HR_FIRST + 78)
#define hrWabNotLoaded                          ATH_HR_E(HR_FIRST + 79)
#define hrTreeInsertDuplicate                   ATH_HR_E(HR_FIRST + 80)
#define hrBufferTooSmall                        ATH_HR_E(HR_FIRST + 81)
#define hrBufferTooLarge                        ATH_HR_E(HR_FIRST + 82)
#define hrGetPropsFailed                        ATH_HR_E(HR_FIRST + 83)
#define hrSetPropsFailed                        ATH_HR_E(HR_FIRST + 84)
#define hrNotFound                              ATH_HR_E(HR_FIRST + 85)
#define hrFolderNameTooLong                     ATH_HR_E(HR_FIRST + 86)
#define hrDiskFull                              ATH_HR_E(HR_FIRST + 87)
#define hrAlreadyConnected                      ATH_HR_E(HR_FIRST + 88)
#define hrInvalidState                          ATH_HR_E(HR_FIRST + 89)
#define hrConn                                  ATH_HR_E(HR_FIRST + 90)
#define hrConnRecv                              ATH_HR_E(HR_FIRST + 91)
#define hrConnSend                              ATH_HR_E(HR_FIRST + 92)
#define hrTooManyReplyTo                        ATH_HR_E(HR_FIRST + 93)
#define hrUnableToLoadMapi32Dll                 ATH_HR_E(HR_FIRST + 94)
#define hrIncomplete                            ATH_HR_E(HR_FIRST + 95)
#define hrAlreadyExists                         ATH_HR_E(HR_FIRST + 96)
#define hrHostLookupFailed                      ATH_HR_E(HR_FIRST + 97)
#define hrInvalidResponse                       ATH_HR_E(HR_FIRST + 98)
#define hrConnectFailed                         ATH_HR_E(HR_FIRST + 99)
#define hrWouldBlock                            ATH_HR_E(HR_FIRST + 100)
#define hrImportLoad                            ATH_HR_E(HR_FIRST + 101)
#define hrMailNotConfigured                     ATH_HR_E(HR_FIRST + 103)
#define hrInvalidFolderName                     ATH_HR_E(HR_FIRST + 104)
#define hrSwitchRasConnection                   ATH_HR_S(HR_FIRST + 105)
#define hrInvalidCertCN                         ATH_HR_E(HR_FIRST + 106)
#define hrInvalidCertDate                       ATH_HR_E(HR_FIRST + 107)

//#define hrRegCreateKeyFailed                    ATH_HR_E(HR_FIRST + 108)
#define hrRegQueryInfoKeyFailed                 ATH_HR_E(HR_FIRST + 109)
//#define hrBadFriendlyName                       ATH_HR_E(HR_FIRST + 110)
//#define hrInvalidPropTag                        ATH_HR_E(HR_FIRST + 111)
//#define hrPropNoData                            ATH_HR_E(HR_FIRST + 112)
//#define hrBufferSizeMismatch                    ATH_HR_E(HR_FIRST + 113)
//#define hrEnumFinished                          ATH_HR_S(HR_FIRST + 114)
//#define hrUnknownPropType                       ATH_HR_E(HR_FIRST + 115)    
//#define hrInvalidPropertySet                    ATH_HR_E(HR_FIRST + 116)
//#define hrRegSetValueFailed                     ATH_HR_E(HR_FIRST + 117)
#define hrRegOpenKeyFailed                      ATH_HR_E(HR_FIRST + 118)
//#define hrDuplicateAccountName                  ATH_HR_E(HR_FIRST + 119)
//#define hrPropOutOfRange                        ATH_HR_E(HR_FIRST + 120)
//#define hrPropInvalidBool                       ATH_HR_E(HR_FIRST + 121)
//#define hrNoAccounts                            ATH_HR_E(HR_FIRST + 122)
//#define hrRegDeleteKeyFailed                    ATH_HR_E(HR_FIRST + 123)
#define hrCantMoveFolderBetweenServers          ATH_HR_E(HR_FIRST + 122)
#define hrCantDeleteAllSubfolders               ATH_HR_E(HR_FIRST + 123)
#define hrCantDeleteFolderWithChildren          ATH_HR_E(HR_FIRST + 124)
#define hrCantMoveSpecialFolder                 ATH_HR_E(HR_FIRST + 125)
#define hrCantMoveIntoSubfolder                 ATH_HR_E(HR_FIRST + 126)

// Offline News Error Codes
#define HR_E_NOTINITIALIZED                     ATH_HR_E(HR_FIRST + 127)
#define HR_E_COULDNOTSTARTTHREAD                ATH_HR_E(HR_FIRST + 128)
#define HR_S_ACCOUNTNOTCONFIGURED               ATH_HR_S(HR_FIRST + 129)
#define HR_E_NOSUBSCRIBEDLIST                   ATH_HR_E(HR_FIRST + 130)
#define HR_E_QUEUEEMPTY                         ATH_HR_E(HR_FIRST + 131)
#define HR_E_COULDNOTFINDACCOUNT                ATH_HR_E(HR_FIRST + 132)
#define HR_E_COULDNOTINITSUBLIST                ATH_HR_E(HR_FIRST + 133)
#define HR_S_DOWNLOADCOMPLETE                   ATH_HR_S(HR_FIRST + 134)
#define HR_E_DOWNLOADCOMPLETE                   ATH_HR_E(HR_FIRST + 135)
#define hrNoSubject                             ATH_HR_E(HR_FIRST + 136)

// Connection Manager Error Codes
#define HR_E_ALREADYEXISTS                      ATH_HR_E(HR_FIRST + 137)
#define HR_S_RASNOTLOADED                       ATH_HR_S(HR_FIRST + 138)
#define HR_E_UNINITIALIZED                      ATH_HR_E(HR_FIRST + 139)
#define HR_E_OFFLINE                            ATH_HR_E(HR_FIRST + 140)
#define HR_E_USER_CANCEL_CONNECT                ATH_HR_E(HR_FIRST + 141)

// BEGIN another general section
#define hrEmptyDistList                         ATH_HR_E(HR_FIRST + 149)
#define hrBadRecipients                         ATH_HR_E(HR_FIRST + 150)
#define HR_S_NOOP                               ATH_HR_S(HR_FIRST + 151)
#define VIEW_E_NOCOLUMNS                        ATH_HR_E(HR_FIRST + 152)
#define VIEW_E_BADVERSION                       ATH_HR_E(HR_FIRST + 153)

#define HR_E_CONFIGURE_SERVER                   ATH_HR_E(HR_FIRST + 154)
#define HR_E_POST_WITHOUT_NEWS                  ATH_HR_E(HR_FIRST + 155)

// IMAP Error codes
#define hrIMAP_E_NoHierarchy                    ATH_HR_E(HR_FIRST + 300)
#define hrIMAP_E_OFFLINE                        ATH_HR_E(HR_FIRST + 301) // online op attempted while offline
#define hrIMAP_E_NoInferiors                    ATH_HR_E(HR_FIRST + 302)

// Security Error codes
#define HR_E_ATHSEC_NOCERTTOSIGN                ATH_HR_E(HR_FIRST + 400)
#define HR_E_ATHSEC_TRUSTFAILED                 ATH_HR_E(HR_FIRST + 401)
#define HR_E_ATHSEC_FAILED                      ATH_HR_E(HR_FIRST + 402)
#define HR_E_ATHSEC_CERTBEGONE                  ATH_HR_E(HR_FIRST + 403)
#define HR_E_ATHSEC_SAMEASSIGNED                ATH_HR_E(HR_FIRST + 404)
#define HR_E_ATHSEC_DONTSIGN                    ATH_HR_E(HR_FIRST + 405)
#define HR_E_ATHSEC_USENEWSIGN                  ATH_HR_E(HR_FIRST + 406)

// SafeOpen return codes
#define S_OPENFILE                              ATH_HR_S(HR_FIRST + 410)
#define S_SAVEFILE                              ATH_HR_S(HR_FIRST + 411)
#define S_READONLY                              ATH_HR_S(HR_FIRST + 412)

// Spell checking
#define HR_S_ABORT                              ATH_HR_S(HR_FIRST + 420)
#define HR_S_SPELLCANCEL                        ATH_HR_S(HR_FIRST + 421)

#define HR_S_BADURLSNOTATTACHED                 ATH_HR_S(HR_FIRST + 422)
#define HR_S_SPELLCONTINUE                      ATH_HR_S(HR_FIRST + 423)
#define HR_S_SPELLBREAK                         ATH_HR_S(HR_FIRST + 424)

// papyrus
#define PAPYRUS_PRESENT                         ATH_HR_E(HR_FIRST + 450)

// FolderCache error codes
#define hrFolderDoesNotExist                    ATH_HR_E(HR_FIRST + 500)
#define hrFolderHasNoChildren                   ATH_HR_E(HR_FIRST + 501)

#define E_NOT_ONLINE                            ATH_HR_E(HR_FIRST + 502)

#define S_PENDING                               ATH_HR_S(HR_FIRST + 503)
#define E_NOMORETASKS                           ATH_HR_E(HR_FIRST + 504)

#define HR_W_CACHEDELTED                        ATH_HR_S(HR_FIRST + 505)    // warning that the cached messages were delted
#define HR_S_OFFLINE                            ATH_HR_S(HR_FIRST + 506)

//Offline folder operation errors
#define HR_E_OFFLINE_FOLDER_CREATE              ATH_HR_E(HR_FIRST + 507)
#define HR_E_OFFLINE_FOLDER_MOVE                ATH_HR_E(HR_FIRST + 508)
#define HR_E_OFFLINE_FOLDER_RENAME              ATH_HR_E(HR_FIRST + 509)
#define HR_E_OFFLINE_FOLDER_DELETE              ATH_HR_E(HR_FIRST + 510)

#define HR_E_DIALING_INPROGRESS                 ATH_HR_E(HR_FIRST + 511)

#endif //__ERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\hotdisp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

#pragma once

// hack - from OLE headers
#define DISPID_VALUE                                ( 0 )
#define DISPID_NEWENUM                              ( -4 )
// hack - from OLE headers

#define DISPID_IOEACCTWIZ_BASE                      1000

#define DISPID_IOEACCTWIZ_SET_PROP_SZ           (DISPID_IOEACCTWIZ_BASE + 1)
#define DISPID_IOEACCTWIZ_GET_PROP_SZ           (DISPID_IOEACCTWIZ_BASE + 2)
#define DISPID_IOEACCTWIZ_CLEAR_PROPS           (DISPID_IOEACCTWIZ_BASE + 3)
#define DISPID_IOEACCTWIZ_CLOSE                 (DISPID_IOEACCTWIZ_BASE + 4)
#define DISPID_IOEACCTWIZ_NEW_HOTMAIL_ACCOUNT   (DISPID_IOEACCTWIZ_BASE + 5)
#define DISPID_IOEACCTWIZ_WIDTH                 (DISPID_IOEACCTWIZ_BASE + 6)
#define DISPID_IOEACCTWIZ_HEIGHT                (DISPID_IOEACCTWIZ_BASE + 7)
#define DISPID_IOEACCTWIZ_SET_PROP_I            (DISPID_IOEACCTWIZ_BASE + 8)
#define DISPID_IOEACCTWIZ_GET_PROP_I            (DISPID_IOEACCTWIZ_BASE + 9)
#define DISPID_IOEACCTWIZ_NEW_ACCOUNT           (DISPID_IOEACCTWIZ_BASE + 10)
#define DISPID_IOEACCTWIZ_RELOAD                (DISPID_IOEACCTWIZ_BASE + 11)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\list.h ===
//============================================================================
//
//    Header file for generic linked list class
//
//============================================================================

#ifndef LIST_H
#define LIST_H

class CList;
typedef class CItem FAR * LPItem;
class CItem
{
friend class CList;
private:
    LPItem FAR * lppListHead;
    LPItem lpPrevItem;
    LPItem lpNextItem;
protected:
    LPVOID lpObj;
    LPCSTR lpName;
    int    iRefCnt;
public:
    CItem(LPVOID lpObj,LPItem FAR * lppHeadItem, LPCSTR lpName);
    ~CItem();
};

class CList
{
protected:
    LPItem lpItem;
    LPItem lpListHead;
    LPItem FindItem(LPVOID lpObj);
public:
    CList(){lpListHead=NULL;}
    ~CList();
    void AddItemWithName(LPVOID lpObj, LPCSTR lpName){new CItem(lpObj,&lpListHead,lpName);}
    void DelItem(LPVOID lpObj){LPItem lpItem=FindItem(lpObj);delete lpItem;}
    LPVOID FindItemHandleWithName( LPCSTR lpName, LPVOID lpMem );
    BOOL IsEmpty(){return lpListHead==NULL;}
};
typedef CList FAR * LPList;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\icwacct.h ===
#ifndef _INC_ICWACCT_H
#define _INC_ICWACCT_H

#ifndef MAC
#define EXTERNAL_DIALOGID_MINIMUM   2200
#define EXTERNAL_DIALOGID_MAXIMUM   3000

#include <prsht.h>

typedef enum
    {
    CANCEL_PROMPT = 0,
    CANCEL_SILENT,
    CANCEL_REBOOT
    } CANCELTYPE;

// {796AD8F0-B2B7-11d0-8D69-00A0C9A06E1F}
DEFINE_GUID(IID_IICWExtension, 0x796ad8f0, 0xb2b7, 0x11d0, 0x8d, 0x69, 0x0, 0xa0, 0xc9, 0xa0, 0x6e, 0x1f);

interface IICWExtension : public IUnknown
    {
	public:
		virtual BOOL STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
		virtual BOOL STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
		virtual BOOL STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type) = 0;
		virtual BOOL STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID) = 0;
    };

#ifndef WIN16
typedef enum
#else
enum
#endif
    {
    CONNECT_LAN = 0,
    CONNECT_MANUAL,
    CONNECT_RAS
    };

typedef struct tagCONNECTINFO
    {
    DWORD   cbSize;
    DWORD   type;
    char    szConnectoid[MAX_PATH];
    } CONNECTINFO;

// IICWApprentice::Save error values
#define ERR_MAIL_ACCT       0x0001
#define ERR_NEWS_ACCT       0x0002
#define ERR_DIRSERV_ACCT    0x0004

// IICWApprentice::AddWizardPages flags
#define WIZ_USE_WIZARD97    0x0008

// {1438E820-B6D2-11D0-8D86-00C04FD6202B}
DEFINE_GUID(IID_IICWApprentice, 0x1438E820L, 0xB6D2, 0x11D0, 0x8D, 0x86, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

interface IICWApprentice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IICWExtension *pExt) = 0;
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages(DWORD dwFlags) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInformation(CONNECTINFO *pInfo) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetConnectionInformation(CONNECTINFO *pInfo) = 0;
        virtual HRESULT STDMETHODCALLTYPE Save(HWND hwnd, DWORD *pdwError) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID) = 0;
    };

// Athena's CLSID
// {1438E821-B6D2-11D0-8D86-00C04FD6202B}
DEFINE_GUID(CLSID_ApprenticeAcctMgr, 0x1438E821L, 0xB6D2, 0x11D0, 0x8D, 0x86, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

//ICW's CLSID
// {8EE42293-C315-11d0-8D6F-00A0C9A06E1F}
DEFINE_GUID(CLSID_ApprenticeICW, 0x8ee42293L, 0xc315, 0x11d0, 0x8d, 0x6f, 0x0, 0xa0, 0xc9, 0xa0, 0x6e, 0x1f);

// flags for CreateAccountsFromFile
#define CAFF_USE_AUTODIAL   0x0001
#define CAFF_NO_SET_DEFAULT 0x0002
#define CAFF_CURRENT_USER   0x0004

HRESULT WINAPI CreateAccountsFromFile(LPSTR lpFile, DWORD dwFlags);
typedef HRESULT	(WINAPI *PFNCREATEACCOUNTSFROMFILE) (LPSTR, DWORD);

HRESULT WINAPI CreateAccountsFromFileEx(LPSTR lpFile, CONNECTINFO *pci, DWORD dwFlags);
typedef HRESULT	(WINAPI *PFNCREATEACCOUNTSFROMFILEEX) (LPSTR, CONNECTINFO *, DWORD);

#endif  // !MAC
#endif // _INC_ICWACCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\migerror.h ===
// --------------------------------------------------------------------------------
// MigError.h
// --------------------------------------------------------------------------------
#ifndef __MIGERROR_H
#define __MIGERROR_H

// --------------------------------------------------------------------------------
// Macros
// --------------------------------------------------------------------------------
#ifndef FACILITY_INTERNET
#define FACILITY_INTERNET 12
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_INTERNET, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// Error HRESULTs
// --------------------------------------------------------------------------------
#define MIGRATE_E_REGOPENKEY                HR_E(100)
#define MIGRATE_E_REGQUERYVALUE             HR_E(101)
#define MIGRATE_E_EXPANDSTRING              HR_E(102)
#define MIGRATE_E_NOFILES                   HR_E(103)
#define MIGRATE_E_BADVERSION                HR_E(104)
#define MIGRATE_E_NOTNEEDED                 HR_E(105)
#define MIGRATE_E_CANTOPENFILE              HR_E(106)
#define MIGRATE_E_CANTGETFILESIZE           HR_E(107)
#define MIGRATE_E_CANTCREATEFILEMAPPING     HR_E(108)
#define MIGRATE_E_CANTMAPVIEWOFFILE         HR_E(109)
#define MIGRATE_E_BADCHAINSIGNATURE         HR_E(111)
#define MIGRATE_E_TOOMANYCHAINNODES         HR_E(112)
#define MIGRATE_E_BADMINCAPACITY            HR_E(113)
#define MIGRATE_E_CANTSETFILEPOINTER        HR_E(115)
#define MIGRATE_E_WRITEFILE                 HR_E(116)
#define MIGRATE_E_OUTOFRANGEADDRESS         HR_E(117)
#define MIGRATE_E_BADRECORDSIGNATURE        HR_E(118)
#define MIGRATE_E_BADSTREAMBLOCKSIGNATURE   HR_E(119)
#define MIGRATE_E_INVALIDIDXHEADER          HR_E(120)
#define MIGRATE_E_NOTENOUGHDISKSPACE        HR_E(121)
#define MIGRATE_E_BADRECORDFORMAT           HR_E(122)
#define MIGRATE_E_CANTCOPYFILE              HR_E(123)
#define MIGRATE_E_CANTSETENDOFFILE          HR_E(124)
#define MIGRATE_E_USERDATASIZEDIFF          HR_E(125)
#define MIGRATE_E_REGSETVALUE               HR_E(126)
#define MIGRATE_E_SHARINGVIOLATION          HR_E(127)

// --------------------------------------------------------------------------------
// Results Returned from oemig50.exe
// --------------------------------------------------------------------------------
#define MIGRATE_S_SUCCESS                   HR_S(800)
#define MIGRATE_E_NOCONTINUE                HR_E(801)
#define MIGRATE_E_CONTINUE                  HR_E(802)

#endif // __MIGERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\mimeolep.h ===
#ifndef _MIMEOLEP_H
#define _MIMEOLEP_H

/* 
 * MimeOle 'P' .h ?
 *
 * what and why:
 * this is a private header file for exports from inetcomm.dll. Why? there are some funcitons we need to share between MimeEdit and Athena
 * to avoid code duplication, some of these functions require string and other resources. If we put them in msoert2.dll (the logical places)
 * this forces the runtime to be a resourced-dll, which means we need yet another dll - msoertres.dll or something. So this
 * hack of exporting them privatley from inetcomm.dll is a less complicated hack.
 * (sorry opie)
 *
 */

#include "mimeole.h"

// forward refs
typedef struct tagOFNA OPENFILENAME;
typedef struct tagOFNW OPENFILENAMEW;

typedef struct ATTACHDATA_tag
{
    WCHAR       szTempFile[MAX_PATH],       // temp file created with this attachment in it
                szDisplay[MAX_PATH],        // the display name of the attachment as generated by MimeOle (this includes (nK))
                szFileName[MAX_PATH];       // the true filename of the attachment
    HICON       hIcon;                      // the associated icon
    HANDLE      hProcess;                   // handle to process that last opened this attachment
    LPSTREAM    pstm;                       // stream to source bits
    HBODY       hAttach;                    // if coming from a message, this is the handle to the body part, if it's a new attachment
                                            // this this will be null. The data can either be found in pstm, or a full path in lpszFileName
    BOOL        fSafe;                      // is this file safe to open/save
} ATTACHDATA, *LPATTACHDATA;

enum
    {
    AV_OPEN      =0,
    AV_SAVEAS,
    AV_PRINT,
    AV_PROPERTIES,
    AV_QUICKVIEW,
    AV_MAX
    };

// attachment helpers
MIMEOLEAPI HrDoAttachmentVerb(HWND hwnd, ULONG uVerb, IMimeMessage *pMsg, LPATTACHDATA pAttach);
MIMEOLEAPI HrAttachDataFromBodyPart(IMimeMessage *pMsg, HBODY hAttach, LPATTACHDATA *ppAttach);
MIMEOLEAPI HrFreeAttachData(LPATTACHDATA pAttach);
MIMEOLEAPI HrGetAttachIcon(IMimeMessage *pMsg, HBODY hAttach, BOOL fLargeIcon, HICON *phIcon);
MIMEOLEAPI HrSaveAttachmentAs(HWND hwnd, IMimeMessage *pMsg, LPATTACHDATA lpAttach);
MIMEOLEAPI HrAttachSafetyFromBodyPart(IMimeMessage *pMsg, HBODY hAttach, BOOL *pfSafe);

MIMEOLEAPI HrGetDisplayNameWithSizeForFile(LPWSTR szPathName, LPWSTR szDisplayName, int cchMaxDisplayName);
MIMEOLEAPI HrAttachDataFromFile(IStream *pstm, LPWSTR szFileName, LPATTACHDATA *ppAttach);
MIMEOLEAPI HrSaveAttachToFile(IMimeMessage *pMsg, HBODY hAttach, LPWSTR lpszFileName);
MIMEOLEAPI HrGetAttachIconByFile(LPWSTR szFilename, BOOL fLargeIcon, HICON *phIcon);

// fileopen dialog wrapper
MIMEOLEAPI HrGetLastOpenFileDirectory(int cchMax, LPSTR lpsz);
MIMEOLEAPI HrGetLastOpenFileDirectoryW(int cchMax, LPWSTR lpsz);
MIMEOLEAPI HrAthGetFileName(OPENFILENAME *pofn, BOOL fOpen);
MIMEOLEAPI HrAthGetFileNameW(OPENFILENAMEW *pofn, BOOL fOpen);

// {53659CFE-AFA1-11d1-BE17-00C04FA31009}
DEFINE_GUID(CMDSETID_OESecurity, 0x53659cfe, 0xafa1, 0x11d1, 0xbe, 0x17, 0x0, 0xc0, 0x4f, 0xa3, 0x10, 0x9);

#define OECSECCMD_ENCRYPTED     1
#define OECSECCMD_SIGNED        2

#endif //_MIMEOLEP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\msoedbg.h ===
// --------------------------------------------------------------------------------
// Msoedbg.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __MSOEDBG_H
#define __MSOEDBG_H

#ifdef DEBUG
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#include <shlwapi.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#endif
#endif

// --------------------------------------------------------------------------------
// Forwards
// --------------------------------------------------------------------------------
#ifdef __cplusplus
interface ILogFile;
#endif

// --------------------------------------------------------------------------------
// IF_DEBUG
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define IF_DEBUG(_block_) _block_
#else
#define IF_DEBUG(_block_)
#endif

// --------------------------------------------------------------------------------
// CRLF Definitions
// --------------------------------------------------------------------------------
#ifdef MAC
#define szCRLF  "\n\r"
#else   // !MAC
#define szCRLF  "\r\n"
#endif  // MAC

// --------------------------------------------------------------------------------
//
// "Normal" assertion checking.  Provided for compatibility with imported code.
// 
// Assert(a)        Displays a message indicating the file and line number
//                  of this Assert() if a == 0.
// 
// AssertSz(a,b)    As Assert(); also displays the message b (which should
//                  be a string literal.)
//
// SideAssert(a)    As Assert(); the expression a is evaluated even if 
//                  asserts are disabled.
//
// --------------------------------------------------------------------------------
#undef AssertSz
#undef Assert
#undef SideAssert

// --------------------------------------------------------------------------------
// We used to define the ASSERTDATA macro as storing the _szFile
// string.  However, that won't work when we have Assert()'s in
// pre-compiled header files.  We've changed this so that we
// define the _szFile for each assert.  However, other functions
// still use _szAssertFile such as the DEBUG PvAlloc(), HvAlloc(), etc.
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define ASSERTDATA                      static char _szAssertFile[]= __FILE__;
#define SideAssert(_exp)                Assert(_exp)
#define Assert(_exp)                    AssertSz(_exp, "Assert(" #_exp ")")
#else // DEBUG
#define ASSERTDATA
#define SideAssert(a)                   (void)(a)
#define Assert(a)
#endif // DEBUG

// --------------------------------------------------------------------------------
// IxpAssert - Used in internet transport code so as not to affect the message pump
// --------------------------------------------------------------------------------
#ifdef DEBUG
#ifndef _X86_
#define IxpAssert(a)   \
    if (!(a)) { \
        DebugBreak(); \
    } else
#else // _X86_
#define IxpAssert(a)   \
    if (!(a)) { \
        __asm { int 3 }; \
    } else
#endif // _X86_
#else
#define IxpAssert(a)
#endif // DEBUG

// --------------------------------------------------------------------------------
// AssertSz - Assert with a message
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define AssertSz(_exp, _msg)   \
    if (!(_exp)) { \
        static char _szFile[] = __FILE__; \
        AssertSzFn(_msg, _szFile, __LINE__); \
    } else
#else // DEBUG
#define AssertSz(a,b)
#endif // DEBUG

// --------------------------------------------------------------------------------
// AssertFalseSz - Assert with a message
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define AssertFalseSz(_msg)   \
    { \
        static char _szFile[] = __FILE__; \
        AssertSzFn(_msg, _szFile, __LINE__); \
    }
#else // DEBUG
#define AssertFalseSz(a)
#endif // DEBUG

// --------------------------------------------------------------------------------
// NFAssertSz - Non-Fatal Assert
// --------------------------------------------------------------------------------
#ifdef DEBUG
#ifndef NFAssertSz
#define NFAssertSz(_exp, _msg)  \
    if (!(_exp)) { \
        static char _szFile[] = __FILE__; \
        static char _szAssertMsg[] = _msg; \
        NFAssertSzFn(_szAssertMsg, _szFile, __LINE__); \
    } else
#endif
#else // DEBUG
#ifndef NFAssertSz
#define NFAssertSz(a,b)
#endif
#endif // DEBUG

// --------------------------------------------------------------------------------
// NYI - Net Yet Implemented
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define NYI(_msg)   \
    if (1) { \
        static char _szFnNYI[]= _msg; \
        static char _szNYI[]= "Not Implemented"; \
        AssertSzFn(_szFnNYI, _szNYI, __LINE__); \
    } else
#else // DEBUG
#define NYI(a)
#endif // DEBUG

// --------------------------------------------------------------------------------
// AssertReadWritePtr - Assert can read and write cb from ptr
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define AssertReadWritePtr(ptr, cb) \
    if (IsBadReadPtr(ptr, cb) && IsBadWritePtr(ptr, cb)) { \
        AssertSz(FALSE, "AssertReadWritePtr: Bad Pointer"); \
    } else
#else // DEBUG
#define AssertReadWritePtr(ptr, cb)
#endif // DEBUG

// --------------------------------------------------------------------------------
// AssertReadPtr - Assert can read cb from ptr
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define AssertReadPtr(ptr, cb) \
    if (IsBadReadPtr(ptr, cb)) { \
        AssertSz(FALSE, "AssertReadPtr: Bad Pointer"); \
    } else
#else // DEBUG
#define AssertReadPtr(ptr, cb)
#endif // DEBUG

// --------------------------------------------------------------------------------
// AssertWritePtr - Assert can write cb to ptr
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define AssertWritePtr(ptr, cb) \
    if (IsBadWritePtr(ptr, cb)) { \
        AssertSz(FALSE, "AssertWritePtr: Bad Pointer"); \
    } else
#else // DEBUG
#define AssertWritePtr(ptr, cb)
#endif // DEBUG

#ifdef DEBUG
#define AssertZeroMemory(ptr, cb) \
    if (1) { \
        for (DWORD _ib = 0; _ib < (cb); _ib++) { \
            Assert(((LPBYTE)(ptr))[_ib] == 0); } \
    } else
#else // DEBUG
#define AssertZeroMemory(ptr, cb)
#endif // DEBUG

// --------------------------------------------------------------------------------
// Debug Output Levels
// --------------------------------------------------------------------------------
#define DOUT_LEVEL1  1
#define DOUT_LEVEL2  2
#define DOUT_LEVEL3  4
#define DOUT_LEVEL4  8
#define DOUT_LEVEL5 16
#define DOUT_LEVEL6 32
#define DOUT_LEVEL7 64

// --------------------------------------------------------------------------------
// Defines for DOUTLL modules
// --------------------------------------------------------------------------------
#define DOUTL_DRAGDROP 1
#define DOUTL_ADDRBOOK 128
#define DOUTL_ATTMAN   256
#define DOUTL_CRYPT    1024

// --------------------------------------------------------------------------------
// CHECKHR - If hrExp FAILED, then Trap the Error (dbgout) and jump to exit label
// Caller must have a local variable named hr and a label named exit:.
// --------------------------------------------------------------------------------
#define CHECKHR(hrExp) \
    if (FAILED (hrExp)) { \
        TRAPHR(hr); \
        goto exit; \
    } else

#define IF_FAILEXIT(hrExp) \
    if (FAILED(hrExp)) { \
        TraceResult(hr); \
        goto exit; \
    } else

#define IF_FAILEXIT_LOG(_pLog, hrExp) \
    if (FAILED(hrExp)) { \
        TraceResultLog((_pLog), hr); \
        goto exit; \
    } else

// --------------------------------------------------------------------------------
// CHECKALLOC - If _palloc FAILED, then Trap E_OUTOFMEMORY (dbgout) and jump to 
// exit label. Caller must have a local variable named hr and a label named exit:.
// --------------------------------------------------------------------------------
#define CHECKALLOC(_palloc) \
    if (NULL == (_palloc)) { \
        hr = TRAPHR(E_OUTOFMEMORY); \
        goto exit; \
    } else

#define IF_NULLEXIT(_palloc) \
    if (NULL == (_palloc)) { \
        hr = TraceResult(E_OUTOFMEMORY); \
        goto exit; \
    } else

#define IF_NULLEXIT_LOG(_pLog, _palloc) \
    if (NULL == (_palloc)) { \
        hr = TraceResultLog((_pLog), E_OUTOFMEMORY); \
        goto exit; \
    } else

// --------------------------------------------------------------------------------
// CHECKEXP - If _expression is TRUE, then Trap _hresult (dbgout) and jump to 
// exit label. Caller must have a local variable named hr and a label named exit:.
// --------------------------------------------------------------------------------
#define CHECKEXP(_expression, _hresult) \
    if (_expression) { \
        hr = TrapError(_hresult); \
        goto exit; \
    } else

#define IF_TRUEEXIT(_expression, _hresult) \
    if (_expression) { \
        hr = TraceResult(_hresult); \
        goto exit; \
    } else

#define IF_FALSEEXIT(_expression, _hresult) \
    if (FALSE == _expression) { \
        hr = TraceResult(_hresult); \
        goto exit; \
    } else

// --------------------------------------------------------------------------------
// TRACEMACROTYPE
// --------------------------------------------------------------------------------
typedef enum tagTRACEMACROTYPE {
    TRACE_INFO,
    TRACE_CALL,
    TRACE_RESULT
} TRACEMACROTYPE;

// --------------------------------------------------------------------------------
// These Traces are for c++ only
// --------------------------------------------------------------------------------
typedef DWORD SHOWTRACEMASK;
#define SHOW_TRACE_NONE     0x00000000
#define SHOW_TRACE_INFO     0x00000001
#define SHOW_TRACE_CALL     0x00000002
#define SHOW_TRACE_ALL      0xffffffff

// --------------------------------------------------------------------------------
// These Traces are for c++ only
// --------------------------------------------------------------------------------
#if defined(__cplusplus)

// --------------------------------------------------------------------------------
// TRACELOGINFOINFO
// --------------------------------------------------------------------------------
typedef struct tagTRACELOGINFO {
    SHOWTRACEMASK       dwMask;
    ILogFile           *pLog;
} TRACELOGINFO, *LPTRACELOGINFO;

// --------------------------------------------------------------------------------
// DebugTraceEx
// --------------------------------------------------------------------------------
#ifdef DEBUG
EXTERN_C HRESULT DebugTraceEx(SHOWTRACEMASK dwMask, TRACEMACROTYPE tracetype, LPTRACELOGINFO pLog,
    HRESULT hr, LPSTR pszFile, INT nLine, LPCSTR pszMsg, LPCSTR pszFunc);

EXTERN_C DWORD GetDebugTraceTagMask(LPCSTR pszTag, SHOWTRACEMASK dwDefaultMask);
#endif

// --------------------------------------------------------------------------------
// TraceCall(_pszFunc)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCall(_pszFunc) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, NULL, _pszfn)
#else
#define TraceCall(_pszFunc) DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, NULL, NULL)
#endif
#else
#define TraceCall(_pszFunc)
#endif

// --------------------------------------------------------------------------------
// TraceCallLog(_pszFunc)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCallLog(_pLog, _pszFunc) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, _pLog, S_OK, __FILE__, __LINE__, NULL, _pszfn)
#else
#define TraceCallLog(_pLog, _pszFunc) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, _pLog, S_OK, __FILE__, __LINE__, NULL, NULL)
#endif
#else
#define TraceCallLog(_pLog, _pszFunc)
#endif

// --------------------------------------------------------------------------------
// TraceCallTag(_pszFunc)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCallTag(_dwMask, _pszFunc) LPCSTR _pszfn = _pszFunc; DebugTraceEx(_dwMask, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, NULL, _pszfn)
#else
#define TraceCallTag(_dwMask, _pszFunc) LPCSTR _pszfn = _pszFunc; DebugTraceEx(_dwMask, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, NULL, NULL)
#endif
#else
#define TraceCallTag(_dwMask, _pszFunc)
#endif

// --------------------------------------------------------------------------------
// TraceCallSz(_pszFunc, _pszMsg)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCallSz(_pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceCallSz(_pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceCallSz(_pszFunc, _pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceCallLogSz(_pLog, _pszFunc, _pszMsg)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCallLogSz(_pLog, _pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, _pLog, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceCallLogSz(_pLog, _pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, _pLog, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceCallLogSz(_pLog, _pszFunc, _pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceCallTagSz(_dwMask, _pszFunc, _pszMsg)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCallTagSz(_dwMask, _pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(_dwMask, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceCallTagSz(_dwMask, _pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(_dwMask, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceCallTagSz(_dwMask, _pszFunc, _pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceInfo(_pszMsg)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceInfo(_pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceInfo(_pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceInfo(_pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceInfoAssert(_exp, _pszMsg)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceInfoAssert(_exp, _pszMsg)	\
    if (!(_exp)) { \
		DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn);	\
    } else
#else
#define TraceInfoAssert(_exp, _pszMsg)	\
    if (!(_exp)) { \
		DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL);	\
    } else
#endif
#else
#define TraceInfoAssert(_exp, _pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceInfoSideAssert(_exp, _pszMsg)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceInfoSideAssert(_exp, _pszMsg)	\
    if (!(_exp)) { \
		DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn);	\
    } else
#else
#define TraceInfoSideAssert(_exp, _pszMsg)	\
    if (!(_exp)) { \
		DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL);	\
    } else
#endif
#else
#define TraceInfoSideAssert(_exp, _pszMsg)	(void)(_exp)
#endif

// --------------------------------------------------------------------------------
// TraceInfoLog(_pLog, _pszMsg)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceInfoLog(_pLog, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, _pLog, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceInfoLog(_pLog, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, _pLog, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceInfoLog(_pLog, _pszMsg) ((_pLog && _pLog->pLog) ? _pLog->pLog->TraceLog((_pLog)->dwMask, TRACE_INFO, __LINE__, S_OK, _pszMsg) : (void)0)
#endif

// --------------------------------------------------------------------------------
// TraceInfoTag(_dwMask, _pszMsg)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceInfoTag(_dwMask, _pszMsg) DebugTraceEx(_dwMask, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceInfoTag(_dwMask, _pszMsg) DebugTraceEx(_dwMask, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceInfoTag(_dwMask, _pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceError(_hrResult)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceError(_hrResult) \
    if (FAILED(_hrResult)) {                                                                            \
        DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, NULL, _pszfn);  \
    }                                                                                                   \
    else
#else
#define TraceError(_hrResult) \
    if (FAILED(_hrResult)) {                                                                            \
        DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, NULL, NULL);    \
    }                                                                                                   \
    else
#endif // defined(MSOEDBG_TRACECALLS)
#else
#define TraceError(_hrResult) _hrResult
#endif // defined(DEBUG)

// --------------------------------------------------------------------------------
// TraceResult(_hrResult)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceResult(_hrResult) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, NULL, _pszfn)
#else
#define TraceResult(_hrResult) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, NULL, NULL)
#endif
#else
#define TraceResult(_hrResult) _hrResult
#endif

// --------------------------------------------------------------------------------
// TraceResultLog(_pLog, _hrResult)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceResultLog(_pLog, _hrResult) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, _pLog, _hrResult, __FILE__, __LINE__, NULL, _pszfn)
#else
#define TraceResultLog(_pLog, _hrResult) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, _pLog, _hrResult, __FILE__, __LINE__, NULL, NULL)
#endif
#else
#define TraceResultLog(_pLog, _hrResult) ((_pLog && _pLog->pLog) ? _pLog->pLog->TraceLog((_pLog)->dwMask, TRACE_RESULT, __LINE__, _hrResult, NULL) : _hrResult)
#endif

// --------------------------------------------------------------------------------
// TraceResultSz(_hrResult, _pszMsg) - Use to log HRESULTs
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceResultSz(_hrResult, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceResultSz(_hrResult, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceResultSz(_hrResult, _pszMsg) _hrResult
#endif

// --------------------------------------------------------------------------------
// TraceResultLogSz(_pLog, _hrResult, _pszMsg) - Use to log HRESULTs
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceResultLogSz(_pLog, _hrResult, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, _pLog, _hrResult, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceResultLogSz(_pLog, _hrResult, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, _pLog, _hrResult, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceResultLogSz(_pLog, _hrResult, _pszMsg) ((_pLog && _pLog->pLog) ? _pLog->pLog->TraceLog((_pLog)->dwMask, TRACE_RESULT, __LINE__, _hrResult, _pszMsg) : _hrResult)
#endif

// --------------------------------------------------------------------------------
// TraceAssert(_exp, _msg) - Performs an assertSz() and TraceInfo
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#define TraceAssert(_exp, _msg) \
    if (!(_exp)) { \
        TraceInfo(_msg); \
        static char _szFile[] = __FILE__; \
        AssertSzFn((char*) _msg, _szFile, __LINE__); \
    } else
#else
#define TraceAssert(_exp, _msg) 
#endif

#endif // #if defined(__cplusplus)

// --------------------------------------------------------------------------------
// DOUT External Values
// --------------------------------------------------------------------------------
#ifdef DEBUG
extern DWORD dwDOUTLevel;
extern DWORD dwDOUTLMod;
extern DWORD dwDOUTLModLevel;
extern DWORD dwATLTraceLevel;
#endif // DEBUG

#if !defined( WIN16 ) || defined( __cplusplus )

// --------------------------------------------------------------------------------
// DOUTLL
// --------------------------------------------------------------------------------
#ifdef DEBUG
__inline void __cdecl DOUTLL(int iModule, int iLevel, LPSTR szFmt, ...) {
    if((iModule & dwDOUTLMod) && (iLevel & dwDOUTLModLevel)) {
        CHAR ach[MAX_PATH];
        va_list arglist;
        va_start(arglist, szFmt);
        wvnsprintf(ach, ARRAYSIZE(ach), szFmt, arglist);
        va_end(arglist);
        StrCatBuff(ach, szCRLF, ARRAYSIZE(ach));
        OutputDebugString(ach);
    }
}
#else
#define DOUTLL  1 ? (void)0 : (void)
#endif // DEBUG

// --------------------------------------------------------------------------------
// vDOUTL
// --------------------------------------------------------------------------------
#ifdef DEBUG
__inline void vDOUTL(int iLevel, LPSTR szFmt, va_list arglist) {
    if (iLevel & dwDOUTLevel) {
        CHAR ach[MAX_PATH];
        wvnsprintf(ach, ARRAYSIZE(ach), szFmt, arglist);
        StrCatBuff(ach, szCRLF, ARRAYSIZE(ach));
        OutputDebugString(ach);
    }
}
#else
#define vDOUTL  1 ? (void)0 : (void)
#endif // DEBUG

// --------------------------------------------------------------------------------
// DOUTL
// --------------------------------------------------------------------------------
#ifdef DEBUG
__inline void __cdecl DOUTL(int iLevel, LPSTR szFmt, ...) {
    va_list arglist;
    va_start(arglist, szFmt);
    vDOUTL(iLevel, szFmt, arglist);
    va_end(arglist);
}
#else
#define DOUTL   1 ? (void)0 : (void)
#endif // DEBUG

// --------------------------------------------------------------------------------
// vDOUT
// --------------------------------------------------------------------------------
#ifdef DEBUG
_inline void vDOUT(LPSTR szFmt, va_list arglist) {
    if (DOUT_LEVEL1 & dwDOUTLevel) {
        CHAR ach[MAX_PATH];
        wvnsprintf(ach, ARRAYSIZE(ach), szFmt, arglist);
        StrCatBuff(ach, szCRLF, ARRAYSIZE(ach));
        OutputDebugString(ach);
    }
}
#else
#define vDOUT   1 ? (void)0 : (void)
#endif // DEBUG

// --------------------------------------------------------------------------------
// OEAtlTrace - This is just like vDOUT except it doesn't add the crlf at the end.
//              It also has a different flag for turning off just the ATL output.
// --------------------------------------------------------------------------------
#ifdef DEBUG
_inline void OEAtlTrace(LPSTR szFmt, va_list arglist) {
    if (DOUT_LEVEL1 & dwATLTraceLevel) {
        CHAR ach[MAX_PATH];
        wvnsprintf(ach, ARRAYSIZE(ach), szFmt, arglist);
        OutputDebugString(ach);
    }
}
#else
#define OEAtlTrace   1 ? (void)0 : (void)
#endif // DEBUG

// --------------------------------------------------------------------------------
// OEATLTRACE
// --------------------------------------------------------------------------------
#ifdef DEBUG
__inline void __cdecl OEATLTRACE(LPSTR szFmt, ...) {
    va_list arglist;
    va_start(arglist, szFmt);
    OEAtlTrace(szFmt, arglist);
    va_end(arglist);
}
#else
#define OEATLTRACE    1 ? (void)0 : (void)
#endif // DEBUG


// --------------------------------------------------------------------------------
// DOUT
// --------------------------------------------------------------------------------
#ifdef DEBUG
__inline void __cdecl DOUT(LPSTR szFmt, ...) {
    va_list arglist;
    va_start(arglist, szFmt);
    vDOUT(szFmt, arglist);
    va_end(arglist);
}
#else
#define DOUT    1 ? (void)0 : (void)
#endif // DEBUG

#define TRACE DOUT
#endif //!def(WIN16) || def(__cplusplus)

// --------------------------------------------------------------------------------
// DOUT Functions implemented in msoert2.dll - debug.c
// --------------------------------------------------------------------------------
#ifdef DEBUG
EXTERN_C __cdecl DebugStrf(LPTSTR lpszFormat, ...);
EXTERN_C HRESULT HrTrace(HRESULT hr, LPSTR lpszFile, INT nLine);
#endif

// --------------------------------------------------------------------------------
// DebugTrace
// --------------------------------------------------------------------------------
#ifdef DEBUG
#ifndef DebugTrace
#define DebugTrace DebugStrf
#endif
#else
#ifndef DebugTrace
#define DebugTrace 1 ? (void)0 : (void)
#endif
#endif // DEBUG

// --------------------------------------------------------------------------------
// TrapError
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define TrapError(_hresult) HrTrace(_hresult, __FILE__, __LINE__)
#else
#define TrapError(_hresult) _hresult
#endif // DEBUG

// --------------------------------------------------------------------------------
// TRAPHR
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define TRAPHR(_hresult)    HrTrace(_hresult, __FILE__, __LINE__)
#else
#define TRAPHR(_hresult)    _hresult
#endif // DEBUG

// --------------------------------------------------------------------------------
// Assert Functions implemented in msoedbg.lib
// --------------------------------------------------------------------------------
#ifdef DEBUG
EXTERN_C void AssertSzFn(LPSTR, LPSTR, int);
EXTERN_C void NFAssertSzFn(LPSTR, LPSTR, int);
#endif // DEBUG


#endif // __MSOEDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\mirror.h ===
//
// Mirroring-Support APIs (astracted in \mailnews\lib\mirror\rtlmir.cpp)
//
#ifdef __cplusplus
extern "C" {
#endif

#ifdef USE_MIRRORING
BOOL  IsBiDiLocalizedSystem( void );
BOOL  Mirror_IsEnabledOS( void );
LANGID Mirror_GetUserDefaultUILanguage( void );
LONG Mirror_EnableWindowLayoutInheritance( HWND hWnd );
LONG Mirror_DisableWindowLayoutInheritance( HWND hWnd );
BOOL  Mirror_IsWindowMirroredRTL( HWND hWnd );
DWORD Mirror_IsDCMirroredRTL( HDC hdc );
DWORD Mirror_MirrorDC( HDC hdc );
BOOL  Mirror_MirrorProcessRTL( void );
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout );
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout );
BOOL Mirror_IsProcessRTL( void );
extern const DWORD dwNoMirrorBitmap;
extern const DWORD dwExStyleRTLMirrorWnd;
extern const DWORD dwPreserveBitmap;
//
// 'g_bMirroredOS' is defined in each component which will use the
//  mirroring APIs. I decided to put it here, in order to make sure
//  each component has validated that the OS supports the mirroring
//  APIs before calling them.
//

#define IS_BIDI_LOCALIZED_SYSTEM()       IsBiDiLocalizedSystem()
#define IS_MIRRORING_ENABLED()           Mirror_IsEnabledOS()
#define ENABLE_LAYOUT_INHERITANCE(hWnd)  Mirror_EnableWindowLayoutInheritance( hWnd )
#define DISABLE_LAYOUT_INHERITANCE(hWnd) Mirror_DisableWindowLayoutInheritance( hWnd )
#define IS_WINDOW_RTL_MIRRORED(hwnd)     (g_bMirroredOS && Mirror_IsWindowMirroredRTL(hwnd))
#define IS_DC_RTL_MIRRORED(hdc)          (g_bMirroredOS && Mirror_IsDCMirroredRTL(hdc))
#define GET_PROCESS_DEF_LAYOUT(pdwl)     (g_bMirroredOS && Mirror_GetProcessDefaultLayout(pdwl))
#define IS_PROCESS_RTL_MIRRORED()        (g_bMirroredOS && Mirror_IsProcessRTL())
#define SET_DC_RTL_MIRRORED(hdc)         Mirror_MirrorDC(hdc)
#define SET_DC_LAYOUT(hdc,dwl)           Mirror_SetLayout(hdc,dwl)
#define SET_PROCESS_RTL_LAYOUT()         Mirror_MirrorProcessRTL()
#define DONTMIRRORBITMAP                 dwNoMirrorBitmap
#define RTL_MIRRORED_WINDOW              dwExStyleRTLMirrorWnd
#define LAYOUT_PRESERVEBITMAP            dwPreserveBitmap

#else
#define IS_BIDI_LOCALIZED_SYSTEM()       FALSE
#define IS_MIRRORING_ENABLED()           FALSE
#define IS_WINDOW_RTL_MIRRORED(hwnd)     FALSE
#define IS_DC_RTL_MIRRORED(hdc)          FALSE
#define GET_PROCESS_DEF_LAYOUT(pdwl)     FALSE
#define IS_PROCESS_RTL_MIRRORED()        FALSE
#define SET_DC_RTL_MIRRORED(hdc)        
#define SET_DC_LAYOUT(hdc,dwl)
#define SET_PROCESS_DEFAULT_LAYOUT()  
#define ENABLE_LAYOUT_INHERITANCE(hWnd)  0L
#define DISABLE_LAYOUT_INHERITANCE(hWnd) 0L  
#define DONTMIRRORBITMAP                 0L
#define RTL_MIRRORED_WINDOW              0L
#define LAYOUT_PRESERVEBITMAP            0L

// MirLibIsOS(): returns TRUE/FALSE if the platform is the indicated OS.
STDAPI_(BOOL) MirLibIsOS(DWORD dwOS);
#endif  // USE_MIRRROING

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\macdupls.h ===
// -----------------------------------------------------------------------------
// macdupls.h
// 
// This file is used to map functions to Macintosh specific implementations.
// 
// Brian A. Moore - 4/28/97
// -----------------------------------------------------------------------------
#ifndef _MACDUPLS_H
#define _MACDUPLS_H
#ifdef MAC

// Need to make these functions unique
#define DebugStrf               Athena_DebugStrf
#define AssertSzFn              Athena_AssertSzFn
#define DllCanUnloadNow         Athena_DllCanUnloadNow

#define HinstDll                CryptDlg_HinstDll

// for functions in IMNXPORT.LIB
#define SzGetLocalPackedIP      Mac_SzGetLocalPackedIP   
#define SzGetLocalHostNameForID Mac_SzGetLocalHostNameForID
#define SzGetLocalHostName      Mac_SzGetLocalHostNameForID

// for some functions that are duplicated in Capone
#define MakeFileName        Athena_MakeFileName
#define StripUndesirables   Athena_StripUndesirables

// These are needed only for MLANG support and
// can be removed when MLANG is brought online.
typedef HRESULT (*PFMAC_BreakLineA)(LCID, UINT, const CHAR*, long, long, long*, long*);
typedef HRESULT (*PFMAC_BreakLineW)(LCID, const WCHAR*, long, long, long*, long*);

HRESULT MAC_BreakLineA(LCID locale, UINT uCodePage, const CHAR* pszSrc, long cchSrc,
                            long cMaxColumns, long* pcchLine, long* pcchSkip);
HRESULT MAC_BreakLineW(LCID locale, const WCHAR* pszSrc, long cchSrc,
                            long cMaxColumns, long* pcchLine, long* pcchSkip);
typedef struct _MAC_LineBreakConsole
{
    PFMAC_BreakLineA BreakLineA;
    PFMAC_BreakLineW BreakLineW;
} MAC_LineBreakConsole, * PMAC_LineBreakConsole;

STDAPI MAC_IsConvertINetStringAvailable(DWORD dwSrcEncoding, DWORD dwDstEncoding);
#define IsConvertINetStringAvailable    MAC_IsConvertINetStringAvailable

STDAPI MAC_ConvertINetString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding,
                    LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize);
#define ConvertINetString    MAC_ConvertINetString

// for inetcomm\mimeole\vstream.cpp
#define VirtualAlloc(_a, _b, _c, _d)    malloc(_b)
#define VirtualFree(_a, _b, _c)         free(_a)

// for lack of CoRegisterClassObject support
#undef CoCreateInstance
STDAPI Athena_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwContext,
							REFIID iid, LPVOID * ppv);
#define CoCreateInstance    Athena_CoCreateInstance
STDAPI Ares_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv);
STDAPI Athena_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv);
#define DllGetClassObject       Athena_DllGetClassObject

#include <mapinls.h>

// For WinNLS support
#ifndef MB_PRECOMPOSED
#define MB_PRECOMPOSED       0x00000001     /* use precomposed chars */
#endif  // !MB_PRECOMPOSED

EXTERN_C BOOL WINAPI MNLS_IsValidCodePage(UINT  uiCodePage);
#define IsValidCodePage     MNLS_IsValidCodePage

EXTERN_C BOOL WINAPI MNLS_IsDBCSLeadByteEx(UINT  uiCodePage, BYTE TestChar);
#define IsDBCSLeadByteEx    MNLS_IsDBCSLeadByteEx
#define IsDBCSLeadByte(_a)  MNLS_IsDBCSLeadByteEx(CP_ACP, (_a))

EXTERN_C int WINAPI MAC_MultiByteToWideChar(UINT uCodePage, DWORD dwFlags,
		LPCSTR lpMultiByteStr, int cchMultiByte,
		LPWSTR lpWideCharStr, int cchWideChar);
#undef MultiByteToWideChar
#define MultiByteToWideChar MAC_MultiByteToWideChar

EXTERN_C int WINAPI MAC_WideCharToMultiByte(UINT uCodePage, DWORD dwFlags,
	LPCWSTR lpWideCharStr, int cchWideChar,
	LPSTR lpMultiByteStr, int cchMultiByte,
	LPCSTR lpDefaultChar, BOOL FAR *lpfUsedDefaultChar);
#undef WideCharToMultiByte
#define WideCharToMultiByte MAC_WideCharToMultiByte

// For inetcomm\mapimime\cpropv.cpp
#define X_lstrcmpW lstrcmpW

// For inetcomm\mapimime\mapimime.cpp
#define CharNextExA(_a, _b, _c)         CharNext((_b))
#define CharPrevExA(_a, _b, _c, _d)     CharPrev((_b), (_c))

// For cryptdlg/select.cpp
STDAPI_(LPWSTR) PszDupW(LPCWSTR pcwszSource);
STDAPI_(int) MNLS_lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);

#define wcslen(_a)          ((size_t)lstrlenW(_a))
#define _wcsdup             PszDupW
#define wcscmp              MNLS_lstrcmpW
wchar_t * __cdecl WchCryptDlgWcsStr (const wchar_t * wcs1, const wchar_t * wcs2);
#define wcsstr              WchCryptDlgWcsStr

// For _splitpath support
#ifndef _MAX_EXT
#define _MAX_EXT    256
#endif  // !_MAX_EXT

// WinHelp patch
EXTERN_C BOOL ExchWinHelp(HWND hwndMain, LPCSTR szHelp, UINT uCommand, DWORD dwData);
#define WinHelpA    ExchWinHelp
#undef WinHelp
#define WinHelp     ExchWinHelp

// More support for SHLWAPI.H
STDAPI_(LPSTR)  MAC_PathFindExtension(LPCSTR pszPath);
STDAPI_(LPSTR)  MAC_PathFindFileName(LPCSTR pszPath);
STDAPI_(LPSTR)  MAC_StrFormatByteSize(DWORD dw, LPSTR szBuf, UINT uiBufSize);
STDAPI_(LPSTR)  Mac_StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch);
STDAPI_(LPSTR)  PszDupA(LPCSTR pcszSource);
STDAPI          MAC_UrlUnescapeA(LPSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags);

#define URL_DONT_ESCAPE_EXTRA_INFO      0x02000000
#define URL_DONT_UNESCAPE_EXTRA_INFO    URL_DONT_ESCAPE_EXTRA_INFO
#define URL_BROWSER_MODE                URL_DONT_ESCAPE_EXTRA_INFO
#define URL_UNESCAPE_INPLACE            0x00100000

#define StrChr              strchr
#define StrChrA             strchr
#define StrDupA             PszDupA
#define StrToInt            atoi
#define StrCmpNI            _strnicmp
#define StrCmpN             strncmp
#define StrStr              strstr
#define StrStrI             Mac_StrStrIA
#define StrFormatByteSize   MAC_StrFormatByteSize
#define PathFindExtension   MAC_PathFindExtension
#define PathFindFileName    MAC_PathFindFileName
#define UrlUnescapeA        MAC_UrlUnescapeA

// Support for URLMON.H
STDAPI MAC_CoInternetCombineUrl(LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags,          
                        LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);                                   
#define CoInternetCombineUrl    MAC_CoInternetCombineUrl

// These are for functions in MSOERT
#define CchFileTimeToDateTimeSz     MAC_CchFileTimeToDateTimeSz

// For _int64 support with LARGE_INTEGER
#define QuadPart    BuildBreak

#endif  // MAC
#endif  //  !_MACDUPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\msoeopt.h ===
#ifndef _INC_MSOEOPT_H
#define _INC_MSOEOPT_H

#include <msoeprop.h>

interface IOptionBucketEx;

// {ED5EE630-5BA4-11d1-AA16-006097D474C4}
DEFINE_GUID(IID_IOptionBucketNotify, 0xed5ee630, 0x5ba4, 0x11d1, 0xaa, 0x16, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

interface IOptionBucketNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoNotification(IOptionBucketEx *pBckt, HWND hwnd, PROPID id) = 0;
    };

MSOEACCTAPI CreatePropertyBucket(IPropertyBucket **ppPropBckt);

typedef HRESULT (CALLBACK *PFNVALIDPROP)(PROPID, LPCPROPVARIANT);

typedef struct tagOPTIONINFO
    {
    PROPID id;
    VARTYPE vt;
    int iszRegKey;      // index into rgpszRegKey
    LPCSTR pszRegValue;
    LPCSTR pszDef;
    int cbDefBinary;    // if pszDef points to a binary struct, this is the size
    DWORD dwMin;
    DWORD dwMax;
    PFNVALIDPROP pfnValid;
    } OPTIONINFO;

typedef const OPTIONINFO *LPCOPTIONINFO;

// {4091C7B0-5557-11d1-AA13-006097D474C4}
DEFINE_GUID(IID_IOptionBucketEx, 0x4091c7b0, 0x5557, 0x11d1, 0xaa, 0x13, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// flags for ISetProperty
#define SP_DONOTIFY     0x0001

typedef struct tagOPTBCKTINIT
    {
    LPCOPTIONINFO rgInfo;
    int cInfo;

    HKEY hkey;
    LPCSTR pszRegKeyBase;
    LPCSTR *rgpszRegSubKey;
    int cszRegKey;
    } OPTBCKTINIT, *LPOPTBCKTINIT;
typedef const OPTBCKTINIT *LPCOPTBCKTINIT;

// implemented by athena
// used by options and accounts
interface IOptionBucketEx : public IOptionBucket
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(LPCOPTBCKTINIT pInit) = 0;
        virtual HRESULT STDMETHODCALLTYPE ISetProperty(HWND hwnd, LPCSTR pszProp, LPCPROPVARIANT pVar, DWORD dwFlags) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetNotification(IOptionBucketNotify *pNotify) = 0;
        virtual HRESULT STDMETHODCALLTYPE EnableNotification(BOOL fEnable) = 0;

        virtual LONG STDMETHODCALLTYPE GetValue(LPCSTR szSubKey, LPCSTR szValue, DWORD *ptype, LPBYTE pb, DWORD *pcb) = 0;
        virtual LONG STDMETHODCALLTYPE SetValue(LPCSTR szSubKey, LPCSTR szValue, DWORD type, LPBYTE pb, DWORD cb) = 0;
    };

MSOEACCTAPI CreateOptionBucketEx(IOptionBucketEx **ppOptBcktEx);

#ifdef DEAD
// IDisplayOption::SetOption flags
#define SETOPTION_DISABLE   0x0001
#define SETOPTION_HIDE      0x0002

// {EC320F22-4B33-11d1-AA10-006097D474C4}
DEFINE_GUID(IID_IDisplayOptions, 0xec320f22, 0x4b33, 0x11d1, 0xaa, 0x10, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// implemented by athena
interface IDisplayOptions : public IOptionBucket
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertPage(HPROPSHEETPAGE hpage, DWORD dwBeforePageID, DWORD dwReserved) = 0;
        virtual HRESULT STDMETHODCALLTYPE RemovePage(DWORD dwPageID, DWORD dwReserved) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetOption(PROPID id, DWORD dwFlags) = 0;
    };

// {EC320F23-4B33-11d1-AA10-006097D474C4}
DEFINE_GUID(IID_IOptionsExtension, 0xec320f23, 0x4b33, 0x11d1, 0xaa, 0x10, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// implemented by externals
interface IOptionsExtension : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DisplayOptions(HWND hwndParent, IOptionBucket *pCont, DWORD dwReserved) = 0;
        virtual HRESULT STDMETHODCALLTYPE InitializeOptions(IDisplayOptions *pOpt, DWORD dwReserved) = 0;
    };

interface IAccount;

// {EC320F24-4B33-11d1-AA10-006097D474C4}
DEFINE_GUID(IID_IAccountExtension, 0xec320f24, 0x4b33, 0x11d1, 0xaa, 0x10, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// implemented by externals
interface IAccountExtension : public IOptionsExtension
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NewAccountWizard(HWND hwndParent, IAccount *pAcctNew) = 0;
    };

#endif // DEAD

#endif // _INC_MSOEOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\privunk.h ===
// --------------------------------------------------------------------------------
// Privunk.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __PRIVUNK_H
#define __PRIVUNK_H

// --------------------------------------------------------------------------------
// CPrivateUnknown
// --------------------------------------------------------------------------------
class CPrivateUnknown : public IUnknown
{
private:
    // ----------------------------------------------------------------------------
    // Embed default IUnknown handler
    // ----------------------------------------------------------------------------
    class CUnkInner : public IUnknown
    {
    private:
        LONG m_cRef;     // Private Ref Count

    public:
        // Construction
        CUnkInner(void) { m_cRef = 1; }

        // IUnknown Members
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);
    };

    friend class CUnkInner;

    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    CUnkInner           m_cUnkInner;      // Private Inner
    IUnknown           *m_pUnkOuter;      // points to _cUnkInner or aggregating IUnknown

protected:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CPrivateUnknown(IUnknown *pUnkOuter);
    virtual ~CPrivateUnknown(void) {};

    // ----------------------------------------------------------------------------
    // This is the QueryInterface the aggregator implements
    // ----------------------------------------------------------------------------
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj) = 0;

public:
    // ----------------------------------------------------------------------------
    // This is the IUnknown that subclasses returns from their CreateInstance func
    // ----------------------------------------------------------------------------
    IUnknown* GetInner() { return &m_cUnkInner; }

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    inline virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) {
        return m_pUnkOuter->QueryInterface(riid, ppvObj); }
    inline virtual STDMETHODIMP_(ULONG) AddRef(void) {
        return m_pUnkOuter->AddRef(); }
    inline virtual STDMETHODIMP_(ULONG) Release(void) {
        return m_pUnkOuter->Release(); }

    // ----------------------------------------------------------------------------
    // Public Utilities
    // ----------------------------------------------------------------------------
    void SetOuter(IUnknown *pUnkOuter);
};

#endif // __PRIVUNK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\notify.h ===
//+-------------------------------------------------------------------------
// Notify.h
//--------------------------------------------------------------------------
#ifndef __NOTIFY_H
#define __NOTIFY_H

#include <msoeapi.h>

//+-------------------------------------------------------------------------
// Consts
//--------------------------------------------------------------------------
#define CMAX_HWND_NOTIFY         128
#define CMAX_STRUCT_MEMBERS      10
#define MSEC_WAIT_NOTIFY         10000

//+-------------------------------------------------------------------------
// STNOTIFYINFO
//--------------------------------------------------------------------------
#define SNF_POSTMSG              0           // Default: Use a PostMessage Command
#define SNF_SENDMSG              0x00000001  // Use a SendMessage command
#define SNF_CALLBACK             0x00000002  // DoNotify - wParam = callback function, lParam = cookie
#define SNF_CROSSPROCESS         0x00000004  // Do not do any cross-process notifications, data can't be thunked
#define SNF_HASTHUNKINFO         0x00000008  // Can go cross-process and data does not need no thunking (wParam and/or lParam are not pointers)
#define SNF_VALIDPARAM1          0x00000010  // NOTIFYDATA::rParam1 is valid
#define SNF_VALIDPARAM2          0x00000020  // NOTIFYDATA::rParam2 is valid
#define SNR_UNREGISTER           0xfffffff0  // A notified hwnd can return this after a SendMessage to auto-unregister itself

//+-------------------------------------------------------------------------
// NOTIFYWINDOW
//--------------------------------------------------------------------------
typedef struct tagNOTIFYWINDOW const *LPCNOTIFYWINDOW;
typedef struct tagNOTIFYWINDOW {
    HWND            hwndThunk;          // Thunking window for x-process notify
    HWND            hwndNotify;         // Handle of window to notify
    BOOL            fExternal;          // Notification is going to an IStoreNamespace or IStoreFolder user
} NOTIFYWINDOW, *LPNOTIFYWINDOW;

//+-------------------------------------------------------------------------
// NOTIFYWINDOWTABLE
//--------------------------------------------------------------------------
typedef struct tagNOTIFYWINDOWTABLE const *LPCNOTIFYWINDOWTABLE;
typedef struct tagNOTIFYWINDOWTABLE {
    DWORD           cWindows;           // Number of registered windows
    NOTIFYWINDOW    rgWindow[CMAX_HWND_NOTIFY]; // Array of thunk/notify windows
} NOTIFYWINDOWTABLE, *LPNOTIFYWINDOWTABLE;

//+-------------------------------------------------------------------------
// MEMBERINFO Flags
//--------------------------------------------------------------------------
#define MEMBERINFO_POINTER       0x00000001
#define MEMBERINFO_POINTER_NULL  (MEMBERINFO_POINTER | 0x00000002)

//+-------------------------------------------------------------------------
// MEMBERINFO - Used to describe the members of a structure
//--------------------------------------------------------------------------
typedef struct tagMEMBERINFO const *LPCMEMBERINFO;
typedef struct tagMEMBERINFO {
    DWORD           dwFlags;            // MEMBERINFO_xxx Flags
    DWORD           cbSize;             // Size of the member
    DWORD           cbData;             // Size of the data
    LPBYTE          pbData;             // Pointer to the data
} MEMBERINFO, *LPMEMBERINFO;

//+-------------------------------------------------------------------------
// STRUCTINFO Flags
//--------------------------------------------------------------------------
#define STRUCTINFO_VALUEONLY     0x00000001
#define STRUCTINFO_POINTER       0x00000002

//+-------------------------------------------------------------------------
// STRUCTINFO - Used to describe the data in a notification parameter
//--------------------------------------------------------------------------
typedef struct tagSTRUCTINFO const *LPCSTRUCTINFO;
typedef struct tagSTRUCTINFO {
    DWORD           dwFlags;            // STRUCTINFO_xxx Flags
    DWORD           cbStruct;           // Size of the structure that we are defining
    LPBYTE          pbStruct;           // Parameter that can be used inproc
    ULONG           cMembers;           // Number of members in the structure
    MEMBERINFO      rgMember[CMAX_STRUCT_MEMBERS]; // An array of members
} STRUCTINFO, *LPSTRUCTINFO;

//+-------------------------------------------------------------------------
// NOTIFYDATA
//--------------------------------------------------------------------------
typedef struct tagNOTIFYDATA {
    HWND            hwndNotify;         // Window to notify
    UINT            msg;                // The notification window message to send
    WPARAM          wParam;             // The wParam data
    LPARAM          lParam;             // The lParam data
    DWORD           dwFlags;            // SNF_xxx Flags
    STRUCTINFO      rParam1;            // First parameter (wParam)
    STRUCTINFO      rParam2;            // Second parameter (lParam)
    COPYDATASTRUCT  rCopyData;          // CopyData Struct
} NOTIFYDATA, *LPNOTIFYDATA;

//+-------------------------------------------------------------------------
// A Callback can return 
//--------------------------------------------------------------------------
typedef HRESULT (*PFNNOTIFYCALLBACK)(LPARAM lParam, LPNOTIFYDATA pNotify, BOOL fNeedThunk, BOOL fExternal);

//+-------------------------------------------------------------------------
// IStoreNotify
//--------------------------------------------------------------------------
interface INotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(LPCSTR pszName) = 0;
        virtual HRESULT STDMETHODCALLTYPE Register(HWND hwndNotify, HWND hwndThunk, BOOL fExternal) = 0;
        virtual HRESULT STDMETHODCALLTYPE Unregister(HWND hwndNotify) = 0;
        virtual HRESULT STDMETHODCALLTYPE Lock(HWND hwnd) = 0;
        virtual HRESULT STDMETHODCALLTYPE Unlock(void) = 0;
        virtual HRESULT STDMETHODCALLTYPE NotificationNeeded(void) = 0;
        virtual HRESULT STDMETHODCALLTYPE DoNotification(UINT uWndMsg, WPARAM wParam, LPARAM lParam, DWORD dwFlags) = 0;
    };

//+-------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
OESTDAPI_(HRESULT) CreateNotify(INotify **ppNotify);
OESTDAPI_(HRESULT) BuildNotificationPackage(LPNOTIFYDATA pNotify, PCOPYDATASTRUCT pCopyData);
OESTDAPI_(HRESULT) CrackNotificationPackage(PCOPYDATASTRUCT pCopyData, LPNOTIFYDATA pNotify);

#endif // __NOTIFY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\msoert.h ===
// --------------------------------------------------------------------------------
// Msoert.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// Debug Crap
// --------------------------------------------------------------------------------
#include "msoedbg.h"

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
#if !defined(__MSOERT_H) || defined(INITGUID)

// {220D5CC1-853A-11d0-84BC-00C04FD43F8F}
#ifdef ENABLE_RULES
DEFINE_GUID(PST_IDENT_TYPE_GUID, 0x220d5cc3, 0x853a, 0x11d0, 0x84, 0xbc, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#elif defined(N_TEST)
DEFINE_GUID(PST_IDENT_TYPE_GUID, 0x220d5cc2, 0x853a, 0x11d0, 0x84, 0xbc, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#else
DEFINE_GUID(PST_IDENT_TYPE_GUID, 0x220d5cc1, 0x853a, 0x11d0, 0x84, 0xbc, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#endif

// {417E2D75-84BD-11d0-84BB-00C04FD43F8F}
#ifdef ENABLE_RULES
DEFINE_GUID(PST_IMNACCT_SUBTYPE_GUID, 0x417e2d77, 0x84bd, 0x11d0, 0x84, 0xbb, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#elif defined(N_TEST)
DEFINE_GUID(PST_IMNACCT_SUBTYPE_GUID, 0x417e2d76, 0x84bd, 0x11d0, 0x84, 0xbb, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#else
DEFINE_GUID(PST_IMNACCT_SUBTYPE_GUID, 0x417e2d75, 0x84bd, 0x11d0, 0x84, 0xbb, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#endif

// {6ADF2E20-8803-11d0-84BF-00C04FD43F8F}
DEFINE_GUID(PST_CERTS_SUBTYPE_GUID, 0x6adf2e20, 0x8803, 0x11d0, 0x84, 0xbf, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);

#endif // !defined(__MSOERT_H) || defined(INITGUID)

// --------------------------------------------------------------------------------
// Include the rest of the stuff
// --------------------------------------------------------------------------------
#ifndef __MSOERT_H
#define __MSOERT_H


// --------------------------------------------------------------------------------
// Define API decoration for direct importing of DLL references.
// --------------------------------------------------------------------------------

// OESTDAPI - Things exported from msoert2.dll (no debug exports)
#if !defined(_MSOERT_)
    #define OESTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else   // _MSOERT_
    #define OESTDAPI_(type)   STDAPI_(type)
#endif  // !_MSOERT_

#define DLLEXPORT   __declspec(dllexport)

#ifndef NOFLAGS
#define NOFLAGS 0
#endif

// --------------------------------------------------------------------------------
// IN OUT OPTIONS Definitions
// --------------------------------------------------------------------------------
#ifndef OUT
#define OUT
#endif

#ifndef IN
#define IN
#endif

#ifndef IN_OUT
#define IN_OUT
#endif

#ifndef IN_OPT
#define IN_OPT
#endif

#ifndef OUT_OPT
#define OUT_OPT
#endif

#ifndef IN_OUT_OPT
#define IN_OUT_OPT
#endif

//WIn64 macros
#ifdef _WIN64
#if defined (_AMD64_) || defined (_IA64_)
#define ALIGNTYPE			LARGE_INTEGER
#else
#define ALIGNTYPE			DWORD
#endif
#define	ALIGN				((ULONG) (sizeof(ALIGNTYPE) - 1))
#define LcbAlignLcb(lcb)	(((lcb) + ALIGN) & ~ALIGN)
#define PbAlignPb(pb)		((LPBYTE) ((((DWORD) (pb)) + ALIGN) & ~ALIGN))
#define	MYALIGN				((POINTER_64_INT) (sizeof(ALIGNTYPE) - 1))
#define MyPbAlignPb(pb)		((LPBYTE) ((((POINTER_64_INT) (pb)) + MYALIGN) & ~MYALIGN))
#else //!WIN64
#define LcbAlignLcb(lcb)	(lcb)
#define PbAlignPb(pb)		(pb)
#define MyPbAlignPb(pb)		(pb)
#endif 

// --------------------------------------------------------------------------------
// CRLF Definitions
// --------------------------------------------------------------------------------
#define wchCR   L'\r'
#define wchLF   L'\n'
#define chCR    '\r'
#define chLF    '\n'
#define szCRLF  "\r\n"

// --------------------------------------------------------------------------------
// Versioning Magic
// --------------------------------------------------------------------------------
typedef enum tagOEDLLVERSION {
    OEDLL_VERSION_5=1
} OEDLLVERSION;

#define OEDLL_VERSION_CURRENT OEDLL_VERSION_5
#define STR_GETDLLMAJORVERSION "GetDllMajorVersion"
typedef OEDLLVERSION (APIENTRY *PFNGETDLLMAJORVERSION)(void);

// --------------------------------------------------------------------------------
// RGB_AUTOCOLOR
// --------------------------------------------------------------------------------
#define RGB_AUTOCOLOR       ((COLORREF)-1)

// --------------------------------------------------------------------------------
// NEXTID
// --------------------------------------------------------------------------------
#define NEXTID(pidl)    ((LPITEMIDLIST)(((BYTE *)(pidl))+(pidl)->mkid.cb))
#define PAD4(x)         (((x)+3)&~3)

// --------------------------------------------------------------------------------
// INLINE
// --------------------------------------------------------------------------------
#ifdef INLINE
    #error define overlap
#else
// speed up debug build by turning off inline functions
    #ifdef DEBUG
        #define INLINE
    #else
        #define INLINE inline
    #endif
#endif

// --------------------------------------------------------------------------------
// IS_EXTENDED
// --------------------------------------------------------------------------------
#define IS_EXTENDED(ch) \
    ((ch > 126 || ch < 32) && ch != '\t' && ch != '\n' && ch != '\r')

// --------------------------------------------------------------------------------
// Flag Utility Functions
// --------------------------------------------------------------------------------
#define FLAGSET(_dw, _f)             do {_dw |= (_f);} while (0)
#define FLAGTOGGLE(_dw, _f)          do {_dw ^= (_f);} while (0)
#define FLAGCLEAR(_dw, _f)           do {_dw &= ~(_f);} while (0)
#define ISFLAGSET(_dw, _f)           (BOOL)(((_dw) & (_f)) == (_f))
#define ISFLAGCLEAR(_dw, _f)         (BOOL)(((_dw) & (_f)) != (_f))

// --------------------------------------------------------------------------------
// Used for building an IDataObject format enumerator
// --------------------------------------------------------------------------------
#define SETDefFormatEtc(fe, cf, med) {\
    (fe).cfFormat = ((CLIPFORMAT) (cf)); \
    (fe).dwAspect = DVASPECT_CONTENT; \
    (fe).ptd = NULL; \
    (fe).tymed = med; \
    (fe).lindex = -1; \
}

// --------------------------------------------------------------------------------
// Some defines to create bit fields easier
// --------------------------------------------------------------------------------
#define FLAG01 0x00000001
#define FLAG02 0x00000002
#define FLAG03 0x00000004
#define FLAG04 0x00000008
#define FLAG05 0x00000010
#define FLAG06 0x00000020
#define FLAG07 0x00000040
#define FLAG08 0x00000080
#define FLAG09 0x00000100
#define FLAG10 0x00000200
#define FLAG11 0x00000400
#define FLAG12 0x00000800
#define FLAG13 0x00001000
#define FLAG14 0x00002000
#define FLAG15 0x00004000
#define FLAG16 0x00008000
#define FLAG17 0x00010000
#define FLAG18 0x00020000
#define FLAG19 0x00040000
#define FLAG20 0x00080000
#define FLAG21 0x00100000
#define FLAG22 0x00200000
#define FLAG23 0x00400000
#define FLAG24 0x00800000
#define FLAG25 0x01000000
#define FLAG26 0x02000000
#define FLAG27 0x04000000
#define FLAG28 0x08000000
#define FLAG29 0x10000000
#define FLAG30 0x20000000
#define FLAG31 0x40000000
#define FLAG32 0x80000000

// --------------------------------------------------------------------------------
// Support Inclusion into a C file
// --------------------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------------
// Common String Lengths
// --------------------------------------------------------------------------------
#define cchMaxDate  64
#define cchMaxTime  22

// --------------------------------------------------------------------------------
// ARRAYSIZE - Don't use this on extern'ed global data structures, it won't work
// --------------------------------------------------------------------------------
#ifndef ARRAYSIZE
#define ARRAYSIZE(_rg)  (sizeof((_rg))/sizeof((_rg)[0]))
#endif // ARRAYSIZE

// --------------------------------------------------------------------------------
// HANDLE_COMMAND - Used in a WindowProc to simplify handling of WM_COMMAND messages
// --------------------------------------------------------------------------------
#define HANDLE_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
                case (id): { (fn)((HWND)(hwnd), (HWND)(hwndCtl), (UINT)(codeNotify)); break; }

// --------------------------------------------------------------------------------
// Standard Boolean Constants
// --------------------------------------------------------------------------------
#define fFalse          ((BOOL) 0)
#define fTrue           ((BOOL) 1)

// --------------------------------------------------------------------------------
// Storage class macros
// --------------------------------------------------------------------------------
#ifdef _X86_
#define BEGIN_CODESPACE_DATA data_seg(".rdata")
#define BEGIN_NAME_CODESPACE_DATA(a) data_seg(".rdata$"#a, ".rdata")
#define BEGIN_FUNCTION_CODESPACE_DATA data_seg(".rdata")
#define END_CODESPACE_DATA data_seg()
#define BEGIN_NAME_DATA(a) data_seg(".data$"#a, ".data")
#define END_NAME_DATA data_seg()
#else
#define BEGIN_FUNCTION_CODESPACE_DATA
#define BEGIN_NAME_CODESPACE_DATA(a)
#define BEGIN_CODESPACE_DATA
#define END_CODESPACE_DATA
#define BEGIN_NAME_DATA(a)
#define END_NAME_DATA
#endif

// --------------------------------------------------------------------------------
// Macro that causes the compiler to ignore a local variable or
// parameter without generating a warning.
// --------------------------------------------------------------------------------
#ifndef Unreferenced
#define Unreferenced(a)         ((void)a)
#endif

// --------------------------------------------------------------------------------
// SAFECAST - Insures that a cast is valid, otherwise it won't compile
// --------------------------------------------------------------------------------
#define SAFECAST(_src, _type) (((_type)(_src)==(_src)?0:0), (_type)(_src))
// --------------------------------------------------------------------------------
// Computes the size of a member in a structure
// --------------------------------------------------------------------------------
#define sizeofMember(s,m)       sizeof(((s *)0)->m)

#if 0

// --------------------------------------------------------------------------------
// Computes the byte offset to the parent class from a nested class
// --------------------------------------------------------------------------------
#define _OEOffset(class, itf)         ((UINT)&(((class *)0)->itf))

// --------------------------------------------------------------------------------
// Computes the parent interface of a nested class
// --------------------------------------------------------------------------------
/------------------Merge Conflict------------------\
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_OEOffset(class, itf)))
#endif

// --------------------------------------------------------------------------------
// SafeReleaseCnt - SafeRelease and set ulCount to the after release ref count
// --------------------------------------------------------------------------------
#define SafeReleaseCnt(_object, _refcount) \
    if (_object) { \
        (_refcount) = (_object)->Release (); \
        (_object) = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafeRelease - Releases an object and sets the object to NULL
// --------------------------------------------------------------------------------
#define SafeRelease(_object) \
    if (_object) { \
        (_object)->Release(); \
        (_object) = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafeFreeLibrary - Checks if _hinst is non null and then calls FreeLibrary
// --------------------------------------------------------------------------------
#define SafeFreeLibrary(_hinst) \
    if (_hinst) { \
        FreeLibrary(_hinst); \
        _hinst = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafeCloseHandle
// --------------------------------------------------------------------------------
#define SafeCloseHandle(_handle) \
    if (_handle) { \
        CloseHandle(_handle); \
        _handle = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafeUnmapViewOfFile
// --------------------------------------------------------------------------------
#define SafeUnmapViewOfFile(_pView) \
    if (_pView) { \
        UnmapViewOfFile((LPVOID)_pView); \
        _pView = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafePidlFree
// --------------------------------------------------------------------------------
#define SafePidlFree(_pidl) \
    if (_pidl) { \
        PidlFree(_pidl); \
        _pidl = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafeInternetCloseHandle
// --------------------------------------------------------------------------------
#define SafeInternetCloseHandle(_handle) \
        if (_handle) { \
                InternetCloseHandle(_handle); \
                _handle = NULL; \
        } else

// --------------------------------------------------------------------------------
// SafeDelete - safely deletes a non-referenced counted object
// --------------------------------------------------------------------------------
#define SafeDelete(_obj) \
        if (_obj) { \
                delete _obj; \
                _obj = NULL; \
        } else

// --------------------------------------------------------------------------------
// ReleaseObj - Releases an Object if it is not NULL
// --------------------------------------------------------------------------------
#ifndef ReleaseObj
#ifdef __cplusplus
#define ReleaseObj(_object)   (_object) ? (_object)->Release() : 0
#else
#define ReleaseObj(_object)   (_object) ? (_object)->lpVtbl->Release(_object) : 0
#endif // __cplusplus
#endif

// --------------------------------------------------------------------------------
// SafeSysFreeString - Frees a bstr if not NULL
// --------------------------------------------------------------------------------
#define SafeSysFreeString(_x) \
    if (_x) { \
        SysFreeString(_x);\
        _x = NULL; \
    } else

 // -------------------------------------------------------------------------

 // ReplaceInterface - Replaces a member interface with a new interface
 // -------------------------------------------------------------------------

 #define ReplaceInterface(_pUnk, _pUnkNew)  \
     { \
     if (_pUnk)  \
         (_pUnk)->Release();   \
     if ((_pUnk) = (_pUnkNew))   \
         (_pUnk)->AddRef();    \
     }

#ifdef __cplusplus
}
#endif

// --------------------------------------------------------------------------------
// SetWndThisPtrOnCreate
// --------------------------------------------------------------------------------
#define SetWndThisPtrOnCreate(hwnd, lpcs) \
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)(((LPCREATESTRUCT)lpcs)->lpCreateParams))

// --------------------------------------------------------------------------------
// SetWndThisPtr
// --------------------------------------------------------------------------------
#define SetWndThisPtr(hwnd, THIS) \
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)THIS)

// --------------------------------------------------------------------------------
// GetWndThisPtr
// --------------------------------------------------------------------------------
#define GetWndThisPtr(hwnd) \
    GetWindowLongPtr(hwnd, GWLP_USERDATA)

// --------------------------------------------------------------------------------
// ListView Helper Macros
// --------------------------------------------------------------------------------
#define ListView_GetSelFocused(_hwndlist)        ListView_GetNextItem(_hwndlist, -1, LVNI_SELECTED|LVIS_FOCUSED)
#define ListView_GetFirstSel(_hwndlist)          ListView_GetNextItem(_hwndlist, -1, LVNI_SELECTED)
#define ListView_GetFocusedItem(_hwndlist)       ListView_GetNextItem(_hwndlist, -1, LVNI_FOCUSED)
#define ListView_SelectItem(_hwndlist, _i)       ListView_SetItemState(_hwndlist, _i, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED)
#define ListView_UnSelectItem(_hwndlist, _i)     ListView_SetItemState(_hwndlist, _i, 0, LVIS_SELECTED)
#define ListView_FocusItem(_hwndlist, _i)        ListView_SetItemState(_hwndlist, _i, LVIS_FOCUSED, LVIS_FOCUSED)
#if (_WIN32_IE >= 0x0400)
#define ListView_UnSelectAll(_hwndlist)          { \
                                                 ListView_SetItemState(_hwndlist, -1, 0, LVIS_SELECTED|LVIS_FOCUSED); \
                                                 ListView_SetSelectionMark(_hwndlist, -1); \
                                                 }
#else
#define ListView_UnSelectAll(_hwndlist)          ListView_SetItemState(_hwndlist, -1, 0, LVIS_SELECTED|LVIS_FOCUSED);
#endif
#define ListView_SelectAll(_hwndlist)            ListView_SetItemState(_hwndlist, -1, LVIS_SELECTED, LVIS_SELECTED)

// --------------------------------------------------------------------------------
// MAX Move Memory Definitions
// --------------------------------------------------------------------------------
#ifdef RtlMoveMemory
#undef RtlMoveMemory
#ifdef __cplusplus
extern "C" {
#endif
__declspec(dllimport) void RtlMoveMemory(void *, const void *, unsigned long);
#ifdef __cplusplus
}
#endif
#endif

#ifndef MSOERT_NO_MEMUTIL
// --------------------------------------------------------------------------------
// Memory Utility Functions
// --------------------------------------------------------------------------------
extern IMalloc *g_pMalloc;

// --------------------------------------------------------------------------------
// SafeMemFree
// --------------------------------------------------------------------------------
#ifndef SafeMemFree
#ifdef __cplusplus
#define SafeMemFree(_pv) \
    if (_pv) { \
        g_pMalloc->Free(_pv); \
        _pv = NULL; \
    } else
#else
#define SafeMemFree(_pv) \
    if (_pv) { \
        g_pMalloc->lpVtbl->Free(g_pMalloc, _pv); \
        _pv = NULL; \
    } else
#endif // __cplusplus
#endif // SafeMemFree

// --------------------------------------------------------------------------------
// MemFree
// --------------------------------------------------------------------------------
#define MemFree(_pv)        g_pMalloc->Free(_pv)
#define ReleaseMem(_pv)     MemFree(_pv)
#define AthFreeString(_psz) g_pMalloc->Free((LPVOID)_psz)

// --------------------------------------------------------------------------------
// Memory Allocation Functions
// --------------------------------------------------------------------------------
LPVOID     ZeroAllocate(DWORD cbSize);
BOOL       MemAlloc(LPVOID* ppv, ULONG cb);
BOOL       MemRealloc(LPVOID *ppv, ULONG cbNew);
HRESULT    HrAlloc(LPVOID *ppv, ULONG cb);
HRESULT    HrRealloc(LPVOID *ppv, ULONG cbNew);

#endif // !MSOERT_NO_MEMUTIL

// --------------------------------------------------------------------------------
// Debug Utility Functions
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_DEBUG

#endif // !MSOERT_NO_DEBUG

// --------------------------------------------------------------------------------
// String Utility Functions
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_STRUTIL

#define CCHMAX_STRINGRES    512

// Used with HrFindInetTimeZone
typedef struct tagINETTIMEZONE {
    LPSTR  lpszZoneCode;
    INT    cHourOffset;
    INT    cMinuteOffset;
} INETTIMEZONE, *LPINETTIMEZONE;

// Used with CchFileTimeToDateTimeSz
#define DTM_LONGDATE            0x00000001
#define DTM_NOSECONDS           0x00000002
#define DTM_NOTIME              0x00000004
#define DTM_NODATE              0x00000008
#define DTM_DOWSHORTDATE        0x00000010
#define DTM_FORCEWESTERN        0x00000020
#define DTM_NOTIMEZONEOFFSET    0x00000040

#define TOUPPERA(_ch) (CHAR)LOWORD(CharUpperA((LPSTR)(DWORD_PTR)MAKELONG(_ch, 0)))
#define TOLOWERA(_ch) (CHAR)LOWORD(CharLowerA((LPSTR)(DWORD_PTR)MAKELONG(_ch, 0)))

OESTDAPI_(LPWSTR)   PszDupW(LPCWSTR pcwszSource);
OESTDAPI_(LPSTR)    PszDupA(LPCSTR pcszSource);
OESTDAPI_(LPSTR)    PszDupLenA(LPCSTR pcszSource, int nLen);
OESTDAPI_(BOOL)     FIsEmptyA(LPCSTR pcszString);
OESTDAPI_(BOOL)     FIsEmptyW(LPCWSTR pcwszString);
OESTDAPI_(LPWSTR)   PszToUnicode(UINT cp, LPCSTR pcszSource);
OESTDAPI_(ULONG)    UlStripWhitespace(LPTSTR lpsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb);
OESTDAPI_(ULONG)    UlStripWhitespaceW(LPWSTR lpwsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb);
OESTDAPI_(LPSTR)    PszSkipWhiteA(LPSTR psz);
OESTDAPI_(LPWSTR)   PszSkipWhiteW(LPWSTR psz);
OESTDAPI_(LPSTR)    PszScanToWhiteA(LPSTR psz);
OESTDAPI_(LPSTR)    PszScanToCharA(LPSTR psz, CHAR ch);
OESTDAPI_(VOID)     StripCRLF(LPSTR lpsz, ULONG *pcb);
OESTDAPI_(LPSTR)    PszAllocA(INT nLen);
OESTDAPI_(LPWSTR)   PszAllocW(INT nLen);
OESTDAPI_(BOOL)     FIsSpaceA(LPSTR psz);
OESTDAPI_(BOOL)     FIsSpaceW(LPWSTR psz);
OESTDAPI_(LPSTR)    PszToANSI(UINT cp, LPCWSTR pcwszSource);
OESTDAPI_(UINT)     StrToUintW(LPCWSTR lpSrc);
OESTDAPI_(UINT)     StrToUintA(LPCSTR lpSrc);
OESTDAPI_(INT)      IsDigit(LPSTR psz);
OESTDAPI_(CHAR)     ChConvertFromHex(CHAR ch);
OESTDAPI_(LPSTR)    PszFromANSIStreamA(LPSTREAM pstm);
OESTDAPI_(HRESULT)  HrIndexOfMonth(LPCSTR pszMonth, ULONG *pulIndex);
OESTDAPI_(HRESULT)  HrIndexOfWeek(LPCSTR pszDay, ULONG *pulIndex);
OESTDAPI_(HRESULT)  HrFindInetTimeZone(LPCSTR pszTimeZone, LPINETTIMEZONE pTimeZone);
OESTDAPI_(LPCSTR)   PszDayFromIndex(ULONG ulIndex);
OESTDAPI_(LPCSTR)   PszMonthFromIndex(ULONG ulIndex);
OESTDAPI_(LPSTR)    PszEscapeMenuStringA(LPCSTR pszSource, LPSTR pszQuoted, int cch);
OESTDAPI_(INT)      IsPrint(LPSTR psz);
OESTDAPI_(INT)      IsUpper(LPSTR psz);
OESTDAPI_(INT)      IsAlphaNum(LPSTR psz);
OESTDAPI_(LPSTR)    strtrim(char *s);
OESTDAPI_(LPWSTR)   strtrimW(WCHAR *s);
OESTDAPI_(INT)      CchFileTimeToDateTimeSz(FILETIME * pft, CHAR * szDateTime, int cch, DWORD dwFlags);
OESTDAPI_(LPCSTR)   StrChrExA(UINT codepage, LPCSTR pszString, CHAR ch);
OESTDAPI_(BOOL)     FIsValidFileNameCharW(WCHAR wch);
OESTDAPI_(BOOL)     FIsValidFileNameCharA(UINT codepage, CHAR ch);
OESTDAPI_(ULONG)    CleanupFileNameInPlaceA(UINT codepage, LPSTR psz);
OESTDAPI_(ULONG)    CleanupFileNameInPlaceW(LPWSTR pwsz);
OESTDAPI_(INT)      ReplaceChars(LPCSTR pszString, CHAR chFind, CHAR chReplace);
OESTDAPI_(INT)      ReplaceCharsW(LPCWSTR pszString, WCHAR chFind, WCHAR chReplace);
OESTDAPI_(LPCSTR)   _MSG(LPSTR pszFormat, ...);
OESTDAPI_(BOOL)     IsValidFileIfFileUrl(LPSTR pszUrl);
OESTDAPI_(BOOL)     IsValidFileIfFileUrlW(LPWSTR pwszUrl);
OESTDAPI_(BOOL)     fGetBrowserUrlEncoding(LPDWORD pdwFlags);

typedef int (*PFGETTIMEFORMATW)(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpTime, 
                                                  LPCWSTR pwzFormat, LPWSTR pwzTimeStr, int cchTime);

typedef int (*PFGETDATEFORMATW)(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpDate, 
                                                  LPCWSTR pwzFormat, LPWSTR pwzDateStr, int cchDate);

typedef int (*PFGETLOCALEINFOW)(LCID Locale, LCTYPE LCType, LPWSTR lpsz, int cchData);

OESTDAPI_(BOOL)     CchFileTimeToDateTimeW(FILETIME *pft, WCHAR * wsDateTime, int cch, 
                                            DWORD dwFlags, PFGETDATEFORMATW pfGetDateFormatW,
                                            PFGETTIMEFORMATW  pfGetTimeFormatW,
                                            PFGETLOCALEINFOW  pfGetLocaleInfo);

// --------------------------------------------------------------------------------
// Unicode/ANSI Function Mapping
// --------------------------------------------------------------------------------
#ifdef UNICODE
#define FIsEmpty            FIsEmptyW
#define PszDup              PszDupW
#define PszAlloc            PszAllocW
#define FIsSpace            FIsSpaceW
#define StrToUint           StrToUintW
#else
#define FIsEmpty            FIsEmptyA
#define PszDup              PszDupA
#define PszAlloc            PszAllocA
#define FIsSpace            FIsSpaceA
#define StrToUint           StrToUintA
#endif

#define IsSpace             FIsSpaceA

#endif // !MSOERT_NO_STRUTIL

// --------------------------------------------------------------------------------
// IStream Utility Functions
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_STMUTIL

OESTDAPI_(HRESULT)  HrIsStreamUnicode(LPSTREAM pstm, BOOL *pfLittleEndian);
OESTDAPI_(HRESULT)  HrCopyStreamToByte(LPSTREAM lpstmIn, LPBYTE pbDest, ULONG *pcb);
OESTDAPI_(HRESULT)  HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb);
OESTDAPI_(HRESULT)  HrGetStreamSize(LPSTREAM pstm, ULONG *pcb);
OESTDAPI_(HRESULT)  HrRewindStream(LPSTREAM pstm);
OESTDAPI_(HRESULT)  HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb);
OESTDAPI_(HRESULT)  HrCopyLockBytesToStream(ILockBytes *pLockBytes, IStream *pStream, ULONG *pcbCopied);
OESTDAPI_(HRESULT)  HrSafeGetStreamSize(LPSTREAM pstm, ULONG *pcb);
OESTDAPI_(HRESULT)  HrGetStreamPos(LPSTREAM pstm, ULONG *piPos);
OESTDAPI_(HRESULT)  HrStreamSeekSet(LPSTREAM pstm, ULONG iPos);
OESTDAPI_(HRESULT)  HrCopyStreamCBEndOnCRLF(LPSTREAM lpstmIn, LPSTREAM  lpstmOut, ULONG cb, ULONG *pcbActual);
OESTDAPI_(HRESULT)  CreateTempFileStream(LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  HrStreamToByte(LPSTREAM lpstm, LPBYTE *lppb, ULONG *pcb);
OESTDAPI_(HRESULT)  HrCopyStreamCB(LPSTREAM lpstmIn, LPSTREAM lpstmOut, ULARGE_INTEGER uliCopy, ULARGE_INTEGER *puliRead, ULARGE_INTEGER *puliWritten);
OESTDAPI_(HRESULT)  HrStreamSeekCur(LPSTREAM pstm, LONG iPos);
OESTDAPI_(HRESULT)  HrStreamSeekEnd(LPSTREAM pstm);
OESTDAPI_(HRESULT)  HrStreamSeekBegin(LPSTREAM pstm);
OESTDAPI_(BOOL)     StreamSubStringMatch(LPSTREAM pstm, TCHAR *sz);

OESTDAPI_(HRESULT)  OpenFileStream(LPSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  OpenFileStreamWithFlags(LPSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, DWORD dwFlagsAndAttributes, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  OpenFileStreamShare(LPSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, DWORD dwShare, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  WriteStreamToFile(LPSTREAM pstm, LPSTR lpszFile, DWORD dwCreationDistribution, DWORD dwAccess);

OESTDAPI_(HRESULT)  OpenFileStreamW(LPWSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  OpenFileStreamWithFlagsW(LPWSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, DWORD dwFlagsAndAttributes, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  OpenFileStreamShareW(LPWSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, DWORD dwShare, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  WriteStreamToFileW(LPSTREAM pstm, LPWSTR lpszFile, DWORD dwCreationDistribution, DWORD dwAccess);

#endif // !MSOERT_NO_STRUTIL

// --------------------------------------------------------------------------------
// Protected Storage
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_PROTSTOR

#include "pstore.h"

#ifdef ENABLE_RULES
#define PST_IDENT_TYPE_STRING       L"Identification with rules"
#elif defined(N_TEST)
#define PST_IDENT_TYPE_STRING       L"Identification test"
#else
#define PST_IDENT_TYPE_STRING       L"Identification"
#endif

#define PST_IMNACCT_SUBTYPE_STRING  L"INETCOMM Server Passwords"
#define PST_CERTS_SUBTYPE_STRING    L"Certificate Trust"



// --------------------------------------------------------------------------------
// Protected Storage Functions
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT)  PSTSetNewData(
        IN IPStore *const      pISecProv,
        IN const GUID *const   guidType,
        IN const GUID *const   guidSubt,
        IN LPCWSTR             wszAccountName,
        IN const BLOB *const   pclear,
        OUT BLOB *const        phandle);

OESTDAPI_(HRESULT)  PSTGetData(
        IN IPStore *const      pISecProv,
        IN const GUID *const   guidType,
        IN const GUID *const   guidSubt,
        IN LPCWSTR             wszLookupName,
        OUT BLOB *const        pclear);

OESTDAPI_(HRESULT)  PSTCreateTypeSubType_NoUI(
        IN IPStore *const     pISecProv,
        IN const GUID *const  guidType,
        IN LPCWSTR            szType,
        IN const GUID *const  guidSubt,
        IN LPCWSTR            szSubt);

OESTDAPI_(LPWSTR)   WszGenerateNameFromBlob(IN BLOB blob);
OESTDAPI_(void)     PSTFreeHandle(IN LPBYTE pb);

#endif // !MSOERT_NO_PROTSTOR

// --------------------------------------------------------------------------------
// CAPI Utility - A few helper functions for the crypt32 utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_CAPIUTIL

#ifndef __WINCRYPT_H__
#define _CRYPT32_
#include <wincrypt.h>
#endif
typedef enum tagCERTSTATE CERTSTATE; // From mimeole.h

OESTDAPI_(LPSTR)    SzGetCertificateEmailAddress(const PCCERT_CONTEXT pCert);
 
OESTDAPI_(HRESULT)  HrDecodeObject(const BYTE *pbEncoded, DWORD cbEncoded, LPCSTR item, DWORD dwFlags,
  DWORD *pcbOut, LPVOID *ppvOut);
OESTDAPI_(LPVOID)   PVDecodeObject(const BYTE *pbEncoded, DWORD cbEncoded, LPCSTR  item, DWORD  *pcbOut);
OESTDAPI_(LPVOID)   PVGetCertificateParam(PCCERT_CONTEXT pCert, DWORD dwParam, DWORD *cbOut);
OESTDAPI_(HRESULT)  HrGetCertificateParam(PCCERT_CONTEXT pCert, DWORD dwParam, LPVOID * pvOut, DWORD *cbOut);
OESTDAPI_(BOOL)     FMissingCert(const CERTSTATE cs);
OESTDAPI_(LPVOID)   PVGetMsgParam(HCRYPTMSG hCryptMsg, DWORD dwParam, DWORD dwIndex, DWORD *pcbData);
OESTDAPI_(HRESULT)  HrGetMsgParam(HCRYPTMSG hCryptMsg, DWORD dwParam, DWORD dwIndex, LPVOID * ppv, DWORD * pcbData);

LPVOID WINAPI                  CryptAllocFunc(size_t cbSize);
VOID WINAPI                    CryptFreeFunc(LPVOID pv);

HRESULT HrGetCertKeyUsage(PCCERT_CONTEXT pccert, DWORD * pdwUsage);
HRESULT HrVerifyCertEnhKeyUsage(PCCERT_CONTEXT pccert, LPCSTR pszOidUsage);

#endif // !MSOERT_NO_CAPIUTIL

// --------------------------------------------------------------------------------
// CAPI Utility - A few helper functions for the crypt32 utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_RASUTIL

OESTDAPI_(HRESULT)  HrCreatePhonebookEntry(HWND hwnd, DWORD *pdwRASResult);
OESTDAPI_(HRESULT)  HrEditPhonebookEntry(HWND hwnd, LPTSTR pszEntryName, DWORD *pdwRASResult);
OESTDAPI_(HRESULT)  HrFillRasCombo(HWND hwndComboBox, BOOL fUpdateOnly, DWORD *pdwRASResult);

#endif // !MSOERT_NO_RASUTIL

// --------------------------------------------------------------------------------
// Win32 Registry Utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_REGUTIL

OESTDAPI_(VOID)     CopyRegistry(HKEY hSourceKey, HKEY hDestinationKey);

#endif // !MSOERT_NO_REGUTIL

// --------------------------------------------------------------------------------
// t-wstrings
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_WSTRINGS

OESTDAPI_(BOOL) UnlocStrEqNW(LPCWSTR pwsz1, LPCWSTR pwsz2, DWORD cch);

#endif // !MSOERT_NO_WSTRINGS

// --------------------------------------------------------------------------------
// CStringParser
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_STRPARSE
#ifdef __cplusplus
#include "strparse.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_STRPARSE

// --------------------------------------------------------------------------------
// DataObject Utility
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_ENUMFMT
#ifdef __cplusplus
typedef struct tagDATAOBJINFO 
    {
    FORMATETC   fe;
    LPVOID      pData;
    DWORD       cbData;
    } DATAOBJINFO, *PDATAOBJINFO;

OESTDAPI_(HRESULT) CreateEnumFormatEtc(LPUNKNOWN pUnkRef, ULONG celt, PDATAOBJINFO rgInfo, LPFORMATETC rgfe,
                             IEnumFORMATETC **  lppstmHFile);
#endif // !__cplusplus
#endif // !MSOERT_NO_ENUMFMT

// --------------------------------------------------------------------------------
// CPrivateUnknown Utility
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_PRIVUNK
#ifdef __cplusplus
#include "privunk.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_PRIVUNK


// --------------------------------------------------------------------------------
// CByteStream Object
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_BYTESTM
#ifdef __cplusplus
#include "bytestm.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_BYTESTM

// --------------------------------------------------------------------------------
// CLogFile Object
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_CLOGFILE
#ifdef __cplusplus
#include "..\\msoert\\clogfile.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_CLOGFILE

// --------------------------------------------------------------------------------
// CDataObject Object
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_DATAOBJ
#ifdef __cplusplus
#include "..\\msoert\\dataobj.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_DATAOBJ

// --------------------------------------------------------------------------------
// CUnknownList and CVoidPtrList Objects
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_LISTOBJS
#ifdef __cplusplus
#include "..\\msoert\\listintr.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_LISTOBJS

// --------------------------------------------------------------------------------
// MSHTML utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_MSHTMLUTILS
#ifdef __cplusplus
#include "..\\msoert\\mshtutil.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_MSHTMLUTILS

// --------------------------------------------------------------------------------
// BSTR utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_BSTUTILS
#ifdef __cplusplus
#include "..\\msoert\\bstr.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_BSTRUTILS

// --------------------------------------------------------------------------------
// HFILESTM utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_HFILESTM
#ifdef __cplusplus
OESTDAPI_(HRESULT) CreateStreamOnHFile (LPTSTR                  lpszFile, 
                                        DWORD                   dwDesiredAccess,
                                        DWORD                   dwShareMode,
                                        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
                                        DWORD                   dwCreationDistribution,
                                        DWORD                   dwFlagsAndAttributes,
                                        HANDLE                  hTemplateFile,
                                        LPSTREAM                *lppstmHFile);

OESTDAPI_(HRESULT) CreateStreamOnHFileW(LPWSTR                  lpwszFile, 
                                        DWORD                   dwDesiredAccess,
                                        DWORD                   dwShareMode,
                                        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
                                        DWORD                   dwCreationDistribution,
                                        DWORD                   dwFlagsAndAttributes,
                                        HANDLE                  hTemplateFile,
                                        LPSTREAM                *lppstmHFile);
#endif // !__cplusplus
#endif // !MSOERT_NO_HFILESTM


// --------------------------------------------------------------------------------
// Outlook Express Runtime Utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_OERTUTIL

typedef struct tagTEMPFILEINFO *LPTEMPFILEINFO;
typedef struct tagTEMPFILEINFO {
    LPTEMPFILEINFO      pNext;
    LPSTR               pszFilePath;
    HANDLE              hProcess;
} TEMPFILEINFO;

#ifndef HIMAGELIST
struct _IMAGELIST;
typedef struct _IMAGELIST NEAR* HIMAGELIST;
#endif

OESTDAPI_(HIMAGELIST)   LoadMappedToolbarBitmap(HINSTANCE hInst, int idBitmap, int cx);
OESTDAPI_(VOID)         UpdateRebarBandColors(HWND hwnd);
OESTDAPI_(HRESULT)      IsPlatformWinNT(void);
OESTDAPI_(HRESULT)      GenerateUniqueFileName(LPCSTR pszDirectory, LPCSTR pszFileName, LPCSTR pszExtension, LPSTR pszFilePath, ULONG cchMaxPath);
OESTDAPI_(HRESULT)      CreateTempFile(LPCSTR pszSuggest, LPCSTR pszExtension, LPSTR *ppszFilePath, HANDLE *phFile);
OESTDAPI_(HRESULT)      WriteStreamToFileHandle(IStream *pStream, HANDLE hFile, ULONG *pcbTotal);
OESTDAPI_(HRESULT)      AppendTempFileList(LPTEMPFILEINFO *ppHead, LPSTR pszFilePath, HANDLE hProcess);
OESTDAPI_(VOID)         DeleteTempFileOnShutdown(LPTEMPFILEINFO pTempFile);
OESTDAPI_(VOID)         DeleteTempFileOnShutdownEx(LPSTR pszFilePath, HANDLE hProcess);
OESTDAPI_(VOID)         CleanupGlobalTempFiles(void);
OESTDAPI_(HRESULT)      DeleteTempFile(LPTEMPFILEINFO pTempFile);
OESTDAPI_(VOID)         FreeTempFileList(LPTEMPFILEINFO pTempFileHead);

#define SafeFreeTempFileList(_p)    \
    {                               \
    if (_p)                         \
        {                           \
        FreeTempFileList(_p);       \
        _p=NULL;                    \
        }                           \
    }

OESTDAPI_(BOOL) FBuildTempPath(LPTSTR lpszOrigFile, LPTSTR lpszPath, ULONG cbMaxPath, BOOL fLink);
OESTDAPI_(BOOL) FBuildTempPathW(LPWSTR lpszOrigFile, LPWSTR lpszPath, ULONG cchMaxPath, BOOL fLink);

OESTDAPI_(HRESULT) ShellUtil_GetSpecialFolderPath(DWORD dwSpecialFolder, LPSTR rgchPath);

OESTDAPI_(BOOL) FIsHTMLFile(LPSTR pszFile);
OESTDAPI_(BOOL) FIsHTMLFileW(LPWSTR pwszFile);

typedef int (*PFLOADSTRINGW)(HINSTANCE,UINT,LPWSTR,int);
typedef int (*PFMESSAGEBOXW)(HWND,LPCWSTR,LPCWSTR,UINT);


OESTDAPI_(int)  MessageBoxInst(HINSTANCE hInst, HWND hwndOwner, LPTSTR pszTitle, LPTSTR psz1, LPTSTR psz2, UINT fuStyle);
OESTDAPI_(int)  MessageBoxInstW(HINSTANCE hInst, HWND hwndOwner, LPWSTR pwszTitle, LPWSTR pwsz1, LPWSTR pwsz2, UINT fuStyle, 
                                PFLOADSTRINGW pfLoadStringW, PFMESSAGEBOXW pfMessageBoxW);

// window utils
OESTDAPI_(void) IDrawText(HDC hdc, LPCTSTR pszText, RECT FAR* prc, BOOL fEllipses, int cyChar);
OESTDAPI_(HRESULT) RicheditStreamIn(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags);
OESTDAPI_(HRESULT) RicheditStreamOut(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags);
OESTDAPI_(VOID) CenterDialog(HWND hwndDlg);
OESTDAPI_(VOID) SetIntlFont(HWND hwnd);
OESTDAPI_(BOOL) GetExePath(LPCTSTR szExe, TCHAR *szPath, DWORD cch, BOOL fDirOnly);
OESTDAPI_(BOOL) BrowseForFolder(HINSTANCE hInst, HWND hwnd, TCHAR *pszDir, int cch, int idsText, BOOL fFileSysOnly);
OESTDAPI_(BOOL) BrowseForFolderW(HINSTANCE hInst, HWND hwnd, WCHAR *pwszDir, int cch, int idsText, BOOL fFileSysOnly);

OESTDAPI_(HRESULT) DoHotMailWizard(HWND hwndOwner, LPSTR pszUrl, LPSTR pszFriendly, RECT *prc, IUnknown *pUnkHost);

OESTDAPI_(LONG_PTR) SetWindowLongPtrAthW(HWND hWnd, int  nIndex, LONG_PTR dwNewLong);

HRESULT GetHtmlCharset(IStream *pStmHtml, LPSTR *ppszCharset);

#endif // MSOERT_NO_OERTUTIL


typedef HANDLE  HTHREAD;
typedef HANDLE  HEVENT;
typedef HANDLE  HPROCESS;

typedef HANDLE  HANDLE_16;
typedef WPARAM  WPARAM_16;

#define EXTERN_C_16
#define WINAPI_16
#define CALLBACK_16
#define EXPORT_16
#define LOADDS_16
#define HUGEP_16

#define WaitForSingleObject_16 WaitForSingleObject
#define GlobalAlloc_16 GlobalAlloc
#define GlobalFree_16 GlobalFree

#define CreateFileMapping_16 CreateFileMapping
#define MapViewOfFile_16 MapViewOfFile
#define UnmapViewOfFile_16 UnmapViewOfFile
#define CloseHandle_FM16 CloseHandle

#define CloseHandle_F16 CloseHandle

#define INVALID_HANDLE_VALUE_16 INVALID_HANDLE_VALUE

#define SetDlgThisPtr(hwnd, THIS) SetWndThisPtr(hwnd, THIS)
#define GetDlgThisPtr(hwnd) GetWndThisPtr(hwnd)

// Some one liners can be wrapped in IF_WIN16 or IF_WIN32 so that the
// code is more readable.
#define IF_WIN16(x)
#define IF_NOT_WIN16(x) x
#define IF_WIN32(x) x

#endif // __MSOERT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\newimp.h ===
#ifndef _INC_NEWIMP_H
#define _INC_NEWIMP_H


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// WARNING:  If you make changes to this header, you must also update  //
//           inetcore\published\inc\newimp.h !!!                       //
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


#ifndef NO_IMPORT_ERROR

#define HR_IMP_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, n)
#define HR_IMP_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, n)
#define HR_IMP      0x3000

#define hrFolderOpenFail    HR_IMP_E(HR_IMP + 1)
#define hrFolderReadFail    HR_IMP_E(HR_IMP + 2)
#define hrMapiInitFail      HR_IMP_E(HR_IMP + 3)
#define hrNoProfilesFound   HR_IMP_E(HR_IMP + 4)
#define hrDiskFull          HR_IMP_E(HR_IMP + 5)
#define hrUserCancel        HR_IMP_E(HR_IMP + 6)

#endif // NO_IMPORT_ERROR

typedef enum tagIMPORTFOLDERTYPE
    {
    FOLDER_TYPE_NORMAL = 0,
    FOLDER_TYPE_INBOX,
    FOLDER_TYPE_OUTBOX,
    FOLDER_TYPE_SENT,
    FOLDER_TYPE_DELETED,
    FOLDER_TYPE_DRAFT,
    CFOLDERTYPE
    } IMPORTFOLDERTYPE;

typedef struct IMSG IMSG;

typedef enum
    {
    MSG_TYPE_MAIL = 0,
    MSG_TYPE_NEWS
    } MSGTYPE;

#define MSG_STATE_UNREAD    0x0001
#define MSG_STATE_UNSENT    0x0002
#define MSG_STATE_SUBMITTED 0x0004
#define MSG_PRI_LOW         0x0010
#define MSG_PRI_NORMAL      0x0020
#define MSG_PRI_HIGH        0x0040
#define MSG_PRI_MASK        0x0070

// {E4499DE7-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IFolderImport, 0xE4499DE7L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IFolderImport IFolderImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IFolderImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMessageCount(ULONG cMsg) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(IMSG *pimsg) = 0;
    };
#else   /* C style interface */
typedef struct IFolderImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IFolderImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IFolderImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IFolderImport * This);

    HRESULT ( STDMETHODCALLTYPE *SetMessageCount )(
		IFolderImport * This,
		ULONG cMsg);
    HRESULT ( STDMETHODCALLTYPE *ImportMessageEx )(
		IFolderImport * This,
		MSGTYPE type, 
		DWORD dwState, 
		LPSTREAM pstm, 
		const TCHAR **rgszAttach, 
		DWORD cAttach);
    HRESULT ( STDMETHODCALLTYPE *ImportMessage )(
		IFolderImport * This,
		IMSG *pimsg);
    END_INTERFACE
} IFolderImportVtbl;

interface IFolderImport
{
    CONST_VTBL struct IFolderImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IFolderImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IFolderImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IFolderImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IFolderImport_SetMessageCount(This,cMsg)	\
	(This)->lpVtbl -> SetMessageCount(This,cMsg)
#define IFolderImport_ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)	\
	(This)->lpVtbl -> ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)
#define IFolderImport_ImportMessage(This,pimsg)	\
	(This)->lpVtbl -> ImportMessage(This,pimsg)
#endif /* COBJMACROS */

#endif  /* C style interface */



// {E4499DE8-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImporter, 0xE4499DE8L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IMailImporter IMailImporter;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImporter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenFolder(DWORD_PTR dwCookie, const TCHAR *szFolder, IMPORTFOLDERTYPE type, DWORD dwFlags, IFolderImport **ppFldrImp, DWORD_PTR *pdwCookie) = 0;
    };
#else   /* C style interface */
typedef struct IMailImporterVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImporter * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImporter * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImporter * This);

    HRESULT ( STDMETHODCALLTYPE *OpenFolder )(
		IMailImporter * This,
		DWORD_PTR dwCookie, 
		const TCHAR *szFolder, 
		IMPORTFOLDERTYPE type, 
		DWORD dwFlags, 
		IFolderImport **ppFldrImp, 
		DWORD_PTR *pdwCookie);
    END_INTERFACE
} IMailImporterVtbl;

interface IMailImporter
{
    CONST_VTBL struct IMailImporterVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImporter_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImporter_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImporter_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImporter_OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)	\
   (This)->lpVtbl -> OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)

#endif /* COBJMACROS */

#endif  /* C style interface */

typedef struct tagIMPORTFOLDER
    {
    DWORD_PTR           dwCookie;
    TCHAR               szName[MAX_PATH];
    IMPORTFOLDERTYPE    type;
    // DWORD       cMsg;
    BOOL                fSubFolders;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    } IMPORTFOLDER;

// {E4499DE9-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IEnumFOLDERS, 0xE4499DE9L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IEnumFOLDERS IEnumFOLDERS;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IEnumFOLDERS : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(IMPORTFOLDER *pfldr) = 0;
        virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;
    };
#else   /* C style interface */
typedef struct IEnumFOLDERSVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IEnumFOLDERS * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IEnumFOLDERS * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IEnumFOLDERS * This);

    HRESULT ( STDMETHODCALLTYPE *Next )(
		IEnumFOLDERS * This,
        IMPORTFOLDER *pfldr);
    HRESULT ( STDMETHODCALLTYPE *Reset )(
		IEnumFOLDERS * This);
    END_INTERFACE
} IEnumFOLDERSVtbl;

interface IEnumFOLDERS
{
    CONST_VTBL struct IEnumFOLDERSVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IEnumFOLDERS_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IEnumFOLDERS_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IEnumFOLDERS_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IEnumFOLDERS_Next(This,pfldr)	\
   (This)->lpVtbl -> Next(This,pfldr);
#define IEnumFOLDERS_Reset(This)	\
   (This)->lpVtbl -> Reset(This);
#endif /* COBJMACROS */

#endif  /* C style interface */


#define COOKIE_ROOT     MAXULONG_PTR

// {E4499DEA-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImport, 0xE4499DEAL, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IMailImport IMailImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetDirectory(char *szDir, UINT cch) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetDirectory(char *szDir) = 0;
        virtual HRESULT STDMETHODCALLTYPE EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport) = 0;
    };
#else   /* C style interface */
typedef struct IMailImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImport * This);

    HRESULT ( STDMETHODCALLTYPE *InitializeImport )(
		IMailImport * This,
        HWND hwnd);
    HRESULT ( STDMETHODCALLTYPE *GetDirectory )(
		IMailImport * This,
        char *szDir, 
        UINT cch);
    HRESULT ( STDMETHODCALLTYPE *SetDirectory )(
		IMailImport * This,
        char *szDir);
    HRESULT ( STDMETHODCALLTYPE *EnumerateFolders )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IEnumFOLDERS **ppEnum);
    HRESULT ( STDMETHODCALLTYPE *ImportFolder )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IFolderImport *pImport);

    END_INTERFACE
} IMailImportVtbl;

interface IMailImport
{
    CONST_VTBL struct IMailImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImport_InitializeImport(This,hwnd) \
    (This)->lpVtbl -> InitializeImport(This,hwnd)
#define IMailImport_GetDirectory(This,szDir,cch)    \
    (This)->lpVtbl -> GetDirectory(This,szDir,cch)
#define IMailImport_SetDirectory(This,szDir)    \
    (This)->lpVtbl -> SetDirectory(This,szDir)
#define IMailImport_EnumerateFolders(This,dwCookie,ppEnum)  \
    (This)->lpVtbl -> EnumerateFolders(This,dwCookie,ppEnum)
#define IMailImport_ImportFolder(This,dwCookie,pImport) \
    (This)->lpVtbl -> ImportFolder(This,dwCookie,pImport)

#endif /* COBJMACROS */

#endif  /* C style interface */

#define achPerformImport    "PerformImport"
void PerformImport(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef void (*PFNPERFORMIMPORT)(HWND, IMailImporter *, DWORD);

#define achPerformMigration "PerformMigration"
HRESULT PerformMigration(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef HRESULT (*PFNPERFORMMIGRATION)(HWND, IMailImporter *, DWORD);

#endif // _INC_NEWIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\sterror.h ===
// --------------------------------------------------------------------------------
// STERROR.H
// --------------------------------------------------------------------------------
#ifndef __STERROR_H
#define __STERROR_H

// --------------------------------------------------------------------------------
// REPORTERRORINFO
// --------------------------------------------------------------------------------
typedef struct tagREPORTERRORINFO {
    UINT                nTitleIds;          // Title of the messagebox
    UINT                nPrefixIds;         // Prefix string resource id
    UINT                nErrorIds;          // Error string resource id
    UINT                nReasonIds;         // Reason string resource id
    BOOL                nHelpIds;           // Help String Resource Id
    LPCSTR              pszExtra1;          // Extra parameter 1
    ULONG               ulLastError;        // GetLastError() Value
} REPORTERRORINFO, *LPREPORTERRORINFO;

// --------------------------------------------------------------------------------
// ReportError - Shared between main Dll and EXE Startup Code
// --------------------------------------------------------------------------------
BOOL ReportError(
    HINSTANCE           hInstance,          // Dll Instance
    HRESULT             hrResult,           // HRESULT of the error
    LONG                lResult,            // LRESULT from like a registry function
    LPREPORTERRORINFO   pInfo)              // Report Error Information
{
    // Locals
    CHAR        szRes[255];
    CHAR        szMessage[1024];
    CHAR        szTitle[128];

    // INit
    *szMessage = '\0';

    // Is there a prefix
    if (pInfo->nPrefixIds)
    {
        // Load the string
        LoadString(hInstance, pInfo->nPrefixIds, szMessage, ARRAYSIZE(szMessage));
    }

    // Error ?
    if (pInfo->nErrorIds)
    {
        // Are there extras in this error string
        if (NULL != pInfo->pszExtra1)
        {
            // Locals
            CHAR szTemp[255];

            // Load and format
            LoadString(hInstance, pInfo->nErrorIds, szTemp, ARRAYSIZE(szTemp));

            // Format the string
            wnsprintf(szRes, ARRAYSIZE(szRes), szTemp, pInfo->pszExtra1);
        }

        // Load the string
        else
        {
            // Load the error string
            LoadString(hInstance, pInfo->nErrorIds, szRes, ARRAYSIZE(szRes));
        }

        // Add to szMessage
        StrCatBuff(szMessage, g_szSpace, ARRAYSIZE(szMessage));
        StrCatBuff(szMessage, szRes, ARRAYSIZE(szMessage));
    }

    // Reason ?
    if (pInfo->nReasonIds)
    {
        // Load the string
        LoadString(hInstance, pInfo->nReasonIds, szRes, ARRAYSIZE(szRes));

        // Add to szMessage
        StrCatBuff(szMessage, g_szSpace, ARRAYSIZE(szMessage));
        StrCatBuff(szMessage, szRes, ARRAYSIZE(szMessage));
    }

    // Load the string
    LoadString(hInstance, pInfo->nHelpIds, szRes, ARRAYSIZE(szRes));

    // Add to szMessage
    StrCatBuff(szMessage, g_szSpace, ARRAYSIZE(szMessage));
    StrCatBuff(szMessage, szRes, ARRAYSIZE(szMessage));

    // Append Error Results
    if (lResult != 0 && E_FAIL == hrResult && pInfo->ulLastError)
        wnsprintf(szRes, ARRAYSIZE(szRes), "(%d, %d)", lResult, pInfo->ulLastError);
    else if (lResult != 0 && E_FAIL == hrResult && 0 == pInfo->ulLastError)
        wnsprintf(szRes, ARRAYSIZE(szRes), "(%d)", lResult);
    else if (pInfo->ulLastError)
        wnsprintf(szRes, ARRAYSIZE(szRes), "(0x%08X, %d)", hrResult, pInfo->ulLastError);
    else
        wnsprintf(szRes, ARRAYSIZE(szRes), "(0x%08X)", hrResult);

    // Add to szMessage
    StrCatBuff(szMessage, g_szSpace, ARRAYSIZE(szMessage));
    StrCatBuff(szMessage, szRes, ARRAYSIZE(szMessage));

    // Get the title
    LoadString(hInstance, pInfo->nTitleIds, szTitle, ARRAYSIZE(szTitle));

    // Show the error message
    MessageBox(NULL, szMessage, szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);

    // Done
    return TRUE;
}

#endif // __STERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\strparse.h ===
// --------------------------------------------------------------------------------
// Strparse.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __STRPARSE_H
#define __STRPARSE_H

typedef DWORD CODEPAGEID;

// --------------------------------------------------------------------------------
// Parse Flags, pass to CStringParser::Init
// --------------------------------------------------------------------------------
#define PSF_NOTRAILWS        0x00000001    // String trailing whitespace from pszValue  
#define PSF_NOFRONTWS        0x00000002    // Skip white space before searching for tokens
#define PSF_ESCAPED          0x00000004    // Detect escaped characters such as '\\'  or '\"'
#define PSF_DBCS             0x00000008    // The String could contain DBCS characters
#define PSF_NOCOMMENTS       0x00000010    // Skips comments (comment)
#define PSF_NORESET          0x00000020    // Don't reset the destination buffer on ChParse

// --------------------------------------------------------------------------------
// LITERALINFO
// --------------------------------------------------------------------------------
typedef struct tagLITERALINFO {
    BYTE            fInside;               // Are we in a literal
    CHAR            chStart;               // Starting literal delimiter
    CHAR            chEnd;                 // Ending literal delimiter if chEnd == chStart, no nesting
    DWORD           cNested;               // Number of nested delimiters
} LITERALINFO, *LPLITERALINFO;

// --------------------------------------------------------------------------------
// CStringParser
// --------------------------------------------------------------------------------
class CStringParser
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CStringParser(void);
    ~CStringParser(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // CStringParser Methods
    // ----------------------------------------------------------------------------
    void    Init(LPCSTR pszParseMe, ULONG cchParseMe, DWORD dwFlags);
    void    SetTokens(LPCSTR pszTokens);
    CHAR    ChSkip(void);
    CHAR    ChParse(void);
    CHAR    ChSkipWhite(void);
    CHAR    ChPeekNext(ULONG cchFromCurrent);
    HRESULT HrAppendValue(CHAR ch);

    // ----------------------------------------------------------------------------
    // Inline CStringParser Methods
    // ----------------------------------------------------------------------------
    UINT    GetCP(void) { return m_codepage; }
    void    SetCodePage(CODEPAGEID codepage) { m_codepage = codepage; }
    void    SetIndex(ULONG iIndex) { m_iSource = iIndex; }
    CHAR    ChSkip(LPCSTR pszTokens) { SetTokens(pszTokens); return ChSkip(); }
    CHAR    ChParse(LPCSTR pszTokens, DWORD dwFlags);
    CHAR    ChParse(LPCSTR pszTokens) { SetTokens(pszTokens); return ChParse(); }
    CHAR    ChParse(CHAR chStart, CHAR chEnd, DWORD dwFlags);
    ULONG   GetLength(void) { return m_cchSource; }
    ULONG   GetIndex(void) { return m_iSource; }
    LPCSTR  PszValue(void) { Assert(m_pszDest && '\0' == m_pszDest[m_cchDest]); return m_pszDest; }
    ULONG   CchValue(void) { Assert(m_pszDest && '\0' == m_pszDest[m_cchDest]); return m_cchDest; }
    void    FlagSet(DWORD dwFlags) { FLAGSET(m_dwFlags, dwFlags); }
    void    FlagClear(DWORD dwFlags) { FLAGCLEAR(m_dwFlags, dwFlags); }
    BOOL    FIsParseSpace(CHAR ch, BOOL *pfCommentChar);

private:
    // ----------------------------------------------------------------------------
    // Private Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrGrowDestination(ULONG cbWrite);
    HRESULT _HrDoubleByteIncrement(BOOL fEscape);
    
private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG           m_cRef;             // Reference Count
    CODEPAGEID      m_codepage;         // Code page to use to parse the string
    LPCSTR          m_pszSource;        // String to parse
    ULONG           m_cchSource;        // Length of pszString
    ULONG           m_iSource;          // Index into m_pszString
    LPSTR           m_pszDest;          // Destination buffer
    ULONG           m_cchDest;          // Write Index/size of dest buffer
    ULONG           m_cbDestMax;        // Maximum size of m_pszDest
    DWORD           m_dwFlags;          // Parse String Flags
    CHAR            m_szScratch[256];   // Scratch Buffer
    BYTE            m_rgbTokTable[256]; // Token Table
    LPCSTR          m_pszTokens;        // Current Parse Tokens
    ULONG           m_cCommentNest;     // Nested comment parens
    LITERALINFO     m_rLiteral;         // Literal Information
};

#endif // __STRPARSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\qstrcmpi.h ===
#ifndef __QSTRCMPI_INC
#define __QSTRCMPI_INC

unsigned char __declspec(selectany) g_achOEMtoupper[256] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x40, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
     'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',0x5b,0x5c,0x5d,0x5e,0x5f,
    0x60, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
     'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',0x7b,0x7c,0x7d,0x7e,0x7f,
    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
    0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
    0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
    0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
};

#define OEMtoupper(ch)	g_achOEMtoupper[(unsigned char) (ch)]

inline int OEMstrcmpi(LPCSTR psz1, LPCSTR psz2) {

    for (;*psz1||*psz2;psz1++,psz2++) {
        if (OEMtoupper(*psz1) < OEMtoupper(*psz2)) {
            return (-1);
        }
        if (OEMtoupper(*psz1) > OEMtoupper(*psz2)) {
            return (1);
        }
    }
    return (0);
}

typedef enum tagOEMcharinfo {
    OCI_isspace = 1
} OEMcharinfo;

DWORD __declspec(selectany) g_adwOEMcharinfo[256] = {
    0,0,0,0,0,0,0,0,/*HT*/OCI_isspace,/*LF*/OCI_isspace,/*VT*/OCI_isspace,/*FF*/OCI_isspace,/*CR*/OCI_isspace,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    /*space*/OCI_isspace,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

inline int OEMisspace(char ch) {

    return (g_adwOEMcharinfo[(unsigned char) ch] & OCI_isspace);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\shared.h ===
/*
*    shared.h
*    
*    History:
*      Feb '98: Created.
*    
*    Copyright (C) Microsoft Corp. 1998
*
*   Describes functions in staticRT/shared.cpp
*/

#ifndef _SHARED_H
#define _SHARED_H

#ifdef  __cplusplus
#define _EXTERN_ extern "C"
#else
#define _EXTERN_ extern
#endif 

#define STR_PATH_MAIN_EXE "msimn.exe"

#ifdef DEFINE_SHARED_STRINGS
#define SHARED_GLOBAL(x,y)         _EXTERN_ CDECL const TCHAR x[] = TEXT(y)
#else
#define SHARED_GLOBAL(x,y)         _EXTERN_ CDECL const TCHAR x[]
#endif

// Files
SHARED_GLOBAL(c_szAdvPackDll,       "ADVPACK.DLL");
SHARED_GLOBAL(c_szOEResDll,         "msoeres.dll");
SHARED_GLOBAL(c_szInetResDll,       "inetres.dll");
SHARED_GLOBAL(c_szAcctResDll,       "acctres.dll");
SHARED_GLOBAL(c_szOutlAcctManDll,   "outlacct.dll");
SHARED_GLOBAL(c_szOEExe,            STR_PATH_MAIN_EXE);

// Reg Keys
SHARED_GLOBAL(c_szRegWinCurrVer,    "Software\\Microsoft\\Windows\\CurrentVersion");
SHARED_GLOBAL(c_szRegInetCommDll,   "Software\\Microsoft\\Outlook Express\\Inetcomm");
SHARED_GLOBAL(c_szRegOEAppPath,     "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\" STR_PATH_MAIN_EXE);
SHARED_GLOBAL(c_szRegMsoeAcctDll,   "Software\\Microsoft\\Internet Account Manager");

// Reg Value Names
SHARED_GLOBAL(c_szDllPath,          "DllPath");
SHARED_GLOBAL(c_szProgFilesDir,     "ProgramFilesDir");

// Misc
SHARED_GLOBAL(c_szReg,              "Reg");
SHARED_GLOBAL(c_szUnReg,            "UnReg");
SHARED_GLOBAL(c_szPath,             "Path");


// Some codepage mapping data structures and functions
struct _tagOENonStdCP
{
    UINT Codepage;              
    UINT cpRead;                // Read note CP
    UINT cpReadMenu;            // Read Note menu
    UINT cpReadTitle;           // Note Title CP
    UINT cpSendMenu;            // Compose note menu CP
    UINT cpSend;                // Send CP
    UINT UseSIO;                // Use SIO

//    UINT cpSend;             // Default compose note CP
};

typedef struct _tagOENonStdCP OENONSTDCP;

extern const OENONSTDCP OENonStdCPs[];

#ifdef __cplusplus
extern "C" {
#endif

HRESULT   CallRegInstall(HINSTANCE hInstCaller, HINSTANCE hInstRes, LPCSTR szSection, LPSTR pszExtra);
BOOL      AddEnvInPath  (LPCSTR pszOldPath, LPSTR pszNew, DWORD cchSize);
HRESULT MakeFilePath(LPCSTR pszDirectory, LPCSTR pszFileName, LPCSTR pszExtension, LPSTR pszFilePath, ULONG cchMaxFilePath);

//PlugUI functions
#ifndef NT5B2
HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName, BOOL fNT);
#else
HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName);
#endif
BOOL OEWinHelp(HWND hWndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
HWND OEHtmlHelp(HWND hWndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData);
BOOL GetPCAndOSTypes(SYSTEM_INFO * pSysInf, OSVERSIONINFO * pOsInf);

// --------------------------------------------------------------------------------
// MEMORYFILE
// --------------------------------------------------------------------------------
typedef struct tagMEMORYFILE {
    HANDLE          hFile;
    HANDLE          hMemoryMap;
    DWORD           cbSize;
    LPVOID          pView;
} MEMORYFILE, *LPMEMORYFILE;

HRESULT CloseMemoryFile(LPMEMORYFILE pFile);
HRESULT OpenMemoryFile(LPCSTR pszFile, LPMEMORYFILE pFile);

#define     S_RESTART_OE            _HRESULT_TYPEDEF_(0x00000714L)
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\wstrpar.h ===
// --------------------------------------------------------------------------------
// wstrpar.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#pragma once

// --------------------------------------------------------------------------------
// Parse Flags, pass to CStringParser::Init
// --------------------------------------------------------------------------------
#define PSF_NOTRAILWS        0x00000001    // String trailing whitespace from pszValue  
#define PSF_NOFRONTWS        0x00000002    // Skip white space before searching for tokens
#define PSF_ESCAPED          0x00000004    // Detect escaped characters such as '\\'  or '\"'
#define PSF_NOCOMMENTS       0x00000010    // Skips comments (comment)
#define PSF_NORESET          0x00000020    // Don't reset the destination buffer on ChParse

// --------------------------------------------------------------------------------
// LITERALINFOW
// --------------------------------------------------------------------------------
typedef struct tagLITERALINFOW {
    BYTE            fInside;               // Are we in a literal
    WCHAR           chStart;               // Starting literal delimiter
    WCHAR           chEnd;                 // Ending literal delimiter if chEnd == chStart, no nesting
    DWORD           cNested;               // Number of nested delimiters
} LITERALINFOW, *LPLITERALINFOW;

// --------------------------------------------------------------------------------
// CStringParserW
// --------------------------------------------------------------------------------
class CStringParserW
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CStringParserW(void);
    ~CStringParserW(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // CStringParser Methods
    // ----------------------------------------------------------------------------
    void    Init(LPCWSTR pszParseMe, ULONG cchParseMe, DWORD dwFlags);
    void    SetTokens(LPCWSTR pszTokens);
    WCHAR   ChSkip(void);
    WCHAR   ChParse(void);
    WCHAR   ChSkipWhite(void);
    WCHAR   ChPeekNext(ULONG cchFromCurrent);
    HRESULT HrAppendValue(WCHAR ch);

    // ----------------------------------------------------------------------------
    // Inline CStringParser Methods
    // ----------------------------------------------------------------------------
    void    SetIndex(ULONG iIndex) { m_iSource = iIndex; }
    WCHAR   ChSkip(LPCWSTR pszTokens) { SetTokens(pszTokens); return ChSkip(); }
    WCHAR   ChParse(LPCWSTR pszTokens, DWORD dwFlags);
    WCHAR   ChParse(LPCWSTR pszTokens) { SetTokens(pszTokens); return ChParse(); }
    WCHAR   ChParse(WCHAR chStart, WCHAR chEnd, DWORD dwFlags);
    ULONG   GetLength(void) { return m_cchSource; }
    ULONG   GetIndex(void) { return m_iSource; }
    LPCWSTR PszValue(void) { Assert(m_pszDest && L'\0' == m_pszDest[m_cchDest]); return m_pszDest; }
    ULONG   CchValue(void) { Assert(m_pszDest && L'\0' == m_pszDest[m_cchDest]); return m_cchDest; }
    ULONG   CbValue(void)  { Assert(m_pszDest && L'\0' == m_pszDest[m_cchDest]); return (m_cchDest * sizeof(WCHAR)); }
    void    FlagSet(DWORD dwFlags) { FLAGSET(m_dwFlags, dwFlags); }
    void    FlagClear(DWORD dwFlags) { FLAGCLEAR(m_dwFlags, dwFlags); }
    BOOL    FIsParseSpace(WCHAR ch, BOOL *pfCommentChar);

private:
    // ----------------------------------------------------------------------------
    // Private Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrGrowDestination(ULONG cch);
    
private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG           m_cRef;             // Reference Count
    LPCWSTR         m_pszSource;        // String to parse
    ULONG           m_cchSource;        // Length of pszString
    ULONG           m_iSource;          // Index into m_pszString
    LPWSTR          m_pszDest;          // Destination buffer
    ULONG           m_cchDest;          // Write Index/size of dest buffer
    ULONG           m_cchDestMax;        // Maximum size of m_pszDest
    DWORD           m_dwFlags;          // Parse String Flags
    WCHAR           m_szScratch[256];   // Scratch Buffer
    ULONG           m_cCommentNest;     // Nested comment parens
    LPCWSTR         m_pszTokens;        // The tokens
    LITERALINFOW    m_rLiteral;         // Literal Information
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\iconsole.h ===
#ifndef __MAIN_H
#define __MAIN_H

interface IRASTransport;
interface INNTPTransport;

extern IRASTransport  *g_pRAS;
extern INNTPTransport *g_pNNTP;

extern UINT g_msgSMTP;
extern UINT g_msgPOP3;
extern UINT g_msgRAS;
extern UINT g_msgNNTP;
extern UINT g_msgHTTPMail;

#define RAS_CONNECT WM_USER + 1000

#endif __MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\main.h ===
#ifndef __MAIN_H
#define __MAIN_H

extern UINT g_msgSMTP;

#endif __MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inc\x16menu.h ===
/***********************************************************************
*
*   X16MENU.H
*
*       Copyright Microsoft Corporation 1997.  All Rights Reserved.
*
*   This module contains a set of functions to provide Win32 specific
*   windows menu handling ability.
*
*
*   This file provides following features:
*
*   - 32bit specific APIs
*   - Menu ID associated with Popup menu (32bit API only)
*   - Application-defined 32bit value associated with a menu item
*   - (TBD)Read values like hBitmap, hbmpChecked, hbmpUnchecked, MFS_HILIGHT
*
*   In order to provide these features, following things happen inside:
*
*   - Provide 32bit specific APIs
*   - Replace 16bit menu APIs to keep track of changes to menus
*   - (TBD)Hook WH_CBT to clean up when a window (and its menu) is destroyed
*
*   To use these functionalities, you need to do followings:
*
*   - If you want to associate ID to a popup menu in RC file, add one menu
*     item at the beginning of the popup menu.  Define the menu item to
*     have menu string of STR_POPUPMENUID and ID value for the popup menu.
*   - Call "InitX16Menu" in the beginning of your application (usually
*     before creating any Windows, and before entering message loop.)
*
***********************************************************************/

#ifndef __INC_X16MENU_H__
#define __INC_X16MENU_H__


#ifdef __cplusplus
extern "C"{
#endif

#define MIIM_STATE       0x00000001
#define MIIM_ID          0x00000002
#define MIIM_SUBMENU     0x00000004
#define MIIM_CHECKMARKS  0x00000008
#define MIIM_TYPE        0x00000010
#define MIIM_DATA        0x00000020

#define MF_DEFAULT          0x00001000L
#define MF_RIGHTJUSTIFY     0x00004000L

#define MFT_STRING          MF_STRING
#define MFT_BITMAP          MF_BITMAP
#define MFT_MENUBARBREAK    MF_MENUBARBREAK
#define MFT_MENUBREAK       MF_MENUBREAK
#define MFT_OWNERDRAW       MF_OWNERDRAW
#define MFT_RADIOCHECK      0x00000200L
#define MFT_SEPARATOR       MF_SEPARATOR
#define MFT_RIGHTORDER      0x00002000L
#define MFT_RIGHTJUSTIFY    MF_RIGHTJUSTIFY

/* Menu flags for Add/Check/EnableMenuItem() */
#define MFS_GRAYED          0x00000003L
#define MFS_DISABLED        MFS_GRAYED
#define MFS_CHECKED         MF_CHECKED
#define MFS_HILITE          MF_HILITE
#define MFS_ENABLED         MF_ENABLED
#define MFS_UNCHECKED       MF_UNCHECKED
#define MFS_UNHILITE        MF_UNHILITE
#define MFS_DEFAULT         MF_DEFAULT

#if 0    // win16x now has this definition
typedef struct tagMENUITEMINFO
{
    UINT    cbSize;
    UINT    fMask;
    UINT    fType;          // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT    fState;         // used if MIIM_STATE
    UINT    wID;            // used if MIIM_ID
    HMENU   hSubMenu;       // used if MIIM_SUBMENU
    HBITMAP hbmpChecked;    // used if MIIM_CHECKMARKS
    HBITMAP hbmpUnchecked;  // used if MIIM_CHECKMARKS
    DWORD   dwItemData;     // used if MIIM_DATA
    LPSTR   dwTypeData;     // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT    cch;            // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
}   MENUITEMINFO, FAR *LPMENUITEMINFO, CONST FAR *LPCMENUITEMINFO;

//typedef MENUITEMINFO MENUITEMINFOA;
//typedef MENUITEMINFO CONST FAR *LPCMENUITEMINFOA;
#endif


#define STR_POPUPMENUID  "Popup Menu ID"

#define DEFINE_POPUP(name,id)  POPUP name \
                               BEGIN \
                                   MENUITEM STR_POPUPMENUID id

// EXTERNAL HELPER APIs

void
WINAPI
X16MenuInitialize(
   HMENU hMenu
);

void
WINAPI
X16MenuDeInitialize(
   HMENU hMenu
);


// 16bit Old MENU APIs

BOOL
WINAPI __export
X16EnableMenuItem(
   HMENU hMenu,
   UINT idEnableItem,
   UINT uEnable
);

#ifndef DONT_USE_16BIT_MENU_WRAPPER
#define EnableMenuItem  X16EnableMenuItem
#endif


// 32bit New MENU APIs

BOOL
WINAPI
GetMenuItemInfo(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPMENUITEMINFO lpmii
);
//#define GetMenuItemInfoA  GetMenuItemInfo

BOOL
WINAPI
SetMenuItemInfo(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPCMENUITEMINFO lpmii
);
//#define SetMenuItemInfoA  SetMenuItemInfo

BOOL
WINAPI
InsertMenuItem(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPCMENUITEMINFO lpmii );
//#define InsertMenuItemA  InsertMenuItem

BOOL
WINAPI
GetMenuItemRect(
    HWND hWnd,
    HMENU hMenu,
    UINT uItem,
    LPRECT lprcItem
);

BOOL
WINAPI
CheckMenuRadioItem(
    HMENU hMenu,
    UINT idFirst,
    UINT idLast,
    UINT idCheck,
    UINT uFlags
);

#ifdef __cplusplus
}
#endif


#endif //__INC_X16MENU_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDBCS_DIVIDE -D_MIMEOLE_ -D_IMNXPORT_ -D_WIN32_OE=0x0501 -D_INETCOMM_DLL_

!ifdef WIN16
C_DEFINES=$(C_DEFINES) -DWIN16_INETCOMM
!endif

WIN32_IE_VERSION=0x0500

!ifndef WIN16
INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(ATHROOT)\inc; \
    $(ATHROOT)\mailnews\extinc; \
    $(R)\inc; \
    $(R)\dll; \
    $(R)\common; \
    $(R)\mimeedit; \
    $(R)\mimeole; \
    $(R)\imnxport; \
    $(R)\fntcache; \
    $(INCLUDES)
!else
INCLUDES=\
    $(ATHROOT)\inc; \
    $(R)\inc; \
    $(R)\dll; \
    $(R)\mimeole; \
    $(R)\imnxport; \
    $(INCLUDES)
!endif

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin

PRECOMPILED_CXX=1
!ifndef WIN16
PRECOMPILED_OPTION=/Yupch.hxx /Fp$R\inc\$(_OBJ_DIR)\*\pch.pch
!else
PRECOMPILED_OPTION=/fh=$R\inc\$(_OBJ_DIR)\*\pch.pch
!endif
PRECOMPILED_TARGET=$(R)\inc\$(_OBJ_DIR)\*\pch.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\nntpcall.cpp ===
// --------------------------------------------------------------------------------
// Nntpcall.cpp
// --------------------------------------------------------------------------------
#include "pch.h"
#include "iconsole.h"
#include "nntpcall.h"

// --------------------------------------------------------------------------------
// HrCreateNNTPTransport
// --------------------------------------------------------------------------------
HRESULT HrCreateNNTPTransport(INNTPTransport **ppNNTP)
    {
    HRESULT          hr;
    CNNTPCallback   *pCallback = NULL;

    // Create the callback object
    pCallback = new CNNTPCallback();
    if (NULL == pCallback)
        {
        printf("Memory allocation failure\n");
        return (E_OUTOFMEMORY);
        }

    // Load the NNTP Transport
    hr = CoCreateInstance(CLSID_INNTPTransport, NULL, CLSCTX_INPROC_SERVER, 
                          IID_INNTPTransport, (LPVOID*) ppNNTP);
    if (FAILED(hr))
        {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_INNTPTransport\n");
        return (hr);
        }

    // Initialize the transport
    hr = (*ppNNTP)->InitNew(NULL, pCallback);
    if (FAILED(hr))
        {
        pCallback->Release();
        printf("Unable to initialize the transport\n");
        return (hr);
        }

    // Release our refcount on the callback since the transport has one now
    pCallback->Release();
    return (S_OK);
    }


// --------------------------------------------------------------------------------
// CNNTPCallback::CNNTPCallback
// --------------------------------------------------------------------------------
CNNTPCallback::CNNTPCallback(void)
    {
    m_cRef = 1;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::~CNNTPCallback
// --------------------------------------------------------------------------------
CNNTPCallback::~CNNTPCallback(void)
    {
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    // Locals
    HRESULT hr=S_OK;
    
    // Bad param
    if (ppv == NULL)
        {
        hr = E_INVALIDARG;
        goto exit;
        }
    
    // Init
    *ppv=NULL;
    
    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    
    // IID_INNTPCallback
    else if (IID_INNTPCallback == riid)
        *ppv = (INNTPCallback *)this;
    
    // If not null, addref it and return
    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
        }
    
    // No Interface
    hr = E_NOINTERFACE;
    
exit:
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CNNTPCallback::AddRef(void) 
    {
    return ++m_cRef;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CNNTPCallback::Release(void) 
    {
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnLogonPrompt(LPINETSERVER pInetServer,
                                          IInternetTransport *pTransport)
    {
    printf("Enter User Name ('quit' to abort logon)>");
    scanf("%s", pInetServer->szUserName);
    fflush(stdin);
    if (lstrcmpi(pInetServer->szUserName, "quit") == 0)
        return S_FALSE;
    
    printf("Enter Password ('quit' to abort logon)>");
    scanf("%s", pInetServer->szPassword);
    fflush(stdin);
    if (lstrcmpi(pInetServer->szPassword, "quit") == 0)
        return S_FALSE;
    
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CNNTPCallback::OnPrompt(HRESULT hrError, LPCTSTR pszText, 
                                           LPCTSTR pszCaption, UINT uType,
                                           IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnError(IXPSTATUS ixpstatus, LPIXPRESULT pIxpResult,
                                    IInternetTransport *pTransport)
    {
    HANDLE                      hConsole = INVALID_HANDLE_VALUE;
    CONSOLE_SCREEN_BUFFER_INFO  csbi;
    BOOL                        fChanged = FALSE;
    char                        szBuffer[256];
    DWORD                       dwWritten = 0;

    // Get a handle to the console window
    if (INVALID_HANDLE_VALUE != (hConsole = GetStdHandle(STD_OUTPUT_HANDLE)))
        {
        // Get the current attributes for the console
        if (GetConsoleScreenBufferInfo(hConsole, &csbi))
            {
            // Set the text color to be red on whatever background is currently
            // there
            fChanged = SetConsoleTextAttribute(hConsole, 
                                               (csbi.wAttributes & 0xF0) | FOREGROUND_RED | FOREGROUND_INTENSITY);
            }
        }

    wsprintf(szBuffer, "CNNTPCallback::OnError - Status: %d, hrResult: %08x\n", 
             ixpstatus, pIxpResult->hrResult);
    WriteConsole(hConsole, szBuffer, lstrlen(szBuffer), &dwWritten, NULL);

    // If we changed the screen attributes, then change them back
    if (fChanged)
        SetConsoleTextAttribute(hConsole, csbi.wAttributes);

    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnStatus(IXPSTATUS ixpstatus,
                                     IInternetTransport *pTransport)
    {
    INETSERVER                  rServer;
    HANDLE                      hConsole = INVALID_HANDLE_VALUE;
    CONSOLE_SCREEN_BUFFER_INFO  csbi;
    BOOL                        fChanged = FALSE;
    char                        szBuffer[256];
    DWORD                       dwWritten = 0;
    
    // Get a handle to the console window
    if (INVALID_HANDLE_VALUE != (hConsole = GetStdHandle(STD_OUTPUT_HANDLE)))
        {
        // Get the current attributes for the console
        if (GetConsoleScreenBufferInfo(hConsole, &csbi))
            {
            // Set the text color to be red on whatever background is currently
            // there
            fChanged = SetConsoleTextAttribute(hConsole, 
                (csbi.wAttributes & 0xF0) | FOREGROUND_GREEN | FOREGROUND_INTENSITY);
            }
        }

    pTransport->GetServerInfo(&rServer);
    
    switch(ixpstatus)
        {
        case IXP_FINDINGHOST:
            wsprintf(szBuffer, "Finding '%s'...\n", rServer.szServerName);
            break;
        case IXP_CONNECTING:
            wsprintf(szBuffer, "Connecting '%s'...\n", rServer.szServerName);
            break;
        case IXP_SECURING:
            wsprintf(szBuffer, "Establishing secure connection to '%s'...\n", rServer.szServerName);
            break;
        case IXP_CONNECTED:
            wsprintf(szBuffer, "Connected '%s'\n", rServer.szServerName);
            break;
        case IXP_AUTHORIZING:
            wsprintf(szBuffer, "Authorizing '%s'...\n", rServer.szServerName);
            break;
        case IXP_AUTHRETRY:
            wsprintf(szBuffer, "Retrying Logon '%s'...\n", rServer.szServerName);
            break;
        case IXP_DISCONNECTING:
            wsprintf(szBuffer, "Disconnecting '%s'...\n", rServer.szServerName);
            break;
        case IXP_DISCONNECTED:
            wsprintf(szBuffer, "Disconnected '%s'\n", rServer.szServerName);
            break;
        }

    WriteConsole(hConsole, szBuffer, lstrlen(szBuffer), &dwWritten, NULL);

    // If we changed the screen attributes, then change them back
    if (fChanged)
        SetConsoleTextAttribute(hConsole, csbi.wAttributes);

    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnProgress(DWORD dwIncrement, DWORD dwCurrent, 
                                       DWORD dwMaximum, IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnCommand(CMDTYPE cmdtype, LPSTR pszLine, 
                                      HRESULT hrResponse,
                                      IInternetTransport *pTransport)
    {
    INETSERVER rServer;

#if 1
    HANDLE     hOut;
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hOut, &csbi);
    SetConsoleTextAttribute(hOut, FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | (0xf0 & csbi.wAttributes));
#endif 

    pTransport->GetServerInfo(&rServer);
    if (CMD_SEND == cmdtype)
        {
        if (strstr(pszLine, "pass") || strstr(pszLine, "PASS"))
            printf("    %s[TX]: <Secret Password>\n", rServer.szServerName);
        else
            printf("    %s[TX]: %s", rServer.szServerName, pszLine);
        }
    else if (CMD_RESP == cmdtype)
        printf("    %s[RX]: %s - %08x\n", rServer.szServerName, pszLine, hrResponse);

#if 1
    SetConsoleTextAttribute(hOut, csbi.wAttributes);
#endif

    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnTimeout(DWORD *pdwTimeout, 
                                      IInternetTransport *pTransport)
    {
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    printf("Timeout '%s' !!!\n", rServer.szServerName);
    return S_OK;
    }


// --------------------------------------------------------------------------------
// CNNTPCallback::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnResponse(LPNNTPRESPONSE pResponse)
    {
    switch(pResponse->state)
        {
        case NS_DISCONNECTED:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_CONNECT:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_AUTHINFO:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_GROUP:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_GROUP_RESP - rGroup.dwFirst  = %d\n"
                       "                rGroup.dwLast   = %d\n"
                       "                rGroup.dwCount  = %d\n"
                       "                rGroup.pszGroup = %s\n\n",
                       pResponse->rGroup.dwFirst, pResponse->rGroup.dwLast, 
                       pResponse->rGroup.dwCount, pResponse->rGroup.pszGroup);
                }
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_NEXT:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_NEXT_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rNext.dwArticleNum, pResponse->rNext.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;
            
        case NS_LAST:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_LAST_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rLast.dwArticleNum, pResponse->rLast.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_STAT:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_STAT_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rLast.dwArticleNum, pResponse->rLast.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_LIST:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_LIST_DATA_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rList.cLines; i++)
                        printf("%s\n", pResponse->rList.rgszLines[i]);
                    }

                g_pNNTP->ReleaseResponse(pResponse);

                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;
            
        case NS_LISTGROUP:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_GROUP_SELECTED)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rListGroup.cArticles; i++)
                        printf("%d\n", pResponse->rListGroup.rgArticles[i]);
                    }

                g_pNNTP->ReleaseResponse(pResponse);

                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_DATE:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\nNS_DATE - %02d/%02d/%04d %02d:%02d:%02d\n\n",
                       pResponse->rDate.wMonth, pResponse->rDate.wDay,
                       pResponse->rDate.wYear, pResponse->rDate.wHour, 
                       pResponse->rDate.wMinute, pResponse->rDate.wSecond);
                }

            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_MODE:
            printf("\nNS_MODE\n\n");
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_NEWGROUPS:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_NEWNEWSGROUPS_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rNewgroups.cLines; i++)
                        printf("%s\n", pResponse->rNewgroups.rgszLines[i]);
                    }

                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;                       

        case NS_ARTICLE:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_ARTICLE_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    printf("%s", pResponse->rArticle.pszLines);

                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_HEAD:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_HEAD_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    printf("%s", pResponse->rArticle.pszLines);

                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_BODY:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_BODY_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    printf("%s", pResponse->rArticle.pszLines);
                    }
                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_IDLE:
            printf("NS_IDLE\n");
            printf("Why would we ever be here?");
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_HEADERS:
            if ((pResponse->rIxpResult.uiServerError / 100) != 2)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rHeaders.cHeaders; i++)
                        {
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwArticleNum);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszSubject);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszFrom);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszDate);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszMessageId);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszReferences);
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwBytes);
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwLines);
                        if (pResponse->rHeaders.rgHeaders[i].pszXref)
                            printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszXref);

                        printf("\n\n");
                        }
                    }

                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_XHDR:
            if ((pResponse->rIxpResult.uiServerError / 100) != 2)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rXhdr.cHeaders; i++)
                        {
                        printf("%6d %s\n", pResponse->rXhdr.rgHeaders[i].dwArticleNum,
                               pResponse->rXhdr.rgHeaders[i].pszHeader);
                        }
                    }

                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;
        
        case NS_POST:
            printf("%s\n", pResponse->rIxpResult.pszResponse);
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_QUIT:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP,0, 0);
            break;
        }
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\pch.cpp ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\main.cpp ===
// --------------------------------------------------------------------------------
// Main.cpp
// --------------------------------------------------------------------------------
#define INITGUID
#include "pch.h"
#include "windowsx.h"
#include <initguid.h>
#include "imnxport.h"
#include "smtpcall.h"
#include "pop3call.h"
#include "nntpcall.h"
#include "iconsole.h"
#include "rascall.h"
#include "httpcall.h"

// Globals
IImnAccountManager  *g_pAcctMan=NULL;
ISMTPTransport      *g_pSMTP=NULL;
IPOP3Transport      *g_pPOP3=NULL;
IRASTransport       *g_pRAS=NULL;
INNTPTransport      *g_pNNTP=NULL;
IHTTPMailTransport  *g_pHTTPMail=NULL;
UINT                 g_msgSMTP=0;
UINT                 g_msgPOP3=0;
UINT                 g_msgRAS=0;
UINT                 g_msgNNTP=0;
UINT                 g_msgHTTPMail=0;

// Prototypes
void ImnxportCommandShell(LPSTR pszShell);
void SMTPCommandShell(void);
void POP3CommandShell(void);
void NNTPCommandShell(void);
void IMAPCommandShell(void);
void RASCommandShell(void);
void HTTPMailCommandShell(void);

void ConnectToSMTPTransport(LPINETSERVER pServer);
void WaitForCompletion(UINT uiMsg, DWORD wparam);

void __cdecl main(int argc, char *argv[])
{
    // Locals
    HRESULT         hr;

    // OLE Init
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        printf("CoInitialize - FAILED\n");
        exit(1);
    }

    // Register completion message
    g_msgSMTP = RegisterWindowMessage("SMTPTransport_Notify");
    g_msgPOP3 = RegisterWindowMessage("POP3Transport_Notify");
    g_msgRAS  = RegisterWindowMessage("RASTransport_Notify");
    g_msgNNTP = RegisterWindowMessage("NNTPTransport_Notify");
    g_msgHTTPMail = RegisterWindowMessage("HTTPMailTransport_Notify");

    // Load the account manager
    hr = CoCreateInstance(CLSID_ImnAccountManager, NULL, CLSCTX_INPROC_SERVER, IID_IImnAccountManager, (LPVOID *)&g_pAcctMan);
    if (FAILED(hr))
    {
        printf("Unable to load the IMN Account Manager.\n");
        goto exit;
    }

    // Init the account manager
    hr = g_pAcctMan->Init(NULL);
    if (FAILED(hr))
    {
        printf("Unable to initialize the IMN Account Manager.\n");
        goto exit;
    }

    // Create smtp transport
    hr = HrCreateSMTPTransport(&g_pSMTP);
    if (FAILED(hr))
        goto exit;

    // Create pop3 transport
    hr = HrCreatePOP3Transport(&g_pPOP3);
    if (FAILED(hr))
        goto exit;

    // Create ras transport
    hr = HrCreateRASTransport(&g_pRAS);
    if (FAILED(hr))
        goto exit;

    // Create NNTP transport
    hr = HrCreateNNTPTransport(&g_pNNTP);
    if (FAILED(hr))
        goto exit;

    hr = HrCreateHTTPMailTransport(&g_pHTTPMail);
    if (FAILED(hr))
        goto exit;

    // Our console IO manager
    if (argc == 2)
        ImnxportCommandShell(argv[1]);
    else
        ImnxportCommandShell(NULL);

exit:
    // Cleanup
    if (g_pSMTP)
        g_pSMTP->Release();
    if (g_pPOP3)
        g_pPOP3->Release();
    if (g_pRAS)
        g_pRAS->Release();
    if (g_pNNTP)
        g_pNNTP->Release();
    if (g_pHTTPMail)
        g_pHTTPMail->Release();
    if (g_pAcctMan)
        g_pAcctMan->Release();

    // CoUninitialize
    CoUninitialize();

    // Done
    exit(1);
}

// --------------------------------------------------------------------------------
// HrByteToStream
// --------------------------------------------------------------------------------
HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb)
{
    // Locals
    HRESULT hr=S_OK;
    LARGE_INTEGER  liOrigin = {0,0};

    // Create H Global Stream
    hr = CreateStreamOnHGlobal (NULL, TRUE, lppstm);
    if (FAILED(hr))
        goto exit;

    // Write String
    hr = (*lppstm)->Write (lpb, cb, NULL);
    if (FAILED(hr))
        goto exit;

    // Rewind the steam
    hr = (*lppstm)->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    if (FAILED(hr))
        goto exit;

exit:
    // Done
    return hr;
}

void ImnxportCommandShellHelp(void)
{
    printf("Valid commands:\nSMTP\nPOP3\nNNTP\nIMAP\nRAS\nHTTPMail\nEXIT\n\n");
}

// Main command handler
void ImnxportCommandShell(LPSTR pszShell)
{
    // Locals
    char    szCommand[50];

    // Title
    printf("\nMicrosoft(R) Internet Mail and News Command Shell.\n");
    printf("(C) Copyright 1985-1996 Microsoft Corp.\n");
    printf("Type ? for help.\n\n");

IMNXPORTPrompt:
    if (!pszShell)
        {
        // Prompt
        printf("Internet> ");
        scanf("%s", szCommand);
        fflush(stdin);
        }
    else
        lstrcpy(szCommand, pszShell);

    printf("\n");

    // Handle Prompt
    if (lstrcmpi(szCommand, "SMTP") == 0)
        SMTPCommandShell();
    else if (lstrcmpi(szCommand, "POP3") == 0)
        POP3CommandShell();
    else if (lstrcmpi(szCommand, "IMAP") == 0)
        IMAPCommandShell();
    else if (lstrcmpi(szCommand, "NNTP") == 0)
        NNTPCommandShell();
    else if (lstrcmpi(szCommand, "RAS") == 0)
        RASCommandShell();
    else if (lstrcmpi(szCommand, "HTTPMail") == 0 || lstrcmpi(szCommand, "HTTP") == 0)
        HTTPMailCommandShell();
    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        ImnxportCommandShellHelp();

    // RePrompt
    pszShell = NULL;
    goto IMNXPORTPrompt;
}

// SMTP Command Help
void SMTPCommandShellHelp(void)
{
    printf("Valid commands:\nACCOUNTS\nCONNECT\nQUIT\nRSET\nSENDMESSAGE\nEHLO\nHELO\nMAIL\nRCPT\nDATA\nSTREAM\nCUSTOM\nEXIT\n\n");
}

// SMTP Command Handler
void SMTPCommandShell(void)
{
    // Locals
    INETSERVER      rServer;
    IImnAccount    *pAccount=NULL;
    char            szCommand[50];

    // Title
    printf("Microsoft(R) SMTP Command Shell.\n");
    printf("Type ? for help.\n\n");

    // Show command
SMTPPrompt:
    printf("SMTP>");
    scanf("%s", szCommand);
    fflush(stdin);

    if (lstrcmpi(szCommand, "ACCOUNTS") == 0)
        g_pAcctMan->AccountListDialog(NULL, NULL);

    else if (lstrcmpi(szCommand, "CONNECT") == 0)
    {
        char szAccount[CCHMAX_ACCOUNT_NAME];
        printf("Enter Account Name>");
        scanf("%s", szAccount);
        fflush(stdin);

        if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            printf("Invalid Account Name: '%s'\n\n", szAccount);
            goto SMTPPrompt;
        }

        if (FAILED(g_pSMTP->InetServerFromAccount(pAccount, &rServer)))
        {
            pAccount->Release();
            printf("IInternetTransport::InetServerFromAccount failed\n");
            goto SMTPPrompt;
        }

        if (FAILED(g_pSMTP->Connect(&rServer, TRUE, TRUE)))
        {
            pAccount->Release();
            printf("IInternetTransport::Connect failed\n");
            goto SMTPPrompt;
        }

        // Wait for completion
        WaitForCompletion(g_msgSMTP, SMTP_CONNECTED);

        // Done
        pAccount->Release();
    }
    else if (lstrcmpi(szCommand, "EHLO") == 0)
    {
        if (FAILED(g_pSMTP->CommandEHLO()))
        {
            printf("ISMTPTransport::CommandEHLO failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_EHLO);
    }
    else if (lstrcmpi(szCommand, "DOT") == 0)
    {
        if (FAILED(g_pSMTP->CommandDOT()))
        {
            printf("ISMTPTransport::CommandDOT failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_DOT);
    }
    else if (lstrcmpi(szCommand, "DATA") == 0)
    {
        if (FAILED(g_pSMTP->CommandDATA()))
        {
            printf("ISMTPTransport::CommandDATA failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_DATA);
    }
    else if (lstrcmpi(szCommand, "HELO") == 0)
    {
        if (FAILED(g_pSMTP->CommandHELO()))
        {
            printf("ISMTPTransport::CommandHELO failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_HELO);
    }
    else if (lstrcmpi(szCommand, "QUIT") == 0)
    {
        if (FAILED(g_pSMTP->CommandQUIT()))
        {
            printf("ISMTPTransport::CommandQUIT failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_QUIT);
    }
    else if (lstrcmpi(szCommand, "RSET") == 0)
    {
        if (FAILED(g_pSMTP->CommandRSET()))
        {
            printf("ISMTPTransport::CommandRSET failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_RSET);
    }
    else if (lstrcmpi(szCommand, "MAIL") == 0)
    {
        char szEmail[CCHMAX_EMAIL_ADDRESS];

        printf("Enter Sender Email Address>");
        scanf("%s", szEmail);
        fflush(stdin);
        if (FAILED(g_pSMTP->CommandMAIL(szEmail)))
        {
            printf("ISMTPTransport::CommandMAIL failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_MAIL);
    }

    else if (lstrcmpi(szCommand, "RCPT") == 0)
    {
        char szEmail[CCHMAX_EMAIL_ADDRESS];

        while(1)
        {
            printf("Enter Recipient Email ('Done')>");
            scanf("%s", szEmail);
            fflush(stdin);
            if (lstrcmpi(szEmail, "DONE") == 0)
                break;

            if (FAILED(g_pSMTP->CommandRCPT(szEmail)))
            {
                printf("ISMTPTransport::CommandRCPT failed.\n");
                goto SMTPPrompt;
            }
            WaitForCompletion(g_msgSMTP, SMTP_RCPT);
        }
    }

    else if (lstrcmpi(szCommand, "SENDMESSAGE") == 0)
    {
        INETADDR            rgAddress[11];
        SMTPMESSAGE         rMessage;
        CHAR                szText[1024];

        ZeroMemory(&rgAddress, sizeof(rgAddress));
        ZeroMemory(&rMessage, sizeof(rMessage));

        printf("Enter Sender Email Address>");
        rgAddress[0].addrtype = ADDR_FROM;
        scanf("%s", rgAddress[0].szEmail);
        fflush(stdin);

        rMessage.rAddressList.prgAddress = rgAddress;
        rMessage.rAddressList.cAddress = 1;
        while(rMessage.rAddressList.cAddress < 11)
        {
            INT i = rMessage.rAddressList.cAddress;
            printf("(%d of 10) Enter Recipient Email ('Done')>", i);
            rgAddress[i].addrtype = ADDR_TO;
            scanf("%s", rgAddress[i].szEmail);
            fflush(stdin);
            if (lstrcmpi(rgAddress[i].szEmail, "DONE") == 0)
                break;
            rMessage.rAddressList.cAddress++;
        }

        printf("Enter Message Text, end with pressing RETURN:\n");
        scanf("%s", szText);
        fflush(stdin);

        rMessage.cbSize = lstrlen(szText);

        if (FAILED(HrByteToStream(&rMessage.pstmMsg, (LPBYTE)szText, rMessage.cbSize + 1)))
        {
            printf("HrByteToStream failed.\n");
            goto SMTPPrompt;
        }

        if (FAILED(g_pSMTP->SendMessage(&rMessage)))
        {
            rMessage.pstmMsg->Release();
            printf("ISMTPTransport::SendMessage failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_SEND_MESSAGE);
        rMessage.pstmMsg->Release();
    }


    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        SMTPCommandShellHelp();

    // Go back to the prompt
    goto SMTPPrompt;
}

// POP3 Command Help
void POP3CommandShellHelp(void)
{
    printf("Valid commands:\nACCOUNTS\nCONNECT\nQUIT\nSTAT\nLIST\nUIDL\nTOP\nRETR\nMARK\n\n");
}

POP3CMDTYPE GetCommandType(LPDWORD pdwPopId)
{
    INT i;
    *pdwPopId = 0;
    printf("(1) - POP3CMD_GET_POPID\n(2) - POP3CMD_GET_MARKED\n(3) - POP3CMD_GET_ALL\nSelect Command Type>");
    scanf("%d", &i);
    fflush(stdin);
    if (i == 1)
    {
        printf("Enter PopId>");
        scanf("%d", pdwPopId);
        return POP3CMD_GET_POPID;
    }
    else if (i == 2)
        return POP3CMD_GET_MARKED;
    return POP3CMD_GET_ALL;
}

// POP3 Command Shell
void POP3CommandShell(void)
{
    // Locals
    DWORD           dwPopId;
    POP3CMDTYPE     cmdtype;
    INETSERVER      rServer;
    IImnAccount    *pAccount=NULL;
    char            szCommand[50];

    // Title
    printf("Microsoft(R) POP3 Command Shell.\n");
    printf("Type ? for help.\n\n");

    // Show command
POP3Prompt:
    printf("POP3>");
    scanf("%s", szCommand);
    fflush(stdin);

    if (lstrcmpi(szCommand, "ACCOUNTS") == 0)
        g_pAcctMan->AccountListDialog(NULL, NULL);

    else if (lstrcmpi(szCommand, "CONNECT") == 0)
    {
        char szAccount[CCHMAX_ACCOUNT_NAME];
        printf("Enter Account Name>");
        scanf("%s", szAccount);
        fflush(stdin);

        if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            printf("Invalid Account Name: '%s'\n\n", szAccount);
            goto POP3Prompt;
        }

        if (FAILED(g_pPOP3->InetServerFromAccount(pAccount, &rServer)))
        {
            pAccount->Release();
            printf("IInternetTransport::InetServerFromAccount failed\n");
            goto POP3Prompt;
        }

        if (FAILED(g_pPOP3->Connect(&rServer, TRUE, TRUE)))
        {
            pAccount->Release();
            printf("IInternetTransport::Connect failed\n");
            goto POP3Prompt;
        }

        // Wait for completion
        WaitForCompletion(g_msgPOP3, POP3_CONNECTED);

        // Done
        pAccount->Release();
    }
    else if (lstrcmpi(szCommand, "QUIT") == 0)
    {
        if (FAILED(g_pPOP3->CommandQUIT()))
        {
            printf("IPOP3Transport::CommandQUIT failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_QUIT);
    }
    else if (lstrcmpi(szCommand, "STAT") == 0)
    {
        if (FAILED(g_pPOP3->CommandSTAT()))
        {
            printf("IPOP3Transport::CommandSTAT failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_STAT);
    }
    else if (lstrcmpi(szCommand, "LIST") == 0)
    {
        cmdtype = GetCommandType(&dwPopId);
        if (FAILED(g_pPOP3->CommandLIST(cmdtype, dwPopId)))
        {
            printf("IPOP3Transport::CommandLIST failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_LIST);
    }
    else if (lstrcmpi(szCommand, "UIDL") == 0)
    {
        cmdtype = GetCommandType(&dwPopId);
        if (FAILED(g_pPOP3->CommandUIDL(cmdtype, dwPopId)))
        {
            printf("IPOP3Transport::CommandUIDL failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_UIDL);
    }
    else if (lstrcmpi(szCommand, "DELE") == 0)
    {
        cmdtype = GetCommandType(&dwPopId);
        if (FAILED(g_pPOP3->CommandDELE(cmdtype, dwPopId)))
        {
            printf("IPOP3Transport::CommandDELE failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_DELE);
    }
    else if (lstrcmpi(szCommand, "TOP") == 0)
    {
        INT cLines;
        cmdtype = GetCommandType(&dwPopId);
        printf("Number of Lines to Preview>");
        scanf("%d", &cLines);
        fflush(stdin);
        if (FAILED(g_pPOP3->CommandTOP(cmdtype, dwPopId, cLines)))
        {
            printf("IPOP3Transport::CommandTOP failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_TOP);
    }
    else if (lstrcmpi(szCommand, "RETR") == 0)
    {
        cmdtype = GetCommandType(&dwPopId);
        if (FAILED(g_pPOP3->CommandRETR(cmdtype, dwPopId)))
        {
            printf("IPOP3Transport::CommandRETR failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_RETR);
    }
    else if (lstrcmpi(szCommand, "MARK") == 0)
    {
        INT     type, popid, flag;
        POP3MARKTYPE marktype;

        printf("(1) - POP3_MARK_FOR_TOP\n");
        printf("(2) - POP3_MARK_FOR_RETR\n");
        printf("(3) - POP3_MARK_FOR_DELE\n");
        printf("(4) - POP3_MARK_FOR_UIDL\n");
        printf("(5) - POP3_MARK_FOR_LIST\n");
        printf("Select MarkItem Type>");
        scanf("%d", &type);
        fflush(stdin);
        printf("Enter PopId>");
        scanf("%d", &popid);
        fflush(stdin);
        printf("Enable or Disable Marked Item (1 = Enable, 0 = Disable)>");
        scanf("%d", &flag);
        fflush(stdin);
        if (1 == type) marktype = POP3_MARK_FOR_TOP;
        else if (2 == type) marktype = POP3_MARK_FOR_RETR;
        else if (3 == type) marktype = POP3_MARK_FOR_DELE;
        else if (4 == type) marktype = POP3_MARK_FOR_UIDL;
        else if (5 == type) marktype = POP3_MARK_FOR_LIST;
        else
        {
            printf("Invalid MarkItemType!\n");
            goto POP3Prompt;
        }

        if (FAILED(g_pPOP3->MarkItem(marktype, popid, flag)))
        {
            printf("IPOP3Transport::MarkItem failed!\n");
            goto POP3Prompt;
        }
    }
    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        POP3CommandShellHelp();

    // Go back to the prompt
    goto POP3Prompt;
}

// NNTP Command Help
void NNTPCommandShellHelp(void)
{
    printf("Valid commands:\nACCOUNTS\nCONNECT\nGROUP\nNEXT\nLAST\n"
           "STAT\nLIST\nMODE\nDATE\nARTICLE\nHEAD\nBODY\nHEADERS\nXHDR\n"
           "POST\nQUIT\n\n");
}

void NNTPCommandShell(void)
{
    // Locals
    INETSERVER      rServer;
    IImnAccount    *pAccount=NULL;
    char            szCommand[50];

    // Title
    printf("Microsoft(R) NNTP Command Shell.\n");
    printf("Type ? for help.\n\n");

    // Show command
NNTPPrompt:
    printf("NNTP> ");
    scanf("%s", szCommand);
    fflush(stdin);

    if (lstrcmpi(szCommand, "ACCOUNTS") == 0)
        g_pAcctMan->AccountListDialog(GetDesktopWindow(), NULL);

    else if (lstrcmpi(szCommand, "CONNECT") == 0)
    {
        char szAccount[CCHMAX_ACCOUNT_NAME];
        printf("Enter Account Name> ");
        scanf("%s", szAccount);
        fflush(stdin);

        if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            printf("Invalid Account Name: '%s'\n\n", szAccount);
            goto NNTPPrompt;
        }

        if (FAILED(g_pNNTP->InetServerFromAccount(pAccount, &rServer)))
        {
            pAccount->Release();
            printf("IInternetTransport::InetServerFromAccount failed\n");
            goto NNTPPrompt;
        }

        if (FAILED(g_pNNTP->Connect(&rServer, TRUE, TRUE)))
        {
            pAccount->Release();
            printf("IInternetTransport::Connect failed\n");
            goto NNTPPrompt;
        }

        // Wait for completion
        WaitForCompletion(g_msgNNTP, 0);

        // Done
        pAccount->Release();
    }
    else if (lstrcmpi(szCommand, "QUIT") == 0)
    {
        if (FAILED(g_pNNTP->CommandQUIT()))
        {
            printf("INNTPTransport::CommandQUIT failed.\n");
            goto NNTPPrompt;
        }
        WaitForCompletion(g_msgNNTP, NS_DISCONNECTED);
    }
    else if (lstrcmpi(szCommand, "AUTHINFO") == 0)
        {
        DWORD dwType;
        char  szUserName[256];
        char  szPassword[256];
        NNTPAUTHINFO authinfo;

        printf("(1) AUTHINFO USER/PASS\n");
        printf("(2) AUTHINFO SIMPLE\n");
        printf("(3) AUTHINFO TRANSACT\n");
        printf("Select type > ");
        scanf("%d", &dwType);
        fflush(stdin);

        authinfo.authtype = (dwType == 1) ? AUTHTYPE_USERPASS : ((dwType == 2) ? AUTHTYPE_SIMPLE : AUTHTYPE_SASL);
        if (dwType < 3)
            {
            printf("User Name > ");
            scanf("%s", &szUserName);
            fflush(stdin);
            printf("Password > ");
            scanf("%s", &szPassword);

            authinfo.pszUser = szUserName;
            authinfo.pszPass = szPassword;
            }

        if (FAILED(g_pNNTP->CommandAUTHINFO(&authinfo)))
            {
            printf("INNTPTransport::CommandAUTHINFO() failed\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "GROUP") == 0)
        {
        char szGroup[256];
        printf("Enter Group Name> ");
        scanf("%s", szGroup);
        fflush(stdin);

        if (FAILED(g_pNNTP->CommandGROUP(szGroup)))
            {
            printf("INNTPTransport::CommandGROUP failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_GROUP);
        }
    else if (lstrcmpi(szCommand, "NEXT") == 0)
        {
        if (FAILED(g_pNNTP->CommandNEXT()))
            {
            printf("INNTPTransport::CommandNEXT failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_NEXT);
        }
    else if (lstrcmpi(szCommand, "LAST") == 0)
        {
        if (FAILED(g_pNNTP->CommandLAST()))
            {
            printf("INNTPTransport::CommandLAST failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_LAST);
        }
    else if (lstrcmpi(szCommand, "STAT") == 0)
        {
        char szStat[256];
        ARTICLEID aid;

        ZeroMemory(szStat, sizeof(szStat));
        ZeroMemory(&aid, sizeof(aid));

        printf("Enter article> ");
        scanf("%s", szStat);
        fflush(stdin);

        if (0 == sscanf(szStat, "%d", &aid.dwArticleNum))
            {
            aid.idType = AID_MSGID;
            aid.pszMessageId = szStat;
            }
        else
            aid.idType = AID_ARTICLENUM;

        if (FAILED(g_pNNTP->CommandSTAT(*szStat ? &aid : NULL)))
            {
            printf("INNTPTransport::CommandSTAT failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_STAT);
        }
    else if (lstrcmpi(szCommand, "LIST") == 0)
        {
        if (FAILED(g_pNNTP->CommandLIST(NULL)))
            {
            printf("INNTPTransport::CommandLIST failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "LISTGROUP") == 0)
        {
        char szGroup[256];
        printf("Enter Group Name> ");
        scanf("%s", szGroup);
        fflush(stdin);

        if (FAILED(g_pNNTP->CommandLISTGROUP(szGroup)))
            {
            printf("INNTPTransport::CommandLISTGROUP failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "LISTARG") == 0)
        {
        char szArg[256];
        ZeroMemory(szArg, 256);

        printf("Enter Arguments> ");
        scanf("%s", szArg);
        fflush(stdin);

        if (FAILED(g_pNNTP->CommandLIST(szArg)))
            {
            printf("INNTPTransport::CommandLIST failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "DATE") == 0)
        {
        if (FAILED(g_pNNTP->CommandDATE()))
            {
            printf("INNTPTransport::CommandDATE failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_DATE);
        }
    else if (lstrcmpi(szCommand, "MODE") == 0)
        {
        char szArg[256];
        ZeroMemory(szArg, 256);

        printf("Enter Arguments> ");
        scanf("%s", szArg);
        fflush(stdin);

        if (FAILED(g_pNNTP->CommandMODE(szArg)))
            {
            printf("INNTPTransport::CommandMODE failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_MODE);
        }
    else if (lstrcmpi(szCommand, "NEWGROUPS") == 0)
        {
        SYSTEMTIME st = {1996, 11, 0, 1, 0, 0, 0, 0};

        if (FAILED(g_pNNTP->CommandNEWGROUPS(&st, "<alt>")))
            {
            printf("INNTPTransport::CommandNEWGROUPS failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "ARTICLE") == 0)
        {
        char szArg[256];
        ARTICLEID aid;
        ZeroMemory(szArg, 256);

        printf("Enter article number> ");
        scanf("%s", szArg);
        fflush(stdin);

        if (0 == sscanf(szArg, "%d", &aid.dwArticleNum))
            {
            aid.idType = AID_MSGID;
            aid.pszMessageId = szArg;
            }
        else
            aid.idType = AID_ARTICLENUM;

        if (FAILED(g_pNNTP->CommandARTICLE(&aid)))
            {
            printf("INNTPTransport::CommandARTICLE failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "HEAD") == 0)
        {
        char szArg[256];
        ARTICLEID aid;
        ZeroMemory(szArg, 256);

        printf("Enter article number> ");
        scanf("%s", szArg);
        fflush(stdin);

        if (0 == sscanf(szArg, "%d", &aid.dwArticleNum))
            {
            aid.idType = AID_MSGID;
            aid.pszMessageId = szArg;
            }
        else
            aid.idType = AID_ARTICLENUM;

        if (FAILED(g_pNNTP->CommandHEAD(&aid)))
            {
            printf("INNTPTransport::CommandHEAD failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "BODY") == 0)
        {
        char szArg[256];
        ARTICLEID aid;
        ZeroMemory(szArg, 256);

        printf("Enter article number> ");
        scanf("%s", szArg);
        fflush(stdin);

        if (0 == sscanf(szArg, "%d", &aid.dwArticleNum))
            {
            aid.idType = AID_MSGID;
            aid.pszMessageId = szArg;
            }
        else
            aid.idType = AID_ARTICLENUM;

        if (FAILED(g_pNNTP->CommandBODY(&aid)))
            {
            printf("INNTPTransport::CommandBODY failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "HEADERS") == 0)
        {
        char szArg1[30], szArg2[30];
        RANGE range;
        
        printf("Enter starting article number> ");
        scanf("%s", szArg1);
        fflush(stdin);

        printf("Enter ending article number (0 for a single article)> ");
        scanf("%s", szArg2);
        fflush(stdin);

        range.idType = (atol(szArg2) == 0 ? RT_SINGLE : RT_RANGE);
        range.dwFirst = atol(szArg1);
        range.dwLast = atol(szArg2);

        if (FAILED(g_pNNTP->GetHeaders(&range)))
            {
            printf("INNTPTransport::GetHeaders() failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "XHDR") == 0)
        {
        char szHdr[256];
        char szArg1[30], szArg2[30];
        RANGE range;
        HRESULT hr;

        // I tested this scenario as well -- SteveSer
        // hr = g_pNNTP->CommandXHDR("Subject", NULL, "<01bb9b7a$7767b020$ff22369d@a-dmay>");

        printf("Enter header> ");
        scanf("%s", szHdr);
        
        printf("Enter starting article number (0 for the current article)> ");
        scanf("%s", szArg1);
        fflush(stdin);

        if (atol(szArg1) != 0)
            {
            printf("Enter ending article number (0 for a single article)> ");
            scanf("%s", szArg2);
            fflush(stdin);
            }

        if (atol(szArg1) == 0)
            hr = g_pNNTP->CommandXHDR(szHdr, NULL, NULL);
        else
            {
            range.idType = (atol(szArg2) == 0 ? RT_SINGLE : RT_RANGE);
            range.dwFirst = atol(szArg1);
            range.dwLast = atol(szArg2);
            hr = g_pNNTP->CommandXHDR(szHdr, &range, NULL);
            }

        if (FAILED(hr))
            {
            printf("INNTPTransport::CommandXHDR() failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "POST") == 0)
        {
        char szMessage[] = "From: \"Steve Serdy\" <steveser@microsoft.com>\r\n"
                           "Newsgroups: alt.test\r\n"
                           "Subject: Test Message\r\n"
                           "\r\nTest\r\n";
        NNTPMESSAGE rMessage;
        LPSTREAM    pStream = 0;
        HRESULT     hr;
        
        if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
            {
            pStream->Write((void const*) szMessage, lstrlen(szMessage) + 1, NULL);

            rMessage.cbSize = lstrlen(szMessage);
            rMessage.pstmMsg = pStream;
            
            hr = g_pNNTP->CommandPOST(&rMessage);
            pStream->Release();

            if (FAILED(hr))
                {
                printf("INNTPTransport::CommandPOST() failed.\n");
                goto NNTPPrompt;
                }
            WaitForCompletion(g_msgNNTP, 0);
            }
        }
    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        NNTPCommandShellHelp();

    // Go back to the prompt
    goto NNTPPrompt;
}


void IMAPCommandShell(void)
{
    printf("Not yet implemented.\n\n");
}

void RASCommandShellHelp(void)
{
    printf("Valid commands:\nCONNECT\nDISCONNECT\nEXIT\n\n");
}

void RASCommandShell(void)
{
    char            szCommand[50];
    IImnAccount    *pAccount=NULL;
    INETSERVER      rServer;

    // Title
    printf("Microsoft(R) RAS Command Shell.\n");
    printf("Type ? for help.\n\n");

    // Show command
RASPrompt:
    printf("RAS>");
    scanf("%s", szCommand);
    fflush(stdin);

    if (lstrcmpi(szCommand, "CONNECT") == 0)
    {
        char szAccount[CCHMAX_ACCOUNT_NAME];
        printf("Enter Account Name>");
        scanf("%s", szAccount);
        fflush(stdin);

        if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            printf("Invalid Account Name: '%s'\n\n", szAccount);
            goto RASPrompt;
        }

        if (FAILED(g_pPOP3->InetServerFromAccount(pAccount, &rServer)))
        {
            pAccount->Release();
            printf("IInternetTransport::InetServerFromAccount failed\n");
            goto RASPrompt;
        }

        if (RAS_CONNECT_RAS != rServer.rasconntype)
        {
            pAccount->Release();
            printf("Account is not using RAS.\n");
            goto RASPrompt;
        }

        if (FAILED(g_pRAS->Connect(&rServer, TRUE, TRUE)))
        {
            pAccount->Release();
            printf("IInternetTransport::Connect failed\n");
            goto RASPrompt;
        }

        // Wait for completion
        WaitForCompletion(g_msgRAS, RAS_CONNECT);

        // Done
        pAccount->Release();
    }
    else if (lstrcmpi(szCommand, "DISCONNECT") == 0)
    {
        g_pRAS->Disconnect();
    }
    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        RASCommandShellHelp();

    // Go back to the prompt
    goto RASPrompt;
}

void HTTPMailCommandShellHelp(void)
{
    printf("Valid commands:\nCONNECT\nDISCONNECT\nGET\nGETROOTPROP\nLISTFOLDERS\nPUT\nPROPFIND\nEXIT\n\n");
}

void HTTPMailCommandShell(void)
{
    INETSERVER      rServer;    
    char            szCommand[50];
    
    // Title
    printf("Microsoft(R) HTTPMail Command Shell.\n");
    printf("Type ? for help.\n\n");

HTTPMailPrompt:
    printf("HTTPMail> ");
    scanf("%s", szCommand);
    fflush(stdin);

    if (lstrcmpi(szCommand, "CONNECT") == 0)
    {
        ZeroMemory(&rServer, sizeof(rServer));
        printf("Enter server> ");
        scanf("%s", rServer.szServerName);
        fflush(stdin);

        printf("Enter login ('*' for anonymous)> ");
        scanf("%s", rServer.szUserName);
        fflush(stdin);
        if ('*' == rServer.szUserName[0])
            rServer.szUserName[0] = '\0';
        else
        {
            printf("Enter password> ");
            scanf("%s", rServer.szPassword);
        }

        if (FAILED(g_pHTTPMail->Connect(&rServer, FALSE, TRUE)))
        {
            printf("IHTTMPMailTransport::Connect failed\n");
            goto HTTPMailPrompt;
        }
        WaitForCompletion(g_msgHTTPMail, HTTPMAIL_CONNECTED);
        goto HTTPMailPrompt;
    }
    else if (lstrcmpi(szCommand, "GET") == 0)
    {
        char szPath[1024];
 
        printf("Enter path ('/' for root)> ");
        scanf("%s", szPath);
        fflush(stdin);

        g_pHTTPMail->CommandGET(szPath, 0);
        WaitForCompletion(g_msgHTTPMail, HTTPMAIL_GET);
        goto HTTPMailPrompt;
    }
    else if (lstrcmpi(szCommand, "GETROOTPROP") == 0)
    {
        int iSelection;
        HTTPMAILROOTPROPTYPE proptype;

        printf("Select a property to retrieve:\n");
        printf("\t(1) Adbar\n\t(2) Contacts\n\t(3) Inbox\n\t(4) Outbox\n\t(5) SentItems");
        printf("\n\t(6) DeletedItems\n\t(7) Drafts\n\t(8) MsgFolderRoot\n\t(9) Sig");
        printf("\nSelection> ");
        scanf("%d", &iSelection);
        fflush(stdin);

        if (iSelection < 1 || iSelection > 9)
        {
            printf("Invalid Selection\n");
            goto HTTPMailPrompt;
        }

        HTTPMAILROOTPROPTYPE    rgProps[] = 
        {
            HTTPMAIL_ROOTPROP_ADBAR,
            HTTPMAIL_ROOTPROP_CONTACTS,
            HTTPMAIL_ROOTPROP_INBOX,
            HTTPMAIL_ROOTPROP_OUTBOX,
            HTTPMAIL_ROOTPROP_SENTITEMS,
            HTTPMAIL_ROOTPROP_DELETEDITEMS,
            HTTPMAIL_ROOTPROP_DRAFTS,
            HTTPMAIL_ROOTPROP_MSGFOLDERROOT,
            HTTPMAIL_ROOTPROP_SIG
        };
        
        LPSTR pszProp = NULL;
        if (SUCCEEDED(g_pHTTPMail->GetRootProperty(rgProps[iSelection - 1], &pszProp)))
        {
            if (pszProp)
                printf("Result: %s\n", pszProp);
        }
        
        goto HTTPMailPrompt;
    }
    else if (lstrcmpi(szCommand, "LISTFOLDERS") == 0)
    {
        g_pHTTPMail->ListFolders(0);
        WaitForCompletion(g_msgHTTPMail, HTTPMAIL_LISTFOLDERS);
    }
    else if (lstrcmpi(szCommand, "PUT") == 0)
    {
        char szPath[1024];
        char *lpszData = "Outlook Express PUT test";
 
        printf("Enter path ('/' for root)> ");
        scanf("%s", szPath);
        fflush(stdin);

        g_pHTTPMail->CommandPUT(szPath, lpszData, strlen(lpszData), 0);
    }
    else if (lstrcmpi(szCommand, "POST") == 0)
    {
        char szPath[1024];
        char *lpszData = "Outlook Express POST test";
 
        printf("Enter path ('/' for root)> ");
        scanf("%s", szPath);
        fflush(stdin);

        g_pHTTPMail->CommandPOST(szPath, lpszData, strlen(lpszData), 0);

    }
    else if (lstrcmpi(szCommand, "PROPFIND") == 0)
    {
        char szPath[1024];

        printf("Enter path ('/' for root)> ");
        scanf("%s", szPath);
        fflush(stdin);

        g_pHTTPMail->CommandPROPFIND(szPath, NULL, 0, 0);
        WaitForCompletion(g_msgHTTPMail, HTTPMAIL_PROPFIND);
        goto HTTPMailPrompt;
    }
    else if (lstrcmpi(szCommand, "DISCONNECT") == 0)
    {
        g_pHTTPMail->Disconnect();
    }
    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        HTTPMailCommandShellHelp();

    // Go back to the prompt
    goto HTTPMailPrompt;
}

void WaitForCompletion(UINT uiMsg, DWORD wparam)
{
    MSG msg;
    while(GetMessage(&msg, NULL, 0, 0))
    {
        if (msg.message == uiMsg && msg.wParam == wparam || msg.wParam == IXP_DISCONNECTED)
            break;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\nntpcall.h ===
// --------------------------------------------------------------------------------
// Nntpcall.h
// --------------------------------------------------------------------------------

#ifndef __NNTPCALL_H__
#define __NNTPCALL_H__

#include "imnxport.h"

HRESULT HrCreateNNTPTransport(INNTPTransport **ppNNTP);


class CNNTPCallback : public INNTPCallback
    {
private:
    ULONG       m_cRef;

public:
    CNNTPCallback(void);
    ~CNNTPCallback(void);

    STDMETHODIMP QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // INNTPCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPNNTPRESPONSE              pResponse);
    };

#endif // __NNTPCALL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\pch.h ===
#include <windows.h>
#include <stdio.h>
#include <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\pop3call.cpp ===
// --------------------------------------------------------------------------------
// Pop3call.cpp
// --------------------------------------------------------------------------------
#include "pch.h"
#include "iconsole.h"
#include "pop3call.h"

// --------------------------------------------------------------------------------
// HrCreatePOP3Transport
// --------------------------------------------------------------------------------
HRESULT HrCreatePOP3Transport(IPOP3Transport **ppPOP3)
{
    // Locals
    HRESULT             hr;
    CPOP3Callback      *pCallback=NULL;

    // Create callback object
    pCallback = new CPOP3Callback();
    if (NULL == pCallback)
    {
        printf("Memory allocation failure\n");
        return E_OUTOFMEMORY;
    }

    // Load SMTP Transport
    hr = CoCreateInstance(CLSID_IPOP3Transport, NULL, CLSCTX_INPROC_SERVER, IID_IPOP3Transport, (LPVOID *)ppPOP3);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_IPOP3Transport\n");
        return E_FAIL;
    }

    // InitNew
    hr = (*ppPOP3)->InitNew(NULL, pCallback);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_IPOP3Transport\n");
        return E_FAIL;
    }

    // Done
    pCallback->Release();
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::CPOP3Callback
// --------------------------------------------------------------------------------
CPOP3Callback::CPOP3Callback(void)
{
    m_cRef = 1;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::~CPOP3Callback
// --------------------------------------------------------------------------------
CPOP3Callback::~CPOP3Callback(void)
{
}

// --------------------------------------------------------------------------------
// CPOP3Callback::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // IID_IPOP3Callback
    else if (IID_IPOP3Callback == riid)
        *ppv = (IPOP3Callback *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = E_NOINTERFACE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPOP3Callback::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPOP3Callback::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnLogonPrompt(
        LPINETSERVER            pInetServer,
        IInternetTransport     *pTransport)
{
    printf("Enter User Name ('quit' to abort logon)>");
    scanf("%s", pInetServer->szUserName);
    fflush(stdin);
    if (lstrcmpi(pInetServer->szUserName, "quit") == 0)
        return S_FALSE;

    printf("Enter Password ('quit' to abort logon)>");
    scanf("%s", pInetServer->szPassword);
    fflush(stdin);
    if (lstrcmpi(pInetServer->szPassword, "quit") == 0)
        return S_FALSE;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CPOP3Callback::OnPrompt(
        HRESULT                 hrError, 
        LPCTSTR                 pszText, 
        LPCTSTR                 pszCaption, 
        UINT                    uType,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnError(
        IXPSTATUS               ixpstatus,
        LPIXPRESULT             pIxpResult,
        IInternetTransport     *pTransport)
{
    printf("CPOP3Callback::OnError - Status: %d, hrResult: %08x\n", ixpstatus, pIxpResult->hrResult);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnStatus(
        IXPSTATUS               ixpstatus,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;

    pTransport->GetServerInfo(&rServer);

    switch(ixpstatus)
    {
    case IXP_FINDINGHOST:
        printf("Finding '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTING:
        printf("Connecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_SECURING:
        printf("Establishing secure connection to '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTED:
        printf("Connected '%s'\n", rServer.szServerName);
        break;
    case IXP_AUTHORIZING:
        printf("Authorizing '%s'...\n", rServer.szServerName);
        break;
    case IXP_AUTHRETRY:
        printf("Retrying Logon '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTING:
        printf("Disconnecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTED:
        printf("Disconnected '%s'\n", rServer.szServerName);
        PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, IXP_DISCONNECTED, 0);
        PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_QUIT, 0);
        break;
    }
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnProgress(
        DWORD                   dwIncrement,
        DWORD                   dwCurrent,
        DWORD                   dwMaximum,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnCommand(
        CMDTYPE                 cmdtype,                                            
        LPSTR                   pszLine,
        HRESULT                 hrResponse,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    if (CMD_SEND == cmdtype)
    {
        if (strstr(pszLine, "pass") || strstr(pszLine, "PASS"))
            printf("%s[TX]: <Secret Password>\n", rServer.szServerName);
        else
            printf("%s[TX]: %s", rServer.szServerName, pszLine);
    }
    else if (CMD_RESP == cmdtype)
        printf("%s[RX]: %s - %08x\n", rServer.szServerName, pszLine, hrResponse);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnTimeout(
        DWORD                  *pdwTimeout,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    printf("Timeout '%s' !!!\n", rServer.szServerName);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnResponse(
        LPPOP3RESPONSE              pResponse)
{
    switch(pResponse->command)
    {
    case POP3_NONE:
        break;

    case POP3_BANNER:
        break;

    case POP3_CONNECTED:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_CONNECTED, 0);
        break;

    case POP3_RSET:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_RSET, 0);
        break;

    case POP3_QUIT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_QUIT, 0);
        break;

    case POP3_LIST:
        // 0 is invalid for dwPopId
        if (pResponse->rListInfo.dwPopId)
        {
            printf("OnResponse::POP3_LIST - dwPopId = %d\n", pResponse->rListInfo.dwPopId);
            printf("OnResponse::POP3_LIST - cbSize = %d\n", pResponse->rListInfo.cbSize);
        }
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_LIST, 0);
        break;

    case POP3_UIDL:
        // 0 is invalid for dwPopId
        if (pResponse->fValidInfo)
        {
            printf("OnResponse::POP3_UIDL - dwPopId = %d\n", pResponse->rUidlInfo.dwPopId);
            printf("OnResponse::POP3_UIDL - pszUidl = %s\n", pResponse->rUidlInfo.pszUidl);
        }
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_UIDL, 0);
        break;

    case POP3_DELE:
        // 0 is invalid for dwPopId
        if (pResponse->fValidInfo)
            printf("OnResponse::POP3_DELE - dwPopId = %d\n", pResponse->dwPopId);
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_DELE, 0);
        break;

    case POP3_STAT:
        if (pResponse->fDone)
        {
            printf("OnResponse::POP3_STAT - cMessages = %d\n", pResponse->rStatInfo.cMessages);
            printf("OnResponse::POP3_STAT - cbMessages = %d\n", pResponse->rStatInfo.cbMessages);
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_STAT, 0);
        }
        break;

    case POP3_TOP:
        if (pResponse->fValidInfo)
        {
            if (pResponse->rTopInfo.pszLines)
                printf("%s", pResponse->rTopInfo.pszLines);
            if (pResponse->rTopInfo.cPreviewLines && pResponse->rTopInfo.fHeader && pResponse->rTopInfo.fBody)
                printf("%d Total\n", pResponse->rTopInfo.cbSoFar);
            else if (pResponse->rTopInfo.cPreviewLines == 0 && pResponse->rTopInfo.fHeader)
                printf("%d Total\n", pResponse->rTopInfo.cbSoFar);
        }
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_TOP, 0);
        break;

    case POP3_RETR:
        if (pResponse->fValidInfo)
        {
            if (pResponse->rRetrInfo.pszLines)
                printf("%s", pResponse->rRetrInfo.pszLines);
            if (pResponse->rRetrInfo.fHeader && pResponse->rRetrInfo.fBody)
                printf("%d Total\n", pResponse->rRetrInfo.cbSoFar);
        }
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_RETR, 0);
        break;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\rascall.h ===
// --------------------------------------------------------------------------------
// Rascall.h
// --------------------------------------------------------------------------------
#ifndef __RASCALL_H
#define __RASCALL_H

#include "imnxport.h"

HRESULT HrCreateRASTransport(IRASTransport **ppRAS);

// --------------------------------------------------------------------------------
// CRASCallback Implementation
// --------------------------------------------------------------------------------
class CRASCallback : public IRASCallback
{
private:
    ULONG m_cRef;

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CRASCallback(void);
    ~CRASCallback(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP OnReconnect(
            LPSTR                   pszCurrentConnectoid,
            LPSTR                   pszNewConnectoid,
		    IRASTransport          *pTransport);

    STDMETHODIMP OnLogonPrompt(
            LPIXPRASLOGON           pRasLogon,
            IRASTransport          *pTransport);

    STDMETHODIMP OnRasDialStatus(
            RASCONNSTATE            rasconnstate, 
            DWORD                   dwError, 
            IRASTransport          *pTransport);

    STDMETHODIMP OnDisconnect(
            LPSTR                   pszCurrentConnectoid,
            boolean                 fConnectionOwner,
		    IRASTransport          *pTransport);
};

#endif // __RASCALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\pop3call.h ===
// --------------------------------------------------------------------------------
// Pop3call.h
// --------------------------------------------------------------------------------
#ifndef __POP3CALL_H
#define __POP3CALL_H

#include "imnxport.h"

HRESULT HrCreatePOP3Transport(IPOP3Transport **ppPOP3);

// --------------------------------------------------------------------------------
// CPOP3Callback Implementation
// --------------------------------------------------------------------------------
class CPOP3Callback : public IPOP3Callback
{
private:
    ULONG m_cRef;

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CPOP3Callback(void);
    ~CPOP3Callback(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // IPOP3Callback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPPOP3RESPONSE              pResponse);
};

#endif // __POP3CALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\rascall.cpp ===
// --------------------------------------------------------------------------------
// Rascall.cpp
// --------------------------------------------------------------------------------
#include "pch.h"
#include "iconsole.h"
#include "rascall.h"

// --------------------------------------------------------------------------------
// HrCreateRASTransport
// --------------------------------------------------------------------------------
HRESULT HrCreateRASTransport(IRASTransport **ppRAS)
{
    // Locals
    HRESULT             hr;
    CRASCallback      *pCallback=NULL;

    // Create callback object
    pCallback = new CRASCallback();
    if (NULL == pCallback)
    {
        printf("Memory allocation failure\n");
        return E_OUTOFMEMORY;
    }

    // Load SMTP Transport
    hr = CoCreateInstance(CLSID_IRASTransport, NULL, CLSCTX_INPROC_SERVER, IID_IRASTransport, (LPVOID *)ppRAS);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_IRASTransport\n");
        return E_FAIL;
    }

    // InitNew
    hr = (*ppRAS)->InitNew(pCallback);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_IRASTransport\n");
        return E_FAIL;
    }

    // Done
    pCallback->Release();
    return S_OK;
}

// --------------------------------------------------------------------------------
// CRASCallback::CRASCallback
// --------------------------------------------------------------------------------
CRASCallback::CRASCallback(void)
{
    m_cRef = 1;
}

// --------------------------------------------------------------------------------
// CRASCallback::~CRASCallback
// --------------------------------------------------------------------------------
CRASCallback::~CRASCallback(void)
{
}

// --------------------------------------------------------------------------------
// CRASCallback::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CRASCallback::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // IID_IRASCallback
    else if (IID_IRASCallback == riid)
        *ppv = (IRASCallback *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = E_NOINTERFACE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASCallback::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRASCallback::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CRASCallback::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRASCallback::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

STDMETHODIMP CRASCallback::OnReconnect(
        LPSTR                   pszCurrentConnectoid,
        LPSTR                   pszNewConnectoid,
		IRASTransport          *pTransport)
{
    printf("CRASCallback::OnReconnect - %s --> %s\n", pszCurrentConnectoid, pszNewConnectoid);
    return S_OK;
}

STDMETHODIMP CRASCallback::OnLogonPrompt(
        LPIXPRASLOGON           pRasLogon,
        IRASTransport          *pTransport)
{
    printf("CRASCallback::OnLogonPrompt\n");
    return S_OK;
}

STDMETHODIMP CRASCallback::OnRasDialStatus(
        RASCONNSTATE            rasconnstate, 
        DWORD                   dwError, 
        IRASTransport          *pTransport)
{
    printf("CRASCallback::OnRasDialStatus - State: %d, dwError: %d\n", rasconnstate, dwError);
    if (dwError || (rasconnstate == RASCS_Connected || rasconnstate == RASCS_Disconnected))
    {
        if (dwError)
        {
            CHAR szError[1024];
            DWORD dwResult;

            g_pRAS->GetRasErrorString(dwError, szError, 1024, &dwResult);
            if (dwResult == 0)
                printf("Ras Error: %s\n", szError);
        }
        PostThreadMessage(GetCurrentThreadId(), g_msgRAS, RAS_CONNECT, 0);
    }
    return S_OK;
}

STDMETHODIMP CRASCallback::OnDisconnect(
        LPSTR                   pszCurrentConnectoid,
        boolean                 fConnectionOwner,
		IRASTransport          *pTransport)
{
    printf("CRASCallback::OnDisconnect - %s, Connection Owner: %d\n", pszCurrentConnectoid, fConnectionOwner);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\smtpcall.h ===
// --------------------------------------------------------------------------------
// Smtpcall.h
// --------------------------------------------------------------------------------
#ifndef __SMTPCALL_H
#define __SMTPCALL_H
#include "imnxport.h"

HRESULT HrCreateSMTPTransport(ISMTPTransport **ppSMTP);

// --------------------------------------------------------------------------------
// CSMTPCallback Implementation
// --------------------------------------------------------------------------------
class CSMTPCallback : public ISMTPCallback
{
private:
    ULONG m_cRef;

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CSMTPCallback(void);
    ~CSMTPCallback(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // ISMTPCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPSMTPRESPONSE              pResponse);
};

#endif // __SMTPCALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\smtpcall.cpp ===
// --------------------------------------------------------------------------------
// Smtpcall.cpp
// --------------------------------------------------------------------------------
#include "pch.h"
#include "iconsole.h"
#include "smtpcall.h"

// --------------------------------------------------------------------------------
// HrCreateSMTPTransport
// --------------------------------------------------------------------------------
HRESULT HrCreateSMTPTransport(ISMTPTransport **ppSMTP)
{
    // Locals
    HRESULT             hr;
    CSMTPCallback      *pCallback=NULL;

    // Create callback object
    pCallback = new CSMTPCallback();
    if (NULL == pCallback)
    {
        printf("Memory allocation failure\n");
        return E_OUTOFMEMORY;
    }

    // Load SMTP Transport
    hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport, (LPVOID *)ppSMTP);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_ISMTPTransport\n");
        return E_FAIL;
    }

    // InitNew
    hr = (*ppSMTP)->InitNew(NULL, pCallback);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_ISMTPTransport\n");
        return E_FAIL;
    }

    // Done
    pCallback->Release();
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::CSMTPCallback
// --------------------------------------------------------------------------------
CSMTPCallback::CSMTPCallback(void)
{
    m_cRef = 1;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::~CSMTPCallback
// --------------------------------------------------------------------------------
CSMTPCallback::~CSMTPCallback(void)
{
}

// --------------------------------------------------------------------------------
// CSMTPCallback::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // IID_ISMTPCallback
    else if (IID_ISMTPCallback == riid)
        *ppv = (ISMTPCallback *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = E_NOINTERFACE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPCallback::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPCallback::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnLogonPrompt(
        LPINETSERVER            pInetServer,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CSMTPCallback::OnPrompt(
        HRESULT                 hrError, 
        LPCTSTR                 pszText, 
        LPCTSTR                 pszCaption, 
        UINT                    uType,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnError(
        IXPSTATUS               ixpstatus,
        LPIXPRESULT             pIxpResult,
        IInternetTransport     *pTransport)
{
    printf("CSMTPCallback::OnError - Status: %d, hrResult: %08x\n", ixpstatus, pIxpResult->hrResult);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnStatus(
        IXPSTATUS               ixpstatus,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;

    pTransport->GetServerInfo(&rServer);

    switch(ixpstatus)
    {
    case IXP_FINDINGHOST:
        printf("Finding '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTING:
        printf("Connecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_SECURING:
        printf("Establishing secure connection to '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTED:
        printf("Connected '%s'\n", rServer.szServerName);
        break;
    case IXP_AUTHORIZING:
        printf("Authorizing '%s'...\n", rServer.szServerName);
        break;
    case IXP_AUTHRETRY:
        printf("Retrying Logon '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTING:
        printf("Disconnecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTED:
        printf("Disconnected '%s'\n", rServer.szServerName);
        PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, IXP_DISCONNECTED, 0);
        PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_QUIT, 0);
        break;
    }
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnProgress(
        DWORD                   dwIncrement,
        DWORD                   dwCurrent,
        DWORD                   dwMaximum,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnCommand(
        CMDTYPE                 cmdtype,                                            
        LPSTR                   pszLine,
        HRESULT                 hrResponse,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    if (CMD_SEND == cmdtype)
    {
        printf("%s[TX]: %s", rServer.szServerName, pszLine);
    }
    else if (CMD_RESP == cmdtype)
        printf("%s[RX]: %s - %08x\n", rServer.szServerName, pszLine, hrResponse);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnTimeout(
        DWORD                  *pdwTimeout,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    printf("Timeout '%s' !!!\n", rServer.szServerName);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnResponse(
        LPSMTPRESPONSE              pResponse)
{
    switch(pResponse->command)
    {
    case SMTP_NONE:
        break;

    case SMTP_BANNER:
        break;

    case SMTP_CONNECTED:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_CONNECTED, 0);
        break;

    case SMTP_SEND_MESSAGE:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_SEND_MESSAGE, 0);
        break;

    case SMTP_EHLO:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_EHLO, 0);
        break;

    case SMTP_HELO:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_HELO, 0);
        break;

    case SMTP_MAIL:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_MAIL, 0);
        break;

    case SMTP_RCPT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_RCPT, 0);
        break;

    case SMTP_RSET:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_RSET, 0);
        break;

    case SMTP_QUIT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_QUIT, 0);
        break;

    case SMTP_DATA:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_DATA, 0);
        break;

    case SMTP_DOT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_DOT, 0);
        break;

    case SMTP_SEND_STREAM:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_SEND_STREAM, 0);
        break;

    case SMTP_CUSTOM:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_CUSTOM, 0);
        break;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\moletest\moletest.cpp ===
// --------------------------------------------------------------------------------
// Moletest.cpp
// --------------------------------------------------------------------------------
#define DEFINE_STRCONST
#define INITGUID
#include <windows.h>
#include <windowsx.h>
#include <richedit.h>
#include <commctrl.h>
#include <initguid.h>
#include <ole2.h>
#include <stdio.h>
#include <conio.h>
#include "resource.h"
#include <d:\foobar\inc\Mimeole.h>

IMimeOleMalloc *g_pMalloc=NULL;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
void MoleTestHeader(IStorage *pStorage);
void MoleTestBody(IStorage *pStorage);
INT_PTR CALLBACK MimeOLETest(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RichStreamShow(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// --------------------------------------------------------------------------------
// Simple (UNSAFE) conversion to UNICODE
// --------------------------------------------------------------------------------
OLECHAR* ConvertToUnicode(char *szA)
{
  static OLECHAR achW[1024]; 

  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, 1024);  
  return achW; 
}

// --------------------------------------------------------------------------------
// Simple (UNSAFE) conversion to ANSI
// --------------------------------------------------------------------------------
char* ConvertToAnsi(OLECHAR FAR* szW)
{
  static char achA[1024]; 
  
  WideCharToMultiByte(CP_ACP, 0, szW, -1, achA, 1024, NULL, NULL);  
  return achA; 
} 

// --------------------------------------------------------------------------------
// Moletest entry point
// --------------------------------------------------------------------------------
void main(int argc, char *argv[])
{
    // Locals
    CHAR        szDocFile[MAX_PATH];
    IStorage   *pStorage=NULL;
    HRESULT     hr;
    HINSTANCE   hRichEdit=NULL;


    // Must have a path to a .stg file...
    if (argc != 2)
    {
        printf("Please enter the path and file name that mbxtodoc.exe generated: ");
        scanf("%s", szDocFile);
        fflush(stdin);
    }

    // Otherwise, copy parmaeter
    else
        lstrcpyn(szDocFile, argv[1], sizeof(szDocFile));

    hRichEdit = LoadLibrary("RICHED32.DLL");

    // Init OLE
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        printf("Error - Unable to initialize OLE.\n");
        exit(1);
    }

    // Get IMimeOleMalloc
    hr = CoCreateInstance(CLSID_MIMEOLE, NULL, CLSCTX_INPROC_SERVER, IID_IMimeOleMalloc, (LPVOID *)&g_pMalloc);
    if (FAILED(hr))
    {
        printf("Error - CoCreateInstance of CLSID_MIMEOLE\\IID_IMimeOleMalloc failed.\n");
        goto exit;
    }

    // Status
    printf("Opening source docfile: %s\n", szDocFile);

    // Get file
/*
    hr = StgOpenStorage(ConvertToUnicode(szDocFile), NULL, STGM_TRANSACTED | STGM_NOSCRATCH | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, NULL, 0, &pStorage);
    if (FAILED(hr))
    {
        printf("StgOpenStorage failed\n");
        goto exit;
    }
*/

    DialogBoxParam(NULL, MAKEINTRESOURCE(IDD_TEST), NULL, MimeOLETest, (LPARAM)szDocFile);
    //MoleTestBody(pStorage);

exit:
    // Cleanup
    if (hRichEdit)
        FreeLibrary(hRichEdit);
    if (pStorage)
        pStorage->Release();
    if (g_pMalloc)
        g_pMalloc->Release();

    // Un-init OLE
    CoUninitialize();

    // Done
    return;
}

// --------------------------------------------------------------------------------
// This is the IMimeHeader torture test
// --------------------------------------------------------------------------------
void MoleTestHeader(IStorage *pStorage)
{
    // Locals
    IMimeHeader     *pHeader=NULL;
    IEnumSTATSTG    *pEnum=NULL;
    IStream         *pStream=NULL;
    STATSTG          rElement;
    ULONG            i, c;
    HRESULT          hr=S_OK;
    CHAR             szData[50];
    IStream         *pSave=NULL, *pstmHeader=NULL;
    IMimeEnumHeaderLines *pEnumLines=NULL;
    LPSTR            pszData;

    // Status
    printf("Starting IMimeHeader torture test...\n");

    // Create a header object...
    hr = CoCreateInstance(CLSID_MIMEOLE, NULL, CLSCTX_INPROC_SERVER, IID_IMimeHeader, (LPVOID *)&pHeader);
    if (FAILED(hr))
    {
        printf("Error - CoCreateInstance of CLSID_Mime\\IID_IMimeHeader failed.\n");
        goto exit;
    }

    // Get storage enumerator
    hr = pStorage->EnumElements(0, NULL, 0, &pEnum);
    if (FAILED(hr))
    {
        printf("Error - IStorage::EnumElements failed.\n");
        goto exit;
    }

    // Enumerate
    for(i=0;;i++)
    {
        // Status
        //printf("Message: %d\n", i);

        // Get element
        hr = pEnum->Next(1, &rElement, &c);
        if (FAILED(hr))
            break;
        if (c == 0)
            break;

        // No Name ?
        if (NULL == rElement.pwcsName)
            continue;

        // Open the stream...
        hr = pStorage->OpenStream(rElement.pwcsName, NULL, STGM_SHARE_EXCLUSIVE | STGM_READWRITE, 0, &pStream);
        if (FAILED(hr))
        {
            printf("IStorage::OpenStream failed: (iMsg = %d)\n", i);
            goto nextmsg;
        }

        // Load the header...
        hr = pHeader->Load(pStream);
        if (FAILED(hr))
        {
            printf("IMimeHeader::Load failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

#if 0
        // Test Enumerator
        hr = pHeader->EnumHeaderLines(NULL, &pEnumLines);
        if (FAILED(hr))
            printf("IMimeHeader::EnumLines failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else
        {
            ULONG           cLines;
            //ULONG           x;
            HEADERLINE      rgLine[2];

            while(SUCCEEDED(pEnumLines->Next(2, rgLine, &cLines)) && cLines)
            {
                //for (x=0; x<cLines; x++)
                //    printf("%s: %s\n", prgLine[x].pszHeader, prgLine[x].pszLine);

                g_pMalloc->FreeHeaderLineArray(cLines, rgLine, FALSE);
            }

            pEnumLines->Release();
            pEnumLines = NULL;
        }

        // Test Enumerator
        hr = pHeader->EnumHeaderLines("Received", &pEnumLines);
        if (FAILED(hr))
            printf("IMimeHeader::EnumLines failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else
        {
            ULONG           cLines;
            //ULONG           x;
            HEADERLINE      rgLine[2];

            while(SUCCEEDED(pEnumLines->Next(2, rgLine, &cLines)) && cLines)
            {
                //for (x=0; x<cLines; x++);
                //    printf("%s: %s\n", prgLine[x].pszHeader, prgLine[x].pszLine);

                g_pMalloc->FreeHeaderLineArray(cLines, rgLine, FALSE);
            }

            pEnumLines->Release();
            pEnumLines = NULL;
        }

        // Test IMimeHeader Interface
        pHeader->IsContentType(NULL, NULL);
        pHeader->IsContentType(STR_CNT_MESSAGE, NULL);
        pHeader->IsContentType(NULL, STR_SUB_PLAIN);

        // ****************************************************************************************
        // Get a few items...
        if (i == 0)
            pHeader->GetInetProp(NULL, NULL);
        pszData = NULL;
        hr = pHeader->GetInetProp("To", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::GetInetProp(\"To\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        // Get a few items...
        pszData = NULL;
        hr = pHeader->GetInetProp("Subject", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::GetInetProp(\"Subject\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        // Get a few items... (multi-line header)
        pszData = NULL;
        hr = pHeader->GetInetProp("Received", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::GetInetProp(\"Received\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        // Get a few items... (multi-line header)
        pszData = NULL;
        hr = pHeader->GetInetProp("Content-Type", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::GetInetProp(\"Content-Type\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        // ****************************************************************************************
        // Prepare a line to set in a bunch of items...
        wsprintf(szData, "<Message@%s>", ConvertToAnsi(rElement.pwcsName));

        // Set a few items...
        if (i == 0)
            pHeader->SetInetProp(NULL, NULL);
        hr = pHeader->SetInetProp("To", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(\"To\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // Get a few items...
        hr = pHeader->SetInetProp("Subject", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(\"Subject\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // Get a few items... (multi-line header)
        hr = pHeader->SetInetProp("Received", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(\"Received\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // Get a few items... (multi-line header)
        hr = pHeader->SetInetProp("Content-Type", "multipart\\related");
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(\"Content-Type\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // ****************************************************************************************
        // Delete a few items
        if (i == 0)
            pHeader->DelInetProp(NULL);
        hr = pHeader->DelInetProp("MIME-Version");
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::DelInetProp(\"MIME-Version\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // Delete a few items
        hr = pHeader->DelInetProp("Content-Disposition");
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::DelInetProp(\"Content-Disposition\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // ****************************************************************************************
        // Get some parameters
        if (i == 0)
        {
            pHeader->SetInetProp(NULL, NULL);
            pHeader->GetInetProp("Content-Type", NULL);
            pHeader->GetInetProp("par:content-type:name", NULL);
        }
        pszData = NULL;
        pHeader->GetInetProp("par:content-type:name", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND && hr != MIME_E_NO_DATA)
            printf("IMimeHeader::GetInetProp(...,\"name\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        pszData = NULL;
        hr = pHeader->GetInetProp("par:Content-Disposition:filename", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND && hr != MIME_E_NO_DATA)
            printf("IMimeHeader::GetInetProp(...,\"filename\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        pszData = NULL;
        hr = pHeader->GetInetProp("par:Content-Type:charset", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND && hr != MIME_E_NO_DATA)
            printf("IMimeHeader::GetInetProp(...,\"charset\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        pszData = NULL;
        hr = pHeader->GetInetProp("par:Content-Type:boundary", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND && hr != MIME_E_NO_DATA)
            printf("IMimeHeader::GetInetProp(...,\"boundary\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        pszData = NULL;
        hr = pHeader->GetInetProp("par:Content-Type:part", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND && hr != MIME_E_NO_DATA)
            printf("IMimeHeader::GetInetProp(...,\"part\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        // ****************************************************************************************
        // Set some parameters
        if (i == 0)
        {
            pHeader->SetInetProp(NULL, NULL);
            pHeader->SetInetProp("Content-Type", NULL);
            pHeader->SetInetProp("par:Content-Type:name", NULL);
        }
        hr = pHeader->SetInetProp("par:Content-Type:name", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(...,\"name\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->SetInetProp("par:Content-Disposition:filename", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(...,\"filename\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->SetInetProp("par:Content-Type:charset", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(...,\"charset\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->SetInetProp("par:content-type:boundary", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(...,\"boundary\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->SetInetProp("par:content-type:part", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(...,\"boundary\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->DelInetProp("par:content-type:part");
        if (FAILED(hr))
            printf("IMimeHeader::DelInetProp(...,\"boundary\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // ****************************************************************************************
        // Try to save it back
        if (i == 0)
            pHeader->GetSizeMax(NULL);
        //hr = pHeader->GetSizeMax(&uli);
        //if (FAILED(hr))
        //    printf("IMimeHeader::GetSizeMax() failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->IsDirty();
        if (FAILED(hr))
            printf("IMimeHeader::IsDirty() failed (HR = %08X): (iMsg = %d)\n", hr, i);

        CreateStreamOnHGlobal(NULL, TRUE, &pstmHeader);
        hr = pHeader->Save(pstmHeader, TRUE);
        if (FAILED(hr))
            printf("IMimeHeader::Save() failed (HR = %08X): (iMsg = %d)\n", hr, i);
        pstmHeader->Release();
#endif

nextmsg:
        // Cleanup
        pStream->Release();
        pStream = NULL;

        // Free the name
        CoTaskMemFree(rElement.pwcsName);
    }

exit:
    // Cleanup
    if (pEnum)
        pEnum->Release();
    if (pHeader)
        pHeader->Release();
    if (pStream)
        pStream->Release();
    if (pEnumLines)
        pEnumLines->Release();

    // Done
    return;
}



// --------------------------------------------------------------------------------
// This is the IMimeBody torture test
// --------------------------------------------------------------------------------
void MoleTestBody(IStorage *pStorage)
{
    // Locals
    IMimeMessage            *pMessage=NULL;
    IEnumSTATSTG            *pEnum=NULL;
    IStream                 *pStream=NULL,
                            *pstmTree=NULL;
    STATSTG                  rElement;
    ULONG                    i, c, cbRead, x;
    HRESULT                  hr=S_OK;
    LARGE_INTEGER            liOrigin = {0,0};
    HBODY                    hBody;
    IMimeBody               *pBody=NULL;
    IStream                 *pBodyStream=NULL;
    BYTE                     rgbBuffer[1024];
    FINDBODY                 rFindBody;
    FILETIME                 ft;
    IMimeMessageParts       *pParts=NULL;
    IStream                 *pSave=NULL;
    IDataObject             *pDataObject=NULL;
    IMimeAddressTable       *pAddressTable=NULL;
    LPSTR                    pszData=NULL;
    IMimeMessage            *pCombine=NULL;
    IMimeBody               *pRootBody=NULL;

    // Status
    printf("Starting IMimeBody torture test...\n");

    // Create a header object...
    hr = CoCreateInstance(CLSID_MIMEOLE, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMessage);
    if (FAILED(hr))
    {
        printf("Error - CoCreateInstance of CLSID_Mime\\IID_IMimeBody failed.\n");
        goto exit;
    }

    // Get storage enumerator
    hr = pStorage->EnumElements(0, NULL, 0, &pEnum);
    if (FAILED(hr))
    {
        printf("Error - IStorage::EnumElements failed.\n");
        goto exit;
    }

    // Enumerate
    for(i=0;;i++)
    {
        // Status
        // printf("Message: %d\n", i);

        // Get element
        hr = pEnum->Next(1, &rElement, &c);
        if (FAILED(hr))
            break;
        if (c == 0)
            break;

        // No Name ?
        if (NULL == rElement.pwcsName)
            continue;

        // Open the stream...
        hr = pStorage->OpenStream(rElement.pwcsName, NULL, STGM_SHARE_EXCLUSIVE | STGM_READWRITE, 0, &pStream);
        if (FAILED(hr))
        {
            printf("IStorage::OpenStream failed: (iMsg = %d)\n", i);
            goto nextmsg;
        }

        // Init New the message
        hr = pMessage->InitNew();
        if (FAILED(hr))
        {
            printf("pMessage->InitNew failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Load the header...
        hr = pMessage->BindToMessage(pStream);
        if (FAILED(hr))
        {
            printf("pMessage->BindMessage failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

#if 0
	    hr = pMessage->SplitMessage(64 * 1024, &pParts);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::SplitMessage failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        else
        {
            hr = pParts->CombineParts(&pCombine);
            if (FAILED(hr))
                MessageBox(NULL, "IMimeMessageParts::CombineParts failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
            else
                pCombine->Release();
            pParts->Release();
        }

        // Test Addresss List
        hr = pMessage->GetAddressList(&pAddressTable);
        if (FAILED(hr))
            printf("IMimeHeader::GetAddressList failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else
        {
            IADDRESSLIST rList;

/*
            hr = pAddressTable->GetViewable(IAT_TO, TRUE, &pszData);
            if (FAILED(hr))
                printf("IMimeAddressList::GetViewable failed (HR = %08X): (iMsg = %d)\n", hr, i);
            else
                g_pMalloc->Free(pszData);
*/

            hr = pAddressTable->GetList(IAT_ALL, &rList);
            if (FAILED(hr) && hr != MIME_E_NO_DATA)
                printf("IMimeAddressList::GetList failed (HR = %08X): (iMsg = %d)\n", hr, i);
            else if (SUCCEEDED(hr))
            {
//                for (x=0; x<rList.cAddresses; x++)
//                    printf("%30s%30s\n", rList.prgAddress[x].pszName, rList.prgAddress[x].pszEmail);
                g_pMalloc->FreeAddressList(&rList);
//                printf("------------------------------------------------------------------------\n");
            }

            pAddressTable->Release();
        }

        // QI for body tree
        hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *)&pRootBody);
        if (FAILED(hr))
        {
            printf("pMessage->GetRootBody failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        hr = pRootBody->SetInetProp(STR_HDR_CNTTYPE, "text/plain");
        if (FAILED(hr))
            MessageBox(NULL, "pRootBody->SetInetProp failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);

        // Get the time...
        hr = pRootBody->GetSentTime(&ft);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::GetSentTime failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);

        hr = pRootBody->SetSentTime(&ft);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::SetSentTime failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);

        hr =pRootBody->GetReceiveTime(&ft);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::GetReceiveTime failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);

        hr = pMessage->GetTextBody(NULL, NULL, &pSave);
        if (FAILED(hr) && hr != MIME_E_NO_DATA)
            MessageBox(NULL, "IMimeMessage::GetTextBody failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        else if (pSave)
            pSave->Release();

        hr = pMessage->GetTextBody("html", NULL, &pSave);
        if (FAILED(hr) && hr != MIME_E_NO_DATA)
            MessageBox(NULL, "IMimeMessage::GetTextBody failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        else if (pSave)
            pSave->Release();

        CreateStreamOnHGlobal(NULL, TRUE, &pSave);
        hr = pMessage->SaveMessage(pSave, TRUE);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::GetReceiveTime failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        pSave->Release();

        hr = pMessage->QueryInterface(IID_IDataObject, (LPVOID *)&pDataObject);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::QueryInterface failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        else
        {
            OleSetClipboard(pDataObject);
            pDataObject->Release();
        }

        // Get Message Source
        pStream->Release();
        pStream = NULL;
        hr = pMessage->GetMessageSource(&pStream);
        if (FAILED(hr))
        {
            printf("IMimeMessageTree::GetMessageSource failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Create body tree stream
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pstmTree);
        if (FAILED(hr))
        {
            printf("CreateStreamOnHGlobal failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // find first/next loop
        ZeroMemory(&rFindBody, sizeof(rFindBody));
        rFindBody.pszCntType = (LPSTR)STR_CNT_TEXT;
        hr = pMessage->FindFirst(&rFindBody, &hBody);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
        {
            printf("pMessage->FindFirst failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }
        else if (SUCCEEDED(hr))
        {
            while(1)
            {
                // Open the body
                hr = pMessage->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody);
                if (FAILED(hr))
                {
                    printf("pMessage->BindToObject failed (HR = %08X): (iMsg = %d)\n", hr, i);
                    goto nextmsg;
                }

                // Get the body stream...
                if (SUCCEEDED(pBody->GetData(FMT_BINARY, &pBodyStream)))
                {
                    // Seek to end and then begginnging
                    hr = pBodyStream->Seek(liOrigin, STREAM_SEEK_END, NULL);
                    if (FAILED(hr))
                    {
                        printf("pBodyStream->Seek failed (HR = %08X): (iMsg = %d)\n", hr, i);
                        goto nextmsg;
                    }

                    // Seek to end and then begginnging
                    hr = pBodyStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
                    if (FAILED(hr))
                    {
                        printf("pBodyStream->Seek failed (HR = %08X): (iMsg = %d)\n", hr, i);
                        goto nextmsg;
                    }

                    // Lets read data from the stream
                    while(1)
                    {
                        // Read block
                        hr = pBodyStream->Read(rgbBuffer, sizeof(rgbBuffer) - 1, &cbRead);
                        if (FAILED(hr))
                        {
                            printf("pBodyStream->Read failed (HR = %08X): (iMsg = %d)\n", hr, i);
                            goto nextmsg;
                        }

                        // Done
                        if (0 == cbRead)
                            break;

//                        rgbBuffer[cbRead] = '\0';
//                        printf("%s", (LPSTR)rgbBuffer);
                    }
                    pBodyStream->Release();
                    pBodyStream = NULL;
//                    printf("\n======================================================================\n");
//                    _getch();
                }

                // Release
                pBody->Release();
                pBody = NULL;

                // Get Next
                if (FAILED(pMessage->FindNext(&rFindBody, &hBody)))
                    break;
            }
        }

        // Save the Tree
        hr = pMessage->SaveTree(pstmTree);
        if (FAILED(hr))
        {
            printf("pMessage->Save failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }
        
        // Commit the stream
        hr = pstmTree->Commit(STGC_DEFAULT);
        if (FAILED(hr))
        {
            printf("pstmTree->Commit failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Rewind it
        hr = pstmTree->Seek(liOrigin, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
        {
            printf("pstmTree->Seek failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Init the tree
        hr = pMessage->InitNew();
        if (FAILED(hr))
        {
            printf("pMessage->InitNew failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Load the body tree
        hr = pMessage->LoadTree(pstmTree);
        if (FAILED(hr))
        {
            printf("pMessage->Load failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Rewind message stream
        hr = pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
        {
            printf("pStream->Seek failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Rebind
        hr = pMessage->BindMessage(pStream);
        if (FAILED(hr))
        {
            printf("pMessage->BindMessage failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }
#endif

nextmsg:
        // Cleanup
        if (pstmTree)
        {
            pstmTree->Release();
            pstmTree = NULL;
        }
        if (pRootBody)
        {
            pRootBody->Release();
            pRootBody = NULL;
        }
        if (pStream)
        {
            pStream->Release();
            pStream = NULL;
        }
        if (pBody)
        {
            pBody->Release();
            pBody = NULL;
        }
        if (pBodyStream)
        {
            pBodyStream->Release();
            pBodyStream=NULL;
        }

        // Free the name
        CoTaskMemFree(rElement.pwcsName);
    }

exit:
    // Cleanup
    if (pEnum)
        pEnum->Release();
    if (pMessage)
        pMessage->Release();
    if (pstmTree)
        pstmTree->Release();
    if (pStream)
        pStream->Release();

    // Done
    return;
}

void TreeViewInsertBody(HWND hwnd, IMimeMessageTree *pTree, HBODY hBody, HTREEITEM hParent, HTREEITEM hInsertAfter, HTREEITEM *phItem)
{
    // Locals
    IMimeHeader       *pHeader=NULL;
    LPSTR              pszCntType=NULL,
                       pszEncType=NULL,
                       pszFree=NULL,
                       psz=NULL,
                       pszFileName=NULL,
                       pszFName;
    TV_INSERTSTRUCT    tvi;
    HRESULT            hr;
    HTREEITEM          hCurrent, hNew;
    HBODY              hChild;

    // Get Header
    hr = pTree->BindToObject(hBody, IID_IMimeHeader, (LPVOID *)&pHeader);
    if (FAILED(hr))
    {
        MessageBox(GetParent(hwnd), "IMimeMessageTree->BindToObject - IID_IMimeHeader failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Get content type
    hr = pHeader->GetInetProp(STR_HDR_CNTTYPE, &pszCntType);
    if (FAILED(hr))
    {
        MessageBox(GetParent(hwnd), "IMimeHeader->GetContentType failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Get content type
    if (FAILED(pHeader->GetInetProp(STR_HDR_CNTENC, &pszFree)))
        pszEncType = (LPSTR)"Unknown";
    else
        pszEncType = pszFree;

    // Get content type
    if (FAILED(pHeader->GetInetProp(STR_ATT_FILENAME, &pszFileName)))
        pszFName = (LPSTR)"Unknown";
    else
        pszFName = pszFileName;

    // Build content-type string
    psz = (LPSTR)CoTaskMemAlloc(lstrlen(pszCntType) + lstrlen(pszEncType) + lstrlen(pszFName) + 15);

    // Insert
    ZeroMemory(&tvi, sizeof(TV_INSERTSTRUCT));
    tvi.hParent = hParent;
    tvi.hInsertAfter = hInsertAfter;
    tvi.item.mask = TVIF_PARAM | TVIF_TEXT;
    tvi.item.lParam = (LPARAM)hBody;
    tvi.item.cchTextMax = wsprintf(psz, "%s - %s (%s)", pszCntType, pszEncType, pszFName);
    tvi.item.pszText = psz;

    // Insert it
    *phItem = hCurrent = TreeView_InsertItem(hwnd, &tvi);

    // Multipart...
    if (pHeader->IsContentType(STR_CNT_MULTIPART, NULL) == S_OK)
    {
        // Get first child...
        hr = pTree->GetBody(BODY_FIRST_CHILD, hBody, &hChild);
        if (FAILED(hr))
        {
            MessageBox(GetParent(hwnd), "IMimeMessageTree->GetBody - BODY_FIRST_CHILD failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
            goto exit;
        }

        // Loop
        while(hChild)
        {
            // Insert it
            TreeViewInsertBody(hwnd, pTree, hChild, hCurrent, TVI_LAST, &hNew);

            // Next
            hr = pTree->GetBody(BODY_NEXT, hChild, &hChild);
            if (FAILED(hr))
                break;
        }
    }

    TreeView_Expand(hwnd, *phItem, TVE_EXPAND);

exit:
    // Cleanup
    if (pHeader)
        pHeader->Release();
    if (pszCntType)
        g_pMalloc->Free(pszCntType);
    if (pszFileName)
        g_pMalloc->Free(pszFileName);
    if (pszFree)
        g_pMalloc->Free(pszFree);
    if (psz)
        CoTaskMemFree(psz);

    // Done
    return;
}

void TreeViewMessage(HWND hwnd, IMimeMessage *pMessage)
{
    // Locals
    IMimeMessageTree  *pTree=NULL;
    HBODY              hBody;
    HRESULT            hr=S_OK; 
    HTREEITEM          hRoot;

    // Delete All
    TreeView_DeleteAllItems(hwnd);

    // QI for body tree
    hr = pMessage->QueryInterface(IID_IMimeMessageTree, (LPVOID *)&pTree);
    if (FAILED(hr))
    {
        MessageBox(GetParent(hwnd), "IMimeMessage->QueryInterface - IID_IMimeMessageTree failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Get the root body object
    hr = pTree->GetBody(BODY_ROOT, NULL, &hBody);
    if (FAILED(hr))
    {
        MessageBox(GetParent(hwnd), "IMimeMessageTree->GetBody - BODY_ROOT failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Insert Body
    TreeViewInsertBody(hwnd, pTree, hBody, TVI_ROOT, TVI_FIRST, &hRoot);

    // Expand all
    TreeView_SelectItem(GetDlgItem(hwnd, IDC_LIST), hRoot);

exit:
    // Cleanup
    if (pTree)
        pTree->Release();

    // Done
    return;
}

DWORD CALLBACK EditStreamInCallback(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb)
{
    LPSTREAM pstm=(LPSTREAM)dwCookie;

    if(pstm)
        pstm->Read(pbBuff, cb, (ULONG *)pcb);
    return NOERROR;
}


HRESULT HrRicheditStreamIn(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags)
{
    EDITSTREAM  es;

    if(!pstm)
        return E_INVALIDARG;

    if(!IsWindow(hwndRE))
        return E_INVALIDARG;
    es.dwCookie = (DWORD)pstm;
    es.pfnCallback=(EDITSTREAMCALLBACK)EditStreamInCallback;
    SendMessage(hwndRE, EM_STREAMIN, uSelFlags, (LONG)&es);
    return NOERROR;
}

BOOL FOpenStorage(HWND hwnd, LPSTR pszFile, IStorage **ppStorage, IEnumSTATSTG **ppEnum)
{
    // Locals
    HRESULT hr;

    // Get file
    hr = StgOpenStorage(ConvertToUnicode(pszFile), NULL, STGM_TRANSACTED | STGM_NOSCRATCH | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, NULL, 0, ppStorage);
    if (FAILED(hr))
    {
        MessageBox(hwnd, "StgOpenStorage failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }

    // Get First element
    hr = (*ppStorage)->EnumElements(0, NULL, 0, ppEnum);
    if (FAILED(hr))
    {
        MessageBox(hwnd, "IStorage::EnumElements failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }

    // Done
    return TRUE;
}

BOOL FOpenMessage(HWND hwnd, IMimeMessage *pMessage, IStorage *pStorage)
{
    HRESULT hr;
    BOOL fResult=FALSE;
    LARGE_INTEGER liOrigin = {0,0};
    CHAR szName[255];
    LPSTREAM pStream=NULL;
    LV_ITEM lvi;
    LPHBODY prgAttach=NULL;
    ULONG cAttach;

    // Get selected string
    ULONG i = ListView_GetNextItem(GetDlgItem(hwnd, IDC_LIST), -1, LVNI_SELECTED);
    if (-1 == i)
        return FALSE;

    // Get the name
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_TEXT;
    lvi.iItem = i;
    lvi.pszText = szName;
    lvi.cchTextMax = sizeof(szName);
    ListView_GetItem(GetDlgItem(hwnd, IDC_LIST), &lvi);

    // OpenStream
    hr = pStorage->OpenStream(ConvertToUnicode(szName), NULL, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &pStream);
    if (FAILED(hr))
    {
        MessageBox(hwnd, "IStorage::OpenStream failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Show Source
    pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    HrRicheditStreamIn(GetDlgItem(hwnd, IDE_EDIT), pStream, SF_TEXT);

    // Load the message
    pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    pMessage->InitNew();
    hr = pMessage->BindToMessage(pStream);
    if (FAILED(hr))
    {
        MessageBox(hwnd, "IMimeMessage::Load failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Save it back out
#if 0
    pMessage->SetInetProp(HBODY_ROOT, STR_HDR_SUBJECT, "This is a test...");
    pMessage->GetAttached(&cAttach, &prgAttach);
    for (i=0; i<cAttach; i++)
        pMessage->DeleteBody(prgAttach[i]);
    if (prgAttach)
        g_pMalloc->Free(prgAttach);
    pMessage->Commit();
#endif

    // View the message
    TreeViewMessage(GetDlgItem(hwnd, IDC_TREE), pMessage);

    // Success
    fResult = TRUE;

exit:
    // Cleanup
    if (pStream)
        pStream->Release();

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// MimeOLETest
// --------------------------------------------------------------------------------
INT_PTR CALLBACK MimeOLETest(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    static CHAR          s_szFile[MAX_PATH];
    static IMimeMessage *s_pMessage=NULL;
    static IStorage     *s_pStorage=NULL;
    IMimeBody           *pBody;
    IStream             *pStream;
    HRESULT              hr;
    IEnumSTATSTG        *pEnum=NULL;
    TV_ITEM              tvi;
    ULONG                c;
    STATSTG              rElement;
    HTREEITEM            hItem;
    LV_COLUMN            lvm;
    LV_ITEM              lvi;
    HWND                 hwndC;

    // Handle the message
    switch(uMsg)
    {
    // Initialize
    case WM_INITDIALOG:
        // Create a header object...
        hr = CoCreateInstance(CLSID_MIMEOLE, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&s_pMessage);
        if (FAILED(hr))
        {
            MessageBox(hwnd, "CoCreateInstance - IID_IMimeMessage failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
            return FALSE;
        }

        //s_pMessage->TestMe();

        // Formats
        hwndC = GetDlgItem(hwnd, IDCB_FORMAT);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_BINARY");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_BINARY);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_INETCSET");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_INETCSET);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_XMIT64");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_XMIT64);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_XMITUU");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_XMITUU);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_XMITQP");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_XMITQP);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_XMIT7BIT");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_XMIT7BIT);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_XMIT8BIT");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_XMIT8BIT);
        SendMessage(hwndC, CB_SETCURSEL, 0, 0);

        // To
//        ListView_SetExtendedListViewStyle(GetDlgItem(hwnd, IDC_LIST), LVS_EX_FULLROWSELECT);
        ZeroMemory(&lvm, sizeof(LV_COLUMN));
        lvm.mask = LVCF_WIDTH | LVCF_TEXT;
        lvm.pszText = "MessageID";
        lvm.cchTextMax = lstrlen(lvm.pszText);
        lvm.cx = 200;
        ListView_InsertColumn(GetDlgItem(hwnd, IDC_LIST), 0, &lvm);

        if (lParam)
        {
            // Copy File Name
            lstrcpyn(s_szFile, (LPSTR)lParam, MAX_PATH);

            // Set file name
            SetDlgItemText(hwnd, IDE_STORAGE, s_szFile);

            // Get file
            hr = StgOpenStorage(ConvertToUnicode(s_szFile), NULL, STGM_TRANSACTED | STGM_NOSCRATCH | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, NULL, 0, &s_pStorage);
            if (FAILED(hr))
            {
                MessageBox(hwnd, "StgOpenStorage failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
                return FALSE;
            }

#if 0
            //MoleTestHeader(s_pStorage);
            MoleTestBody(s_pStorage);
            s_pMessage->Release();
            s_pStorage->Release();
            exit(1);
#endif

            // Get First element
            hr = s_pStorage->EnumElements(0, NULL, 0, &pEnum);
            if (FAILED(hr))
            {
                MessageBox(hwnd, "IStorage::EnumElements failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
                return FALSE;
            }

            // Enumerate
            ZeroMemory(&lvi, sizeof(lvi));
            lvi.mask = LVIF_TEXT;
            lvi.iItem = 0;
            while(SUCCEEDED(pEnum->Next(1, &rElement, &c)) && c)
            {
                lvi.pszText = ConvertToAnsi(rElement.pwcsName);
                lvi.cchTextMax = lstrlen(lvi.pszText);
                ListView_InsertItem(GetDlgItem(hwnd, IDC_LIST), &lvi);
                CoTaskMemFree(rElement.pwcsName);
                lvi.iItem++;
            }

            // Select first item
            ListView_SetItemState(GetDlgItem(hwnd, IDC_LIST), 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);

            // Release enum
            pEnum->Release();
        }

        // Done
        return FALSE;

    case WM_NOTIFY:
        switch(wParam)
        {
        case IDC_LIST:
            {
                NM_LISTVIEW *pnmv;
                pnmv = (NM_LISTVIEW *)lParam;  

                if (pnmv->uChanged & LVIF_STATE)
                {
                    if (pnmv->uNewState & LVIS_SELECTED && pnmv->uNewState & LVIS_FOCUSED)
                        FOpenMessage(hwnd, s_pMessage, s_pStorage);
                }
            }
            return 1;
        }
        break;

    // Handle Command
    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDB_OPEN:
            hItem = TreeView_GetSelection(GetDlgItem(hwnd, IDC_TREE));
            if (hItem)
            {
                ZeroMemory(&tvi, sizeof(TV_ITEM));
                tvi.mask = TVIF_PARAM | TVIF_HANDLE;
                tvi.hItem = hItem;
                if (TreeView_GetItem(GetDlgItem(hwnd, IDC_TREE), &tvi))
                {
                    hr = s_pMessage->BindToObject((HBODY)tvi.lParam, IID_IMimeBody, (LPVOID *)&pBody);
                    if (FAILED(hr))
                    {
                        MessageBox(hwnd, "IMimeMessageTree::BindToObject failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
                        return FALSE;
                    }

                    c = SendMessage(GetDlgItem(hwnd, IDCB_FORMAT), CB_GETCURSEL, 0, 0);
                    if (CB_ERR == c)
                    {
                        pBody->Release();
                        MessageBox(hwnd, "Select an Object Object Format", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
                        return FALSE;
                    }

                    hr = pBody->GetData((BODYFORMAT)SendMessage(GetDlgItem(hwnd, IDCB_FORMAT), CB_GETITEMDATA, c, 0), &pStream);
                    if (FAILED(hr))
                    {
                        pBody->Release();
                        MessageBox(hwnd, "IMimeMessageTree::BindToObject failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
                        return FALSE;
                    }

                    DialogBoxParam(NULL, MAKEINTRESOURCE(IDD_MESSAGE), NULL, RichStreamShow, (LPARAM)pStream);
                    pBody->Release();
                    pStream->Release();
                }
            }
            return 1;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            return 1;
        }
        break;

    // Close
    case WM_CLOSE:
        EndDialog(hwnd, IDB_NEXT);
        break;

    // Cleanup
    case WM_DESTROY:
        if (s_pMessage)
            s_pMessage->Release();
        if (s_pStorage)
            s_pStorage->Release();
        break;
    }
    return FALSE;
}

// --------------------------------------------------------------------------------
// RichStreamShow
// --------------------------------------------------------------------------------
INT_PTR CALLBACK RichStreamShow(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        HrRicheditStreamIn(GetDlgItem(hwnd, IDE_EDIT), (IStream *)lParam, SF_TEXT);
        return FALSE;
    case WM_CLOSE:
        EndDialog(hwnd, IDCANCEL);
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\moletest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Moletest.rc
//
#define IDD_TEST                        101
#define IDD_MESSAGE                     102
#define IDR_MENU1                       103
#define IDC_TREE                        1000
#define IDB_NEXT                        1001
#define IDB_STOP                        1002
#define IDB_INSERT                      1003
#define IDB_DELETE                      1004
#define IDB_OPEN                        1005
#define IDB_REVERT                      1006
#define IDB_SAVEMSG                     1008
#define IDB_VIEWSOURCE                  1010
#define IDB_PROMOTE                     1011
#define IDB_UNDELETE                    1012
#define IDB_HANDSOFF                    1013
#define IDS_COUNT                       1014
#define IDB_NEWTREE                     1015
#define IDE_EDIT                        1016
#define IDE_STORAGE                     1017
#define IDB_BROWSE                      1018
#define IDE_MESSAGENUM                  1019
#define IDB_GOTOMESSAGE                 1020
#define IDB_TESTHEADERS                 1021
#define IDB_RESET                       1022
#define IDB_TESTMESSAGE                 1023
#define IDC_LIST1                       1030
#define IDC_LIST                        1030
#define IDCB_FORMAT                     1031
#define ID_IMIMEMESSAGETREE_INSERTBODY  40002
#define ID_IMIMEMESSAGETREE_DELETEBODY  40003
#define ID_IMIMEMESSAGETREE_UNDELETEBODY 40004
#define ID_IMIMEMESSAGETREE_SAVEMESSAGE 40005
#define ID_IMIMEMESSAGETREE_SAFE        40006
#define ID_IMIMEMESSAGETREE_PROMOTEBODY 40007
#define ID_IMIMEMESSAGETREE_REVERT      40008
#define ID_IMIMEMESSAGETREE_INITNEW     40009
#define ID_IMIMEMESSAGETREE_HANDSOFFSTORAGE 40010
#define ID_IMIMEMESSAGETREE_SAVETOFILE  40011
#define IDM_SAVEFILE                    40011
#define ID_IMIMEMESSAGETREE_CREATEFROMFILE 40012
#define ID_BATCHTESTING_HEADERS         40013
#define ID_BATCHTESTING_MESSAGES        40014
#define ID_RICHEDIT_SENDTEXT            40015
#define ID_RICHEDIT_REPARSETEXT         40016
#define ID_TESTSTORAGE_OPEN             40017
#define ID_TESTSTORAGE_IMPORTMBX        40018
#define ID_TESTSTORAGE_DOWNLOADPOP3     40019

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40020
#define _APS_NEXT_CONTROL_VALUE         1032
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\oedump\main.cpp ===
#define DEFINE_STRCONST
#define INITGUID
#define INC_OLE2
#include <windows.h>
#include <initguid.h>

#include <mimeole.h>
#undef OE5_BETA2
#include <msoeapi.h>
#include "main.h"
#include "stdio.h"

static TCHAR        c_szHr[]        = "<HR>",
                    c_szPT_Open[]   = "<XMP>",
                    c_szPT_Close[]  = "</XMP>";

HRESULT ExtractFolder(IStoreFolder *pFolder, LPSTR pszFileName);
HRESULT FindFolder(LPSTR pszFolder, IStoreFolder **ppFolder);
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb);
                 
void __cdecl main(int argc, char *argv[])
{
    IStoreFolder        *pFolder;
    HRESULT             hr;
    LPSTR               pszFolder,
                        pszFileName;

    if (argc != 3)
        {
        printf( "Usage: oedump <foldername> <filename>\n"
                " - converts a store folder to HTML and dumps to a file");
        return;        
        }

    pszFolder = argv[1];
    pszFileName = argv[2];

    if (FAILED(OleInitialize(NULL)))
		{
		printf("CoInit failed\n\r");
		return;
        }

    
    hr = FindFolder(pszFolder, &pFolder);
    if (!FAILED(hr)) 
        {
        hr = ExtractFolder(pFolder, pszFileName);
        if (FAILED(hr))
            {
            printf(" - err: could not extract folder to '%s'", pszFileName);

            }
        pFolder->Release();
        }
    else
        {
        printf(" - err: could not find folder '%s'", pszFolder);
        }
    OleUninitialize();
    return; 
}



HRESULT ExtractFolder(IStoreFolder *pFolder, LPSTR pszFileName)
{
    HENUMSTORE      hEnum;
    MESSAGEPROPS    rProps;
    HRESULT         hr;
    IMimeMessage    *pMsg; 
    IStream         *pstmOut;
    IStream         *pstm;

    rProps.cbSize = sizeof(MESSAGEPROPS);
    
    if (pFolder==NULL || pszFileName==NULL)
        return E_INVALIDARG;

    if (!FAILED(hr = MimeOleOpenFileStream(pszFileName, CREATE_ALWAYS, GENERIC_WRITE|GENERIC_READ, &pstmOut)))
        {
        if (pFolder->GetFirstMessage(0, 0, -1, &rProps, &hEnum)==S_OK)
            {
            do 
                {
                if (!FAILED(pFolder->OpenMessage(rProps.dwMessageId, IID_IMimeMessage, (void **)&pMsg)))
                    {
                    if (!FAILED(pMsg->GetTextBody(TXT_HTML, IET_BINARY, &pstm, NULL)))
                        {
                        HrCopyStream(pstm, pstmOut, NULL);
                        pstm->Release();
                        }
                    else
                        {
                        if (!FAILED(pMsg->GetTextBody(TXT_PLAIN, IET_BINARY, &pstm, NULL)))
                            {
                            // emit plaintext tags arounnd a non-html message
                            pstmOut->Write(c_szPT_Open, lstrlen(c_szPT_Open), NULL);
                            HrCopyStream(pstm, pstmOut, NULL);
                            pstmOut->Write(c_szPT_Close, lstrlen(c_szPT_Close), NULL);
                            pstm->Release();
                            }
                        }

                    pstmOut->Write(c_szHr, lstrlen(c_szHr), NULL);
                    // dump
                    pMsg->Release();
                    }
                
                rProps.cbSize = sizeof(MESSAGEPROPS);
                }
                while (pFolder->GetNextMessage(hEnum, 0, &rProps)==S_OK);

            pFolder->GetMessageClose(hEnum);
            }

        pstmOut->Commit(0);
        pstmOut->Release();
        }
    return hr;
}


HRESULT FindFolder(LPSTR pszFolder, IStoreFolder **ppFolder)
{
    HRESULT hr;
    IStoreNamespace     *pStore;
    FOLDERPROPS         fp;
    HENUMSTORE          hEnum;
    STOREFOLDERID       dwFldr=0;

    *ppFolder = NULL;

    fp.cbSize = sizeof(FOLDERPROPS);
    hr = CoCreateInstance(CLSID_StoreNamespace, NULL, CLSCTX_INPROC_SERVER, IID_IStoreNamespace, (LPVOID*)&pStore);
    if (!FAILED(hr))
        {
        hr = pStore->Initialize(NULL, 0);
        if (!FAILED(hr))
            {
            if (!FAILED(pStore->GetFirstSubFolder(FOLDERID_ROOT, &fp, &hEnum)))
                {
                do
                    {
                    if (lstrcmpi(fp.szName, pszFolder)==0)
                        {
                        dwFldr = fp.dwFolderId;
                        break;
                        }
                    fp.cbSize = sizeof(FOLDERPROPS);        // msoeapi changes the size!
                    }
                while (pStore->GetNextSubFolder(hEnum, &fp)==S_OK);

                pStore->GetSubFolderClose(hEnum);
                }
            
            if (dwFldr)
                pStore->OpenFolder(dwFldr, 0, ppFolder);
            }
        pStore->Release();
        }

    return (*ppFolder) ? S_OK : E_FAIL;
}


HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb)
{
    // Locals
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead=0,
                   cbTotal=0;

    do
    {
        if (pstmIn->Read(buf, sizeof(buf), &cbRead))
            goto exit;

        if (cbRead == 0) break;
        
        if (hr = pstmOut->Write(buf, cbRead, NULL))
            goto exit;

        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));

exit:
    if (pcb)
        *pcb = cbTotal;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\oedump\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sendfile.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\oedump\main.h ===
#ifndef _MAIN_H
#define _MAIN_H



#endif //_MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\trawl\main.cpp ===
#define DEFINE_STRCONST
#define INITGUID
#define INC_OLE2
#include <windows.h>
#include <initguid.h>

#include <mimeole.h>
#include "main.h"
#include "trawler.h"
#include "stdio.h"

UINT                g_msgNNTP;
                 
void __cdecl main(int argc, char *argv[])
{
	CTrawler	*pTrawler;

    if (FAILED(OleInitialize(NULL)))
		{
		printf("CoInit failed\n\r");
		return;
        }

	if (HrCreateTrawler(&pTrawler)==S_OK)
		{
		pTrawler->DoTrawl();
		pTrawler->Close();
		pTrawler->Release();
		}

    OleUninitialize();
    return; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\trawl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sendfile.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\trawl\main.h ===
#ifndef _MAIN_H
#define _MAIN_H

extern UINT g_msgSMTP;

#endif //_MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\trawl\trawler.cpp ===
// --------------------------------------------------------------------------------
// Trawler.cpp
// --------------------------------------------------------------------------------
#define INC_OLE2
#include "windows.h"
#include "main.h"
#include "stdio.h"
#include "shlwapi.h"
#include "mimeole.h"
#include "trawler.h"

extern UINT                g_msgNNTP;

void WaitForCompletion(UINT uiMsg, DWORD wparam);


HRESULT HrCreateTrawler(CTrawler **ppTrawler)
{
	CTrawler	*pTrawler;
	HRESULT		hr;

	pTrawler = new CTrawler();
	if (!pTrawler)
		return E_OUTOFMEMORY;

	hr = pTrawler->Init();
	if (FAILED(hr))
		goto error;

	*ppTrawler = pTrawler;
	pTrawler->AddRef();

error:
	pTrawler->Release();
	return hr;

}

// --------------------------------------------------------------------------------
// CTrawler::CTrawler
// --------------------------------------------------------------------------------
CTrawler::CTrawler(void)
    {
    m_cRef = 1;
	m_pNNTP = NULL;
	m_pstm = NULL;
    }

// --------------------------------------------------------------------------------
// CTrawler::~CTrawler
// --------------------------------------------------------------------------------
CTrawler::~CTrawler(void)
    {
    }

// --------------------------------------------------------------------------------
// CTrawler::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    // Locals
    HRESULT hr=S_OK;
    
    // Bad param
    if (ppv == NULL)
        {
        hr = E_INVALIDARG;
        goto exit;
        }
    
    // Init
    *ppv=NULL;
    
    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    
    // IID_INNTPCallback
    else if (IID_INNTPCallback == riid)
        *ppv = (INNTPCallback *)this;
    
    // If not null, addref it and return
    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
        }
    
    // No Interface
    hr = E_NOINTERFACE;
    
exit:
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CTrawler::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTrawler::AddRef(void) 
    {
    return ++m_cRef;
    }

// --------------------------------------------------------------------------------
// CTrawler::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTrawler::Release(void) 
    {
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
    }


// --------------------------------------------------------------------------------
// CTrawler::Init
// --------------------------------------------------------------------------------
HRESULT CTrawler::Init()
{
    HRESULT          hr;

    // Load the NNTP Transport
    hr = CoCreateInstance(CLSID_INNTPTransport, NULL, CLSCTX_INPROC_SERVER, 
                          IID_INNTPTransport, (LPVOID*)&m_pNNTP);
    if (FAILED(hr))
        {
        Error("Failed to CoCreate Transport Object\n");
        return hr;
        }

    // Initialize the transport
    hr = m_pNNTP->InitNew(NULL, this);
    if (FAILED(hr))
        {
        Error("Unable to initialize the transport\n");
        m_pNNTP->Release();
		m_pNNTP=NULL;
        return hr;
        }

    return S_OK;
}

HRESULT CTrawler::Close()
{
	if (m_pNNTP)
		{
		m_pNNTP->Disconnect();
        WaitForCompletion(g_msgNNTP, NS_DISCONNECTED);
        m_pNNTP->Release();
		m_pNNTP=NULL;
		}

	return S_OK;
}

HRESULT CTrawler::DoTrawl()
{
	char					*pszGroup;
	INETSERVER				rServer={0};

	if (FAILED(LoadIniData()))
		{
		return E_FAIL;
		}


	lstrcpy(rServer.szServerName, m_szServer);
	rServer.dwPort = 119;
	rServer.dwTimeout = 30;

	if (FAILED(m_pNNTP->Connect(&rServer, 0, 0)))
		{
		Error("Cannot connect to server\n\r");
		return E_FAIL;
		}

    WaitForCompletion(g_msgNNTP, NS_CONNECT);

	pszGroup=m_szGroups;
        
    while (*pszGroup)
        {
        if (FAILED(SelectGroup(pszGroup)))
            {
            Error("failed to select group\n\r");
			continue;
            }

        DumpGroup(pszGroup);
        pszGroup+=lstrlen(pszGroup)+1;
        }

	return S_OK;
}


HRESULT CTrawler::SelectGroup(LPSTR lpszGroup)
{
    HRESULT     hr;

    hr = m_pNNTP->CommandGROUP(lpszGroup);
    if (FAILED(hr))
       goto error;

    // Wait for completion
    WaitForCompletion(g_msgNNTP, NS_GROUP);

error:
    return hr;

}


HRESULT CTrawler::DumpGroup(LPSTR pszGroup)
{
    ULONG           c;
    ARTICLEID         rArtId;
    ULONG           uMin;
    char            sz[256];

    uMin = GetPrivateProfileInt(pszGroup, "Last", m_uMin, "trawl.ini");

    for(c=uMin; c<m_uMax; c++)
        {
        printf("Downloading article %d...\n\r", c);        
        rArtId.idType = AID_ARTICLENUM;
        rArtId.dwArticleNum = c;
                
        m_pNNTP->CommandARTICLE(&rArtId);
        WaitForCompletion(g_msgNNTP, NS_ARTICLE);
        }

    wsprintf(sz, "%d", m_uMax);
    WritePrivateProfileString(pszGroup, "Last", sz, "trawl.ini");
    printf("** GROUP DOWNLOAD COMPLETE ** (Last=%d)\n\r", m_uMax);
    return S_OK;
}

HRESULT CTrawler::LoadIniData()
{
	char	szDefault[MAX_PATH];

	if (GetPrivateProfileSection("groups", m_szGroups, sizeof(m_szGroups), "trawl.ini")==0)
		{
		Error("No group list found\n\rPlease add a [group] section to trawl.ini\n\r");
		return E_FAIL;
		}


	GetTempPath(MAX_PATH, szDefault);
	GetPrivateProfileString("setup", "path", szDefault, m_szPath, sizeof(m_szPath), "trawl.ini");

    if (m_szPath[lstrlen(m_szPath)-1]!='\\')
        m_szPath[lstrlen(m_szPath)-1]='\\';

	printf("using path=%s\n\r", m_szPath);

	GetPrivateProfileString("setup", "server", "newsvr", m_szServer, sizeof(m_szServer), "trawl.ini");
	printf("using server='%s'\n\r", m_szServer);

	
	if (GetPrivateProfileSection("types", m_szTypes, sizeof(m_szTypes), "trawl.ini")==0)
		{
		Error("No files types found to search for\n\rPlease add a [types] section to trawl.ini\n\r");
		return E_FAIL;
		}

	return S_OK;
}


HRESULT CTrawler::IsValidType(char *szExt)
{
	char *pszTypes=m_szTypes;

	if (*szExt == '.')
		szExt++;

	while (*pszTypes)
		{
		if (lstrcmp(szExt, pszTypes)==0)
			{
			return S_OK;
			}

        pszTypes+=lstrlen(pszTypes)+1;
		}
	return S_FALSE;
}



// --------------------------------------------------------------------------------
// CTrawler::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnLogonPrompt(LPINETSERVER pInetServer,
                                          IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CTrawler::OnPrompt(HRESULT hrError, LPCTSTR pszText, 
                                           LPCTSTR pszCaption, UINT uType,
                                           IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnError(IXPSTATUS ixpstatus, LPIXPRESULT pIxpResult,
                                    IInternetTransport *pTransport)
    {
    char                        szBuffer[256];

    wsprintf(szBuffer, "CTrawler::OnError - Status: %d, hrResult: %08x\n", ixpstatus, pIxpResult->hrResult);
	Error(szBuffer);
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnStatus(IXPSTATUS ixpstatus,
                                     IInternetTransport *pTransport)
    {
    INETSERVER                  rServer;
    char                        szBuffer[256];
    
    pTransport->GetServerInfo(&rServer);
    switch(ixpstatus)
        {
        case IXP_FINDINGHOST:
            wsprintf(szBuffer, "Finding '%s'...\n", rServer.szServerName);
            break;
        case IXP_CONNECTING:
            wsprintf(szBuffer, "Connecting '%s'...\n", rServer.szServerName);
            break;
        case IXP_SECURING:
            wsprintf(szBuffer, "Establishing secure connection to '%s'...\n", rServer.szServerName);
            break;
        case IXP_CONNECTED:
            wsprintf(szBuffer, "Connected '%s'\n", rServer.szServerName);
            break;
        case IXP_AUTHORIZING:
            wsprintf(szBuffer, "Authorizing '%s'...\n", rServer.szServerName);
            break;
        case IXP_AUTHRETRY:
            wsprintf(szBuffer, "Retrying Logon '%s'...\n", rServer.szServerName);
            break;
        case IXP_DISCONNECTING:
            wsprintf(szBuffer, "Disconnecting '%s'...\n", rServer.szServerName);
            break;
        case IXP_DISCONNECTED:
            wsprintf(szBuffer, "Disconnected '%s'\n", rServer.szServerName);
            break;
        }

    ShowMsg(szBuffer, FOREGROUND_GREEN);
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnProgress(DWORD dwIncrement, DWORD dwCurrent, 
                                       DWORD dwMaximum, IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnCommand(CMDTYPE cmdtype, LPSTR pszLine, 
                                      HRESULT hrResponse,
                                      IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnTimeout(DWORD *pdwTimeout, 
                                      IInternetTransport *pTransport)
    {
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    printf("Timeout '%s' !!!\n", rServer.szServerName);
    return S_OK;
    }


// --------------------------------------------------------------------------------
// CTrawler::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnResponse(LPNNTPRESPONSE pResponse)
    {
    switch(pResponse->state)
        {
        case NS_DISCONNECTED:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_CONNECT:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, NS_CONNECT, 0);
            break;

        case NS_AUTHINFO:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_GROUP:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_GROUP_RESP - rGroup.dwFirst  = %d\n"
                       "                rGroup.dwLast   = %d\n"
                       "                rGroup.dwCount  = %d\n"
                       "                rGroup.pszGroup = %s\n\n",
                       pResponse->rGroup.dwFirst, pResponse->rGroup.dwLast, 
                       pResponse->rGroup.dwCount, pResponse->rGroup.pszGroup);
                
                m_uMin = pResponse->rGroup.dwFirst;
                m_uMax = pResponse->rGroup.dwLast;
                }
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_NEXT:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_NEXT_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rNext.dwArticleNum, pResponse->rNext.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;
            
        case NS_LAST:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_LAST_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rLast.dwArticleNum, pResponse->rLast.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_STAT:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_STAT_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rLast.dwArticleNum, pResponse->rLast.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_LIST:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_LIST_DATA_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rList.cLines; i++)
                        printf("%s\n", pResponse->rList.rgszLines[i]);
                    }

                m_pNNTP->ReleaseResponse(pResponse);

                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;
            
        case NS_LISTGROUP:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_GROUP_SELECTED)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rListGroup.cArticles; i++)
                        printf("%d\n", pResponse->rListGroup.rgArticles[i]);
                    }

                m_pNNTP->ReleaseResponse(pResponse);

                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_DATE:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\nNS_DATE - %02d/%02d/%04d %02d:%02d:%02d\n\n",
                       pResponse->rDate.wMonth, pResponse->rDate.wDay,
                       pResponse->rDate.wYear, pResponse->rDate.wHour, 
                       pResponse->rDate.wMinute, pResponse->rDate.wSecond);
                }

            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_MODE:
            printf("\nNS_MODE\n\n");
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_NEWGROUPS:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_NEWNEWSGROUPS_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rNewgroups.cLines; i++)
                        printf("%s\n", pResponse->rNewgroups.rgszLines[i]);
                    }

                m_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;                       

        case NS_ARTICLE:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_ARTICLE_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, NS_ARTICLE, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    OnArticle(pResponse->rArticle.pszLines, pResponse->rArticle.cbLines, pResponse->fDone);
                    }
                
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, NS_ARTICLE, 0);
                
                m_pNNTP->ReleaseResponse(pResponse);
                }
            break;

        case NS_HEAD:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_HEAD_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    printf("%s", pResponse->rArticle.pszLines);

                m_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_BODY:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_BODY_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    printf("%s", pResponse->rArticle.pszLines);
                    }
                m_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_IDLE:
            printf("NS_IDLE\n");
            printf("Why would we ever be here?");
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_HEADERS:
            if ((pResponse->rIxpResult.uiServerError / 100) != 2)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rHeaders.cHeaders; i++)
                        {
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwArticleNum);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszSubject);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszFrom);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszDate);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszMessageId);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszReferences);
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwBytes);
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwLines);
                        if (pResponse->rHeaders.rgHeaders[i].pszXref)
                            printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszXref);

                        printf("\n\n");
                        }
                    }

                m_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_XHDR:
            if ((pResponse->rIxpResult.uiServerError / 100) != 2)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rXhdr.cHeaders; i++)
                        {
                        printf("%6d %s\n", pResponse->rXhdr.rgHeaders[i].dwArticleNum,
                               pResponse->rXhdr.rgHeaders[i].pszHeader);
                        }
                    }

                m_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;
        
        case NS_POST:
            printf("%s\n", pResponse->rIxpResult.pszResponse);
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_QUIT:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP,0, 0);
            break;
        }
    return S_OK;
    }


HRESULT HrRewindStream(LPSTREAM pstm)
{
    LARGE_INTEGER  liOrigin = {0,0};

    return pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
}


void CTrawler::DumpMsg(IMimeMessage *pMsg)
{
    TCHAR       *szExt;
    ULONG       cAttach=0,
                uAttach;
    LPHBODY     rghAttach=0;
    LPSTR       lpszFile=0;
    HBODY       hAttach=0;
    LPMIMEBODY  pBody=0;
    TCHAR       szTemp[MAX_PATH];

    if (FAILED(pMsg->GetAttachments(&cAttach, &rghAttach)))
        goto error;

    if (cAttach==0)
        goto error;

    for (uAttach = 0; uAttach < cAttach; uAttach++)
        {
        hAttach = rghAttach[uAttach];

        if (FAILED(MimeOleGetBodyPropA(pMsg, hAttach, STR_ATT_GENFNAME, NOFLAGS, &lpszFile)))
            continue;   // can't inline this dude...

        szExt = PathFindExtension(lpszFile);

		if (IsValidType(szExt)==S_OK)
            {
            // we can inline
            lstrcpy(szTemp, m_szPath);
            lstrcat(szTemp, lpszFile);

            if (pMsg->BindToObject(hAttach, IID_IMimeBody, (LPVOID *)&pBody)==S_OK)
                {
                ShowMsg(szTemp, FOREGROUND_BLUE);
    
                if (FAILED(pBody->SaveToFile(IET_BINARY, szTemp)))
					Error("Error: could not create file on disk.");
                
				pBody->Release();
                }
            }
        
		// I'm being lazy, I can't be bother writing to code to get the mime allocator, so I'm just not going to 
		// free this string...
		//SafeMimeOleFree(lpszFile);
        }
error:
    return;
}

void CTrawler::OnArticle(LPSTR lpszLines, ULONG cbLines, BOOL fDone)
{
    IMimeMessage    *pMsg;
        
    if (!m_pstm)
		{
		// if we need a new stream let's create one
		MimeOleCreateVirtualStream(&m_pstm);
		}

	if (m_pstm)
        {
        if (!FAILED(m_pstm->Write(lpszLines, cbLines, NULL)))
            {
            if (fDone)
                {
                // if we're done, scan the msg and release and NULL the stream ready
				// for the next article
				if (!FAILED(MimeOleCreateMessage(NULL, &pMsg)))
                    {
                    HrRewindStream(m_pstm);
                    if (!FAILED(pMsg->Load(m_pstm)))
                        DumpMsg(pMsg);
                    pMsg->Release();
                    m_pstm->Release();
                    m_pstm = NULL;
                    }
                }
            }
        }
}



void CTrawler::ShowMsg(LPSTR psz, BYTE fgColor)
{
    HANDLE                      hConsole = INVALID_HANDLE_VALUE;
    CONSOLE_SCREEN_BUFFER_INFO  csbi;
    BOOL                        fChanged = FALSE;
    char                        szBuffer[256];
    DWORD                       dwWritten = 0;

    // Get a handle to the console window
    if (INVALID_HANDLE_VALUE != (hConsole = GetStdHandle(STD_OUTPUT_HANDLE)))
        {
        // Get the current attributes for the console
        if (GetConsoleScreenBufferInfo(hConsole, &csbi))
            {
            // Set the text color to be red on whatever background is currently
            // there
            fChanged = SetConsoleTextAttribute(hConsole, 
                                               (csbi.wAttributes & 0xF0) | fgColor | FOREGROUND_INTENSITY);
            }
        }

    wsprintf(szBuffer, "%s\n\r", psz);
    WriteConsole(hConsole, szBuffer, lstrlen(szBuffer), &dwWritten, NULL);

    // If we changed the screen attributes, then change them back
    if (fChanged)
        SetConsoleTextAttribute(hConsole, csbi.wAttributes);

}


void CTrawler::Error(LPSTR psz)
{
	ShowMsg(psz, FOREGROUND_RED);
}



void WaitForCompletion(UINT uiMsg, DWORD wparam)
{
    MSG msg;
    
    while(GetMessage(&msg, NULL, 0, 0))
        {
        if (msg.message == uiMsg && msg.wParam == wparam || msg.wParam == IXP_DISCONNECTED)
            break;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\build\makefile.inc ===
$(O)\inetdum.rc : $(R)\resdummy\inetdum.rc
    copy $** $@

$O\*.sbr :
    move $(R)\inc\$O\*.sbr $O
    move $(R)\dll\$O\*.sbr $O
    move $(R)\common\$O\*.sbr $O
    move $(R)\fntcache\$O\*.sbr $O
    move $(R)\imnxport\$O\*.sbr $O
    move $(R)\mimeedit\$O\*.sbr $O
    move $(R)\mimeole\$O\*.sbr $O
    move $(R)\res\$O\*.sbr $O
    move $(R)\exrwlck\$O\*.sbr $O
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\build\main.c ===
#include "windows.h"

int CALLBACK WEP(int x)
{

    // Free Global Variables
    FreeGlobalVars();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\apitest\trawl\trawler.h ===
// --------------------------------------------------------------------------------
// trawler.h
// --------------------------------------------------------------------------------

#ifndef __TRAWLER_H__
#define __TRAWLER_H__

#include "imnxport.h"

#define CCH_MAX 4096

interface IMimeMessage;

class CTrawler : public INNTPCallback
    {
public:
    CTrawler(void);
    ~CTrawler(void);

    STDMETHODIMP QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // INNTPCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPNNTPRESPONSE              pResponse);



	HRESULT Init();
	HRESULT Close();
	HRESULT DoTrawl();

private:
    ULONG			m_cRef,
					m_uMin,
					m_uMax;
	INNTPTransport	*m_pNNTP;
	char			m_szGroups[CCH_MAX],
					m_szTypes[CCH_MAX],
					m_szPath[MAX_PATH],
					m_szServer[MAX_PATH];
	LPSTREAM		m_pstm;

	void ShowMsg(LPSTR psz, BYTE fgColor);
	void Error(LPSTR psz);
	void OnArticle(LPSTR lpszLines, ULONG cbLines, BOOL fDone);
	void DumpMsg(IMimeMessage *pMsg);

	HRESULT LoadIniData();
	HRESULT SelectGroup(LPSTR lpszGroup);
	HRESULT DumpGroup(LPSTR lpszGroup);
	HRESULT IsValidType(char *szExt);

    };


HRESULT HrCreateTrawler(CTrawler **ppTrawler);

#endif // __TRAWLER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\dll\defguid.cpp ===
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
#include "pch.hxx"
#include <initguid.h>
#include <ole2.h>
#include <shlguidp.h>
#define INITGUID
#include "mimeole.h"
#ifdef SMIME_V3
#include "smimepol.h"
#endif // SMIME_V3
#include "mimeolep.h"
#include "mimeedit.h"
#ifndef MAC
#include "imnxport.h"
#endif  // !MAC
#include "stmlock.h"
#ifndef WIN16
#include "ibdylock.h"
#endif // !WIN16
#include "ibdystm.h"
#include <xmlparser.h>
#include <booktree.h>

#ifdef WIN16
// The BINDNODESTATE type was defined in "booktree.h" file - only for WATCOMC.
#include "ibdylock.h"
#include <olectlid.h>           // IID_IPersistStreamInit
#endif // WIN16

#include <containx.h>
#include <bookbody.h>
#ifndef MAC
#include <mlang.h>
#endif  // !MAC
#include <msoert.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\common\attmenu.cpp ===
/*
 *    a t t m e n u. c p p
 *    
 *    Purpose:
 *        Attachment menu
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "dllmain.h"
#include "docobj.h"
#include "resource.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "mimeole.h"
#include "mimeolep.h"
#include "attmenu.h"
#include "saveatt.h"
#include <icutil.h>
#include "demand.h"

ASSERTDATA

/*
 *  e x t e r n s
 */

/*
 *  t y p e d e f s 
 */

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s 
 */

/*
 *  g l o b a l s 
 */

static const TCHAR  c_szSubThisPtr[]="AttMenu_SubThisPtr";

/*
 *  p r o t o t y p e s
 */



CAttMenu::CAttMenu()
{
    m_hMenu=NULL;
    m_cRef=1;
    m_hCharset=NULL;
    m_pFntCache=NULL;
    m_pFrame=NULL;
    m_pMsg=NULL;
    m_pfnWndProc=NULL;
    m_fShowingMenu=FALSE;
    m_pAttachVCard=NULL;
    m_pHostCmdTarget=NULL;
    m_cAttach = 0;
    m_cVisibleAttach = 0;
    m_cEnabledAttach = 0;
    m_fAllowUnsafe = FALSE;
    m_hVCard = NULL;
    m_rghAttach = NULL;

}

CAttMenu::~CAttMenu()
{
    if (m_hMenu)
        DestroyMenu(m_hMenu);
    HrFreeAttachData(m_pAttachVCard);    
    ReleaseObj(m_pFntCache);
    ReleaseObj(m_pFrame);
    ReleaseObj(m_pMsg);
    ReleaseObj(m_pHostCmdTarget);
    SafeMemFree(m_rghAttach);
}


ULONG CAttMenu::AddRef()
{
    return ++m_cRef;
}

ULONG CAttMenu::Release()
{
    m_cRef--;
    if (m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CAttMenu::Init(IMimeMessage *pMsg, IFontCache *pFntCache, IOleInPlaceFrame *pFrame, IOleCommandTarget *pHostCmdTarget)
{
    if (pMsg==NULL || pFntCache==NULL)
        return E_INVALIDARG;

    ReplaceInterface(m_pFntCache, pFntCache);
    ReplaceInterface(m_pFrame, pFrame);
    ReplaceInterface(m_pMsg, pMsg);
    ReplaceInterface(m_pHostCmdTarget, pHostCmdTarget);
    pMsg->GetCharset(&m_hCharset);
    return ScanForAttachmentCount();
}

HRESULT CAttMenu::Show(HWND hwnd, LPPOINT ppt, BOOL fRightClick)
{
    ULONG           iCmd;
    LPATTACHDATA    lpAttach;
    HRESULT         hr=S_OK;

    // Check Params
    AssertSz (hwnd && ppt, "Null Parameter");

    if (m_fShowingMenu)
        return S_OK;

    if (m_hMenu == NULL)
        {
        hr = BuildMenu();
        if (FAILED(hr))
            goto error;
        }

    Assert (m_hMenu);

    // BUG: If the right edge is off the screen, TrackPopupMenu picks a random point
    // ppt->x = min(GetSystemMetrics(SM_CXSCREEN), ppt->x);

    // set m_uVerb so we can show correct context menu help for Open or Save.
    m_uVerb = fRightClick || (GetAsyncKeyState(VK_CONTROL)&0x8000) ? AV_SAVEAS : AV_OPEN;
    
    m_fShowingMenu=TRUE;
    SubClassWindow(hwnd, TRUE);

    // sheer brillance. We subclass the parent window during the context menu loop so we can steal the
    // owndraw messages and also steal the menu select messages.

    iCmd = (ULONG)TrackPopupMenu (m_hMenu, TPM_RIGHTALIGN | TPM_LEFTBUTTON | TPM_RETURNCMD, ppt->x, ppt->y, 0, hwnd, NULL);

    SubClassWindow(hwnd, FALSE);
    m_fShowingMenu=FALSE;

    if (iCmd<=0)        // nothing selected, bail
        goto error;
    
    if (iCmd == idmSaveAllAttach)
        return HrSaveAll(hwnd);


    hr = FindItem(iCmd, FALSE, &lpAttach);
    if (FAILED(hr))
        goto error;

    hr = HrDoAttachmentVerb(hwnd, m_uVerb, m_pMsg, lpAttach);

error:
    return hr;
}





/*
 * note, we build the attachment menu we hang the lpAttach data off the context menu 
 * which contains all the temp file to delete etc.
 */

HRESULT CAttMenu::BuildMenu()
{
    HRESULT             hr = S_OK;
    MENUITEMINFO        mii={0};
    INT                 iMenu = 0;
    int                 cyMenu, cyMenuMax, cyItem;    
    SIZE                size;
    ULONG               uAttach;
    LPATTACHDATA        pAttach;
    int                 cSafeFiles = 0;

    Assert (!m_hMenu);

    // Create the menu
    m_hMenu = CreatePopupMenu();
    if (!m_hMenu)
        return E_OUTOFMEMORY;

    // figure out where to put menu breaks
    cyMenu = 0;
    cyMenuMax = GetSystemMetrics(SM_CYSCREEN);

    // calculate the rough height of each item, and the maximum width
    // for the attachment name
    GetItemTextExtent(NULL, L"BIGGERMAXATTACHMENTNAME.TXT", &size);
    m_cxMaxText = size.cx;
    cyItem = max(size.cy, GetSystemMetrics(SM_CYSMICON)) + 8;

    mii.cbSize = sizeof(mii); 
    mii.fMask = MIIM_DATA|MIIM_ID|MIIM_TYPE; 
    mii.fType = MFT_OWNERDRAW; 
    mii.wID = 1;

    /*
     * This is weird, but cool. So we assign menu items idms based on idmSaveAttachLast + i
     * where i is the item added. If we're a popup on a menubar, then we ensure that we don't go
     * over the reserved limit. If we're not then we are a context menu. The context menu is called with
     * TPM_RETURNCMD, so the commands are not sent to the owners WM_COMMAND. Therefore over-running this range
     * and going into someone elses idm-space is not an issue.
     */

    for (uAttach=0; uAttach<m_cAttach; uAttach++)
    {
        if (m_rghAttach[uAttach] != m_hVCard)
        {
            hr = HrAttachDataFromBodyPart(m_pMsg, m_rghAttach[uAttach], &pAttach);
            if (!FAILED(hr))
            {
                // for the ownerdraw menus, we simply hang off the attachment pointers, we are guaranteed
                // these to be valid during the lifetime of the menu
                mii.dwItemData = (DWORD_PTR)pAttach; 
                mii.fType = MFT_OWNERDRAW; 
            
                // insert menu breaks as appropriate
                cyMenu += cyItem;
                if (cyMenu >= cyMenuMax)
                {
                    mii.fType |= MFT_MENUBARBREAK;
                    cyMenu = cyItem;
                }

                if (pAttach && !pAttach->fSafe && !m_fAllowUnsafe)
                {
                    mii.fMask |= MIIM_STATE;
                    mii.fState = MFS_DISABLED;
                }
                else
                    cSafeFiles++;

                if (!InsertMenuItem (m_hMenu, iMenu++, TRUE, &mii))
                {
                    MemFree(pAttach);
                    hr = E_FAIL;
                    goto error;
                }
                mii.fMask &= ~MIIM_STATE;
                mii.fState = 0;

                mii.wID++;
            }
        }                
    }

    mii.fType = MFT_SEPARATOR;
    mii.dwItemData=0;
    InsertMenuItem (m_hMenu, iMenu++, TRUE, &mii);

    // we have to owner-draw this menu item as we draw the entire menu in a different font
    // based on the message locale
    mii.fType = MFT_OWNERDRAW;
    mii.dwTypeData = NULL;
    mii.dwItemData = NULL;
    mii.wID = idmSaveAllAttach;
    if (!m_fAllowUnsafe)
    {
        if (!cSafeFiles)
        {
            mii.fMask |= MIIM_STATE;
            mii.fState = MFS_DISABLED;
        }
        m_cEnabledAttach = cSafeFiles;
    }
    InsertMenuItem (m_hMenu, iMenu++, TRUE, &mii);

error:
    // Failed cond
    if (FAILED (hr) && m_hMenu)
        DestroyMenu(m_hMenu);

    // Done
    return hr;
}

HRESULT CAttMenu::DestroyMenu(HMENU hMenu)
{
    ULONG           uItem,
                    cItems;
    LPATTACHDATA    pAttach;

    cItems = GetMenuItemCount(hMenu);
    
    for (uItem = 0; uItem < cItems; uItem++)
    {
        // free the lpAttach hanging off the menu
        if (FindItem(uItem, TRUE, &pAttach)==S_OK)
            HrFreeAttachData(pAttach);
    }

    ::DestroyMenu(hMenu);
    return S_OK;
}



HRESULT CAttMenu::OnMeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT lpmis)
{
    WORD                cxIcon=(WORD)GetSystemMetrics (SM_CXSMICON), 
                        cyIcon=(WORD)GetSystemMetrics (SM_CYSMICON);
    SIZE                rSize;
    LPATTACHDATA        lpAttach;
    WCHAR               rgch[CCHMAX_STRINGRES];

    Assert(lpmis && hwnd);

    if (lpmis->CtlType == ODT_MENU)
    {
        // Default width and height
        lpmis->itemHeight = cyIcon + 8;
        lpmis->itemWidth = cxIcon + 9;
        
        lpAttach = (LPATTACHDATA)lpmis->itemData;
        if (lpAttach)
        {
            if (FAILED(GetItemTextExtent(hwnd, lpAttach->szDisplay, &rSize)))
                return E_FAIL;
            
            lpmis->itemWidth += min(rSize.cx, m_cxMaxText);
            lpmis->itemHeight = max (rSize.cy, cyIcon) + 8;
            return S_OK;
        }
        
        if (lpmis->itemID == idmSaveAllAttach)
        {
            LoadStringWrapW(g_hLocRes, idsSaveAllAttach, rgch, ARRAYSIZE(rgch));
            if (FAILED(GetItemTextExtent(hwnd, rgch, &rSize)))
                return E_FAIL;
            
            lpmis->itemWidth  = min(rSize.cx, m_cxMaxText) + 9;
            lpmis->itemHeight = max (rSize.cy, cyIcon) + 8;
            return S_OK;
        }
    }
    return E_FAIL;
}

HRESULT CAttMenu::GetItemTextExtent(HWND hwnd, LPWSTR szDisp, LPSIZE pSize)
{
    HDC         hdc;
    HFONT       hFont=0,
                hFontOld;
    HRESULT     hr=E_FAIL;
    
    // I need a DC to measure the size of the menu font
    hdc = GetDC (hwnd);
    if (hdc)
    {
        Assert (m_hCharset!=NULL);
        Assert (m_pFntCache);
        
        // Create the menu font
        m_pFntCache->GetFont(FNT_SYS_MENU, m_hCharset, &hFont);
        if (hFont)
            hFontOld = SelectFont (hdc, hFont);
        
        // Get the size of the text
        hr = GetTextExtentPoint32AthW(hdc, szDisp, lstrlenW(szDisp), pSize, DT_NOPREFIX)?S_OK:S_FALSE;
        
        if (hFont)
            SelectObject (hdc, hFontOld);
        
        ReleaseDC (hwnd, hdc);
    }
    return S_OK;
}

HRESULT CAttMenu::OnDrawItem(HWND hwnd, LPDRAWITEMSTRUCT lpdis)
{
    DWORD           rgbBack, rgbText;
    WORD            dx, x, y, 
                    cxIcon=(WORD) GetSystemMetrics (SM_CXSMICON), 
                    cyIcon=(WORD) GetSystemMetrics (SM_CYSMICON);
    HFONT           hFont = NULL, 
                    hFontOld = NULL;
    LPATTACHDATA    lpAttach;
    RECT            rc;
    LPWSTR          pszDisplay;
    WCHAR           rgch[CCHMAX_STRINGRES];
    HICON           hIcon;
    HCHARSET        hCharset;
            
    AssertSz (lpdis, "Null Parameter");

    // not a menu
    if (lpdis->CtlType != ODT_MENU)
        return E_FAIL;

    if (lpdis->itemID == idmSaveAllAttach)
    {
        if (!LoadStringWrapW(g_hLocRes, idsSaveAllAttach, rgch, ARRAYSIZE(rgch)))
            return E_FAIL;
        
        pszDisplay = rgch;
        hIcon=NULL;
        hCharset = NULL;    // always draw in system font
    }
    else
    {
        lpAttach = (LPATTACHDATA)lpdis->itemData;
        if (!lpAttach)
            return E_FAIL;
        
        hIcon = lpAttach->hIcon;
        pszDisplay = lpAttach->szDisplay;
        hCharset = m_hCharset;  // always draw in localised font
    }
    
    // Determine Colors
    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor (lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
        if (lpdis->itemState & ODS_DISABLED)
            rgbText = SetTextColor (lpdis->hDC, GetSysColor(COLOR_GRAYTEXT));
        else
            rgbText = SetTextColor (lpdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor (lpdis->hDC, GetSysColor(COLOR_MENU));
        if (lpdis->itemState & ODS_DISABLED)
            rgbText = SetTextColor (lpdis->hDC, GetSysColor(COLOR_GRAYTEXT));
        else
            rgbText = SetTextColor (lpdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
    }
    
    // Clear the item
    ExtTextOutWrapW(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, ETO_OPAQUE, &lpdis->rcItem, NULL, 0, NULL);
    
    dx = 4;
    if (hIcon)
    {
        x = (WORD) lpdis->rcItem.left + dx;
        y = (WORD) lpdis->rcItem.top + (INT)(((lpdis->rcItem.bottom - lpdis->rcItem.top) / 2) - (INT)(cyIcon / 2));
        DrawIconEx(lpdis->hDC, x, y, lpAttach->hIcon, cxIcon, cyIcon, NULL, NULL, DI_NORMAL);
    }
    
    // Create the menu font
    
    m_pFntCache->GetFont(FNT_SYS_MENU, hCharset, &hFont);
    if (hFont)
        hFontOld = (HFONT)SelectObject (lpdis->hDC, hFont);
    
    rc = lpdis->rcItem;
    rc.left += (cxIcon + (2*dx));
    rc.right -= 2*dx;
    DrawTextExWrapW(lpdis->hDC, pszDisplay, lstrlenW(pszDisplay), &rc, DT_END_ELLIPSIS|DT_SINGLELINE|DT_VCENTER|DT_WORDBREAK|DT_NOPREFIX, NULL);
    
    if (hFont)
        SelectObject (lpdis->hDC, hFontOld);
    
    // Reset Text Colors
    SetTextColor (lpdis->hDC, rgbText);
    SetBkColor (lpdis->hDC, rgbBack);
    return S_OK;
}


HRESULT CAttMenu::OnMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    LPATTACHDATA    pAttach;
    WCHAR           wszRes[CCHMAX_STRINGRES],
                    wsz[CCHMAX_STRINGRES + ARRAYSIZE(pAttach->szDisplay)];
    
    if (!m_pFrame)
        return E_FAIL;
    
    if (HIWORD(wParam)&MF_OWNERDRAW)
    {
        if (LOWORD(wParam) == idmSaveAllAttach)
        {
            SideAssert(LoadStringWrapW(g_hLocRes, idsSaveAllAttachMH, wszRes, ARRAYSIZE(wszRes)));
            m_pFrame->SetStatusText(wszRes);
            return S_OK;
        }
        
        if (FindItem(LOWORD(wParam), FALSE, &pAttach)==S_OK)
        {
            // if we're showing the context menu, rather than the save-attachment menu then we offer menuhelp
            // in the Form of 'Opens the attachment'. If a right-click context, do a save
            LoadStringWrapW(g_hLocRes, 
                            (m_uVerb == AV_OPEN) ? idsOpenAttachControl : idsSaveAttachControl, 
                            wszRes, 
                            ARRAYSIZE(wszRes));
            
            wnsprintfW(wsz, ARRAYSIZE(wsz), wszRes, pAttach->szDisplay);
            m_pFrame->SetStatusText(wsz);
            return S_OK;
        }
    }
    return S_FALSE;
}

HRESULT CAttMenu::SubClassWindow(HWND hwnd, BOOL fOn)
{
    if (fOn)
    {
        Assert (!m_pfnWndProc);
        SetProp(hwnd, c_szSubThisPtr, (HANDLE)this);
        m_pfnWndProc = (WNDPROC)SetWindowLongPtrAthW(hwnd, GWLP_WNDPROC, (LONG_PTR)ExtSubClassProc);
    }
    else
    {
        Assert (m_pfnWndProc);
        SetWindowLongPtrAthW(hwnd, GWLP_WNDPROC, (LONG_PTR)m_pfnWndProc);
        RemoveProp(hwnd, c_szSubThisPtr);
        m_pfnWndProc=NULL;
    }
    return S_OK;
}


LRESULT CAttMenu::ExtSubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CAttMenu    *pAttMenu = (CAttMenu *)GetProp(hwnd, c_szSubThisPtr);
    
    Assert (pAttMenu);
    switch (msg)
    {
    case WM_MEASUREITEM:
        pAttMenu->OnMeasureItem(hwnd, (LPMEASUREITEMSTRUCT)lParam);
        break;
        
    case WM_DRAWITEM:
        pAttMenu->OnDrawItem(hwnd, (LPDRAWITEMSTRUCT)lParam);
        break;
        
    case WM_MENUSELECT:
        pAttMenu->OnMenuSelect(hwnd, wParam, lParam);
        break;
    }
    
    return CallWindowProcWrapW(pAttMenu->m_pfnWndProc, hwnd, msg, wParam, lParam);
}


HRESULT CAttMenu::FindItem(int idm, BOOL fByPos, LPATTACHDATA *ppAttach)
{
    MENUITEMINFO    mii;
    
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask  = MIIM_DATA;
    
    Assert (ppAttach);
    
    if (GetMenuItemInfo(m_hMenu, idm, fByPos, &mii) && mii.dwItemData)
    {
        *ppAttach = (LPATTACHDATA)mii.dwItemData;
        return S_OK;
    }
    return E_FAIL;
}


HRESULT CAttMenu::HasAttach()
{
    return m_cVisibleAttach ? S_OK:S_FALSE;
}

HRESULT CAttMenu::HasEnabledAttach()
{
    return m_cEnabledAttach ? S_OK:S_FALSE;
}

HRESULT CAttMenu::HasVCard()
{
    return  m_hVCard ? S_OK:S_FALSE;
}

HRESULT CAttMenu::LaunchVCard(HWND hwnd)
{
    if (!m_hVCard)
        return E_FAIL;

    if (m_pAttachVCard==NULL &&
        HrAttachDataFromBodyPart(m_pMsg, m_hVCard, &m_pAttachVCard)!=S_OK)
        return E_FAIL;

    return HrDoAttachmentVerb(hwnd, AV_OPEN, m_pMsg, m_pAttachVCard);
}

HRESULT CAttMenu::HrSaveAll(HWND hwnd)
{
    return SaveAttachmentsWithPath(hwnd, m_pHostCmdTarget, m_pMsg);
}


HRESULT SaveAttachmentsWithPath(HWND hwnd, IOleCommandTarget *pCmdTarget, IMimeMessage *pMsg)
{
    VARIANTARG          va;
    WCHAR               rgchPath[MAX_PATH];
    HRESULT             hr;
    BOOL                fAllowUnsafe = FALSE;

    *rgchPath = 0;

    if (pCmdTarget && 
        pCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SAVEATTACH_PATH, 0, NULL, &va)==S_OK &&
        va.vt == VT_BSTR && 
        va.bstrVal)
    {
        StrCpyNW(rgchPath, va.bstrVal, ARRAYSIZE(rgchPath));
        SysFreeString(va.bstrVal);
    }
    
    if (pCmdTarget && 
        pCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_UNSAFEATTACHMENTS, 0, NULL, &va)==S_OK &&
        va.vt == VT_I4 && va.lVal == 0)
        fAllowUnsafe = TRUE;

    hr = HrSaveAttachments(hwnd, pMsg, rgchPath, ARRAYSIZE(rgchPath), fAllowUnsafe);
    if (hr == S_OK)
    {
        // if successful, then set the save attachment path

        if (pCmdTarget)
        {
            DWORD cchPath = lstrlenW(rgchPath);
            va.bstrVal = SysAllocStringLen(NULL, cchPath);
            if (va.bstrVal)
            {
                StrCpyNW(va.bstrVal, rgchPath, cchPath);
                va.vt = VT_BSTR;

                pCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SAVEATTACH_PATH, 0, &va, NULL);
                SysFreeString(va.bstrVal);
            }
            else
                TraceResult(hr = E_OUTOFMEMORY);
        }
    }

    return hr;
}

HRESULT CAttMenu::ScanForAttachmentCount()
{
    ULONG       uAttach,
                cAttach=0;
    LPSTR       psz;
    PROPVARIANT pv;
    VARIANTARG  va;

    // we quickly need to determine if there's a Vcard and or/attachments
    // so the preview pane can update the icons. When clicked on, we then defer-load the
    // actual info.

    Assert(m_rghAttach == NULL);
    Assert(m_cVisibleAttach == 0);
    Assert(m_cEnabledAttach == 0);
    Assert(m_cAttach == 0);

    if (m_pHostCmdTarget && 
        m_pHostCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_UNSAFEATTACHMENTS, 0, NULL, &va)==S_OK &&
        va.vt == VT_I4 && va.lVal == 0)
        m_fAllowUnsafe = TRUE;

    if (m_pMsg &&
        m_pMsg->GetAttachments(&cAttach, &m_rghAttach)==S_OK)
    {
        for (uAttach=0; uAttach<cAttach; uAttach++)
        {
            BOOL fSafe = FALSE;

            if (m_hVCard == NULL &&
                MimeOleGetBodyPropA(m_pMsg, m_rghAttach[uAttach], PIDTOSTR(PID_HDR_CNTTYPE), NOFLAGS, &psz)==S_OK)
            {
                // hang onto first v-card
                if (lstrcmpi(psz, "text/x-vcard")==0)
                    m_hVCard = m_rghAttach[uAttach];
                MemFree(psz);
            }
            if (!m_fAllowUnsafe && SUCCEEDED(HrAttachSafetyFromBodyPart(m_pMsg, m_rghAttach[uAttach], &fSafe)) && fSafe)
                m_cEnabledAttach++;
        }
    }

    // we keep the actual attachment count (tells the size of m_rghAttach) and also the 
    // count of 'visible' attachment we want to show
    m_cVisibleAttach = m_cAttach = cAttach;

    if (m_hVCard)
    {
        Assert (cAttach>0);
        m_cVisibleAttach--;
        m_cEnabledAttach--;
    }
    if (m_fAllowUnsafe)   // all visible attachments are enabled if we allow all files
        m_cEnabledAttach = m_cVisibleAttach;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\common\attmenu.h ===
#ifndef _ATTMENU_H
#define _ATTMENU_H

interface IOleCommandTarget;

class CAttMenu
{
public:
    CAttMenu();
    ~CAttMenu();

    ULONG AddRef();
    ULONG Release();

    HRESULT Init(IMimeMessage *pMsg, IFontCache *pFntCache, IOleInPlaceFrame *pFrame, IOleCommandTarget *pHostCmdTarget);
    HRESULT HasAttach();
    HRESULT HasEnabledAttach();
    HRESULT Show(HWND hwnd, LPPOINT ppt, BOOL fRightClick);
    
    HRESULT HasVCard();
    HRESULT LaunchVCard(HWND hwnd);

    static LRESULT ExtSubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
    HMENU               m_hMenu;
    ULONG               m_cRef,
                        m_uVerb,
                        m_cAttach,
                        m_cVisibleAttach,
                        m_cEnabledAttach;
    BOOL                m_fAllowUnsafe;
    int                 m_cxMaxText;
    HCHARSET            m_hCharset;
    IFontCache          *m_pFntCache;
    IOleInPlaceFrame    *m_pFrame;
    IOleCommandTarget   *m_pHostCmdTarget;
    WNDPROC             m_pfnWndProc;
    IMimeMessage        *m_pMsg;
    BOOL                m_fShowingMenu;
    LPATTACHDATA        m_pAttachVCard;
    HBODY               m_hVCard;
    HBODY               *m_rghAttach;

    HRESULT BuildMenu();
    HRESULT DestroyMenu(HMENU hMenu);
    HRESULT OnMeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT lpmis);
    HRESULT OnDrawItem(HWND hwnd, LPDRAWITEMSTRUCT lpdis);
    HRESULT OnMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam);
    HRESULT GetItemTextExtent(HWND hwnd, LPWSTR szDisp, LPSIZE pSize);
    HRESULT SubClassWindow(HWND hwnd, BOOL fOn);
    HRESULT FindItem(int idm, BOOL fByPos, LPATTACHDATA *ppAttach);    
    HRESULT HrSaveAll(HWND hwnd);
    HRESULT ScanForAttachmentCount();
};

typedef CAttMenu *LPATTMENU;

HRESULT SaveAttachmentsWithPath(HWND hwnd, IOleCommandTarget *pCmdTarget, IMimeMessage *pMsg);

#endif // _ATTMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\common\attach.cpp ===
/*
 *    a t t a c h . c p p
 *    
 *    Purpose:
 *        Attachment utilities
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */



#include <pch.hxx>
#include "dllmain.h"
#include "resource.h"
#include "error.h"
#include "mimeolep.h"
#include "shellapi.h"
#include "shlobj.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "mimeole.h"
#include "commdlg.h"
#include "demand.h"
#include "saferun.h"

ASSERTDATA

/*
 *  t y p e d e f s
 */

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s 
 */
#define MAX_CHARS_FOR_NUM       20

static const CHAR c_szWebMark[] = "<!-- saved from url=(0022)http://internet.e-mail -->\r\n";
static const WCHAR c_wszWebMark[] = L"<!-- saved from url=(0022)http://internet.e-mail -->\r\n";
/*
 *  g l o b a l s 
 */


/*
 *  p r o t o t y p e s
 */
HRESULT HrCleanTempFile(LPATTACHDATA pAttach);
HRESULT HrGetTempFile(IMimeMessage *pMsg, LPATTACHDATA lpAttach);
DWORD AthGetShortPathName(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer);

STDAPI HrGetAttachIconByFile(LPWSTR szFilename, BOOL fLargeIcon, HICON *phIcon)
{
    HICON           hIcon = NULL;
    LPWSTR          lpszExt;
    SHFILEINFOW     rShFileInfo;

    if (szFilename)
    {
        // Does the file exist already ?
        if ((UINT)GetFileAttributesWrapW(szFilename) != (UINT)-1)
        {
            // Try to get the icon out of the file
            SHGetFileInfoWrapW(szFilename, 0, &rShFileInfo, sizeof(rShFileInfo), SHGFI_ICON |(fLargeIcon ? 0 : SHGFI_SMALLICON));
            hIcon=rShFileInfo.hIcon;
        }
        else
            if (lpszExt = PathFindExtensionW(szFilename))
            {
                // Lookup the icon for lpszExt
                SHGetFileInfoWrapW(lpszExt, FILE_ATTRIBUTE_NORMAL, &rShFileInfo, sizeof (rShFileInfo), SHGFI_USEFILEATTRIBUTES | SHGFI_ICON | (fLargeIcon ? 0 : SHGFI_SMALLICON));
                hIcon=rShFileInfo.hIcon;
            }
    }

    if (!hIcon)
        hIcon = CopyIcon(LoadIcon (g_hLocRes, MAKEINTRESOURCE (idiDefaultAtt)));

    *phIcon=hIcon;
    return S_OK;
}

STDAPI HrGetAttachIcon(IMimeMessage *pMsg, HBODY hAttach, BOOL fLargeIcon, HICON *phIcon)
{
    // Locals
    HRESULT         hr = S_OK;
    LPWSTR          lpszFile=0;

    if (!phIcon || !hAttach || !pMsg)
        return E_INVALIDARG;

    *phIcon=NULL;

    // Get file name for body part. If get an error, doesn't matter.  Still use
    // a default icon that will be provided through HrGetAttachIconByFile
    MimeOleGetBodyPropW(pMsg, hAttach, PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &lpszFile);
    hr = HrGetAttachIconByFile(lpszFile, fLargeIcon, phIcon);
    SafeMemFree(lpszFile);
    return hr;
}

//
//  GetUIVersion()
//
//  returns the version of shell32
//  3 == win95 gold / NT4
//  4 == IE4 Integ / win98
//  5 == win2k / millennium
//
UINT GetUIVersion()
{
    static UINT s_uiShell32 = 0;

    if (s_uiShell32 == 0)
    {
        HINSTANCE hinst = LoadLibrary("SHELL32.DLL");
        if (hinst)
        {
            DLLGETVERSIONPROC pfnGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");
            DLLVERSIONINFO dllinfo;

            dllinfo.cbSize = sizeof(DLLVERSIONINFO);
            if (pfnGetVersion && pfnGetVersion(&dllinfo) == NOERROR)
                s_uiShell32 = dllinfo.dwMajorVersion;
            else
                s_uiShell32 = 3;

            FreeLibrary(hinst);
        }
    }
    return s_uiShell32;
}

STDAPI HrDoAttachmentVerb(HWND hwnd, ULONG uVerb, IMimeMessage *pMsg, LPATTACHDATA pAttach)
{
    HRESULT                 hr = S_OK;
    SHELLEXECUTEINFOW       rShellExec;
    LPSTREAM                lpstmAtt = NULL;
    LPWSTR                  lpszShortName = NULL, 
                            lpszParameters = NULL,
                            lpszExt = NULL;
    DWORD                   dwFlags;
    WCHAR                   szCommand[MAX_PATH];
    HKEY                    hKeyAssoc = NULL;

    AssertSz( uVerb < AV_MAX, "Bad Verb");

    if (uVerb == AV_PROPERTIES)
    {
        AssertSz(FALSE, "AV_PROPERTIES is NYI!!");
        return E_NOTIMPL;
    }
    
    if (!pAttach)
        return E_INVALIDARG;
    
    // Save As - much simpler case
    if (uVerb == AV_SAVEAS)
    {
        hr=HrSaveAttachmentAs(hwnd, pMsg, pAttach);
        goto error;  // done
    }
    
    // If opening attachment, lets verify thsi
    if (uVerb == AV_OPEN)
    {
        // If nVerb is to open the attachment, lets verify that with the user
        hr = IsSafeToRun(hwnd, pAttach->szFileName, TRUE);
        
        if (hr == MIMEEDIT_E_USERCANCEL)    // map mimeedit error to athena error
            hr = hrUserCancel;
        
        if (FAILED(hr))     // user doesn't want to do this
            goto error;
        
        if (hr == MIMEEDIT_S_SAVEFILE)
        {
            hr=HrSaveAttachmentAs(hwnd, pMsg, pAttach);
            // done
            goto error;  
        }
    }
    
    // get temp file
    hr = HrGetTempFile(pMsg, pAttach);
    if (FAILED(hr))
        goto error;
    
    Assert(lstrlenW(pAttach->szTempFile));
    
    // Setup Shell Execute Info Struct
    ZeroMemory (&rShellExec, sizeof (rShellExec));
    rShellExec.cbSize = sizeof (rShellExec);
    rShellExec.fMask = SEE_MASK_NOCLOSEPROCESS;
    rShellExec.hwnd = hwnd;
    rShellExec.nShow = SW_SHOWNORMAL;
    
    // Verb
    if (uVerb == AV_OPEN)
    {
        // Were going to run the file
        hr = VerifyTrust(hwnd, pAttach->szFileName, pAttach->szTempFile);
        if (FAILED(hr))
        {
            hr = hrUserCancel;
            goto error;
        }
        
        StrCpyNW(szCommand, pAttach->szTempFile, ARRAYSIZE(szCommand));
        rShellExec.lpFile = szCommand;
        
        // If the file does not have an associated type, do an OpenAs.
        // We're not testing the result of AssocQueryKeyW because even if it fails,
        // we want to try to open the file.
        lpszExt = PathFindExtensionW(pAttach->szTempFile);
        AssocQueryKeyW(NULL, ASSOCKEY_CLASS, lpszExt, NULL, &hKeyAssoc);
        if((hKeyAssoc == NULL) && (GetUIVersion() != 5))
            rShellExec.lpVerb = L"OpenAs";
        else
            RegCloseKey(hKeyAssoc);
    }
    
    else if (uVerb == AV_PRINT)
    {
        StrCpyNW(szCommand, pAttach->szTempFile, ARRAYSIZE(szCommand));
        rShellExec.lpFile = szCommand;
        rShellExec.lpVerb = L"Print";
    }
    
    else if (uVerb == AV_QUICKVIEW)
    {
        UINT        uiSysDirLen;
        const WCHAR c_szSubDir[] = L"\\VIEWERS\\QUIKVIEW.EXE";
        
        // Find out where the viewer lives
        uiSysDirLen = GetSystemDirectoryWrapW(szCommand, ARRAYSIZE(szCommand));
        if (0 == uiSysDirLen || uiSysDirLen >= ARRAYSIZE(szCommand) ||
            uiSysDirLen + ARRAYSIZE(c_szSubDir) > ARRAYSIZE(szCommand))
        {
            hr = E_FAIL;
            goto error;
        }
        
        StrCpyNW(szCommand + uiSysDirLen, c_szSubDir, ARRAYSIZE(szCommand) - uiSysDirLen);
        
        // Alloc for short file name
        ULONG cchShortName = MAX_PATH + lstrlenW(pAttach->szTempFile) + 1;
        if (!MemAlloc ((LPVOID *)&lpszShortName, cchShortName * sizeof (WCHAR)))
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        
        // Alloc a string for the parameters
        ULONG cchParameters = 30 + cchShortName;
        if (!MemAlloc ((LPVOID *)&lpszParameters, cchParameters * sizeof (WCHAR)))
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        
        // Get Short File Name
        if (0 == AthGetShortPathName(pAttach->szTempFile, lpszShortName, cchShortName))
            StrCpyNW(lpszShortName, pAttach->szTempFile, cchShortName);
        
        // Put together the paramenters for QVSTUB.EXE
        Assert(cchParameters > cchShortName);
        StrCpyNW(lpszParameters, L"-v -f:", cchParameters);
        StrCatBuffW(lpszParameters, lpszShortName, cchParameters);
        
        // Setup Shellexec
        rShellExec.lpParameters = lpszParameters;
        rShellExec.lpFile = szCommand;
    }
    else
        Assert (FALSE);
    
    if (fIsNT5())   // quoted paths cause problems downlevel
        PathQuoteSpacesW(szCommand);

    // Execute it - even if this fails, we handled it - it will give a good error
    ShellExecuteExWrapW(&rShellExec);
    pAttach->hProcess = rShellExec.hProcess;
    
    
error:
    MemFree(lpszParameters);
    MemFree(lpszShortName);
    return hr;
}

DWORD AthGetShortPathName(LPCWSTR pwszLongPath, LPWSTR pwszShortPath, DWORD cchBuffer)
{
    CHAR    szShortPath[MAX_PATH*2]; // Each Unicode char might go multibyte
    LPSTR   pszLongPath = NULL;
    DWORD   result = 0;

    Assert(pwszLongPath);
    pszLongPath = PszToANSI(CP_ACP, pwszLongPath);

    if (pszLongPath)
    {
        result = GetShortPathName(pszLongPath, szShortPath, ARRAYSIZE(szShortPath));
        if (result && result <= ARRAYSIZE(szShortPath))
        {
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szShortPath, lstrlen(szShortPath), pwszShortPath, cchBuffer);
            pwszShortPath[cchBuffer - 1] = 0;
        }

        MemFree(pszLongPath);
    }

    return result;
}

STDAPI HrAttachDataFromBodyPart(IMimeMessage *pMsg, HBODY hAttach, LPATTACHDATA *ppAttach)
{
    LPATTACHDATA    pAttach;
    LPWSTR          pszW;
    IMimeBodyW      *pBody;

    Assert (pMsg && ppAttach && hAttach);

    if (!MemAlloc((LPVOID *)&pAttach, sizeof(ATTACHDATA)))
        return E_OUTOFMEMORY;

    // fill in attachment data
    ZeroMemory(pAttach, sizeof(ATTACHDATA));

    if (pMsg->BindToObject(hAttach, IID_IMimeBodyW, (LPVOID *)&pBody)==S_OK)
    {
        if (pBody->GetDisplayNameW(&pszW)==S_OK)
        {
            StrCpyNW(pAttach->szDisplay, pszW, ARRAYSIZE(pAttach->szDisplay));
            MemFree(pszW);
        }
        ReleaseObj(pBody);
    }
    
    if (MimeOleGetBodyPropW(pMsg, hAttach, PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &pszW)==S_OK)
    {
        if(IsPlatformWinNT() != S_OK)
        {
            CHAR pszFile[MAX_PATH*2];
            DWORD cchSizeW = (lstrlenW(pszW) + 1);

            WideCharToMultiByte(CP_ACP, 0, pszW, -1, pszFile, ARRAYSIZE(pszFile), NULL, NULL);
            pszFile[ARRAYSIZE(pszFile) - 1] = '\0';
            MultiByteToWideChar(CP_ACP, 0, pszFile, -1, pszW, cchSizeW);
            pszW[cchSizeW - 1] = 0;

            CleanupFileNameInPlaceW(pszW);
        }

        StrCpyNW(pAttach->szFileName, pszW, ARRAYSIZE(pAttach->szFileName));
        MemFree(pszW);
    }
    
    SideAssert(HrGetAttachIcon(pMsg, hAttach, FALSE, &pAttach->hIcon)==S_OK);
    pAttach->hAttach = hAttach;
    pAttach->fSafe = (IsSafeToRun(NULL, pAttach->szFileName, FALSE) == MIMEEDIT_S_OPENFILE);
    
    *ppAttach = pAttach;
    return S_OK;
}

STDAPI HrAttachDataFromFile(IStream *pstm, LPWSTR pszFileName, LPATTACHDATA *ppAttach)
{
    LPATTACHDATA    pAttach=0;
    LPMIMEBODY      pBody=0;
    HRESULT         hr;
    int             cFileNameLength;

    Assert(ppAttach);

    if (!MemAlloc((LPVOID *)&pAttach, sizeof(ATTACHDATA)))
        return E_OUTOFMEMORY;

    // fill in attachment data
    ZeroMemory(pAttach, sizeof(ATTACHDATA));

    HrGetDisplayNameWithSizeForFile(pszFileName, pAttach->szDisplay, ARRAYSIZE(pAttach->szDisplay));
    StrCpyNW(pAttach->szFileName, pszFileName, ARRAYSIZE(pAttach->szFileName));
    if (!pstm)
    {
        // for new attachments set tempfile to be the same as filename
        // note: if creating from an IStream then pszFileName is not a valid path
        // we can create a tempfile later
        StrCpyNW(pAttach->szTempFile, pszFileName, ARRAYSIZE(pAttach->szTempFile));
    }
    ReplaceInterface(pAttach->pstm, pstm);
    SideAssert(HrGetAttachIconByFile(pszFileName, FALSE, &pAttach->hIcon)==S_OK);
    
    if (ppAttach)
        *ppAttach=pAttach;
    
    return S_OK;
}

STDAPI HrFreeAttachData(LPATTACHDATA pAttach)
{
    if (pAttach)    
    {
        HrCleanTempFile(pAttach);
        ReleaseObj(pAttach->pstm);
        if (pAttach->hIcon)
            DestroyIcon(pAttach->hIcon);
        
        MemFree(pAttach);
    }
    return NOERROR;
}


HRESULT HrCleanTempFile(LPATTACHDATA pAttach)
{
    if (pAttach)
    {
        if (*pAttach->szTempFile && pAttach->hAttach)
        {
            // we only clean the tempfile if hAttach != NULL. Otherwise we assume it's a new attachment
            // and szTempFile points to the source file
            // If the file was launched, don't delete the temp file if the process still has it open
            if (pAttach->hProcess)
            {
                if (WaitForSingleObject (pAttach->hProcess, 0) == WAIT_OBJECT_0)
                    DeleteFileWrapW(pAttach->szTempFile);
            }
            else
                DeleteFileWrapW(pAttach->szTempFile);
        }
        *pAttach->szTempFile = NULL;
        pAttach->hProcess=NULL;
    }
    return NOERROR;
}

HRESULT HrAttachSafetyFromBodyPart(IMimeMessage *pMsg, HBODY hAttach, BOOL *pfSafe)
{
    LPWSTR pszW = NULL;

    Assert (pMsg && pfSafe && hAttach);

    *pfSafe = FALSE;
    if (MimeOleGetBodyPropW(pMsg, hAttach, PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &pszW)==S_OK)
    {
        if(IsPlatformWinNT() != S_OK)
        {
            CHAR pszFile[MAX_PATH*2];
            DWORD cchSizeW = lstrlenW(pszW)+1;

            WideCharToMultiByte(CP_ACP, 0, pszW, -1, pszFile, ARRAYSIZE(pszFile), NULL, NULL);
            pszFile[ARRAYSIZE(pszFile) - 1] = 0;
            MultiByteToWideChar(CP_ACP, 0, pszFile, -1, pszW, cchSizeW);
            pszW[cchSizeW - 1] = 0;

            CleanupFileNameInPlaceW(pszW);
        }
        *pfSafe = (IsSafeToRun(NULL, pszW, FALSE) == MIMEEDIT_S_OPENFILE);
        MemFree(pszW);
    }

    return S_OK;
}

STDAPI HrGetDisplayNameWithSizeForFile(LPWSTR pszPathName, LPWSTR pszDisplayName, int cchMaxDisplayName)
{
    HANDLE  hFile;
    DWORD   uFileSize;
    WCHAR   szSize[MAX_CHARS_FOR_NUM+1+3],
            szBuff[MAX_CHARS_FOR_NUM+1];
    LPWSTR  pszFileName = NULL,
            pszFirst;
    int     iSizeLen = 0,
            iLenFirst;

    szSize[0] = L'\0';

    hFile = CreateFileWrapW(pszPathName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        uFileSize = GetFileSize(hFile, NULL);
        CloseHandle(hFile);
        if ((uFileSize != 0xffffffff) && StrFormatByteSizeW(uFileSize, szBuff, ARRAYSIZE(szBuff) - 1))
        {
            StrCpyNW(szSize, L" (", ARRAYSIZE(szSize));
            StrCatBuffW(szSize, szBuff, ARRAYSIZE(szSize));
            StrCatBuffW(szSize, L")", ARRAYSIZE(szSize));
        }
    }
    pszFileName = PathFindFileNameW(pszPathName);

    iSizeLen = lstrlenW(szSize);
    if (pszFileName)
        pszFirst = pszFileName;
    else
        pszFirst = pszPathName;

    iLenFirst = lstrlenW(pszFirst);
    StrCpyNW(pszDisplayName, pszFirst, cchMaxDisplayName);

    if (iLenFirst + iSizeLen + 1 > cchMaxDisplayName)
        return E_FAIL;

    StrCpyNW(pszDisplayName + iLenFirst, szSize, cchMaxDisplayName - iLenFirst);
    return S_OK;
}


STDAPI HrSaveAttachmentAs(HWND hwnd, IMimeMessage *pMsg, LPATTACHDATA lpAttach)
{
    HRESULT         hr = S_OK;
    OPENFILENAMEW   ofn;
    WCHAR           szTitle[CCHMAX_STRINGRES],
                    szFilter[CCHMAX_STRINGRES],
                    szFile[MAX_PATH];

    *szFile=0;
    *szFilter=0;
    *szTitle=0;

    Assert (lpAttach->szFileName);
    if (lpAttach->szFileName)
        StrCpyNW(szFile, lpAttach->szFileName, ARRAYSIZE(szFile));

    ZeroMemory (&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    LoadStringWrapW(g_hLocRes, idsFilterAttSave, szFilter, ARRAYSIZE(szFilter));
    ReplaceCharsW(szFilter, L'|', L'\0');
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = ARRAYSIZE(szFile);
    LoadStringWrapW(g_hLocRes, idsSaveAttachmentAs, szTitle, ARRAYSIZE(szTitle));
    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_NOCHANGEDIR | OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

    // Show SaveAs Dialog
    if (HrAthGetFileNameW(&ofn, FALSE) != S_OK)
    {
        hr = hrUserCancel;
        goto error;
    }
    
    if (lpAttach->hAttach == NULL)
    {
        if (!PathFileExistsW(lpAttach->szFileName))
        {
            hr = hrNotFound;
            goto error;
        }

        // if hAttach == NULL then try and copy the file
        CopyFileWrapW(lpAttach->szFileName, szFile, TRUE);
    }
    else
    {
        // Verify the Attachment's Stream
        hr=HrSaveAttachToFile(pMsg, lpAttach->hAttach, szFile);
        if (FAILED(hr))
            goto error;
    }
error:
    return hr;
}



HRESULT HrGetTempFile(IMimeMessage *pMsg, LPATTACHDATA lpAttach)
{
    HRESULT         hr;
    
    if (*lpAttach->szTempFile)
        return S_OK;
    
    if (!FBuildTempPathW(lpAttach->szFileName, lpAttach->szTempFile, ARRAYSIZE(lpAttach->szTempFile), FALSE))
    {
        hr = E_FAIL;
        goto error;
    }
    
    if (lpAttach->hAttach)
    {
        hr=HrSaveAttachToFile(pMsg, lpAttach->hAttach, lpAttach->szTempFile);
        if (FAILED(hr))
            goto error;
    }
    else
    {
        AssertSz(lpAttach->pstm, "if no hAttach then pstm should be set");
        
        hr = WriteStreamToFileW(lpAttach->pstm, lpAttach->szTempFile, CREATE_ALWAYS, GENERIC_WRITE);
        if (FAILED(hr))
            goto error;
    }
    
error:
    if (FAILED(hr))
    {
        // Null out temp file as we didn't really create it
        *(lpAttach->szTempFile)=0;
    }
    return hr;
}

const BYTE c_rgbUTF[3] = {0xEF, 0xBB, 0xBF};
STDAPI HrSaveAttachToFile(IMimeMessage *pMsg, HBODY hAttach, LPWSTR lpszFileName)
{
    HRESULT         hr;
    LPSTREAM        pstm=NULL,
                    pstmOut=NULL;
    BOOL            fEndian,
                    fUTFEncoded = FALSE;
    BYTE            rgbBOM[2];
    BYTE            rgbUTF[3];
    DWORD           cbRead;

    if (pMsg == NULL || hAttach == NULL)
        IF_FAILEXIT(hr =  E_INVALIDARG);

    // bind to the attachment data
    IF_FAILEXIT(hr=pMsg->BindToObject(hAttach, IID_IStream, (LPVOID *)&pstm));

    // create a file stream
    IF_FAILEXIT(hr = OpenFileStreamW(lpszFileName, CREATE_ALWAYS, GENERIC_WRITE, &pstmOut));

    // if we have an .HTM file, then pre-pend 'mark of the web' comment
    // If we are a unicode file, the BOM will be "0xFFFE"
    // If we are a UTF8 file, the BOM will be "0xEFBBBF"
    if (PathIsHTMLFileW(lpszFileName))
    {
        if (S_OK == HrIsStreamUnicode(pstm, &fEndian))
        {
            // Don't rewind otherwise end up with BOM after 'mark of the web' as well.
            IF_FAILEXIT(hr = pstm->Read(rgbBOM, sizeof(rgbBOM), &cbRead));

            // Since HrIsStreamUnicode succeeded, there should be at least two
            Assert(sizeof(rgbBOM) == cbRead);

            IF_FAILEXIT(hr = pstmOut->Write(rgbBOM, cbRead, NULL));
            IF_FAILEXIT(hr = pstmOut->Write(c_wszWebMark, sizeof(c_wszWebMark)-sizeof(WCHAR), NULL));
        }
        else
        {
            // Check for UTF8 file BOM
            IF_FAILEXIT(hr = pstm->Read(rgbUTF, sizeof(rgbUTF), &cbRead));
            if (sizeof(rgbUTF) == cbRead)
            {
                fUTFEncoded = (0 == memcmp(c_rgbUTF, rgbUTF, sizeof(rgbUTF)));
            }

            // If we are not UTF8 encoded, then rewind, else write out BOM
            if (!fUTFEncoded)
                IF_FAILEXIT(hr = HrRewindStream(pstm));
            else
                IF_FAILEXIT(hr = pstmOut->Write(c_rgbUTF, sizeof(c_rgbUTF), NULL));

            IF_FAILEXIT(hr = pstmOut->Write(c_szWebMark, sizeof(c_szWebMark)-sizeof(CHAR), NULL));

        }
    }
    
    // write out the actual file data
    IF_FAILEXIT(hr = HrCopyStream(pstm, pstmOut, NULL));

exit:
    ReleaseObj(pstm);
    ReleaseObj(pstmOut);
    return hr;
}



/*
 * Why? 
 * 
 * we wrap this as if we don't use NOCHANGEDIR, then things like ShellExec
 * fail if the current directory is nolonger valid. Eg: attach a file from a:\
 * and remove the floppy. Then all ShellExec's fail. So we maintain our own
 * last directory buffer. We should use thread-local for this, as it is possible
 * that two thread could whack the same buffer, it is unlikley that a user action
 * could cause two open file dialogs in the note and the view to open at exactly the
 * same time.
 */

WCHAR   g_wszLastDir[MAX_PATH];

HRESULT SetDefaultSpecialFolderPath()
{
    LPITEMIDLIST    pidl = NULL;
    HRESULT         hr = E_FAIL;

    if (SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl)==S_OK)
    {
        if (SHGetPathFromIDListWrapW(pidl, g_wszLastDir))
            hr = S_OK;
        
        SHFree(pidl);
    }
    return hr;
}

STDAPI HrAthGetFileName(OPENFILENAME *pofn, BOOL fOpen)
{
    BOOL    fRet;
    LPSTR   pszDir = NULL;
    HRESULT hr = S_OK;

    Assert(pofn != NULL);

    // force NOCHANGEDIR
    pofn->Flags |= OFN_NOCHANGEDIR;

    if (pofn->lpstrInitialDir == NULL)
    {
        if (!PathFileExistsW(g_wszLastDir))
            SideAssert(SetDefaultSpecialFolderPath()==S_OK);
    
        IF_NULLEXIT(pszDir = PszToANSI(CP_ACP, g_wszLastDir));
        
        pofn->lpstrInitialDir = pszDir;
    }

    if (fOpen)
        fRet = GetOpenFileName(pofn);
    else
        fRet = GetSaveFileName(pofn);        
    
    if (fRet)
    {
        // store the last path
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pofn->lpstrFile, lstrlen(pofn->lpstrFile), g_wszLastDir, ARRAYSIZE(g_wszLastDir));
        if (!PathIsDirectoryW(g_wszLastDir))
            PathRemoveFileSpecW(g_wszLastDir);
    }
    else
        TraceResult(hr = E_FAIL);

exit:
    MemFree(pszDir);
    
    return hr;
}

STDAPI HrAthGetFileNameW(OPENFILENAMEW *pofn, BOOL fOpen)
{
    BOOL    fRet;

    Assert(pofn != NULL);

    // force NOCHANGEDIR
    pofn->Flags |= OFN_NOCHANGEDIR;

    if (pofn->lpstrInitialDir == NULL)
    {
        if (!PathFileExistsW(g_wszLastDir))
            SideAssert(SetDefaultSpecialFolderPath()==S_OK);
    
        pofn->lpstrInitialDir = g_wszLastDir;
    }

    if (fOpen)
        fRet = GetOpenFileNameWrapW(pofn);
    else
        fRet = GetSaveFileNameWrapW(pofn);        
    
    if (fRet)
    {
        // store the last path
        StrCpyNW(g_wszLastDir, pofn->lpstrFile, ARRAYSIZE(g_wszLastDir));
        if (!PathIsDirectoryW(g_wszLastDir))
            PathRemoveFileSpecW(g_wszLastDir);
    }
    
    return fRet?S_OK:E_FAIL;
}

STDAPI  HrGetLastOpenFileDirectory(int cchMax, LPSTR lpsz)
{
    if (!PathFileExistsW(g_wszLastDir))
        SideAssert(SetDefaultSpecialFolderPath()==S_OK);

    WideCharToMultiByte(CP_ACP, 0, g_wszLastDir, lstrlenW(g_wszLastDir), lpsz, cchMax, NULL, NULL);
    lpsz[cchMax - 1] = 0;
    return S_OK;
}

STDAPI  HrGetLastOpenFileDirectoryW(int cchMax, LPWSTR lpsz)
{
    if (!PathFileExistsW(g_wszLastDir))
        SideAssert(SetDefaultSpecialFolderPath()==S_OK);

    StrCpyNW(lpsz, g_wszLastDir, cchMax);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\dll\factory.cpp ===
// --------------------------------------------------------------------------------
// Factory.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "factory.h"
#include "ixppop3.h"
#include "ixpsmtp.h"
#include "ixpnntp.h"
#include "ixphttpm.h"
#include "ixpras.h"
#include "imap4.h"
#include "range.h"
#include "olealloc.h"
#include "smime.h"
#include "vstream.h"
#include "icoint.h"
#include "internat.h"
#include "partial.h"
#include "docobj.h"
#include "doc.h"
#include "hash.h"
#include "fontcash.h"
#include "propfind.h"

// --------------------------------------------------------------------------------
// Pretty
// --------------------------------------------------------------------------------
#define OBJTYPE0        0
#define OBJTYPE1        OIF_ALLOWAGGREGATION

// --------------------------------------------------------------------------------
// Global Object Info Table
// --------------------------------------------------------------------------------
static CClassFactory g_rgFactory[] = {
    CClassFactory(&CLSID_IMimePropertySet,    OBJTYPE1, (PFCREATEINSTANCE)WebBookContentBody_CreateInstance),
    CClassFactory(&CLSID_IMimeBody,           OBJTYPE1, (PFCREATEINSTANCE)WebBookContentBody_CreateInstance),
    CClassFactory(&CLSID_IMimeBodyW,          OBJTYPE1, (PFCREATEINSTANCE)WebBookContentBody_CreateInstance),
    CClassFactory(&CLSID_IMimeMessageTree,    OBJTYPE1, (PFCREATEINSTANCE)WebBookContentTree_CreateInstance),
    CClassFactory(&CLSID_IMimeMessage,        OBJTYPE1, (PFCREATEINSTANCE)WebBookContentTree_CreateInstance),
    CClassFactory(&CLSID_IMimeMessageW,       OBJTYPE1, (PFCREATEINSTANCE)WebBookContentTree_CreateInstance),
    CClassFactory(&CLSID_IMimeAllocator,      OBJTYPE0, (PFCREATEINSTANCE)IMimeAllocator_CreateInstance),
    CClassFactory(&CLSID_IMimeSecurity,       OBJTYPE0, (PFCREATEINSTANCE)IMimeSecurity_CreateInstance),
    CClassFactory(&CLSID_IMimeMessageParts,   OBJTYPE0, (PFCREATEINSTANCE)IMimeMessageParts_CreateInstance),
    CClassFactory(&CLSID_IMimeInternational,  OBJTYPE0, (PFCREATEINSTANCE)IMimeInternational_CreateInstance),
    CClassFactory(&CLSID_IMimeHeaderTable,    OBJTYPE0, (PFCREATEINSTANCE)IMimeHeaderTable_CreateInstance),
    CClassFactory(&CLSID_IMimePropertySchema, OBJTYPE0, (PFCREATEINSTANCE)IMimePropertySchema_CreateInstance),
    CClassFactory(&CLSID_IVirtualStream,      OBJTYPE0, (PFCREATEINSTANCE)IVirtualStream_CreateInstance),
    CClassFactory(&CLSID_IMimeHtmlProtocol,   OBJTYPE1, (PFCREATEINSTANCE)IMimeHtmlProtocol_CreateInstance),
    CClassFactory(&CLSID_ISMTPTransport,      OBJTYPE0, (PFCREATEINSTANCE)ISMTPTransport_CreateInstance),
    CClassFactory(&CLSID_IPOP3Transport,      OBJTYPE0, (PFCREATEINSTANCE)IPOP3Transport_CreateInstance),
    CClassFactory(&CLSID_INNTPTransport,      OBJTYPE0, (PFCREATEINSTANCE)INNTPTransport_CreateInstance),
    CClassFactory(&CLSID_IRASTransport,       OBJTYPE0, (PFCREATEINSTANCE)IRASTransport_CreateInstance),
    CClassFactory(&CLSID_IIMAPTransport,      OBJTYPE0, (PFCREATEINSTANCE)IIMAPTransport_CreateInstance),
    CClassFactory(&CLSID_IRangeList,          OBJTYPE0, (PFCREATEINSTANCE)IRangeList_CreateInstance),
    CClassFactory(&CLSID_MimeEdit,            OBJTYPE1, (PFCREATEINSTANCE)MimeEdit_CreateInstance),
    CClassFactory(&CLSID_IHashTable,          OBJTYPE0, (PFCREATEINSTANCE)IHashTable_CreateInstance),
    CClassFactory(&CLSID_IFontCache,          OBJTYPE1, (PFCREATEINSTANCE)CFontCache::CreateInstance),
#ifndef NOHTTPMAIL
    CClassFactory(&CLSID_IHTTPMailTransport,  OBJTYPE0, (PFCREATEINSTANCE)IHTTPMailTransport_CreateInstance),
    CClassFactory(&CLSID_IPropFindRequest,    OBJTYPE0, (PFCREATEINSTANCE)IPropFindRequest_CreateInstance),
    CClassFactory(&CLSID_IPropPatchRequest,   OBJTYPE0, (PFCREATEINSTANCE)IPropPatchRequest_CreateInstance),
#endif

};
                 
// --------------------------------------------------------------------------------
// DllGetClassObject
// --------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // No memory allocator
    if (NULL == g_pMalloc)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            CHECKHR(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, no class
    hr = TrapError(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::CClassFactory
// --------------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

// --------------------------------------------------------------------------------
// CClassFactory::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // Invalid Arg
    if (NULL == ppvObj)
        return TrapError(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TrapError(E_NOINTERFACE);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    DllAddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CClassFactory::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    DllAddRef();
    return 2;
}

// --------------------------------------------------------------------------------
// CClassFactory::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    DllRelease();
    return 1;
}

// --------------------------------------------------------------------------------
// CClassFactory::CreateInstance
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Bad param
    if (ppvObj == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter && IID_IUnknown != riid)
        return TrapError(CLASS_E_NOAGGREGATION);

    // No memory allocator
    if (NULL == g_pMalloc)
        return TrapError(E_OUTOFMEMORY);

    // Can I do aggregaton
    if (pUnkOuter !=NULL && !(m_dwFlags & OIF_ALLOWAGGREGATION))  
        return TrapError(CLASS_E_NOAGGREGATION);

    // Create the object...
    CHECKHR(hr = CreateObjectInstance(pUnkOuter, &pObject));

    // Aggregated, then we know we're looking for an IUnknown, return pObject, otherwise, QI
    if (pUnkOuter)
    {
        // Matches Release after Exit
        pObject->AddRef();

        // Return pObject::IUnknown
        *ppvObj = (LPVOID)pObject;
    }

    // Otherwise
    else
    {
        // Get the interface requested from pObj
        CHECKHR(hr = pObject->QueryInterface(riid, ppvObj));
    }
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::LockServer
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) InterlockedIncrement(&g_cLock);
    else       InterlockedDecrement(&g_cLock);
    return NOERROR;
}

// --------------------------------------------------------------------------------
// CreateRASTransport
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateRASTransport(
          /* out */      IRASTransport **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = new CRASTransport();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CreateNNTPTransport
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateNNTPTransport(
          /* out */      INNTPTransport **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = new CNNTPTransport();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CreateSMTPTransport
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateSMTPTransport(
          /* out */      ISMTPTransport **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = new CSMTPTransport();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CreatePOP3Transport
// --------------------------------------------------------------------------------
IMNXPORTAPI CreatePOP3Transport(
          /* out */      IPOP3Transport **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = new CPOP3Transport();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CreateIMAPTransport
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateIMAPTransport(
          /* out */      IIMAPTransport **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = (IIMAPTransport *) new CImap4Agent();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}


// --------------------------------------------------------------------------------
// CreateIMAPTransport2
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateIMAPTransport2(
          /* out */      IIMAPTransport2 **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = (IIMAPTransport2 *) new CImap4Agent();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}


// --------------------------------------------------------------------------------
// CreateRangeList
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateRangeList(
          /* out */      IRangeList **ppRangeList)
{
    // check params
    if (NULL == ppRangeList)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppRangeList = (IRangeList *) new CRangeList();
    if (NULL == *ppRangeList)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimeAllocator_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeAllocator_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMimeAllocator *pNew = new CMimeAllocator();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMimeAllocator *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimeSecurity_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeSecurity_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CSMime *pNew = new CSMime();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMimeSecurity *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimePropertySchema_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimePropertySchema_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Out of memory
    if (NULL == g_pSymCache)
        return TrapError(E_OUTOFMEMORY);

    // Create me
    *ppUnknown = ((IUnknown *)((IMimePropertySchema *)g_pSymCache));

    // Increase RefCount
    (*ppUnknown)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimeInternational_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeInternational_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Outof memory
    if (NULL == g_pInternat)
        return TrapError(E_OUTOFMEMORY);

    // Assign It
    *ppUnknown = ((IUnknown *)((IMimeInternational *)g_pInternat));

    // Increase RefCount
    (*ppUnknown)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// ISMTPTransport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT ISMTPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CSMTPTransport *pNew = new CSMTPTransport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, ISMTPTransport *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IPOP3Transport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IPOP3Transport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CPOP3Transport *pNew = new CPOP3Transport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IPOP3Transport *);

    // Done
    return S_OK;
}

#ifndef NOHTTPMAIL

// --------------------------------------------------------------------------------
// IHTTPMailTransport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IHTTPMailTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CHTTPMailTransport *pNew = new CHTTPMailTransport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IHTTPMailTransport *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IPropFindRequest_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IPropFindRequest_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CPropFindRequest *pNew = new CPropFindRequest();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IPropFindRequest *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IPropPatchRequest_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IPropPatchRequest_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CPropPatchRequest *pNew = new CPropPatchRequest();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IPropPatchRequest *);

    // Done
    return S_OK;
}

#endif

// --------------------------------------------------------------------------------
// INNTPTransport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT INNTPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CNNTPTransport *pNew = new CNNTPTransport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, INNTPTransport *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IRASTransport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IRASTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CRASTransport *pNew = new CRASTransport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IRASTransport *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IIMAPTransport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IIMAPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CImap4Agent *pNew = new CImap4Agent();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IIMAPTransport *);

    // Done
    return S_OK;
}


// --------------------------------------------------------------------------------
// IRangeList_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IRangeList_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CRangeList *pNew = new CRangeList();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IRangeList *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IVirtualStream_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IVirtualStream_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CVirtualStream *pNew = new CVirtualStream();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IStream *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimeMessageParts_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeMessageParts_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMimeMessageParts *pNew = new CMimeMessageParts();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMimeMessageParts *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimeHeaderTable_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeHeaderTable_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    return TrapError(MimeOleCreateHeaderTable((IMimeHeaderTable **)ppUnknown));
}

// --------------------------------------------------------------------------------
// MimeEdit_CreateInstance
// --------------------------------------------------------------------------------
HRESULT MimeEdit_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CDoc *pNew = new CDoc(pUnkOuter);
    if (NULL == pNew)
        return (E_OUTOFMEMORY);

    // Return the Innter
    *ppUnknown = pNew->GetInner();

    // Done
    return S_OK;
}



// --------------------------------------------------------------------------------
// IHashTable_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IHashTable_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CHash *pNew= new CHash(pUnkOuter);
    if (NULL == pNew)
        return (E_OUTOFMEMORY);

    // Return the Innter
    *ppUnknown = pNew->GetInner();

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\dll\dllmain.h ===
// --------------------------------------------------------------------------------
// Dllmain.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __DLLMAIN_H
#define __DLLMAIN_H

// --------------------------------------------------------------------------------
// Defined later
// --------------------------------------------------------------------------------
class CMimeInternational;
class CMimeAllocator;
class CSMime;
typedef class CMimeActiveUrlCache *LPMHTMLURLCACHE;
typedef class CPropertySymbolCache *LPSYMBOLCACHE;
interface IMLangLineBreakConsole;
interface IFontCache;

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern CRITICAL_SECTION     g_csDllMain;
extern CRITICAL_SECTION     g_csRAS;
extern CRITICAL_SECTION     g_csCounter;
extern CRITICAL_SECTION     g_csMLANG;
extern CRITICAL_SECTION     g_csCSAPI3T1;
extern HINSTANCE            g_hinstMLANG;
extern DWORD                g_dwCompatMode;
extern DWORD                g_dwCounter;     // boundary/cid/mid ratchet
extern LONG                 g_cRef;
extern LONG                 g_cLock;
extern HINSTANCE            g_hInst;
extern HINSTANCE            g_hLocRes;
extern HINSTANCE            g_hinstRAS;
extern HINSTANCE            g_hinstCSAPI3T1;
extern HINSTANCE            g_hCryptoDll;
extern HINSTANCE            g_hAdvApi32;
extern BOOL                 g_fWinsockInit;
extern CMimeInternational  *g_pInternat;
extern DWORD                g_dwSysPageSize;
extern CMimeAllocator *     g_pMoleAlloc;
extern LPSYMBOLCACHE        g_pSymCache;
extern LPMHTMLURLCACHE      g_pUrlCache;  
extern ULONG                g_ulUpperCentury;
extern ULONG                g_ulY2kThreshold;
extern IFontCache          *g_lpIFontCache;

extern HCERTSTORE           g_hCachedStoreMy;
extern HCERTSTORE           g_hCachedStoreAddressBook;


IF_DEBUG(extern DWORD       TAG_SSPI;)

// --------------------------------------------------------------------------------
// IMimeMessage::IDataObject clipboard formats (also CF_TEXT)
// --------------------------------------------------------------------------------
extern UINT		            CF_HTML;
extern UINT                 CF_INETMSG;
extern UINT                 CF_RFC822;

// --------------------------------------------------------------------------------
// String Lengths
// --------------------------------------------------------------------------------
#define CCHMAX_RES          255

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
ULONG DllAddRef(void);
ULONG DllRelease(void);
DWORD DwCounterNext(void);
HRESULT GetTypeLibrary(ITypeLib **ppTypeLib);

HCERTSTORE
WINAPI
OpenCachedHKCUStore(
    IN OUT HCERTSTORE *phStoreCache,
    IN LPCWSTR pwszStore
    );

HCERTSTORE
WINAPI
OpenCachedMyStore();

HCERTSTORE
WINAPI
OpenCachedAddressBookStore();

BOOL fIsNT5();

#endif // __DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\dll\factory.h ===
// --------------------------------------------------------------------------------
// Factory.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __FACTORY_H
#define __FACTORY_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CClassFactory;

// --------------------------------------------------------------------------------
// Object Flags
// --------------------------------------------------------------------------------
#define OIF_ALLOWAGGREGATION  0x0001

// --------------------------------------------------------------------------------
// Object Creation Prototypes
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);
#define CreateObjectInstance (*m_pfCreateInstance)

// --------------------------------------------------------------------------------
// InetComm ClassFactory
// --------------------------------------------------------------------------------
class CClassFactory : public IClassFactory
{
public:
    // ----------------------------------------------------------------------------
    // Public Data
    // ----------------------------------------------------------------------------
    CLSID const        *m_pclsid;
    DWORD               m_dwFlags;
    PFCREATEINSTANCE    m_pfCreateInstance;

    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

    // ----------------------------------------------------------------------------
    // IUnknown members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IClassFactory members
    // ----------------------------------------------------------------------------
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};

// --------------------------------------------------------------------------------
// Object Creators
// --------------------------------------------------------------------------------
HRESULT IVirtualStream_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT WebBookContentBody_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT WebBookContentTree_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeAllocator_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeSecurity_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeInternational_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT ISMTPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IPOP3Transport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT INNTPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IRASTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IIMAPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IHTTPMailTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IPropFindRequest_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IPropPatchRequest_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IRangeList_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeMessageParts_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeHeaderTable_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimePropertySchema_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeBindHost_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IInternetMessageUrl_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeHtmlProtocol_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT MimeEdit_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IHashTable_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);

#endif // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\dll\dllmain.cpp ===
// --------------------------------------------------------------------------------
// Dllmain.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include <shfusion.h>
#define DEFINE_STRING_CONSTANTS
#define DEFINE_STRCONST
#define DEFINE_PROPSYMBOLS
#define DEFINE_TRIGGERS
#include "mimeole.h"
#include "symcache.h"
#include "strconst.h"
#include "htmlstr.h"
#include "thorsspi.h"
#include "sicily.h"
#include "ixputil.h"
#include "olealloc.h"
#include "smime.h"
#include "objheap.h"
#include "internat.h"
#include "icoint.h"
#include "msoert.h"
#include "dllmain.h"
#include "mhtmlurl.h"
#include "mlang.h"
#include <lookup.h>
#include "shared.h"
#include "shlwapi.h"
#include "demand.h"
#include "fontcash.h"
#include "util.h"
#include "resource.h"
#include "../imnxport/asynconn.h"

// --------------------------------------------------------------------------------
// Globals - Object count and lock count
// --------------------------------------------------------------------------------
CRITICAL_SECTION    g_csDllMain={0};
CRITICAL_SECTION    g_csRAS={0};
CRITICAL_SECTION    g_csCounter={0};
CRITICAL_SECTION    g_csMLANG={0};
CRITICAL_SECTION    g_csCSAPI3T1={0};
BOOL                g_fAttached = FALSE;
DWORD               g_dwCounter=0;       // boundary/cid/mid ratchet
LONG                g_cRef=0;
LONG                g_cLock=0;
HINSTANCE           g_hInst=NULL;
HINSTANCE           g_hLocRes=NULL;
CMimeInternational *g_pInternat=NULL;
BOOL                g_fWinsockInit=FALSE;
DWORD               g_dwSysPageSize;
UINT                CF_HTML=0;
UINT                CF_INETMSG=0;
UINT                CF_RFC822=0;
CMimeAllocator *    g_pMoleAlloc=NULL;
LPINETCSETINFO      g_pDefBodyCset=NULL;
LPINETCSETINFO      g_pDefHeadCset=NULL;
LPSYMBOLCACHE       g_pSymCache=NULL;
IMalloc            *g_pMalloc=NULL;
HINSTANCE           g_hinstMLANG=NULL;
HINSTANCE           g_hinstRAS=NULL;
HINSTANCE           g_hinstCSAPI3T1=NULL;
LPMHTMLURLCACHE     g_pUrlCache=NULL;
BOOL                g_fCanEditBiDi=FALSE;
DWORD               g_dwCompatMode=0;
IF_DEBUG(DWORD      TAG_SSPI=0);
SYSTEM_INFO         g_SystemInfo={0};
OSVERSIONINFO       g_OSInfo={0};
ULONG               g_ulUpperCentury = 0;
ULONG               g_ulY2kThreshold = 2029;
IFontCache         *g_lpIFontCache=NULL;

HCERTSTORE          g_hCachedStoreMy = NULL;
HCERTSTORE          g_hCachedStoreAddressBook = NULL;
LPSRVIGNORABLEERROR g_pSrvErrRoot = NULL;

BOOL fIsNT5()        { return((g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_OSInfo.dwMajorVersion >= 5)); }

// --------------------------------------------------------------------------------
// Debug Globals
// --------------------------------------------------------------------------------
#ifdef DEBUG
DWORD               dwDOUTLevel=0;
DWORD               dwDOUTLMod=0;
DWORD               dwDOUTLModLevel=0;
#endif

#ifdef WIN16
// --------------------------------------------------------------------------------
// From main.c of the build
// --------------------------------------------------------------------------------
extern "C" { void FreeGlobalVars(); };
#endif

#ifdef SMIME_V3
STDAPI EssRegisterServer(void);
BOOL WINAPI EssASNDllMain(HMODULE hInst, ULONG ulReason, LPVOID lpv);
#endif // SMIME_V3

HRESULT GetDllPathName(WCHAR **ppszW);

// These lines should be hardcoded! (YST)
static const TCHAR sc_szLangDll[]         = "INETRES.DLL";

// --------------------------------------------------------------------------------
// GetDllMajorVersion
// --------------------------------------------------------------------------------
STDAPI_(OEDLLVERSION) GetDllMajorVersion(void)
{
    return OEDLL_VERSION_CURRENT;
}

extern BOOL CanEditBiDi(void);
// --------------------------------------------------------------------------------
// InitGlobalVars
// --------------------------------------------------------------------------------
void InitGlobalVars(void)
{
    // Locals
    SYSTEM_INFO rSystemInfo;
    TCHAR szY2kThreshold[16];
    TCHAR rgch[MAX_PATH];
    HKEY hkey = NULL;
    HRESULT hr;
    DWORD cb;

    // Initialize Global Critical Sections
    InitializeCriticalSection(&g_csDllMain);
    InitializeCriticalSection(&g_csRAS);
    InitializeCriticalSection(&g_csCounter);
    InitializeCriticalSection(&g_csMLANG);
    InitializeCriticalSection(&g_csCSAPI3T1);
    g_fAttached = TRUE;

    // This for the winsock multi-thread hostname lookup
    InitLookupCache();

    // Get System & OS Info
    GetPCAndOSTypes(&g_SystemInfo, &g_OSInfo);
    g_dwSysPageSize = g_SystemInfo.dwPageSize;

    // Create OLE Task Memory Allocator
    CoGetMalloc(1, &g_pMalloc);
    Assert(g_pMalloc);

    // Create our global allocator
    g_pMoleAlloc = new CMimeAllocator;
    Assert(g_pMoleAlloc);
    
    // Security Initialize
    SecurityInitialize();

    // Initialize Demand-loaded Libs
    InitDemandLoadedLibs();

    // INit crit sect
    g_pSymCache = new CPropertySymbolCache;
    Assert(g_pSymCache);

    // Initialize the Symbol Table
    SideAssert(SUCCEEDED(g_pSymCache->Init()));

    // Init Body Object Heap
    InitObjectHeaps();

    // Init International
    InitInternational();

    // Init ActiveUrl Cache
    g_pUrlCache = new CMimeActiveUrlCache;
    Assert(g_pUrlCache);

    // Check if the system can edit Bidi documents
    g_fCanEditBiDi = CanEditBiDi();
    
    // Register clipboard formats
    CF_HTML = RegisterClipboardFormat(STR_CF_HTML);
    Assert(CF_HTML != 0);
    CF_INETMSG = RegisterClipboardFormat(STR_CF_INETMSG);
    Assert(CF_INETMSG != 0);
    CF_RFC822 = RegisterClipboardFormat(STR_CF_RFC822);
    Assert(CF_RFC822 != 0);

    // --- Calculate Y2K cut off information
    // See http://officeweb/specs/excel/CYu/nty2k.htm
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REG_Y2K_THRESHOLD, 0, KEY_READ, &hkey))
    {
        cb = sizeof(szY2kThreshold);
        if(ERROR_SUCCESS == RegQueryValueEx(hkey, "1", NULL, NULL, (LPBYTE)szY2kThreshold, &cb))
        {
            g_ulY2kThreshold = (ULONG)StrToInt(szY2kThreshold);
        }
        RegCloseKey(hkey);
    }

    g_ulUpperCentury = g_ulY2kThreshold / 100;
    g_ulY2kThreshold %= 100;

    // Create the Font Cache Object

    if (NULL == g_lpIFontCache)
    {
        hr = CFontCache::CreateInstance(NULL, (IUnknown **)&g_lpIFontCache);        
        
        if(SUCCEEDED(hr))
        {
            StrCpyN(rgch, c_szExplorerRegPath, ARRAYSIZE(rgch));
            StrCatBuff(rgch, "\\International", ARRAYSIZE(rgch));
            hr = g_lpIFontCache->Init(HKEY_CURRENT_USER, rgch, 0);            
        }
        
        if(FAILED(hr))
        {
            AthMessageBox(HWND_DESKTOP, MAKEINTRESOURCE(IDS_APPNAME), MAKEINTRESOURCE(idsFontCacheError),
                NULL, MB_OK | MB_ICONSTOP);
        }
    }
}

// --------------------------------------------------------------------------------
// FreeGlobalVars
// --------------------------------------------------------------------------------
void FreeGlobalVars(void)
{
    // Server ignorable errors
    if(g_pSrvErrRoot)
        FreeSrvErr(g_pSrvErrRoot);

    // Cache stores
    if (g_hCachedStoreMy)
        CertCloseStore(g_hCachedStoreMy, 0);
    if (g_hCachedStoreAddressBook)
        CertCloseStore(g_hCachedStoreAddressBook, 0);

    // Release ActiveUrlCache
    Assert(g_pUrlCache);
    SafeRelease(g_pUrlCache);

    // Free Address Info Heap (must be before release of g_pSymCache)
    FreeObjectHeaps();

    // Release Symbol CAche
    Assert(g_pSymCache);
    SafeRelease(g_pSymCache);

    // Unload RAS Dll
    EnterCriticalSection(&g_csRAS);
    SafeFreeLibrary(g_hinstRAS);
    LeaveCriticalSection(&g_csRAS);

    // Uninitialize Security
    SSPIUninitialize();
    UnloadSecurity();

    // Unload S/MIME
    CSMime::UnloadAll();

    // Must be before UnInitializeWinsock()
    DeInitLookupCache();

    // Cleanup Winsock
    if (g_fWinsockInit)
        UnInitializeWinsock();

    // Free libraries that demand.cpp loaded
    FreeDemandLoadedLibs();

    // Free CSAPI3T1
    EnterCriticalSection(&g_csCSAPI3T1);
    SafeFreeLibrary(g_hinstCSAPI3T1);
    LeaveCriticalSection(&g_csCSAPI3T1);

    // Free mlang lib
    EnterCriticalSection(&g_csMLANG);
    SafeFreeLibrary(g_hinstMLANG);
    LeaveCriticalSection(&g_csMLANG);

    // Release Font Cache
    SafeRelease(g_lpIFontCache);

    // Release g_pInternat
    Assert(g_pInternat);
    SafeRelease(g_pInternat);

    // Free INETRES.DLL (g_hLocRes)
    SafeFreeLibrary(g_hLocRes);

    // Delete Global Critical Sections
    g_fAttached = FALSE;
    DeleteCriticalSection(&g_csCSAPI3T1);
    DeleteCriticalSection(&g_csMLANG);
    DeleteCriticalSection(&g_csCounter);
    DeleteCriticalSection(&g_csRAS);
    DeleteCriticalSection(&g_csDllMain);

    // Release Global Memory allocator
    SafeRelease(g_pMoleAlloc);
    
    // Release Global Memory allocator
    SafeRelease(g_pMalloc); 
    
    //Don't SafeRelease() anything after here, as the allocator has been Released()

#ifdef WIN16
    // Need uninitialize it to clean the ole garbage.
    CoUninitialize();
#endif // WIN16
}

#ifndef WIN16
// --------------------------------------------------------------------------------
// Win32 Dll Entry Point
// --------------------------------------------------------------------------------
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Handle Attach - detach reason
    switch (dwReason)                 
    {
    case DLL_PROCESS_ATTACH:
         SHFusionInitialize(NULL);
#ifdef DEBUG
        dwDOUTLevel=GetPrivateProfileInt("Debug", "ICLevel", 0, "athena.ini");
        dwDOUTLMod=GetPrivateProfileInt("Debug", "Mod", 0, "athena.ini");
        dwDOUTLModLevel=GetPrivateProfileInt("Debug", "ModLevel", 0, "athena.ini");
        TAG_SSPI = GetDebugTraceTagMask("InetCommSSPI", TAG_SSPI);
#endif
        g_hInst = hInst;
        g_hLocRes = LoadLangDll(g_hInst, c_szInetResDll, fIsNT5());
        if(g_hLocRes == NULL)
        {
            Assert(FALSE);
            return FALSE;
        }
        InitGlobalVars();        
        SideAssert(DisableThreadLibraryCalls(hInst));

#ifdef SMIME_V3
        if (!EssASNDllMain(hInst, dwReason, lpReserved)) {
            return FALSE;
        }
#endif // SMIME_V3
        break;

    case DLL_PROCESS_DETACH:
#ifdef SMIME_V3
        if (!EssASNDllMain(hInst, dwReason, lpReserved)) {
            return FALSE;
        }
#endif // SMIME_V3
        FreeGlobalVars();
        SHFusionUninitialize();
        break;
    }

    // Done
    return TRUE;
}

#else
// --------------------------------------------------------------------------------
// Win16 Dll Entry Point
// --------------------------------------------------------------------------------
BOOL FAR PASCAL LibMain (HINSTANCE hDll, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine)
{
    // Win16 specific
    CoInitialize(NULL);

    // Set global instance handle
    g_hInst = hDll;

    // Initialize Global Variables
    InitGlobalVars();

#ifdef DEBUG
    dwDOUTLevel=GetPrivateProfileInt("Debug", "ICLevel", 0, "athena.ini");
    dwDOUTLMod=GetPrivateProfileInt("Debug", "Mod", 0, "athena.ini");
    dwDOUTLModLevel=GetPrivateProfileInt("Debug", "ModLevel", 0, "athena.ini");
#endif

    // Done
    return TRUE;
}
#endif // !WIN16

// --------------------------------------------------------------------------------
// DwCounterNext
// --------------------------------------------------------------------------------
DWORD DwCounterNext(void)
{
    EnterCriticalSection(&g_csCounter);
    DWORD dwCounter = g_dwCounter++;
    LeaveCriticalSection(&g_csCounter);
    return dwCounter;
}

// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    TraceCall("DllAddRef");
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    TraceCall("DllRelease");
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    // Tracing
    TraceCall("DllCanUnloadNow");

    if(!g_fAttached)   // critacal sections was deleted (or not created): we defently can be unloaded
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Trace This
    // DebugTrace("DllCanUnloadNow: %s - Reference Count: %d, LockServer Count: %d\n", __FILE__, g_cRef, g_cLock);

    // Can We Unload
    HRESULT hr = (0 == g_cRef && 0 == g_cLock) ? S_OK : S_FALSE;

    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// RegTypeLib
// --------------------------------------------------------------------------------
__inline HRESULT RegTypeLib(HINSTANCE hInstRes)
{
    AssertSz(hInstRes,    "[ARGS] RegTypeLib: NULL hInstRes");
    
    HRESULT     hr = E_FAIL;
    CHAR        szDll[MAX_PATH];
    WCHAR       wszDll[MAX_PATH];

    GetModuleFileName(hInstRes, szDll, ARRAYSIZE(szDll));

    // Convert the module path to Wide-String
    if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szDll, -1, wszDll, ARRAYSIZE(wszDll)))
    {
        ITypeLib   *pTypeLib;

        hr = LoadTypeLib(wszDll, &pTypeLib);
        if (SUCCEEDED(hr))
        {
            // Register the typelib
            hr = RegisterTypeLib(pTypeLib, wszDll, NULL);
            pTypeLib->Release();
        }
    }

    return hr;
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("DllRegisterServer");

#ifdef SMIME_V3
    //  Register the ESS routines
    hr = EssRegisterServer();
    if (FAILED(hr)) {
        return hr;
    }
#endif // SMIME_V3

    // CallRegInstall and RegTypeLib are in staticRT/shared.cpp
    if (SUCCEEDED(hr = CallRegInstall(g_hInst, g_hInst, c_szReg, NULL)))
        return RegTypeLib(g_hInst);
    else
        return hr;

}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("DllUnregisterServer");

    // UnRegister
    IF_FAILEXIT(hr = CallRegInstall(g_hInst, g_hInst, c_szUnReg, NULL));

exit:
    // Done
    return hr;
}

HRESULT GetTypeLibrary(ITypeLib **ppTypeLib)
{
    HRESULT     hr;
    WCHAR       *pszModuleW=0;

    hr = GetDllPathName(&pszModuleW);
    if (!FAILED(hr))
        {
        hr = LoadTypeLib(pszModuleW, ppTypeLib);
        SafeMemFree(pszModuleW);
        }
    return hr;
}

HRESULT GetDllPathName(WCHAR **ppszW)
{
    HRESULT     hr;
    TCHAR       rgch[MAX_PATH];
    WCHAR       *pszModuleW=0;

    *ppszW=NULL;

    if (!GetModuleFileName(g_hInst, rgch, sizeof(rgch)/sizeof(TCHAR)))
        return E_FAIL;
   
    *ppszW = PszToUnicode(CP_ACP, rgch);
    return *ppszW ? S_OK : E_OUTOFMEMORY;
}


HCERTSTORE
WINAPI
OpenCachedHKCUStore(
    IN OUT HCERTSTORE *phStoreCache,
    IN LPCWSTR pwszStore
    )
{
    HCERTSTORE hStore;

    // This caching optimization is only supported on WXP

    if (g_OSInfo.dwPlatformId != VER_PLATFORM_WIN32_NT ||
            g_OSInfo.dwMajorVersion < 5 ||
            (g_OSInfo.dwMajorVersion == 5 && g_OSInfo.dwMinorVersion < 1))
    {
        return CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            0,
            NULL,
            CERT_SYSTEM_STORE_CURRENT_USER |
                CERT_STORE_MAXIMUM_ALLOWED_FLAG,
            (const void *) pwszStore
            );
    }

    hStore = *phStoreCache;
    if (NULL == hStore) {
        hStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            0,
            NULL,
            CERT_SYSTEM_STORE_CURRENT_USER |
                CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                CERT_STORE_SHARE_CONTEXT_FLAG,
            (const void *) pwszStore
            );

        if (hStore) {
            HCERTSTORE hPrevStore;

            CertControlStore(
                hStore,
                0,                  // dwFlags
                CERT_STORE_CTRL_AUTO_RESYNC,
                NULL                // pvCtrlPara
                );

            hPrevStore = InterlockedCompareExchangePointer(
                phStoreCache, hStore, NULL);

            if (hPrevStore) {
                CertCloseStore(hStore, 0);
                hStore = hPrevStore;
            }
        }
    }

    if (hStore)
        hStore = CertDuplicateStore(hStore);

    return hStore;
}

HCERTSTORE
WINAPI
OpenCachedMyStore()
{
    return OpenCachedHKCUStore(&g_hCachedStoreMy, L"My");
}

HCERTSTORE
WINAPI
OpenCachedAddressBookStore()
{
    return OpenCachedHKCUStore(&g_hCachedStoreAddressBook, L"AddressBook");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//	File:		debug.cpp
//
//	Contents:	Debug sub system APIs implementation
//
//
//	03/20/96    kevinr      wrote it
//  04/17/96    kevinr      added OSS init
//  05-Sep-1997 pberkman    added sub-system debug.
//
//----------------------------------------------------------------------------
#ifdef SMIME_V3

#if DBG

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <memory.h>
#include <string.h>
#include <process.h>
#include <time.h>
#include <crtdbg.h>
#include <asn1code.h>

#include "badstrfunctions.h"

//#include "regtest.h"          // JLS

#include "dbgdef.h"

// set DEBUG_MASK=0x26
LPSTR pszDEBUG_MASK = "DEBUG_MASK";
#define DEBUG_MASK_DELAY_FREE_MEM   _CRTDBG_DELAY_FREE_MEM_DF /* 0x02 */
#define DEBUG_MASK_CHECK_ALWAYS     _CRTDBG_CHECK_ALWAYS_DF   /* 0x04 */
#define DEBUG_MASK_LEAK_CHECK       _CRTDBG_LEAK_CHECK_DF     /* 0x20 */
#define DEBUG_MASK_MEM \
(DEBUG_MASK_DELAY_FREE_MEM | DEBUG_MASK_CHECK_ALWAYS | DEBUG_MASK_LEAK_CHECK)


// from asn1code.h:
//      #define DEBUGPDU     0x02 /* produce tracing output */
//      #define DEBUG_ERRORS 0x10 /* print decoder errors to output */
// set OSS_DEBUG_MASK=0x02        
// set OSS_DEBUG_MASK=0x10        - only print decoder errors
LPSTR pszOSS_DEBUG_MASK = "OSS_DEBUG_MASK";

// receives trace output
LPSTR pszOSS_DEBUG_TRACEFILE = "OSS_DEBUG_TRACEFILE";

static char  *pszDEBUG_PRINT_MASK   = "DEBUG_PRINT_MASK";
static char  *pszDefualtSSTag       = "ISPU";

static DBG_SS_TAG sSSTags[]         = __DBG_SS_TAGS;

#if 0 // JLS
// 
//+-------------------------------------------------------------------------
//
//  Pithy stubs to create stdcall proc from cdecl
//
//--------------------------------------------------------------------------
void*
_stdcall
scMalloc( size_t size)
{
    return malloc(size);
}

void*
_stdcall
scRealloc( void *memblock, size_t size)
{
    return realloc(memblock, size);
}

void
_stdcall
scFree( void *memblock)
{
    free(memblock);
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgGetDebugFlags
//
//  Synopsis:  Get the debug flags.
//
//  Returns:   the debug flags
//
//--------------------------------------------------------------------------
int
WINAPI
DbgGetDebugFlags()
{
    char    *pszEnvVar;
    char    *p;
    int     iDebugFlags = 0;

    if (pszEnvVar = getenv( pszDEBUG_MASK))
        iDebugFlags = strtol( pszEnvVar, &p, 16);

    return iDebugFlags;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgProcessAttach
//
//  Synopsis:  Handle process attach.
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgProcessAttach()
{
    int     tmpFlag;

#ifdef _DEBUG

    tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );    // get current
    tmpFlag |=  DbgGetDebugFlags();     // enable flags
    tmpFlag &= ~_CRTDBG_CHECK_CRT_DF;   // disable CRT block checking
    _CrtSetDbgFlag( tmpFlag);           // set new value
#endif

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgProcessDetach
//
//  Synopsis:  Handle process detach.
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgProcessDetach()
{
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgInitOSS
//
//  Synopsis:  Do OSS init for debug.
//
//  Returns:   TRUE
//
//  Note:      Always FRONT_ALIGN encoding
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgInitOSS(
        OssGlobal   *pog)
{
    char    *pszEnvVar;
    char    *p;

    // from asn1code.h:
    //      #define DEBUGPDU 0x02     /* produce tracing output */
    //      #define DEBUG_ERRORS 0x10 /* print decoder errors to output */
    // set OSS_DEBUG_MASK=0x02
    // set OSS_DEBUG_MASK=0x10        - only print decoder errors
    if (pszEnvVar = getenv( pszOSS_DEBUG_MASK)) {
        unsigned long ulEnvVar;
        ulEnvVar = strtoul( pszEnvVar, &p, 16) & (DEBUGPDU | DEBUG_ERRORS);
        if ( ulEnvVar)
            ossSetDecodingFlags( pog, ulEnvVar | RELAXBER);
        if ( DEBUGPDU & ulEnvVar)
            ossSetEncodingFlags( pog, DEBUGPDU | FRONT_ALIGN);
        else
            ossSetEncodingFlags( pog, FRONT_ALIGN);
    } else {
        ossSetDecodingFlags( pog, DEBUG_ERRORS | RELAXBER);
        ossSetEncodingFlags( pog, FRONT_ALIGN);
    }

    if (pszEnvVar = getenv( pszOSS_DEBUG_TRACEFILE))
        ossOpenTraceFile( pog, pszEnvVar);

#ifdef _DEBUG
    if (DbgGetDebugFlags() & DEBUG_MASK_MEM) {
        pog->mallocp = scMalloc;
        pog->reallocp = scRealloc;
        pog->freep = scFree;
    }
#else
    pog->mallocp = scMalloc;
    pog->reallocp = scRealloc;
    pog->freep = scFree;
#endif
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:  DebugDllMain
//
//  Synopsis:  Initialize the debug DLL
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DebugDllMain(
        HMODULE hInst,
        ULONG   ulReason,
        LPVOID  lpReserved)
{
    BOOL    fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        fRet = DbgProcessAttach();
        //        fRet &= RegTestInit();        // JLS
        break;

    case DLL_PROCESS_DETACH:
        fRet = DbgProcessDetach();
        //        RegTestCleanup();             // JLS
        break;

    default:
        break;
    }

  return fRet;
}


const char *DbgGetSSString(DWORD dwSubSystemId)
{
    DBG_SS_TAG  *psSS;

    psSS = &sSSTags[0];

    while (psSS->dwSS > 0)
    {
        if ((psSS->dwSS & dwSubSystemId) > 0)
        {
            if (psSS->pszTag)
            {
                return(psSS->pszTag);
            }

            return(pszDefualtSSTag);
        }

        psSS++;
    }

    return(pszDefualtSSTag);
}

static BOOL DbgIsSSActive(DWORD dwSSIn)
{
    char    *pszEnvVar;
    DWORD   dwEnv;

    dwEnv = 0;

    if (pszEnvVar = getenv(pszDEBUG_PRINT_MASK))
    {
        dwEnv = (DWORD)strtol(pszEnvVar, NULL, 16);
    }


    return((dwEnv & dwSSIn) > 0);
}

//+-------------------------------------------------------------------------
//
//  Function:  DbgPrintf
//
//  Synopsis:  outputs debug info to stdout and debugger
//
//  Returns:   number of chars output
//
//--------------------------------------------------------------------------
int WINAPIV DbgPrintf(DWORD dwSubSystemId, LPCSTR lpFmt, ...)
{
    va_list arglist;
    CHAR    ach1[1024];
    CHAR    ach2[1080];
    int     cch;
    HANDLE  hStdOut;
    DWORD   cb;
    DWORD   dwErr;

    dwErr = GetLastError();

    if (!(DbgIsSSActive(dwSubSystemId)))
    {
        SetLastError(dwErr);
        return(0);
    }

    _try 
    {
        va_start(arglist, lpFmt);

        wvnsprintf( ach1, ARRAYSIZE(ach1), lpFmt, arglist);

        va_end(arglist);

        cch = wnsprintf(ach2, ARRAYSZIE(ach2),"%s: %s", DbgGetSSString(dwSubSystemId), ach1);

        hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

        if (hStdOut != INVALID_HANDLE_VALUE)
        {
            WriteConsole( hStdOut, ach2, strlen(ach2), &cb, NULL);
        }

        OutputDebugString(ach2);

    } _except( EXCEPTION_EXECUTE_HANDLER) 
    {
        // return failure
        cch = 0;
    }
    SetLastError(dwErr);
    return cch;
}
#else  // !0 // JLS
int WINAPIV DbgPrintf(DWORD dwSubSystemId, LPCSTR lpFmt, ...)
{
    return 0;
}
#endif // 0 JLS


#endif // DBG
#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\ess.cpp ===
#include <windows.h>
#include <windows.h>

#include "badstrfunctions.h"

#include "msber.h"
#include "crypttls.h"
#include "demand2.h"
#include "ess.h"
#include "msber.inl"

ASN1module_t ESS_Module = NULL;

static int ASN1CALL ASN1Enc_SigningCertificate_policies(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate_policies *val);
static int ASN1CALL ASN1Enc_SigningCertificate_certs(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate_certs *val);
static int ASN1CALL ASN1Enc_MLReceiptPolicy_inAdditionTo(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy_inAdditionTo *val);
static int ASN1CALL ASN1Enc_MLReceiptPolicy_insteadOf(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy_insteadOf *val);
static int ASN1CALL ASN1Enc_ReceiptsFrom_receiptList(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptsFrom_receiptList *val);
static int ASN1CALL ASN1Enc_ReceiptRequest_receiptsTo(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptRequest_receiptsTo *val);
static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Enc_ReceiptsFrom(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptsFrom *val);
static int ASN1CALL ASN1Enc_Receipt(ASN1encoding_t enc, ASN1uint32_t tag, Receipt *val);
static int ASN1CALL ASN1Enc_ContentHints(ASN1encoding_t enc, ASN1uint32_t tag, ContentHints *val);
static int ASN1CALL ASN1Enc_ContentReference(ASN1encoding_t enc, ASN1uint32_t tag, ContentReference *val);
static int ASN1CALL ASN1Enc_ESSPrivacyMark(ASN1encoding_t enc, ASN1uint32_t tag, ESSPrivacyMark *val);
static int ASN1CALL ASN1Enc_SecurityCategories(ASN1encoding_t enc, ASN1uint32_t tag, SecurityCategories *val);
static int ASN1CALL ASN1Enc_SecurityCategory(ASN1encoding_t enc, ASN1uint32_t tag, SecurityCategory *val);
static int ASN1CALL ASN1Enc_EquivalentLabels(ASN1encoding_t enc, ASN1uint32_t tag, EquivalentLabels *val);
static int ASN1CALL ASN1Enc_MLExpansionHistory(ASN1encoding_t enc, ASN1uint32_t tag, MLExpansionHistory *val);
static int ASN1CALL ASN1Enc_EntityIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EntityIdentifier *val);
static int ASN1CALL ASN1Enc_MLReceiptPolicy(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy *val);
static int ASN1CALL ASN1Enc_SigningCertificate(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate *val);
static int ASN1CALL ASN1Enc_ReceiptRequest(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptRequest *val);
static int ASN1CALL ASN1Enc_ESSSecurityLabel(ASN1encoding_t enc, ASN1uint32_t tag, ESSSecurityLabel *val);
static int ASN1CALL ASN1Enc_MLData(ASN1encoding_t enc, ASN1uint32_t tag, MLData *val);
static int ASN1CALL ASN1Enc_ESSCertID(ASN1encoding_t enc, ASN1uint32_t tag, ESSCertID *val);
static int ASN1CALL ASN1Enc_SMimeEncryptCerts(ASN1encoding_t enc, ASN1uint32_t tag, SMimeEncryptCerts *val);
static int ASN1CALL ASN1Enc_SMIMECapabilities(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapabilities *val);
static int ASN1CALL ASN1Enc_SMIMECapability(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapability *val);
static int ASN1CALL ASN1Enc_OtherKeyAttribute(ASN1encoding_t enc, ASN1uint32_t tag, OtherKeyAttribute *val);
static int ASN1CALL ASN1Enc_SMimeEncryptCert(ASN1encoding_t enc, ASN1uint32_t tag, SMimeEncryptCert *val);
static int ASN1CALL ASN1Enc_RecipientKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientKeyIdentifier *val);
static int ASN1CALL ASN1Enc_SMIMEEncryptionKeyPreference(ASN1encoding_t enc, ASN1uint32_t tag, SMIMEEncryptionKeyPreference *val);
static int ASN1CALL ASN1Dec_SigningCertificate_policies(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate_policies *val);
static int ASN1CALL ASN1Dec_SigningCertificate_certs(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate_certs *val);
static int ASN1CALL ASN1Dec_MLReceiptPolicy_inAdditionTo(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy_inAdditionTo *val);
static int ASN1CALL ASN1Dec_MLReceiptPolicy_insteadOf(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy_insteadOf *val);
static int ASN1CALL ASN1Dec_ReceiptsFrom_receiptList(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptsFrom_receiptList *val);
static int ASN1CALL ASN1Dec_ReceiptRequest_receiptsTo(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptRequest_receiptsTo *val);
static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Dec_ReceiptsFrom(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptsFrom *val);
static int ASN1CALL ASN1Dec_Receipt(ASN1decoding_t dec, ASN1uint32_t tag, Receipt *val);
static int ASN1CALL ASN1Dec_ContentHints(ASN1decoding_t dec, ASN1uint32_t tag, ContentHints *val);
static int ASN1CALL ASN1Dec_ContentReference(ASN1decoding_t dec, ASN1uint32_t tag, ContentReference *val);
static int ASN1CALL ASN1Dec_ESSPrivacyMark(ASN1decoding_t dec, ASN1uint32_t tag, ESSPrivacyMark *val);
static int ASN1CALL ASN1Dec_SecurityCategories(ASN1decoding_t dec, ASN1uint32_t tag, SecurityCategories *val);
static int ASN1CALL ASN1Dec_SecurityCategory(ASN1decoding_t dec, ASN1uint32_t tag, SecurityCategory *val);
static int ASN1CALL ASN1Dec_EquivalentLabels(ASN1decoding_t dec, ASN1uint32_t tag, EquivalentLabels *val);
static int ASN1CALL ASN1Dec_MLExpansionHistory(ASN1decoding_t dec, ASN1uint32_t tag, MLExpansionHistory *val);
static int ASN1CALL ASN1Dec_EntityIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EntityIdentifier *val);
static int ASN1CALL ASN1Dec_MLReceiptPolicy(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy *val);
static int ASN1CALL ASN1Dec_SigningCertificate(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate *val);
static int ASN1CALL ASN1Dec_ReceiptRequest(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptRequest *val);
static int ASN1CALL ASN1Dec_ESSSecurityLabel(ASN1decoding_t dec, ASN1uint32_t tag, ESSSecurityLabel *val);
static int ASN1CALL ASN1Dec_MLData(ASN1decoding_t dec, ASN1uint32_t tag, MLData *val);
static int ASN1CALL ASN1Dec_ESSCertID(ASN1decoding_t dec, ASN1uint32_t tag, ESSCertID *val);
static int ASN1CALL ASN1Dec_SMimeEncryptCerts(ASN1decoding_t dec, ASN1uint32_t tag, SMimeEncryptCerts *val);
static int ASN1CALL ASN1Dec_SMIMECapabilities(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapabilities *val);
static int ASN1CALL ASN1Dec_SMIMECapability(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapability *val);
static int ASN1CALL ASN1Dec_OtherKeyAttribute(ASN1decoding_t dec, ASN1uint32_t tag, OtherKeyAttribute *val);
static int ASN1CALL ASN1Dec_SMimeEncryptCert(ASN1decoding_t dec, ASN1uint32_t tag, SMimeEncryptCert *val);
static int ASN1CALL ASN1Dec_RecipientKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientKeyIdentifier *val);
static int ASN1CALL ASN1Dec_SMIMEEncryptionKeyPreference(ASN1decoding_t dec, ASN1uint32_t tag, SMIMEEncryptionKeyPreference *val);
static void ASN1CALL ASN1Free_SigningCertificate_policies(SigningCertificate_policies *val);
static void ASN1CALL ASN1Free_SigningCertificate_certs(SigningCertificate_certs *val);
static void ASN1CALL ASN1Free_MLReceiptPolicy_inAdditionTo(MLReceiptPolicy_inAdditionTo *val);
static void ASN1CALL ASN1Free_MLReceiptPolicy_insteadOf(MLReceiptPolicy_insteadOf *val);
static void ASN1CALL ASN1Free_ReceiptsFrom_receiptList(ReceiptsFrom_receiptList *val);
static void ASN1CALL ASN1Free_ReceiptRequest_receiptsTo(ReceiptRequest_receiptsTo *val);
static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val);
static void ASN1CALL ASN1Free_ReceiptsFrom(ReceiptsFrom *val);
static void ASN1CALL ASN1Free_Receipt(Receipt *val);
static void ASN1CALL ASN1Free_ContentHints(ContentHints *val);
static void ASN1CALL ASN1Free_ContentReference(ContentReference *val);
static void ASN1CALL ASN1Free_ESSPrivacyMark(ESSPrivacyMark *val);
static void ASN1CALL ASN1Free_SecurityCategories(SecurityCategories *val);
static void ASN1CALL ASN1Free_SecurityCategory(SecurityCategory *val);
static void ASN1CALL ASN1Free_EquivalentLabels(EquivalentLabels *val);
static void ASN1CALL ASN1Free_MLExpansionHistory(MLExpansionHistory *val);
static void ASN1CALL ASN1Free_EntityIdentifier(EntityIdentifier *val);
static void ASN1CALL ASN1Free_MLReceiptPolicy(MLReceiptPolicy *val);
static void ASN1CALL ASN1Free_SigningCertificate(SigningCertificate *val);
static void ASN1CALL ASN1Free_ReceiptRequest(ReceiptRequest *val);
static void ASN1CALL ASN1Free_ESSSecurityLabel(ESSSecurityLabel *val);
static void ASN1CALL ASN1Free_MLData(MLData *val);
static void ASN1CALL ASN1Free_ESSCertID(ESSCertID *val);
static void ASN1CALL ASN1Free_SMimeEncryptCerts(SMimeEncryptCerts *val);
static void ASN1CALL ASN1Free_SMIMECapabilities(SMIMECapabilities *val);
static void ASN1CALL ASN1Free_SMIMECapability(SMIMECapability *val);
static void ASN1CALL ASN1Free_OtherKeyAttribute(OtherKeyAttribute *val);
static void ASN1CALL ASN1Free_SMimeEncryptCert(SMimeEncryptCert *val);
static void ASN1CALL ASN1Free_RecipientKeyIdentifier(RecipientKeyIdentifier *val);
static void ASN1CALL ASN1Free_SMIMEEncryptionKeyPreference(SMIMEEncryptionKeyPreference *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[10] = {
    (ASN1EncFun_t) ASN1Enc_Receipt,
    (ASN1EncFun_t) ASN1Enc_ContentHints,
    (ASN1EncFun_t) ASN1Enc_ContentReference,
    (ASN1EncFun_t) ASN1Enc_EquivalentLabels,
    (ASN1EncFun_t) ASN1Enc_MLExpansionHistory,
    (ASN1EncFun_t) ASN1Enc_SigningCertificate,
    (ASN1EncFun_t) ASN1Enc_SMimeEncryptCerts,
    (ASN1EncFun_t) ASN1Enc_ReceiptRequest,
    (ASN1EncFun_t) ASN1Enc_SMIMEEncryptionKeyPreference,
    (ASN1EncFun_t) ASN1Enc_ESSSecurityLabel,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[10] = {
    (ASN1DecFun_t) ASN1Dec_Receipt,
    (ASN1DecFun_t) ASN1Dec_ContentHints,
    (ASN1DecFun_t) ASN1Dec_ContentReference,
    (ASN1DecFun_t) ASN1Dec_EquivalentLabels,
    (ASN1DecFun_t) ASN1Dec_MLExpansionHistory,
    (ASN1DecFun_t) ASN1Dec_SigningCertificate,
    (ASN1DecFun_t) ASN1Dec_SMimeEncryptCerts,
    (ASN1DecFun_t) ASN1Dec_ReceiptRequest,
    (ASN1DecFun_t) ASN1Dec_SMIMEEncryptionKeyPreference,
    (ASN1DecFun_t) ASN1Dec_ESSSecurityLabel,
};
static const ASN1FreeFun_t freefntab[10] = {
    (ASN1FreeFun_t) ASN1Free_Receipt,
    (ASN1FreeFun_t) ASN1Free_ContentHints,
    (ASN1FreeFun_t) ASN1Free_ContentReference,
    (ASN1FreeFun_t) ASN1Free_EquivalentLabels,
    (ASN1FreeFun_t) ASN1Free_MLExpansionHistory,
    (ASN1FreeFun_t) ASN1Free_SigningCertificate,
    (ASN1FreeFun_t) ASN1Free_SMimeEncryptCerts,
    (ASN1FreeFun_t) ASN1Free_ReceiptRequest,
    (ASN1FreeFun_t) ASN1Free_SMIMEEncryptionKeyPreference,
    (ASN1FreeFun_t) ASN1Free_ESSSecurityLabel,
};
static const ULONG sizetab[10] = {
    SIZE_ESS_Module_PDU_0,
    SIZE_ESS_Module_PDU_1,
    SIZE_ESS_Module_PDU_2,
    SIZE_ESS_Module_PDU_3,
    SIZE_ESS_Module_PDU_4,
    SIZE_ESS_Module_PDU_5,
    SIZE_ESS_Module_PDU_6,
    SIZE_ESS_Module_PDU_7,
    SIZE_ESS_Module_PDU_8,
    SIZE_ESS_Module_PDU_9,
};

/* forward declarations of values: */
extern ASN1uint32_t id_aa_receiptRequest_elems[9];
extern ASN1uint32_t id_aa_contentIdentifier_elems[9];
extern ASN1uint32_t id_ct_receipt_elems[9];
extern ASN1uint32_t id_aa_contentHint_elems[9];
extern ASN1uint32_t id_aa_msgSigDigest_elems[9];
extern ASN1uint32_t id_aa_contentReference_elems[9];
extern ASN1uint32_t id_aa_securityLabel_elems[9];
extern ASN1uint32_t id_aa_equivalentLabels_elems[9];
extern ASN1uint32_t id_aa_mlExpandHistory_elems[9];
extern ASN1uint32_t id_aa_signingCertificate_elems[9];
/* definitions of value components: */
static const struct ASN1objectidentifier_s id_aa_receiptRequest_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[8]), 2 },
    { NULL, 1 }
};
static const struct ASN1objectidentifier_s id_aa_contentIdentifier_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[8]), 2 },
    { NULL, 7 }
};
static const struct ASN1objectidentifier_s id_ct_receipt_list[9] = {
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[8]), 1 },
    { NULL, 1 }
};
static const struct ASN1objectidentifier_s id_aa_contentHint_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[8]), 2 },
    { NULL, 4 }
};
static const struct ASN1objectidentifier_s id_aa_msgSigDigest_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[8]), 2 },
    { NULL, 5 }
};
static const struct ASN1objectidentifier_s id_aa_contentReference_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[8]), 2 },
    { NULL, 10 }
};
static const struct ASN1objectidentifier_s id_aa_securityLabel_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[8]), 2 },
    { NULL, 2 }
};
static const struct ASN1objectidentifier_s id_aa_equivalentLabels_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[8]), 2 },
    { NULL, 9 }
};
static const struct ASN1objectidentifier_s id_aa_mlExpandHistory_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[8]), 2 },
    { NULL, 3 }
};
static const struct ASN1objectidentifier_s id_aa_signingCertificate_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[8]), 2 },
    { NULL, 12 }
};
/* definitions of values: */
ASN1int32_t ub_receiptsTo = 16;
ASN1objectidentifier_t id_aa_receiptRequest = (ASN1objectidentifier_t) id_aa_receiptRequest_list;
ASN1objectidentifier_t id_aa_contentIdentifier = (ASN1objectidentifier_t) id_aa_contentIdentifier_list;
ASN1objectidentifier_t id_ct_receipt = (ASN1objectidentifier_t) id_ct_receipt_list;
ASN1objectidentifier_t id_aa_contentHint = (ASN1objectidentifier_t) id_aa_contentHint_list;
ASN1objectidentifier_t id_aa_msgSigDigest = (ASN1objectidentifier_t) id_aa_msgSigDigest_list;
ASN1objectidentifier_t id_aa_contentReference = (ASN1objectidentifier_t) id_aa_contentReference_list;
ASN1objectidentifier_t id_aa_securityLabel = (ASN1objectidentifier_t) id_aa_securityLabel_list;
ASN1int32_t ub_integer_options = 256;
ASN1int32_t ub_privacy_mark_length = 128;
ASN1int32_t ub_security_categories = 64;
ASN1objectidentifier_t id_aa_equivalentLabels = (ASN1objectidentifier_t) id_aa_equivalentLabels_list;
ASN1objectidentifier_t id_aa_mlExpandHistory = (ASN1objectidentifier_t) id_aa_mlExpandHistory_list;
ASN1int32_t ub_ml_expansion_history = 64;
ASN1objectidentifier_t id_aa_signingCertificate = (ASN1objectidentifier_t) id_aa_signingCertificate_list;

void ASN1CALL ESS_Module_Startup(void)
{
    if (ESS_Module == NULL) {
        ESS_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 10, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x737365);
    }
}

void ASN1CALL ESS_Module_Cleanup(void)
{
    ASN1_CloseModule(ESS_Module);
    ESS_Module = NULL;
}

static int ASN1CALL ASN1Enc_SigningCertificate_policies(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate_policies *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SigningCertificate_policies(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate_policies *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        PolicyInformation *value = (PolicyInformation *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;     
        else
            return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SigningCertificate_policies(SigningCertificate_policies *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_SigningCertificate_certs(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate_certs *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_ESSCertID(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SigningCertificate_certs(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate_certs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        ESSCertID * value = (ESSCertID *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if (value)
            val->value = value;
        else
            return 0;
	}
	if (!ASN1Dec_ESSCertID(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SigningCertificate_certs(SigningCertificate_certs *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
	ASN1Free_ESSCertID(&(val)->value[i]);
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_MLReceiptPolicy_inAdditionTo(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy_inAdditionTo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MLReceiptPolicy_inAdditionTo(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy_inAdditionTo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        GeneralNames *value = (GeneralNames *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
	    if (value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MLReceiptPolicy_inAdditionTo(MLReceiptPolicy_inAdditionTo *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_MLReceiptPolicy_insteadOf(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy_insteadOf *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MLReceiptPolicy_insteadOf(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy_insteadOf *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        GeneralNames *value = (GeneralNames *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MLReceiptPolicy_insteadOf(MLReceiptPolicy_insteadOf *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_ReceiptsFrom_receiptList(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptsFrom_receiptList *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReceiptsFrom_receiptList(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptsFrom_receiptList *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        GeneralNames *value = (GeneralNames *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReceiptsFrom_receiptList(ReceiptsFrom_receiptList *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_ReceiptRequest_receiptsTo(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptRequest_receiptsTo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReceiptRequest_receiptsTo(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptRequest_receiptsTo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        GeneralNames * value = (GeneralNames *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReceiptRequest_receiptsTo(ReceiptRequest_receiptsTo *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->issuer))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val)
{
    ASN1intx_free(&(val)->serialNumber);
}

static int ASN1CALL ASN1Enc_ReceiptsFrom(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptsFrom *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncS32(enc, 0x80000000, (val)->u.allOrFirstTier))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ReceiptsFrom_receiptList(enc, 0, &(val)->u.receiptList))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReceiptsFrom(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptsFrom *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecS32Val(dec, 0x80000000, &(val)->u.allOrFirstTier))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_ReceiptsFrom_receiptList(dec, 0, &(val)->u.receiptList))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReceiptsFrom(ReceiptsFrom *val)
{
    switch ((val)->choice) {
    case 2:
        ASN1Free_ReceiptsFrom_receiptList(&(val)->u.receiptList);
        break;
    }
}

static int ASN1CALL ASN1Enc_Receipt(ASN1encoding_t enc, ASN1uint32_t tag, Receipt *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signedContentIdentifier).length, ((val)->signedContentIdentifier).value))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->originatorSignatureValue).length, ((val)->originatorSignatureValue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Receipt(ASN1decoding_t dec, ASN1uint32_t tag, Receipt *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->signedContentIdentifier))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->originatorSignatureValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Receipt(Receipt *val)
{
    ASN1octetstring_free(&(val)->signedContentIdentifier);
}

static int ASN1CALL ASN1Enc_ContentHints(ASN1encoding_t enc, ASN1uint32_t tag, ContentHints *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncUTF8String(enc, 0xc, ((val)->contentDescription).length, ((val)->contentDescription).value))
	    return 0;
    }
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentHints(ASN1decoding_t dec, ASN1uint32_t tag, ContentHints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0xc) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecUTF8String(dd, 0xc, &(val)->contentDescription))
	    return 0;
    }
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentHints(ContentHints *val)
{
    if ((val)->o[0] & 0x80) {
        ASN1utf8string_free(&(val)->contentDescription);
    }
}

static int ASN1CALL ASN1Enc_ContentReference(ASN1encoding_t enc, ASN1uint32_t tag, ContentReference *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signedContentIdentifier).length, ((val)->signedContentIdentifier).value))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->originatorSignatureValue).length, ((val)->originatorSignatureValue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentReference(ASN1decoding_t dec, ASN1uint32_t tag, ContentReference *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->signedContentIdentifier))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->originatorSignatureValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentReference(ContentReference *val)
{
    ASN1octetstring_free(&(val)->signedContentIdentifier);
    ASN1octetstring_free(&(val)->originatorSignatureValue);
}

static int ASN1CALL ASN1Enc_ESSPrivacyMark(ASN1encoding_t enc, ASN1uint32_t tag, ESSPrivacyMark *val)
{
    ASN1uint32_t t;
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncUTF8String(enc, 0xc, ((val)->u.utf8String).length, ((val)->u.utf8String).value))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.pString);
	if (!ASN1DEREncCharString(enc, 0x13, t, (val)->u.pString))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ESSPrivacyMark(ASN1decoding_t dec, ASN1uint32_t tag, ESSPrivacyMark *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0xc:
	(val)->choice = 1;
	if (!ASN1BERDecUTF8String(dec, 0xc, &(val)->u.utf8String))
	    return 0;
	break;
    case 0x13:
	(val)->choice = 2;
	if (!ASN1BERDecZeroCharString(dec, 0x13, &(val)->u.pString))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ESSPrivacyMark(ESSPrivacyMark *val)
{
    switch ((val)->choice) {
    case 1:
        ASN1utf8string_free(&(val)->u.utf8String);
        break;
    case 2:
        ASN1ztcharstring_free((val)->u.pString);
        break;
    }
}

static int ASN1CALL ASN1Enc_SecurityCategories(ASN1encoding_t enc, ASN1uint32_t tag, SecurityCategories *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SecurityCategory(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityCategories(ASN1decoding_t dec, ASN1uint32_t tag, SecurityCategories *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        SecurityCategory *value = (SecurityCategory *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1Dec_SecurityCategory(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SecurityCategories(SecurityCategories *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
	ASN1Free_SecurityCategory(&(val)->value[i]);
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_SecurityCategory(ASN1encoding_t enc, ASN1uint32_t tag, SecurityCategory *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x80000000, &(val)->type))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityCategory(ASN1decoding_t dec, ASN1uint32_t tag, SecurityCategory *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x80000000, &(val)->type))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType2(dd0, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SecurityCategory(SecurityCategory *val)
{
}

static int ASN1CALL ASN1Enc_EquivalentLabels(ASN1encoding_t enc, ASN1uint32_t tag, EquivalentLabels *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_ESSSecurityLabel(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EquivalentLabels(ASN1decoding_t dec, ASN1uint32_t tag, EquivalentLabels *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        ESSSecurityLabel *value = (ESSSecurityLabel *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1Dec_ESSSecurityLabel(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EquivalentLabels(EquivalentLabels *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
	ASN1Free_ESSSecurityLabel(&(val)->value[i]);
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_MLExpansionHistory(ASN1encoding_t enc, ASN1uint32_t tag, MLExpansionHistory *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MLData(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MLExpansionHistory(ASN1decoding_t dec, ASN1uint32_t tag, MLExpansionHistory *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        MLData *value = (MLData *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
            return 0;
	}
	if (!ASN1Dec_MLData(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MLExpansionHistory(MLExpansionHistory *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
	ASN1Free_MLData(&(val)->value[i]);
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_EntityIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EntityIdentifier *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->u.subjectKeyIdentifier).length, ((val)->u.subjectKeyIdentifier).value))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EntityIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EntityIdentifier *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x4:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString2(dec, 0x4, &(val)->u.subjectKeyIdentifier))
	    return 0;
	break;
    case 0x10:
	(val)->choice = 2;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EntityIdentifier(EntityIdentifier *val)
{
    switch ((val)->choice) {
    case 1:
        break;
    case 2:
        ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
        break;
    }
}

static int ASN1CALL ASN1Enc_MLReceiptPolicy(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncNull(enc, 0x80000000))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MLReceiptPolicy_insteadOf(enc, 0, &(val)->u.insteadOf))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MLReceiptPolicy_inAdditionTo(enc, 0, &(val)->u.inAdditionTo))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MLReceiptPolicy(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecNull(dec, 0x80000000))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_MLReceiptPolicy_insteadOf(dec, 0, &(val)->u.insteadOf))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1Dec_MLReceiptPolicy_inAdditionTo(dec, 0, &(val)->u.inAdditionTo))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MLReceiptPolicy(MLReceiptPolicy *val)
{
    switch ((val)->choice) {
    case 2:
        ASN1Free_MLReceiptPolicy_insteadOf(&(val)->u.insteadOf);
        break;
    case 3:
        ASN1Free_MLReceiptPolicy_inAdditionTo(&(val)->u.inAdditionTo);
        break;
    }
}

static int ASN1CALL ASN1Enc_SigningCertificate(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_SigningCertificate_certs(enc, 0, &(val)->certs))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SigningCertificate_policies(enc, 0, &(val)->policies))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SigningCertificate(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_SigningCertificate_certs(dd, 0, &(val)->certs))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_SigningCertificate_policies(dd, 0, &(val)->policies))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SigningCertificate(SigningCertificate *val)
{
    ASN1Free_SigningCertificate_certs(&(val)->certs);
    if ((val)->o[0] & 0x80) {
        ASN1Free_SigningCertificate_policies(&(val)->policies);
    }
}

static int ASN1CALL ASN1Enc_ESSCertID(ASN1encoding_t enc, ASN1uint32_t tag, ESSCertID *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->certHash).length, ((val)->certHash).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->issuerSerial))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ESSCertID(ASN1decoding_t dec, ASN1uint32_t tag, ESSCertID *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->certHash))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_IssuerAndSerialNumber(dd, 0, &(val)->issuerSerial))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ESSCertID(ESSCertID *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->certHash);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_IssuerAndSerialNumber(&(val)->issuerSerial);
	}
    }
}

static int ASN1CALL ASN1Enc_SMimeEncryptCerts(ASN1encoding_t enc, ASN1uint32_t tag, SMimeEncryptCerts *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_SMimeEncryptCert(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMimeEncryptCerts(ASN1decoding_t dec, ASN1uint32_t tag, SMimeEncryptCerts *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        SMimeEncryptCert *value = (SMimeEncryptCert *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
            return 0;
	}
	if (!ASN1Dec_SMimeEncryptCert(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMimeEncryptCerts(SMimeEncryptCerts *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SMimeEncryptCert(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SMimeEncryptCert(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SMIMECapabilities(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapabilities *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_SMIMECapability(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMECapabilities(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapabilities *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        SMIMECapability *value = (SMIMECapability *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
            return 0;
	}
	if (!ASN1Dec_SMIMECapability(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMIMECapabilities(SMIMECapabilities *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SMIMECapability(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SMIMECapability(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SMIMECapability(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapability *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->capabilityID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMECapability(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->capabilityID))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMIMECapability(SMIMECapability *val)
{
    if ((val)->o[0] & 0x80) {
        //        ASN1open_free(&(val)->parameters);
    }
}

static int ASN1CALL ASN1Enc_OtherKeyAttribute(ASN1encoding_t enc, ASN1uint32_t tag, OtherKeyAttribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->keyAttrId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->keyAttr))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherKeyAttribute(ASN1decoding_t dec, ASN1uint32_t tag, OtherKeyAttribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->keyAttrId))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->keyAttr))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherKeyAttribute(OtherKeyAttribute *val)
{
    if ((val)->o[0] & 0x80) {
        //        ASN1open_free(&(val)->keyAttr);
    }
}

static int ASN1CALL ASN1Enc_ReceiptRequest(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signedContentIdentifier).length, ((val)->signedContentIdentifier).value))
	return 0;
    if (!ASN1Enc_ReceiptsFrom(enc, 0, &(val)->receiptsFrom))
	return 0;
    if (!ASN1Enc_ReceiptRequest_receiptsTo(enc, 0, &(val)->receiptsTo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReceiptRequest(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->signedContentIdentifier))
	return 0;
    if (!ASN1Dec_ReceiptsFrom(dd, 0, &(val)->receiptsFrom))
	return 0;
    if (!ASN1Dec_ReceiptRequest_receiptsTo(dd, 0, &(val)->receiptsTo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReceiptRequest(ReceiptRequest *val)
{
    ASN1octetstring_free(&(val)->signedContentIdentifier);
    ASN1Free_ReceiptsFrom(&(val)->receiptsFrom);
    ASN1Free_ReceiptRequest_receiptsTo(&(val)->receiptsTo);
}

static int ASN1CALL ASN1Enc_ESSSecurityLabel(ASN1encoding_t enc, ASN1uint32_t tag, ESSSecurityLabel *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncU32(enc, 0x2, (val)->security_classification))
	    return 0;
    }
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->security_policy_identifier))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ESSPrivacyMark(enc, 0, &(val)->privacy_mark))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SecurityCategories(enc, 0, &(val)->security_categories))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ESSSecurityLabel(ASN1decoding_t dec, ASN1uint32_t tag, ESSSecurityLabel *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	switch (t) {
	case 0x2:
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecU16Val(dd, 0x2, &(val)->security_classification))
		return 0;
	    break;
	case 0x6:
	    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->security_policy_identifier))
		return 0;
	    break;
	case 0x13:
        case 0x0c:
	    (val)->o[0] |= 0x40;
	    if (!ASN1Dec_ESSPrivacyMark(dd, 0, &(val)->privacy_mark))
		return 0;
	    break;
	case 0x11:
	    (val)->o[0] |= 0x20;
	    if (!ASN1Dec_SecurityCategories(dd, 0, &(val)->security_categories))
		return 0;
	    break;
	default:
	    ASN1DecSetError(dd, ASN1_ERR_CORRUPT);
	    return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ESSSecurityLabel(ESSSecurityLabel *val)
{
    if ((val)->o[0] & 0x40) {
        ASN1Free_ESSPrivacyMark(&(val)->privacy_mark);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_SecurityCategories(&(val)->security_categories);
    }
}

static int ASN1CALL ASN1Enc_MLData(ASN1encoding_t enc, ASN1uint32_t tag, MLData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_EntityIdentifier(enc, 0, &(val)->mailListIdentifier))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->expansionTime))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MLReceiptPolicy(enc, 0, &(val)->mlReceiptPolicy))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MLData(ASN1decoding_t dec, ASN1uint32_t tag, MLData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_EntityIdentifier(dd, 0, &(val)->mailListIdentifier))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->expansionTime))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000 || t == 0x80000001 || t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_MLReceiptPolicy(dd, 0, &(val)->mlReceiptPolicy))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MLData(MLData *val)
{
    ASN1Free_EntityIdentifier(&(val)->mailListIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_MLReceiptPolicy(&(val)->mlReceiptPolicy);
    }
}

static int ASN1CALL ASN1Enc_SMimeEncryptCert(ASN1encoding_t enc, ASN1uint32_t tag, SMimeEncryptCert *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->hash).length, ((val)->hash).value))
	return 0;
    if (!ASN1Enc_SMIMECapabilities(enc, 0, &(val)->capabilities))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMimeEncryptCert(ASN1decoding_t dec, ASN1uint32_t tag, SMimeEncryptCert *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->hash))
	return 0;
    if (!ASN1Dec_SMIMECapabilities(dd, 0, &(val)->capabilities))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMimeEncryptCert(SMimeEncryptCert *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->hash);
	ASN1Free_SMIMECapabilities(&(val)->capabilities);
    }
}

static int ASN1CALL ASN1Enc_RecipientKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientKeyIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->subjectKeyIdentifier).length, ((val)->subjectKeyIdentifier).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->date))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OtherKeyAttribute(enc, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientKeyIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->subjectKeyIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x18) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->date))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_OtherKeyAttribute(dd, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientKeyIdentifier(RecipientKeyIdentifier *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->subjectKeyIdentifier);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OtherKeyAttribute(&(val)->other);
	}
    }
}

static int ASN1CALL ASN1Enc_SMIMEEncryptionKeyPreference(ASN1encoding_t enc, ASN1uint32_t tag, SMIMEEncryptionKeyPreference *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0x80000000, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_RecipientKeyIdentifier(enc, 0x80000001, &(val)->u.recipientKeyId))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->u.subjectAltKeyIdentifier).length, ((val)->u.subjectAltKeyIdentifier).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMEEncryptionKeyPreference(ASN1decoding_t dec, ASN1uint32_t tag, SMIMEEncryptionKeyPreference *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0x80000000, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_RecipientKeyIdentifier(dec, 0x80000001, &(val)->u.recipientKeyId))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.subjectAltKeyIdentifier))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SMIMEEncryptionKeyPreference(SMIMEEncryptionKeyPreference *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
	    break;
	case 2:
	    ASN1Free_RecipientKeyIdentifier(&(val)->u.recipientKeyId);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.subjectAltKeyIdentifier);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\demand2.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

//
// IF YOU #INCLUDE A FILE HERE YOU PROBABLY CONFUSED.
// THIS FILE IS INCLUDED BY LOTS OF PEOPLE.  THINK THRICE
// BEFORE #INCLUDING *ANYTHING* HERE.  MAKE GOOD USE
// OF FORWARD REFS, THIS IS C++.
//

#define USE_CRITSEC

#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           ESS_DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           ESS_DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return;     \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#endif // IMPLEMENT_LOADER_FUNCTIONS

extern HINSTANCE g_hInst;

void ESS_InitDemandLoadLibs();
void ESS_FreeDemandLoadLibs();

/////////////////////////////////////
// CRYPT32.DLL

#define _CRYPT32_

BOOL ESS_DemandLoadCrypt32(void);

typedef void *HCERTSTORE;
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;
typedef struct _CERT_INFO *PCERT_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCERT_NAME_INFO;
typedef void *HCRYPTMSG;
typedef struct _CMSG_STREAM_INFO *PCMSG_STREAM_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCCERT_NAME_INFO;

LOADER_FUNCTION( BOOL, CryptRegisterOIDFunction,
    (DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll,
     LPCSTR pszOverrideFuncName),
    (dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName),
    NULL, Crypt32)
#define CryptRegisterOIDFunction VAR_CryptRegisterOIDFunction

LOADER_FUNCTION( BOOL, I_CryptUninstallAsn1Module,
    (HCRYPTASN1MODULE hAsn1Module),
    (hAsn1Module),
    NULL, Crypt32)
#define I_CryptUninstallAsn1Module VAR_I_CryptUninstallAsn1Module

LOADER_FUNCTION( BOOL, I_CryptInstallAsn1Module,
    (ASN1module_t pMod, DWORD dwFlags, void *pvReserved),
    (pMod, dwFlags, pvReserved),
    NULL, Crypt32)
#define I_CryptInstallAsn1Module VAR_I_CryptInstallAsn1Module

LOADER_FUNCTION( ASN1encoding_t, I_CryptGetAsn1Encoder,
    (HCRYPTASN1MODULE hAsn1Module),
    (hAsn1Module),
    NULL, Crypt32)
#define I_CryptGetAsn1Encoder VAR_I_CryptGetAsn1Encoder

LOADER_FUNCTION( ASN1decoding_t, I_CryptGetAsn1Decoder,
    (HCRYPTASN1MODULE hAsn1Module),
    (hAsn1Module),
    NULL, Crypt32)
#define I_CryptGetAsn1Decoder VAR_I_CryptGetAsn1Decoder

////////////////////////////////
//  nmasn1.dll

BOOL ESS_DemandLoadNmasn1(void);

LOADER_FUNCTION( ASN1module_t,  ASN1_CreateModule,
    ( ASN1uint32_t nVersion, ASN1encodingrule_e eRule, ASN1uint32_t dwFlags,ASN1uint32_t cPDU, const ASN1GenericFun_t apfnEncoder[], const ASN1GenericFun_t apfnDecoder[], const ASN1FreeFun_t apfnFreeMemory[], const ASN1uint32_t acbStructSize[], ASN1magic_t  nModuleName),
    ( nVersion, eRule, dwFlags,cPDU, apfnEncoder, apfnDecoder, apfnFreeMemory, acbStructSize,  nModuleName),
    NULL, Nmasn1)
#define ASN1_CreateModule VAR_ASN1_CreateModule

LOADER_FUNCTION_VOID( void,  ASN1_CloseModule,
    (ASN1module_t pModule),
    (pModule),
    Nmasn1)
#define ASN1_CloseModule VAR_ASN1_CloseModule

LOADER_FUNCTION( int,  ASN1BEREncObjectIdentifier2,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val),
    (enc, tag, val),
    NULL, Nmasn1)
#define ASN1BEREncObjectIdentifier2 VAR_ASN1BEREncObjectIdentifier2

LOADER_FUNCTION( int,  ASN1BERDecObjectIdentifier2,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t * a),
    (dec, tag, a),
    NULL, Nmasn1)
#define ASN1BERDecObjectIdentifier2 VAR_ASN1BERDecObjectIdentifier2

LOADER_FUNCTION( int,  ASN1BEREncEndOfContents,
    (ASN1encoding_t enc, ASN1uint32_t LengthOffset),
    (enc, LengthOffset),
    NULL, Nmasn1)
#define ASN1BEREncEndOfContents VAR_ASN1BEREncEndOfContents

LOADER_FUNCTION( int,  ASN1BEREncS32,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t b),
    (enc, tag, b),
    NULL, Nmasn1)
#define ASN1BEREncS32 VAR_ASN1BEREncS32

LOADER_FUNCTION( int,  ASN1BEREncOpenType,
    (ASN1encoding_t enc, ASN1open_t * a),
    (enc, a),
    NULL, Nmasn1)
#define ASN1BEREncOpenType VAR_ASN1BEREncOpenType

LOADER_FUNCTION( int,  ASN1BEREncExplicitTag,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pLengthOffset),
    (enc, tag, pLengthOffset),
    NULL, Nmasn1)
#define ASN1BEREncExplicitTag VAR_ASN1BEREncExplicitTag

LOADER_FUNCTION( int,  ASN1BERDecEndOfContents,
    (ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *di),
    (dec, dd, di),
    NULL, Nmasn1)
#define ASN1BERDecEndOfContents VAR_ASN1BERDecEndOfContents

LOADER_FUNCTION( int,  ASN1BERDecS32Val,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t * a),
    (dec, tag, a),
    NULL, Nmasn1)
#define ASN1BERDecS32Val VAR_ASN1BERDecS32Val

LOADER_FUNCTION( int,  ASN1BERDecOpenType2,
    (ASN1decoding_t dec, ASN1open_t * a),
    (dec, a),
    NULL, Nmasn1)
#define ASN1BERDecOpenType2 VAR_ASN1BERDecOpenType2

LOADER_FUNCTION( int,  ASN1BERDecExplicitTag,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **di),
    (dec, tag, dd,di),
    NULL, Nmasn1)
#define ASN1BERDecExplicitTag VAR_ASN1BERDecExplicitTag

LOADER_FUNCTION( int,  ASN1CEREncOctetString,
    (ASN1encoding_t enc, ASN1uint32_t a, ASN1uint32_t b, ASN1octet_t * c),
    (enc, a, b, c),
    NULL, Nmasn1)
#define ASN1CEREncOctetString VAR_ASN1CEREncOctetString

LOADER_FUNCTION( int,  ASN1BERDecOctetString2,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val),
    (dec, tag, val),
    NULL, Nmasn1)
#define ASN1BERDecOctetString2 VAR_ASN1BERDecOctetString2

LOADER_FUNCTION( int,  ASN1BERDecOctetString,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val),
    (dec, tag, val),
    NULL, Nmasn1)
#define ASN1BERDecOctetString VAR_ASN1BERDecOctetString

LOADER_FUNCTION_VOID( void,  ASN1octetstring_free,
    (ASN1octetstring_t * a),
    (a),
    Nmasn1)
#define ASN1octetstring_free VAR_ASN1octetstring_free

LOADER_FUNCTION( int,  ASN1BEREncUTF8String,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value),
    (enc, tag, length, value),
    NULL, Nmasn1)
#define ASN1BEREncUTF8String VAR_ASN1BEREncUTF8String

LOADER_FUNCTION( int,  ASN1BERDecUTF8String,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val),
    (dec, tag, val),
    NULL, Nmasn1)
#define ASN1BERDecUTF8String VAR_ASN1BERDecUTF8String

LOADER_FUNCTION( int,  ASN1BERDecPeekTag,
    (ASN1decoding_t dec, ASN1uint32_t *tag),
    (dec, tag),
    NULL, Nmasn1)
#define ASN1BERDecPeekTag VAR_ASN1BERDecPeekTag

LOADER_FUNCTION_VOID( void,  ASN1utf8string_free,
    (ASN1wstring_t * a),
    (a),
    Nmasn1)
#define ASN1utf8string_free VAR_ASN1utf8string_free

LOADER_FUNCTION( void *,  ASN1DecRealloc,
    (ASN1decoding_t dec, void *ptr, ASN1uint32_t size),
    (dec, ptr, size),
    NULL, Nmasn1)
#define ASN1DecRealloc VAR_ASN1DecRealloc

LOADER_FUNCTION( int,  ASN1BERDecNotEndOfContents,
    (ASN1decoding_t dec, ASN1octet_t *di),
    (dec, di),
    NULL, Nmasn1)
#define ASN1BERDecNotEndOfContents VAR_ASN1BERDecNotEndOfContents

LOADER_FUNCTION_VOID( void,  ASN1Free,
    (void *ptr),
    (ptr),
    Nmasn1)
#define ASN1Free VAR_ASN1Free

LOADER_FUNCTION( ASN1error_e,  ASN1DecSetError,
    (ASN1decoding_t dec, ASN1error_e err),
    (dec, err),
    ASN1_ERR_INTERNAL, Nmasn1)
#define ASN1DecSetError VAR_ASN1DecSetError

LOADER_FUNCTION( int,  ASN1BEREncU32,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t a),
    (enc, tag, a),
    NULL, Nmasn1)
#define ASN1BEREncU32 VAR_ASN1BEREncU32

LOADER_FUNCTION( int,  ASN1CEREncCharString,
    (ASN1encoding_t enc, ASN1uint32_t a, ASN1uint32_t b, ASN1char_t * c),
    (enc, a, b, c),
    NULL, Nmasn1)
#define ASN1CEREncCharString VAR_ASN1CEREncCharString

LOADER_FUNCTION( int,  ASN1CEREncBeginBlk,
    (ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk),
    (enc, eBlkType, ppBlk),
    NULL, Nmasn1)
#define ASN1CEREncBeginBlk VAR_ASN1CEREncBeginBlk

LOADER_FUNCTION( int,  ASN1CEREncNewBlkElement,
    (void *pBlk, ASN1encoding_t *enc2),
    (pBlk, enc2),
    NULL, Nmasn1)
#define ASN1CEREncNewBlkElement VAR_ASN1CEREncNewBlkElement

LOADER_FUNCTION( int,  ASN1CEREncFlushBlkElement,
    (void *pBlk),
    (pBlk),
    NULL, Nmasn1)
#define ASN1CEREncFlushBlkElement VAR_ASN1CEREncFlushBlkElement

LOADER_FUNCTION( int,  ASN1CEREncEndBlk,
    (void *pBlk),
    (pBlk),
    NULL, Nmasn1)
#define ASN1CEREncEndBlk VAR_ASN1CEREncEndBlk

LOADER_FUNCTION( int,  ASN1BERDecU16Val,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *a),
    (dec, tag, a),
    NULL, Nmasn1)
#define ASN1BERDecU16Val VAR_ASN1BERDecU16Val

LOADER_FUNCTION( int,  ASN1BERDecZeroCharString,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t * a),
    (dec, tag, a),
    NULL, Nmasn1)
#define ASN1BERDecZeroCharString VAR_ASN1BERDecZeroCharString

LOADER_FUNCTION_VOID( void,  ASN1ztcharstring_free,
    (ASN1ztcharstring_t a),
    (a),
    Nmasn1)
#define ASN1ztcharstring_free VAR_ASN1ztcharstring_free

LOADER_FUNCTION( int,  ASN1CEREncGeneralizedTime,
    (ASN1encoding_t enc, ASN1uint32_t a, ASN1generalizedtime_t * b),
    (enc, a, b),
    NULL, Nmasn1)
#define ASN1CEREncGeneralizedTime VAR_ASN1CEREncGeneralizedTime

LOADER_FUNCTION( int,  ASN1BEREncNull,
    (ASN1encoding_t enc, ASN1uint32_t tag),
    (enc, tag),
    NULL, Nmasn1)
#define ASN1BEREncNull VAR_ASN1BEREncNull

LOADER_FUNCTION( int,  ASN1BERDecGeneralizedTime,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t * a),
    (dec, tag, a),
    NULL, Nmasn1)
#define ASN1BERDecGeneralizedTime VAR_ASN1BERDecGeneralizedTime

LOADER_FUNCTION( int,  ASN1BERDecNull,
    (ASN1decoding_t dec, ASN1uint32_t tag),
    (dec, tag),
    NULL, Nmasn1)
#define ASN1BERDecNull VAR_ASN1BERDecNull

LOADER_FUNCTION( ASN1error_e,  ASN1_Encode,
    ( ASN1encoding_t pEncoderInfo, void *pDataStruct, ASN1uint32_t nPduNum, ASN1uint32_t dwFlags, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize),
    ( pEncoderInfo, pDataStruct, nPduNum, dwFlags, pbBuf, cbBufSize),
    ASN1_ERR_INTERNAL, Nmasn1)
#define ASN1_Encode VAR_ASN1_Encode

LOADER_FUNCTION_VOID( void,  ASN1_FreeEncoded,
    ( ASN1encoding_t pEncoderInfo, void *pBuf),
    ( pEncoderInfo, pBuf),
    Nmasn1)
#define ASN1_FreeEncoded VAR_ASN1_FreeEncoded

LOADER_FUNCTION( ASN1error_e,  ASN1_Decode,
    ( ASN1decoding_t pDecoderInfo, void **ppDataStruct, ASN1uint32_t nPduNum, ASN1uint32_t dwFlags, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize),
    ( pDecoderInfo, ppDataStruct, nPduNum, dwFlags, pbBuf, cbBufSize),
    ASN1_ERR_INTERNAL, Nmasn1)
#define ASN1_Decode VAR_ASN1_Decode

LOADER_FUNCTION( ASN1error_e,  ASN1_SetEncoderOption,
    ( ASN1encoding_t pEncoderInfo, ASN1optionparam_t *pOptParam),
    ( pEncoderInfo, pOptParam),
    ASN1_ERR_INTERNAL, Nmasn1)
#define ASN1_SetEncoderOption VAR_ASN1_SetEncoderOption

LOADER_FUNCTION( ASN1error_e,  ASN1_GetEncoderOption,
    ( ASN1encoding_t pEncoderInfo, ASN1optionparam_t *pOptParam),
    ( pEncoderInfo, pOptParam),
    ASN1_ERR_INTERNAL, Nmasn1)
#define ASN1_GetEncoderOption VAR_ASN1_GetEncoderOption

LOADER_FUNCTION_VOID( void,  ASN1_FreeDecoded,
    ( ASN1decoding_t pDecoderInfo, void *pDataStruct, ASN1uint32_t nPduNum),
    ( pDecoderInfo, pDataStruct, nPduNum),
    Nmasn1)
#define ASN1_FreeDecoded VAR_ASN1_FreeDecoded

LOADER_FUNCTION( int,  ASN1BEREncOctetString,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val),
    (enc, tag, len, val),
    0, Nmasn1)
#define ASN1BEREncOctetString VAR_ASN1BEREncOctetString

LOADER_FUNCTION( int,  ASN1BEREncCharString,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t a, ASN1char_t * b),
    (enc, tag, a, b),
    0, Nmasn1)
#define ASN1BEREncCharString VAR_ASN1BEREncCharString

LOADER_FUNCTION( int,  ASN1BEREncSX,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t * a),
    (enc, tag, a),
    0, Nmasn1)
#define ASN1BEREncSX VAR_ASN1BEREncSX

LOADER_FUNCTION( int, ASN1BERDecSXVal,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *a),
    (dec, tag, a),
    0, Nmasn1)
#define ASN1BERDecSXVal VAR_ASN1BERDecSXVal

LOADER_FUNCTION_VOID( void, ASN1intx_free,
    (ASN1intx_t * a),
    (a),
    Nmasn1)
#define ASN1intx_free VAR_ASN1intx_free
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\demand2.cpp ===
// --------------------------------------------------------------------------------
// Demand.cpp
// Written By: jimsch, brimo, t-erikne (bastardized by sbailey)
// --------------------------------------------------------------------------------
// W4 stuff
#ifdef SMIME_V3
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------

#include <windows.h>
//#include "myassert.h"
#define AssertSz(a, b)
#define Assert(a)
#define IMPLEMENT_LOADER_FUNCTIONS
#include "crypttls.h"
#include "ess.h"
#include "demand2.h"

#include "badstrfunctions.h"

// --------------------------------------------------------------------------------
// CRIT_GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
    temp = (TYP_##fn) GetProcAddress(h, #fn);   \
    if (temp)                                   \
        VAR_##fn = temp;                        \
    else                                        \
        {                                       \
        AssertSz(0, VAR_##fn" failed to load"); \
        goto error;                             \
        }

// --------------------------------------------------------------------------------
// RESET
// --------------------------------------------------------------------------------
#define RESET(fn) VAR_##fn = LOADER_##fn;

// --------------------------------------------------------------------------------
// GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR(h, fn) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
    Assert(VAR_##fn != NULL); \
    if(NULL == VAR_##fn ) { \
        VAR_##fn  = LOADER_##fn; \
    }


// --------------------------------------------------------------------------------
// GET_PROC_ADDR_ORDINAL
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR_ORDINAL(h, fn, ord) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, MAKEINTRESOURCE(ord));  \
    Assert(VAR_##fn != NULL);

// --------------------------------------------------------------------------------
// GET_PROC_ADDR3
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR3(h, fn, varname) \
    VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
    Assert(VAR_##varname != NULL);

// --------------------------------------------------------------------------------
// Static Globals
// --------------------------------------------------------------------------------
static HMODULE s_hCrypt = 0;
static HMODULE s_hNmasn1 = 0;

static CRITICAL_SECTION g_csDefLoad = {0};

// --------------------------------------------------------------------------------
// InitDemandLoadedLibs
// --------------------------------------------------------------------------------
void ESS_InitDemandLoadLibs(void)
{
    InitializeCriticalSection(&g_csDefLoad);
}

// --------------------------------------------------------------------------------
// FreeDemandLoadedLibs
// --------------------------------------------------------------------------------
void ESS_FreeDemandLoadLibs(void)
{
    EnterCriticalSection(&g_csDefLoad);
    if (s_hCrypt)       FreeLibrary(s_hCrypt);
    if (s_hNmasn1)    FreeLibrary(s_hNmasn1);

    LeaveCriticalSection(&g_csDefLoad);
    DeleteCriticalSection(&g_csDefLoad);
}


// --------------------------------------------------------------------------------
// DemandLoadCrypt32
// --------------------------------------------------------------------------------
BOOL ESS_DemandLoadCrypt32(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCrypt)
        {
        s_hCrypt = LoadLibrary("CRYPT32.DLL");
        AssertSz((BOOL)s_hCrypt, TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCrypt, CryptRegisterOIDFunction);
            GET_PROC_ADDR(s_hCrypt, I_CryptUninstallAsn1Module);
            GET_PROC_ADDR(s_hCrypt, I_CryptInstallAsn1Module);
            GET_PROC_ADDR(s_hCrypt, I_CryptGetAsn1Encoder);
            GET_PROC_ADDR(s_hCrypt, I_CryptGetAsn1Decoder);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

BOOL FIsMsasn1Loaded()
{
    static int  fTested = FALSE;

    if (!fTested) {
        ESS_DemandLoadNmasn1();
        fTested = TRUE;
    }

    return s_hNmasn1 != 0;
}

// --------------------------------------------------------------------------------
// DemandLoadNmasn1
// --------------------------------------------------------------------------------
BOOL ESS_DemandLoadNmasn1(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hNmasn1) {
        s_hNmasn1 = LoadLibrary("MSAsn1.DLL");
        AssertSz((BOOL)s_hNmasn1, TEXT("LoadLibrary failed on MSAsn1.DLL"));

        if (0 == s_hNmasn1)
            fRet = FALSE;
        else {
            GET_PROC_ADDR(s_hNmasn1, ASN1_CreateModule);
            GET_PROC_ADDR(s_hNmasn1, ASN1_CloseModule);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncObjectIdentifier2);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecObjectIdentifier2);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncEndOfContents);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncS32);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncOpenType);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncExplicitTag);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecEndOfContents);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecS32Val);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecOpenType2);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecExplicitTag);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncOctetString);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecOctetString2);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecOctetString);
            GET_PROC_ADDR(s_hNmasn1, ASN1octetstring_free);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncUTF8String);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecUTF8String);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecPeekTag);
            GET_PROC_ADDR(s_hNmasn1, ASN1utf8string_free);
            GET_PROC_ADDR(s_hNmasn1, ASN1DecRealloc);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecNotEndOfContents);
            GET_PROC_ADDR(s_hNmasn1, ASN1Free);
            GET_PROC_ADDR(s_hNmasn1, ASN1DecSetError);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncU32);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncCharString);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncBeginBlk);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncNewBlkElement);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncFlushBlkElement);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncEndBlk);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecU16Val);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecZeroCharString);
            GET_PROC_ADDR(s_hNmasn1, ASN1ztcharstring_free);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncGeneralizedTime);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncNull);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecGeneralizedTime);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecNull);
            GET_PROC_ADDR(s_hNmasn1, ASN1_Encode);
            GET_PROC_ADDR(s_hNmasn1, ASN1_FreeEncoded);
            GET_PROC_ADDR(s_hNmasn1, ASN1_Decode);
            GET_PROC_ADDR(s_hNmasn1, ASN1_SetEncoderOption);
            GET_PROC_ADDR(s_hNmasn1, ASN1_GetEncoderOption);
            GET_PROC_ADDR(s_hNmasn1, ASN1_FreeDecoded);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncOctetString);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncCharString);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncSX);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecSXVal);
            GET_PROC_ADDR(s_hNmasn1, ASN1intx_free);
        }
    }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\essout.h ===
///////////////////////////////////////////////////////////////////////////


typedef interface ISMimePolicy ISMimePolicy;

#define SMIME_POLICY_EDIT_UI            0x00000001

EXTERN_C const IID IID_ISMimePolicy;
MIDL_INTERFACE("744dffc0-63f4-11d2-8a52-0080c76b34c6")
ISMimePolicy : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetInfo(
             /* OUT */ DWORD * pdwFlags,
             /* OUT */ DWORD * pcClassifications) = 0;
    virtual HRESULT STDMETHODCALLTYPE EnumClassifications(
             /* OUT */ LPWSTR  rgwch,
             /* OUT */ DWORD * pcb, 
             /* OUT */ DWORD * dwValue,
             /* IN  */ DWORD i) = 0;
    virtual HRESULT STDMETHODCALLTYPE EditUI(
             /* IN     */  HWND hwnd,
             /* IN/OUT */  DWORD * pdwClassification,
             /* IN/OUT */  LPWSTR * pwszPrivacyMark,
             /* IN/OUT */  LPBYTE * ppbLabel,
             /* IN/OUT */  DWORD  * pcbLabel) = 0;
   virtual HRESULT STDMETHODCALLTYPE CheckEdits(
             /* IN */     HWND hwnd,
             /* IN */     DWORD dwClassification,
             /* IN */     LPCWSTR wszPrivacyLabel,
             /* IN/OUT */ LPBYTE * ppbLabel,
             /* IN/OUT */ DWORD *  pcbLabel) = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\essmime.cpp ===
#ifdef SMIME_V3
#include <windows.h>
#include <mimeole.h>
#include <essout.h>

#include "badstrfunctions.h"

#include        "demand.h"
#include        "crypttls.h"
#include        "demand2.h"

extern CRYPT_DECODE_PARA       CryptDecodeAlloc;
#define szOID_MSFT_ATTR_SEQUENCE        "1.3.6.1.4.1.311.16.1.1"

/////////////////////////////////////////////////////////////////////////

typedef struct {
    DWORD               cNames;
    CERT_NAME_BLOB *    rgNames;
} ReceiptNames;

HRESULT SetNames(ReceiptNames * pnames, DWORD cNames, CERT_NAME_BLOB * rgNames)
{
    DWORD       cb;
    DWORD       i;
    LPBYTE      pb;
    
    if (pnames->rgNames != NULL) {
        free(pnames->rgNames);
        pnames->rgNames = NULL;
        pnames->cNames = 0;
    }

    for (i=0, cb=cNames*sizeof(CERT_NAME_BLOB); i<cNames; i++) {
        cb += rgNames[i].cbData;
    }

    pnames->rgNames = (CERT_NAME_BLOB *) malloc(cb);
    if (pnames->rgNames == NULL) {
        return E_OUTOFMEMORY;
    }

    pb = (LPBYTE) &pnames->rgNames[cNames];
    for (i=0; i<cNames; i++) {
        pnames->rgNames[i].pbData = pb;
        pnames->rgNames[i].cbData = rgNames[i].cbData;
        memcpy(pb, rgNames[i].pbData, rgNames[i].cbData);
        pb += rgNames[i].cbData;
    }

    pnames->cNames = cNames;
    return S_OK;
}

HRESULT MergeNames(ReceiptNames * pnames, DWORD cNames, CERT_NAME_BLOB * rgNames)
{
    DWORD               cb;
    DWORD               i;
    DWORD               i1;
    LPBYTE              pb;
    CERT_NAME_BLOB *    p;

    for (i=0, cb=0; i<pnames->cNames; i++) {
        cb += pnames->rgNames[i].cbData;
    }

    for (i=0; i<cNames; i++) {
        cb += rgNames[i].cbData;
    }

    p = (CERT_NAME_BLOB *) malloc(cb + (pnames->cNames + cNames) * 
                                  sizeof(CERT_NAME_BLOB));
    if (p == NULL) {
        return E_OUTOFMEMORY;
    }

    pb = (LPBYTE) &p[pnames->cNames + cNames];
    for (i=0, i1=0; i<pnames->cNames; i++, i1++) {
        p[i1].pbData = pb;
        p[i1].cbData = pnames->rgNames[i].cbData;
        memcpy(pb, pnames->rgNames[i].pbData, pnames->rgNames[i].cbData);
        pb += pnames->rgNames[i].cbData;
    }

    for (i=0; i<pnames->cNames; i++, i1++) {
        p[i1].pbData = pb;
        p[i1].cbData = rgNames[i].cbData;
        memcpy(pb, rgNames[i].pbData, rgNames[i].cbData);
        pb += rgNames[i].cbData;
    }

    free(pnames->rgNames);
    pnames->rgNames = p;
    pnames->cNames = i1;
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////

MIMEOLEAPI MimeOleCreateReceipt(IMimeMessage * pMsgSrc, PCX509CERT pCertToSign, 
                                HWND hwndDlg, IMimeMessage ** ppMessage,
                                const CERT_ALT_NAME_INFO * pMyNames)
{
    DWORD                       cb;
    DWORD                       cLayers;
    DWORD                       dwReceiptsFrom;
    BOOL                        fSkipAddress = FALSE;
    HRESULT                     hr;
    DWORD                       i;
    DWORD                       i1;
    DWORD                       i2;
    DWORD                       iAttr;
    DWORD                       iLayer;
    PCRYPT_ATTRIBUTES           pattrs = NULL;
    IMimeBody *                 pbody = NULL;
    LPBYTE                      pbReceiptReq = NULL;
    IMimeAddressTable *         pmatbl = NULL;
    IMimeBody *                 pmb = NULL;
    IMimeMessage *              pmm = NULL;
    PSMIME_RECEIPT_REQUEST      preq = NULL;
    LPSTREAM                    pstm = NULL;
    ReceiptNames          receiptsTo = {0, NULL};
    PROPVARIANT *               rgpvAuthAttr = NULL;
    PROPVARIANT                 var;

    //
    //  Get the Layer Count
    //  Get the Authenticated Attributes
    //  Decode Receipt Request
    //  Set ReceiptsFrom from the request
    //  For Each layer
    //          is mlExpansion in this layer? No -- Skip to next layer
    //          Receipt for First Tier only? Yes - return S_FALSE
    //          Policy override on mlExpansion?
    //              None - return S_FALSE
    //              insteadOf - set ReceiptsFrom from mlExpansion History
    //              inAdditionTo - add to ReceiptsFrom
    //  Is my name in ReceiptsFrom list? No -- return S_FALSE
    //  Setup new IMimeMessage
    //  Attach receipt body
    //  Address from Receipt Request
    //  return S_OK

    //  Obtain the body of the message

    hr = pMsgSrc->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pbody);
    if (FAILED(hr)) {
        goto CommonExit;
    }
    
    // Get the set of authenticated attributes on all layers of S/MIME in the
    //  message.

    hr = pbody->GetOption(OID_SECURITY_SIGNATURE_COUNT, &var);
    if (FAILED(hr)) {
        goto GeneralFail;
    }
    cLayers = var.ulVal;

    hr = pbody->GetOption(OID_SECURITY_AUTHATTR_RG, &var);
    if (FAILED(hr)) {
        goto CommonExit;
    }
    rgpvAuthAttr = var.capropvar.pElems;

    //  Create a stream object to hold the receipt and put the receipt into the
    //  stream -- this supplies the body of the receipt message.

    hr = MimeOleCreateVirtualStream(&pstm);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    hr = pbody->GetOption(OID_SECURITY_RECEIPT, &var);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    hr = pstm->Write(var.blob.pBlobData, var.blob.cbSize, NULL);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    //
    //  Walk through each layer of authenticated attributes processing the
    //  two relevant attributes.
    //
    
    for (iLayer=0; iLayer<cLayers; iLayer++) {
        if (rgpvAuthAttr[iLayer].blob.cbSize == 0) {
            continue;
        }

        //
        //  Decode the attributes at this layer of S/MIME
        //

        if (!CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_MSFT_ATTR_SEQUENCE,
                                 rgpvAuthAttr[iLayer].blob.pBlobData, 
                                 rgpvAuthAttr[iLayer].blob.cbSize, 
                                 CRYPT_ENCODE_ALLOC_FLAG, &CryptDecodeAlloc,
                                 &pattrs, &cb)) {
            goto GeneralFail;
        }

        //
        //  Walk through each attribute looking for
        //      if innermost layer - the receipt request
        //      else - a Mail List expansion history
        //
        
        for (iAttr=0; iAttr<pattrs->cAttr; iAttr++) {
            if (iLayer==0) {
                if (strcmp(pattrs->rgAttr[iAttr].pszObjId,
                           szOID_SMIME_Receipt_Request) == 0) {
                    //
                    // Crack the contents of the receipt request
                    //
                
                    if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                             szOID_SMIME_Receipt_Request,
                                             pattrs->rgAttr[iAttr].rgValue[0].pbData,
                                             pattrs->rgAttr[iAttr].rgValue[0].cbData,
                                             CRYPT_DECODE_ALLOC_FLAG,
                                             &CryptDecodeAlloc, &preq, &cb)) {
                        goto GeneralFail;
                    }

                    //
                    //  Initialize the ReceiptsTo list
                    //

                    if (preq->cReceiptsTo != 0) {
                        SetNames(&receiptsTo, preq->cReceiptsTo, preq->rgReceiptsTo);
                    }

                    //  Who are receipts from?
                
                    dwReceiptsFrom = preq->ReceiptsFrom.AllOrFirstTier;
                }
                else if (strcmp(pattrs->rgAttr[iAttr].pszObjId,
                                szOID_RSA_messageDigest) == 0) {
                    ;
                }
            }
            else if ((iLayer != 0) && (strcmp(pattrs->rgAttr[iAttr].pszObjId,
                                              szOID_SMIME_MLExpansion_History) == 0)) {
                //
                //  If receipts are from first tier only and we see this attribute
                //      we are not first tier by definition.
                //
                
                if (dwReceiptsFrom == SMIME_RECEIPTS_FROM_FIRST_TIER) {
                    hr = S_FALSE;
                    goto CommonExit;
                }

                PSMIME_ML_EXPANSION_HISTORY     pmlhist = NULL;
                
                //
                //  Crack the attribute
                //
                
                if (!CryptDecodeObjectEx(X509_ASN_ENCODING, 
                                         szOID_SMIME_MLExpansion_History,
                                         pattrs->rgAttr[iAttr].rgValue[0].pbData,
                                         pattrs->rgAttr[iAttr].rgValue[0].cbData,
                                         CRYPT_ENCODE_ALLOC_FLAG,
                                         &CryptDecodeAlloc, &pmlhist, &cb)) {
                    goto GeneralFail;
                }

                PSMIME_MLDATA     pMLData = &pmlhist->rgMLData[pmlhist->cMLData-1];

                switch( pMLData->dwPolicy) {
                    //  No receipt is to be returned
                case SMIME_MLPOLICY_NONE:
                    hr = S_FALSE;
                    free(pmlhist);
                    goto CommonExit;

                    //  Return receipt to a new list
                case SMIME_MLPOLICY_INSTEAD_OF:
                    SetNames(&receiptsTo, pMLData->cNames, pMLData->rgNames);
                    break;
                        
                case SMIME_MLPOLICY_IN_ADDITION_TO:
                    MergeNames(&receiptsTo, pMLData->cNames, pMLData->rgNames);
                    break;

                case SMIME_MLPOLICY_NO_CHANGE:
                    break;
                        
                default:
                    free(pmlhist);
                    goto GeneralFail;
                }

                free(pmlhist);
                break;
            }
        }

        free(pattrs);
        pattrs = NULL;
    }

    //
    //  Am I on the ReceiptsFrom List --
    //
    
    if (preq->ReceiptsFrom.cNames != 0) {
        BOOL    fFoundMe = FALSE;
        
        for (i=0; !fFoundMe && (i<preq->ReceiptsFrom.cNames); i++) {
            CERT_ALT_NAME_INFO *    pname = NULL;

            if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                     preq->ReceiptsFrom.rgNames[i].pbData,
                                     preq->ReceiptsFrom.rgNames[i].cbData,
                                     CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptDecodeAlloc, &pname, &cb)) {
                goto GeneralFail;
            }

            for (i1=0; i1<pname->cAltEntry; i1++) {
                for (i2=0; i2<pMyNames->cAltEntry; i2++) {
                    if (pname->rgAltEntry[i1].dwAltNameChoice !=
                        pMyNames->rgAltEntry[i1].dwAltNameChoice) {
                        continue;
                    }
                    
                    switch (pname->rgAltEntry[i1].dwAltNameChoice) {
                    case CERT_ALT_NAME_RFC822_NAME:
                        if (lstrcmpW(pname->rgAltEntry[i1].pwszRfc822Name,
                                    pMyNames->rgAltEntry[i1].pwszRfc822Name) == 0) {
                            fFoundMe = TRUE;
                            goto FoundMe;
                        }
                    }
                }
            }

        FoundMe:
            free(pname);
        }

        if (!fFoundMe) {
            hr = S_FALSE;
            goto CommonExit;
        }
    }

    hr = MimeOleCreateMessage(NULL, &pmm);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    hr = pmb->SetData(IET_BINARY, "OID", szOID_SMIME_ContentType_Receipt,
                      IID_IStream, pstm);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    //
    //  Address the receipt back to the receipients
    //

    hr = pmm->GetAddressTable(&pmatbl);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    for (i=0; i<receiptsTo.cNames; i++) {
        CERT_ALT_NAME_INFO *    pname = NULL;
        
        if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                 receiptsTo.rgNames[i].pbData,
                                 receiptsTo.rgNames[i].cbData,
                                 CRYPT_ENCODE_ALLOC_FLAG,
                                 &CryptDecodeAlloc, &pname, &cb)) {
            goto GeneralFail;
        }

        for (i1=0; i1<pname->cAltEntry; i1++) {
            char        cch;
            char        rgch[256];
            
            if (pname->rgAltEntry[i1].dwAltNameChoice == CERT_ALT_NAME_RFC822_NAME) {
                cch = WideCharToMultiByte(CP_ACP, 0,
                                          pname->rgAltEntry[i1].pwszRfc822Name,
                                          -1, rgch, sizeof(rgch), NULL, NULL);
                if (cch > 0) {
                    hr = pmatbl->AppendRfc822(IAT_TO, IET_UNICODE,
                                              rgch);
                    if (FAILED(hr)) {
                        goto CommonExit;
                    }
                }
                break;
            }
        }

        if (i1 == pname->cAltEntry) {
            fSkipAddress = TRUE;
        }
    }

#ifdef DEBUG
    {
        LPSTREAM        pstmTmp = NULL;
        hr = MimeOleCreateVirtualStream(&pstmTmp);
        pmm->Save(pstmTmp, TRUE);
        pstmTmp->Release();
    }
#endif // DEBUG

    hr = S_OK;
    *ppMessage = pmm;
    pmm->AddRef();
    
CommonExit:
    CoTaskMemFree(var.blob.pBlobData);
    if (preq != NULL)           free(preq);
    if (pbReceiptReq != NULL)   CoTaskMemFree(pbReceiptReq);
    if (rgpvAuthAttr != NULL)   CoTaskMemFree(rgpvAuthAttr);
    if (pattrs != NULL)         free(pattrs);
    if (pstm != NULL)           pstm->Release();
    if (pmatbl != NULL)         pmatbl->Release();
    if (pmb != NULL)            pmb->Release();
    if (pmm != NULL)            pmm->Release();
    if (pbody != NULL)          pbody->Release();
    return hr;

GeneralFail:
    hr = E_FAIL;
    goto CommonExit;
}
#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\ess.h ===
#ifndef _ESS_Module_H_
#define _ESS_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1objectidentifier2_t ObjectIdentifier;

typedef ObjectIdentifier ContentType;

typedef ASN1int32_t Version;
#define Version_v0 0
#define Version_v1 1
#define Version_v2 2
#define Version_v3 3

typedef ASN1intx_t HUGEINTEGER;

typedef HUGEINTEGER SerialNumber;

typedef SerialNumber CertificateSerialNumber;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef OCTETSTRING SubjectKeyIdentifier;

typedef NOCOPYANY GeneralNames;

typedef ASN1octetstring_t ContentIdentifier;

typedef ASN1int32_t AllOrFirstTier;
#define AllOrFirstTier_allReceipts 0
#define AllOrFirstTier_firstTierRecipients 1

typedef ASN1octetstring_t MsgSigDigest;

typedef ObjectIdentifier SecurityPolicyIdentifier;

typedef ASN1uint16_t SecurityClassification;
#define SecurityClassification_unmarked 0
#define SecurityClassification_unclassified 1
#define SecurityClassification_restricted 2
#define SecurityClassification_confidential 3
#define SecurityClassification_secret 4
#define SecurityClassification_top_secret 5

typedef ASN1octetstring_t Hash;

typedef NOCOPYANY PolicyInformation;

typedef struct SigningCertificate_policies {
    ASN1uint32_t count;
    PolicyInformation *value;
} SigningCertificate_policies;

typedef struct SigningCertificate_certs {
    ASN1uint32_t count;
    struct ESSCertID *value;
} SigningCertificate_certs;

typedef struct MLReceiptPolicy_inAdditionTo {
    ASN1uint32_t count;
    GeneralNames *value;
} MLReceiptPolicy_inAdditionTo;

typedef struct MLReceiptPolicy_insteadOf {
    ASN1uint32_t count;
    GeneralNames *value;
} MLReceiptPolicy_insteadOf;

typedef struct ReceiptsFrom_receiptList {
    ASN1uint32_t count;
    GeneralNames *value;
} ReceiptsFrom_receiptList;

typedef struct ReceiptRequest_receiptsTo {
    ASN1uint32_t count;
    GeneralNames *value;
} ReceiptRequest_receiptsTo;

typedef struct IssuerAndSerialNumber {
    NOCOPYANY issuer;
    SerialNumber serialNumber;
} IssuerAndSerialNumber;

typedef struct ReceiptsFrom {
    ASN1choice_t choice;
    union {
#	define allOrFirstTier_chosen 1
	AllOrFirstTier allOrFirstTier;
#	define receiptList_chosen 2
	ReceiptsFrom_receiptList receiptList;
    } u;
} ReceiptsFrom;

typedef struct Receipt {
    Version version;
    ContentType contentType;
    ContentIdentifier signedContentIdentifier;
    OCTETSTRING originatorSignatureValue;
} Receipt;
#define Receipt_PDU 0
#define SIZE_ESS_Module_PDU_0 sizeof(Receipt)

typedef struct ContentHints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define contentDescription_present 0x80
    ASN1wstring_t contentDescription;
    ObjectIdentifier contentType;
} ContentHints;
#define ContentHints_PDU 1
#define SIZE_ESS_Module_PDU_1 sizeof(ContentHints)

typedef struct ContentReference {
    ContentType contentType;
    ContentIdentifier signedContentIdentifier;
    ASN1octetstring_t originatorSignatureValue;
} ContentReference;
#define ContentReference_PDU 2
#define SIZE_ESS_Module_PDU_2 sizeof(ContentReference)

typedef struct ESSPrivacyMark {
    ASN1choice_t choice;
    union {
#	define utf8String_chosen 1
	ASN1wstring_t utf8String;
#	define pString_chosen 2
	ASN1ztcharstring_t pString;
    } u;
} ESSPrivacyMark;

typedef struct SecurityCategories {
    ASN1uint32_t count;
    struct SecurityCategory *value;
} SecurityCategories;

typedef struct SecurityCategory {
    ObjectIdentifier type;
    NOCOPYANY value;
} SecurityCategory;

typedef struct EquivalentLabels {
    ASN1uint32_t count;
    struct ESSSecurityLabel *value;
} EquivalentLabels;
#define EquivalentLabels_PDU 3
#define SIZE_ESS_Module_PDU_3 sizeof(EquivalentLabels)

typedef struct MLExpansionHistory {
    ASN1uint32_t count;
    struct MLData *value;
} MLExpansionHistory;
#define MLExpansionHistory_PDU 4
#define SIZE_ESS_Module_PDU_4 sizeof(MLExpansionHistory)

typedef struct EntityIdentifier {
    ASN1choice_t choice;
    union {
#	define subjectKeyIdentifier_chosen 1
	SubjectKeyIdentifier subjectKeyIdentifier;
#	define EntityIdentifier_issuerAndSerialNumber_chosen 2
	IssuerAndSerialNumber issuerAndSerialNumber;
    } u;
} EntityIdentifier;

typedef struct MLReceiptPolicy {
    ASN1choice_t choice;
    union {
#	define none_chosen 1
#	define insteadOf_chosen 2
	MLReceiptPolicy_insteadOf insteadOf;
#	define inAdditionTo_chosen 3
	MLReceiptPolicy_inAdditionTo inAdditionTo;
    } u;
} MLReceiptPolicy;

typedef struct SigningCertificate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SigningCertificate_certs certs;
#   define policies_present 0x80
    SigningCertificate_policies policies;
} SigningCertificate;
#define SigningCertificate_PDU 5
#define SIZE_ESS_Module_PDU_5 sizeof(SigningCertificate)

typedef struct ESSCertID {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Hash certHash;
#   define issuerSerial_present 0x80
    IssuerAndSerialNumber issuerSerial;
} ESSCertID;

typedef struct SMimeEncryptCerts {
    ASN1uint32_t count;
    struct SMimeEncryptCert *value;
} SMimeEncryptCerts;
#define SMimeEncryptCerts_PDU 6
#define SIZE_ESS_Module_PDU_6 sizeof(SMimeEncryptCerts)

typedef struct SMIMECapabilities {
    ASN1uint32_t count;
    struct SMIMECapability *value;
} SMIMECapabilities;

typedef struct SMIMECapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectIdentifier capabilityID;
#   define parameters_present 0x80
    ASN1open_t parameters;
} SMIMECapability;

typedef struct OtherKeyAttribute {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectIdentifier keyAttrId;
#   define keyAttr_present 0x80
    ASN1open_t keyAttr;
} OtherKeyAttribute;

typedef struct ReceiptRequest {
    ContentIdentifier signedContentIdentifier;
    ReceiptsFrom receiptsFrom;
    ReceiptRequest_receiptsTo receiptsTo;
} ReceiptRequest;
#define ReceiptRequest_PDU 7
#define SIZE_ESS_Module_PDU_7 sizeof(ReceiptRequest)

typedef struct ESSSecurityLabel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define security_classification_present 0x80
    SecurityClassification security_classification;
    SecurityPolicyIdentifier security_policy_identifier;
#   define privacy_mark_present 0x40
    ESSPrivacyMark privacy_mark;
#   define security_categories_present 0x20
    SecurityCategories security_categories;
} ESSSecurityLabel;
#define ESSSecurityLabel_PDU 9
#define SIZE_ESS_Module_PDU_9 sizeof(ESSSecurityLabel)

typedef struct MLData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EntityIdentifier mailListIdentifier;
    ASN1generalizedtime_t expansionTime;
#   define mlReceiptPolicy_present 0x80
    MLReceiptPolicy mlReceiptPolicy;
} MLData;

typedef struct SMimeEncryptCert {
    Hash hash;
    SMIMECapabilities capabilities;
} SMimeEncryptCert;

typedef struct RecipientKeyIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubjectKeyIdentifier subjectKeyIdentifier;
#   define date_present 0x80
    ASN1generalizedtime_t date;
#   define other_present 0x40
    OtherKeyAttribute other;
} RecipientKeyIdentifier;

typedef struct SMIMEEncryptionKeyPreference {
    ASN1choice_t choice;
    union {
#	define SMIMEEncryptionKeyPreference_issuerAndSerialNumber_chosen 1
	IssuerAndSerialNumber issuerAndSerialNumber;
#	define recipientKeyId_chosen 2
	RecipientKeyIdentifier recipientKeyId;
#	define subjectAltKeyIdentifier_chosen 3
	SubjectKeyIdentifier subjectAltKeyIdentifier;
    } u;
} SMIMEEncryptionKeyPreference;
#define SMIMEEncryptionKeyPreference_PDU 8
#define SIZE_ESS_Module_PDU_8 sizeof(SMIMEEncryptionKeyPreference)

extern ASN1int32_t ub_receiptsTo;
extern ASN1objectidentifier_t id_aa_receiptRequest;
extern ASN1objectidentifier_t id_aa_contentIdentifier;
extern ASN1objectidentifier_t id_ct_receipt;
extern ASN1objectidentifier_t id_aa_contentHint;
extern ASN1objectidentifier_t id_aa_msgSigDigest;
extern ASN1objectidentifier_t id_aa_contentReference;
extern ASN1objectidentifier_t id_aa_securityLabel;
extern ASN1int32_t ub_integer_options;
extern ASN1int32_t ub_privacy_mark_length;
extern ASN1int32_t ub_security_categories;
extern ASN1objectidentifier_t id_aa_equivalentLabels;
extern ASN1objectidentifier_t id_aa_mlExpandHistory;
extern ASN1int32_t ub_ml_expansion_history;
extern ASN1objectidentifier_t id_aa_signingCertificate;

extern ASN1module_t ESS_Module;
extern void ASN1CALL ESS_Module_Startup(void);
extern void ASN1CALL ESS_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _ESS_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\ossconv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       ossconv.cpp
//
//  Contents:   Conversion APIs to/from OSS ASN.1 data structures
//
//  Functions:  OssConvToObjectIdentifier
//              OssConvFromObjectIdentifier
//              OssConvToUTCTime
//              OssConvFromUTCTime
//              OssConvToGeneralizedTime
//              OssConvFromGeneralizedTime
//              OssConvToChoiceOfTime
//              OssConvFromChoiceOfTime
//              OssConvToAttribute
//              OssConvToAlgorithmIdentifier
//              OssConvFromAlgorithmIdentifier
//
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-04.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    28-Mar-96   philh   created
//              03-May-96   kevinr  merged from wincrmsg
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#include "badstrfunctions.h"

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//  These are the old 4.0 versions of these routines.
#define atol StrToInt

char * __cdecl _ltoa(long l, char * psz, int) {wnsprintf(psz, 10, "%d", l); return psz; }

/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

//
// UTCTime in X.509 certs are represented using a 2-digit year
// field (yuk! but true).
//
// According to IETF draft, YY years greater than this are
// to be interpreted as 19YY; YY years less than this are 20YY. Sigh.
//
#define MAGICYEAR               50

#define YEARFIRST               1951
#define YEARLAST                2050
#define YEARFIRSTGENERALIZED    2050

inline BOOL my_isdigit( char ch)
{
    return (ch >= '0') && (ch <= '9');
}

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to OSS's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    char    ch;

    if (psz) {
        unsigned short cMax = *pCount;
        unsigned long *pul = rgulValue;
        while ((ch = *psz) != '\0' && c++ < cMax) {
            *pul++ = (unsigned long)atol(psz);
            while (my_isdigit(ch = *psz++))
                ;
            if (ch != '.')
                break;
        }
        if (ch != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromObjectIdentifier(
    IN unsigned short Count,
    IN unsigned long rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    )
{
    BOOL fResult = TRUE;
    LONG lRemain;

    if (pszObjId == NULL)
        *pcbObjId = 0;

    lRemain = (LONG) *pcbObjId;
    if (Count == 0) {
        if (--lRemain > 0)
            pszObjId++;
    } else {
        char rgch[36];
        LONG lData;
        unsigned long *pul = rgulValue;
        for (; Count > 0; Count--, pul++) {
            _ltoa(*pul, rgch, 10);
            lData = strlen(rgch);
            lRemain -= lData + 1;
            if (lRemain >= 0) {
                if (lData > 0) {
                    memcpy(pszObjId, rgch, lData);
                    pszObjId += lData;
                }
                *pszObjId++ = '.';
            }
        }
    }

    if (lRemain >= 0) {
        *(pszObjId -1) = '\0';
        *pcbObjId = *pcbObjId - (DWORD) lRemain;
    } else {
        *pcbObjId = *pcbObjId + (DWORD) -lRemain;
        if (pszObjId) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Adjust FILETIME for timezone.
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
static BOOL AdjustFileTime(
    IN OUT LPFILETIME pFileTime,
    IN short mindiff,
    IN ossBoolean utc
    )
{
    if (utc || mindiff == 0)
        return TRUE;

    BOOL fResult;
    SYSTEMTIME stmDiff;
    FILETIME ftmDiff;
    short absmindiff;

    memset(&stmDiff, 0, sizeof(stmDiff));
    // Note: FILETIME is 100 nanoseconds interval since January 1, 1601
    stmDiff.wYear   = 1601;
    stmDiff.wMonth  = 1;
    stmDiff.wDay    = 1;

    absmindiff = mindiff > 0 ? mindiff : -mindiff;
    stmDiff.wHour = absmindiff / 60;
    stmDiff.wMinute = absmindiff % 60;
    if (stmDiff.wHour >= 24) {
        stmDiff.wDay += stmDiff.wHour / 24;
        stmDiff.wHour %= 24;
    }
    if ((fResult = SystemTimeToFileTime(&stmDiff, &ftmDiff))) {
        if (mindiff > 0)
            *((_int64 *) pFileTime) += *((_int64 *) &ftmDiff);
        else
            *((_int64 *) pFileTime) -= *((_int64 *) &ftmDiff);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToUTCTime(
    IN LPFILETIME pFileTime,
    OUT UTCTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear > YEARLAST)
        goto YearRangeError;

    pOssTime->year   = t.wYear % 100;
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
TRACE_ERROR(YearRangeError)
}

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromUTCTime(
    IN UTCTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pOssTime->year > MAGICYEAR ?
                    (1900 + pOssTime->year) : (2000 + pOssTime->year);
    t.wMonth  = pOssTime->month;
    t.wDay    = pOssTime->day;
    t.wHour   = pOssTime->hour;
    t.wMinute = pOssTime->minute;
    t.wSecond = pOssTime->second;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pOssTime->mindiff,
        pOssTime->utc
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT GeneralizedTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    pOssTime->year   = t.wYear;
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->millisec = t.wMilliseconds;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}

//+-------------------------------------------------------------------------
//  Convert from OSS's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromGeneralizedTime(
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pOssTime->year;
    t.wMonth  = pOssTime->month;
    t.wDay    = pOssTime->day;
    t.wHour   = pOssTime->hour;
    t.wMinute = pOssTime->minute;
    t.wSecond = pOssTime->second;
    t.wMilliseconds = pOssTime->millisec;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pOssTime->mindiff,
        pOssTime->utc
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}


//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear >= YEARFIRSTGENERALIZED) {
        *pwChoice = OSS_GENERALIZED_TIME_CHOICE;
        pOssTime->year   = t.wYear;
    } else {
        *pwChoice = OSS_UTC_TIME_CHOICE;
        pOssTime->year = t.wYear % 100;
    }
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *pwChoice = 0;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}


//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    if (OSS_UTC_TIME_CHOICE == wChoice)
        return OssConvFromUTCTime(pOssTime, pFileTime);
    else
        return OssConvFromGeneralizedTime(pOssTime, pFileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\essasn.cpp ===
#ifdef SMIME_V3
#include	<windows.h>
//#include        "oss\global.hxx"
//#include        "oss\ossconv.h"
#include        "mimeole.h"

#include "badstrfunctions.h"

extern "C" {
#include        "ess.h"
}
#include        "essOut.h"
#include        "pkiasn1.h"
#include        "crypttls.h"
#include        "msoert.h"

#include        "demand2.h"

#define wcslen my_wcslen
extern int my_wcslen(LPCWSTR pwsz);

//
//

HCRYPTASN1MODULE  ICM_hAsn1Module;

typedef struct {
    LPSTR       szOID;
    LPSTR       szFunc;
} OIDFunction;

static const OIDFunction EssEncodeExFuncTable[] = {
    {szOID_SMIME_Content_Hints, "EssContentHintEncodeEx"},
    {szOID_SMIME_Receipt_Request, "EssReceiptRequestEncodeEx"},
    {szOID_SMIME_ContentType_Receipt, "EssReceiptEncodeEx"},
    {szOID_SMIME_Security_Label, "EssSecurityLabelEncodeEx"},
    {szOID_SMIME_MLExpansion_History, "EssMLHistoryEncodeEx"},
    {szOID_SMIME_Encryption_Key_Preference, "EssKeyExchPreferenceEncodeEx"},
    {szOID_SMIME_Signing_Certificate, "EssSignCertificateEncodeEx"},
};
const int EssEncodeExFuncCount = (sizeof(EssEncodeExFuncTable)/
                                  sizeof(EssEncodeExFuncTable[0]));

static const OIDFunction EssDecodeExFuncTable[] = {
    {szOID_SMIME_Content_Hints, "EssContentHintDecodeEx"},
    {szOID_SMIME_Receipt_Request, "EssReceiptRequestDecodeEx"},
    {szOID_SMIME_ContentType_Receipt, "EssReceiptDecodeEx"},
    {szOID_SMIME_Security_Label, "EssSecurityLabelDecodeEx"},
    {szOID_SMIME_MLExpansion_History, "EssMLHistoryDecodeEx"},
    {szOID_SMIME_Encryption_Key_Preference, "EssKeyExchPreferenceDecodeEx"},
    {szOID_SMIME_Signing_Certificate, "EssSignCertificateDecodeEx"},
};
const int EssDecodeExFuncCount = (sizeof(EssDecodeExFuncTable)/
                                  sizeof(EssDecodeExFuncTable[0]));


STDAPI EssRegisterServer(void)
{
    HRESULT     hr;
    int         i;

    // M00BUG -- need to put in a path for inetcomm.dll!!!!!

    for (i=0; i<EssEncodeExFuncCount; i++) {
        if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                      CRYPT_OID_ENCODE_OBJECT_EX_FUNC,
                                      EssEncodeExFuncTable[i].szOID,
                                      L"inetcomm.dll",
                                      EssEncodeExFuncTable[i].szFunc)) {
            goto InstallError;
        }
    }
        
    for (i=0; i<EssDecodeExFuncCount; i++) {
        if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                      CRYPT_OID_DECODE_OBJECT_EX_FUNC,
                                      EssDecodeExFuncTable[i].szOID,
                                      L"inetcomm.dll",
                                      EssDecodeExFuncTable[i].szFunc)) {
            goto InstallError;
        }
    }
        
    hr = S_OK;
CommonReturn:
    return hr;

InstallError:
    hr = E_FAIL;
    goto CommonReturn;
}

STDAPI EssUnRegisterServer(void)
{
    return S_OK;
}

BOOL WINAPI
EssASNDllMain(HMODULE hInst, ULONG ulReason, LPVOID lpv)
{
    BOOL        fRet;
    
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        ESS_InitDemandLoadLibs();
        break;

    case DLL_PROCESS_DETACH:
        if (ICM_hAsn1Module != NULL) {
            I_CryptUninstallAsn1Module(ICM_hAsn1Module);
            ESS_Module_Cleanup();
        }
        ESS_FreeDemandLoadLibs();
        break;
    }

    fRet = TRUE;
    return fRet;
}

#if 0
///////////////////////////////// STOLEN FUNCTIONS ///////////////////////////
//
//  The following functions were taken from the wincert.cpp file in the
//      ISPU tree.  If possible we should get these exported from crypt32.
//
///////////////////////////////////////////////////////////////////////////////

#define INFO_LEN_ALIGN(a) a

//+-------------------------------------------------------------------------
//  Set/Get Encoded Object Identifier string
//--------------------------------------------------------------------------
//+-------------------------------------------------------------------------
//  Set/Get Object Identifier string
//--------------------------------------------------------------------------
static BOOL OssX509SetObjId(
        IN LPCSTR pszObjId,
        OUT ObjectID *pOss
        )
{
    pOss->count = sizeof(pOss->value) / sizeof(pOss->value[0]);
    if (OssConvToObjectIdentifier(pszObjId, &pOss->count, pOss->value))
        return TRUE;
    else {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
}

static void OssX509GetObjId(
        IN ObjectID *pOss,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    OssConvFromObjectIdentifier(
        pOss->count,
        pOss->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//#define OssX509SetEncodedObjId(pszObjId, pOss) \
//            I_CryptSetOssEncodedOID(pszObjId, (OssEncodedOID *) (pOss))

//#define OssX509GetEncodedObjId(pOss, dwFlags, \
//                ppszObjId, ppbExtra, plRemainExtra) \
//            I_CryptGetOssEncodedOID((OssEncodedOID *) (pOss), dwFlags, \
//                ppszObjId, ppbExtra, plRemainExtra)

//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
inline void OssX509SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT NOCOPYANY *pOss
        )
{
    OssUtilSetAny(pInfo, (OpenType *) pOss);
}
inline void OssX509GetAny(
        IN NOCOPYANY *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    OssUtilGetAny((OpenType *) pOss, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
inline void OssX509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pOss
        )
{
    pOss->value = pInfo->pbData;
    pOss->length = pInfo->cbData;
}
inline void OssX509GetOctetString(
        IN OCTETSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    OssUtilGetOctetString(pOss->length, pOss->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}


#if 0
//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ALT_NAME_ENTRY
//--------------------------------------------------------------------------
BOOL OssX509SetAltNameEntry(
        IN PCERT_ALT_NAME_ENTRY pInfo,
        OUT GeneralName *pOss,
        IN DWORD dwEntryIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;

    // Assumption: OSS choice == dwAltNameChoice
    // OssX509GetAltNameEntry has asserts to verify
    pOss->choice = (unsigned short) pInfo->dwAltNameChoice;

    *pdwErrLocation = 0;

    switch (pInfo->dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        if (!OssX509SetEncodedObjId(pInfo->pOtherName->pszObjId,
                &pOss->u.otherName.type))
            goto ErrorReturn;
        OssX509SetAny(&pInfo->pOtherName->Value, &pOss->u.otherName.value);
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        OssX509SetAny(&pInfo->DirectoryName, &pOss->u.directoryName);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        if (!OssX509SetUnicodeConvertedToIA5(pInfo->pwszRfc822Name,
                &pOss->u.rfc822Name, dwEntryIndex, pdwErrLocation))
            goto ErrorReturn;
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        OssX509SetOctetString(&pInfo->IPAddress, &pOss->u.iPAddress);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        if (!OssX509SetEncodedObjId(pInfo->pszRegisteredID, &pOss->u.registeredID))
            goto ErrorReturn;
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
    case CERT_ALT_NAME_EDI_PARTY_NAME:
    default:
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void OssX509FreeAltNameEntry(
        IN GeneralName *pOss
        )
{
    switch (pOss->choice) {
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        OssX509FreeUnicodeConvertedToIA5(&pOss->u.rfc822Name);
        break;
    default:
        break;
    }
}

BOOL OssX509GetAltNameEntry(
        IN GeneralName *pOss,
        IN DWORD dwFlags,
        OUT PCERT_ALT_NAME_ENTRY pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    DWORD dwAltNameChoice;

    assert(otherName_chosen == CERT_ALT_NAME_OTHER_NAME);
    assert(rfc822Name_chosen == CERT_ALT_NAME_RFC822_NAME);
    assert(dNSName_chosen == CERT_ALT_NAME_DNS_NAME);
    assert(x400Address_chosen == CERT_ALT_NAME_X400_ADDRESS);
    assert(directoryName_chosen == CERT_ALT_NAME_DIRECTORY_NAME);
    assert(ediPartyName_chosen == CERT_ALT_NAME_EDI_PARTY_NAME);
    assert(uniformResourceLocator_chosen == CERT_ALT_NAME_URL);
    assert(iPAddress_chosen == CERT_ALT_NAME_IP_ADDRESS);
    assert(registeredID_chosen == CERT_ALT_NAME_REGISTERED_ID);


    dwAltNameChoice = pOss->choice;
    if (*plRemainExtra >= 0)
        pInfo->dwAltNameChoice = dwAltNameChoice;
    switch (dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        {
            LONG lAlignExtra;
            PCERT_OTHER_NAME pOtherName;

            lAlignExtra = INFO_LEN_ALIGN(sizeof(CERT_OTHER_NAME));
            *plRemainExtra -= lAlignExtra;
            if (*plRemainExtra >= 0) {
                pOtherName = (PCERT_OTHER_NAME) *ppbExtra;
                pInfo->pOtherName = pOtherName;
                *ppbExtra += lAlignExtra;
            } else
                pOtherName = NULL;

            OssX509GetEncodedObjId(&pOss->u.otherName.type, dwFlags,
                &pOtherName->pszObjId, ppbExtra, plRemainExtra);
            OssX509GetAny(&pOss->u.otherName.value, dwFlags,
                &pOtherName->Value, ppbExtra, plRemainExtra);
        }
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        OssX509GetAny(&pOss->u.directoryName, dwFlags,
            &pInfo->DirectoryName, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        OssX509GetIA5ConvertedToUnicode(&pOss->u.rfc822Name, dwFlags,
            &pInfo->pwszRfc822Name, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        OssX509GetOctetString(&pOss->u.iPAddress, dwFlags,
            &pInfo->IPAddress, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        OssX509GetEncodedObjId(&pOss->u.registeredID, dwFlags,
            &pInfo->pszRegisteredID, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
    case CERT_ALT_NAME_EDI_PARTY_NAME:
        break;
    default:
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ALT_NAME_INFO
//--------------------------------------------------------------------------
BOOL OssX509SetAltNames(
        IN PCERT_ALT_NAME_INFO pInfo,
        OUT AltNames *pOss,
        IN DWORD dwIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD i;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    GeneralName *pOssEntry;

    *pdwErrLocation = 0;

    cEntry = pInfo->cAltEntry;
    pEntry = pInfo->rgAltEntry;
    pOss->count = cEntry;
    pOss->value = NULL;
    if (cEntry > 0) {
        pOssEntry =
            (GeneralName *) PkiZeroAlloc(cEntry * sizeof(GeneralName));
        if (pOssEntry == NULL)
            goto ErrorReturn;
        pOss->value = pOssEntry;
    }

    // Array of AltName entries
    for (i = 0; i < cEntry; i++, pEntry++, pOssEntry++) {
        if (!OssX509SetAltNameEntry(pEntry, pOssEntry,
                (dwIndex << 8) | i, pdwErrLocation))
            goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void OssX509FreeAltNames(
        OUT AltNames *pOss
        )
{
    if (pOss->value) {
        DWORD cEntry = pOss->count;
        GeneralName *pOssEntry = pOss->value;
        for ( ; cEntry > 0; cEntry--, pOssEntry++)
            OssX509FreeAltNameEntry(pOssEntry);
        PkiFree(pOss->value);
    }
}

BOOL OssX509GetAltNames(
        IN AltNames *pOss,
        IN DWORD dwFlags,
        OUT PCERT_ALT_NAME_INFO pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    GeneralName *pOssEntry;

    cEntry = pOss->count;
    lAlignExtra = INFO_LEN_ALIGN(cEntry * sizeof(CERT_ALT_NAME_ENTRY));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        pInfo->cAltEntry = cEntry;
        pEntry = (PCERT_ALT_NAME_ENTRY) *ppbExtra;
        pInfo->rgAltEntry = pEntry;
        *ppbExtra += lAlignExtra;
    } else
        pEntry = NULL;

    // Array of AltName entries
    pOssEntry = pOss->value;
    for (; cEntry > 0; cEntry--, pEntry++, pOssEntry++) {
        if (!OssX509GetAltNameEntry(pOssEntry, dwFlags,
                    pEntry, ppbExtra, plRemainExtra))
                return FALSE;
    }
    return TRUE;
}
#endif // 0

//+-------------------------------------------------------------------------
//  Function:  GetPog
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized OssGlobal data structure
//--------------------------------------------------------------------------
static inline POssGlobal GetPog(void)
{
    return I_CryptGetOssGlobal(hX509OssGlobal);
}

#endif // 0

//+-------------------------------------------------------------------------
//  Function:  GetEncoder/GetDecoder
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized Asn1 encoder/decoder data
//             structures
//--------------------------------------------------------------------------
static inline ASN1encoding_t GetEncoder(void)
{
    if (ICM_hAsn1Module == NULL) {
        ESS_Module_Startup();
        if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(ESS_Module, 0, NULL))) {
            return NULL;
        }
    }
    return I_CryptGetAsn1Encoder(ICM_hAsn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    if (ICM_hAsn1Module == NULL) {
        ESS_Module_Startup();
        if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(ESS_Module, 0, NULL))) {
            return NULL;
        }
    }
    return I_CryptGetAsn1Decoder(ICM_hAsn1Module);
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//
//  Called by the OssX509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoEncodeEx(
        IN int pdunum,
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(GetEncoder(), pdunum, pvOssInfo, dwFlags,
                               pEncodePara, pvEncoded, pcbEncoded);
}

//+-------------------------------------------------------------------------
//  Decode into an OSS formatted info structure. Call the callback
//  function to convert into the 'C' data structure. If
//  CRYPT_DECODE_ALLOC_FLAG is set, call the callback twice. First,
//  to get the length of the 'C' data structure. Then after allocating,
//  call again to update the 'C' data structure.
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoDecodeAndAllocEx(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return PkiAsn1DecodeAndAllocInfoEx(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
inline void OssX509SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT NOCOPYANY *pOss
        )
{
    PkiAsn1SetAny(pInfo, pOss);
}
inline void OssX509GetAny(
        IN NOCOPYANY *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetAny(pOss, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
inline void OssX509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pOss
        )
{
    pOss->value = pInfo->pbData;
    pOss->length = pInfo->cbData;
}
inline void OssX509GetOctetString(
        IN OCTETSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pOss, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}


#define OssX509SetEncodedObjId(pszObjId, pOss) \
                PkiAsn1ToObjectIdentifier(pszObjId, &(pOss)->count, (pOss)->value)
// I_CryptSetEncodedOID(pszObjId, pOss)


#define OssX509GetEncodedObjId(pOss, dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra) \
                PkiAsn1FromObjectIdentifier((pOss)->count, (pOss)->value, \
                                            ppszObjId, ppbExtra, plRemainExtra)

//            I_CryptGetEncodedOID(pOss, dwFlags, \
//                ppszObjId, ppbExtra, plRemainExtra)

BOOL
WINAPI
I_CryptSetEncodedOID(
        IN LPSTR pszObjId,
        OUT ASN1encodedOID_t *pEncodedOid
        );

void I_CryptGetEncodedOID(
        IN ASN1encodedOID_t *pEncodedOid,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );



inline BOOL
WINAPI
PkiAsn1SetUTF8String(LPCWSTR pwsz, ASN1wstring_t * pAsn1String)
{
    pAsn1String->length = my_wcslen(pwsz);
    pAsn1String->value = (LPWSTR) pwsz;
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Get UTF8 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetUTF8String(
        IN ASN1wstring_t *putf8String,
        IN DWORD dwFlags,
        OUT LPWSTR *pwszPrivacyMark,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG  lRemainExtra = *plRemainExtra;
    ULONG ulSize = putf8String->length * sizeof(WCHAR);

    lRemainExtra -= (sizeof(WCHAR) + ulSize); 
    if (lRemainExtra < 0) {
        ;
    }
    else {
        LPBYTE pbExtra = *ppbExtra;
        *pwszPrivacyMark = (LPWSTR) pbExtra;
        memcpy(pbExtra, putf8String->value, ulSize);
        pbExtra += ulSize;
        (* ((LPWSTR) pbExtra) ) = '\0'; // null terminate the wsz.
        pbExtra += sizeof(WCHAR);
        *ppbExtra = pbExtra;
    }
    *plRemainExtra = lRemainExtra;
}

#define OssX509GetEncodedUTF8String(putf8String, dwFlags, pwszPrivacyMark, ppbExtra, plRemainExtra) \
        PkiAsn1GetUTF8String(putf8String, dwFlags, pwszPrivacyMark, ppbExtra, plRemainExtra)

                                    
//+-------------------------------------------------------------------------
//  Get PString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetPString(
        IN ASN1ztcharstring_t *pPString,
        IN DWORD dwFlags,
        OUT LPWSTR *pwszPrivacyMark,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG  lRemainExtra = *plRemainExtra;
    INT   cwch = MultiByteToWideChar(CP_ACP, 0, *pPString, -1, NULL, 0);
    ULONG ulSize = cwch * sizeof(WCHAR);

    if (cwch != 0) {
        lRemainExtra -= ulSize; 
        if (lRemainExtra < 0) {
            ;
        }
        else {
            *pwszPrivacyMark = (LPWSTR) *ppbExtra;
            cwch = MultiByteToWideChar(CP_ACP, 0, *pPString, -1, (LPWSTR) *ppbExtra, cwch);
            *ppbExtra += ulSize;
        }
        *plRemainExtra = lRemainExtra;
    }
}

#define OssX509GetEncodedPString(PString, dwFlags, pwszPrivacyMark, ppbExtra, plRemainExtra) \
        PkiAsn1GetPString(PString, dwFlags, pwszPrivacyMark, ppbExtra, plRemainExtra)



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

////    EssContentHintEncodeEx
//
//  Description:
//      This function is used to encode the ContentHint attribute found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssContentHintEncodeEx(IN DWORD dwCertEncodingType,
                                   IN LPCSTR lpszStructType,
                                   IN PSMIME_CONTENT_HINTS pInfo,
                                   IN DWORD dwFlags,
                                   IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                   OUT OPTIONAL void *pvEncoded,
                                   IN OUT DWORD *pcbEncoded
                                   )
{
    BOOL                fResult;
    ContentHints        OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    if (pInfo->pszDescription != NULL) {
        OssInfo.bit_mask |= contentDescription_present;
        OssInfo.contentDescription.length = wcslen(pInfo->pszDescription)*2;
        OssInfo.contentDescription.value = pInfo->pszDescription;
    }
    OssInfo.contentType.count = sizeof(OssInfo.contentType.value)/sizeof(OssInfo.contentType.value[0]);
    if (!OssX509SetEncodedObjId(pInfo->pszOIDContent, &OssInfo.contentType)) {
        goto ErrorReturn;
    }

    fResult = OssInfoEncodeEx(ContentHints_PDU, &OssInfo, dwFlags,
                              pEncodePara, pvEncoded, pcbEncoded);
CommonReturn:
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

////    

STDAPI_(BOOL) EssContentHintDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                           PCRYPT_DECODE_PARA pDecodePara,
                                           void *pvStructInfo, LONG *plRemainExtra)
{
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    PSMIME_CONTENT_HINTS        pInfo = (PSMIME_CONTENT_HINTS) pvStructInfo;
    ContentHints *              pOssInfo = (ContentHints *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_CONTENT_HINTS);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_CONTENT_HINTS);
    }
    else {
        pbExtra = NULL;
    }

    // decode the content-hint description.
    if (pOssInfo->bit_mask & contentDescription_present) {
        OssX509GetEncodedUTF8String(&pOssInfo->contentDescription, dwFlags,
                                    (pInfo == NULL) ? NULL : &pInfo->pszDescription,
                                    &pbExtra, &lRemainExtra);
    }

    // decode the content-hint oid.
    OssX509GetEncodedObjId(&pOssInfo->contentType, dwFlags, &pInfo->pszOIDContent, 
                           &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssContentHintDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssContentHintDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(ContentHints_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssContentHintDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}


////    EssReceiptRequestEncodeEx
//
//  Description:
//      This function is used to encode the ReceiptRequest attribute found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssReceiptRequestEncodeEx(IN DWORD dwCertEncodingType,
                                   IN LPCSTR lpszStructType,
                                   IN PSMIME_RECEIPT_REQUEST pInfo,
                                   IN DWORD dwFlags,
                                   IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                   OUT OPTIONAL void *pvEncoded,
                                   IN OUT DWORD *pcbEncoded
                                   )
{
    BOOL                fResult;
    DWORD               i;
    ReceiptRequest      OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    //  ContentIdentifier
    OssInfo.signedContentIdentifier.length = pInfo->ContentIdentifier.cbData;
    OssInfo.signedContentIdentifier.value = pInfo->ContentIdentifier.pbData;

    // Receipts From
    if (pInfo->ReceiptsFrom.cNames > 0) {
        OssInfo.receiptsFrom.choice = receiptList_chosen;
        OssInfo.receiptsFrom.u.receiptList.count = pInfo->ReceiptsFrom.cNames;
        OssInfo.receiptsFrom.u.receiptList.value = 
            (NOCOPYANY *) malloc(pInfo->ReceiptsFrom.cNames * sizeof(NOCOPYANY));
        if (OssInfo.receiptsFrom.u.receiptList.value == NULL) {
            goto ErrorReturn;
        }
        for (i=0; i<pInfo->ReceiptsFrom.cNames; i++) {
            OssX509SetAny(&pInfo->ReceiptsFrom.rgNames[i],
                          &OssInfo.receiptsFrom.u.receiptList.value[i]);
        }
    }
    else {
        OssInfo.receiptsFrom.choice = allOrFirstTier_chosen;
        OssInfo.receiptsFrom.u.allOrFirstTier = pInfo->ReceiptsFrom.AllOrFirstTier;
    }

    // Receipts To

    OssInfo.receiptsTo.count = (USHORT) pInfo->cReceiptsTo;
    OssInfo.receiptsTo.value = 
            (NOCOPYANY *) malloc(pInfo->cReceiptsTo * sizeof(NOCOPYANY));
    if (OssInfo.receiptsTo.value == NULL) {
        goto ErrorReturn;
    }
    
    for (i=0; i<pInfo->cReceiptsTo; i++) {
        OssX509SetAny(&pInfo->rgReceiptsTo[i],
                      &OssInfo.receiptsTo.value[i]);
    }

    fResult = OssInfoEncodeEx(ReceiptRequest_PDU, &OssInfo, dwFlags,
                              pEncodePara, pvEncoded, pcbEncoded);
CommonReturn:
    if (OssInfo.receiptsFrom.u.receiptList.value != NULL) {
        free(OssInfo.receiptsFrom.u.receiptList.value);
    }
    if (OssInfo.receiptsTo.value != NULL) {
        free(OssInfo.receiptsTo.value);
    }
    
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

////    

STDAPI_(BOOL) EssReceiptRequestDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                           PCRYPT_DECODE_PARA pDecodePara,
                                           void *pvStructInfo, LONG *plRemainExtra)
{
    DWORD                       cb;
    DWORD                       i;
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    PSMIME_RECEIPT_REQUEST      pInfo = (PSMIME_RECEIPT_REQUEST) pvStructInfo;
    ReceiptRequest *            pOssInfo = (ReceiptRequest *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_RECEIPT_REQUEST);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_RECEIPT_REQUEST);
        memset(pInfo, 0, sizeof(SMIME_RECEIPT_REQUEST));
    }
    else {
        pbExtra = NULL;
        pInfo = NULL;
    }

    //
    //  ContentIdentifier
    //

    if (pOssInfo->signedContentIdentifier.length > 0) {
        lRemainExtra -= pOssInfo->signedContentIdentifier.length;
        if (lRemainExtra >= 0) {
            pInfo->ContentIdentifier.cbData = 
                pOssInfo->signedContentIdentifier.length;
            pInfo->ContentIdentifier.pbData = pbExtra;
            memcpy(pbExtra, pOssInfo->signedContentIdentifier.value,
                   pOssInfo->signedContentIdentifier.length);
            pbExtra += pOssInfo->signedContentIdentifier.length;
        }
    }

    //
    //  ReceiptsFrom
    //

    if (pOssInfo->receiptsFrom.choice == receiptList_chosen) {
        cb = pOssInfo->receiptsFrom.u.receiptList.count * sizeof(CERT_NAME_BLOB);
        lRemainExtra -= cb;
            
        if (lRemainExtra >= 0) {
            pInfo->ReceiptsFrom.cNames = pOssInfo->receiptsFrom.u.receiptList.count;
            pInfo->ReceiptsFrom.rgNames = (CERT_NAME_BLOB *) pbExtra;
            pbExtra += cb;
        }

        for (i=0; i<pOssInfo->receiptsFrom.u.receiptList.count; i++) {
            OssX509GetAny(&pOssInfo->receiptsFrom.u.receiptList.value[i], dwFlags,
                          (pInfo == NULL) ? NULL : &pInfo->ReceiptsFrom.rgNames[i],
                          &pbExtra, &lRemainExtra);
        }
    }
    else {
        if (pInfo != NULL) {
            pInfo->ReceiptsFrom.AllOrFirstTier = 
                pOssInfo->receiptsFrom.u.allOrFirstTier;
        }
    }

    //  ReceiptsTo

    cb = pOssInfo->receiptsTo.count * sizeof(CERT_NAME_BLOB);
    lRemainExtra -= cb;
    if (lRemainExtra >= 0) {
        pInfo->cReceiptsTo = pOssInfo->receiptsTo.count;
        pInfo->rgReceiptsTo = (CERT_NAME_BLOB *) pbExtra;
        pbExtra += cb;
    }
    
    for (i=0; i<pOssInfo->receiptsTo.count; i++) {
        OssX509GetAny(&pOssInfo->receiptsTo.value[i], dwFlags,
                      (pInfo == NULL) ? NULL : &pInfo->rgReceiptsTo[i], 
                      &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssReceiptRequestDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssReceiptRequestDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(ReceiptRequest_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssReceiptRequestDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}


////////////////////////////// Receipt Content Type ///////////////////////////////////

////    EssReceiptEncodeEx
//
//  Description:
//      This function is used to encode the Receipt content type found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssReceiptEncodeEx(IN DWORD dwCertEncodingType,
                               IN LPCSTR lpszStructType,
                               IN PSMIME_RECEIPT pInfo,
                               IN DWORD dwFlags,
                               IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                               OUT OPTIONAL void *pvEncoded,
                               IN OUT DWORD *pcbEncoded
                               )
{
    BOOL                fResult;
    DWORD               i;
    Receipt             OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    //  Version number
    OssInfo.version = pInfo->Version;

    //  ContentType
    OssInfo.contentType.count = sizeof(OssInfo.contentType.value)/sizeof(OssInfo.contentType.value[0]);
    fResult = OssX509SetEncodedObjId(pInfo->pszOIDContent, &OssInfo.contentType);
    if (!fResult) {
        goto ErrorReturn;
    }
    
    //  ContentIdentifier
    OssInfo.signedContentIdentifier.length = pInfo->ContentIdentifier.cbData;
    OssInfo.signedContentIdentifier.value = pInfo->ContentIdentifier.pbData;

    //  Originator signature

    OssX509SetOctetString(&pInfo->OriginatorSignature, 
                          &OssInfo.originatorSignatureValue);

    //  Do the actual encoding

    fResult = OssInfoEncodeEx(Receipt_PDU, &OssInfo, dwFlags, pEncodePara, 
                              pvEncoded, pcbEncoded);
CommonReturn:
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

////    

STDAPI_(BOOL) EssReceiptDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                       PCRYPT_DECODE_PARA pDecodePara,
                                       void *pvStructInfo, LONG *plRemainExtra)
{
    DWORD                       cb;
    DWORD                       i;
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    PSMIME_RECEIPT              pInfo = (PSMIME_RECEIPT) pvStructInfo;
    Receipt *                   pOssInfo = (Receipt *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_RECEIPT);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_RECEIPT);
        memset(pInfo, 0, sizeof(SMIME_RECEIPT));
    }
    else {
        pbExtra = NULL;
    }

    //
    //  VersionNumber
    //

    if (pInfo != NULL) {
        pInfo->Version = pOssInfo->version;
    }

    //  ContentType
    #pragma prefast(suppress:11, "&pInfo->pszOIDContent is OK when pInfo is NULL");
    OssX509GetEncodedObjId(&pOssInfo->contentType, dwFlags, &pInfo->pszOIDContent, 
                           &pbExtra, &lRemainExtra);

    //
    //  ContentIdentifier
    //

    if (pOssInfo->signedContentIdentifier.length > 0) {
        lRemainExtra -= pOssInfo->signedContentIdentifier.length;
        if (lRemainExtra >= 0) {
            pInfo->ContentIdentifier.cbData = 
                pOssInfo->signedContentIdentifier.length;
            pInfo->ContentIdentifier.pbData = pbExtra;
            memcpy(pbExtra, pOssInfo->signedContentIdentifier.value,
                   pOssInfo->signedContentIdentifier.length);
            pbExtra += pOssInfo->signedContentIdentifier.length;
        }
    }

    //
    //  Originator signature
    //
    #pragma prefast(suppress:11, "&pInfo->OriginatorSignature is OK when pInfo is NULL");
    OssX509GetOctetString(&pOssInfo->originatorSignatureValue, dwFlags,
                          &pInfo->OriginatorSignature, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssReceiptDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssReceiptDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(Receipt_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssReceiptDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}


////////////////////////////// ML Expansion History /////////////////////////////////

////    EssMLHistoryEncodeEx
//
//  Description:
//      This function is used to encode the MLHistory content type found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssMLHistoryEncodeEx(IN DWORD dwCertEncodingType,
                                 IN LPCSTR lpszStructType,
                                 IN PSMIME_ML_EXPANSION_HISTORY pInfo,
                                 IN DWORD dwFlags,
                                 IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                 OUT OPTIONAL void *pvEncoded,
                                 IN OUT DWORD *pcbEncoded
                                 )
{
    BOOL                fResult;
    DWORD               i;
    DWORD               i1;
    MLExpansionHistory  OssInfo;
    MLData *            pData;
    PSMIME_MLDATA       pMLData;

    memset(&OssInfo, 0, sizeof(OssInfo));

    //  Move over the count
    OssInfo.count = (USHORT) pInfo->cMLData;
    pData = OssInfo.value = (MLData *) malloc(OssInfo.count * sizeof(MLData));
    if (pData == NULL) {
        goto ErrorReturn;
    }
    memset(OssInfo.value, 0, OssInfo.count*sizeof(MLData));

    //    Assert(none_chosen == SMIME_MLPOLICY_NONE);
    //    Assert(insteadOf_chosen == SMIME_MLPOLICY_INSTEAD_OF);
    //    Assert(inAdditionTo_chosen == SMIME_MLPOLICY_IN_ADDITION_TO);

    pMLData = pInfo->rgMLData;
    for (i=0; i<OssInfo.count; i++, pData++, pMLData++) {
        if (pMLData->dwChoice == SMIME_MLDATA_SUBJECT_KEY_IDENTIFIER) {
            pData->mailListIdentifier.choice = subjectKeyIdentifier_chosen;

            PkiAsn1SetOctetString(&pMLData->SubjectKeyIdentifier,
                          &pData->mailListIdentifier.u.subjectKeyIdentifier);
        }
        else {
            pData->mailListIdentifier.choice = EntityIdentifier_issuerAndSerialNumber_chosen;
            PkiAsn1SetHugeInteger(&pMLData->u.SerialNumber,
                          &pData->mailListIdentifier.u.issuerAndSerialNumber.serialNumber);
            PkiAsn1SetAny(&pMLData->u.Issuer,
                          &pData->mailListIdentifier.u.issuerAndSerialNumber.issuer);
        }
        
        PkiAsn1ToGeneralizedTime(&pMLData->ExpansionTime, &pData->expansionTime);
        
        if (pMLData->dwPolicy != SMIME_MLPOLICY_NO_CHANGE) {
            pData->bit_mask |= mlReceiptPolicy_present;
            pData->mlReceiptPolicy.choice = (USHORT) pMLData->dwPolicy;
            if (pData->mlReceiptPolicy.choice != SMIME_MLPOLICY_NONE) {
                pData->mlReceiptPolicy.u.insteadOf.count = pMLData->cNames;
                pData->mlReceiptPolicy.u.insteadOf.value = (GeneralNames *)
                    malloc(pData->mlReceiptPolicy.u.insteadOf.count * sizeof(GeneralNames));
                if (pData->mlReceiptPolicy.u.insteadOf.value == NULL) {
                    goto ErrorReturn;
                }
                for (i1=0; i1<pData->mlReceiptPolicy.u.insteadOf.count; i1++) {
                    OssX509SetAny(&pMLData->rgNames[i1],
                                  &pData->mlReceiptPolicy.u.insteadOf.value[i1]);
                }
            }
        }
    }

    //  Do the actual encoding

    fResult = OssInfoEncodeEx(MLExpansionHistory_PDU, &OssInfo, dwFlags, pEncodePara, 
                              pvEncoded, pcbEncoded);
CommonReturn:
    if (OssInfo.value != NULL) {
        for (pData = OssInfo.value, i=0; i<OssInfo.count; i++, pData++) {
            PkiAsn1FreeHugeInteger(pData->mailListIdentifier.u.issuerAndSerialNumber.serialNumber);
            if (pData->mlReceiptPolicy.u.insteadOf.value != NULL) {
                free(pData->mlReceiptPolicy.u.insteadOf.value);
            }
        }
        free(OssInfo.value);
    }
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

////    

STDAPI_(BOOL) EssMLHistoryDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                       PCRYPT_DECODE_PARA pDecodePara,
                                       void *pvStructInfo, LONG *plRemainExtra)
{
    DWORD                       cb;
    DWORD                       i;
    DWORD                       i1;
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    MLData *                    pData;
    PSMIME_ML_EXPANSION_HISTORY pInfo = (PSMIME_ML_EXPANSION_HISTORY) pvStructInfo;
    PSMIME_MLDATA               pMLData;
    MLExpansionHistory *        pOssInfo = (MLExpansionHistory *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_ML_EXPANSION_HISTORY);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_ML_EXPANSION_HISTORY);
        memset(pInfo, 0, sizeof(SMIME_ML_EXPANSION_HISTORY));
    }
    else {
        pbExtra = NULL;
        pInfo = NULL;
    }

    lRemainExtra -= pOssInfo->count * sizeof(SMIME_MLDATA);
    if (lRemainExtra >= 0) {
        pInfo->cMLData = pOssInfo->count;
        pMLData = pInfo->rgMLData = (PSMIME_MLDATA) pbExtra;
        pbExtra += pOssInfo->count * sizeof(SMIME_MLDATA);
    }

    for (i=0, pData = pOssInfo->value; i<pOssInfo->count; i++, pData++) {
        if (pData->mailListIdentifier.choice == subjectKeyIdentifier_chosen) {
            pData->mailListIdentifier.choice = subjectKeyIdentifier_chosen;
            PkiAsn1GetOctetString(&pData->mailListIdentifier.u.subjectKeyIdentifier,
                                  dwFlags, &pMLData->SubjectKeyIdentifier, 
                                  &pbExtra, &lRemainExtra);
        }
        else {
            pData->mailListIdentifier.choice = EntityIdentifier_issuerAndSerialNumber_chosen;
            PkiAsn1GetHugeInteger(pData->mailListIdentifier.u.issuerAndSerialNumber.serialNumber,
                               dwFlags, &pMLData->u.SerialNumber, 
                               &pbExtra, &lRemainExtra);
            PkiAsn1GetAny(&pData->mailListIdentifier.u.issuerAndSerialNumber.issuer,
                          dwFlags, &pMLData->u.Issuer, 
                          &pbExtra, &lRemainExtra);
        }
        
        if (lRemainExtra >= 0) {
            PkiAsn1FromGeneralizedTime(&pData->expansionTime, &pMLData->ExpansionTime);
        }            
        if (pData->bit_mask & mlReceiptPolicy_present) {
            if (lRemainExtra >= 0) {
                pMLData->dwPolicy = pData->mlReceiptPolicy.choice;
            }

            if (pData->mlReceiptPolicy.choice != none_chosen) {
                lRemainExtra -= pData->mlReceiptPolicy.u.insteadOf.count * sizeof(GeneralNames);
                if (lRemainExtra >= 0) {
                    pMLData->cNames = pData->mlReceiptPolicy.u.insteadOf.count;
                    pMLData->rgNames = (CERT_NAME_BLOB *) pbExtra;
                    pbExtra += pMLData->cNames * sizeof(CERT_NAME_BLOB);
                }
                for (i1=0; i1<pData->mlReceiptPolicy.u.insteadOf.count; i1++) {
                    OssX509GetAny(&pData->mlReceiptPolicy.u.insteadOf.value[i1],
                                  dwFlags, &pMLData->rgNames[i1], &pbExtra,
                                  &lRemainExtra);
                }
            }
        }
        else if (lRemainExtra >= 0) {
            pMLData->dwPolicy = SMIME_MLPOLICY_NO_CHANGE;
        }
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssMLHistoryDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssMLHistoryDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(MLExpansionHistory_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssMLHistoryDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}

/////////////////////////////////////////////////////////////////////////////

////    EssSecurityLabelEncodeEx
//
//  Description:
//      This function is used to encode the SecurityLabel attribute found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Security_Label
//      pInfo                   - external passed structure with Security Label
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssSecurityLabelEncodeEx(IN DWORD dwCertEncodingType,
                                   IN LPCSTR lpszStructType,
                                   IN PSMIME_SECURITY_LABEL pInfo,
                                   IN DWORD dwFlags,
                                   IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                   OUT OPTIONAL void *pvEncoded,
                                   IN OUT DWORD *pcbEncoded
                                   )
{
    BOOL                fResult;
    DWORD               i;
    ESSSecurityLabel    OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    OssInfo.security_policy_identifier.count = sizeof(OssInfo.security_policy_identifier.value)/sizeof(OssInfo.security_policy_identifier.value[0]);
    if (!OssX509SetEncodedObjId(pInfo->pszObjIdSecurityPolicy,
                         &OssInfo.security_policy_identifier)) {
        goto ErrorReturn;
    }
    
    if (pInfo->fHasClassification) {
        OssInfo.bit_mask |= security_classification_present;
        OssInfo.security_classification = (USHORT) pInfo->dwClassification;
    }

    if (pInfo->wszPrivacyMark != NULL) {
        OssInfo.bit_mask |= privacy_mark_present;
        OssInfo.privacy_mark.choice = utf8String_chosen;
        PkiAsn1SetUTF8String(pInfo->wszPrivacyMark, &OssInfo.privacy_mark.u.utf8String);
    }

    if (pInfo->cCategories != 0) {
        OssInfo.bit_mask |= security_categories_present;
        OssInfo.security_categories.count = (USHORT) pInfo->cCategories;
        OssInfo.security_categories.value = (SecurityCategory *)
            malloc(OssInfo.security_categories.count * sizeof(SecurityCategory));
        for (i=0; i<pInfo->cCategories; i++) {
            OssInfo.security_categories.value[i].type.count = sizeof(OssInfo.security_categories.value[0].type.value)/sizeof(OssInfo.security_categories.value[0].type.value[0]);
            if (!OssX509SetEncodedObjId(pInfo->rgCategories[i].pszObjId,
                                 &OssInfo.security_categories.value[i].type)) {
                goto ErrorReturn;
            }
            OssX509SetAny(&pInfo->rgCategories[i].Value,
                          &OssInfo.security_categories.value[i].value);
        }
    }

    fResult = OssInfoEncodeEx(ESSSecurityLabel_PDU, &OssInfo, dwFlags,
                              pEncodePara, pvEncoded, pcbEncoded);
CommonReturn:
    if (OssInfo.security_categories.value != NULL) {
        free(OssInfo.security_categories.value);
    }
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

////    

STDAPI_(BOOL) EssSecurityLabelDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                           PCRYPT_DECODE_PARA pDecodePara,
                                           void *pvStructInfo, LONG *plRemainExtra)
{
    DWORD                       cb;
    DWORD                       i;
    LONG                        lRemainExtra = *plRemainExtra;
    CRYPT_ATTRIBUTE_TYPE_VALUE * pattr;
    LPBYTE                      pbExtra;
    PSMIME_SECURITY_LABEL       pInfo = (PSMIME_SECURITY_LABEL) pvStructInfo;
    ESSSecurityLabel *          pOssInfo = (ESSSecurityLabel *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_SECURITY_LABEL);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_SECURITY_LABEL);
        memset(pInfo, 0, sizeof(*pInfo));
    }
    else {
        pbExtra = NULL;
        pInfo = NULL;
    }

    if (lRemainExtra >= 0) {
        pInfo->pszObjIdSecurityPolicy = (LPSTR) pbExtra;
    }
    OssX509GetEncodedObjId(&pOssInfo->security_policy_identifier, dwFlags,
                    (pInfo == NULL) ? NULL : &pInfo->pszObjIdSecurityPolicy, 
                    &pbExtra, &lRemainExtra);

    if ((pInfo != NULL) &&
        (pOssInfo->bit_mask & security_classification_present)) {
        pInfo->dwClassification = pOssInfo->security_classification;
        pInfo->fHasClassification = TRUE;
    }

    if (pOssInfo->bit_mask & privacy_mark_present) {
        if (utf8String_chosen == pOssInfo->privacy_mark.choice) {
            OssX509GetEncodedUTF8String(&pOssInfo->privacy_mark.u.utf8String, dwFlags,
                                        (pInfo == NULL) ? NULL : &pInfo->wszPrivacyMark,
                                        &pbExtra, &lRemainExtra);
        }
        else if (pString_chosen == pOssInfo->privacy_mark.choice) {            
            Assert(NULL != pOssInfo->privacy_mark.u.pString);
            OssX509GetEncodedPString(&pOssInfo->privacy_mark.u.pString, dwFlags,
                                        (pInfo == NULL) ? NULL : &pInfo->wszPrivacyMark,
                                        &pbExtra, &lRemainExtra);
        }
        else {
            return FALSE; // unknown privacy_mark encoding...
        }
    }

    if (pOssInfo->bit_mask & security_categories_present) {
        cb = pOssInfo->security_categories.count *
            sizeof(CRYPT_ATTRIBUTE_TYPE_VALUE);
        lRemainExtra -= cb;

        if (lRemainExtra >= 0) {
            pInfo->cCategories = pOssInfo->security_categories.count;
            pattr = pInfo->rgCategories = (CRYPT_ATTRIBUTE_TYPE_VALUE *) pbExtra;
            pbExtra += cb;
        }
        else {
            pattr = NULL;
        }

        for (i=0; i<pOssInfo->security_categories.count; i++, pattr++) {
            OssX509GetEncodedObjId(&pOssInfo->security_categories.value[i].type,
                            dwFlags, (pattr == NULL) ? NULL : &pattr->pszObjId,
                            &pbExtra, &lRemainExtra);
            OssX509GetAny(&pOssInfo->security_categories.value[i].value,
                          dwFlags, (pattr == NULL) ? NULL : &pattr->Value,
                          &pbExtra, &lRemainExtra);
        }
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssSecurityLabelDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Security Label decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssSecurityLabelDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(ESSSecurityLabel_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssSecurityLabelDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}

///////////////////////////////////////////////////////////////////////

BOOL DH_ImportPublicKeyInfoEx(HCRYPTPROV hprov, DWORD dwCertEncodingType,
                              PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID algId,
                              DWORD dwFlags,
                              void * pvAuxInfo, HCRYPTKEY * phKey)
{
    DWORD                       cb;
    int                         cbBlob;
    DWORD                       cbKey;
    BOOL                        fRet = FALSE;
    HRESULT                     hr;
    LPBYTE                      pb;
    CRYPT_UINT_BLOB *           pblob = NULL;
    LPBYTE                      pbBlob = NULL;
    DHPUBKEY *                  pdhPubKey;
    PCERT_DSS_PARAMETERS        pDssParameters = NULL;
    PUBLICKEYSTRUC *            pKeyBlob;

    hr = HrDecodeObject(pInfo->Algorithm.Parameters.pbData,
                        pInfo->Algorithm.Parameters.cbData,
                        X509_DSS_PARAMETERS, 0, &cb, (LPVOID*) &pDssParameters);
    if (FAILED(hr)) {
        goto Exit;
    }

    cbKey = pDssParameters->p.cbData;
    if (0 == cbKey) {
        goto Exit;
    }
    
    cbBlob = sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) + 3*cbKey;

    pbBlob = (LPBYTE) malloc(cbBlob);

    pKeyBlob = (PUBLICKEYSTRUC *) pbBlob;
    pKeyBlob->bType = PUBLICKEYBLOB;
    pKeyBlob->bVersion = CUR_BLOB_VERSION;
    pKeyBlob->aiKeyAlg = CALG_DH_EPHEM;
    
    pdhPubKey = (DHPUBKEY *) &pKeyBlob[1];
    pdhPubKey->magic = 0x33484400;
    pdhPubKey->bitlen = cbKey*8;

    pb = (LPBYTE) &pdhPubKey[1];
    memcpy(pb, pDssParameters->p.pbData, cbKey);
    pb += cbKey;
    
    //    memcpy(pb, pDssParameters->q.pbData, pDssParameters->q.cbData);
    //    pb += pDssParameters->q.cbData;
    
    memcpy(pb, pDssParameters->g.pbData, cbKey);
    pb += cbKey;
    
    memcpy(pb, pInfo->PublicKey.pbData, cbKey);
    pb += cbKey;

    Assert(cbBlob == (pb - pbBlob));
    
    //    memcpy(pb, &seed, sizeof(seed));
    

    if (!CryptImportKey(hprov, pbBlob, cbBlob, NULL, 0, phKey)) {
        goto Exit;
    }

    fRet = TRUE;
Exit:
    if (pblob != NULL)          LocalFree(pblob);
    if (pbBlob != NULL)         free(pbBlob);
    if (pDssParameters != NULL) LocalFree(pDssParameters);
    return fRet;
}
#endif // SMIME_V3

////////////////////////////////////////////////////////////////////////////////

////    EssContentHintEncodeEx
//
//  Description:
//      This function is used to encode the ContentHint attribute found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssKeyExchPreferenceEncodeEx(IN DWORD dwCertEncodingType,
                                         IN LPCSTR lpszStructType,
                                         IN PSMIME_ENC_KEY_PREFERENCE pInfo,
                                         IN DWORD dwFlags,
                                         IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                         OUT OPTIONAL void *pvEncoded,
                                         IN OUT DWORD *pcbEncoded)
{
    BOOL                                fResult;
    SMIMEEncryptionKeyPreference        OssInfo;
    
    memset(&OssInfo, 0, sizeof(OssInfo));

    switch (pInfo->RecipientId.dwIdChoice) {
    case CERT_ID_ISSUER_SERIAL_NUMBER:
        OssInfo.choice = SMIMEEncryptionKeyPreference_issuerAndSerialNumber_chosen;
        PkiAsn1SetHugeInteger(&pInfo->RecipientId.IssuerSerialNumber.SerialNumber,
                              &OssInfo.u.issuerAndSerialNumber.serialNumber);
        PkiAsn1SetAny(&pInfo->RecipientId.IssuerSerialNumber.Issuer,
                      &OssInfo.u.issuerAndSerialNumber.issuer);
        break;

    case CERT_ID_KEY_IDENTIFIER:
        OssInfo.choice = recipientKeyId_chosen;
        OssX509SetOctetString(&pInfo->RecipientId.KeyId,
                              &OssInfo.u.recipientKeyId.subjectKeyIdentifier);
        if ((pInfo->Date.dwLowDateTime != 0) || (pInfo->Date.dwHighDateTime != 0)) {
            
            PkiAsn1ToGeneralizedTime(&pInfo->Date, &OssInfo.u.recipientKeyId.date);
        }
        if (pInfo->pOtherAttr != NULL) {
            if (!OssX509SetEncodedObjId(pInfo->pOtherAttr->pszObjId,
                                        &OssInfo.u.recipientKeyId.other.keyAttrId)) {
                goto ErrorReturn;
            }

            if (pInfo->pOtherAttr->Value.cbData != 0) {
                OssInfo.u.recipientKeyId.other.bit_mask |= keyAttr_present;
                PkiAsn1SetAny(&pInfo->pOtherAttr->Value,
                              &OssInfo.u.recipientKeyId.other.keyAttr);
            }
        }
        break;

    case CERT_ID_SHA1_HASH:
        OssInfo.choice = subjectAltKeyIdentifier_chosen;
        OssX509SetOctetString(&pInfo->RecipientId.HashId,
                              &OssInfo.u.subjectAltKeyIdentifier);
        break;

    default:
        goto ErrorReturn;
    }

    fResult = OssInfoEncodeEx(SMIMEEncryptionKeyPreference_PDU, &OssInfo, dwFlags,
                              pEncodePara, pvEncoded, pcbEncoded);
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


STDAPI_(BOOL) EssKeyExchPreferenceDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                           PCRYPT_DECODE_PARA pDecodePara,
                                           void *pvStructInfo, LONG *plRemainExtra)
{
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    PSMIME_ENC_KEY_PREFERENCE   pInfo = (PSMIME_ENC_KEY_PREFERENCE) pvStructInfo;
    SMIMEEncryptionKeyPreference *  pOssInfo = (SMIMEEncryptionKeyPreference *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_ENC_KEY_PREFERENCE);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_ENC_KEY_PREFERENCE);
    }
    else {
        pbExtra = NULL;
    }

    switch (pOssInfo->choice) {
    case SMIMEEncryptionKeyPreference_issuerAndSerialNumber_chosen:
        if (pInfo != NULL) {
            pInfo->RecipientId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
        }
        PkiAsn1GetHugeInteger(pOssInfo->u.issuerAndSerialNumber.serialNumber,
                              dwFlags, (pInfo == NULL) ? NULL :
                               &pInfo->RecipientId.IssuerSerialNumber.SerialNumber,
                              &pbExtra, &lRemainExtra);
        PkiAsn1GetAny(&pOssInfo->u.issuerAndSerialNumber.issuer, dwFlags,
                      (pInfo == NULL) ? NULL :
                                &pInfo->RecipientId.IssuerSerialNumber.Issuer,
                      &pbExtra, &lRemainExtra);
        break;

    case recipientKeyId_chosen:
        if (pInfo != NULL) {
            pInfo->RecipientId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
        }
        OssX509GetOctetString(&pOssInfo->u.recipientKeyId.subjectKeyIdentifier,
                              dwFlags, &pInfo->RecipientId.KeyId,
                              &pbExtra, &lRemainExtra);
        if ((lRemainExtra >= 0) &&
            (pOssInfo->u.recipientKeyId.bit_mask & date_present)) {
            PkiAsn1FromGeneralizedTime(&pOssInfo->u.recipientKeyId.date,
                                       &pInfo->Date);
        }

        if (pOssInfo->u.recipientKeyId.bit_mask & other_present) {
            OssX509GetEncodedObjId(&pOssInfo->u.recipientKeyId.other.keyAttrId,
                                   dwFlags, (pInfo == NULL) ? NULL :
                                        &pInfo->pOtherAttr->pszObjId, 
                                   &pbExtra, &lRemainExtra);
            if (pOssInfo->u.recipientKeyId.other.bit_mask & keyAttr_present) {
                PkiAsn1GetAny(&pOssInfo->u.recipientKeyId.other.keyAttr,
                              dwFlags, (pInfo == NULL) ? NULL :
                              &pInfo->pOtherAttr->Value, &pbExtra, &lRemainExtra);
            }
        }
        break;

    case subjectAltKeyIdentifier_chosen:
        if (pInfo != NULL) {
            pInfo->RecipientId.dwIdChoice = CERT_ID_SHA1_HASH;
        }
        OssX509GetOctetString(&pOssInfo->u.subjectAltKeyIdentifier, dwFlags,
                              &pInfo->RecipientId.HashId, &pbExtra, &lRemainExtra);
        break;

    default:
        return FALSE;
    }
     
    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssKeyExchPreferenceDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssKeyExchPreferenceDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(SMIMEEncryptionKeyPreference_PDU, pbEncoded,
                                   cbEncoded, dwFlags, pDecodePara, 
                                   EssKeyExchPreferenceDecodeExCallback,
                                   pvStructInfo, pcbStructInfo);
}

////    EssSignCertificateEncodeEx
//
//  Description:
//      This function is used to encode the ContentHint attribute found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssSignCertificateEncodeEx(IN DWORD dwCertEncodingType,
                                       IN LPCSTR lpszStructType,
                                       IN PSMIME_SIGNING_CERTIFICATE pInfo,
                                       IN DWORD dwFlags,
                                       IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                       OUT OPTIONAL void *pvEncoded,
                                       IN OUT DWORD *pcbEncoded)
{
    BOOL                fResult;
    SigningCertificate  OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    fResult = OssInfoEncodeEx(SigningCertificate_PDU, &OssInfo, dwFlags,
                              pEncodePara, pvEncoded, pcbEncoded);
    //CommonReturn:
    return fResult;

#if 0
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
#endif // 0
}


STDAPI_(BOOL) EssSignCertificateDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                           PCRYPT_DECODE_PARA pDecodePara,
                                           void *pvStructInfo, LONG *plRemainExtra)
{
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    PSMIME_CONTENT_HINTS        pInfo = (PSMIME_CONTENT_HINTS) pvStructInfo;
    ContentHints *              pOssInfo = (ContentHints *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_CONTENT_HINTS);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_CONTENT_HINTS);
    }
    else {
        pbExtra = NULL;
    }

    OssX509GetEncodedObjId(&pOssInfo->contentType, dwFlags, &pInfo->pszOIDContent, 
                           &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssSignCertificateDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssSignCertificateDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(SigningCertificate_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssSignCertificateDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\ossutil.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       ossutil.cpp
//
//  Contents:   OSS ASN.1 compiler utility helper functions.
//
//  Functions:  OssUtilReverseBytes
//              OssUtilAllocAndReverseBytes
//              OssUtilGetOctetString
//              OssUtilSetHugeInteger
//              OssUtilFreeHugeInteger
//              OssUtilGetHugeInteger
//              OssUtilSetHugeUINT
//              OssUtilGetHugeUINT
//              OssUtilSetBitString
//              OssUtilGetBitString
//              OssUtilGetIA5String
//              OssUtilSetUnicodeConvertedToIA5String
//              OssUtilFreeUnicodeConvertedToIA5String
//              OssUtilGetIA5StringConvertedToUnicode
//              OssUtilGetBMPString
//              OssUtilSetAny
//              OssUtilGetAny
//              OssUtilEncodeInfoEx
//              OssUtilEncodeInfo
//              OssUtilDecodeAndAllocInfo
//              OssUtilFreeInfo
//              OssUtilAllocStructInfoEx
//              OssUtilDecodeAndAllocInfoEx
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#include "badstrfunctions.h"

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#if 0 // JLS
//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
OssUtilReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. OssUtilFree() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
OssUtilAllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            )
{
    PBYTE	pbOut;
    PBYTE	pbSrc;
    PBYTE	pbDst;
    DWORD	cb;

    if (NULL == (pbOut = (PBYTE)OssUtilAlloc(cbIn)))
        return NULL;

    for (pbSrc = pbIn, pbDst = pbOut + cbIn - 1, cb = cbIn; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
    return pbOut;
}
#endif // 0 // JLS

//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetOctetString(
        IN unsigned int OssLength,
        IN unsigned char *OssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = OssLength;
            pInfo->pbData = OssValue;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) OssLength;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, OssValue, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

#if 0 // JLS
//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  BUGBUG: BYTE reversal::
//   - this only needs to be done for little endian
//   - this needs to be fixed in the OSS compiler
//
//  For OssUtilSetInteger, OssUtilFreeInteger must be called to free
//  the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        )
{
    if (pInfo->cbData > 0) {
        if (NULL == (*ppOssValue = OssUtilAllocAndReverseBytes(
                pInfo->pbData, pInfo->cbData))) {
            *pOssLength = 0;
            return FALSE;
        }
    } else
        *ppOssValue = NULL;
    *pOssLength = pInfo->cbData;
    return TRUE;
}

void
WINAPI
OssUtilFreeHugeInteger(
        IN unsigned char *pOssValue
        )
{
    // Only for BYTE reversal
    OssUtilFree(pOssValue);
}

void
WINAPI
OssUtilGetHugeInteger(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Since bytes need to be reversed, always need to do a copy (dwFlags = 0)
    OssUtilGetOctetString(OssLength, pOssValue, 0,
        pInfo, ppbExtra, plRemainExtra);
    if (*plRemainExtra >= 0 && pInfo->cbData > 0)
        OssUtilReverseBytes(pInfo->pbData, pInfo->cbData);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing. Note, any extra leading
//  0x00's are removed by OSS before ASN.1 encoding.
//
//  Get removes a leading 0x00 if present, after reversing.
//
//  OssUtilFreeHugeUINT must be called to free the allocated OssValue.
//  OssUtilFreeHugeUINT has been #define'd to OssUtilFreeHugeInteger.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        )
{
    BOOL fResult;
    DWORD cb = pInfo->cbData;
    BYTE *pb;
    DWORD i;

    if (cb > 0) {
        if (NULL == (pb = (BYTE *) OssUtilAlloc(cb + 1)))
            goto ErrorReturn;
        *pb = 0x00;
        for (i = 0; i < cb; i++)
            pb[1 + i] = pInfo->pbData[cb - 1 - i];
        cb++;
    } else
        pb = NULL;
    fResult = TRUE;
CommonReturn:
    *pOssLength = cb;
    *ppOssValue = pb;
    return fResult;
ErrorReturn:
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;
}


void
WINAPI
OssUtilGetHugeUINT(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Check for and advance past a leading 0x00.
    if (OssLength > 1 && *pOssValue == 0) {
        pOssValue++;
        OssLength--;
    }
    OssUtilGetHugeInteger(
        OssLength,
        pOssValue,
        dwFlags,
        pInfo,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        )
{
    if (pInfo->cbData) {
        *ppOssValue = pInfo->pbData;
        assert(pInfo->cUnusedBits <= 7);
        *pOssBitLength = pInfo->cbData * 8 - pInfo->cUnusedBits;
    } else {
        *ppOssValue = NULL;
        *pOssBitLength = 0;
    }
}

static const BYTE rgbUnusedAndMask[8] =
    {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

void
WINAPI
OssUtilGetBitString(
        IN unsigned int OssBitLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG && 0 == (OssBitLength % 8)) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = OssBitLength / 8;
            pInfo->cUnusedBits = 0;
            pInfo->pbData = pOssValue;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
        DWORD cUnusedBits;
    
        lData = (LONG) OssBitLength / 8;
        cUnusedBits = OssBitLength % 8;
        if (cUnusedBits) {
            cUnusedBits = 8 - cUnusedBits;
            lData++;
        }
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                pInfo->cUnusedBits = cUnusedBits;
                memcpy(pbExtra, pOssValue, lData);
                if (cUnusedBits)
                    *(pbExtra + lData - 1) &= rgbUnusedAndMask[cUnusedBits];
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetIA5String(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) OssLength;
    lAlignExtra = INFO_LEN_ALIGN(lData + 1);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pOssValue, lData);
        *(pbExtra + lData) = 0;
        *ppsz = (LPSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT unsigned int *pOssLength,
        OUT char **ppOssValue
        )
{
    BOOL fResult;
    LPSTR psz = NULL;
    int cchUTF8;
    int cchWideChar;
    int i;

    cchWideChar = wcslen(pwsz);
    if (cchWideChar == 0) {
        *pOssLength = 0;
        *ppOssValue = 0;
        return TRUE;
    }
    // Check that the input string contains valid IA5 characters
    for (i = 0; i < cchWideChar; i++) {
        if (pwsz[i] > 0x7F) {
            SetLastError((DWORD) CRYPT_E_INVALID_IA5_STRING);
            *pOssLength = (unsigned int) i;
            goto InvalidIA5;
        }
    }

    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        NULL,       // lpUTF8Str
        0           // cchUTF8
        );

    if (cchUTF8 <= 0)
        goto ErrorReturn;
    if (NULL == (psz = (LPSTR) OssUtilAlloc(cchUTF8)))
        goto ErrorReturn;
    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        psz,
        cchUTF8
        );
    *ppOssValue = psz;
    *pOssLength = cchUTF8;
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *pOssLength = 0;
InvalidIA5:
    *ppOssValue = NULL;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

void
WINAPI
OssUtilFreeUnicodeConvertedToIA5String(
        IN char *pOssValue
        )
{
    OssUtilFree(pOssValue);
}

void
WINAPI
OssUtilGetIA5StringConvertedToUnicode(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    int cchWideChar;

    cchWideChar = UTF8ToWideChar(
        (LPSTR) pOssValue,
        OssLength,
        NULL,                   // lpWideCharStr
        0                       // cchWideChar
        );
    if (cchWideChar > 0)
        lData = cchWideChar * sizeof(WCHAR);
    else
        lData = 0;
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            UTF8ToWideChar(pOssValue, OssLength,
                (LPWSTR) pbExtra, cchWideChar);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetBMPString(
        IN unsigned int OssLength,
        IN unsigned short *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) OssLength * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pOssValue, lData);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}
#endif // 0 // JLS

//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    pOss->encoded = pInfo->pbData;
    pOss->length = pInfo->cbData;
}

void
WINAPI
OssUtilGetAny(
        IN OpenType *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = pOss->length;
            pInfo->pbData = (BYTE *) pOss->encoded;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) pOss->length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pOss->encoded, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cbEncoded;
    OssBuf OssEncoded;
    int OssStatus;
    unsigned char *value;

    if (NULL == pvEncoded || (dwFlags & CRYPT_ENCODE_ALLOC_FLAG))
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    OssEncoded.length = cbEncoded;
    if (cbEncoded == 0)
        value = NULL;
    else
        value = (unsigned char *) pvEncoded;
    OssEncoded.value = value;

    ossSetEncodingRules(Pog, OSS_DER);
    OssStatus = ossEncode(
        Pog,
        pdunum,
        pvOssInfo,
        &OssEncoded);
    cbEncoded = OssEncoded.length;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        PFN_CRYPT_ALLOC pfnAlloc;
        BYTE *pbEncoded;

        if (0 != OssStatus || 0 == cbEncoded) {
            ossFreeBuf(Pog, OssEncoded.value);
            *((void **) pvEncoded) = NULL;
            goto OssError;
        }

        pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
        if (NULL == (pbEncoded = (BYTE *) pfnAlloc(cbEncoded))) {
            ossFreeBuf(Pog, OssEncoded.value);
            *((void **) pvEncoded) = NULL;
            goto OutOfMemory;
        }
        memcpy(pbEncoded, OssEncoded.value, cbEncoded);
        *((BYTE **) pvEncoded) = pbEncoded;
        ossFreeBuf(Pog, OssEncoded.value);
        goto SuccessReturn;
    } else if (value == NULL && OssEncoded.value) {
        // Length only calculation with a throw away allocation
        ossFreeBuf(Pog, OssEncoded.value);
        if (pvEncoded && 0 == OssStatus) {
            // Upon entry *pcbEncoded == 0
            goto LengthError;
        }
    }

    if (0 != OssStatus) {
        // For MORE_BUF:: redo as a length only calculation
        if (OssStatus == MORE_BUF && pvEncoded &&
                OssUtilEncodeInfoEx(
                Pog,
                pdunum,
                pvOssInfo,
                0,                  // dwFlags
                NULL,               // pEncodePara
                NULL,               // pbEncoded
                &cbEncoded))
            goto LengthError;
        else {
            cbEncoded = 0;
            goto OssError;
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(LengthError, ERROR_MORE_DATA)
SET_ERROR_VAR(OssError, CRYPT_E_OSS_ERROR + OssStatus)
}

#if 0 // JLS
//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfoEx(
        Pog,
        pdunum,
        pvOssInfo,
        0,                  // dwFlags
        NULL,               // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}
#endif // 0 // JLS


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvOssInfo
        )
{
    BOOL fResult;
    OssBuf OssEncoded;
    int OssStatus;

    OssEncoded.length = cbEncoded;
    OssEncoded.value = (unsigned char *) pbEncoded;

    ossSetEncodingRules(Pog, OSS_BER);
    *ppvOssInfo = NULL;
    if (0 != (OssStatus = ossDecode(
                Pog,
                &pdunum,
                &OssEncoded,
                ppvOssInfo)))
        goto OssError;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppvOssInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(OssError, CRYPT_E_OSS_ERROR + OssStatus)
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
void
WINAPI
OssUtilFreeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo
        )
{
    if (pvOssInfo) {
        ossFreePDU(Pog, pdunum, pvOssInfo);
    }
}

//+-------------------------------------------------------------------------
//  Call the callback to convert the OSS structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilAllocStructInfoEx(
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!pfnDecodeExCallback(
            pvOssInfo,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeExCallback(
                pvOssInfo,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo = cbStructInfo - (DWORD) lRemainExtra;
    } else {
        cbStructInfo = cbStructInfo + (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Decode the OSS formatted info structure and call the callback
//  function to convert the OSS structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    void *pvOssInfo = NULL;

    if (!OssUtilDecodeAndAllocInfo(
            Pog,
            pdunum,
            pbEncoded,
            cbEncoded,
            &pvOssInfo
            )) goto OssDecodeError;

    fResult = OssUtilAllocStructInfoEx(
        pvOssInfo,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    OssUtilFreeInfo(Pog, pdunum, pvOssInfo);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OssDecodeError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\pkiasn1.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       pkiasn1.cpp
//
//  Contents:   PKI ASN.1 support functions.
//
//  Functions:  PkiAsn1ErrToHr
//              PkiAsn1Encode
//              PkiAsn1Decode
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//
//              PkiAsn1ReverseBytes
//              PkiAsn1AllocAndReverseBytes
//              PkiAsn1GetOctetString
//              PkiAsn1SetHugeInteger
//              PkiAsn1FreeHugeInteger
//              PkiAsn1GetHugeInteger
//              PkiAsn1SetHugeUINT
//              PkiAsn1GetHugeUINT
//              PkiAsn1SetBitString
//              PkiAsn1GetBitString
//              PkiAsn1GetIA5String
//              PkiAsn1SetUnicodeConvertedToIA5String
//              PkiAsn1FreeUnicodeConvertedToIA5String
//              PkiAsn1GetIA5StringConvertedToUnicode
//              PkiAsn1GetBMPString
//              PkiAsn1SetAny
//              PkiAsn1GetAny
//              PkiAsn1EncodeInfoEx
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//              PkiAsn1ToUTCTime
//              PkiAsn1FromUTCTime
//              PkiAsn1ToGeneralizedTime
//              PkiAsn1FromGeneralizedTime
//              PkiAsn1ToChoiceOfTime
//              PkiAsn1FromChoiceOfTime
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//
//  According to the <draft-ietf-pkix-ipki-part1-04.txt> :
//      For UTCTime. Where YY is greater than 50, the year shall
//      be interpreted as 19YY. Where YY is less than or equal to
//      50, the year shall be interpreted as 20YY.
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------
#ifdef SMIME_V3
#include <windows.h>
#include "msasn1.h"
#include "msber.h"
#include "utf8.h"
#include "crypttls.h"

#include "badstrfunctions.h"

#include "demand2.h"
#include "pkiasn1.h"
//#include "pkialloc.h"
//#include "global.hxx"
#include <dbgdef.h>
#define assert(a)

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define MSASN1_SUPPORTS_NOCOPY

#define wcslen my_wcslen
extern int my_wcslen(LPCWSTR pwsz)
{
    int i = 0;
    while (*pwsz++ != 0) i += 1;
    return i;
}



//
// UTCTime in X.509 certs are represented using a 2-digit year
// field (yuk! but true).
//
// According to IETF draft, YY years greater than this are
// to be interpreted as 19YY; YY years less than this are 20YY. Sigh.
//
#define MAGICYEAR               50

#define YEARFIRST               1951
#define YEARLAST                2050
#define YEARFIRSTGENERALIZED    2050

inline BOOL my_isdigit( char ch)
{
    return (ch >= '0') && (ch <= '9');
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    Asn1Err = ASN1_Encode(
        pEnc,
        pvAsn1Info,
        id,
        ASN1ENCODE_ALLOCATEBUFFER,
        NULL,                       // pbBuf
        0                           // cbBufSize
        );

    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded = pEnc->buf;
        *pcbEncoded = pEnc->len;
    } else {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded) {
        // Length only calculation

        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_ALLOCATEBUFFER,
            NULL,                       // pbBuf
            0                           // cbBufSize
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            if (pbEncoded)
                Asn1Err = ASN1_ERR_OVERFLOW;
            else
                Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
            PkiAsn1FreeEncoded(pEnc, pEnc->buf);
        }
    } else {
        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_SETBUFFER,
            pbEncoded,
            cbEncoded
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
        } else if (ASN1_ERR_OVERFLOW == Asn1Err) {
            // Re-do as length only calculation
            Asn1Err = PkiAsn1Encode2(
                pEnc,
                pvAsn1Info,
                id,
                NULL,   // pbEncoded
                &cbEncoded
                );
            if (ASN1_SUCCESS == Asn1Err)
                Asn1Err = ASN1_ERR_OVERFLOW;
        } else
            cbEncoded = 0;
    }

    *pcbEncoded = cbEncoded;
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        (BYTE *) pbEncoded,
        cbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err))
        Asn1Err = ASN1_SUCCESS;
    else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        *ppbEncoded,
        *pcbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded += pDec->len;
        *pcbEncoded -= pDec->len;
    } else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ASN1optionparam_s OptParam;

    OptParam.eOption = ASN1OPT_CHANGE_RULE;
    OptParam.eRule = eRule;

    return ASN1_SetEncoderOption(pEnc, &OptParam);
}

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ASN1error_e Asn1Err;
    ASN1encodingrule_e eRule;
    ASN1optionparam_s OptParam;
    OptParam.eOption = ASN1OPT_GET_RULE;

    Asn1Err = ASN1_GetEncoderOption(pEnc, &OptParam);
    if (ASN1_SUCCEEDED(Asn1Err))
        eRule = OptParam.eRule;
    else
        eRule = ASN1_BER_RULE_DER;

    return eRule;
}


//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. PkiAsn1Free() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
PkiAsn1AllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            )
{
    PBYTE	pbOut;
    PBYTE	pbSrc;
    PBYTE	pbDst;
    DWORD	cb;

    if (NULL == (pbOut = (PBYTE)PkiAsn1Alloc(cbIn)))
        return NULL;

    for (pbSrc = pbIn, pbDst = pbOut + cbIn - 1, cb = cbIn; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
    return pbOut;
}


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetOctetString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = Asn1Length;
            pInfo->pbData = pAsn1Value;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) Asn1Length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pAsn1Value, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  For PkiAsn1SetHugeInteger, PkiAsn1FreeHugeInteger must be called to free
//  the allocated Asn1Value.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    if (pInfo->cbData > 0) {
        if (NULL == (*ppAsn1Value = PkiAsn1AllocAndReverseBytes(
                pInfo->pbData, pInfo->cbData))) {
            *pAsn1Length = 0;
            return FALSE;
        }
    } else
        *ppAsn1Value = NULL;
    *pAsn1Length = pInfo->cbData;
    return TRUE;
}

void
WINAPI
PkiAsn1FreeHugeInteger(
        IN ASN1octet_t *pAsn1Value
        )
{
    // Only for BYTE reversal
    PkiAsn1Free(pAsn1Value);
}

void
WINAPI
PkiAsn1GetHugeInteger(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Since bytes need to be reversed, always need to do a copy (dwFlags = 0)
    PkiAsn1GetOctetString(Asn1Length, pAsn1Value, 0,
        pInfo, ppbExtra, plRemainExtra);
    if (*plRemainExtra >= 0 && pInfo->cbData > 0)
        PkiAsn1ReverseBytes(pInfo->pbData, pInfo->cbData);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing. Note, any extra leading
//  0x00's are removed by ASN1 before ASN.1 encoding.
//
//  Get removes a leading 0x00 if present, after reversing.
//
//  PkiAsn1FreeHugeUINT must be called to free the allocated Asn1Value.
//  PkiAsn1FreeHugeUINT has been #define'd to PkiAsn1FreeHugeInteger.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    BOOL fResult;
    DWORD cb = pInfo->cbData;
    BYTE *pb;
    DWORD i;

    if (cb > 0) {
        if (NULL == (pb = (BYTE *) PkiAsn1Alloc(cb + 1)))
            goto ErrorReturn;
        *pb = 0x00;
        for (i = 0; i < cb; i++)
            pb[1 + i] = pInfo->pbData[cb - 1 - i];
        cb++;
    } else
        pb = NULL;
    fResult = TRUE;
CommonReturn:
    *pAsn1Length = cb;
    *ppAsn1Value = pb;
    return fResult;
ErrorReturn:
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;
}


void
WINAPI
PkiAsn1GetHugeUINT(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Check for and advance past a leading 0x00.
    if (Asn1Length > 1 && *pAsn1Value == 0) {
        pAsn1Value++;
        Asn1Length--;
    }
    PkiAsn1GetHugeInteger(
        Asn1Length,
        pAsn1Value,
        dwFlags,
        pInfo,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    if (pInfo->cbData) {
        *ppAsn1Value = pInfo->pbData;
        assert(pInfo->cUnusedBits <= 7);
        *pAsn1BitLength = pInfo->cbData * 8 - pInfo->cUnusedBits;
    } else {
        *ppAsn1Value = NULL;
        *pAsn1BitLength = 0;
    }
}

static const BYTE rgbUnusedAndMask[8] =
    {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

void
WINAPI
PkiAsn1GetBitString(
        IN ASN1uint32_t Asn1BitLength,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG && 0 == (Asn1BitLength % 8)) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = Asn1BitLength / 8;
            pInfo->cUnusedBits = 0;
            pInfo->pbData = pAsn1Value;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
        DWORD cUnusedBits;
    
        lData = (LONG) Asn1BitLength / 8;
        cUnusedBits = Asn1BitLength % 8;
        if (cUnusedBits) {
            cUnusedBits = 8 - cUnusedBits;
            lData++;
        }
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                pInfo->cUnusedBits = cUnusedBits;
                memcpy(pbExtra, pAsn1Value, lData);
                if (cUnusedBits)
                    *(pbExtra + lData - 1) &= rgbUnusedAndMask[cUnusedBits];
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetIA5String(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) Asn1Length;
    lAlignExtra = INFO_LEN_ALIGN(lData + 1);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pAsn1Value, lData);
        *(pbExtra + lData) = 0;
        *ppsz = (LPSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1char_t **ppAsn1Value
        )
{
    BOOL fResult;
    LPSTR psz = NULL;
    int cchUTF8;
    int cchWideChar;
    int i;

    cchWideChar = wcslen(pwsz);
    if (cchWideChar == 0) {
        *pAsn1Length = 0;
        *ppAsn1Value = 0;
        return TRUE;
    }
    // Check that the input string contains valid IA5 characters
    for (i = 0; i < cchWideChar; i++) {
        if (pwsz[i] > 0x7F) {
            SetLastError((DWORD) CRYPT_E_INVALID_IA5_STRING);
            *pAsn1Length = (unsigned int) i;
            goto InvalidIA5;
        }
    }

    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        NULL,       // lpUTF8Str
        0           // cchUTF8
        );

    if (cchUTF8 <= 0)
        goto ErrorReturn;
    if (NULL == (psz = (LPSTR) PkiAsn1Alloc(cchUTF8)))
        goto ErrorReturn;
    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        psz,
        cchUTF8
        );
    *ppAsn1Value = psz;
    *pAsn1Length = cchUTF8;
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *pAsn1Length = 0;
InvalidIA5:
    *ppAsn1Value = NULL;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

void
WINAPI
PkiAsn1FreeUnicodeConvertedToIA5String(
        IN ASN1char_t *pAsn1Value
        )
{
    PkiAsn1Free(pAsn1Value);
}

void
WINAPI
PkiAsn1GetIA5StringConvertedToUnicode(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    int cchWideChar;

    cchWideChar = UTF8ToWideChar(
        (LPSTR) pAsn1Value,
        Asn1Length,
        NULL,                   // lpWideCharStr
        0                       // cchWideChar
        );
    if (cchWideChar > 0)
        lData = cchWideChar * sizeof(WCHAR);
    else
        lData = 0;
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            UTF8ToWideChar(pAsn1Value, Asn1Length,
                (LPWSTR) pbExtra, cchWideChar);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetBMPString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char16_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) Asn1Length * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pAsn1Value, lData);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT ASN1open_t *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    pAsn1->encoded = pInfo->pbData;
    pAsn1->length = pInfo->cbData;
}

void
WINAPI
PkiAsn1GetAny(
        IN ASN1open_t *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = pAsn1->length;
            pInfo->pbData = (BYTE *) pAsn1->encoded;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) pAsn1->length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pAsn1->encoded, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}


//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        BYTE *pbEncoded;
        BYTE *pbAllocEncoded;
        PFN_CRYPT_ALLOC pfnAlloc;

        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode(
            pEnc,
            pvAsn1Info,
            id,
            &pbEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            *((void **) pvEncoded) = NULL;
            goto Asn1EncodeError;
        }

        pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
        if (NULL == (pbAllocEncoded = (BYTE *) pfnAlloc(cbEncoded))) {
            PkiAsn1FreeEncoded(pEnc, pbEncoded);
            *((void **) pvEncoded) = NULL;
            goto OutOfMemory;
        }
        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        *((BYTE **) pvEncoded) = pbAllocEncoded;
        PkiAsn1FreeEncoded(pEnc, pbEncoded);
    } else {
        cbEncoded = *pcbEncoded;
        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode2(
            pEnc,
            pvAsn1Info,
            id,
            (BYTE *) pvEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            if (ASN1_ERR_OVERFLOW == Asn1Err)
                goto LengthError;
            else
                goto Asn1EncodeError;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(LengthError, ERROR_MORE_DATA)
SET_ERROR_VAR(Asn1EncodeError, PkiAsn1ErrToHr(Asn1Err))
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        pEnc,
        id,
        pvAsn1Info,
        0,                  // dwFlags
        NULL,               // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    if (ASN1_SUCCESS != (Asn1Err = PkiAsn1Decode(
            pDec,
            ppvAsn1Info,
            id,
            pbEncoded,
            cbEncoded
            )))
        goto Asn1DecodeError;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppvAsn1Info = NULL;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
}


//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!pfnDecodeExCallback(
            pvAsn1Info,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeExCallback(
                pvAsn1Info,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo = cbStructInfo - (DWORD) lRemainExtra;
    } else {
        cbStructInfo = cbStructInfo + (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    void *pvAsn1Info = NULL;

    if (!PkiAsn1DecodeAndAllocInfo(
            pDec,
            id,
            pbEncoded,
            cbEncoded,
            &pvAsn1Info
            )) goto Asn1DecodeError;

    fResult = PkiAsn1AllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    PkiAsn1FreeInfo(pDec, id, pvAsn1Info);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(Asn1DecodeError)
}

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    char    ch;

    if (psz) {
        ASN1uint16_t cMax = *pCount;
        ASN1uint32_t *pul = rgulValue;
        while ((ch = *psz) != '\0' && c++ < cMax) {
            *pul = 0;
            while (my_isdigit(ch = *psz++)) {
                *pul = (*pul * 10) + (ch - '0');
            }
            pul++;
            if (ch != '.')
                break;
        }
        if (ch != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR * ppszObjId,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fResult = TRUE;
    LONG lRemain;
    LPSTR pszObjId = NULL;

    if (ppbExtra != NULL) {
        pszObjId = (LPSTR) *ppbExtra;
    }

    lRemain = (LONG) *plRemainExtra;
    if (Count == 0) {
        if (--lRemain > 0)
            pszObjId++;
    } else {
        char rgch[36];
        LONG lData;
        ASN1uint32_t *pul = rgulValue;
        for (; Count > 0; Count--, pul++) {
            _ltoa(*pul, rgch, 10);
            lData = strlen(rgch);
            lRemain -= lData + 1;
            if (lRemain >= 0) {
                if (lData > 0) {
                    memcpy(pszObjId, rgch, lData);
                    pszObjId += lData;
                }
                *pszObjId++ = '.';
            }
        }
    }

    if (lRemain >= 0) {
        *(pszObjId -1) = '\0';
        *ppszObjId = (LPSTR) *ppbExtra; 
        *ppbExtra = (LPBYTE) pszObjId;
        *plRemainExtra = lRemain;
    } else {
        *plRemainExtra = lRemain;
        if (pszObjId) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Adjust FILETIME for timezone.
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
static BOOL AdjustFileTime(
    IN OUT LPFILETIME pFileTime,
    IN ASN1int16_t mindiff,
    IN ASN1bool_t utc
    )
{
    if (utc || mindiff == 0)
        return TRUE;

    BOOL fResult;
    SYSTEMTIME stmDiff;
    FILETIME ftmDiff;
    short absmindiff;

    memset(&stmDiff, 0, sizeof(stmDiff));
    // Note: FILETIME is 100 nanoseconds interval since January 1, 1601
    stmDiff.wYear   = 1601;
    stmDiff.wMonth  = 1;
    stmDiff.wDay    = 1;

    absmindiff = mindiff > 0 ? mindiff : -mindiff;
    stmDiff.wHour = absmindiff / 60;
    stmDiff.wMinute = absmindiff % 60;
    if (stmDiff.wHour >= 24) {
        stmDiff.wDay += stmDiff.wHour / 24;
        stmDiff.wHour %= 24;
    }

    // Note, FILETIME is only 32 bit aligned. __int64 is 64 bit aligned.
    if ((fResult = SystemTimeToFileTime(&stmDiff, &ftmDiff))) {
        unsigned __int64 uTime;
        unsigned __int64 uDiff;

        memcpy(&uTime, pFileTime, sizeof(uTime));
        memcpy(&uDiff, &ftmDiff, sizeof(uDiff));

        if (mindiff > 0)
            uTime += uDiff;
        else
            uTime -= uDiff;

        memcpy(pFileTime, &uTime, sizeof(*pFileTime));
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToUTCTime(
    IN LPFILETIME pFileTime,
    OUT ASN1utctime_t *pAsn1Time
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pAsn1Time, 0, sizeof(*pAsn1Time));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear > YEARLAST)
        goto YearRangeError;

    pAsn1Time->year   = (ASN1uint8_t) (t.wYear % 100);
    pAsn1Time->month  = (ASN1uint8_t) t.wMonth;
    pAsn1Time->day    = (ASN1uint8_t) t.wDay;
    pAsn1Time->hour   = (ASN1uint8_t) t.wHour;
    pAsn1Time->minute = (ASN1uint8_t) t.wMinute;
    pAsn1Time->second = (ASN1uint8_t) t.wSecond;
    pAsn1Time->universal = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
TRACE_ERROR(YearRangeError)
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromUTCTime(
    IN ASN1utctime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pAsn1Time->year > MAGICYEAR ?
                    (1900 + pAsn1Time->year) : (2000 + pAsn1Time->year);
    t.wMonth  = pAsn1Time->month;
    t.wDay    = pAsn1Time->day;
    t.wHour   = pAsn1Time->hour;
    t.wMinute = pAsn1Time->minute;
    t.wSecond = pAsn1Time->second;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pAsn1Time->diff,
        pAsn1Time->universal
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT ASN1generalizedtime_t *pAsn1Time
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pAsn1Time, 0, sizeof(*pAsn1Time));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    pAsn1Time->year   = t.wYear;
    pAsn1Time->month  = (ASN1uint8_t) t.wMonth;
    pAsn1Time->day    = (ASN1uint8_t) t.wDay;
    pAsn1Time->hour   = (ASN1uint8_t) t.wHour;
    pAsn1Time->minute = (ASN1uint8_t) t.wMinute;
    pAsn1Time->second = (ASN1uint8_t) t.wSecond;
    pAsn1Time->millisecond = 0; // t.wMilliseconds;
    pAsn1Time->universal    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromGeneralizedTime(
    IN ASN1generalizedtime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pAsn1Time->year;
    t.wMonth  = pAsn1Time->month;
    t.wDay    = pAsn1Time->day;
    t.wHour   = pAsn1Time->hour;
    t.wMinute = pAsn1Time->minute;
    t.wSecond = pAsn1Time->second;
    t.wMilliseconds = pAsn1Time->millisecond;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pAsn1Time->diff,
        pAsn1Time->universal
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}


//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT ASN1generalizedtime_t *pGeneralTime,
    OUT ASN1utctime_t *pUtcTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear >= YEARFIRSTGENERALIZED) {
        *pwChoice = PKI_ASN1_GENERALIZED_TIME_CHOICE;
        memset(pGeneralTime, 0, sizeof(*pGeneralTime));
        pGeneralTime->year   = t.wYear;
        pGeneralTime->month  = (ASN1uint8_t) t.wMonth;
        pGeneralTime->day    = (ASN1uint8_t) t.wDay;
        pGeneralTime->hour   = (ASN1uint8_t) t.wHour;
        pGeneralTime->minute = (ASN1uint8_t) t.wMinute;
        pGeneralTime->second = (ASN1uint8_t) t.wSecond;
        pGeneralTime->universal    = TRUE;
    } else {
        *pwChoice = PKI_ASN1_UTC_TIME_CHOICE;
        memset(pUtcTime, 0, sizeof(*pUtcTime));
        pUtcTime->year = (ASN1uint8_t) (t.wYear % 100);
        pUtcTime->month  = (ASN1uint8_t) t.wMonth;
        pUtcTime->day    = (ASN1uint8_t) t.wDay;
        pUtcTime->hour   = (ASN1uint8_t) t.wHour;
        pUtcTime->minute = (ASN1uint8_t) t.wMinute;
        pUtcTime->second = (ASN1uint8_t) t.wSecond;
        pUtcTime->universal    = TRUE;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *pwChoice = 0;
    memset(pGeneralTime, 0, sizeof(*pGeneralTime));
    memset(pUtcTime, 0, sizeof(*pUtcTime));
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}


//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN ASN1generalizedtime_t *pGeneralTime,
    IN ASN1utctime_t *pUtcTime,
    OUT LPFILETIME pFileTime
    )
{
    if (PKI_ASN1_UTC_TIME_CHOICE == wChoice) {
        return PkiAsn1FromUTCTime(pUtcTime, pFileTime);
    } else
        return PkiAsn1FromGeneralizedTime(pGeneralTime, pFileTime);
}
#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\pkialloc.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       pkialloc.cpp
//
//  Contents:   PKI Allocation Functions
//
//  Functions:  PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------
#ifdef SMIME_V3

#include <windows.h>
#include "pkialloc.h"
#include <dbgdef.h>

#include "badstrfunctions.h"

#ifndef offsetof
#define offsetof(a, b) ((size_t) &(((a *) 0)->b))
#endif

// This macro for _WIN64, but works for Win32 too
#define LOWDWORD(l) 		((DWORD)((DWORD_PTR) (l) & 0xffffffff))

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN UINT cbBytes
    )
{
    LPVOID pv;
#if DBG
    if (NULL == (pv = malloc(cbBytes)))
#else
    if (NULL == (pv = (LPVOID) LocalAlloc(LPTR, cbBytes)))
#endif
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}


// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;

#if DBG
    pv = malloc(cbBytes);
#else
    pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes);
#endif
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}


// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN UINT cbBytes
    )
{
    LPVOID pv;
#if DBG
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    else
        memset(pv, 0, cbBytes);
#else
    // LPTR (OR includes ZEROINIT)
    pv = (LPVOID) LocalAlloc(LPTR, cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
#endif
    return pv;
}

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    )
{
    LPVOID pv;
#if DBG
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
#else
    if (NULL == (pv = pvOrg ?
            (LPVOID) LocalReAlloc((HLOCAL)pvOrg, cbBytes, LMEM_MOVEABLE) :
            (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes)))
#endif
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    )
{
    if (pv)
#if DBG
        free(pv);
#else
        LocalFree((HLOCAL)pv);
#endif
}

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN size_t cbSize
    )
{
    LPVOID pv;
    if (NULL == (pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbSize)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree((HLOCAL) pv);
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_ENCODE_PARA PkiEncodePara = {
    LOWDWORD(offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(PkiEncodePara.pfnFree)),
    (PFN_CRYPT_ALLOC) PkiNonzeroAlloc,
    PkiFree
};


//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
          		  pEncodePara->cbSize >= LOWDWORD(offsetof(CRYPT_ENCODE_PARA, pfnAlloc) +
                sizeof(pEncodePara->pfnAlloc)) &&
            pEncodePara->pfnAlloc)
        return pEncodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= LOWDWORD(offsetof(CRYPT_ENCODE_PARA, pfnFree) +
                sizeof(pEncodePara->pfnFree)) &&
            pEncodePara->pfnFree)
        return pEncodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_DECODE_PARA PkiDecodePara = {
   LOWDWORD(offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(PkiDecodePara.pfnFree)),
    (PFN_CRYPT_ALLOC) PkiNonzeroAlloc,
    PkiFree
};

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= LOWDWORD(offsetof(CRYPT_DECODE_PARA, pfnAlloc) +
                sizeof(pDecodePara->pfnAlloc)) &&
            pDecodePara->pfnAlloc)
        return pDecodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= LOWDWORD(offsetof(CRYPT_DECODE_PARA, pfnFree) +
                sizeof(pDecodePara->pfnFree)) &&
            pDecodePara->pfnFree)
        return pDecodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}
#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#ifdef __cplusplus
    extern "C" 
    {
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#define DBG_SS_CRYPT32                      0x00000001

#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000

#define DBG_SS_APP                          0x10000000

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                NULL, NULL                      \
                            }

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG

    extern int WINAPIV DbgPrintf( DWORD dwSubSysId, LPCSTR lpFmt, ...);

#   define DBG_TRACE_EX(argFmt) DbgPrintf argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_CRYPT32,argFmt))

#   define DBG_PRINTF(args)     DbgPrintf args

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#   define DBG_PRINTF(args)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_CRYPT32,name)
#define SET_ERROR(name,err)             SET_ERROR_EX(DBG_SS_CRYPT32,name,err)
#define SET_ERROR_VAR(name,err)         SET_ERROR_VAR_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT(name,err)           SET_HRESULT_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT_VAR(name,err)       SET_HRESULT_VAR_EX(DBG_SS_CRYPT32,name,err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_CRYPT32,name)


#ifdef __cplusplus
    }       // balance of extern "C"
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\utf8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       utf8.cpp
//
//  Contents:   WideChar to/from UTF8 APIs
//
//  Functions:  WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------
#ifdef SMIME_V3
#include <windows.h>
#include <dbgdef.h>
#include "utf8.h"

#include "badstrfunctions.h"

#define wcslen my_wcslen
int my_wcslen(LPCWSTR pwsz);

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    )
{
    int cchRemainUTF8;

    if (cchUTF8 < 0)
        goto InvalidParameter;
    cchRemainUTF8 = cchUTF8;

    if (cchWideChar < 0)
        cchWideChar = wcslen(lpWideCharStr) + 1;

    while (cchWideChar--) {
        WCHAR wch = *lpWideCharStr++;
        if (wch <= 0x7F) {
            // 7 bits
            cchRemainUTF8 -= 1;
            if (cchRemainUTF8 >= 0)
                *lpUTF8Str++ = (char) wch;
        } else if (wch <= 0x7FF) {
            // 11 bits
            cchRemainUTF8 -= 2;
            if (cchRemainUTF8 >= 0) {
                *lpUTF8Str++ = (char) (0xC0 | ((wch >> 6) & 0x1F));
                *lpUTF8Str++ = (char) (0x80 | (wch & 0x3F));
            }
        } else {
            // 16 bits
            cchRemainUTF8 -= 3;
            if (cchRemainUTF8 >= 0) {
                *lpUTF8Str++ = (char) (0xE0 | ((wch >> 12) & 0x0F));
                *lpUTF8Str++ = (char) (0x80 | ((wch >> 6) & 0x3F));
                *lpUTF8Str++ = (char) (0x80 | (wch & 0x3F));
            }
        }
    }

    if (cchRemainUTF8 >= 0)
        cchUTF8 = cchUTF8 - cchRemainUTF8;
    else if (cchUTF8 == 0)
        cchUTF8 = -cchRemainUTF8;
    else {
        cchUTF8 = 0;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }
    return cchUTF8;

InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return 0;
}

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    )
{
    int cchRemainWideChar;

    if (cchWideChar < 0)
        goto InvalidParameter;
    cchRemainWideChar = cchWideChar;

    if (cchUTF8 < 0)
        cchUTF8 = strlen(lpUTF8Str) + 1;

    while (cchUTF8--) {
        char ch = *lpUTF8Str++;
        WCHAR wch;
        if (0 == (ch & 0x80))
            // 7 bits, 1 byte
            wch = (WCHAR) ch;
        else if (0xC0 == (ch & 0xE0)) {
            // 11 bits, 2 bytes
            char ch2;

            if (--cchUTF8 < 0)
                goto InvalidParameter;
            ch2 = *lpUTF8Str++;
            if (0x80 != (ch2 & 0xC0))
                goto InvalidParameter;
            wch = (((WCHAR) ch & 0x1F) << 6) | ((WCHAR) ch2 & 0x3F);
        } else if (0xE0 == (ch & 0xF0)) {
            // 16 bits, 3 bytes
            char ch2;
            char ch3;
            cchUTF8 -= 2;
            if (cchUTF8 < 0)
                goto InvalidParameter;
            ch2 = *lpUTF8Str++;
            ch3 = *lpUTF8Str++;
            if (0x80 != (ch2 & 0xC0) || 0x80 != (ch3 & 0xC0))
                goto InvalidParameter;
            wch = (((WCHAR) ch & 0x0F) << 12) | (((WCHAR) ch2 & 0x3F) << 6) |
                ((WCHAR) ch3 & 0x3F);
        } else
            goto InvalidParameter;

        if (--cchRemainWideChar >= 0)
            *lpWideCharStr++ = wch;
    }

    if (cchRemainWideChar >= 0)
        cchWideChar = cchWideChar - cchRemainWideChar;
    else if (cchWideChar == 0)
        cchWideChar = -cchRemainWideChar;
    else {
        cchWideChar = 0;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }
    return cchWideChar;

InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return 0;
}
#endif //SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\crypttls.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crypttls.h
//
//  Contents:   Crypt Thread Local Storage (TLS) and OssGlobal "world"
//              installation and allocation functions
//
//  APIs:
//              I_CryptAllocTls
//              I_CryptFreeTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//              I_CryptInstallOssGlobal
//              I_CryptUninstallOssGlobal
//              I_CryptGetOssGlobal
//
//              I_CryptInstallAsn1Module
//              I_CryptUninstallAsn1Module
//              I_CryptGetAsn1Encoder
//              I_CryptGetAsn1Decoder
//
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTTLS_H__
#define __CRYPTTLS_H__

#include "msasn1.h"
#include "ossglobl.h"
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


// Handle to an allocated Crypt TLS entry
typedef DWORD HCRYPTTLS;

// Handle to an installed OssGlobal table
typedef DWORD HCRYPTOSSGLOBAL;

// Pointer to OssGlobal. Returned by I_CryptGetOssGlobal()
typedef  OssGlobal  *POssGlobal;

// Handle to an installed Asn1 module
typedef DWORD HCRYPTASN1MODULE;

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls();

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to free a thread local storage entry.
//  Optionally, calls the callback for each thread having a non-NULL pvTls.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptFreeTls(
    IN HCRYPTTLS hCryptTls,
    IN OPTIONAL PFN_CRYPT_FREE pfnFree
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    );

//+-------------------------------------------------------------------------
//  Called at DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//
//  Note, at DLL_PROCESS_DETACH, I_CryptFreeTls should be called instead.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Install an OssGlobal entry and return a handle for future access.
//
//  Each thread has its own copy of OssGlobal. Allocation and
//  initialization are deferred until first referenced by the thread.
//
//  The parameter, pvCtlTbl is passed to ossinit() to initialize the OssGlobal.
//
//  I_CryptGetOssGlobal must be called with the handled returned by
//  I_CryptInstallOssGlobal to get the thread specific OssGlobal.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTOSSGLOBAL
WINAPI
I_CryptInstallOssGlobal(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an OssGlobal entry. Iterate
//  through the threads and frees their allocated copy of OssGlobal.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the OssGlobal specified by the
//  hOssGlobal returned by CryptInstallOssGlobal. If the
//  OssGlobal doesn't exist, then, its allocated and initialized using
//  the pvCtlTbl associated with hOssGlobal.
//--------------------------------------------------------------------------
POssGlobal
WINAPI
I_CryptGetOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

//+-------------------------------------------------------------------------
//  Install an Asn1 module entry and return a handle for future access.
//
//  Each thread has its own copy of the decoder and encoder associated
//  with the Asn1 module. Creation is deferred until first referenced by
//  the thread.
//
//  I_CryptGetAsn1Encoder or I_CryptGetAsn1Decoder must be called with the
//  handle returned by I_CryptInstallAsn1Module to get the thread specific
//  Asn1 encoder or decoder.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    return (HCRYPTASN1MODULE) I_CryptInstallOssGlobal(
        pvCtlTbl, dwFlags, pvReserved);
}
#else

HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an hAsn1Module entry. Iterates
//  through the threads and frees their created Asn1 encoders and decoders.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return I_CryptUninstallOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 encoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  encoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return (ASN1encoding_t) I_CryptGetOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 decoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  decoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return (ASN1decoding_t) I_CryptGetOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\msasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_ASN1_H__
#define __MS_ASN1_H__

#ifdef __cplusplus
extern "C" {
#endif

/* ------ Basic integer types ------ */

typedef unsigned char   ASN1uint8_t;
typedef signed char     ASN1int8_t;

typedef unsigned short  ASN1uint16_t;
typedef signed short    ASN1int16_t;

typedef unsigned long   ASN1uint32_t;
typedef signed long     ASN1int32_t;


/* ------ Function modifiers ------ */

#ifdef ASN1LIB
#define ASN1_PUBLIC     __declspec(dllexport)
#elif defined(ASN1C)
#define ASN1_PUBLIC     
#else
#define ASN1_PUBLIC     __declspec(dllimport)
#endif
#define ASN1API         __stdcall
#define ASN1CALL        __stdcall


/* ------ Basic ASN.1 types ------ */

typedef ASN1uint8_t ASN1octet_t;

typedef ASN1uint8_t ASN1bool_t;

typedef struct tagASN1intx_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1intx_t;

typedef struct tagASN1octetstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1octetstring_t;

typedef struct tagASN1octetstring2_t
{
    ASN1uint32_t length;
    ASN1octet_t value[1];
}
    ASN1octetstring2_t;

typedef struct ASN1iterator_s
{
    struct ASN1iterator_s *next;
    void *value;
}
    ASN1iterator_t;

typedef struct tagASN1bitstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1bitstring_t;

typedef char ASN1char_t;

typedef struct tagASN1charstring_t
{
    ASN1uint32_t length;
    ASN1char_t *value;
}
    ASN1charstring_t;

typedef ASN1uint16_t ASN1char16_t;

typedef struct tagASN1char16string_t
{
    ASN1uint32_t length;
    ASN1char16_t *value;
}
    ASN1char16string_t;

typedef ASN1uint32_t ASN1char32_t;

typedef struct tagASN1char32string_t
{
    ASN1uint32_t length;
    ASN1char32_t *value;
}
    ASN1char32string_t;

typedef ASN1char_t *ASN1ztcharstring_t;
typedef ASN1char16_t *ASN1ztchar16string_t;
typedef ASN1char32_t *ASN1ztchar32string_t;

typedef struct tagASN1wstring_t
{
    ASN1uint32_t length;
    WCHAR *value;
}
    ASN1wstring_t;

typedef struct ASN1objectidentifier_s
{
    struct ASN1objectidentifier_s *next;
    ASN1uint32_t value;
}
    *ASN1objectidentifier_t;

typedef struct tagASN1objectidentifier2_t
{
    ASN1uint16_t count;
    ASN1uint32_t value[16];
}
    ASN1objectidentifier2_t;

typedef struct tagASN1encodedOID_t
{
    ASN1uint16_t length;
    ASN1octet_t  *value;
}
    ASN1encodedOID_t;

typedef struct tagASN1stringtableentry_t
{
    ASN1char32_t lower;
    ASN1char32_t upper;
    ASN1uint32_t value;
}
    ASN1stringtableentry_t;

typedef struct tagASN1stringtable_t
{
    ASN1uint32_t length;
    ASN1stringtableentry_t *values;
}
    ASN1stringtable_t;

typedef ASN1ztcharstring_t ASN1objectdescriptor_t;

typedef struct tagASN1generalizedtime_t
{
    ASN1uint16_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1uint16_t millisecond;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1generalizedtime_t;

typedef struct tagASN1utctime_t
{
    ASN1uint8_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1utctime_t;

typedef struct tagASN1open_t
{
    // encoded
    ASN1uint32_t    length;
    union
    {
        void           *encoded;
        void           *value;
    };
}
    ASN1open_t;

typedef enum tagASN1blocktype_e
{
    ASN1_DER_SET_OF_BLOCK,
}
    ASN1blocktype_e;

typedef ASN1int32_t     ASN1enum_t;     // enumerated type

typedef ASN1uint16_t    ASN1choice_t;   // choice

typedef ASN1uint32_t    ASN1magic_t;

/* ------ Current version of this ASN.1 software ------ */

#define ASN1_MAKE_VERSION(major,minor)  (((major) << 16) | (minor))
#define ASN1_THIS_VERSION               ASN1_MAKE_VERSION(1,0)

enum
{
    ASN1_CHOICE_BASE      = 1,
    ASN1_CHOICE_INVALID   = -1,     // invalid choice
    ASN1_CHOICE_EXTENSION = 0,      // extension choice
};



/*
   Error codes for decoding functions:
   - err == 0:    data has been successfully decoded
   - err <  0:    fatal error has occured, no data has been generated
                  err contains the error number
   - err >  0:    non-fatal event has occured, data has been generated
                  err is a bit set of occured events
 */

typedef enum tagASN1error_e
{
    ASN1_SUCCESS        = 0,            /* success */

    // Teles specific error codes
    ASN1_ERR_INTERNAL   = (-1001),      /* internal error */
    ASN1_ERR_EOD        = (-1002),      /* unexpected end of data */
    ASN1_ERR_CORRUPT    = (-1003),      /* corrupted data */
    ASN1_ERR_LARGE      = (-1004),      /* value too large */
    ASN1_ERR_CONSTRAINT = (-1005),      /* constraint violated */
    ASN1_ERR_MEMORY     = (-1006),      /* out of memory */
    ASN1_ERR_OVERFLOW   = (-1007),      /* buffer overflow */
    ASN1_ERR_BADPDU     = (-1008),      /* function not supported for this pdu*/
    ASN1_ERR_BADARGS    = (-1009),      /* bad arguments to function call */
    ASN1_ERR_BADREAL    = (-1010),      /* bad real value */
    ASN1_ERR_BADTAG     = (-1011),      /* bad tag value met */
    ASN1_ERR_CHOICE     = (-1012),      /* bad choice value */
    ASN1_ERR_RULE       = (-1013),      /* bad encoding rule */
    ASN1_ERR_UTF8       = (-1014),      /* bad unicode (utf8) */

    // New error codes
    ASN1_ERR_PDU_TYPE   = (-1051),      /* bad pdu type */
    ASN1_ERR_NYI        = (-1052),      /* not yet implemented */

    // Teles specific warning codes
    ASN1_WRN_EXTENDED   = 1001,         /* skipped unknown extension(s) */
    ASN1_WRN_NOEOD      = 1002,         /* end of data expected */
}
    ASN1error_e;

#define ASN1_SUCCEEDED(ret)     (((int) (ret)) >= 0)
#define ASN1_FAILED(ret)        (((int) (ret)) < 0)


/* ------ Encoding rules ------ */

typedef enum
{
    ASN1_PER_RULE_ALIGNED       = 0x0001,
    ASN1_PER_RULE_UNALIGNED     = 0x0002, // not supported
    ASN1_PER_RULE               = ASN1_PER_RULE_ALIGNED | ASN1_PER_RULE_UNALIGNED,

    ASN1_BER_RULE_BER           = 0x0100,
    ASN1_BER_RULE_CER           = 0x0200,
    ASN1_BER_RULE_DER           = 0x0400,
    ASN1_BER_RULE               = ASN1_BER_RULE_BER | ASN1_BER_RULE_CER | ASN1_BER_RULE_DER,
}
    ASN1encodingrule_e;

/* ------ public structures ------ */

typedef struct ASN1encoding_s   *ASN1encoding_t;
typedef struct ASN1decoding_s   *ASN1decoding_t;

typedef ASN1int32_t (ASN1CALL *ASN1PerEncFun_t)(ASN1encoding_t enc, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1PerDecFun_t)(ASN1decoding_t enc, void *data);
typedef struct tagASN1PerFunArr_t
{
    const ASN1PerEncFun_t *apfnEncoder;
    const ASN1PerDecFun_t *apfnDecoder;
}
    ASN1PerFunArr_t;

typedef ASN1int32_t (ASN1CALL *ASN1BerEncFun_t)(ASN1encoding_t enc, ASN1uint32_t tag, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1BerDecFun_t)(ASN1decoding_t enc, ASN1uint32_t tag, void *data);
typedef struct tagASN1BerFunArr_t
{
    const ASN1BerEncFun_t *apfnEncoder;
    const ASN1BerDecFun_t *apfnDecoder;
}
    ASN1BerFunArr_t;

typedef void (ASN1CALL *ASN1GenericFun_t)(void);
typedef void (ASN1CALL *ASN1FreeFun_t)(void *data);

typedef struct tagASN1module_t
{
    ASN1magic_t             nModuleName;
    ASN1encodingrule_e      eRule;
    ASN1uint32_t            dwFlags;
    ASN1uint32_t            cPDUs;

    const ASN1FreeFun_t    *apfnFreeMemory;
    const ASN1uint32_t     *acbStructSize;
    union
    {
        ASN1PerFunArr_t     PER;
        ASN1BerFunArr_t     BER;
    };
}
    *ASN1module_t;


struct ASN1encoding_s
{
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this encoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to encode into */
    ASN1uint32_t        size;   /* current size of buffer */
    ASN1uint32_t        len;    /* len of encoded data in buffer */
    ASN1error_e         err;    /* error code for last encoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1uint32_t        cbExtraHeader;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};

struct ASN1decoding_s
{
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this decoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to decode from */
    ASN1uint32_t        size;   /* size of buffer */
    ASN1uint32_t        len;    /* len of decoded data in buffer */
    ASN1error_e         err;    /* error code for last decoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};


/* --- flags for functions --- */

#define ASN1DECFREE_NON_PDU_ID    ((ASN1uint32_t) -1)

enum
{
    ASN1FLAGS_NONE              = 0x00000000L, /* no flags */
    ASN1FLAGS_NOASSERT          = 0x00001000L, /* no asertion */
};

enum
{
    ASN1ENCODE_APPEND           = 0x00000001L, /* append to current buffer*/
    ASN1ENCODE_REUSEBUFFER      = 0x00000004L, /* empty destination buffer */
    ASN1ENCODE_SETBUFFER        = 0x00000008L, /* use a user-given destination buffer */
    ASN1ENCODE_ALLOCATEBUFFER   = 0x00000010L, /* do not free/reuse buffer */
    ASN1ENCODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

enum
{
    ASN1DECODE_APPENDED         = 0x00000001L, /* continue behind last pdu*/
    ASN1DECODE_REWINDBUFFER     = 0x00000004L, /* rescan from buffer start*/
    ASN1DECODE_SETBUFFER        = 0x00000008L, /* use a user-given src buffer */
    ASN1DECODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

/* ------ public basic ASN.1 API ------ */

extern ASN1_PUBLIC ASN1module_t ASN1API ASN1_CreateModule
(
    ASN1uint32_t            nVersion,
    ASN1encodingrule_e      eRule,
    ASN1uint32_t            dwFlags, /* ASN1FLAGS_NONE or ASN1FLAGS_NOASSERT */
    ASN1uint32_t            cPDU,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseModule
(
    ASN1module_t        pModule
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateEncoder
(
    ASN1module_t        pModule,
    ASN1encoding_t     *ppEncoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Encode
(
    ASN1encoding_t      pEncoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder
(
    ASN1encoding_t      pEncoderInfo
);


extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateDecoder
(
    ASN1module_t        pModule,
    ASN1decoding_t     *ppDecoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Decode
(
    ASN1decoding_t      pDecoderInfo,
    void              **ppDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseDecoder
(
    ASN1decoding_t      pDecoderInfo
);


extern ASN1_PUBLIC void ASN1API ASN1_FreeEncoded
(
    ASN1encoding_t      pEncoderInfo,
    void               *pBuf
);

extern ASN1_PUBLIC void ASN1API ASN1_FreeDecoded
(
    ASN1decoding_t      pDecoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum
);


/* ------ public advanced ASN.1 API ------ */

typedef enum
{
    // common set option
    ASN1OPT_CHANGE_RULE                 = 0x101, 

    // common get option
    ASN1OPT_GET_RULE                    = 0x201,

    // set encoder option
    ASN1OPT_NOT_REUSE_BUFFER            = 0x301,
    ASN1OPT_REWIND_BUFFER               = 0x302,

    // get encoder option

    // set decoder option
    ASN1OPT_SET_DECODED_BUFFER          = 0x501,
    ASN1OPT_DEL_DECODED_BUFFER          = 0x502,

    // get decoder option
    ASN1OPT_GET_DECODED_BUFFER_SIZE     = 0x601,
}
    ASN1option_e;

typedef struct tagASN1optionparam_t
{
    ASN1option_e    eOption;
    union
    {
        ASN1encodingrule_e              eRule;
        ASN1uint32_t                    cbRequiredDecodedBufSize;
        struct
        {
            ASN1octet_t    *pbBuf;
            ASN1uint32_t    cbBufSize;
        }                               Buffer;
    };
}
    ASN1optionparam_t, ASN1optionparam_s;


extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);


/* ------ internal ASN.1 API ------ */

extern ASN1_PUBLIC void ASN1API ASN1bitstring_free(ASN1bitstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1octetstring_free(ASN1octetstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1objectidentifier_free(ASN1objectidentifier_t *);
extern ASN1_PUBLIC void ASN1API ASN1charstring_free(ASN1charstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1char16string_free(ASN1char16string_t *);
extern ASN1_PUBLIC void ASN1API ASN1char32string_free(ASN1char32string_t *);
extern ASN1_PUBLIC void ASN1API ASN1ztcharstring_free(ASN1ztcharstring_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar16string_free(ASN1ztchar16string_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar32string_free(ASN1ztchar32string_t);
extern ASN1_PUBLIC void ASN1API ASN1open_free(ASN1open_t *);
extern ASN1_PUBLIC void ASN1API ASN1utf8string_free(ASN1wstring_t *);

extern ASN1_PUBLIC void * ASN1API ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size);
extern ASN1_PUBLIC void * ASN1API ASN1DecRealloc(ASN1decoding_t dec, void *ptr, ASN1uint32_t size);
extern ASN1_PUBLIC void   ASN1API ASN1Free(void *ptr);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err);
extern ASN1_PUBLIC ASN1error_e ASN1API ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err);

extern ASN1_PUBLIC void ASN1API ASN1intx_sub(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_uoctets(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_free(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_add(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);

extern ASN1_PUBLIC void ASN1API ASN1DbgMemTrackDumpCurrent ( ASN1uint32_t nModuleName );

extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);

extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *v1, ASN1objectidentifier_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier2_cmp(ASN1objectidentifier2_t *v1, ASN1objectidentifier2_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1bitstring_cmp(ASN1bitstring_t *, ASN1bitstring_t *, int);
extern ASN1_PUBLIC int ASN1API ASN1octetstring_cmp(ASN1octetstring_t *, ASN1octetstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1charstring_cmp(ASN1charstring_t *, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1char16string_cmp(ASN1char16string_t *, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1char32string_cmp(ASN1char32string_t *, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1ztcharstring_cmp(ASN1ztcharstring_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1ztchar16string_cmp(ASN1ztchar16string_t, ASN1ztchar16string_t);
extern ASN1_PUBLIC int ASN1API ASN1open_cmp(ASN1open_t *, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1generalizedtime_cmp(ASN1generalizedtime_t *, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1utctime_cmp(ASN1utctime_t *, ASN1utctime_t *);


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

typedef enum tagASN1real_e
{
    eReal_Normal,
    eReal_PlusInfinity,
    eReal_MinusInfinity
}
    ASN1real_e;

typedef struct tagASN1real_t
{
    ASN1real_e type;
    ASN1intx_t mantissa;
    ASN1uint32_t base;
    ASN1intx_t exponent;
}
    ASN1real_t;

typedef struct tagASN1external_t
{
#   define ASN1external_data_value_descriptor_o 0
    ASN1octet_t o[1];
    struct ASN1external_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1external_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1external_identification_context_negotiation_o 3
            struct ASN1external_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
        } u;
    } identification;
    ASN1objectdescriptor_t data_value_descriptor;
    struct ASN1external_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1external_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1external_t;

typedef struct ASN1external_identification_s ASN1external_identification_t;
typedef struct ASN1external_identification_context_negotiation_s ASN1external_identification_context_negotiation_t;
typedef struct ASN1external_data_value_s ASN1external_data_value_t;

typedef struct tagASN1embeddedpdv_t
{
    struct ASN1embeddedpdv_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_identification_syntaxes_o 0
            struct ASN1embeddedpdv_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1embeddedpdv_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1embeddedpdv_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1embeddedpdv_identification_context_negotiation_o 3
            struct ASN1embeddedpdv_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1embeddedpdv_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1embeddedpdv_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1embeddedpdv_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1embeddedpdv_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1embeddedpdv_t;

typedef struct ASN1embeddedpdv_identification_s ASN1embeddedpdv_identification_t;
typedef struct ASN1embeddedpdv_identification_syntaxes_s ASN1embeddedpdv_identification_syntaxes_t;
typedef struct ASN1embeddedpdv_identification_context_negotiation_s ASN1embeddedpdv_identification_context_negotiation_t;
typedef struct ASN1embeddedpdv_data_value_s ASN1embeddedpdv_data_value_t;

typedef struct tagASN1characterstring_t
{
    struct ASN1characterstring_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_identification_syntaxes_o 0
            struct ASN1characterstring_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1characterstring_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1characterstring_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1characterstring_identification_context_negotiation_o 3
            struct ASN1characterstring_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1characterstring_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1characterstring_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1characterstring_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1characterstring_data_value_encoded_o 1
            ASN1octetstring_t encoded;
        } u;
    } data_value;
} ASN1characterstring_t;

typedef struct ASN1characterstring_identification_s ASN1characterstring_identification_t;
typedef struct ASN1characterstring_identification_syntaxes_s ASN1characterstring_identification_syntaxes_t;
typedef struct ASN1characterstring_identification_context_negotiation_s ASN1characterstring_identification_context_negotiation_t;
typedef struct ASN1characterstring_data_value_s ASN1characterstring_data_value_t;


extern ASN1_PUBLIC void ASN1API ASN1real_free(ASN1real_t *);
extern ASN1_PUBLIC void ASN1API ASN1external_free(ASN1external_t *);
extern ASN1_PUBLIC void ASN1API ASN1embeddedpdv_free(ASN1embeddedpdv_t *);
extern ASN1_PUBLIC void ASN1API ASN1characterstring_free(ASN1characterstring_t *);


#ifdef __cplusplus
}
#endif

#endif // __MS_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\msper.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_PER_H__
#define __MS_PER_H__

#include <msasn1.h>

#ifdef __cplusplus
extern "C" {
#endif

extern ASN1_PUBLIC int ASN1API ASN1PEREncZero(ASN1encoding_t enc, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBit(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBitVal(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBitIntx(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncNormallySmallBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctets(ASN1encoding_t enc, ASN1uint32_t noctets, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val, ASN1uint32_t minlen);
extern ASN1_PUBLIC int ASN1API ASN1PEREncNormallySmall(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedIntx(ASN1encoding_t enc, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedUIntx(ASN1encoding_t enc, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedLength(ASN1uint32_t *len, ASN1encoding_t enc, ASN1uint32_t nitems);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmented(ASN1encoding_t enc, ASN1uint32_t nitems, ASN1octet_t *val, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PEREncObjectIdentifier(ASN1encoding_t enc, ASN1objectidentifier_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncObjectIdentifier2(ASN1encoding_t enc, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncDouble(ASN1encoding_t enc, double d);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFlush(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFlushFragmentedToParent(ASN1encoding_t enc);
extern ASN1_PUBLIC void ASN1API ASN1PEREncAlignment(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncMultibyteString(ASN1encoding_t enc, ASN1char_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncGeneralizedTime(ASN1encoding_t enc, ASN1generalizedtime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUTCTime(ASN1encoding_t dec, ASN1utctime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckExtensions(ASN1uint32_t nbits, ASN1octet_t *val);

extern ASN1_PUBLIC int ASN1API ASN1PERDecBit(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN32Val(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN16Val(ASN1decoding_t dec, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN8Val(ASN1decoding_t dec, ASN1uint8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecNXVal(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmented(ASN1decoding_t dec, ASN1uint32_t *nitems, ASN1octet_t **val, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFlush(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1PERDecAlignment(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1PERDecExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBits(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecDouble(ASN1decoding_t dec, double *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBitIntx(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedIntx(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedUIntx(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedLength(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecObjectIdentifier2(ASN1decoding_t dec, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecMultibyteString(ASN1decoding_t dec, ASN1char_t **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecGeneralizedTime(ASN1decoding_t dec, ASN1generalizedtime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTCTime(ASN1decoding_t dec, ASN1utctime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipBits(ASN1decoding_t dec, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipFragmented(ASN1decoding_t dec, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmall(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions);

extern ASN1_PUBLIC int ASN1API ASN1PEREncInteger(ASN1encoding_t enc, ASN1int32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecInteger(ASN1decoding_t dec, ASN1int32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUnsignedInteger(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUnsignedInteger(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUnsignedShort(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUnsignedShort(ASN1decoding_t dec, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBoolean(ASN1encoding_t enc, ASN1bool_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBoolean(ASN1decoding_t dec, ASN1bool_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncExtensionBitClear(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncExtensionBitSet(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSimpleChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSimpleChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSimpleChoiceEx(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSimpleChoiceEx(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncComplexChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice);
extern ASN1_PUBLIC int ASN1API ASN1PERDecComplexChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice);

/* unconstrained */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_NoSize(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_NoSize(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr);

/* fixed-array */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_FixedSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_FixedSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_VarSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_VarSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);

/* unbounded */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_FixedSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_FixedSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_VarSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_VarSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);

typedef int (ASN1CALL *ASN1iterator_encfn) (ASN1encoding_t, ASN1iterator_t *);
typedef int (ASN1CALL *ASN1iterator_decfn) (ASN1decoding_t, ASN1iterator_t *);
typedef int (ASN1CALL *ASN1iterator_freefn) (ASN1iterator_t *);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSeqOf_NoSize(ASN1encodi