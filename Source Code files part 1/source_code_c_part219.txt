   )
{
    PDOSRECORD pDOSRecord;

    if (pConsoleRecord == NULL)
        return;

    while (pDOSRecord = pConsoleRecord->DOSRecord){
        pConsoleRecord->DOSRecord = pDOSRecord->DOSRecordNext;
        BaseSrvFreeDOSRecord (pDOSRecord);
    }

    if (pConsoleRecord->lpszzCurDirs)
        RtlFreeHeap(BaseSrvHeap, 0, pConsoleRecord->lpszzCurDirs);

    if (pConsoleRecord->DosUserToken)
        NtClose(pConsoleRecord->DosUserToken);

    BaseSrvRemoveConsoleRecord (pConsoleRecord);

    RtlFreeHeap (RtlProcessHeap (), 0, pConsoleRecord );
}

VOID BaseSrvRemoveConsoleRecord (
    PCONSOLERECORD pConsoleRecord
    )
{

    PCONSOLERECORD pTempLast,pTemp;

    if (DOSHead == NULL)
        return;

    if(DOSHead == pConsoleRecord) {
        DOSHead = pConsoleRecord->Next;
        return;
    }

    pTempLast = DOSHead;
    pTemp = DOSHead->Next;

    while (pTemp && pTemp != pConsoleRecord){
        pTempLast = pTemp;
        pTemp = pTemp->Next;
    }

    if (pTemp)
        pTempLast->Next = pTemp->Next;

    return;
}

PDOSRECORD
BaseSrvAllocateDOSRecord(
    VOID
    )
{
    PDOSRECORD DOSRecord;

    DOSRecord = RtlAllocateHeap ( RtlProcessHeap (), MAKE_TAG( VDM_TAG ), sizeof (DOSRECORD));

    if (DOSRecord == NULL)
        return NULL;

    RtlZeroMemory ((PVOID)DOSRecord,sizeof(DOSRECORD));
    return DOSRecord;
}

VOID BaseSrvFreeDOSRecord (
    PDOSRECORD pDOSRecord
    )
{
    BaseSrvFreeVDMInfo (pDOSRecord->lpVDMInfo);
    if(pDOSRecord->pFilePath) {
       RtlFreeHeap(RtlProcessHeap (), 0, pDOSRecord->pFilePath);
    }

    RtlFreeHeap(RtlProcessHeap (), 0, pDOSRecord);
    return;
}

VOID BaseSrvAddDOSRecord (
    PCONSOLERECORD pConsoleRecord,
    PDOSRECORD pDOSRecord
    )
{
    PDOSRECORD pDOSRecordTemp;

    pDOSRecord->DOSRecordNext = NULL;

    if(pConsoleRecord->DOSRecord == NULL){
        pConsoleRecord->DOSRecord = pDOSRecord;
        return;
    }

    pDOSRecordTemp = pConsoleRecord->DOSRecord;

    while (pDOSRecordTemp->DOSRecordNext)
        pDOSRecordTemp = pDOSRecordTemp->DOSRecordNext;

    pDOSRecordTemp->DOSRecordNext = pDOSRecord;
    return;
}

VOID
BaseSrvRemoveDOSRecord (
    PCONSOLERECORD pConsoleRecord,
    PDOSRECORD pDOSRecord
    )
{
    PDOSRECORD DOSRecordCurrent,DOSRecordLast = NULL;

    if( pConsoleRecord == NULL)
        return;

    if(pConsoleRecord->DOSRecord == pDOSRecord){
        pConsoleRecord->DOSRecord = pDOSRecord->DOSRecordNext;
        return;
        }

    DOSRecordLast = pConsoleRecord->DOSRecord;
    if (DOSRecordLast)
        DOSRecordCurrent = DOSRecordLast->DOSRecordNext;
    else
        return;

    while (DOSRecordCurrent && DOSRecordCurrent != pDOSRecord){
        DOSRecordLast = DOSRecordCurrent;
        DOSRecordCurrent = DOSRecordCurrent->DOSRecordNext;
    }

    if (DOSRecordCurrent == NULL)
        return;
    else
        DOSRecordLast->DOSRecordNext = pDOSRecord->DOSRecordNext;

    return;
}


VOID
BaseSrvFreeVDMInfo(
    IN PVDMINFO lpVDMInfo
    )
{
    if (lpVDMInfo == NULL)
        return;

    if (lpVDMInfo->CmdLine)
        RtlFreeHeap(RtlProcessHeap (), 0,lpVDMInfo->CmdLine);

    if (lpVDMInfo->AppName) {
       RtlFreeHeap(RtlProcessHeap (), 0, lpVDMInfo->AppName);
    }

    if (lpVDMInfo->PifFile) {
       RtlFreeHeap(RtlProcessHeap (), 0, lpVDMInfo->PifFile);
    }

    if(lpVDMInfo->Enviornment)
        RtlFreeHeap(RtlProcessHeap (), 0,lpVDMInfo->Enviornment);

    if(lpVDMInfo->Desktop)
        RtlFreeHeap(RtlProcessHeap (), 0,lpVDMInfo->Desktop);

    if(lpVDMInfo->Title)
        RtlFreeHeap(RtlProcessHeap (), 0,lpVDMInfo->Title);

    if(lpVDMInfo->Reserved)
        RtlFreeHeap(RtlProcessHeap (), 0,lpVDMInfo->Reserved);

    if(lpVDMInfo->CurDirectory)
        RtlFreeHeap(RtlProcessHeap (), 0,lpVDMInfo->CurDirectory);

    RtlFreeHeap(RtlProcessHeap (), 0,lpVDMInfo);

    return;
}


ULONG BaseSrvCreatePairWaitHandles (ServerHandle, ClientHandle)
HANDLE *ServerHandle;
HANDLE *ClientHandle;
{
    NTSTATUS Status;
    PCSR_THREAD t;

    Status = NtCreateEvent(
                        ServerHandle,
                        EVENT_ALL_ACCESS,
                        NULL,
                        NotificationEvent,
                        FALSE
                        );

    if (!NT_SUCCESS(Status) )
        return Status;

    t = CSR_SERVER_QUERYCLIENTTHREAD();

    Status = NtDuplicateObject (
                            NtCurrentProcess(),
                            *ServerHandle,
                            t->Process->ProcessHandle,
                            ClientHandle,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS
                         );

    if ( NT_SUCCESS(Status) ){
        return STATUS_SUCCESS;
        }
    else {
        NtClose (*ServerHandle);
        return Status;
    }
}


// generate global task id
//
// The handling of a task id should be redone wrt the user notification
// private apis
// note that wow task id is never 0 or (ULONG)-1
//



ULONG
BaseSrvGetWOWTaskId(
   PSHAREDWOWRECORDHEAD pSharedWowHead // (->pSharedWowRecord)
    )
{
    PWOWRECORD pWOWRecord;
    PSHAREDWOWRECORD pSharedWow = pSharedWowHead->pSharedWowRecord;

    static BOOL fWrapped = FALSE;

    if (WOWTaskIdNext == WOWMAXID) {
        fWrapped = TRUE;
        WOWTaskIdNext = WOWMINID;
    }

    if (fWrapped && NULL != pSharedWow) {
       while (NULL != pSharedWow) {

#if 0
          if (pSharedWow->WowSessionId == WOWTaskIdNext) {
             if (WOWMAXID == ++WOWTaskIdNext) {
                WOWTaskIdNext = WOWMINID;
             }

             pSharedWow = pSharedWowHead->pSharedWowRecord;
             continue; // go back to the beginning of the loop
          }
#endif

          // examine all the records for this wow

          pWOWRecord = pSharedWow->pWOWRecord;
          while (NULL != pWOWRecord) {

             if (pWOWRecord->iTask == WOWTaskIdNext) {
                if (WOWMAXID == ++WOWTaskIdNext) {
                   WOWTaskIdNext = WOWMINID;
                }

                break; // we are breaking out => (pWOWRecord != NULL)
             }

             pWOWRecord = pWOWRecord->WOWRecordNext;
          }


          if (NULL == pWOWRecord) { // id is ok for this wow -- check the next wow
             pSharedWow = pSharedWow->pNextSharedWow;
          }
          else {
             pSharedWow = pSharedWowHead->pSharedWowRecord;
          }
       }
    }

    return WOWTaskIdNext++;
}


VOID
BaseSrvAddConsoleRecord(
    IN PCONSOLERECORD pConsoleRecord
    )
{

    pConsoleRecord->Next = DOSHead;
    DOSHead = pConsoleRecord;
}


VOID BaseSrvCloseStandardHandles (HANDLE hVDM, PDOSRECORD pDOSRecord)
{
    PVDMINFO pVDMInfo = pDOSRecord->lpVDMInfo;

    if (pVDMInfo == NULL)
        return;

    if (pVDMInfo->StdIn)
        NtDuplicateObject (hVDM,
                           pVDMInfo->StdIn,
                           NULL,
                           NULL,
                           0,
                           0,
                           DUPLICATE_CLOSE_SOURCE);

    if (pVDMInfo->StdOut)
        NtDuplicateObject (hVDM,
                           pVDMInfo->StdOut,
                           NULL,
                           NULL,
                           0,
                           0,
                           DUPLICATE_CLOSE_SOURCE);

    if (pVDMInfo->StdErr)
        NtDuplicateObject (hVDM,
                           pVDMInfo->StdErr,
                           NULL,
                           NULL,
                           0,
                           0,
                           DUPLICATE_CLOSE_SOURCE);

    pVDMInfo->StdIn  = 0;
    pVDMInfo->StdOut = 0;
    pVDMInfo->StdErr = 0;
    return;
}

VOID BaseSrvClosePairWaitHandles (PDOSRECORD pDOSRecord)
{
    PCSR_THREAD t;

    if (pDOSRecord->hWaitForParentDup)
        NtClose (pDOSRecord->hWaitForParentDup);

    t = CSR_SERVER_QUERYCLIENTTHREAD();

    if (pDOSRecord->hWaitForParent)
        NtDuplicateObject (t->Process->ProcessHandle,
                           pDOSRecord->hWaitForParent,
                           NULL,
                           NULL,
                           0,
                           0,
                           DUPLICATE_CLOSE_SOURCE);

    pDOSRecord->hWaitForParentDup = 0;
    pDOSRecord->hWaitForParent = 0;
    return;
}


ULONG
BaseSrvSetReenterCount (
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_SET_REENTER_COUNT_MSG b = (PBASE_SET_REENTER_COUNT_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLERECORD pConsoleRecord;
    ULONG SequenceNumber;

    if(!NT_SUCCESS(BaseSrvGetVdmSequence(m->h.ClientId.UniqueProcess, &SequenceNumber))) {
       return (ULONG)STATUS_INVALID_PARAMETER;
    }

    Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
    ASSERT(NT_SUCCESS(Status));
    Status = BaseSrvGetConsoleRecord(b->ConsoleHandle,&pConsoleRecord);

    if (!NT_SUCCESS (Status) || SequenceNumber != pConsoleRecord->SequenceNumber) {
        RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
        return ((ULONG)STATUS_INVALID_PARAMETER);
        }

    if (b->fIncDec == INCREMENT_REENTER_COUNT)
        pConsoleRecord->nReEntrancy++;
    else {
        pConsoleRecord->nReEntrancy--;
        if(pConsoleRecord->hWaitForVDMDup)
           NtSetEvent (pConsoleRecord->hWaitForVDMDup,NULL);
        }

    RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
    return TRUE;
}

/*
 *  Spawn of ntvdm failed before CreateProcessW finished.
 *  delete the console record.
 */


VOID
BaseSrvVDMTerminated (
    IN HANDLE hVDM,
    IN ULONG  DosSesId
    )
{
    NTSTATUS Status;
    PCONSOLERECORD pConsoleRecord;

    RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );

    if (!hVDM)  // no-console-handle case
       Status = GetConsoleRecordDosSesId(DosSesId,&pConsoleRecord);
    else
       Status = BaseSrvGetConsoleRecord(hVDM,&pConsoleRecord);

    if (NT_SUCCESS (Status)) {
        BaseSrvExitVDMWorker(pConsoleRecord);
        }

    RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );

}

NTSTATUS
BaseSrvUpdateVDMSequenceNumber (
    IN ULONG  VdmBinaryType,    // binary type
    IN HANDLE hVDM,             // console handle
    IN ULONG  DosSesId,         // session id
    IN HANDLE UniqueProcessClientID, // client id
    IN HANDLE UniqueProcessParentID // parent id
    )

{
    NTSTATUS Status;
    PCSR_PROCESS ProcessVDM;
    ULONG SequenceNumber;

    if(!NT_SUCCESS(BaseSrvGetVdmSequence(UniqueProcessParentID, &SequenceNumber))){
       return STATUS_INVALID_PARAMETER;
    }


    // so how do we know what to update ?
    // this condition is always true: (hvdm ^ DosSesId)
    // hence since shared wow

    // sequence numbers are important -- hence we need to acquire
    // a wow critical section -- does not hurt -- this op performed once
    // during the new wow creation

    if (IS_SHARED_WOW_BINARY(VdmBinaryType)) {

       PSHAREDWOWRECORD pSharedWowRecord;

       Status = ENTER_WOW_CRITICAL();
       ASSERT(NT_SUCCESS(Status));

       // this looks like a shared wow binary -- hence locate the
       // appropriate vdm either by hvdm or by dos session id
       if (!hVDM) { // search by console handle
          Status = BaseSrvFindSharedWowRecordByConsoleHandle(&gWowHead,
                                                             hVDM,
                                                             &pSharedWowRecord);
       }
       else { // search by the task id
          Status = BaseSrvFindSharedWowRecordByTaskId(&gWowHead,
                                                      DosSesId,
                                                      &pSharedWowRecord,
                                                      NULL);
       }

       if (NT_SUCCESS(Status) && 0 == pSharedWowRecord->SequenceNumber) {

          if (SequenceNumber == pSharedWowRecord->ParentSequenceNumber) {

              // now obtain a sequence number please
              Status = CsrLockProcessByClientId(UniqueProcessClientID,
                                               &ProcessVDM);
              if (NT_SUCCESS(Status)) {
                  ProcessVDM->fVDM = TRUE;
                  pSharedWowRecord->SequenceNumber = ProcessVDM->SequenceNumber;
                  pSharedWowRecord->ParentSequenceNumber = 0;
                  pSharedWowRecord->dwWowExecProcessId = HandleToLong(UniqueProcessClientID);
                  CsrUnlockProcess(ProcessVDM);
              } else {
                  // The spawned ntvdm.exe went away, give up.
                  BaseSrvDeleteSharedWowRecord(&gWowHead,pSharedWowRecord);
              }
          }
       }
       else {
#if DEVL
          DbgPrint( "BASESRV: WOW is in inconsistent state. Contact WOW Team\n");
#endif
       }

       LEAVE_WOW_CRITICAL();
    }
    else {   // not shared wow binary
       PCONSOLERECORD pConsoleRecord;

       Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
       ASSERT( NT_SUCCESS( Status ) );

       if (!hVDM)  // no-console-handle case
          Status = GetConsoleRecordDosSesId(DosSesId,&pConsoleRecord);
       else
          Status = BaseSrvGetConsoleRecord(hVDM,&pConsoleRecord);

       if (NT_SUCCESS (Status) && 0 == pConsoleRecord->SequenceNumber) {

          if (SequenceNumber == pConsoleRecord->ParentSequenceNumber) {
              Status = CsrLockProcessByClientId(UniqueProcessClientID,
                                                &ProcessVDM);
              if (NT_SUCCESS(Status)) {
                  ProcessVDM->fVDM = TRUE;
                  pConsoleRecord->SequenceNumber = ProcessVDM->SequenceNumber;
                  pConsoleRecord->ParentSequenceNumber = 0;
                  pConsoleRecord->dwProcessId = HandleToLong(UniqueProcessClientID);
                  CsrUnlockProcess(ProcessVDM);
              }
              // The spawned ntvdm.exe went away, give up.
              // The caller BasepCreateProcess will clean up dos records, so we don't need to here.
              // else
              //     BaseSrvExitVdmWorker(pConsoleRecord);
          }
       }
       else {
#if DEVL
           DbgPrint( "BASESRV: DOS is in inconsistent state. Contact DOS Team\n");
#endif
       }

       RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
   }
   return Status;
}


VOID
BaseSrvCleanupVDMResources (   //////// BUGBUGBUGBUG
    IN PCSR_PROCESS Process
    )
{
    PCONSOLERECORD pConsoleHead;
    PSHAREDWOWRECORD pSharedWowRecord;
    NTSTATUS Status;
    PBATRECORD pBatRecord;

    if (!Process->fVDM) {
        Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
        ASSERT(NT_SUCCESS(Status));
        pBatRecord = BatRecordHead;
        while (pBatRecord &&
               pBatRecord->SequenceNumber != Process->SequenceNumber)
            pBatRecord = pBatRecord->BatRecordNext;

        if (pBatRecord)
            BaseSrvFreeAndRemoveBatRecord(pBatRecord);
        RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
    }

    // search all the shared wow's

    Status = ENTER_WOW_CRITICAL();
    ASSERT(NT_SUCCESS(Status));

    pSharedWowRecord = gWowHead.pSharedWowRecord;

    while (pSharedWowRecord) {
        if (pSharedWowRecord->SequenceNumber == Process->SequenceNumber) {
           BaseSrvDeleteSharedWowRecord(&gWowHead, pSharedWowRecord);
           break;
        }
        else
           pSharedWowRecord = pSharedWowRecord->pNextSharedWow;
    }

    pSharedWowRecord = gWowHead.pSharedWowRecord;

    while (pSharedWowRecord) {
        if (pSharedWowRecord->ParentSequenceNumber == Process->SequenceNumber) {
           BaseSrvDeleteSharedWowRecord(&gWowHead, pSharedWowRecord);
           break;
        }
        else
           pSharedWowRecord = pSharedWowRecord->pNextSharedWow;
    }

    LEAVE_WOW_CRITICAL();

    // search all the dos's and separate wow's

    Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
    ASSERT(NT_SUCCESS(Status));

    pConsoleHead = DOSHead;

    while (pConsoleHead) {
        if (pConsoleHead->SequenceNumber == Process->SequenceNumber){
            BaseSrvExitVDMWorker (pConsoleHead);
            break;
        }
        else
            pConsoleHead = pConsoleHead->Next;
    }

    pConsoleHead = DOSHead;

    while (pConsoleHead) {
        if (pConsoleHead->ParentSequenceNumber == Process->SequenceNumber){
            BaseSrvExitVDMWorker (pConsoleHead);
            break;
        }
        else
            pConsoleHead = pConsoleHead->Next;
    }

    RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
    return;
}


VOID
BaseSrvExitVDMWorker (
    PCONSOLERECORD pConsoleRecord
    )
{
    PDOSRECORD pDOSRecord;

    if (pConsoleRecord->hWaitForVDMDup){
        NtClose(pConsoleRecord->hWaitForVDMDup);
        pConsoleRecord->hWaitForVDMDup =0;
    }

    pDOSRecord = pConsoleRecord->DOSRecord;

    while (pDOSRecord) {
        if (pDOSRecord->hWaitForParentDup) {
            NtSetEvent (pDOSRecord->hWaitForParentDup,NULL);
            NtClose (pDOSRecord->hWaitForParentDup);
            pDOSRecord->hWaitForParentDup = 0;
        }
        pDOSRecord = pDOSRecord->DOSRecordNext;
    }
    NtClose(pConsoleRecord->hVDM);
    BaseSrvFreeConsoleRecord (pConsoleRecord);
    return;
}


NTSTATUS
BaseSrvFillPifInfo (
    PVDMINFO lpVDMInfo,
    PBASE_GET_NEXT_VDM_COMMAND_MSG b
    )
{

    LPSTR    Title;
    ULONG    TitleLen;
    NTSTATUS Status;


    Status  = STATUS_INVALID_PARAMETER;
    if (!lpVDMInfo)
        return Status;

       /*
        *  Get the title for the window in precedence order
        */
             // startupinfo title
    if (lpVDMInfo->TitleLen && lpVDMInfo->Title)
       {
        Title = lpVDMInfo->Title;
        TitleLen = lpVDMInfo->TitleLen;
        }
             // App Name
    else if (lpVDMInfo->AppName && lpVDMInfo->AppLen)
       {
        Title = lpVDMInfo->AppName;
        TitleLen = lpVDMInfo->AppLen;
        }
            // hopeless
    else {
        Title = NULL;
        TitleLen = 0;
        }

    try {

        if (b->PifLen) {
            *b->PifFile = '\0';
            }

        if (b->TitleLen) {
            *b->Title = '\0';
            }

        if (b->CurDirectoryLen) {
            *b->CurDirectory = '\0';
            }


        if ( (!b->TitleLen || TitleLen <= b->TitleLen) &&
             (!b->PifLen || lpVDMInfo->PifLen <= b->PifLen) &&
             (!b->CurDirectoryLen ||
               lpVDMInfo->CurDirectoryLen <= b->CurDirectoryLen) &&
             (!b->ReservedLen || lpVDMInfo->ReservedLen <= b->ReservedLen))
           {
            if (b->TitleLen) {
                if (Title && TitleLen)  {
                    RtlMoveMemory(b->Title, Title, TitleLen);
                    *((LPSTR)b->Title + TitleLen - 1) = '\0';
                    }
                else {
                    *b->Title = '\0';
                    }
                }

            if (lpVDMInfo->PifLen && b->PifLen)
                RtlMoveMemory(b->PifFile,
                              lpVDMInfo->PifFile,
                              lpVDMInfo->PifLen);

            if (lpVDMInfo->CurDirectoryLen && b->CurDirectoryLen)
                RtlMoveMemory(b->CurDirectory,
                              lpVDMInfo->CurDirectory,
                              lpVDMInfo->CurDirectoryLen
                             );
            if (lpVDMInfo->Reserved && b->ReservedLen)
                RtlMoveMemory(b->Reserved,
                              lpVDMInfo->Reserved,
                              lpVDMInfo->ReservedLen
                             );

            Status = STATUS_SUCCESS;
            }
        }
    except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }


    /* fill out the size for each field */
    b->PifLen = (USHORT)lpVDMInfo->PifLen;
    b->CurDirectoryLen = lpVDMInfo->CurDirectoryLen;
    b->TitleLen = TitleLen;
    b->ReservedLen = lpVDMInfo->ReservedLen;

    return Status;
}


/***************************************************************************\
* IsClientSystem
*
* Determines if caller is SYSTEM
*
* Returns TRUE is caller is system, FALSE if not (or error)
*
* History:
* 12-May-94 AndyH       Created
\***************************************************************************/
BOOL
IsClientSystem(
    HANDLE hUserToken
    )
{
    BYTE achBuffer[100];
    PTOKEN_USER pUser = (PTOKEN_USER) achBuffer;
    DWORD dwBytesRequired;
    NTSTATUS NtStatus;
    BOOL fAllocatedBuffer = FALSE;
    BOOL fSystem;
    SID_IDENTIFIER_AUTHORITY SidIdAuth = SECURITY_NT_AUTHORITY;
    static PSID pSystemSid = NULL;

    if (!pSystemSid) {
        // Create a sid for local system
        NtStatus = RtlAllocateAndInitializeSid(
                     &SidIdAuth,
                     1,                   // SubAuthorityCount, 1 for local system
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,0,0,0,0,0,0,
                     &pSystemSid
                     );

        if (!NT_SUCCESS(NtStatus)) {
            pSystemSid = NULL;
            return FALSE;
            }
        }

    NtStatus = NtQueryInformationToken(
                 hUserToken,                // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 sizeof(achBuffer),         // TokenInformationLength
                 &dwBytesRequired           // ReturnLength
                 );

    if (!NT_SUCCESS(NtStatus))
    {
        if (NtStatus != STATUS_BUFFER_TOO_SMALL)
        {
            return FALSE;
        }

        //
        // Allocate space for the user info
        //

        pUser = (PTOKEN_USER) RtlAllocateHeap(BaseSrvHeap, MAKE_TAG( VDM_TAG ), dwBytesRequired);
        if (pUser == NULL)
        {
            return FALSE;
        }

        fAllocatedBuffer = TRUE;

        //
        // Read in the UserInfo
        //

        NtStatus = NtQueryInformationToken(
                     hUserToken,                // Handle
                     TokenUser,                 // TokenInformationClass
                     pUser,                     // TokenInformation
                     dwBytesRequired,           // TokenInformationLength
                     &dwBytesRequired           // ReturnLength
                     );

        if (!NT_SUCCESS(NtStatus))
        {
            RtlFreeHeap(BaseSrvHeap, 0, pUser);
            return FALSE;
        }
    }


    // Compare callers SID with SystemSid

    fSystem = RtlEqualSid(pSystemSid,  pUser->User.Sid);

    if (fAllocatedBuffer)
    {
        RtlFreeHeap(BaseSrvHeap, 0, pUser);
    }

    return (fSystem);
}
BOOL
BaseSrvIsVdmAllowed(
    VOID
    )
/*++

Routine Description:

    This routine checks the registry to see if running NTVDM is disabled.
    If the information is not specified in registry, the default will be NOT disabled and
    TRUE will be returned to indicated running VDM is allowed.

Arguments:

    None.

Return Value:

    BOOL - TRUE means yes; Otherwise no.

--*/
{
    NTSTATUS            status;
    HANDLE              hCurrentUser, hAppCompat;
    UNICODE_STRING      unicodeKeyName, unicodeValueName;
    OBJECT_ATTRIBUTES   objectAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION keyValueInformation;
    UCHAR               valueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    ULONG               resultLength;
    BOOL                vdmAllowed, impersonate, checkDefault = TRUE;
    ULONG               flags = 0;

    RtlInitUnicodeString(&unicodeValueName, L"VDMDisallowed" );
    keyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)valueBuffer;

    //
    // First check if machine policy for Vdm Disallow is enabled, if yes
    // vdm is not allowed to run.
    //

    RtlInitUnicodeString(&unicodeKeyName,
                         L"\\REGISTRY\\MACHINE\\Software\\Policies\\Microsoft\\Windows\\AppCompat");
    InitializeObjectAttributes( &objectAttributes,
                                &unicodeKeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    //
    //  Open key for READ access.
    //

    status = NtOpenKey( &hAppCompat,
                        KEY_READ,
                        &objectAttributes );

    if (NT_SUCCESS(status))
    {
        status = NtQueryValueKey( hAppCompat,
                                  &unicodeValueName,
                                  KeyValuePartialInformation,
                                  keyValueInformation,
                                  sizeof(valueBuffer),
                                  &resultLength
                                );
        NtClose( hAppCompat);
        if (NT_SUCCESS(status) && keyValueInformation->Type == REG_DWORD)
        {
            checkDefault = FALSE;
            flags = *(PULONG)keyValueInformation->Data;
            if (flags)
            {
                return FALSE;
            }
        }
    }

    //
    // If we come here, machine policy is either not configured or VDM
    // is allowed to run on this machine.
    // Next check if current user policy for Vdm Disallow is enabled, if yes
    // vdm is not allowed to run.
    //

    impersonate = CsrImpersonateClient(NULL);

    if (impersonate) {

        status = RtlOpenCurrentUser(KEY_READ, &hCurrentUser);

        CsrRevertToSelf();
    } else {
        status = STATUS_BAD_IMPERSONATION_LEVEL;
    }

    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&unicodeKeyName,
                             L"Software\\Policies\\Microsoft\\Windows\\AppCompat");
        InitializeObjectAttributes( &objectAttributes,
                                    &unicodeKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    hCurrentUser,
                                    NULL );

        //
        //  Open key for READ access.
        //

        status = NtOpenKey( &hAppCompat,
                            KEY_READ,
                            &objectAttributes );

        NtClose(hCurrentUser);
        if (NT_SUCCESS(status))
        {
            status = NtQueryValueKey( hAppCompat,
                                      &unicodeValueName,
                                      KeyValuePartialInformation,
                                      keyValueInformation,
                                      sizeof(valueBuffer),
                                      &resultLength
                                    );
            NtClose( hAppCompat);
            if (NT_SUCCESS(status) && keyValueInformation->Type == REG_DWORD)
            {
                checkDefault = FALSE;
                flags = *(PULONG)keyValueInformation->Data;
                if (flags)
                {
                    return FALSE;
                }
            }
        }
    }

    if (checkDefault == FALSE)
    {
        return TRUE;
    }

    //
    // If we come here, machine policy is not configured AND
    // the current user policy is not configured either.
    // Next check if default setting for Vdm Disallow is enabled, if yes
    // vdm is not allowed to run.
    //

    vdmAllowed = TRUE;
    RtlInitUnicodeString(&unicodeKeyName, L"\\REGISTRY\\MACHINE\\System\\CurrentControlSet\\Control\\WOW");
    RtlInitUnicodeString(&unicodeValueName, L"DisallowedPolicyDefault" );
    InitializeObjectAttributes( &objectAttributes,
                                &unicodeKeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    //
    //  Open key for READ access.
    //

    status = NtOpenKey( &hAppCompat,
                        KEY_READ,
                        &objectAttributes );

    if (NT_SUCCESS(status))
    {
        status = NtQueryValueKey( hAppCompat,
                                  &unicodeValueName,
                                  KeyValuePartialInformation,
                                  keyValueInformation,
                                  sizeof(valueBuffer),
                                  &resultLength
                                );
        NtClose( hAppCompat);
        if (NT_SUCCESS(status))
        {
            if (keyValueInformation->Type == REG_DWORD)
            {
                flags = *(PULONG)keyValueInformation->Data;
                if (flags) vdmAllowed = FALSE;
            }

        }
    }
    return vdmAllowed;
}

NTSTATUS
BaseSrvIsClientVdm(
    IN  HANDLE UniqueProcessClientId
    )
/*
 * Verifies that the client thread is in a VDM process
 *
 */
{
    NTSTATUS Status;
    PCSR_PROCESS    Process;
    VDM_QUERY_VDM_PROCESS_DATA QueryVdmProcessData;


    Status = CsrLockProcessByClientId(UniqueProcessClientId,&Process);
    if (!NT_SUCCESS(Status))
        return Status;

    //
    // Check the Target Process to see if this is a Wx86 process
    //

    QueryVdmProcessData.IsVdmProcess = FALSE;

    QueryVdmProcessData.ProcessHandle = Process->ProcessHandle;

    Status = NtVdmControl(VdmQueryVdmProcess, &QueryVdmProcessData);

    if (!NT_SUCCESS(Status) || QueryVdmProcessData.IsVdmProcess == FALSE) {

        Status = STATUS_ACCESS_DENIED;
    }

    CsrUnlockProcess(Process);

    return(Status);
}

NTSTATUS
BaseSrvGetSharedWowRecordByPid(
   DWORD                dwProcessId,
   PSHAREDWOWRECORD*    ppSharedWowRecord
)
{
   PSHAREDWOWRECORD pSharedWowRecord = gWowHead.pSharedWowRecord;

   while (NULL != pSharedWowRecord) {
      if (pSharedWowRecord->dwWowExecProcessId == dwProcessId) {
         break;
      }
      pSharedWowRecord = pSharedWowRecord->pNextSharedWow;
   }

   if (NULL != pSharedWowRecord) {
      *ppSharedWowRecord = pSharedWowRecord;
      return STATUS_SUCCESS;
   }

   return STATUS_NOT_FOUND; // bummer, this is not found
}

NTSTATUS
BaseSrvGetConsoleRecordByPid (
    DWORD dwProcessId,
    OUT PCONSOLERECORD *pConsoleRecord
    )
{
    PCONSOLERECORD pConsoleHead;

    pConsoleHead = DOSHead;


    while (pConsoleHead) {
           if (pConsoleHead->dwProcessId == dwProcessId){
               *pConsoleRecord = pConsoleHead;
                return STATUS_SUCCESS;
           }
           else
              pConsoleHead = pConsoleHead->Next;
    }

    return STATUS_NOT_FOUND;
}
NTSTATUS
BaseSrvAddSepWowTask(
      PBASE_GET_NEXT_VDM_COMMAND_MSG b,
      PCONSOLERECORD pConsoleRecord
){
    PDOSRECORD pDosRecord;
    LPSHAREDTASK pSharedTask;
    PCHAR pFilePath; 
    DWORD dwFilePath;   
    BOOL fWinExecApp = FALSE;

    if(b->EnvLen != sizeof(SHAREDTASK)) {
       return STATUS_INVALID_PARAMETER;
    }

    if(!pConsoleRecord->pfnW32HungAppNotifyThread) {
       pConsoleRecord->pfnW32HungAppNotifyThread = (LPTHREAD_START_ROUTINE)b->Reserved;
    }

    if(b->iTask == -1) {
       // this wow app was run through winexec instead of createprocess
       // we need to add a record for this app.
       pDosRecord = BaseSrvAllocateDOSRecord();
       if(NULL == pDosRecord) {
          return STATUS_MEMORY_NOT_ALLOCATED;
       }
       pDosRecord->iTask = BaseSrvGetWOWTaskId(&gWowHead);
       pDosRecord->VDMState = VDM_BUSY;
       fWinExecApp = TRUE;
    }
    else {
       pDosRecord = pConsoleRecord->DOSRecord;       
    }

    if(pDosRecord->pFilePath) {
       RtlFreeHeap(RtlProcessHeap (), 0, pDosRecord->pFilePath);
       pDosRecord->pFilePath = NULL;
    }

    pSharedTask = (LPSHAREDTASK) b->Env;    
    pFilePath = pSharedTask->szFilePath;
    while(*pFilePath  && 
          pFilePath < pSharedTask->szFilePath + 127) {
            pFilePath++;
    }
    dwFilePath = (DWORD)(pFilePath - pSharedTask->szFilePath) + 1;

    if(pDosRecord->pFilePath) {
       RtlFreeHeap(RtlProcessHeap (), 0, pDosRecord->pFilePath);       
    }
    pDosRecord->pFilePath = RtlAllocateHeap ( RtlProcessHeap (), MAKE_TAG( VDM_TAG ), dwFilePath);
    if(!pDosRecord->pFilePath) {
       if(fWinExecApp) {
          BaseSrvFreeDOSRecord(pDosRecord);
       }
       return STATUS_MEMORY_NOT_ALLOCATED;
    }
     
    pDosRecord->dwThreadId = pSharedTask->dwThreadId;
    pDosRecord->hTask16 = pSharedTask->hTask16;
    pDosRecord->hMod16  = pSharedTask->hMod16;
    RtlCopyMemory( pDosRecord->szModName, pSharedTask->szModName,9);
    RtlCopyMemory( pDosRecord->pFilePath, pSharedTask->szFilePath, dwFilePath);
    pDosRecord->pFilePath[dwFilePath-1] = 0;
    if(fWinExecApp) {
       BaseSrvAddDOSRecord(pConsoleRecord,pDosRecord);
    }
    return STATUS_SUCCESS;
}

NTSTATUS BaseSrvAddSharedWowTask (
    PBASE_GET_NEXT_VDM_COMMAND_MSG b,     
    PSHAREDWOWRECORD pSharedWow
    )
{
    PWOWRECORD pWowRecord;
    BOOL fWinExecApp = FALSE;
    LPSHAREDTASK pSharedTask;
    PCHAR pFilePath;
    DWORD dwFilePath;

    //
    // Make sure source buffer is the right size.
    //

    if(b->EnvLen != sizeof(SHAREDTASK)) {
       return STATUS_INVALID_PARAMETER;
    }

    if(!pSharedWow->pfnW32HungAppNotifyThread) {
       pSharedWow->pfnW32HungAppNotifyThread = (LPTHREAD_START_ROUTINE)b->Reserved;
    }

    if(b->iTask == -1) {
       // this wow app was run through winexec instead of createprocess
       // we need to add a record for this app.
       pWowRecord = BaseSrvAllocateWOWRecord(&gWowHead);
       if(NULL == pWowRecord) {
          return STATUS_MEMORY_NOT_ALLOCATED;
       }
       pWowRecord->fDispatched = TRUE;
       fWinExecApp = TRUE;
    }
    else {
       // this wow app run through createprocess, there should be a record
       // of it stored someplace.
       // find it and check if it needs to be updated

       pWowRecord = pSharedWow->pWOWRecord;

       while (NULL != pWowRecord && pWowRecord->iTask != b->iTask){
              pWowRecord = pWowRecord->WOWRecordNext;
       }
       if (NULL == pWowRecord) {
           // Couldn't find the record,bad iTask then
           return  STATUS_INVALID_PARAMETER;
       }
    }

    b->iTask = pWowRecord->iTask;
    pSharedTask = (LPSHAREDTASK) b->Env;


    pFilePath = pSharedTask->szFilePath;
    while(*pFilePath  && 
          pFilePath < pSharedTask->szFilePath + 127) {
            pFilePath++;
    }
    dwFilePath = (DWORD)(pFilePath - pSharedTask->szFilePath) + 1;

    if(pWowRecord->pFilePath) {
       RtlFreeHeap(RtlProcessHeap (), 0, pWowRecord->pFilePath);       
    }

    pWowRecord->pFilePath = RtlAllocateHeap ( RtlProcessHeap (), MAKE_TAG( VDM_TAG ), dwFilePath);
    if(!pWowRecord->pFilePath) {
       if(fWinExecApp) {
          BaseSrvFreeWOWRecord(pWowRecord);
       }
       return STATUS_MEMORY_NOT_ALLOCATED;
    }
     
    pWowRecord->dwThreadId = pSharedTask->dwThreadId;
    pWowRecord->hTask16 = pSharedTask->hTask16;
    pWowRecord->hMod16  = pSharedTask->hMod16;
    RtlCopyMemory( pWowRecord->szModName, pSharedTask->szModName,9);
    RtlCopyMemory( pWowRecord->pFilePath, pSharedTask->szFilePath, dwFilePath);
    pWowRecord->pFilePath[dwFilePath-1] = 0;

    if(fWinExecApp) {
       BaseSrvAddWOWRecord (pSharedWow, pWowRecord);
    }
    return STATUS_SUCCESS;
}

NTSTATUS
BaseSrvAddWowTask (
      PCSR_API_MSG m,
      ULONG SequenceNumber
){
  PBASE_GET_NEXT_VDM_COMMAND_MSG b = (PBASE_GET_NEXT_VDM_COMMAND_MSG)&m->u.ApiMessageData;
  DWORD dwProcessId = HandleToLong( m->h.ClientId.UniqueProcess);
  PCONSOLERECORD pConsoleRecord;
  PSHAREDWOWRECORD pSharedWow;
  NTSTATUS Status;

  RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
  Status = BaseSrvGetConsoleRecordByPid(dwProcessId, &pConsoleRecord);
  if(NT_SUCCESS(Status)) {
     if(pConsoleRecord->SequenceNumber == SequenceNumber) {
        Status = BaseSrvAddSepWowTask(b, pConsoleRecord);
     }
     else {
        RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
        return STATUS_INVALID_PARAMETER;  
     }
  }
  RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );

  if(NT_SUCCESS(Status)) {
     return STATUS_SUCCESS;
  }  

  ENTER_WOW_CRITICAL();

  Status = BaseSrvGetSharedWowRecordByPid(dwProcessId, &pSharedWow);
  if(NT_SUCCESS(Status)) {
     if(pSharedWow->SequenceNumber == SequenceNumber) {
       Status = BaseSrvAddSharedWowTask(b, pSharedWow);
     }
     else 
       Status = STATUS_INVALID_PARAMETER;
  }
  LEAVE_WOW_CRITICAL();
  return Status;
}

BOOL 
BaseSrvCheckProcessAccess(
           DWORD dwProcessId,
           BOOL fImpersonateClientFirst
){
  BOOL fResult;
  CLIENT_ID ClientId;
  OBJECT_ATTRIBUTES Obja;
  HANDLE ProcessHandle;
  NTSTATUS Status;

  if(fImpersonateClientFirst) {
     fResult = CsrImpersonateClient(NULL);
     if(!fResult) {
        return STATUS_BAD_IMPERSONATION_LEVEL;
     }
  }
     
  ClientId.UniqueThread = NULL;
  ClientId.UniqueProcess = LongToHandle(dwProcessId);;

  InitializeObjectAttributes(
      &Obja,
      NULL,
      0,
      NULL,
      NULL
      );
  Status = NtOpenProcess( &ProcessHandle,
                          PROCESS_QUERY_INFORMATION,
                          &Obja,
                          &ClientId);

  if(fImpersonateClientFirst) {
     CsrRevertToSelf();
  }

  if(!NT_SUCCESS(Status)) {
     return STATUS_INVALID_PARAMETER;
  }

  NtClose(ProcessHandle);
  return STATUS_SUCCESS;
}  

NTSTATUS
BaseSrvEnumSepWow (
      PBASE_GET_NEXT_VDM_COMMAND_MSG b,
      PCONSOLERECORD pConsoleRecord
){
  PDOSRECORD pDosRecord;
  LPSHAREDTASK pCurrentTask;
  DWORD cbTaskArray = 0;
  PCHAR pSource,pDest;  
  NTSTATUS Status;

  pDosRecord = pConsoleRecord->DOSRecord;


  RtlZeroMemory(b->Env, b->EnvLen);

  pCurrentTask = (LPSHAREDTASK)b->Env;

  while(pDosRecord) {             
        if(pDosRecord->pFilePath) {
           cbTaskArray += sizeof(SHAREDTASK);
           if(cbTaskArray <= b->EnvLen) {
              pCurrentTask->dwThreadId = pDosRecord->dwThreadId;
              pCurrentTask->hTask16 = pDosRecord->hTask16;
              pCurrentTask->hMod16 = pDosRecord->hMod16;
              RtlCopyMemory(pCurrentTask->szModName,pDosRecord->szModName,9);
              pSource = pDosRecord->pFilePath;
              pDest = pCurrentTask->szFilePath;
              while(*pSource) {
                    *pDest++ = *pSource++;              
              }
              pCurrentTask++;
           }
        }
        pDosRecord = pDosRecord->DOSRecordNext;
  }

  Status = cbTaskArray > b->EnvLen ? STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS;

  b->EnvLen = cbTaskArray;

  return Status;
}

NTSTATUS
BaseSrvEnumSharedWow (
      PBASE_GET_NEXT_VDM_COMMAND_MSG b,
      PSHAREDWOWRECORD pSharedWow
){
  PWOWRECORD pWowRecord;
  LPSHAREDTASK pCurrentTask;
  DWORD cbTaskArray = 0;
  PCHAR pSource,pDest;  
  NTSTATUS Status;

  pWowRecord = pSharedWow->pWOWRecord;
   
  RtlZeroMemory(b->Env, b->EnvLen);

  pCurrentTask = (LPSHAREDTASK)b->Env;



  while(pWowRecord) {      
        if(pWowRecord->pFilePath) {
           cbTaskArray += sizeof(SHAREDTASK);
           if(cbTaskArray <= b->EnvLen) {
              pCurrentTask->dwThreadId = pWowRecord->dwThreadId;
              pCurrentTask->hTask16 = pWowRecord->hTask16;
              pCurrentTask->hMod16 = pWowRecord->hMod16;
              RtlCopyMemory(pCurrentTask->szModName,pWowRecord->szModName,9);
              pSource = pWowRecord->pFilePath;
              pDest = pCurrentTask->szFilePath;
              while(*pSource) {
                    *pDest++ = *pSource++;
              }
              pCurrentTask++;   
           }
        }
        pWowRecord = pWowRecord->WOWRecordNext;
  }

  Status = cbTaskArray > b->EnvLen ? STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS;

  b->EnvLen = cbTaskArray;

  return Status;
}


NTSTATUS
BaseSrvEnumWowTask (
      PBASE_GET_NEXT_VDM_COMMAND_MSG b
){
  PCONSOLERECORD pConsoleRecord;
  PSHAREDWOWRECORD pSharedWow;
  BOOL fReturnSize = FALSE;
  NTSTATUS Status;  

  Status = BaseSrvCheckProcessAccess(b->iTask,TRUE);
  if(!NT_SUCCESS(Status)) {
     return STATUS_ACCESS_DENIED;
  }  
  RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );    
  Status = BaseSrvGetConsoleRecordByPid(b->iTask,&pConsoleRecord);
  if(NT_SUCCESS(Status)) {
     Status = BaseSrvEnumSepWow(b,
                              pConsoleRecord);
  }
  RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
  if(NT_SUCCESS(Status)) {
     return STATUS_SUCCESS;
  }

  ENTER_WOW_CRITICAL();
  Status = BaseSrvGetSharedWowRecordByPid(b->iTask,&pSharedWow); 
  if(NT_SUCCESS(Status)) {
     Status = BaseSrvEnumSharedWow(b,
                              pSharedWow);
  }
  LEAVE_WOW_CRITICAL();
  return Status;
}

NTSTATUS
BaseSrvEnumWowProcess(
       PBASE_GET_NEXT_VDM_COMMAND_MSG b
){
  LPSHAREDPROCESS pSharedProcess;
  PSHAREDWOWRECORD pSharedWow;
  PCONSOLERECORD   pConsoleRecord;
  NTSTATUS Status;
  DWORD cbProcArray = 0;
  BOOL fImpersonate;

  RtlZeroMemory(b->Env, b->EnvLen);

  if(b->iTask) {
     if(!NT_SUCCESS(BaseSrvCheckProcessAccess(b->iTask,TRUE))) {
        return STATUS_ACCESS_DENIED;
     }
     if(b->EnvLen != sizeof(SHAREDPROCESS)) {
        return STATUS_INVALID_PARAMETER;
     }

     ENTER_WOW_CRITICAL();

     Status = BaseSrvGetSharedWowRecordByPid(b->iTask,&pSharedWow);

     if(NT_SUCCESS(Status)) {
        pSharedProcess = (LPSHAREDPROCESS)b->Env;
        pSharedProcess->dwProcessId = pSharedWow->dwWowExecProcessId;
        pSharedProcess->dwAttributes = WOW_SYSTEM;
        pSharedProcess->pfnW32HungAppNotifyThread =pSharedWow->pfnW32HungAppNotifyThread;
     }
     LEAVE_WOW_CRITICAL();

     if(NT_SUCCESS(Status)) {
        return STATUS_SUCCESS;
     }
       
     RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );     
     Status = BaseSrvGetConsoleRecordByPid(b->iTask,&pConsoleRecord);                                               

     if(NT_SUCCESS(Status)) {                                                
        pSharedProcess = (LPSHAREDPROCESS)b->Env;
        pSharedProcess->dwProcessId = pConsoleRecord->dwProcessId;
        pSharedProcess->dwAttributes = 0;
        pSharedProcess->pfnW32HungAppNotifyThread = pConsoleRecord->pfnW32HungAppNotifyThread;
     }
     RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );

     return Status;
  }
  

  fImpersonate = CsrImpersonateClient(NULL);
  if (!fImpersonate) {
      return STATUS_BAD_IMPERSONATION_LEVEL;
  }

  ENTER_WOW_CRITICAL();
  
  pSharedProcess = (LPSHAREDPROCESS)b->Env;
  pSharedWow = gWowHead.pSharedWowRecord;

  while(pSharedWow) {            
        Status =BaseSrvCheckProcessAccess(
                        pSharedWow->dwWowExecProcessId,FALSE);        
        if(NT_SUCCESS(Status)) {
           cbProcArray += sizeof(SHAREDPROCESS);
           if(cbProcArray <= b->EnvLen) {
              pSharedProcess->dwProcessId = pSharedWow->dwWowExecProcessId;
              pSharedProcess->dwAttributes = WOW_SYSTEM;
              pSharedProcess->pfnW32HungAppNotifyThread =pSharedWow->pfnW32HungAppNotifyThread;
              pSharedProcess++;
           }
        }   
        pSharedWow = pSharedWow->pNextSharedWow;
  }
  LEAVE_WOW_CRITICAL();

  RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );

  pConsoleRecord = DOSHead;
  while(pConsoleRecord) {

        // jarbats. 02-04-26
        // The only difference between separate wow and regular dos console records
        // is that DOSRecord->pFilePath is not NULL for a separate wow (initialized
        // in BaseSrvAddSepWow) whereas for dos it is always NULL.
        
        if(pConsoleRecord->DOSRecord && pConsoleRecord->DOSRecord->pFilePath) {
           Status =BaseSrvCheckProcessAccess(
                           pConsoleRecord->dwProcessId,FALSE);        
           if(NT_SUCCESS(Status)) {
              cbProcArray += sizeof(SHAREDPROCESS);
              if(cbProcArray <= b->EnvLen) {
                 pSharedProcess->dwProcessId = pConsoleRecord->dwProcessId;
                 pSharedProcess->dwAttributes = 0;
                 pSharedProcess->pfnW32HungAppNotifyThread = pConsoleRecord->pfnW32HungAppNotifyThread;
                 pSharedProcess++;
              }
           }   
        }
        pConsoleRecord = pConsoleRecord->Next;
  }
  RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );

  CsrRevertToSelf();

  Status = cbProcArray > b->EnvLen ? STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS;

  b->EnvLen = cbProcArray;

  return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\critsect.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    critsect.c

Abstract:

    This module implements verification functions for 
    critical section interfaces.

Author:

    Daniel Mihai (DMihai) 27-Mar-2001

Revision History:

--*/

#include "pch.h"

#include "verifier.h"
#include "critsect.h"
#include "support.h"
#include "deadlock.h"
#include "logging.h"


//
// Ntdll functions declarations.
//

VOID
RtlpWaitForCriticalSection (
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

//
// The root of our critical section splay tree, ordered by
// the address of the critical sections.
//

PRTL_SPLAY_LINKS CritSectSplayRoot = NULL;

//
// Global lock protecting the access to our splay tree.
//
// N.B.
//
// WE CANNOT HOLD THIS LOCK AND CALL ANY API THAT WILL
// TRY TRY TO AQUIRE ANOTHER LOCK (e.g. RtlAllocateHeap)
// BECAUSE THE FUNCTIONS BELOW CAN BE CALLED WITH THAT OTHER
// LOCK HELD BY ANOTHER THREAD AND WE WILL DEADLOCK.
// 

RTL_CRITICAL_SECTION CriticalSectionLock;
BOOL CriticalSectionLockInitialized = FALSE;


NTSTATUS
CritSectInitialize (
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = RtlInitializeCriticalSectionAndSpinCount (&CriticalSectionLock,
                                                       0x80000000);

    if (NT_SUCCESS (Status)) {

        CriticalSectionLockInitialized = TRUE;
    }

    return Status;
}


VOID
CritSectUninitialize (
    VOID
    )
{
    if (CriticalSectionLockInitialized) {

        RtlDeleteCriticalSection (&CriticalSectionLock);
        CriticalSectionLockInitialized = FALSE;
    }
}


VOID
AVrfpVerifyCriticalSectionOwner (
    volatile RTL_CRITICAL_SECTION *CriticalSection,
    BOOL VerifyCountOwnedByThread
    )
{
    HANDLE CurrentThread;
    PAVRF_TLS_STRUCT TlsStruct;

    //
    // Verify that the CS is locked.
    //

    if (CriticalSection->LockCount < 0) {

        //
        // The CS is not locked
        //

        VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_OVER_RELEASED | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                       "critical section over-released or corrupted",
                       CriticalSection, "Critical section address",
                       CriticalSection->LockCount, "Lock count", 
                       0, "Expected minimum lock count", 
                       CriticalSection->DebugInfo, "Critical section debug info address");
    }

    //
    // Verify that the current thread owns the CS.
    //

    CurrentThread = NtCurrentTeb()->ClientId.UniqueThread;

    if (CriticalSection->OwningThread != CurrentThread) {

        VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_INVALID_OWNER | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                       "invalid critical section owner thread",
                       CriticalSection, "Critical section address",
                       CriticalSection->OwningThread, "Owning thread", 
                       CurrentThread, "Expected owning thread", 
                       CriticalSection->DebugInfo, "Critical section debug info address");
    }

    //
    // Verify the recursion count.
    //
    // ntdll\ia64\critsect.s is using RecursionCount = 0 first time
    // the current thread is acquiring the CS.
    //
    // ntdll\i386\critsect.asm is using RecursionCount = 1 first time
    // the current thread is acquiring the CS.
    //
    
    
#if defined(_IA64_)
    
    if (CriticalSection->RecursionCount < 0) {
        VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_INVALID_RECURSION_COUNT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                       "invalid critical section recursion count",
                       CriticalSection, "Critical section address",
                       CriticalSection->RecursionCount, "Recursion count", 
                       0, "Expected minimum recursion count", 
                       CriticalSection->DebugInfo, "Critical section debug info address");
    }

#else //#if defined(_IA64_)

    if (CriticalSection->RecursionCount < 1) {
        VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_INVALID_RECURSION_COUNT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                       "invalid critical section recursion count",
                       CriticalSection, "Critical section address",
                       CriticalSection->RecursionCount, "Recursion count", 
                       1, "Expected minimum recursion count", 
                       CriticalSection->DebugInfo, "Critical section debug info address");
    }
#endif //#if defined(_IA64_)

    if (VerifyCountOwnedByThread != FALSE) {

        //
        // Verify that the current thread owns at least one critical section.
        //

        TlsStruct = AVrfpGetVerifierTlsValue();

        if (TlsStruct != NULL && TlsStruct->CountOfOwnedCriticalSections <= 0) {

            VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_OVER_RELEASED | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                           "critical section over-released or corrupted",
                           TlsStruct->CountOfOwnedCriticalSections, "Number of critical sections owned by curent thread.",
                           NULL, "", 
                           NULL, "", 
                           NULL, "");
        }
    }
}


VOID
AVrfpDumpCritSectTreeRecursion( 
    PRTL_SPLAY_LINKS Root,
    ULONG RecursionLevel
    )
{
    ULONG RecursionCount;
    PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;

    for (RecursionCount = 0; RecursionCount < RecursionLevel; RecursionCount += 1) {

        DbgPrint (" ");
    }

    CritSectSplayNode = CONTAINING_RECORD (Root,
                                           CRITICAL_SECTION_SPLAY_NODE,
                                           SplayLinks);

    DbgPrint ("%p (CS = %p, DebugInfo = %p), left %p, right %p, parent %p\n",
              Root,
              CritSectSplayNode->CriticalSection,
              CritSectSplayNode->DebugInfo,
              Root->LeftChild,
              Root->RightChild,
              Root->Parent);

    if (Root->LeftChild != NULL) {

        AVrfpDumpCritSectTreeRecursion (Root->LeftChild,
                                        RecursionLevel + 1 );
    }

    if (Root->RightChild != NULL) {

        AVrfpDumpCritSectTreeRecursion (Root->RightChild,
                                        RecursionLevel + 1 );
    }
}


VOID
AVrfpDumpCritSectTree(
    )
{
    //
    // N.B. 
    //
    // This code is dangerous because we are calling DbgPrint
    // with CriticalSectionLock held. If DbgPrint is using
    // the heap internally it might need the heap lock
    // which might be help by another thread waiting for CriticalSectionLock.
    // We are going to use this function only in desperate cases
    // for debugging verifier issues with the CS tree.
    //

    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOCKS_VERIFIER) != 0) {

        AVrfpVerifyCriticalSectionOwner (&CriticalSectionLock,
                                         FALSE);

        if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOCKS_DUMP_TREE) != 0) {

            DbgPrint ("================================================\n"
                      "Critical section tree root = %p\n",
                      CritSectSplayRoot);

            if (CritSectSplayRoot != NULL) {

                AVrfpDumpCritSectTreeRecursion( CritSectSplayRoot,
                                                0 );
            }

            DbgPrint ("================================================\n");
        }
    }
}


NTSTATUS
AVrfpInsertCritSectInSplayTree (
    PRTL_CRITICAL_SECTION CriticalSection
    )
{
    PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;
    PCRITICAL_SECTION_SPLAY_NODE NewCritSectSplayNode;
    PRTL_SPLAY_LINKS Parent;
    NTSTATUS Status;

    ASSERT (CriticalSection->DebugInfo != NULL);

    Status = STATUS_SUCCESS;

    NewCritSectSplayNode = NULL;

    //
    // The caller must be the owner of the splay tree lock.
    //

    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOCKS_VERIFIER) != 0) {

        AVrfpVerifyCriticalSectionOwner (&CriticalSectionLock,
                                         FALSE);

        DbgPrint ("\n\nAVrfpInsertCritSectInSplayTree( %p )\n",
                  CriticalSection);

        AVrfpDumpCritSectTree ();
    }

    //
    // Allocate a new node.
    //
    // N.B. 
    //
    // We need to drop CriticalSectionLock while using the heap.
    // Otherwise we might deadlock. This also means that another thread
    // might come along and initialize this critical section again.
    // We don;t expect this to happen often and we will detect this 
    // only later on, in ntdll!RtlCheckForOrphanedCriticalSections.
    //

    RtlLeaveCriticalSection (&CriticalSectionLock);

    try {

        NewCritSectSplayNode = AVrfpAllocate (sizeof (*NewCritSectSplayNode));
    }
    finally {

        RtlEnterCriticalSection (&CriticalSectionLock);
    }


    if (NewCritSectSplayNode == NULL) {

        Status = STATUS_NO_MEMORY;
    }
    else {

        //
        // Initialize the data members of the node structure.
        //

        NewCritSectSplayNode->CriticalSection = CriticalSection;
        NewCritSectSplayNode->DebugInfo = CriticalSection->DebugInfo;

        //
        // Insert the node in the tree.
        //

        ZeroMemory( &NewCritSectSplayNode->SplayLinks,
                    sizeof(NewCritSectSplayNode->SplayLinks));


        //
        // If the tree is currently empty set the new node as root.
        //

        if (CritSectSplayRoot == NULL) {

            NewCritSectSplayNode->SplayLinks.Parent = &NewCritSectSplayNode->SplayLinks;

            CritSectSplayRoot = &NewCritSectSplayNode->SplayLinks;
        }
        else {

            //
            // Search for the right place to insert our CS in the tree.
            //

            Parent = CritSectSplayRoot;

            while (TRUE) {

                CritSectSplayNode = CONTAINING_RECORD (Parent,
                                                       CRITICAL_SECTION_SPLAY_NODE,
                                                       SplayLinks);

                if (CriticalSection < CritSectSplayNode->CriticalSection) {

                    //
                    // Starting address of the virtual address descriptor is less
                    // than the parent starting virtual address.
                    // Follow left child link if not null. Otherwise 
                    // return from the function - we didn't find the CS.
                    //

                    if (Parent->LeftChild) {

                        Parent = Parent->LeftChild;
                    } 
                    else {

                        //
                        // Insert the node here.
                        //

                        RtlInsertAsLeftChild (Parent,
                                              NewCritSectSplayNode);  
                        break;
                    }
                } 
                else {

                    //
                    // Starting address of the virtual address descriptor is greater
                    // than the parent starting virtual address.
                    // Follow right child link if not null. Otherwise 
                    // return from the function - we didn't find the CS.
                    //

                    if (Parent->RightChild) {

                        Parent = Parent->RightChild;
                    } 
                    else {

                        //
                        // Insert the node here.
                        //
                        
                        RtlInsertAsRightChild (Parent,
                                               NewCritSectSplayNode);  

                        break;
                    }
                }
            }

            CritSectSplayRoot = RtlSplay( CritSectSplayRoot );
        }
    }

    return Status;
}


PCRITICAL_SECTION_SPLAY_NODE
AVrfpFindCritSectInSplayTree (
    PRTL_CRITICAL_SECTION CriticalSection
    )
{
    PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;
    PCRITICAL_SECTION_SPLAY_NODE FoundNode;
    PRTL_SPLAY_LINKS Parent;

    FoundNode = NULL;

    //
    // The caller must be the owner of the splay tree lock.
    //

    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOCKS_VERIFIER) != 0) {

        AVrfpVerifyCriticalSectionOwner (&CriticalSectionLock,
                                         FALSE);

        DbgPrint ("\n\nAVrfpFindCritSectInSplayTree( %p )\n",
                  CriticalSection);

        AVrfpDumpCritSectTree ();
    }

    if (CritSectSplayRoot == NULL) {

        goto Done;
    }

    //
    // Search for our CS in the tree.
    //

    Parent = CritSectSplayRoot;

    while (TRUE) {

        CritSectSplayNode = CONTAINING_RECORD (Parent,
                                               CRITICAL_SECTION_SPLAY_NODE,
                                               SplayLinks);

        if (CriticalSection == CritSectSplayNode->CriticalSection) {

            //
            // Found it.
            //

            FoundNode = CritSectSplayNode;
            break;
        }
        else if (CriticalSection < CritSectSplayNode->CriticalSection) {

            //
            // Starting address of the virtual address descriptor is less
            // than the parent starting virtual address.
            // Follow left child link if not null. Otherwise 
            // return from the function - we didn't find the CS.
            //

            if (Parent->LeftChild) {

                Parent = Parent->LeftChild;
            } 
            else {

                break;
            }
        } 
        else {

            //
            // Starting address of the virtual address descriptor is greater
            // than the parent starting virtual address.
            // Follow right child link if not null. Otherwise 
            // return from the function - we didn't find the CS.
            //

            if (Parent->RightChild) {

                Parent = Parent->RightChild;
            } 
            else {

                break;
            }
        }
    }

Done:

    return FoundNode;
}


VOID
AVrfpDeleteCritSectFromSplayTree (
    PRTL_CRITICAL_SECTION CriticalSection
    )
{
	PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;

    //
    // The caller must be the owner of the splay tree lock.
    //

    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOCKS_VERIFIER) != 0) {

        AVrfpVerifyCriticalSectionOwner (&CriticalSectionLock,
                                         FALSE);

        DbgPrint ("\n\nAVrfpDeleteCritSectFromSplayTree( %p )\n",
                  CriticalSection);

        AVrfpDumpCritSectTree ();
    }

    //
    // Find the critical section in the tree and delete it.
    //

    CritSectSplayNode = AVrfpFindCritSectInSplayTree (CriticalSection);

    if (CritSectSplayNode != NULL) {

        CritSectSplayRoot = RtlDelete (&CritSectSplayNode->SplayLinks);

        // N.B. 
        //
        // We need to drop CriticalSectionLock while using the heap.
        // Otherwise we might deadlock. This also means that another thread
        // might come along and initialize this critical section again.
        // We don;t expect this to happen often and we will detect this 
        // only later on, in ntdll!RtlCheckForOrphanedCriticalSections.
        //

        RtlLeaveCriticalSection (&CriticalSectionLock);

        try {

            AVrfpFree (CritSectSplayNode);
        }
        finally {

            RtlEnterCriticalSection (&CriticalSectionLock );
        }
    }
    else {

        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) != 0 &&
            RtlDllShutdownInProgress() == FALSE ) {

                VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_NOT_INITIALIZED | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "critical section not initialized",
                               CriticalSection, "Critical section address",
                               CriticalSection->DebugInfo, "Critical section debug info address", 
                               NULL, "", 
                               NULL, "");
        }
    }
}


PCRITICAL_SECTION_SPLAY_NODE
AVrfpVerifyInitializedCriticalSection (
    volatile RTL_CRITICAL_SECTION *CriticalSection
    )
{
    PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;

    CritSectSplayNode = NULL;

    //
    // Sanity test for DebugInfo.
    //

    if (CriticalSection->DebugInfo == NULL) {

        //
        // This CS is not initialized.
        //

        VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_NOT_INITIALIZED | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                       "critical section not initialized",
                       CriticalSection, "Critical section address",
                       CriticalSection->DebugInfo, "Critical section debug info address", 
                       NULL, "", 
                       NULL, "");
    }
    else if (CriticalSection != NtCurrentPeb()->LoaderLock) {

        //
        // The loader lock is not in our tree because it is initialized in ntdll
        // but is exposed via the pointer in the PEB so various pieces of code 
        // are (ab)using it...
        //

	    //
	    // Grab the CS splay tree lock.
	    //

	    RtlEnterCriticalSection (&CriticalSectionLock );

	    try {

            //
            // If the CS was initialized it should be in our tree.
            //

            CritSectSplayNode = AVrfpFindCritSectInSplayTree ((PRTL_CRITICAL_SECTION)CriticalSection);

            if (CritSectSplayNode == NULL) {

                //
                // This CS is not initialized.
                //

                VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_NOT_INITIALIZED | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "critical section not initialized",
                               CriticalSection, "Critical section address",
                               CriticalSection->DebugInfo, "Critical section debug info address", 
                               NULL, "", 
                               NULL, "");
            }
        }
        finally {

            //
            // Release the CS splay tree lock.
            //

            RtlLeaveCriticalSection( &CriticalSectionLock );
        }
    }

    return CritSectSplayNode;
}


VOID
AVrfpVerifyInitializedCriticalSection2 (
    volatile RTL_CRITICAL_SECTION *CriticalSection
    )
{
    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) != 0 &&
        RtlDllShutdownInProgress() == FALSE ) {

        //
        // Grab the CS splay tree lock.
        //

        RtlEnterCriticalSection( &CriticalSectionLock );

        try	{

            //
            // Verify that the CS was initialized.
            //

            AVrfpVerifyInitializedCriticalSection (CriticalSection);
        }
        finally {

            //
            // Release the CS splay tree lock.
            //

            RtlLeaveCriticalSection( &CriticalSectionLock );
        }
    }
}


VOID
AVrfpVerifyNoWaitersCriticalSection (
    volatile RTL_CRITICAL_SECTION *CriticalSection
    )
{
    PAVRF_TLS_STRUCT TlsStruct;
    PTEB Teb;

    Teb = NtCurrentTeb();

    //
    // Verify that no thread owns or waits for this CS or
    // the owner is the current thread. 
    //
    // ntdll\ia64\critsect.s is using RecursionCount = 0 first time
    // the current thread is acquiring the CS.
    //
    // ntdll\i386\critsect.asm is using RecursionCount = 1 first time
    // the current thread is acquiring the CS.
    //

    if (CriticalSection->LockCount != -1)
    {
        if (CriticalSection->OwningThread != Teb->ClientId.UniqueThread ||
#if defined(_WIN64)
            CriticalSection->RecursionCount < 0) {
#else
            CriticalSection->RecursionCount < 1) {
#endif //#if defined(_IA64_)

            VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_INVALID_LOCK_COUNT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                        "deleting critical section with invalid lock count",
                        CriticalSection, "Critical section address",
                        CriticalSection->LockCount, "Lock count", 
                        -1, "Expected lock count", 
                        CriticalSection->OwningThread, "Owning thread");
        }
        else
        {
            //
            // Deleting CS currently owned by the current thread.
            // Unfortunately we have to allow this because various
            // components have beein doing it for years.
            //

            AVrfpIncrementOwnedCriticalSections (-1);

            //
            // For debugging purposes, keep the address of the critical section deleted while
            // its LockCount was incorrect. Teb->CountOfOwnedCriticalSections might be left > 0 
            // although no critical section is owned by the current thread in this case.
            //

            TlsStruct = AVrfpGetVerifierTlsValue();

            if (TlsStruct != NULL) {

                TlsStruct->IgnoredIncorrectDeleteCS = (PRTL_CRITICAL_SECTION)CriticalSection;
            }
        }
    }

}

VOID 
AVrfpFreeMemLockChecks (
    VERIFIER_DLL_FREEMEM_TYPE FreeMemType,
    PVOID StartAddress,
    SIZE_T RegionSize,
    PWSTR UnloadedDllName
    )
{
    PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;
    PRTL_SPLAY_LINKS Parent;
    PVOID TraceAddress = NULL;

    //
    // Check for leaked critical sections in this memory range.
    //

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) != 0 &&
        RtlDllShutdownInProgress() == FALSE ) {
	
        //
        // Grab the CS tree lock.
        //

        RtlEnterCriticalSection( &CriticalSectionLock );

        //
        // Search the CS tree.
        //

        try {

            if (CritSectSplayRoot != NULL) {

                //
                // Look in the splay tree for any critical sections 
                // that might live in the memory range that isbeing deleted.
                //

                Parent = CritSectSplayRoot;

                while (TRUE) {

                    CritSectSplayNode = CONTAINING_RECORD (Parent,
                                                           CRITICAL_SECTION_SPLAY_NODE,
                                                           SplayLinks);

                    if ( (PCHAR)CritSectSplayNode->CriticalSection >= (PCHAR)StartAddress &&
                         (PCHAR)CritSectSplayNode->CriticalSection <  (PCHAR)StartAddress + RegionSize) {

                        //
                        // Found a CS that is about to be leaked.
                        //

                        if (AVrfpGetStackTraceAddress != NULL) {

					        TraceAddress = AVrfpGetStackTraceAddress (
                                CritSectSplayNode->DebugInfo->CreatorBackTraceIndex);
                        }
                        else {

                            TraceAddress = NULL;
                        }

                        switch (FreeMemType) {

                        case VerifierFreeMemTypeFreeHeap:

                            //
                            // We are releasing a heap block that contains this CS
                            //

                            VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_IN_FREED_HEAP | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                           "releasing heap allocation containing active critical section",
                                           CritSectSplayNode->CriticalSection, "Critical section address",
                                           TraceAddress, "Initialization stack trace. Use dds to dump it if non-NULL.",
                                           StartAddress, "Heap block address",
                                           RegionSize, "Heap block size" );

                            break;

                        case VerifierFreeMemTypeVirtualFree:

                            //
                            // We are releasing a virtual memory that contains this CS
                            //

                            VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_IN_FREED_MEMORY | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                           "releasing virtual memory containing active critical section",
                                           CritSectSplayNode->CriticalSection, "Critical section address",
                                           TraceAddress, "Initialization stack trace. Use dds to dump it if non-NULL.",
                                           StartAddress, "Memory block address",
                                           RegionSize, "Memory block size");

                            break;

                        case VerifierFreeMemTypeUnloadDll:

                            ASSERT (UnloadedDllName != NULL);

                            //
                            // We are unloading a DLL that contained this CS
                            //

                            VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_IN_UNLOADED_DLL | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                           "unloading dll containing active critical section",
                                           CritSectSplayNode->CriticalSection, "Critical section address",
                                           TraceAddress, "Initialization stack trace. Use dds to dump it if non-NULL.",
                                           UnloadedDllName, "DLL name address. Use du to dump it.",
                                           StartAddress, "DLL base address");

                            break;

                        case VerifierFreeMemTypeUnmap:

                            //
                            // We are unmapping memory that contains this CS
                            //

                            VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_IN_FREED_MEMORY | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                           "Unmapping memory region containing active critical section",
                                           CritSectSplayNode->CriticalSection, "Critical section address",
                                           TraceAddress, "Initialization stack trace. Use dds to dump it if non-NULL.",
                                           StartAddress, "Memory block address",
                                           RegionSize, "Memory block size" );
                            break;

                        default:

                            ASSERT (FALSE);
                        }

                        //
                        // Try to find other leaked critical sections only 
                        // with address greater than the current one 
                        // (only in the right subtree).
                        //

                        if (Parent->RightChild) {

                            Parent = Parent->RightChild;
                        }
                        else {

                            break;
                        }
                    }
                    else if ((PCHAR)StartAddress < (PCHAR)CritSectSplayNode->CriticalSection) {

                        //
                        // Starting address of the virtual address descriptor is less
                        // than the parent starting virtual address.
                        // Follow left child link if not null. Otherwise 
                        // return from the function - we didn't find the CS.
                        //

                        if (Parent->LeftChild) {

                            Parent = Parent->LeftChild;
                        } 
                        else {

                            break;
                        }
                    } 
                    else {

                        //
                        // Starting address of the virtual address descriptor is greater
                        // than the parent starting virtual address.
                        // Follow right child link if not null. Otherwise 
                        // return from the function - we didn't find the CS.
                        //

                        if (Parent->RightChild) {

                            Parent = Parent->RightChild;
                        } 
                        else {

                            break;
                        }
                    }
                }
            }
        }
        finally {

	        //
	        // Release the CS splay tree lock.
	        //

	        RtlLeaveCriticalSection( &CriticalSectionLock );
        }
	}
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//NTSYSAPI
BOOL
NTAPI
AVrfpRtlTryEnterCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    )
{
    BOOL Result;
    HANDLE CurrentThread;
    LONG LockCount;
    PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;
    PTEB Teb;
    BOOL AlreadyOwner;

    Teb = NtCurrentTeb();

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) != 0 &&
        RtlDllShutdownInProgress() == FALSE ) {

        CurrentThread = Teb->ClientId.UniqueThread;

        //
        // Verify that the CS was initialized.
        //

        CritSectSplayNode = AVrfpVerifyInitializedCriticalSection (CriticalSection);

        if (CritSectSplayNode != NULL)
        {
            InterlockedExchangePointer (&CritSectSplayNode->TryEnterThread,
                                        (PVOID)CurrentThread);
        }

        //
        // The TryEnterCriticalSection algorithm starts here.
        //

        LockCount = InterlockedCompareExchange( &CriticalSection->LockCount,
                                                0,
                                                -1 );
        if (LockCount == -1) {

            //
            // The CS was unowned and we just acquired it
            //

            //
            // Sanity test for the OwningThread.
            //

            if (CriticalSection->OwningThread != 0) {

                //
                // The loader lock gets handled differently, so don't assert on it.
                //

                if (CriticalSection != NtCurrentPeb()->LoaderLock ||
                    CriticalSection->OwningThread != CurrentThread) {

                    //
                    // OwningThread should have been 0.
                    //

                    VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_INVALID_OWNER | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                   "invalid critical section owner thread",
                                   CriticalSection, "Critical section address",
                                   CriticalSection->OwningThread, "Owning thread", 
                                   0, "Expected owning thread", 
                                   CriticalSection->DebugInfo, "Critical section debug info address");
                }
            }

            //
            // Sanity test for the RecursionCount.
            //

            if (CriticalSection->RecursionCount != 0) {

                //
                // The loader lock gets handled differently, so don't assert on it.
                //

                if (CriticalSection != NtCurrentPeb()->LoaderLock) {

                    //
                    // RecursionCount should have been 0.
                    //

                    VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_INVALID_RECURSION_COUNT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                   "invalid critical section recursion count",
                                   CriticalSection, "Critical section address",
                                   CriticalSection->RecursionCount, "Recursion count", 
                                   0, "Expected recursion count", 
                                   CriticalSection->DebugInfo, "Critical section debug info address");
                }
            }

            //
            // Set the CS owner
            //

            CriticalSection->OwningThread = CurrentThread;

            //
            // Set the recursion count
            //
            // ntdll\ia64\critsect.s is using RecursionCount = 0 first time
            // the current thread is acquiring the critical section.
            //
            // ntdll\i386\critsect.asm is using RecursionCount = 1 first time
            // the current thread is acquiring the critical section.
            //

#if defined(_IA64_)
            CriticalSection->RecursionCount = 0;
#else //#if defined(_IA64_)
            CriticalSection->RecursionCount = 1;
#endif
    
            AVrfpIncrementOwnedCriticalSections (1);

            //
            // We are updating this counter on all platforms, 
            // unlike the ntdll code that does this only on x86 chk.
            // We need the updated counter in the TEB to speed up 
            // ntdll!RtlCheckHeldCriticalSections.
            // 

            Teb->CountOfOwnedCriticalSections += 1;

            //
            // All done, CriticalSection is owned by the current thread.
            //

            Result = TRUE;
        }
        else {

            //
            // The CS is currently owned by the current or another thread.
            //

            if (CriticalSection->OwningThread == CurrentThread) {

                //
                // The current thread is already the owner.
                //

                //
                // Interlock increment the LockCount, and increment the RecursionCount.
                //

                InterlockedIncrement (&CriticalSection->LockCount);

                CriticalSection->RecursionCount += 1;

                //
                // All done, CriticalSection was already owned by 
                // the current thread and we have just incremented the RecursionCount.
                //

                Result = TRUE;
            }
            else {

                //
                // Another thread is the owner of this CS.
                //

                Result = FALSE;
            }
        }
    }
    else {

        //
        // The CS verifier is not enabled
        //

        Result = RtlTryEnterCriticalSection (CriticalSection);

        if (Result != FALSE) {

#if defined(_IA64_)
            AlreadyOwner = (CriticalSection->RecursionCount > 0);
#else
            AlreadyOwner = (CriticalSection->RecursionCount > 1);
#endif //#if defined(_IA64_)

            if (AlreadyOwner == FALSE) {

                AVrfpIncrementOwnedCriticalSections (1);

#if !DBG || !defined (_X86_)
                //
                // We are updating this counter on all platforms, 
                // unlike the ntdll code that does this only on x86 chk.
                // We need the updated counter in the TEB to speed up 
                // ntdll!RtlCheckHeldCriticalSections.
                // 

                Teb->CountOfOwnedCriticalSections += 1;
#endif //#if !DBG || !defined (_X86_)
            }
        }
    }

    if (Result != FALSE) {
       
        //
        // Tell deadlock verifier that the lock has been acquired.
        //

        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_DEADLOCK_CHECKS) != 0) {

            AVrfDeadlockResourceAcquire (CriticalSection,
                                          _ReturnAddress(),
                                          TRUE);
        }
        
        //
        // We will introduce a random delay
        // in order to randomize the timings in the process.
        //

        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RACE_CHECKS)) {
            AVrfpCreateRandomDelay ();
        }
    }

    return Result;
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlEnterCriticalSection(
    volatile RTL_CRITICAL_SECTION *CriticalSection
    )
{
    NTSTATUS Status;
    HANDLE CurrentThread;
    LONG LockCount;
    ULONG_PTR SpinCount;
    PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;
    PTEB Teb;
    BOOL AlreadyOwner;

    Teb = NtCurrentTeb();

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) != 0 &&
        RtlDllShutdownInProgress() == FALSE ) {

        CurrentThread = Teb->ClientId.UniqueThread;

        //
        // Verify that the CS was initialized.
        //

        CritSectSplayNode = AVrfpVerifyInitializedCriticalSection (CriticalSection);

        if (CritSectSplayNode != NULL)
        {
            InterlockedExchangePointer (&CritSectSplayNode->EnterThread,
                                        (PVOID)CurrentThread);
        }

        //
        // The EnterCriticalSection algorithm starts here.
        //

        Status = STATUS_SUCCESS;

        SpinCount = CriticalSection->SpinCount;

        if (SpinCount == 0) {

            //
            // Zero spincount for this CS.
            //

EnterZeroSpinCount:

            LockCount = InterlockedIncrement (&CriticalSection->LockCount);

            if (LockCount == 0) {

EnterSetOwnerAndRecursion:
        
                //
                // The current thread is the new owner of the CS.
                //

                //
                // Sanity test for the OwningThread.
                //

                if (CriticalSection->OwningThread != 0) {

                    //
                    // The loader lock gets handled differently, so don't assert on it.
                    //

                    if (CriticalSection != NtCurrentPeb()->LoaderLock ||
                        CriticalSection->OwningThread != CurrentThread) {

                        //
                        // OwningThread should have been 0.
                        //

                        VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_INVALID_OWNER | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                       "invalid critical section owner thread",
                                       CriticalSection, "Critical section address",
                                       CriticalSection->OwningThread, "Owning thread", 
                                       0, "Expected owning thread", 
                                       CriticalSection->DebugInfo, "Critical section debug info address");
                    }
                }

                //
                // Sanity test for the RecursionCount.
                //

                if (CriticalSection->RecursionCount != 0) {

                    //
                    // The loader lock gets handled differently, so don't assert on it.
                    //

                    if (CriticalSection != NtCurrentPeb()->LoaderLock) {

                        //
                        // RecursionCount should have been 0.
                        //

                        VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_INVALID_RECURSION_COUNT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                       "invalid critical section recursion count",
                                       CriticalSection, "Critical section address",
                                       CriticalSection->RecursionCount, "Recursion count", 
                                       0, "Expected recursion count", 
                                       CriticalSection->DebugInfo, "Critical section debug info address");
                    }
                }

                //
                // Set the CS owner
                //

                CriticalSection->OwningThread = CurrentThread;

                //
                // Set the recursion count
                //
                // ntdll\ia64\critsect.s is using RecursionCount = 0 first time
                // the current thread is acquiring the CS.
                //
                // ntdll\i386\critsect.asm is using RecursionCount = 1 first time
                // the current thread is acquiring the CS.
                //

#if defined(_IA64_)
                CriticalSection->RecursionCount = 0;
#else //#if defined(_IA64_)
                CriticalSection->RecursionCount = 1;
#endif
        
                AVrfpIncrementOwnedCriticalSections (1);

                //
                // We are updating this counter on all platforms, 
                // unlike the ntdll code that does this only on x86 chk.
                // We need the updated counter in the TEB to speed up 
                // ntdll!RtlCheckHeldCriticalSections.
                // 

                Teb->CountOfOwnedCriticalSections += 1;

#if DBG && defined (_X86_)
                CriticalSection->DebugInfo->EntryCount += 1;
#endif

                //
                // All done, CriticalSection is owned by the current thread.
                //
            }
            else if (LockCount > 0) {

                //
                // The CS is currently owned by the current or another thread.
                //

                if (CriticalSection->OwningThread == CurrentThread) {

                    //
                    // The current thread is already the owner.
                    //

                    CriticalSection->RecursionCount += 1;

#if DBG && defined (_X86_)
                    //
                    // In a chk build we are updating this additional counter, 
                    // just like the original function in ntdll does.
                    // 

                    CriticalSection->DebugInfo->EntryCount += 1;
#endif

                    //
                    // All done, CriticalSection was already owned by 
                    // the current thread and we have just incremented the RecursionCount.
                    //
                }
                else {

                    //
                    // The current thread is not the owner. Wait for ownership
                    //

                    if (CritSectSplayNode != NULL)
                    {
                        InterlockedExchangePointer (&CritSectSplayNode->WaitThread,
                                                    (PVOID)CurrentThread);
                    }

                    RtlpWaitForCriticalSection ((PRTL_CRITICAL_SECTION)CriticalSection);

                    if (CritSectSplayNode != NULL)
                    {
                        InterlockedExchangePointer (&CritSectSplayNode->WaitThread,
                                                    (PVOID)( (ULONG_PTR)CurrentThread | 0x1 ));
                    }

                    //
                    // We have just aquired the CS.
                    //

                    goto EnterSetOwnerAndRecursion;
                }
            }
            else {

                //
                // The original LockCount was < -1 so the CS was 
                // over-released or corrupted.
                //

                VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_OVER_RELEASED | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "critical section over-released or corrupted",
                               CriticalSection, "Critical section address",
                               CriticalSection->LockCount, "Lock count", 
                               0, "Expected minimum lock count", 
                               CriticalSection->DebugInfo, "Critical section debug info address");
            }
        }
        else {

            //
            // SpinCount > 0 for this CS
            //

            if( CriticalSection->OwningThread == CurrentThread ) {

                //
                // The current thread is already the owner.
                //

                InterlockedIncrement( &CriticalSection->LockCount );

                CriticalSection->RecursionCount += 1;

#if DBG && defined (_X86_)
                //
                // In a chk build we are updating this additional counter, 
                // just like the original function in ntdll does.
                // 

                CriticalSection->DebugInfo->EntryCount += 1;
#endif

                //
                // All done, CriticalSection was already owned by the current thread 
                // and we have just incremented the LockCount and RecursionCount.
                //
            }
            else {

                //
                // The current thread is not the owner. Attempt to acquire.
                //

EnterTryAcquire:

                LockCount = InterlockedCompareExchange( &CriticalSection->LockCount,
                                                        0,
                                                        -1 );

                if (LockCount == -1) {

                    //
                    // We have just aquired the CS.
                    //

                    goto EnterSetOwnerAndRecursion;
                }
                else {

                    //
                    // Look if there are already other threads spinning while
                    // waiting for this CS.
                    //

                    if (CriticalSection->LockCount >= 1) {

                        //
                        // There are other waiters for this CS.
                        // Do not spin, just wait for the CS to be
                        // released as if we had 0 spin count from the beginning.
                        // 

                        goto EnterZeroSpinCount;
                    }
                    else {

                        //
                        // No other threads are waiting for this CS.
                        //

EnterSpinOnLockCount:

                        if (CriticalSection->LockCount == -1) {

                            //
                            // We have a chance for aquiring it now
                            //

                            goto EnterTryAcquire;
                        }
                        else {

                            //
                            // The CS is still owned. 
                            // Decrement the spin count and decide if we should continue
                            // to spin or simply wait for the CS's event.
                            //

                            SpinCount -= 1;

                            if (SpinCount > 0) {

                                //
                                // Spin
                                //

                                goto EnterSpinOnLockCount;
                            }
                            else {

                                //
                                // Spun enough, just wait for the CS to be
                                // released as if we had 0 spin count from the beginning.
                                //

                                goto EnterZeroSpinCount;
                            }
                        }
                    }
                }
            }
        }
    }
    else {

        //
        // The CS verifier is not enabled
        //

        Status = RtlEnterCriticalSection ((PRTL_CRITICAL_SECTION)CriticalSection);
    
        if (NT_SUCCESS(Status)) {

#if defined(_IA64_)
            AlreadyOwner = (CriticalSection->RecursionCount > 0);
#else
            AlreadyOwner = (CriticalSection->RecursionCount > 1);
#endif //#if defined(_IA64_)

            if (AlreadyOwner == FALSE) {

                AVrfpIncrementOwnedCriticalSections (1);

#if !DBG || !defined (_X86_)
                //
                // We are updating this counter on all platforms, 
                // unlike the ntdll code that does this only on x86 chk.
                // We need the updated counter in the TEB to speed up 
                // ntdll!RtlCheckHeldCriticalSections.
                // 

                Teb->CountOfOwnedCriticalSections += 1;
#endif  //#if !DBG || !defined (_X86_)
            }
        }
    }

    if (NT_SUCCESS (Status)) {
        
        //
        // Tell deadlock verifier that the lock has been acquired.
        //

        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_DEADLOCK_CHECKS) != 0) {

            AVrfDeadlockResourceAcquire ((PVOID)CriticalSection,
                                         _ReturnAddress(),
                                         FALSE);
        }
        
        //
        // We will introduce a random delay
        // in order to randomize the timings in the process.
        //

        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RACE_CHECKS)) {
            AVrfpCreateRandomDelay ();
        }
    }

    return Status;
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlLeaveCriticalSection(
    volatile RTL_CRITICAL_SECTION *CriticalSection
    )
{
    NTSTATUS Status;
    PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;
    BOOL LeavingRecursion;

    //
    // Tell deadlock verifier that the lock has been released.
    // Note that we need to do this before the actual critical section
    // gets released since otherwise we get into race issues where some other
    // thread manages to enter/leave the critical section.
    //

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_DEADLOCK_CHECKS) != 0) {

        AVrfDeadlockResourceRelease ((PVOID)CriticalSection,
                                     _ReturnAddress());
    }

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) != 0 &&
        RtlDllShutdownInProgress() == FALSE) {

        //
        // Verify that the CS was initialized.
        //

        CritSectSplayNode = AVrfpVerifyInitializedCriticalSection (CriticalSection);

        if (CritSectSplayNode != NULL)
        {
            InterlockedExchangePointer (&CritSectSplayNode->LeaveThread,
                                        (PVOID)NtCurrentTeb()->ClientId.UniqueThread);

            //
            // Verify that the CS is owned by the the current thread.
            //

            AVrfpVerifyCriticalSectionOwner (CriticalSection,
                                            TRUE);
        }
    }

    //
    // We need to know if we are just leaving CS ownership recursion
    // because in that case we don't decrement Teb->CountOfOwnedCriticalSections.
    //
    // ntdll\ia64\critsect.s is using RecursionCount = 0 first time
    // the current thread is acquiring the CS.
    //
    // ntdll\i386\critsect.asm is using RecursionCount = 1 first time
    // the current thread is acquiring the CS.
    //
#if defined(_IA64_)
    LeavingRecursion = (CriticalSection->RecursionCount > 0);
#else
    LeavingRecursion = (CriticalSection->RecursionCount > 1);
#endif //#if defined(_IA64_)

    Status = RtlLeaveCriticalSection ((PRTL_CRITICAL_SECTION)CriticalSection);

    if (NT_SUCCESS (Status)) {
        

        if (LeavingRecursion == FALSE) {

            AVrfpIncrementOwnedCriticalSections (-1);

#if !DBG || !defined (_X86_)
            //
            // We are updating this counter on all platforms, 
            // unlike the ntdll code that does this only on x86 chk.
            // We need the updated counter in the TEB to speed up 
            // ntdll!RtlCheckHeldCriticalSections.
            // 

            NtCurrentTeb()->CountOfOwnedCriticalSections -= 1;
#endif //#if !DBG || !defined (_X86_)
        }
    }

    return Status;
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlInitializeCriticalSectionAndSpinCount(
    PRTL_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    )
{
    NTSTATUS Status;
	PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;
    PVOID TraceAddress;

    Status = STATUS_SUCCESS;

    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOCKS_INITIALIZE_DELETE) != 0) {

        DbgPrint ("AVrfpRtlInitializeCriticalSectionAndSpinCount (%p)\n",
                  CriticalSection);
    }

    //
    // We cannot use the CriticalSectionLock after shutdown started,
    // because the RTL critical sections stop working at that time.
    //

    if (RtlDllShutdownInProgress() == FALSE) {

        //
        // Grab the CS splay tree lock.
        //

        RtlEnterCriticalSection( &CriticalSectionLock );

        try {

            //
            // Check if the CS is already initialized.
            //

            CritSectSplayNode = AVrfpFindCritSectInSplayTree (CriticalSection);

            if (CritSectSplayNode != NULL &&
                (AVrfpProvider.VerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) != 0) {

                //
                // The caller is trying to reinitialize this CS.
                //

                if (AVrfpGetStackTraceAddress != NULL) {

                    TraceAddress = AVrfpGetStackTraceAddress (CritSectSplayNode->DebugInfo->CreatorBackTraceIndex);
                }
                else {

                    TraceAddress = NULL;
                }

                VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_ALREADY_INITIALIZED | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
			                   "reinitializing critical section",
			                   CritSectSplayNode->CriticalSection, "Critical section address",
			                   CritSectSplayNode->DebugInfo, "Critical section debug info address",
			                   TraceAddress, "First initialization stack trace. Use dds to dump it if non-NULL.",
			                   NULL, "" );
            }

            //
            // Call the regular CS initialization routine in ntdll.
            // This will allocate heap for the DebugInfo so we need to temporarily 
            // drop CriticalSectionLock, otherwise we can deadlock with the heap lock.
            //

            RtlLeaveCriticalSection (&CriticalSectionLock);

            try {

                Status = RtlInitializeCriticalSectionAndSpinCount (CriticalSection,
                                                                   SpinCount);
            }
            finally {

                RtlEnterCriticalSection (&CriticalSectionLock);
            }

            if (NT_SUCCESS (Status)) {

                //
                // Insert the CS in our splay tree.
                //

                Status = AVrfpInsertCritSectInSplayTree (CriticalSection);

                if (!NT_SUCCESS( Status )) {

                    //
                    // Undo the ntdll initialization. This will use the heap to free up
                    // the debug info so we need to temporarily drop CriticalSectionLock, 
                    // otherwise we can deadlock with the heap lock.
                    //

                    RtlLeaveCriticalSection (&CriticalSectionLock);

                    try {

                        RtlDeleteCriticalSection (CriticalSection);
                    }
                    finally {

                        RtlEnterCriticalSection (&CriticalSectionLock);
                    }
                }
            }
        }
        finally {

            //
            // Release the CS splay tree lock.
            //

            RtlLeaveCriticalSection( &CriticalSectionLock );
        }
    }
    else {

        Status = RtlInitializeCriticalSectionAndSpinCount (CriticalSection,
                                                           SpinCount);
    }

    //
    // Register the lock with deadlock verifier.
    //

    if (NT_SUCCESS(Status)) {

        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_DEADLOCK_CHECKS) != 0) {

            AVrfDeadlockResourceInitialize (CriticalSection,
                                             _ReturnAddress());
        }
    }

    return Status;
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlInitializeCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    )
{
	return AVrfpRtlInitializeCriticalSectionAndSpinCount (CriticalSection,
                                                          0);
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlDeleteCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    )
{
    NTSTATUS Status;
    PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;

    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOCKS_INITIALIZE_DELETE) != 0) {

        DbgPrint ("AVrfpRtlDeleteCriticalSection (%p)\n",
                  CriticalSection);
    }

    //
    // We cannot use the CriticalSectionLock after shutdown started,
    // because the RTL critical sections stop working at that time.
    //

    if (RtlDllShutdownInProgress() == FALSE) {

        //
        // Grab the CS splay tree lock.
        //

        RtlEnterCriticalSection( &CriticalSectionLock );

        try	{

            if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) != 0 &&
                RtlDllShutdownInProgress() == FALSE ) {

                //
                // Verify that the CS was initialized.
                //

                CritSectSplayNode = AVrfpVerifyInitializedCriticalSection (CriticalSection);

                if (CritSectSplayNode != NULL) {

                    //
                    // Verify that no thread owns or waits for this CS or
                    // the owner is the current thread. 
                    //

                    AVrfpVerifyNoWaitersCriticalSection (CriticalSection);
                }
            }

            //
            // Remove the critical section from our splay tree.
            //

            AVrfpDeleteCritSectFromSplayTree (CriticalSection);
        }
        finally {

            //
            // Release the CS splay tree lock.
            //

            RtlLeaveCriticalSection( &CriticalSectionLock );
        }
    }

    //
    // Regular ntdll CS deletion.
    //

    Status = RtlDeleteCriticalSection (CriticalSection);

    //
    // Deregister the lock from deadlock verifier structures.
    //

    if (NT_SUCCESS(Status)) {

        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_DEADLOCK_CHECKS) != 0) {

            AVrfDeadlockResourceDelete (CriticalSection,
                                        _ReturnAddress());
        }
    }

    return Status;
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
VOID
AVrfpRtlInitializeResource(
    IN PRTL_RESOURCE Resource
    )
{
    NTSTATUS Status;
	PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;
    PVOID TraceAddress;

    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOCKS_INITIALIZE_DELETE) != 0) {

        DbgPrint ("AVrfpRtlInitializeResource (%p), CS = %p\n",
                  Resource,
                  &Resource->CriticalSection);
    }

    //
    // We cannot use the CriticalSectionLock after shutdown started,
    // because the RTL critical sections stop working at that time.
    //

    if (RtlDllShutdownInProgress() == FALSE) {

        //
        // Grab the CS splay tree lock.
        //

        RtlEnterCriticalSection( &CriticalSectionLock );

        try	{

            //
            // Check if the CS is already initialized.
            //

            CritSectSplayNode = AVrfpFindCritSectInSplayTree (&Resource->CriticalSection);

            if (CritSectSplayNode != NULL &&
                (AVrfpProvider.VerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) != 0) {

	            //
	            // The caller is trying to reinitialize this CS.
	            //
	            
                if (AVrfpGetStackTraceAddress != NULL) {

                    TraceAddress = AVrfpGetStackTraceAddress (CritSectSplayNode->DebugInfo->CreatorBackTraceIndex);
                }
                else {

                    TraceAddress = NULL;
                }

                VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_ALREADY_INITIALIZED | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
			                   "reinitializing critical section",
			                   CritSectSplayNode->CriticalSection, "Critical section address",
			                   CritSectSplayNode->DebugInfo, "Critical section debug info address",
			                   TraceAddress, "First initialization stack trace. Use dds to dump it if non-NULL.",
			                   NULL, "" );

            }

            //
            // Call the regular CS initialization routine in ntdll.
            // This will allocate heap for the DebugInfo so we need to temporarily 
            // drop CriticalSectionLock, otherwise we can deadlock with the heap lock.
            //

            RtlLeaveCriticalSection (&CriticalSectionLock);

            try {

                RtlInitializeResource (Resource);
            }
            finally {

                RtlEnterCriticalSection (&CriticalSectionLock);
            }

            //
            // Insert the CS in our splay tree.
            //

            Status = AVrfpInsertCritSectInSplayTree (&Resource->CriticalSection);

            if (!NT_SUCCESS( Status )) {

                //
                // Undo the ntdll initialization. This will use the heap to free up
                // the debug info so we need to temporarily drop CriticalSectionLock, 
                // otherwise we can deadlock with the heap lock.
                //

                RtlLeaveCriticalSection (&CriticalSectionLock);

                try {

                    RtlDeleteResource (Resource);
                }
                finally {

                    RtlEnterCriticalSection (&CriticalSectionLock);
                }

                //
                // Raise an exception for failure case, just like ntdll does for resources.
                //

                RtlRaiseStatus(Status);
            }
        }
        finally {

            //
            // Release the CS splay tree lock.
            //

            RtlLeaveCriticalSection( &CriticalSectionLock );
        }
    }
    else {

        RtlInitializeResource (Resource);
    }
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
VOID
AVrfpRtlDeleteResource (
    IN PRTL_RESOURCE Resource
    )
{
    PRTL_CRITICAL_SECTION CriticalSection;
    PCRITICAL_SECTION_SPLAY_NODE CritSectSplayNode;

    CriticalSection = &Resource->CriticalSection;

    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOCKS_INITIALIZE_DELETE) != 0) {

        DbgPrint ("AVrfpRtlDeleteResource (%p), CS = %p\n",
                  Resource,
                  CriticalSection);
    }

    //
    // We cannot use the CriticalSectionLock after shutdown started,
    // because the RTL critical sections stop working at that time.
    //

    if (RtlDllShutdownInProgress() == FALSE) {

        //
        // Grab the CS splay tree lock.
        //

        RtlEnterCriticalSection( &CriticalSectionLock );

        try	{

            if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) != 0 &&
                RtlDllShutdownInProgress() == FALSE ) {

                //
                // Verify that the CS was initialized.
                //

                CritSectSplayNode = AVrfpVerifyInitializedCriticalSection (CriticalSection);

                if (CritSectSplayNode != NULL) {

                    //
                    // Verify that no thread owns or waits for this CS or
                    // the owner is the current thread. 
                    //

                    AVrfpVerifyNoWaitersCriticalSection (CriticalSection);
                }
            }

            //
            // Remove the critical section from our splay tree.
            //

            AVrfpDeleteCritSectFromSplayTree (CriticalSection);
        }
        finally {

            //
            // Release the CS splay tree lock.
            //

            RtlLeaveCriticalSection( &CriticalSectionLock );
        }
    }

    //
    // Regular ntdll resource deletion.
    //

    RtlDeleteResource (Resource);
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
BOOLEAN
AVrfpRtlAcquireResourceShared (
    IN PRTL_RESOURCE Resource,
    IN BOOLEAN Wait
    )
{
    //
    // Verify that the CS was initialized.
    //

    AVrfpVerifyInitializedCriticalSection2 (&Resource->CriticalSection);

    //
    // Call the regular ntdll function.
    //

    return RtlAcquireResourceShared (Resource,
                                     Wait);
}


BOOLEAN
AVrfpRtlAcquireResourceExclusive (
    IN PRTL_RESOURCE Resource,
    IN BOOLEAN Wait
    )
{
    //
    // Verify that the CS was initialized.
    //

    AVrfpVerifyInitializedCriticalSection2 (&Resource->CriticalSection);

    //
    // Call the regular ntdll function.
    //

    return RtlAcquireResourceExclusive (Resource,
                                        Wait);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
VOID
AVrfpRtlReleaseResource (
    IN PRTL_RESOURCE Resource
    )
{
    //
    // Verify that the CS was initialized.
    //

    AVrfpVerifyInitializedCriticalSection2 (&Resource->CriticalSection);

    //
    // Call the regular ntdll function.
    //

    RtlReleaseResource (Resource);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
VOID
AVrfpRtlConvertSharedToExclusive(
    IN PRTL_RESOURCE Resource
    )
{
    //
    // Verify that the CS was initialized.
    //

    AVrfpVerifyInitializedCriticalSection2 (&Resource->CriticalSection);

    //
    // Call the regular ntdll function.
    //

    RtlConvertSharedToExclusive (Resource);
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
VOID
AVrfpRtlConvertExclusiveToShared (
    IN PRTL_RESOURCE Resource
    )
{
    //
    // Verify that the CS was initialized.
    //

    AVrfpVerifyInitializedCriticalSection2 (&Resource->CriticalSection);

    //
    // Call the regular ntdll function.
    //

    RtlConvertExclusiveToShared (Resource);
}

LONG AVrfpCSCountHacks = 0;

VOID
AVrfpIncrementOwnedCriticalSections (
    LONG Increment
    )
{
    PAVRF_TLS_STRUCT TlsStruct;

    TlsStruct = AVrfpGetVerifierTlsValue();

    if (TlsStruct != NULL) {

        TlsStruct->CountOfOwnedCriticalSections += Increment;

        if (TlsStruct->CountOfOwnedCriticalSections < 0 &&
            (AVrfpProvider.VerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) != 0 &&
            RtlDllShutdownInProgress() == FALSE ) {

            VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_OVER_RELEASED | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                           "critical section over-released or corrupted",
                           TlsStruct->CountOfOwnedCriticalSections, "Number of critical sections owned by curent thread.",
                           NULL, "", 
                           NULL, "", 
                           NULL, "");

            //
            // Hack:
            //
            // If the number of owned critical sections became -1 (over-release) we are
            // resetting it to 0 because otherwise we will keep breaking for
            // every future legitimate critical section usage by this thread.
            //

            if (TlsStruct->CountOfOwnedCriticalSections == -1) {

                InterlockedIncrement (&AVrfpCSCountHacks);

                TlsStruct->CountOfOwnedCriticalSections = 0;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\faults.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

    faults.h

Abstract:

    This module implements fault injection support.

Author:

    Silviu Calinoiu (SilviuC) 3-Dec-2001

Revision History:

    3-Dec-2001 (SilviuC): initial version.

--*/

#ifndef _FAULTS_H_
#define _FAULTS_H_

NTSTATUS
AVrfpInitializeFaultInjectionSupport (
    VOID
    );

LOGICAL
AVrfpShouldFaultInject (
    ULONG Class,
    PVOID Caller
    );

#define SHOULD_FAULT_INJECT(cls) AVrfpShouldFaultInject((cls), _ReturnAddress())

#define CLS_WAIT_APIS                FAULT_INJECTION_CLASS_WAIT_APIS
#define CLS_HEAP_ALLOC_APIS          FAULT_INJECTION_CLASS_HEAP_ALLOC_APIS
#define CLS_VIRTUAL_ALLOC_APIS       FAULT_INJECTION_CLASS_VIRTUAL_ALLOC_APIS
#define CLS_REGISTRY_APIS            FAULT_INJECTION_CLASS_REGISTRY_APIS
#define CLS_FILE_APIS                FAULT_INJECTION_CLASS_FILE_APIS
#define CLS_EVENT_APIS               FAULT_INJECTION_CLASS_EVENT_APIS
#define CLS_MAP_VIEW_APIS            FAULT_INJECTION_CLASS_MAP_VIEW_APIS
#define CLS_OLE_ALLOC_APIS           FAULT_INJECTION_CLASS_OLE_ALLOC_APIS
                                         
#define CLS_MAXIMUM_INDEX 16

#endif // _FAULTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\handle.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    handle.c

Abstract:

    This module implements handle checking code.

Author:

    Silviu Calinoiu (SilviuC) 1-Mar-2001

Revision History:

--*/

#include "pch.h"

#include "verifier.h"
#include "support.h"
#include "faults.h"

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtClose(
    IN HANDLE Handle
    )
{
    NTSTATUS Status;

    Status = NtClose (Handle);

    return Status;
}


//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    )
{
    NTSTATUS Status;
    
    BUMP_COUNTER (CNT_CREATE_EVENT_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_EVENT_APIS)) {
        BUMP_COUNTER (CNT_CREATE_EVENT_FAILS);
        CHECK_BREAK (BRK_CREATE_EVENT_FAIL);
        return STATUS_NO_MEMORY;
    }
    
    Status = NtCreateEvent (EventHandle,
                            DesiredAccess,
                            ObjectAttributes,
                            EventType,
                            InitialState);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\deadlock.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

   deadlock.h

Abstract:

    This module implements a deadlock verification package for
    critical section operations. The initial version is based on
    the driver verifier deadlock checking package for kernel
    synchornization objects.

Author:

    Silviu Calinoiu (SilviuC) 6-Feb-2002

Revision History:

--*/

#ifndef _DEADLOCK_H_
#define _DEADLOCK_H_

//
// Deadlock detection package initialization.
//

VOID
AVrfDeadlockDetectionInitialize (
    VOID
    );

//
// Deadlock verifier main entry points.
//

LOGICAL
AVrfDeadlockResourceInitialize (
    PVOID Resource, 
    PVOID Caller
    );

LOGICAL
AVrfDeadlockResourceDelete (
    PVOID Resource, 
    PVOID Caller
    );

LOGICAL
AVrfDeadlockResourceAcquire (
    PVOID Resource, 
    PVOID Caller,
    LOGICAL TryAcquire
    );

LOGICAL
AVrfDeadlockResourceRelease (
    PVOID Resource, 
    PVOID Caller
    );

//
// Maximum number of nodes paraticipating in a cycle. We do not
// attempt to find cycles in the graph with more than 32 nodes
// because this would be mind boggling anyway and no human will be
// able to understand it.
//

#define NO_OF_DEADLOCK_PARTICIPANTS 32

//
// AVRF_DEADLOCK_RESOURCE_TYPE
//

typedef enum _AVRF_DEADLOCK_RESOURCE_TYPE {

    AVrfpDeadlockTypeUnknown = 0,
    AVrfpDeadlockTypeCriticalSection = 1,
    AVrfpDeadlockTypeMaximum = 2

} AVRF_DEADLOCK_RESOURCE_TYPE;

//
// AVRF_DEADLOCK_NODE
//

typedef struct _AVRF_DEADLOCK_NODE {

    //
    // Node representing the acquisition of the previous resource.
    //

    struct _AVRF_DEADLOCK_NODE * Parent;

    //
    // Node representing the next resource acquisitions, that are
    // done after acquisition of the current resource.
    //

    struct _LIST_ENTRY ChildrenList;

    //
    // Field used to chain siblings in the tree. A parent node has the
    // ChildrenList field as the head of the children list that is chained
    // with the Siblings field.
    //

    struct _LIST_ENTRY SiblingsList;

    union {

        //
        // List of nodes representing the same resource acquisition
        // as the current node but in different contexts (lock combinations).
        //

        struct _LIST_ENTRY ResourceList;

        //
        // Used to chain free nodes. This is used only after the node has
        // been deleted (resource was freed). Nodes are kept in a cache
        // to reduce contention for the kernel pool.
        //

        struct _LIST_ENTRY FreeListEntry;
    };

    //
    // Back pointer to the descriptor for this resource.
    //

    struct _AVRF_DEADLOCK_RESOURCE * Root;

    //
    // When we find a deadlock, we keep this info around in order to
    // be able to identify the parties involved who have caused
    // the deadlock.
    //

    struct _AVRF_DEADLOCK_THREAD * ThreadEntry;

    //
    // Fields used for decision making within the deadlock analysis 
    // algorithm.
    //
    // Active: 1 if the node represents a resource currently acquired,
    //     0 if resource was acquired in the past.
    //
    // OnlyTryAcquiredUsed: 1 if resource was always acquired with TryAcquire.
    //     0 if at least once normal acquire was used. A node that uses
    //     only TryAcquire cannot be involved in a deadlock.
    //
    // ReleasedOutOfOrder: 1 if the resource was at least once released 
    //     out of order. The flag is used while looking for cycles because
    //     this type of nodes will appear as part of the cycle but there is
    //     no deadlock.
    //
    // SequenceNumber: field that gets a unique stamp during each deadlock
    //     analysis run. It helps figure out if the node was touched 
    //     already in the current graph traversal.
    //

    struct {

        ULONG Active : 1;
        ULONG OnlyTryAcquireUsed : 1;         
        ULONG ReleasedOutOfOrder : 1;
        ULONG SequenceNumber : 29;
    };

    //
    // Stack traces for the resource acquisition moment.
    // Used when displaying deadlock proofs. On free builds
    // anything other than the first entry (return address)
    // may be bogus in case stack trace capturing failed.
    //

    PVOID StackTrace[MAX_TRACE_DEPTH];
    PVOID ParentStackTrace[MAX_TRACE_DEPTH];

} AVRF_DEADLOCK_NODE, *PAVRF_DEADLOCK_NODE;

//
// AVRF_DEADLOCK_RESOURCE
//

typedef struct _AVRF_DEADLOCK_RESOURCE {

    //
    // Resource type (mutex, spinlock, etc.).
    //

    AVRF_DEADLOCK_RESOURCE_TYPE Type;

    //
    // Resource flags
    //    
    // NodeCount : number of resource nodes created for this resource.
    //
    // RecursionCount : number of times this resource has been recursively acquired 
    //     It makes sense to put this counter in the resource because as long as
    //     resource is acquired only one thread can operate on it.
    //

    struct {
        ULONG NodeCount : 16;
        ULONG RecursionCount : 16;
    };

    //
    // The address of the synchronization object used by the kernel.
    //

    PVOID ResourceAddress;

    //
    // The thread that currently owns the resource. The field is
    // null if nobody owns the resource.
    //

    struct _AVRF_DEADLOCK_THREAD * ThreadOwner;

    //
    // List of resource nodes representing acquisitions of this resource.
    //

    LIST_ENTRY ResourceList;

    union {

        //
        // List used for chaining resources from a hash bucket.
        //

        LIST_ENTRY HashChainList;

        //
        // Used to chain free resources. This list is used only after
        // the resource has been freed and we put the structure
        // into a cache to reduce kernel pool contention.
        //

        LIST_ENTRY FreeListEntry;
    };

    //
    // Stack trace of the resource creator. On free builds we
    // may have here only a return address that is bubbled up
    // from verifier thunks. 
    //

    PVOID StackTrace [MAX_TRACE_DEPTH];

    //
    // Stack trace for last acquire
    //

    PVOID LastAcquireTrace [MAX_TRACE_DEPTH];

    //
    // Stack trace for last release
    //

    PVOID LastReleaseTrace [MAX_TRACE_DEPTH];

} AVRF_DEADLOCK_RESOURCE, * PAVRF_DEADLOCK_RESOURCE;

//
// AVRF_DEADLOCK_THREAD
//

typedef struct _AVRF_DEADLOCK_THREAD {

    //
    // Kernel thread address
    //

    PKTHREAD Thread;

    //
    // The node representing the last resource acquisition made by
    // this thread.
    //

    PAVRF_DEADLOCK_NODE CurrentTopNode;

    union {

        //
        // Thread list. It is used for chaining into a hash bucket.
        //

        LIST_ENTRY ListEntry;

        //
        // Used to chain free nodes. The list is used only after we decide
        // to delete the thread structure (possibly because it does not
        // hold resources anymore). Keeping the structures in a cache
        // reduces pool contention.
        //

        LIST_ENTRY FreeListEntry;
    };

    //
    // Count of resources currently acquired by a thread. When this becomes
    // zero the thread will be destroyed. The count goes up during acquire
    // and down during release.
    //

    ULONG NodeCount;

} AVRF_DEADLOCK_THREAD, *PAVRF_DEADLOCK_THREAD;

//
// Deadlock verifier globals
//

typedef struct _AVRF_DEADLOCK_GLOBALS {

    //
    // Structure counters: [0] - current, [1] - maximum
    //

    ULONG Nodes[2];
    ULONG Resources[2];
    ULONG Threads[2];

    //
    // Total number of kernel pool bytes used by the deadlock verifier
    //

    SIZE_T BytesAllocated;

    //
    // Resource and thread collection.
    //

    PLIST_ENTRY ResourceDatabase;
    PLIST_ENTRY ThreadDatabase;   

    //
    // How many times ExAllocatePool failed on us?
    // If this is >0 we stop deadlock verification.
    //

    ULONG AllocationFailures;

    //
    // How many nodes have been trimmed when we decided to forget
    // partially the history of some resources.
    //

    ULONG NodesTrimmedBasedOnAge;
    ULONG NodesTrimmedBasedOnCount;

    //
    // Deadlock analysis statistics
    //

    ULONG NodesSearched;
    ULONG MaxNodesSearched;
    ULONG SequenceNumber;

    ULONG RecursionDepthLimit;
    ULONG SearchedNodesLimit;

    ULONG DepthLimitHits;
    ULONG SearchLimitHits;

    //
    // Number of times we have to exonerate a deadlock because
    // it was protected by a common resource (e.g. thread 1 takes ABC, 
    // thread 2 takes ACB -- this will get flagged initially by our algorithm 
    // since B&C are taken out of order but is not actually a deadlock.
    //

    ULONG ABC_ACB_Skipped;

    ULONG OutOfOrderReleases;
    ULONG NodesReleasedOutOfOrder;

    //
    // How many locks are held simultaneously while the system is running?
    //

    ULONG NodeLevelCounter[8];
    ULONG GraphNodes[8];

    ULONG TotalReleases;
    ULONG RootNodesDeleted;

    //
    // Used to control how often we delete portions of the dependency
    // graph.
    //

    ULONG ForgetHistoryCounter;

    //
    // How often was a worker items dispatched to trim the
    // pool cache.
    //

    ULONG PoolTrimCounter;

    //
    // Caches of freed structures (thread, resource, node) used to
    // decrease kernel pool contention.
    //

    LIST_ENTRY FreeResourceList;    
    LIST_ENTRY FreeThreadList;
    LIST_ENTRY FreeNodeList;

    ULONG FreeResourceCount;
    ULONG FreeThreadCount;
    ULONG FreeNodeCount;   

    //
    // Resource address that caused the deadlock
    //

    PVOID Instigator;

    //
    // Number of participants in the deadlock
    //

    ULONG NumberOfParticipants;

    //
    // List of the nodes that participate in the deadlock
    //

    PAVRF_DEADLOCK_NODE Participant [NO_OF_DEADLOCK_PARTICIPANTS];

    LOGICAL CacheReductionInProgress;

} AVRF_DEADLOCK_GLOBALS, *PAVRF_DEADLOCK_GLOBALS;

#endif // #ifndef _DEADLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\faults.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    faults.c

Abstract:

    This module implements fault injection support.

Author:

    Silviu Calinoiu (SilviuC) 3-Dec-2001

Revision History:

    3-Dec-2001 (SilviuC): initial version.

--*/

#include "pch.h"

#include "verifier.h"
#include "support.h"
#include "faults.h"

ULONG AVrfpFaultSeed;                                           
ULONG AVrfpFaultProbability [CLS_MAXIMUM_INDEX];

ULONG AVrfpFaultBreak [CLS_MAXIMUM_INDEX];
ULONG AVrfpFaultTrue [CLS_MAXIMUM_INDEX];
ULONG AVrfpFaultFalse [CLS_MAXIMUM_INDEX];

//
// Target ranges for fault injection.
//

#define MAXIMUM_TARGET_INDEX 128

ULONG_PTR AVrfpFaultTargetStart [MAXIMUM_TARGET_INDEX];
ULONG_PTR AVrfpFaultTargetEnd [MAXIMUM_TARGET_INDEX];
ULONG AVrfpFaultTargetHits [MAXIMUM_TARGET_INDEX];

ULONG AVrfpFaultTargetMaximumIndex;

//
// Exclusion ranges for fault injection.
//

#define MAXIMUM_EXCLUSION_INDEX 128

ULONG_PTR AVrfpFaultExclusionStart [MAXIMUM_TARGET_INDEX];
ULONG_PTR AVrfpFaultExclusionEnd [MAXIMUM_TARGET_INDEX];
ULONG AVrfpFaultExclusionHits [MAXIMUM_TARGET_INDEX];

ULONG AVrfpFaultExclusionMaximumIndex;

//
// Fault injection trace history.
//

#define NUMBER_OF_TRACES 128

PVOID AVrfpFaultTrace[NUMBER_OF_TRACES][MAX_TRACE_DEPTH];

ULONG AVrfpFaultNumberOfTraces = NUMBER_OF_TRACES;
ULONG AVrfpFaultTraceSize = MAX_TRACE_DEPTH;

ULONG AVrfpFaultTraceIndex;

//
// Period amnesty. The period of time when fault injection should 
// be avoided is written from debugger.
//

LARGE_INTEGER AVrfpFaultStartTime;
ULONG AVrfpFaultPeriodTimeInMsecs;

//
// Lock used to synchronize some low frequency operations (e.g. exports
// for target/exclusion range manipulation).
//

RTL_CRITICAL_SECTION AVrfpFaultInjectionLock;

LOGICAL
AVrfpIsAddressInTargetRange (
    ULONG_PTR Address
    );

LOGICAL
AVrfpIsAddressInExclusionRange (
    ULONG_PTR Address
    );

VOID
AVrfpLogFaultTrace (
    VOID
    );

NTSTATUS
AVrfpInitializeFaultInjectionSupport (
    VOID
    )
{
    NTSTATUS Status;
    LARGE_INTEGER PerformanceCounter;

    Status = STATUS_SUCCESS;

    //
    // Initialize lock used for some fault injection operations.
    //

    Status = RtlInitializeCriticalSection (&AVrfpFaultInjectionLock);

    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Initialize the seed for the random generator.
    //

    NtQueryPerformanceCounter (&PerformanceCounter, NULL);
    AVrfpFaultSeed = PerformanceCounter.LowPart;

    NtQuerySystemTime (&AVrfpFaultStartTime);

    //
    // Touch the break triggers vector so that the compiler
    // does not optimize away the entire structure. Since it 
    // is supposed to be modified only from debugger the compiler
    // considers that the array is not needed.
    //

    RtlZeroMemory (AVrfpBreak, sizeof AVrfpBreak);

    //
    // Same reason as above.
    //

    AVrfpFaultTargetMaximumIndex = MAXIMUM_TARGET_INDEX;
    RtlZeroMemory (AVrfpFaultTargetStart, sizeof AVrfpFaultTargetStart);
    RtlZeroMemory (AVrfpFaultTargetEnd, sizeof AVrfpFaultTargetEnd);
    RtlZeroMemory (AVrfpFaultTargetHits, sizeof AVrfpFaultTargetHits);

    AVrfpFaultTargetStart[0] = 0;
    AVrfpFaultTargetEnd[0] = ~((ULONG_PTR)0);

    AVrfpFaultExclusionMaximumIndex = MAXIMUM_EXCLUSION_INDEX;
    RtlZeroMemory (AVrfpFaultExclusionStart, sizeof AVrfpFaultExclusionStart);
    RtlZeroMemory (AVrfpFaultExclusionEnd, sizeof AVrfpFaultExclusionEnd);
    RtlZeroMemory (AVrfpFaultExclusionHits, sizeof AVrfpFaultExclusionHits);

    return Status;
}


LOGICAL
AVrfpShouldFaultInject (
    ULONG Class,
    PVOID Caller
    )
{
    ULONG Random;
    LARGE_INTEGER Time;
    LARGE_INTEGER Delta;

    //
    // No fault injection => return FALSE
    //

    if (AVrfpFaultProbability[Class] == 0) {
        return FALSE;
    }

    //
    // Check if some period amnesty was set. `AVrfpFaultPeriodTimeInMsecs' variable
    // is only read and reset to zero from verifier code. It is set to non null values 
    // only from debugger extensions. Therefore to way it is used before without
    // serialization is ok even if after the `if' condition another thread resets it.
    //

    if (AVrfpFaultPeriodTimeInMsecs) {
        
        NtQuerySystemTime (&Time);

        Delta.QuadPart = (DWORDLONG)AVrfpFaultPeriodTimeInMsecs * 1000 * 10;

        if (Time.QuadPart - AVrfpFaultStartTime.QuadPart > Delta.QuadPart) {

            AVrfpFaultPeriodTimeInMsecs = 0;    
        }
        else {
            return FALSE;
        }
    }

    //
    // If in exclusion range => return FALSE
    //

    if (AVrfpIsAddressInExclusionRange ((ULONG_PTR)Caller) == TRUE) {
        return FALSE;
    }

    //
    // Not in target range => return FALSE
    //

    if (AVrfpIsAddressInTargetRange ((ULONG_PTR)Caller) == FALSE) {
        return FALSE;
    }

    //
    // Operations above access only READ-ONLY data (it gets modified
    // only from debugger). From now on though we need synchronized
    // access.
    //

    Random = RtlRandom (&AVrfpFaultSeed);

    if (Random % 100 < AVrfpFaultProbability[Class]) {

        InterlockedIncrement((PLONG)(&(AVrfpFaultTrue[Class])));

        if (AVrfpFaultBreak[Class]) {
            DbgPrint ("AVRF: fault injecting call made from %p \n", Caller);
            DbgBreakPoint ();
        }

        AVrfpLogFaultTrace ();
        return TRUE;
    }
    else {

        InterlockedIncrement((PLONG)(&(AVrfpFaultFalse[Class])));
        return FALSE;
    }
}


LOGICAL
AVrfpIsAddressInTargetRange (
    ULONG_PTR Address
    )
{
    ULONG I;

    if (Address == 0) {
        return FALSE;
    }

    for (I = 0; I < AVrfpFaultTargetMaximumIndex; I += 1) {
        
        if (AVrfpFaultTargetEnd[I] != 0) {

            if (AVrfpFaultTargetStart[I] <= Address &&
                AVrfpFaultTargetEnd[I] > Address) {

                AVrfpFaultTargetHits[I] += 1;
                return TRUE;
            }
        }
    }

    return FALSE;
}


LOGICAL
AVrfpIsAddressInExclusionRange (
    ULONG_PTR Address
    )
{
    ULONG I;

    if (Address == 0) {
        return FALSE;
    }

    for (I = 0; I < AVrfpFaultExclusionMaximumIndex; I += 1) {
        
        if (AVrfpFaultExclusionEnd[I] != 0) {

            if (AVrfpFaultExclusionStart[I] <= Address &&
                AVrfpFaultExclusionEnd[I] > Address) {

                AVrfpFaultExclusionHits[I] += 1;
                return TRUE;
            }
        }
    }

    return FALSE;
}


VOID
AVrfpLogFaultTrace (
    VOID
    )
{
    ULONG Index;

    Index = (ULONG)InterlockedIncrement ((PLONG)(&AVrfpFaultTraceIndex));

    Index %= AVrfpFaultNumberOfTraces;

    RtlCaptureStackBackTrace (2, 
                              AVrfpFaultTraceSize,
                              &(AVrfpFaultTrace[Index][0]),
                              NULL);
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////// Fault injection general SDK
/////////////////////////////////////////////////////////////////////


VOID
VerifierSetFaultInjectionProbability (
    ULONG Class,
    ULONG Probability
    )
/*++

Routine Description:

    This routine set fault injection probability for a certain class of events 
    (heap operations, registry operations, etc.).

Arguments:

    Class - class of events for which fault injection probability is set. Constants
        are of type FAULT_INJECTION_CLASS_XXX.

    Probability - probability for fault injection.
        
Return Value:

    None.

--*/
{
    //
    // Application verifier must be enabled.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return;
    }

    if (Class >= FAULT_INJECTION_INVALID_CLASS) {

        DbgPrint ("AVRF:FINJ: invalid fault injection class %X \n", Class);
        DbgBreakPoint ();
        return;
    }

    RtlEnterCriticalSection (&AVrfpFaultInjectionLock);

    AVrfpFaultProbability [Class] = Probability;
    
    RtlLeaveCriticalSection (&AVrfpFaultInjectionLock);
}


/////////////////////////////////////////////////////////////////////
///////////////////////// Target/exclusion fault injection ranges SDK
/////////////////////////////////////////////////////////////////////


ULONG 
VerifierEnableFaultInjectionTargetRange (
    PVOID StartAddress,
    PVOID EndAddress
    )
/*++

Routine Description:

    This routine establishes at runtime a fault injection target range. If successful
    it will return a range index that can be used later to disable the range.

Arguments:

    StartAddress - start address of the target range.
    
    EndAddress - end address of the target range.
    
Return Value:

    A range index >0 if succesful. Zero otherwise.

--*/
{
    ULONG Ri;
    ULONG FinalIndex;

    //
    // Application verifier must be enabled.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return 0;
    }

    FinalIndex = 0;

    RtlEnterCriticalSection (&AVrfpFaultInjectionLock);

    if (AVrfpFaultTargetStart[0] == 0 && 
        AVrfpFaultTargetEnd[0] == ~((ULONG_PTR)0)) {
        
        AVrfpFaultTargetStart[0] = (ULONG_PTR)StartAddress;                
        AVrfpFaultTargetEnd[0] = (ULONG_PTR)EndAddress;                
        AVrfpFaultTargetHits[0] = 0;                
        FinalIndex = 1;
    }
    else {

        for (Ri = 0; Ri < AVrfpFaultTargetMaximumIndex; Ri += 1) {

            if (AVrfpFaultTargetEnd[Ri] == 0) {

                AVrfpFaultTargetStart[Ri] = (ULONG_PTR)StartAddress;                
                AVrfpFaultTargetEnd[Ri] = (ULONG_PTR)EndAddress;                
                AVrfpFaultTargetHits[Ri] = 0;                
                FinalIndex = Ri + 1;
                break;
            }
        }
    }

    RtlLeaveCriticalSection (&AVrfpFaultInjectionLock);

    return FinalIndex;
}


VOID 
VerifierDisableFaultInjectionTargetRange (
    ULONG RangeIndex
    )
/*++

Routine Description:

    This routine disables the target range specified by the RangeIndex.
    If the RangeIndex is zero then all target ranges will be disabled.
    The function breaks in the debugger (even in free builds) if the
    range index is invalid. 

Arguments:

    RangeIndex - index of range to disable or zero if all need to be disabled.
    
Return Value:

    None.

--*/
{
    ULONG Ri;
    LOGICAL FoundOne;

    //
    // Application verifier must be enabled.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return;
    }

    RtlEnterCriticalSection (&AVrfpFaultInjectionLock);

    if (RangeIndex == 0) {
        
        //
        // Disable all target ranges.
        //

        for (Ri = 0; Ri < AVrfpFaultTargetMaximumIndex; Ri += 1) {

            AVrfpFaultTargetStart[Ri] = 0;                
            AVrfpFaultTargetEnd[Ri] = 0;                
            AVrfpFaultTargetHits[Ri] = 0;                
        }

        AVrfpFaultTargetStart[0] = 0;                
        AVrfpFaultTargetEnd[0] = ~((ULONG_PTR)0);                
        AVrfpFaultTargetHits[0] = 0;                
    }
    else {

        //
        // disable target range `RangeIndex - 1'.
        //

        RangeIndex -= 1;

        if (RangeIndex >= AVrfpFaultTargetMaximumIndex) {

            DbgPrint ("AVRF:FINJ: invalid target range index %X \n", RangeIndex);
            DbgBreakPoint ();
            goto Exit;
        }

        if (AVrfpFaultTargetEnd[RangeIndex] == 0) {

            DbgPrint ("AVRF:FINJ: disabling empty target range at index %X \n", RangeIndex);
            DbgBreakPoint ();
            goto Exit;
        }

        AVrfpFaultTargetStart[RangeIndex] = 0;                
        AVrfpFaultTargetEnd[RangeIndex] = 0;                
        AVrfpFaultTargetHits[RangeIndex] = 0;                

        //
        // If we do not have any target ranges active then establish the default
        // target range that spans the entire virtual space.
        //

        FoundOne = FALSE;

        for (Ri = 0; Ri < AVrfpFaultTargetMaximumIndex; Ri += 1) {

            if (AVrfpFaultTargetEnd[Ri] != 0) {

                FoundOne = TRUE;
                break;
            }
        }

        if (! FoundOne) {

            AVrfpFaultTargetStart[0] = 0;                
            AVrfpFaultTargetEnd[0] = ~((ULONG_PTR)0);                
            AVrfpFaultTargetHits[0] = 0;                
        }
    }

    Exit:

    RtlLeaveCriticalSection (&AVrfpFaultInjectionLock);
}


ULONG 
VerifierEnableFaultInjectionExclusionRange (
    PVOID StartAddress,
    PVOID EndAddress
    )
/*++

Routine Description:

    This routine establishes at runtime a fault injection exclusion range. If successful
    it will return a range index that can be used later to disable the range.

Arguments:

    StartAddress - start address of the exclusion range.
    
    EndAddress - end address of the exclusion range.
    
Return Value:

    A range index >0 if succesful. Zero otherwise.

--*/
{
    ULONG Ri;
    ULONG FinalIndex;

    //
    // Application verifier must be enabled.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return 0;
    }

    FinalIndex = 0;

    RtlEnterCriticalSection (&AVrfpFaultInjectionLock);
    
    for (Ri = 0; Ri < AVrfpFaultExclusionMaximumIndex; Ri += 1) {

        if (AVrfpFaultExclusionEnd[Ri] == 0) {

            AVrfpFaultExclusionStart[Ri] = (ULONG_PTR)StartAddress;                
            AVrfpFaultExclusionEnd[Ri] = (ULONG_PTR)EndAddress;                
            AVrfpFaultExclusionHits[Ri] = 0;                
            FinalIndex = Ri + 1;
            break;
        }
    }

    RtlLeaveCriticalSection (&AVrfpFaultInjectionLock);

    return FinalIndex;
}


VOID 
VerifierDisableFaultInjectionExclusionRange (
    ULONG RangeIndex
    )
/*++

Routine Description:

    This routine disables the exclusion range specified by the RangeIndex.
    If the RangeIndex is zero then all exclusion ranges will be disabled.
    The function breaks in the debugger (even in free builds) if the
    range index is invalid. 

Arguments:

    RangeIndex - index of range to disable or zero if all need to be disabled.
    
Return Value:

    None.

--*/
{
    ULONG Ri;

    //
    // Application verifier must be enabled.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return;
    }

    RtlEnterCriticalSection (&AVrfpFaultInjectionLock);

    if (RangeIndex == 0) {
        
        //
        // Disable all exclusion ranges.
        //

        for (Ri = 0; Ri < AVrfpFaultExclusionMaximumIndex; Ri += 1) {

            AVrfpFaultExclusionStart[Ri] = 0;                
            AVrfpFaultExclusionEnd[Ri] = 0;                
            AVrfpFaultExclusionHits[Ri] = 0;                
        }
    }
    else {

        //
        // disable exclusion range `RangeIndex - 1'.
        //

        RangeIndex -= 1;

        if (RangeIndex >= AVrfpFaultExclusionMaximumIndex) {

            DbgPrint ("AVRF:FINJ: invalid exclusion range index %X \n", RangeIndex);
            DbgBreakPoint ();
            goto Exit;
        }

        if (AVrfpFaultExclusionEnd[RangeIndex] == 0) {

            DbgPrint ("AVRF:FINJ: disabling empty exclusion range at index %X \n", RangeIndex);
            DbgBreakPoint ();
            goto Exit;
        }

        AVrfpFaultExclusionStart[RangeIndex] = 0;                
        AVrfpFaultExclusionEnd[RangeIndex] = 0;                
        AVrfpFaultExclusionHits[RangeIndex] = 0;                
    }

    Exit:

    RtlLeaveCriticalSection (&AVrfpFaultInjectionLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\deadlock.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    deadlock.c

Abstract:

    This module implements a deadlock verification package for
    critical section operations. The initial version is based on
    the driver verifier deadlock checking package for kernel
    synchornization objects.

Author:

    Silviu Calinoiu (SilviuC) 6-Feb-2002

Revision History:

--*/

/*++

    silviuc: update this comment
    
    The Deadlock Verifier
    
    The deadlock verifier is used to detect potential deadlocks. It does this
    by acquiring the history of how resources are acquired and trying to figure
    out on the fly if there are any potential lock hierarchy issues. The algorithms
    for finding cycles in the lock dependency graph is totally "blind". This means
    that if a driver acquires lock A then B in one place and lock B then A in 
    another this will be triggered as a deadlock issue. This will happen even if you 
    can build a proof based on other contextual factors that the deadlock can never
    happen. 
    
    The deadlock verifier assumes there are four operations during the lifetime
    of a resource: initialize(), acquire(), release() and free(). The only one that
    is caught 100% of the time is free() due to special support from the kernel
    pool manager. The other ones can be missed if the operations are performed
    by an unverified driver or by kernel with kernel verifier disabled. The most
    typical of these misses is the initialize(). For example the kernel initializes
    a resource and then passes it to a driver to be used in acquire()/releae() cycles.
    This situation is covered 100% by the deadlock verifier. It will never complain
    about "resource uninitialized" issues.
    
    Missing acquire() or release() operations is trickier to deal with. 
    This can happen if the a verified driver acquires a resource and then another
    driver that is not verified releases it or viceversa. This is in and on itself
    a very bad programming practive and therefore the deadlock verifier will flag
    these issues. As a side note we cannot do too much about working around them
    given that we would like to. Also, because missing acquire() or release()
    operations puts deadlock verifier internal structures into inconsistent
    states these failures are difficult to debug.
    
    The deadlock verifier stores the lock dependency graph using three types
    of structures: THREAD, RESOURCE, NODE.

    For every active thread in the system that holds at least one resource
    the package maintains a THREAD structure. This gets created when a thread
    acquires first resource and gets destroyed when thread releases the last
    resource. If a thread does not hold any resource it will not have a
    corresponding THREAD structure.

    For every resource in the system there is a RESOURCE structure. This is created
    when Initialize() is called in a verified driver or we first encounter an
    Acquire() in a verified driver. Note that a resource can be initialized in
    an unverified driver and then passed to a verified driver for use. Therefore
    we can encounter Acquire() operations for resources that are not in the
    deadlock verifier database. The resource gets deleted from the database when
    the memory containing it is freed either because ExFreePool gets called or

    Every acquisition of a resource is modeled by a NODE structure. When a thread
    acquires resource B while holding A the deadlock verifier  will create a NODE 
    for B and link it to the node for A. 

    There are three important functions that make the interface with the outside
    world.

        AVrfpDeadlockInitializeResource   hook for resource initialization
        AVrfpDeadlockAcquireResource      hook for resource acquire
        AVrfpDeadlockReleaseResource      hook for resource release
        VerifierDeadlockFreePool       hook called from ExFreePool for every free()


--*/

#include "pch.h"
#include "support.h"
#include "deadlock.h"
#include "logging.h"

//
// Enable/disable the deadlock detection package. This can be used
// to disable temporarily the deadlock detection package.
//

BOOLEAN AVrfpDeadlockDetectionEnabled;

//
// If true we will complain about release() without acquire() or acquire()
// while we think the resource is still owned. This can happen legitimately
// if a lock is shared between drivers and for example acquire() happens in
// an unverified driver and release() in a verified one or viceversa. The
// safest thing would be to enable this checks only if kernel verifier and
// dirver verifier for all drivers are enabled.
//

BOOLEAN AVrfpDeadlockStrict; //silviuc: needed?

//
// If true we will complain about uninitialized and double initialized
// resources. If false we resolve quitely these issues on the fly by 
// simulating an initialize ourselves during the acquire() operation.
// This can happen legitimately if the resource is initialized in an
// unverified driver and passed to a verified one to be used. Therefore
// the safest thing would be to enable this only if kernel verifier and
// all driver verifier for all dirvers are enabled.
//

BOOLEAN AVrfpDeadlockVeryStrict; //silviuc: needed?

//
// AgeWindow is used while trimming the graph nodes that have not
// been accessed in a while. If the global age minus the age of the node
// is bigger than the age window then the node is a candidate for trimming.
//
// The TrimThreshold variable controls if the trimming will start for a 
// resource. As long as a resource has less than TrimThreshold nodes we will
// not apply the ageing algorithm to trim nodes for that resource. 
//

ULONG AVrfpDeadlockAgeWindow = 0x2000;

ULONG AVrfpDeadlockTrimThreshold = 0x100;

//
// Various deadlock verification flags flags
//
// Recursive aquisition ok: mutexes can be recursively acquired
//
// No initialization function: if resource type does not have such a function
//     we cannot expect that in acquire() the resource is already initialized
//     by a previous call to initialize(). Fast mutexes are like this.
//
// Reverse release ok: release is not done in the same order as acquire
//
// Reinitialize ok: sometimes they reinitialize the resource.
//
// Note that a resource might appear as uninitialized if it is initialized
// in an unverified driver and then passed to a verified driver that calls
// acquire(). This is for instance the case with device extensions that are
// allocated by the kernel but used by a particular driver.
//
// silviuc: based on this maybe we should drop the whole not initialized thing?
//

// silviuc: do we need all these flags?

#define AVRF_DEADLOCK_FLAG_RECURSIVE_ACQUISITION_OK       0x0001 
#define AVRF_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION     0x0002
#define AVRF_DEADLOCK_FLAG_REVERSE_RELEASE_OK             0x0004
#define AVRF_DEADLOCK_FLAG_REINITIALIZE_OK                0x0008

//
// Specific verification flags for each resource type. The
// indeces in the vector match the values for the enumeration
// type AVRF_DEADLOCK_RESOURCE_TYPE from `deadlock.h'.
//

ULONG AVrfpDeadlockResourceTypeInfo[AVrfpDeadlockTypeMaximum] =
{
    // AVrfpDeadlockTypeUnknown //
    0,

    // AVrfpDeadlockTypeCriticalSection//
    AVRF_DEADLOCK_FLAG_RECURSIVE_ACQUISITION_OK |
    AVRF_DEADLOCK_FLAG_REVERSE_RELEASE_OK |
    // silviuc: delete this if not needed
    // AVRF_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION |
    // AVRF_DEADLOCK_FLAG_REINITIALIZE_OK |
    0,
};

//
// Control debugging behavior. A zero value means bugcheck for every failure.
//

ULONG AVrfpDeadlockDebug;

//
// Various health indicators
//

struct {

    ULONG AllocationFailures : 1;
    ULONG KernelVerifierEnabled : 1; //silviuc:delete
    ULONG DriverVerifierForAllEnabled : 1; //silviuc:delete
    ULONG SequenceNumberOverflow : 1;
    ULONG DeadlockParticipantsOverflow : 1;
    ULONG ResourceNodeCountOverflow : 1;
    ULONG Reserved : 15;

} AVrfpDeadlockState;

//
// Maximum number of locks acceptable to be hold simultaneously
//

ULONG AVrfpDeadlockSimultaneousLocksLimit = 10;

//
// Deadlock verifier specific issues (bugs)
//
// SELF_DEADLOCK
//
//     Acquiring the same resource recursively.
//
// DEADLOCK_DETECTED
//
//     Plain deadlock. Need the previous information
//     messages to build a deadlock proof.
//
// UNINITIALIZED_RESOURCE
//
//     Acquiring a resource that was never initialized.
//
// UNEXPECTED_RELEASE
//
//     Releasing a resource which is not the last one
//     acquired by the current thread. Spinlocks are handled like this
//     in a few drivers. It is not a bug per se.
//
// UNEXPECTED_THREAD
//
//     Current thread does not have any resources acquired. This may be legit if
//     we acquire in one thread and release in another. This would be bad programming
//     practice but not a crash waiting to happen per se.
//
// MULTIPLE_INITIALIZATION
//
//      Attempting to initialize a second time the same resource.
//
// THREAD_HOLDS_RESOURCES
//
//      Thread was killed while holding resources or a resource is being
//      deleted while holding resources.
//

#define AVRF_DEADLOCK_ISSUE_SELF_DEADLOCK           0x1000
#define AVRF_DEADLOCK_ISSUE_DEADLOCK_DETECTED       0x1001
#define AVRF_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE  0x1002
#define AVRF_DEADLOCK_ISSUE_UNEXPECTED_RELEASE      0x1003
#define AVRF_DEADLOCK_ISSUE_UNEXPECTED_THREAD       0x1004
#define AVRF_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION 0x1005
#define AVRF_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES  0x1006
#define AVRF_DEADLOCK_ISSUE_UNACQUIRED_RESOURCE     0x1007

//
// Performance counters read from registry.
//

ULONG ViSearchedNodesLimitFromRegistry;//silviuc:delete
ULONG ViRecursionDepthLimitFromRegistry;//silviuc:delete

//
// Water marks for the cache of freed structures.
//
// N.B. The `MAX_FREE' value will trigger a trim and the 
// `TRIM_TARGET' will be the trim goal. The trim target must 
// be meaningfully lower than the free watermark to avoid a
// chainsaw effect where we get one above free highwater mark,
// we trim to the mark and next free will trigger a repeat.
// Since trimming is done in worker threads this will put a lot
// of unnecessary strain on the system.
//

#define AVRF_DEADLOCK_MAX_FREE_THREAD    0x40
#define AVRF_DEADLOCK_MAX_FREE_NODE      0x80
#define AVRF_DEADLOCK_MAX_FREE_RESOURCE  0x80

#define AVRF_DEADLOCK_TRIM_TARGET_THREAD    0x20
#define AVRF_DEADLOCK_TRIM_TARGET_NODE      0x40
#define AVRF_DEADLOCK_TRIM_TARGET_RESOURCE  0x40

WORK_QUEUE_ITEM ViTrimDeadlockPoolWorkItem;

//
// Amount of memory preallocated if kernel verifier
// is enabled. If kernel verifier is enabled no memory
// is ever allocated from kernel pool except in the
// DeadlockDetectionInitialize() routine.
//

ULONG AVrfpDeadlockReservedThreads = 0x200;
ULONG AVrfpDeadlockReservedNodes = 0x4000;
ULONG AVrfpDeadlockReservedResources = 0x2000;

//
// Block types that can be allocated.
//

typedef enum {

    AVrfpDeadlockUnknown = 0,
    AVrfpDeadlockResource,
    AVrfpDeadlockNode,
    AVrfpDeadlockThread

} AVRF_DEADLOCK_ALLOC_TYPE;

//
// AVRF_DEADLOCK_GLOBALS
//

// silviuc: should have diff numbers for threads and resources.
#define AVRF_DEADLOCK_HASH_BINS 0x1F

PAVRF_DEADLOCK_GLOBALS AVrfpDeadlockGlobals;

//
// Default maximum recursion depth for the deadlock 
// detection algorithm. This can be overridden by registry.
//

#define AVRF_DEADLOCK_MAXIMUM_DEGREE 4

//
// Default maximum number of searched nodes for the deadlock 
// detection algorithm. This can be overridden by registry.
//

#define AVRF_DEADLOCK_MAXIMUM_SEARCH 1000

//
//  Verifier deadlock detection pool tag.
//

#define AVRF_DEADLOCK_TAG 'kclD'

//
// Controls how often ForgetResourceHistory gets called.
//

#define AVRF_DEADLOCK_FORGET_HISTORY_FREQUENCY  16

//
// Function to capture runtime stack traces.
//

NTSYSAPI
USHORT
NTAPI
RtlCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////// Internal deadlock detection functions
/////////////////////////////////////////////////////////////////////


VOID
AVrfpDeadlockDetectionInitialize (
    VOID
    );

VOID
AVrfpDeadlockDetectionCleanup (
    VOID
    );

PLIST_ENTRY
AVrfpDeadlockDatabaseHash (
    IN PLIST_ENTRY Database,
    IN PVOID Address
    );

PAVRF_DEADLOCK_RESOURCE
AVrfpDeadlockSearchResource (
    IN PVOID ResourceAddress
    );

BOOLEAN
AVrfpDeadlockSimilarNode (
    IN PVOID Resource,
    IN BOOLEAN TryNode,
    IN PAVRF_DEADLOCK_NODE Node
    );

BOOLEAN
AVrfpDeadlockCanProceed (
    VOID
    );

BOOLEAN
AVrfpDeadlockAnalyze (
    IN PVOID ResourceAddress,
    IN PAVRF_DEADLOCK_NODE CurrentNode,
    IN BOOLEAN FirstCall,
    IN ULONG Degree
    );

PAVRF_DEADLOCK_THREAD
AVrfpDeadlockSearchThread (
    HANDLE Thread
    );

PAVRF_DEADLOCK_THREAD
AVrfpDeadlockAddThread (
    HANDLE Thread,
    PVOID ReservedThread
    );

VOID
AVrfpDeadlockDeleteThread (
    PAVRF_DEADLOCK_THREAD Thread,
    BOOLEAN Cleanup
    );

BOOLEAN
AVrfpDeadlockAddResource(
    IN PVOID Resource,
    IN AVRF_DEADLOCK_RESOURCE_TYPE Type,
    IN PVOID Caller,
    IN PVOID ReservedResource
    );

PVOID
AVrfpDeadlockAllocate (
    AVRF_DEADLOCK_ALLOC_TYPE Type
    );

VOID
AVrfpDeadlockFree (
    PVOID Object,
    AVRF_DEADLOCK_ALLOC_TYPE Type
    );

VOID
AVrfpDeadlockTrimPoolCache (
    VOID
    );

VOID
AVrfpDeadlockTrimPoolCacheWorker (
    PVOID
    );

PVOID
AVrfpDeadlockAllocateFromPoolCache (
    PULONG Count,
    ULONG MaximumCount,
    PLIST_ENTRY List,
    SIZE_T Offset
    );

VOID
AVrfpDeadlockFreeIntoPoolCache (
    PVOID Object,
    PULONG Count,
    PLIST_ENTRY List,
    SIZE_T Offset
    );

VOID
AVrfpDeadlockReportIssue (
    ULONG_PTR Param1,
    ULONG_PTR Param2,
    ULONG_PTR Param3,
    ULONG_PTR Param4
    );

VOID
AVrfpDeadlockAddParticipant(
    PAVRF_DEADLOCK_NODE Node
    );

VOID
AVrfpDeadlockDeleteResource (
    PAVRF_DEADLOCK_RESOURCE Resource,
    BOOLEAN Cleanup
    );

VOID
AVrfpDeadlockDeleteNode (
    PAVRF_DEADLOCK_NODE Node,
    BOOLEAN Cleanup
    );

ULONG
AVrfpDeadlockNodeLevel (
    PAVRF_DEADLOCK_NODE Node
    );

BOOLEAN
AVrfpDeadlockCertify(
    VOID
    );

VOID
AVrfpDeadlockDetectionLock (
    VOID
    );

VOID
AVrfpDeadlockDetectionUnlock (
    VOID
    );

VOID
AVrfpDeadlockCheckThreadConsistency (
    PAVRF_DEADLOCK_THREAD Thread,
    BOOLEAN Recursion
    );

VOID
AVrfpDeadlockCheckNodeConsistency (
    PAVRF_DEADLOCK_NODE Node,
    BOOLEAN Recursion
    );

VOID
AVrfpDeadlockCheckResourceConsistency (
    PAVRF_DEADLOCK_RESOURCE Resource,
    BOOLEAN Recursion
    );

PAVRF_DEADLOCK_THREAD
AVrfpDeadlockCheckThreadReferences (
    PAVRF_DEADLOCK_NODE Node
    );

VOID 
AVrfpDeadlockCheckDuplicatesAmongChildren (
    PAVRF_DEADLOCK_NODE Parent,
    PAVRF_DEADLOCK_NODE Child
    );

VOID 
AVrfpDeadlockCheckDuplicatesAmongRoots (
    PAVRF_DEADLOCK_NODE Root
    );

LOGICAL
AVrfpDeadlockSimilarNodes (
    PAVRF_DEADLOCK_NODE NodeA,
    PAVRF_DEADLOCK_NODE NodeB
    );

VOID
AVrfpDeadlockMergeNodes (
    PAVRF_DEADLOCK_NODE NodeTo,
    PAVRF_DEADLOCK_NODE NodeFrom
    );

VOID
AVrfpDeadlockTrimResources (
    PLIST_ENTRY HashList
    );

VOID
AVrfpDeadlockForgetResourceHistory (
    PAVRF_DEADLOCK_RESOURCE Resource,
    ULONG TrimThreshold,
    ULONG AgeThreshold
    );

VOID
AVrfpDeadlockCheckStackLimits (
    VOID
    );

BOOLEAN
AVrfpDeadlockResourceInitialize(
    IN PVOID Resource,
    IN AVRF_DEADLOCK_RESOURCE_TYPE Type,
    IN PVOID Caller
    );

VOID
AVrfpDeadlockAcquireResource (
    IN PVOID Resource,
    IN AVRF_DEADLOCK_RESOURCE_TYPE Type,
    IN HANDLE Thread,   
    IN BOOLEAN TryAcquire,
    IN PVOID Caller
    );

VOID
AVrfpDeadlockReleaseResource(
    IN PVOID Resource,
    IN AVRF_DEADLOCK_RESOURCE_TYPE Type,
    IN HANDLE Thread,
    IN PVOID Caller
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////// Deadlock verifier public entry points
/////////////////////////////////////////////////////////////////////

LOGICAL
AVrfDeadlockResourceInitialize (
    PVOID Resource, 
    PVOID Caller
    )
{
    return AVrfpDeadlockResourceInitialize(Resource,
                                           AVrfpDeadlockTypeCriticalSection,
                                           Caller);
}

LOGICAL
AVrfDeadlockResourceDelete (
    PVOID Resource, 
    PVOID Caller
    )
{
    PAVRF_DEADLOCK_RESOURCE Descriptor;

    UNREFERENCED_PARAMETER (Caller);

    AVrfpDeadlockDetectionLock ();

    Descriptor = AVrfpDeadlockSearchResource (Resource);

    if (Descriptor == NULL) {

        //silviuc: whine about bogus address.
    }
    else {

        AVrfpDeadlockDeleteResource (Descriptor, FALSE);
    }

    AVrfpDeadlockDetectionUnlock ();

    return TRUE;
}

LOGICAL
AVrfDeadlockResourceAcquire (
    PVOID Resource, 
    PVOID Caller,
    LOGICAL TryAcquire
    )
{   // silviuc: should use only LOGICAL instead of BOOLEAN
    AVrfpDeadlockAcquireResource (Resource,
                                  AVrfpDeadlockTypeCriticalSection,
                                  NtCurrentTeb()->ClientId.UniqueThread,
                                  (BOOLEAN)TryAcquire,
                                  Caller);

    return TRUE;
}

LOGICAL
AVrfDeadlockResourceRelease (
    PVOID Resource, 
    PVOID Caller
    )
{
    AVrfpDeadlockReleaseResource (Resource,
                                  AVrfpDeadlockTypeCriticalSection,
                                  NtCurrentTeb()->ClientId.UniqueThread,
                                  Caller);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Lock/unlock deadlock verifier 
/////////////////////////////////////////////////////////////////////

//
// Global `deadlock lock database' lock
//

RTL_CRITICAL_SECTION AVrfpDeadlockDatabaseLock;

VOID
AVrfpDeadlockDetectionLock (
    VOID
    )
{
    RtlEnterCriticalSection (&AVrfpDeadlockDatabaseLock);               
}

VOID
AVrfpDeadlockDetectionUnlock (
    VOID
    )
{
    RtlLeaveCriticalSection (&AVrfpDeadlockDatabaseLock);               
}


/////////////////////////////////////////////////////////////////////
///////////////////// Initialization and deadlock database management
/////////////////////////////////////////////////////////////////////

PLIST_ENTRY
AVrfpDeadlockDatabaseHash(
    IN PLIST_ENTRY Database,
    IN PVOID Address
    )
/*++

Routine Description:

    This routine hashes the resource address into the deadlock database.
    The hash bin is represented by a list entry.
        
Arguments:

    ResourceAddress: Address of the resource that is being hashed

Return Value:

    PLIST_ENTRY -- the list entry associated with the hash bin we land in.

--*/    
{
    return Database + ((((ULONG_PTR)Address)) % AVRF_DEADLOCK_HASH_BINS);
}


VOID
AVrfDeadlockDetectionInitialize(
    VOID
    )
/*++

Routine Description:

    This routine initializes the data structures necessary for detecting
    deadlocks in usage of synchronization objects.

Arguments:

    None.

Return Value:

    None. If successful AVrfpDeadlockGlobals will point to a fully initialized
    structure.

Environment:

    Application verifier initialization only.

--*/    
{
    ULONG I;
    SIZE_T TableSize;

    //
    // Allocate the globals structure. AVrfpDeadlockGlobals value is
    // used to figure out if the whole initialization was successful
    // or not.
    //

    AVrfpDeadlockGlobals = AVrfpAllocate (sizeof (AVRF_DEADLOCK_GLOBALS));

    if (AVrfpDeadlockGlobals == NULL) {
        goto Failed;
    }

    RtlZeroMemory (AVrfpDeadlockGlobals, sizeof (AVRF_DEADLOCK_GLOBALS));

    //
    // Allocate hash tables for resources and threads.
    //

    TableSize = sizeof (LIST_ENTRY) * AVRF_DEADLOCK_HASH_BINS;

    AVrfpDeadlockGlobals->ResourceDatabase = AVrfpAllocate (TableSize);
    
    if (AVrfpDeadlockGlobals->ResourceDatabase == NULL) {
        goto Failed;
    }

    AVrfpDeadlockGlobals->ThreadDatabase = AVrfpAllocate (TableSize);

    if (AVrfpDeadlockGlobals->ThreadDatabase == NULL) {
        goto Failed;
    }

    //
    // Initialize the free lists.
    //

    InitializeListHead(&AVrfpDeadlockGlobals->FreeResourceList);
    InitializeListHead(&AVrfpDeadlockGlobals->FreeThreadList);
    InitializeListHead(&AVrfpDeadlockGlobals->FreeNodeList);

    //
    // Initialize hash bins and database lock.
    //    

    for (I = 0; I < AVRF_DEADLOCK_HASH_BINS; I += 1) {

        InitializeListHead(&(AVrfpDeadlockGlobals->ResourceDatabase[I]));        
        InitializeListHead(&AVrfpDeadlockGlobals->ThreadDatabase[I]);    
    }

    RtlInitializeCriticalSection (&AVrfpDeadlockDatabaseLock);    

    //
    // Initialize deadlock analysis parameters
    //

    AVrfpDeadlockGlobals->RecursionDepthLimit = AVRF_DEADLOCK_MAXIMUM_DEGREE;
    AVrfpDeadlockGlobals->SearchedNodesLimit = AVRF_DEADLOCK_MAXIMUM_SEARCH;
                                            
    //
    // Mark that everything went fine and return
    //

    AVrfpDeadlockDetectionEnabled = TRUE;
    return;

    Failed:

    //
    // Cleanup if any of our allocations failed
    //

    if (AVrfpDeadlockGlobals) {
        
        if (AVrfpDeadlockGlobals->ResourceDatabase != NULL) {
            AVrfpFree (AVrfpDeadlockGlobals->ResourceDatabase);
        }

        if (AVrfpDeadlockGlobals->ThreadDatabase != NULL) {
            AVrfpFree (AVrfpDeadlockGlobals->ThreadDatabase);
        }

        if (AVrfpDeadlockGlobals != NULL) {
            AVrfpFree (AVrfpDeadlockGlobals);

            //
            // Important to set this to null for failure because it is
            // used to figure out if the package got initialized or not.
            //

            AVrfpDeadlockGlobals = NULL;
        }
    }

    return;
}


VOID
AVrfpDeadlockDetectionCleanup (
    VOID
    )
/*++

Routine Description:

    This routine tears down all deadlock verifier internal structures.

Arguments:

    None.

Return Value:

    None.

--*/    
{
    ULONG Index;
    PLIST_ENTRY Current;
    PAVRF_DEADLOCK_RESOURCE Resource;
    PAVRF_DEADLOCK_THREAD Thread;
    PVOID Block;

    // silviuc: no locks?

    //
    // If we are not initialized then nothing to do.
    //

    if (AVrfpDeadlockGlobals == NULL) {
        return;
    }

    //
    // Iterate all resources and delete them. This will also delete
    // all nodes associated with resources.
    //

    for (Index = 0; Index < AVRF_DEADLOCK_HASH_BINS; Index += 1) {

        Current = AVrfpDeadlockGlobals->ResourceDatabase[Index].Flink;

        while (Current != &(AVrfpDeadlockGlobals->ResourceDatabase[Index])) {


            Resource = CONTAINING_RECORD (Current,
                                          AVRF_DEADLOCK_RESOURCE,
                                          HashChainList);

            Current = Current->Flink;

            AVrfpDeadlockDeleteResource (Resource, TRUE);
        }
    }

    //
    // Iterate all threads and delete them.
    //

    for (Index = 0; Index < AVRF_DEADLOCK_HASH_BINS; Index += 1) {
        Current = AVrfpDeadlockGlobals->ThreadDatabase[Index].Flink;

        while (Current != &(AVrfpDeadlockGlobals->ThreadDatabase[Index])) {

            Thread = CONTAINING_RECORD (Current,
                                        AVRF_DEADLOCK_THREAD,
                                        ListEntry);

            Current = Current->Flink;

            AVrfpDeadlockDeleteThread (Thread, TRUE);
        }
    }

    //
    // Everything should be in the pool caches by now.
    //

    ASSERT (AVrfpDeadlockGlobals->BytesAllocated == 0);

    //
    // Free pool caches.
    //

    Current = AVrfpDeadlockGlobals->FreeNodeList.Flink;

    while (Current != &(AVrfpDeadlockGlobals->FreeNodeList)) {

        Block = (PVOID) CONTAINING_RECORD (Current,
                                           AVRF_DEADLOCK_NODE,
                                           FreeListEntry);

        Current = Current->Flink;
        AVrfpFree (Block);
    }

    Current = AVrfpDeadlockGlobals->FreeResourceList.Flink;

    while (Current != &(AVrfpDeadlockGlobals->FreeResourceList)) {

        Block = (PVOID) CONTAINING_RECORD (Current,
                                           AVRF_DEADLOCK_RESOURCE,
                                           FreeListEntry);

        Current = Current->Flink;
        AVrfpFree (Block);
    }

    Current = AVrfpDeadlockGlobals->FreeThreadList.Flink;

    while (Current != &(AVrfpDeadlockGlobals->FreeThreadList)) {

        Block = (PVOID) CONTAINING_RECORD (Current,
                                           AVRF_DEADLOCK_THREAD,
                                           FreeListEntry);

        Current = Current->Flink;
        AVrfpFree (Block);
    }

    //
    // Free databases and global structure
    //

    AVrfpFree (AVrfpDeadlockGlobals->ResourceDatabase);    
    AVrfpFree (AVrfpDeadlockGlobals->ThreadDatabase);    

    AVrfpFree (AVrfpDeadlockGlobals);    

    AVrfpDeadlockGlobals = NULL;
    AVrfpDeadlockDetectionEnabled = FALSE;
}


BOOLEAN
AVrfpDeadlockCanProceed (
    VOID
    )
/*++

Routine Description:

    This routine is called by deadlock verifier exports (initialize,
    acquire, release) to figure out if deadlock verification should
    proceed for the current operation. There are several reasons
    why the return should be false. For example we failed to initialize 
    the deadlock verifier package etc.

Arguments:

    None.

Return Value:

    True if deadlock verification should proceed for the current
    operation.

Environment:

    Internal. Called by deadlock verifier exports.

--*/    
{
    //
    // Skip if process is shutting down.
    //

    if (RtlDllShutdownInProgress()) {
        return FALSE;
    }

    //
    // Skip if package not initialized
    //

    if (AVrfpDeadlockGlobals == NULL) {
        return FALSE;
    }

    //
    // Skip if package is disabled
    //

    if (! AVrfpDeadlockDetectionEnabled) {
        return FALSE;
    }

    //
    // Skip if we ever encountered an allocation failure
    //

    if (AVrfpDeadlockGlobals->AllocationFailures > 0) {
        return FALSE;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// Deadlock detection logic
/////////////////////////////////////////////////////////////////////


BOOLEAN
AVrfpDeadlockAnalyze(
    IN PVOID ResourceAddress,
    IN PAVRF_DEADLOCK_NODE AcquiredNode,
    IN BOOLEAN FirstCall,
    IN ULONG Degree
    )
/*++

Routine Description:

    This routine determines whether the acquisition of a certain resource
    could result in a deadlock.

    The routine assumes the deadlock database lock is held.

Arguments:

    ResourceAddress - address of the resource that will be acquired

    AcquiredNode - a node representing the most recent resource acquisition
        made by the thread trying to acquire `ResourceAddress'.

    FirstCall - true if this is not a recursive call made from within the
        function. It is used for doing one time per analysis only operations.

    Degree - depth of recursion.

Return Value:

    True if deadlock detected, false otherwise.

--*/    
{
    PAVRF_DEADLOCK_NODE CurrentNode;
    PAVRF_DEADLOCK_RESOURCE CurrentResource;
    PAVRF_DEADLOCK_NODE CurrentParent;
    BOOLEAN FoundDeadlock;
    PLIST_ENTRY Current;

    ASSERT (AcquiredNode);

    //
    // Setup global counters.
    //

    if (FirstCall) {

        AVrfpDeadlockGlobals->NodesSearched = 0;
        AVrfpDeadlockGlobals->SequenceNumber += 1;
        AVrfpDeadlockGlobals->NumberOfParticipants = 0;                
        AVrfpDeadlockGlobals->Instigator = NULL;

        if (AVrfpDeadlockGlobals->SequenceNumber == ((1 << 30) - 2)) {
            AVrfpDeadlockState.SequenceNumberOverflow = 1;
        }
    }

    //
    // If our node is already stamped with the current sequence number
    // then we have been here before in the current search. There is a very
    // remote possibility that the node was not touched in the last
    // 2^N calls to this function and the sequence number counter
    // overwrapped but we can live with this.
    //

    if (AcquiredNode->SequenceNumber == AVrfpDeadlockGlobals->SequenceNumber) {
        return FALSE;
    }

    //
    // Update the counter of nodes touched in this search
    //

    AVrfpDeadlockGlobals->NodesSearched += 1;

    //
    // Stamp node with current sequence number.
    //

    AcquiredNode->SequenceNumber = AVrfpDeadlockGlobals->SequenceNumber;

    //
    // Stop recursion if it gets too deep.
    //

    if (Degree > AVrfpDeadlockGlobals->RecursionDepthLimit) {

        AVrfpDeadlockGlobals->DepthLimitHits += 1;
        return FALSE;
    }

    //
    // Stop recursion if it gets too lengthy
    //

    if (AVrfpDeadlockGlobals->NodesSearched >= AVrfpDeadlockGlobals->SearchedNodesLimit) {

        AVrfpDeadlockGlobals->SearchLimitHits += 1;
        return FALSE;
    }

    //
    // Check if AcquiredNode's resource equals ResourceAddress.
    // This is the final point for a deadlock detection because
    // we managed to find a path in the graph that leads us to the
    // same resource as the one to be acquired. From now on we
    // will start returning from recursive calls and build the
    // deadlock proof along the way.
    //

    ASSERT (AcquiredNode->Root);

    if (ResourceAddress == AcquiredNode->Root->ResourceAddress) {

        if (AcquiredNode->ReleasedOutOfOrder == 0) {

            ASSERT (FALSE == FirstCall);

            FoundDeadlock = TRUE;

            AVrfpDeadlockAddParticipant (AcquiredNode);

            goto Exit;
        }
    }

    //
    // Iterate all nodes in the graph using the same resource from AcquiredNode.
    //

    FoundDeadlock = FALSE;

    CurrentResource = AcquiredNode->Root;

    Current = CurrentResource->ResourceList.Flink;

    while (Current != &(CurrentResource->ResourceList)) {

        CurrentNode = CONTAINING_RECORD (Current,
                                         AVRF_DEADLOCK_NODE,
                                         ResourceList);

        ASSERT (CurrentNode->Root);
        ASSERT (CurrentNode->Root == CurrentResource);

        //
        // Mark node as visited
        //

        CurrentNode->SequenceNumber = AVrfpDeadlockGlobals->SequenceNumber;

        //
        // Check recursively the parent of the CurrentNode. This will check the 
        // whole parent chain eventually through recursive calls.
        //

        CurrentParent = CurrentNode->Parent;

        if (CurrentParent != NULL) {

            //
            // If we are traversing the Parent chain of AcquiredNode we do not
            // increment the recursion Degree because we know the chain will
            // end. For calls to other similar nodes we have to protect against
            // too much recursion (time consuming).
            //

            if (CurrentNode != AcquiredNode) {

                //
                // Recurse across the graph
                //

                FoundDeadlock = AVrfpDeadlockAnalyze (ResourceAddress,
                                                   CurrentParent,
                                                   FALSE,
                                                   Degree + 1);

            }
            else {

                //
                // Recurse down the graph
                //

                FoundDeadlock = AVrfpDeadlockAnalyze (ResourceAddress,
                                                   CurrentParent,
                                                   FALSE,
                                                   Degree);

            }

            if (FoundDeadlock) {

                //
                // Here we might skip adding a node that was released out of order.
                // This will make cycle reporting cleaner but it will be more
                // difficult to understand the actual issue. So we will pass
                // for now.
                //

                AVrfpDeadlockAddParticipant(CurrentNode);

                if (CurrentNode != AcquiredNode) {

                    AVrfpDeadlockAddParticipant(AcquiredNode);

                }

                goto Exit;
            }
        }

        Current = Current->Flink;
    }


    Exit:

    if (FoundDeadlock && FirstCall) {

        //
        // Make sure that the deadlock does not look like ABC - ACB.
        // These sequences are protected by a common resource and therefore
        // this is not a real deadlock.
        //

        if (AVrfpDeadlockCertify ()) {

            //
            // Print deadlock information and save the address so the 
            // debugger knows who caused the deadlock.
            //

            AVrfpDeadlockGlobals->Instigator = ResourceAddress;

            DbgPrint("****************************************************************************\n");
            DbgPrint("**                                                                        **\n");
            DbgPrint("** Potential deadlock detected!                                           **\n");
            DbgPrint("** Type !avrf -dlck in the debugger for more information.                 **\n");
            DbgPrint("**                                                                        **\n");
            DbgPrint("****************************************************************************\n");

            AVrfpDeadlockReportIssue (AVRF_DEADLOCK_ISSUE_DEADLOCK_DETECTED,
                                      (ULONG_PTR)ResourceAddress,
                                      (ULONG_PTR)AcquiredNode,
                                      0);

            //
            // It is impossible to continue at this point.
            //

            return FALSE;

        }
        else {

            //
            // If we decided that this was not a deadlock after all, set the return value
            // to not return a deadlock
            //

            FoundDeadlock = FALSE;
        }
    }

    if (FirstCall) {

        if (AVrfpDeadlockGlobals->NodesSearched > AVrfpDeadlockGlobals->MaxNodesSearched) {

            AVrfpDeadlockGlobals->MaxNodesSearched = AVrfpDeadlockGlobals->NodesSearched;
        }
    }

    return FoundDeadlock;
}


BOOLEAN
AVrfpDeadlockCertify(
    VOID
    )
/*++

Routine Description:

    A potential deadlock has been detected. However our algorithm will generate
    false positives in a certain case -- if two deadlocking nodes are ever taken
    after the same node -- i.e. A->B->C A->C->B. While this can be considered
    bad programming practice it is not really a deadlock and we should not
    bugcheck.

    Also we must check to make sure that there are no nodes at the top of the
    deadlock chains that have only been acquired with try-acquire... this does
    not cause a real deadlock.

    The deadlock database lock should be held.

Arguments:

    None.

Return Value:

    True if this is really a deadlock, false to exonerate.

--*/    
{
    PAVRF_DEADLOCK_NODE innerNode,outerNode;
    ULONG innerParticipant,outerParticipant;
    ULONG numberOfParticipants;

    ULONG currentParticipant;

    numberOfParticipants = AVrfpDeadlockGlobals->NumberOfParticipants;

    //
    // Note -- this isn't a particularly efficient way to do this. However,
    // it is a particularly easy way to do it. This function should be called
    // extremely rarely -- so IMO there isn't really a problem here.
    //

    //
    // Outer loop
    //
    outerParticipant = numberOfParticipants;
    while (outerParticipant > 1) {
        outerParticipant--;

        for (outerNode = AVrfpDeadlockGlobals->Participant[outerParticipant]->Parent;
            outerNode != NULL;
            outerNode = outerNode->Parent ) {

            //
            // Inner loop
            //
            innerParticipant = outerParticipant-1;
            while (innerParticipant) {
                innerParticipant--;

                for (innerNode = AVrfpDeadlockGlobals->Participant[innerParticipant]->Parent;
                    innerNode != NULL;
                    innerNode = innerNode->Parent) {

                    if (innerNode->Root->ResourceAddress == outerNode->Root->ResourceAddress) {
                        //
                        // The twain shall meet -- this is not a deadlock
                        //
                        AVrfpDeadlockGlobals->ABC_ACB_Skipped++;                                           
                        return FALSE;
                    }
                }

            }
        }
    }

    for (currentParticipant = 1; currentParticipant < numberOfParticipants; currentParticipant += 1) {
        if (AVrfpDeadlockGlobals->Participant[currentParticipant]->Root->ResourceAddress == 
            AVrfpDeadlockGlobals->Participant[currentParticipant-1]->Root->ResourceAddress) {
            //
            // This is the head of a chain...
            //
            if (AVrfpDeadlockGlobals->Participant[currentParticipant-1]->OnlyTryAcquireUsed == TRUE) {
                //
                // Head of a chain used only try acquire. This can never cause a deadlock.
                //
                return FALSE;

            }
        }

    }



    return TRUE;

}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// Resource management
/////////////////////////////////////////////////////////////////////

PAVRF_DEADLOCK_RESOURCE
AVrfpDeadlockSearchResource(
    IN PVOID ResourceAddress
    )
/*++

Routine Description:

    This routine finds the resource descriptor structure for a
    resource if one exists.

Arguments:

    ResourceAddress: Address of the resource in question (as used by
       the kernel).     

Return Value:

    PAVRF_DEADLOCK_RESOURCE structure describing the resource, if available,
    or else NULL

    Note. The caller of the function should hold the database lock.

--*/    
{
    PLIST_ENTRY ListHead;
    PLIST_ENTRY Current;
    PAVRF_DEADLOCK_RESOURCE Resource;

    ListHead = AVrfpDeadlockDatabaseHash (AVrfpDeadlockGlobals->ResourceDatabase, 
                                          ResourceAddress);    

    if (IsListEmpty (ListHead)) {
        return NULL;
    }

    //
    // Trim resources from this hash list. It has nothing to do with searching
    // but it is a good place to do this operation.
    //

    AVrfpDeadlockTrimResources (ListHead);

    //
    // Now search the bucket for our resource.
    //

    Current = ListHead->Flink;

    while (Current != ListHead) {

        Resource = CONTAINING_RECORD(Current,
                                     AVRF_DEADLOCK_RESOURCE,
                                     HashChainList);

        if (Resource->ResourceAddress == ResourceAddress) {

            return Resource;
        }

        Current = Current->Flink;
    }

    return NULL;
}


BOOLEAN
AVrfpDeadlockResourceInitialize(
    IN PVOID Resource,
    IN AVRF_DEADLOCK_RESOURCE_TYPE Type,
    IN PVOID Caller
    )
/*++

Routine Description:

    This routine adds an entry for a new resource to our deadlock detection
    database.

Arguments:

    Resource: Address of the resource in question as used by the kernel.

    Type: Type of the resource.
    
    Caller: address of the caller
    
    DoNotAcquireLock: if true it means the call is done internally and the
        deadlock verifier lock is already held.

Return Value:

    True if we created and initialized a new RESOURCE structure.

--*/    
{
    PVOID ReservedResource;
    BOOLEAN Result;

    //
    // If we are not initialized or package is not enabled
    // we return immediately.
    //

    if (! AVrfpDeadlockCanProceed()) {
        return FALSE;
    }

    // silviuc: I do not need all this gymnastics with allocations out of locks.
    ReservedResource = AVrfpDeadlockAllocate (AVrfpDeadlockResource);

    AVrfpDeadlockDetectionLock ();

    Result = AVrfpDeadlockAddResource (Resource,
                                       Type,
                                       Caller,
                                       ReservedResource);

    AVrfpDeadlockDetectionUnlock ();
    return Result;
}


BOOLEAN
AVrfpDeadlockAddResource(
    IN PVOID Resource,
    IN AVRF_DEADLOCK_RESOURCE_TYPE Type,
    IN PVOID Caller,
    IN PVOID ReservedResource
    )
/*++

Routine Description:

    This routine adds an entry for a new resource to our deadlock detection
    database.

Arguments:

    Resource: Address of the resource in question as used by the kernel.

    Type: Type of the resource.
    
    Caller: address of the caller
    
    ReservedResource: block of memory to be used by the new resource.        

Return Value:

    True if we created and initialized a new RESOURCE structure.

--*/    
{
    PLIST_ENTRY HashBin;
    PAVRF_DEADLOCK_RESOURCE ResourceRoot;
    ULONG HashValue;
    ULONG DeadlockFlags;
    BOOLEAN ReturnValue = FALSE;

    //
    // Check if this resource was initialized before.
    // This would be a bug in most of the cases.
    //

    ResourceRoot = AVrfpDeadlockSearchResource (Resource);

    if (ResourceRoot) {

        DeadlockFlags = AVrfpDeadlockResourceTypeInfo[Type];

        //
        // Check if we are reinitializing a good resource.
        //

        AVrfpDeadlockReportIssue (AVRF_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION,
                                  (ULONG_PTR)Resource,
                                  (ULONG_PTR)ResourceRoot,
                                  0);

        ReturnValue = TRUE;
        goto Exit;
    }

    //
    // At this point we know for sure the resource is not represented in the
    // deadlock verifier database.
    //

    ASSERT (AVrfpDeadlockSearchResource (Resource) == NULL);

    //
    // Use reserved memory for the new resource.
    // Set ReservedResource to null to signal that memory has 
    // been used. This will prevent freeing it at the end.
    //

    ResourceRoot = ReservedResource;
    ReservedResource = NULL;

    if (ResourceRoot == NULL) {

        ReturnValue = FALSE;
        goto Exit;
    }

    //
    // Fill information about resource.
    //

    RtlZeroMemory (ResourceRoot, sizeof(AVRF_DEADLOCK_RESOURCE));

    ResourceRoot->Type = Type;
    ResourceRoot->ResourceAddress = Resource;

    InitializeListHead (&ResourceRoot->ResourceList);

    //
    // Capture the stack trace of the guy that creates the resource first.
    // This should happen when resource gets initialized or during the first
    // acquire.
    //    

    RtlCaptureStackBackTrace (2,
                              MAX_TRACE_DEPTH,
                              ResourceRoot->StackTrace,
                              &HashValue);    

    ResourceRoot->StackTrace[0] = Caller;

    //
    // Figure out which hash bin this resource corresponds to.
    //

    HashBin = AVrfpDeadlockDatabaseHash (AVrfpDeadlockGlobals->ResourceDatabase, Resource);

    //
    // Now add to the corresponding hash bin
    //

    InsertHeadList(HashBin, &ResourceRoot->HashChainList);

    ReturnValue = TRUE;

    Exit:

    if (ReservedResource) {
        AVrfpDeadlockFree (ReservedResource, AVrfpDeadlockResource);
    }

    return ReturnValue;
}


BOOLEAN
AVrfpDeadlockSimilarNode (
    IN PVOID Resource,
    IN BOOLEAN TryNode,
    IN PAVRF_DEADLOCK_NODE Node
    )
/*++

Routine description:

    This routine determines if an acquisition with the (resource, try)
    characteristics is already represented in the Node parameter.
    
    We used to match nodes based on (resource, thread, stack trace, try)
    4-tuplet but this really causes an explosion in the number of nodes.
    Such a method would yield more accurate proofs but does not affect
    the correctness of the deadlock detection algorithms.
        
Return value:    

    True if similar node.
    
 --*/
{
    ASSERT (Node);
    ASSERT (Node->Root);

    if (Resource == Node->Root->ResourceAddress 
        && TryNode == Node->OnlyTryAcquireUsed) {

        //
        // Second condition is important to keep nodes for TryAcquire operations
        // separated from normal acquires. A TryAcquire cannot cause a deadlock
        // and therefore we have to be careful not to report bogus deadlocks.
        //

        return TRUE;
    }
    else {

        return FALSE;
    }
}


VOID
AVrfpDeadlockAcquireResource (
    IN PVOID Resource,
    IN AVRF_DEADLOCK_RESOURCE_TYPE Type,
    IN HANDLE Thread,   
    IN BOOLEAN TryAcquire,
    IN PVOID Caller
    )
/*++

Routine Description:

    This routine makes sure that it is ok to acquire the resource without
    causing a deadlock. It will also update the resource graph with the new
    resource acquisition.

Arguments:

    Resource: Address of the resource in question as used by kernel.

    Type: Type of the resource.
    
    Thread: thread attempting to acquire the resource
    
    TryAcquire: true if this is a tryacquire() operation
    
    Caller: address of the caller

Return Value:

    None.

--*/    
{
    HANDLE CurrentThread;
    PAVRF_DEADLOCK_THREAD ThreadEntry;
    PAVRF_DEADLOCK_NODE CurrentNode;
    PAVRF_DEADLOCK_NODE NewNode;
    PAVRF_DEADLOCK_RESOURCE ResourceRoot;
    PLIST_ENTRY Current;
    ULONG HashValue;
    ULONG DeadlockFlags;
    BOOLEAN CreatingRootNode = FALSE;
    BOOLEAN ThreadCreated = FALSE;
    BOOLEAN AddResult;
    PVOID ReservedThread;
    PVOID ReservedNode;
    PVOID ReservedResource;
    PAVRF_DEADLOCK_NODE ThreadCurrentNode;

    CurrentNode = NULL;
    ThreadEntry = NULL;
    ThreadCurrentNode = NULL;

    //
    // If we are not initialized or package is not enabled
    // we return immediately.
    //

    if (! AVrfpDeadlockCanProceed()) {
        return;
    }

    CurrentThread = Thread;

    DeadlockFlags = AVrfpDeadlockResourceTypeInfo[Type];

    //
    // Before getting into the real stuff trim the pool cache.
    // This needs to happen out of any locks.
    //

    AVrfpDeadlockTrimPoolCache ();

    //
    // Reserve resources that might be needed. If upon exit these
    // variables are null it means the allocation either failed or was used.
    // In both cases we do not need to free anything.
    //

    ReservedThread = AVrfpDeadlockAllocate (AVrfpDeadlockThread);
    ReservedNode = AVrfpDeadlockAllocate (AVrfpDeadlockNode);
    ReservedResource = AVrfpDeadlockAllocate (AVrfpDeadlockResource);

    //
    // Lock the deadlock database.
    //

    AVrfpDeadlockDetectionLock();

    //
    // Allocate a node that might be needed. If we will not use it
    // we will deallocate it at the end. If we fail to allocate
    // we will return immediately.
    //

    NewNode = ReservedNode;
    ReservedNode = NULL;

    if (NewNode == NULL) {
        goto Exit;
    }

    //
    // Find the thread descriptor. If there is none we will create one.
    //

    ThreadEntry = AVrfpDeadlockSearchThread (CurrentThread);        

    if (ThreadEntry == NULL) {

        ThreadEntry = AVrfpDeadlockAddThread (CurrentThread, ReservedThread);
        ReservedThread = NULL;

        if (ThreadEntry == NULL) {

            //
            // If we cannot allocate a new thread entry then
            // no deadlock detection will happen.
            //

            goto Exit;
        }

        ThreadCreated = TRUE;
    }

#if DBG
    if (ThreadEntry->CurrentTopNode != NULL) {

        ASSERT(ThreadEntry->CurrentTopNode->Root->ThreadOwner == ThreadEntry);
        ASSERT(ThreadEntry->CurrentTopNode->ThreadEntry == ThreadEntry);
        ASSERT(ThreadEntry->NodeCount != 0);
        ASSERT(ThreadEntry->CurrentTopNode->Active != 0);
        ASSERT(ThreadEntry->CurrentTopNode->Root->NodeCount != 0);
    }
#endif

    //
    // Find the resource descriptor. If we do not find a descriptor
    // we will create one on the fly.
    //

    ResourceRoot = AVrfpDeadlockSearchResource (Resource);

    if (ResourceRoot == NULL) {

        //
        // Complain about the resource not being initialized. After that 
        // in order to continue we initialize a resource.
        //

        AVrfpDeadlockReportIssue (AVRF_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE,
                                  (ULONG_PTR) Resource,
                                  (ULONG_PTR) NULL,
                                  (ULONG_PTR) NULL);

        AddResult = AVrfpDeadlockAddResource (Resource, 
                                              Type, 
                                              Caller, 
                                              ReservedResource);

        ReservedResource = NULL;

        if (AddResult == FALSE) {

            //
            // If we failed to add the resource then no deadlock detection.
            //

            if (ThreadCreated) {
                AVrfpDeadlockDeleteThread (ThreadEntry, FALSE);
            }

            goto Exit;
        }

        //
        // Search again the resource. This time we should find it.
        //

        ResourceRoot = AVrfpDeadlockSearchResource (Resource);
    }

    //
    // At this point we have a THREAD and a RESOURCE to play with.
    // In addition we are just about to acquire the resource which means
    // there should not be another thread owning unless it is a recursive
    // acquisition.
    //

    ASSERT (ResourceRoot);
    ASSERT (ThreadEntry); 

    ThreadCurrentNode = ThreadEntry->CurrentTopNode;

    //
    // silviuc: update comment and maybe break?
    // Since we just acquired the resource the valid value for ThreadOwner is
    // null or ThreadEntry (for a recursive acquisition). This might not be
    // true if we missed a release() from an unverified driver. So we will
    // not complain about it. We will just put the resource in a consistent
    // state and continue;
    //    

    if (ResourceRoot->ThreadOwner) {
        if (ResourceRoot->ThreadOwner != ThreadEntry) {
            ResourceRoot->RecursionCount = 0;
        }
        else {
            ASSERT (ResourceRoot->RecursionCount > 0);
        }
    }
    else {
        ASSERT (ResourceRoot->RecursionCount == 0);
    }

    ResourceRoot->ThreadOwner = ThreadEntry;    
    ResourceRoot->RecursionCount += 1;

    //
    // Check if thread holds any resources. If it does we will have to determine
    // at that local point in the dependency graph if we need to create a
    // new node. If this is the first resource acquired by the thread we need
    // to create a new root node or reuse one created in the past.
    //    

    if (ThreadCurrentNode != NULL) {

        //
        // If we get here, the current thread had already acquired resources.        
        // Check to see if this resource has already been acquired.
        // 

        if (ResourceRoot->RecursionCount > 1) {

            //
            // Recursive acquisition is OK for some resources...
            //

            if ((DeadlockFlags & AVRF_DEADLOCK_FLAG_RECURSIVE_ACQUISITION_OK) != 0) {

                //
                // Recursion can't cause a deadlock. Don't set CurrentNode 
                // since we don't want to move any pointers.
                //

                goto Exit;

            }
            else {

                //
                // This is a recursive acquire for a resource type that is not allowed
                // to acquire recursively. Note on continuing from here: we have a recursion
                // count of two which will come in handy when the resources are released.
                //

                AVrfpDeadlockReportIssue (AVRF_DEADLOCK_ISSUE_SELF_DEADLOCK,
                                       (ULONG_PTR)Resource,
                                       (ULONG_PTR)ResourceRoot,
                                       (ULONG_PTR)ThreadEntry);

                goto Exit;
            }
        }

        //
        // If link already exists, update pointers and exit.
        // otherwise check for deadlocks and create a new node        
        //

        Current = ThreadCurrentNode->ChildrenList.Flink;

        while (Current != &(ThreadCurrentNode->ChildrenList)) {

            CurrentNode = CONTAINING_RECORD (Current,
                                             AVRF_DEADLOCK_NODE,
                                             SiblingsList);

            Current = Current->Flink;

            if (AVrfpDeadlockSimilarNode (Resource, TryAcquire, CurrentNode)) {

                //
                // We have found a link. A link that already exists doesn't have 
                // to be checked for a deadlock because it would have been caught 
                // when the link was created in the first place. We can just update 
                // the pointers to reflect the new resource acquired and exit.
                //
                // We apply our graph compression function to minimize duplicates.
                //                

                AVrfpDeadlockCheckDuplicatesAmongChildren (ThreadCurrentNode,
                                                           CurrentNode);

                goto Exit;
            }
        }

        //
        // Now we know that we're in it for the long haul. We must create a new
        // link and make sure that it doesn't cause a deadlock. Later in the 
        // function CurrentNode being null will signify that we need to create
        // a new node.
        //

        CurrentNode = NULL;

        //
        // We will analyze deadlock if the resource just about to be acquired
        // was acquired before and there are nodes in the graph for the
        // resource. Try acquire can not be the cause of a deadlock. 
        // Don't analyze on try acquires.
        //

        if (ResourceRoot->NodeCount > 0 && TryAcquire == FALSE) {

            if (AVrfpDeadlockAnalyze (Resource,  ThreadCurrentNode, TRUE, 0)) {

                //
                // If we are here we detected deadlock. The analyze() function
                // does all the reporting. Being here means we hit `g' in the 
                // debugger. We will just exit and do not add this resource 
                // to the graph.
                //

                goto Exit;
            }
        }
    }
    else {

        //
        // Thread does not have any resources acquired. We have to figure out
        // if this is a scenario we have encountered in the past by looking
        // at all nodes (that are roots) for the resource to be acquired.
        // Note that all this is bookkeeping but we cannot encounter a deadlock
        // from now on.
        //

        PLIST_ENTRY CurrentListEntry;
        PAVRF_DEADLOCK_NODE Node = NULL;
        BOOLEAN FoundNode = FALSE;

        CurrentListEntry = ResourceRoot->ResourceList.Flink;

        while (CurrentListEntry != &(ResourceRoot->ResourceList)) {

            Node = CONTAINING_RECORD (CurrentListEntry,
                                      AVRF_DEADLOCK_NODE,
                                      ResourceList);

            CurrentListEntry = Node->ResourceList.Flink;

            if (Node->Parent == NULL) {

                if (AVrfpDeadlockSimilarNode (Resource, TryAcquire, Node)) {

                    //
                    // We apply our graph compression function to minimize duplicates.
                    //

                    AVrfpDeadlockCheckDuplicatesAmongRoots (Node);

                    FoundNode = TRUE;
                    break;
                }
            }
        }

        if (FoundNode) {

            CurrentNode = Node;

            goto Exit;
        }
        else {

            CreatingRootNode = TRUE;
        }
    }

    //
    // At this moment we know for sure the new link will not cause
    // a deadlock. We will create the new resource node.
    //

    if (NewNode != NULL) {

        CurrentNode = NewNode;

        //
        // Set newnode to NULL to signify it has been used -- otherwise it 
        // will get freed at the end of this function.
        //

        NewNode = NULL;

        //
        // Initialize the new resource node
        //

        RtlZeroMemory (CurrentNode, sizeof *CurrentNode);

        CurrentNode->Active = 0;
        CurrentNode->Parent = ThreadCurrentNode;
        CurrentNode->Root = ResourceRoot;
        CurrentNode->SequenceNumber = AVrfpDeadlockGlobals->SequenceNumber;

        InitializeListHead (&(CurrentNode->ChildrenList));

        //
        // Mark the TryAcquire type of the node. 
        //

        CurrentNode->OnlyTryAcquireUsed = TryAcquire;

        //
        // Add to the children list of the parent.
        //

        if (! CreatingRootNode) {

            InsertHeadList(&(ThreadCurrentNode->ChildrenList),
                           &(CurrentNode->SiblingsList));
        }

        //
        // Register the new resource node in the list of nodes maintained
        // for this resource.
        //

        InsertHeadList(&(ResourceRoot->ResourceList),
                       &(CurrentNode->ResourceList));

        ResourceRoot->NodeCount += 1;

        if (ResourceRoot->NodeCount > 0xFFF0) {
            AVrfpDeadlockState.ResourceNodeCountOverflow = 1;
        }

        //
        // Add to the graph statistics.
        //
        {
            ULONG Level;

            Level = AVrfpDeadlockNodeLevel (CurrentNode);

            if (Level < 8) {
                AVrfpDeadlockGlobals->GraphNodes[Level] += 1;
            }
        }
    }

    //
    //  Exit point.
    //

    Exit:

    //
    // Add information we use to identify the culprit should
    // a deadlock occur
    //

    if (CurrentNode) {

        ASSERT (ThreadEntry);
        ASSERT (ThreadCurrentNode == CurrentNode->Parent);

        CurrentNode->Active = 1;

        //
        // The node should have thread entry field null either because
        // it was newly created or because the node was released in the
        // past and therefore the field was zeroed.
        //
        // silviuc: true? What about if we miss release() operations.
        //

        ASSERT (CurrentNode->ThreadEntry == NULL);

        CurrentNode->ThreadEntry = ThreadEntry;

        ThreadEntry->CurrentTopNode = CurrentNode;

        ThreadEntry->NodeCount += 1;

        if (ThreadEntry->NodeCount <= 8) {
            AVrfpDeadlockGlobals->NodeLevelCounter[ThreadEntry->NodeCount - 1] += 1;
        }
        else {
            AVrfpDeadlockGlobals->NodeLevelCounter[7] += 1;
        }

        //
        // If we have a parent, save the parent's stack trace
        //             

        if (CurrentNode->Parent) {

            RtlCopyMemory(CurrentNode->ParentStackTrace, 
                          CurrentNode->Parent->StackTrace, 
                          sizeof (CurrentNode->ParentStackTrace));
        }

        //
        // Capture stack trace for the current acquire. 
        //

        RtlCaptureStackBackTrace (2,
                                  MAX_TRACE_DEPTH,
                                  CurrentNode->StackTrace,
                                  &HashValue);

        if (CurrentNode->Parent) {
            CurrentNode->ParentStackTrace[0] = CurrentNode->Parent->StackTrace[0];
        }

        CurrentNode->StackTrace[0] = Caller;

        //
        // Copy the trace for the last acquire in the resource object.
        //

        RtlCopyMemory (CurrentNode->Root->LastAcquireTrace,
                       CurrentNode->StackTrace,
                       sizeof (CurrentNode->Root->LastAcquireTrace));
    }

    //
    // We allocated space for a new node but it didn't get used -- put it back 
    // in the list (don't worry this doesn't do a real 'free' it just puts it 
    // in a free list).
    //

    if (NewNode != NULL) {

        AVrfpDeadlockFree (NewNode, AVrfpDeadlockNode);
    }

    //
    // Free up unused reserved resources.
    // Release deadlock database and return.
    //

    if (ReservedResource) {
        AVrfpDeadlockFree (ReservedResource, AVrfpDeadlockResource);
    }

    if (ReservedNode) {
        AVrfpDeadlockFree (ReservedNode, AVrfpDeadlockNode);
    }

    if (ReservedThread) {
        AVrfpDeadlockFree (ReservedThread, AVrfpDeadlockThread);
    }

    AVrfpDeadlockDetectionUnlock();

    return;
}


VOID
AVrfpDeadlockReleaseResource(
    IN PVOID Resource,
    IN AVRF_DEADLOCK_RESOURCE_TYPE Type,
    IN HANDLE Thread,
    IN PVOID Caller
    )
/*++

Routine Description:

    This routine does the maintenance necessary to release resources from our
    deadlock detection database.

Arguments:

    Resource: Address of the resource in question.
    
    Thread: thread releasing the resource. In most of the cases this is the
        current thread but it might be different for resources that can be
        acquired in one thread and released in another one.
    
    Caller: address of the caller of release()

Return Value:

    None.
--*/    

{
    HANDLE CurrentThread;
    PAVRF_DEADLOCK_THREAD ThreadEntry;
    PAVRF_DEADLOCK_RESOURCE ResourceRoot;
    PAVRF_DEADLOCK_NODE ReleasedNode;
    ULONG HashValue;
    PAVRF_DEADLOCK_NODE ThreadCurrentNode;

    UNREFERENCED_PARAMETER (Caller);
    UNREFERENCED_PARAMETER (Type);

    //
    // If we aren't initialized or package is not enabled
    // we return immediately.
    //

    if (! AVrfpDeadlockCanProceed()) {
        return;
    }

    ReleasedNode = NULL;
    CurrentThread = Thread;
    ThreadEntry = NULL;

    AVrfpDeadlockDetectionLock();

    ResourceRoot = AVrfpDeadlockSearchResource (Resource);

    if (ResourceRoot == NULL) {

        // silviuc: we should report an issue. It cannot happen in u-mode.
        //
        // Release called with a resource address that was never
        // stored in our resource database. This can happen in
        // the following circumstances:
        //
        // (a) resource is released but we never seen it before 
        //     because it was acquired in an unverified driver.
        //
        // (b) we have encountered allocation failures that prevented
        //     us from completing an acquire() or initialize().
        //
        // All are legitimate cases and therefore we just ignore the
        // release operation.
        //

        goto Exit;
    }

    //
    // Check if we are trying to release a resource that was never
    // acquired.
    //

    if (ResourceRoot->RecursionCount == 0) {

        AVrfpDeadlockReportIssue (AVRF_DEADLOCK_ISSUE_UNACQUIRED_RESOURCE,
                                  (ULONG_PTR)Resource,
                                  (ULONG_PTR)ResourceRoot,
                                  (ULONG_PTR)AVrfpDeadlockSearchThread(CurrentThread));
        goto Exit;
    }

    //
    // Look for this thread in our thread list. Note we are looking actually 
    // for the thread that acquired the resource -- not the current one
    // It should, in fact be the current one, but if the resource is being released 
    // in a different thread from the one it was acquired in, we need the original.
    //

    ASSERT (ResourceRoot->RecursionCount > 0);
    ASSERT (ResourceRoot->ThreadOwner);

    ThreadEntry = ResourceRoot->ThreadOwner;

    if (ThreadEntry->Thread != CurrentThread) {

        //
        // silviuc: we have to report this. It is not allowed in U-mode.
        //
        // Someone acquired a resource that is released in another thread.
        // This is bad design but we have to live with it.
        //
        // NB. If this occurrs, we may call a non-deadlock a deadlock.
        //     For example, we see a simple deadlock -- AB BA
        //     If another thread releases B, there won't actually
        //     be a deadlock. Kind of annoying and ugly.
        //

#if DBG
        DbgPrint("Thread %p acquired resource %p but thread %p released it\n",
                 ThreadEntry->Thread, Resource, CurrentThread );

        AVrfpDeadlockReportIssue (AVRF_DEADLOCK_ISSUE_UNEXPECTED_THREAD,
                               (ULONG_PTR)Resource,
                               (ULONG_PTR)ThreadEntry->Thread,
                               (ULONG_PTR)CurrentThread
                              );
#endif

        //
        // If we don't want this to be fatal, in order to
        // continue we must pretend that the current
        // thread is the resource's owner.
        //

        CurrentThread = ThreadEntry->Thread;
    }

    //
    // In this moment we have a resource (ResourceRoot) and a
    // thread (ThreadEntry) to play with.
    //

    ThreadCurrentNode = ThreadEntry->CurrentTopNode;

    ASSERT (ResourceRoot && ThreadEntry);
    ASSERT (ThreadCurrentNode);
    ASSERT (ThreadCurrentNode->Root);
    ASSERT (ThreadEntry->NodeCount > 0);

    ResourceRoot->RecursionCount -= 1;

    if (ResourceRoot->RecursionCount > 0) {

        //
        // Just decrement the recursion count and do not change any state
        //        

        goto Exit;
    }

    //
    // Wipe out the resource owner.
    //

    ResourceRoot->ThreadOwner = NULL;

    AVrfpDeadlockGlobals->TotalReleases += 1;

    //
    // Check for out of order releases
    //

    if (ThreadCurrentNode->Root != ResourceRoot) {

        AVrfpDeadlockGlobals->OutOfOrderReleases += 1;

        //
        // Getting here means that somebody acquires a then b then tries
        // to release a before b. This is bad for certain kinds of resources,
        // and for others we have to look the other way.
        //

        if ((AVrfpDeadlockResourceTypeInfo[ThreadCurrentNode->Root->Type] &
             AVRF_DEADLOCK_FLAG_REVERSE_RELEASE_OK) == 0) {

            // silviuc: In u-mode is always allowed.
            DbgPrint("Deadlock detection: Must release resources in reverse-order\n");
            DbgPrint("Resource %p acquired before resource %p -- \n"
                     "Current thread (%p) is trying to release it first\n",
                     Resource,
                     ThreadCurrentNode->Root->ResourceAddress,
                     ThreadEntry);

            AVrfpDeadlockReportIssue (AVRF_DEADLOCK_ISSUE_UNEXPECTED_RELEASE,
                                   (ULONG_PTR)Resource,
                                   (ULONG_PTR)ThreadCurrentNode->Root->ResourceAddress,
                                   (ULONG_PTR)ThreadEntry);
        }

        //
        // We need to mark the node for the out of order released resource as
        // not active so that other threads will be able to acquire it.
        //

        {
            PAVRF_DEADLOCK_NODE Current;

            ASSERT (ThreadCurrentNode->Active == 1);
            ASSERT (ThreadCurrentNode->ThreadEntry == ThreadEntry);

            Current = ThreadCurrentNode;

            while (Current != NULL) {

                if (Current->Root == ResourceRoot) {

                    ASSERT (Current->Active == 1);
                    ASSERT (Current->Root->RecursionCount == 0);
                    ASSERT (Current->ThreadEntry == ThreadEntry);

                    Current->Active = 0;
                    ReleasedNode = Current;

                    break;
                }

                Current = Current->Parent;
            }

            if (Current == NULL) {

                //
                // If we do not manage to find an active node we must be in an
                // weird state. The resource must be here or else we would have 
                // gotten an `unxpected release' bugcheck.
                //

                ASSERT (0);
            }
            else {

                //
                // Mark the fact that this node represents a resource
                // that can be released out of order. This information is
                // important while looking for cycles because this type of
                // nodes cannot cause a deadlock.
                //

                if (Current->ReleasedOutOfOrder == 0) {
                    AVrfpDeadlockGlobals->NodesReleasedOutOfOrder += 1;
                }

                Current->ReleasedOutOfOrder = 1;
            }
        }

    }
    else {

        //
        // We need to release the top node held by the thread.
        //

        ASSERT (ThreadCurrentNode->Active);

        ReleasedNode = ThreadCurrentNode;
        ReleasedNode->Active = 0;
    }

    //
    // Put the `CurrentNode' field of the thread in a consistent state.
    // It should point to the most recent active node that it owns.
    //

    while (ThreadEntry->CurrentTopNode) {

        if (ThreadEntry->CurrentTopNode->Active == 1) {
            if (ThreadEntry->CurrentTopNode->ThreadEntry == ThreadEntry) {
                break;
            }
        }

        ThreadEntry->CurrentTopNode = ThreadEntry->CurrentTopNode->Parent;
    }

    Exit:

    //
    // Properly release the node if there is one to be released.
    //

    if (ReleasedNode) {

        ASSERT (ReleasedNode->Active == 0);
        ASSERT (ReleasedNode->Root->ThreadOwner == 0);
        ASSERT (ReleasedNode->Root->RecursionCount == 0);
        ASSERT (ReleasedNode->ThreadEntry == ThreadEntry);
        ASSERT (ThreadEntry->NodeCount > 0);

        ASSERT (ThreadEntry->CurrentTopNode != ReleasedNode);

        ReleasedNode->ThreadEntry = NULL;
        ThreadEntry->NodeCount -= 1;

#if DBG
        AVrfpDeadlockCheckNodeConsistency (ReleasedNode, FALSE);
        AVrfpDeadlockCheckResourceConsistency (ReleasedNode->Root, FALSE);
        AVrfpDeadlockCheckThreadConsistency (ThreadEntry, FALSE);
#endif

        if (ThreadEntry && ThreadEntry->NodeCount == 0) {
            AVrfpDeadlockDeleteThread (ThreadEntry, FALSE);
        }

        //
        // N.B. Since this is a root node with no children we can delete 
        // the node too. This would be important to keep memory low. A single node
        // can never be the cause of a deadlock. However there are thousands of 
        // resources used like this and constantly creating and deleting them
        // will create a bottleneck. So we prefer to keep them around.
        //
#if 0
        if (ReleasedNode->Parent == NULL && IsListEmpty(&(ReleasedNode->ChildrenList))) {
            AVrfpDeadlockDeleteNode (ReleasedNode, FALSE);
            AVrfpDeadlockGlobals->RootNodesDeleted += 1;
        }
#endif
    }

    //
    // Capture the trace for the last release in the resource object.
    //

    if (ResourceRoot) {

        RtlCaptureStackBackTrace (2,
                                  MAX_TRACE_DEPTH,
                                  ResourceRoot->LastReleaseTrace,
                                  &HashValue);    
    }

    AVrfpDeadlockDetectionUnlock ();
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Thread management
/////////////////////////////////////////////////////////////////////

PAVRF_DEADLOCK_THREAD
AVrfpDeadlockSearchThread (
    HANDLE Thread
    )
/*++

Routine Description:

    This routine searches for a thread in the thread database.

    The function assumes the deadlock database lock is held.

Arguments:

    Thread - thread address

Return Value:

    Address of AVRF_DEADLOCK_THREAD structure if thread was found.
    Null otherwise.

--*/    
{
    PLIST_ENTRY Current;
    PLIST_ENTRY ListHead;
    PAVRF_DEADLOCK_THREAD ThreadInfo;

    ThreadInfo = NULL;

    ListHead = AVrfpDeadlockDatabaseHash (AVrfpDeadlockGlobals->ThreadDatabase, Thread);

    if (IsListEmpty(ListHead)) {
        return NULL;
    }

    Current = ListHead->Flink;

    while (Current != ListHead) {

        ThreadInfo = CONTAINING_RECORD (Current,
                                        AVRF_DEADLOCK_THREAD,
                                        ListEntry);

        if (ThreadInfo->Thread == Thread) {
            return ThreadInfo;
        }

        Current = Current->Flink;
    }

    return NULL;
}


PAVRF_DEADLOCK_THREAD
AVrfpDeadlockAddThread (
    HANDLE Thread,
    PVOID ReservedThread
    )
/*++

Routine Description:

    This routine adds a new thread to the thread database.

    The function assumes the deadlock database lock is held. 

Arguments:

    Thread - thread address

Return Value:

    Address of the AVRF_DEADLOCK_THREAD structure just added.
    Null if allocation failed.
--*/    
{
    PAVRF_DEADLOCK_THREAD ThreadInfo;    
    PLIST_ENTRY HashBin;

    //
    // Use reserved block for the new thread. Set ReservedThread
    // to null to signal that block was used. 
    //

    ThreadInfo = ReservedThread;
    ReservedThread = NULL;

    if (ThreadInfo == NULL) {
        return NULL;
    }

    RtlZeroMemory (ThreadInfo, sizeof *ThreadInfo);

    ThreadInfo->Thread = Thread;   

    HashBin = AVrfpDeadlockDatabaseHash (AVrfpDeadlockGlobals->ThreadDatabase, Thread);

    InsertHeadList(HashBin, &ThreadInfo->ListEntry);

    return ThreadInfo;
}


VOID
AVrfpDeadlockDeleteThread (
    PAVRF_DEADLOCK_THREAD Thread,
    BOOLEAN Cleanup
    )
/*++

Routine Description:

    This routine deletes a thread.

Arguments:

    Thread - thread address

    Cleanup - true if this is a call generated from DeadlockDetectionCleanup().

Return Value:

    None.
--*/    
{
    if (Cleanup == FALSE) {

        if (Thread->NodeCount != 0 
            || Thread->CurrentTopNode != NULL) {

            //
            // A thread should not be deleted while it has resources acquired.
            //

            AVrfpDeadlockReportIssue (AVRF_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES,
                                   (ULONG_PTR)(Thread->Thread),
                                   (ULONG_PTR)(Thread),
                                   (ULONG_PTR)0);    
        }
        else {

            ASSERT (Thread->NodeCount == 0);
        }

    }

    RemoveEntryList (&(Thread->ListEntry));

    AVrfpDeadlockFree (Thread, AVrfpDeadlockThread);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Allocate/Free
/////////////////////////////////////////////////////////////////////


PVOID
AVrfpDeadlockAllocateFromPoolCache (
    PULONG Count,
    ULONG MaximumCount,
    PLIST_ENTRY List,
    SIZE_T Offset
    )
{
    PVOID Address = NULL;
    PLIST_ENTRY Entry;

    UNREFERENCED_PARAMETER (MaximumCount);

    if (*Count > 0) {

        *Count -= 1;
        Entry = RemoveHeadList (List);
        Address = (PVOID)((SIZE_T)Entry - Offset);
    }

    return Address;
}


VOID
AVrfpDeadlockFreeIntoPoolCache (
    PVOID Object,
    PULONG Count,
    PLIST_ENTRY List,
    SIZE_T Offset
    )
{
    PLIST_ENTRY Entry;

    Entry = (PLIST_ENTRY)((SIZE_T)Object + Offset);

    *Count += 1;
    InsertHeadList(List, Entry);
}


PVOID
AVrfpDeadlockAllocate (
    AVRF_DEADLOCK_ALLOC_TYPE Type
    )
/*++

Routine Description:

    This routine is used to allocate deadlock verifier structures, 
    that is nodes, resources and threads.

Arguments:

    Type - what structure do we need to allocate (node, resource or thread).

Return Value:

    Address of the newly allocate structure or null if allocation failed.

Side effects:

    If allocation fails the routine will bump the AllocationFailures field
    from AVrfpDeadlockGlobals.
    
--*/    
{
    PVOID Address = NULL;
    SIZE_T Offset;
    SIZE_T Size = 0;

    //
    // If it is a resource, thread, or node alocation, see
    // if we have a pre-allocated one on the free list.
    //

    AVrfpDeadlockDetectionLock ();

    switch (Type) {
        
        case AVrfpDeadlockThread:

            Offset = (SIZE_T)(&(((PAVRF_DEADLOCK_THREAD)0)->FreeListEntry));
            Size = sizeof (AVRF_DEADLOCK_THREAD);

            Address = AVrfpDeadlockAllocateFromPoolCache (&(AVrfpDeadlockGlobals->FreeThreadCount),
                                                          AVRF_DEADLOCK_MAX_FREE_THREAD,
                                                          &(AVrfpDeadlockGlobals->FreeThreadList),
                                                          Offset);

            break;

        case AVrfpDeadlockResource:

            Offset = (SIZE_T)(&(((PAVRF_DEADLOCK_RESOURCE)0)->FreeListEntry));
            Size = sizeof (AVRF_DEADLOCK_RESOURCE);

            Address = AVrfpDeadlockAllocateFromPoolCache (&(AVrfpDeadlockGlobals->FreeResourceCount),
                                                          AVRF_DEADLOCK_MAX_FREE_RESOURCE,
                                                          &(AVrfpDeadlockGlobals->FreeResourceList),
                                                          Offset);

            break;

        case AVrfpDeadlockNode:

            Offset = (SIZE_T)(&(((PAVRF_DEADLOCK_NODE)0)->FreeListEntry));
            Size = sizeof (AVRF_DEADLOCK_NODE);

            Address = AVrfpDeadlockAllocateFromPoolCache (&(AVrfpDeadlockGlobals->FreeNodeCount),
                                                          AVRF_DEADLOCK_MAX_FREE_NODE,
                                                          &(AVrfpDeadlockGlobals->FreeNodeList),
                                                          Offset);

            break;

        default:

            ASSERT (0);
            break;
    }        

    //
    // If we did not find anything then go to the process heap for a 
    // direct allocation. 
    //

    if (Address == NULL) {

        // silviuc: it is nice to release the lock but should we?
        AVrfpDeadlockDetectionUnlock (); 
        Address = AVrfpAllocate (Size);  
        AVrfpDeadlockDetectionLock ();
    }

    if (Address) {

        switch (Type) {
            
            case AVrfpDeadlockThread:
                AVrfpDeadlockGlobals->Threads[0] += 1;

                if (AVrfpDeadlockGlobals->Threads[0] > AVrfpDeadlockGlobals->Threads[1]) {
                    AVrfpDeadlockGlobals->Threads[1] = AVrfpDeadlockGlobals->Threads[0];
                }
                break;

            case AVrfpDeadlockResource:
                AVrfpDeadlockGlobals->Resources[0] += 1;

                if (AVrfpDeadlockGlobals->Resources[0] > AVrfpDeadlockGlobals->Resources[1]) {
                    AVrfpDeadlockGlobals->Resources[1] = AVrfpDeadlockGlobals->Resources[0];
                }
                break;

            case AVrfpDeadlockNode:
                AVrfpDeadlockGlobals->Nodes[0] += 1;

                if (AVrfpDeadlockGlobals->Nodes[0] > AVrfpDeadlockGlobals->Nodes[1]) {
                    AVrfpDeadlockGlobals->Nodes[1] = AVrfpDeadlockGlobals->Nodes[0];
                }
                break;

            default:
                ASSERT (0);
                break;
        }
    }
    else {

        AVrfpDeadlockState.AllocationFailures = 1;
        AVrfpDeadlockGlobals->AllocationFailures += 1;

        //
        // Note that making the AllocationFailures counter bigger than zero
        // essentially disables deadlock verification because the CanProceed()
        // routine will start returning false.
        //
    }

    //
    // Update statistics. No need to zero the block since every
    // call site takes care of this.
    //

    if (Address) {

#if DBG
        RtlFillMemory (Address, Size, 0xFF);
#endif
        AVrfpDeadlockGlobals->BytesAllocated += Size;
    }

    AVrfpDeadlockDetectionUnlock ();

    return Address;
}


VOID
AVrfpDeadlockFree (
    PVOID Object,
    AVRF_DEADLOCK_ALLOC_TYPE Type
    )
/*++

Routine Description:

    This routine deallocates a deadlock verifier structure (node, resource
    or thread). The function will place the block in the corrsponding cache
    based on the type of the structure. The routine never calls ExFreePool.

    The reason for not calling ExFreePool is that we get notifications from 
    ExFreePool every time it gets called. Sometimes the notification comes
    with pool locks held and therefore we cannot call again.

Arguments:

    Object - block to deallocate
    
    Type - type of object (node, resource, thread).

Return Value:

    None.

--*/
//
// silviuc: update comment
// Note ... if a thread, node, or resource is being freed, we must not
// call ExFreePool. Since the pool lock may be already held, calling ExFreePool
// would cause a recursive spinlock acquisition (which is bad).
// Instead, we move everything to a 'free' list and try to reuse.
// Non-thread-node-resource frees get ExFreePooled
//        
{
    SIZE_T Offset;
    SIZE_T Size = 0;

    switch (Type) {
        
        case AVrfpDeadlockThread:

            AVrfpDeadlockGlobals->Threads[0] -= 1;
            Size = sizeof (AVRF_DEADLOCK_THREAD);

            Offset = (SIZE_T)(&(((PAVRF_DEADLOCK_THREAD)0)->FreeListEntry));

            AVrfpDeadlockFreeIntoPoolCache (Object,
                                            &(AVrfpDeadlockGlobals->FreeThreadCount),
                                            &(AVrfpDeadlockGlobals->FreeThreadList),
                                            Offset);
            break;

        case AVrfpDeadlockResource:

            AVrfpDeadlockGlobals->Resources[0] -= 1;
            Size = sizeof (AVRF_DEADLOCK_RESOURCE);

            Offset = (SIZE_T)(&(((PAVRF_DEADLOCK_RESOURCE)0)->FreeListEntry));

            AVrfpDeadlockFreeIntoPoolCache (Object,
                                            &(AVrfpDeadlockGlobals->FreeResourceCount),
                                            &(AVrfpDeadlockGlobals->FreeResourceList),
                                            Offset);
            break;

        case AVrfpDeadlockNode:

            AVrfpDeadlockGlobals->Nodes[0] -= 1;
            Size = sizeof (AVRF_DEADLOCK_NODE);

            Offset = (SIZE_T)(&(((PAVRF_DEADLOCK_NODE)0)->FreeListEntry));

            AVrfpDeadlockFreeIntoPoolCache (Object,
                                            &(AVrfpDeadlockGlobals->FreeNodeCount),
                                            &(AVrfpDeadlockGlobals->FreeNodeList),
                                            Offset);
            break;

        default:

            ASSERT (0);
            break;
    }        

    AVrfpDeadlockGlobals->BytesAllocated -= Size;
}


VOID
AVrfpDeadlockTrimPoolCache (
    VOID
    )
/*++

Routine Description:

    // silviuc: update comment
    This function trims the pool caches to decent levels. It is carefully
    written to queue a work item to do the actual processing (freeing of pool)
    because the caller may hold various pool mutexes above us.

Arguments:

    None.
    
Return Value:

    None.

--*/    
{
    LOGICAL ShouldTrim = FALSE;
    AVrfpDeadlockDetectionLock ();

    if (AVrfpDeadlockGlobals->CacheReductionInProgress == TRUE) {
        AVrfpDeadlockDetectionUnlock ();
        return;
    }

    if ((AVrfpDeadlockGlobals->FreeThreadCount > AVRF_DEADLOCK_MAX_FREE_THREAD) ||
        (AVrfpDeadlockGlobals->FreeNodeCount > AVRF_DEADLOCK_MAX_FREE_NODE) ||
        (AVrfpDeadlockGlobals->FreeResourceCount > AVRF_DEADLOCK_MAX_FREE_RESOURCE)) {

        ShouldTrim = TRUE;
        
        AVrfpDeadlockGlobals->CacheReductionInProgress = TRUE;
        AVrfpDeadlockGlobals->PoolTrimCounter += 1;
    }

    AVrfpDeadlockDetectionUnlock ();

    if (ShouldTrim) {
        AVrfpDeadlockTrimPoolCacheWorker (NULL);
    }

    return;
}


VOID
AVrfpDeadlockTrimPoolCacheWorker (
    PVOID Parameter
    )
/*++

Routine Description:

    This function trims the pool caches to decent levels. It is carefully
    written so that ExFreePool is called without holding any deadlock
    verifier locks.

Arguments:

    None.
    
Return Value:

    None.

Environment:

    Worker thread, PASSIVE_LEVEL, no locks held.

--*/    
{
    LIST_ENTRY ListOfThreads;
    LIST_ENTRY ListOfNodes;
    LIST_ENTRY ListOfResources;
    PLIST_ENTRY Entry;
    LOGICAL CacheReductionNeeded;

    UNREFERENCED_PARAMETER (Parameter);

    CacheReductionNeeded = FALSE;

    InitializeListHead (&ListOfThreads);
    InitializeListHead (&ListOfNodes);
    InitializeListHead (&ListOfResources);

    AVrfpDeadlockDetectionLock ();

    while (AVrfpDeadlockGlobals->FreeThreadCount > AVRF_DEADLOCK_TRIM_TARGET_THREAD) {

        Entry = RemoveHeadList (&(AVrfpDeadlockGlobals->FreeThreadList));
        InsertTailList (&ListOfThreads, Entry);
        AVrfpDeadlockGlobals->FreeThreadCount -= 1;
        CacheReductionNeeded = TRUE;
    }

    while (AVrfpDeadlockGlobals->FreeNodeCount > AVRF_DEADLOCK_TRIM_TARGET_NODE) {

        Entry = RemoveHeadList (&(AVrfpDeadlockGlobals->FreeNodeList));
        InsertTailList (&ListOfNodes, Entry);
        AVrfpDeadlockGlobals->FreeNodeCount -= 1;
        CacheReductionNeeded = TRUE;
    }

    while (AVrfpDeadlockGlobals->FreeResourceCount > AVRF_DEADLOCK_TRIM_TARGET_RESOURCE) {

        Entry = RemoveHeadList (&(AVrfpDeadlockGlobals->FreeResourceList));
        InsertTailList (&ListOfResources, Entry);
        AVrfpDeadlockGlobals->FreeResourceCount -= 1;
        CacheReductionNeeded = TRUE;
    }

    //
    // Don't clear CacheReductionInProgress until the pool allocations are
    // freed to prevent needless recursion.
    //

    if (CacheReductionNeeded == FALSE) {
        AVrfpDeadlockGlobals->CacheReductionInProgress = FALSE;
        AVrfpDeadlockDetectionUnlock ();
        return;
    }

    AVrfpDeadlockDetectionUnlock ();

    //
    // Now, out of the deadlock verifier lock we can deallocate the 
    // blocks trimmed.
    //

    Entry = ListOfThreads.Flink;

    while (Entry != &ListOfThreads) {

        PAVRF_DEADLOCK_THREAD Block;

        Block = CONTAINING_RECORD (Entry,
                                   AVRF_DEADLOCK_THREAD,
                                   FreeListEntry);

        Entry = Entry->Flink;
        AVrfpFree (Block);
    }

    Entry = ListOfNodes.Flink;

    while (Entry != &ListOfNodes) {

        PAVRF_DEADLOCK_NODE Block;

        Block = CONTAINING_RECORD (Entry,
                                   AVRF_DEADLOCK_NODE,
                                   FreeListEntry);

        Entry = Entry->Flink;
        AVrfpFree (Block);
    }

    Entry = ListOfResources.Flink;

    while (Entry != &ListOfResources) {

        PAVRF_DEADLOCK_RESOURCE Block;

        Block = CONTAINING_RECORD (Entry,
                                   AVRF_DEADLOCK_RESOURCE,
                                   FreeListEntry);

        Entry = Entry->Flink;
        AVrfpFree (Block);
    }

    //
    // It's safe to clear CacheReductionInProgress now that the pool
    // allocations are freed.
    //

    AVrfpDeadlockDetectionLock ();
    AVrfpDeadlockGlobals->CacheReductionInProgress = FALSE;
    AVrfpDeadlockDetectionUnlock ();
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Error reporting and debugging
/////////////////////////////////////////////////////////////////////

//
// Variable accessed by the !deadlock debug extension to investigate
// failures.
//

ULONG_PTR AVrfpDeadlockIssue[4];

VOID
AVrfpDeadlockReportIssue (
    ULONG_PTR Param1,
    ULONG_PTR Param2,
    ULONG_PTR Param3,
    ULONG_PTR Param4
    )
/*++

Routine Description:

    This routine is called to report a deadlock verifier issue.
    If we are in debug mode we will just break in debugger.
    Otherwise we will bugcheck,

Arguments:

    Param1..Param4 - relevant information for the point of failure.

Return Value:

    None.

--*/    
{
    AVrfpDeadlockIssue[0] = Param1;
    AVrfpDeadlockIssue[1] = Param2;
    AVrfpDeadlockIssue[2] = Param3;
    AVrfpDeadlockIssue[3] = Param4;


    if (AVrfpDeadlockDebug) {

        DbgPrint ("AVRF: deadlock: stop: %p %p %p %p %p \n",
                  DRIVER_VERIFIER_DETECTED_VIOLATION,
                  Param1,
                  Param2,
                  Param3,
                  Param4);

        DbgBreakPoint ();
    }
    else {

        // silviuc: APPLICATION_VERIFIER_DEADLOCK_ISSUE
        VERIFIER_STOP (APPLICATION_VERIFIER_UNKNOWN_ERROR, 
                       "Application verifier deadlock/resource issue",
                       Param1, "",
                       Param2, "",
                       Param3, "",
                       Param4, "");
    }
}


VOID
AVrfpDeadlockAddParticipant(
    PAVRF_DEADLOCK_NODE Node
    )
/*++

Routine Description:

    Adds a new node to the set of nodes involved in a deadlock.
    The function is called only from AVrfpDeadlockAnalyze().

Arguments:

    Node - node to be added to the deadlock participants collection.

Return Value:

    None.

--*/    
{
    ULONG Index;

    Index = AVrfpDeadlockGlobals->NumberOfParticipants;

    if (Index >= NO_OF_DEADLOCK_PARTICIPANTS) {

        AVrfpDeadlockState.DeadlockParticipantsOverflow = 1;
        return;
    }

    AVrfpDeadlockGlobals->Participant[Index] = Node;
    AVrfpDeadlockGlobals->NumberOfParticipants += 1;
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// Resource cleanup
/////////////////////////////////////////////////////////////////////

VOID
AVrfpDeadlockDeleteResource (
    PAVRF_DEADLOCK_RESOURCE Resource,
    BOOLEAN Cleanup
    )
/*++

Routine Description:

    This routine deletes a routine and all nodes representing
    acquisitions of that resource.

Arguments:

    Resource - resource to be deleted
    
    Cleanup - true if are called from AVrfpDeadlockDetectionCleanup

Return Value:

    None.

--*/    
{
    PLIST_ENTRY Current;
    PAVRF_DEADLOCK_NODE Node;

    ASSERT (Resource != NULL);

    //
    // Check if the resource being deleted is still acquired. 
    // If it is we will release it ourselves in order to put in 
    // order all internal deadlock verifier structures. Unfortunately
    // it is not a bug to delete a critical section that is not released.
    // Too many people already do it to change the rules in mid flight.
    //

    if (Cleanup == FALSE && Resource->ThreadOwner != NULL) {

        while (Resource->RecursionCount > 0) {
            
            AVrfDeadlockResourceRelease (Resource->ResourceAddress, 
                                         _ReturnAddress());
        }
    }

    ASSERT (Resource->ThreadOwner == NULL);
    ASSERT (Resource->RecursionCount == 0);

    //
    // If this is a normal delete (not a cleanup) we will collapse all trees
    // containing nodes for this resource. If it is a cleanup we will just
    // wipe out the node.
    //

    Current = Resource->ResourceList.Flink;

    while (Current != &(Resource->ResourceList)) {

        Node = CONTAINING_RECORD (Current,
                                  AVRF_DEADLOCK_NODE,
                                  ResourceList);


        Current = Current->Flink;

        ASSERT (Node->Root == Resource);

        AVrfpDeadlockDeleteNode (Node, Cleanup);
    }

    //
    // There should not be any NODEs for the resource at this moment.
    //

    ASSERT (&(Resource->ResourceList) == Resource->ResourceList.Flink);
    ASSERT (&(Resource->ResourceList) == Resource->ResourceList.Blink);

    //
    // Remote the resource from the hash table and
    // delete the resource structure.
    //

    RemoveEntryList (&(Resource->HashChainList));   
    AVrfpDeadlockFree (Resource, AVrfpDeadlockResource);
}


VOID
AVrfpDeadlockTrimResources (
    PLIST_ENTRY HashList
    )
{
    PLIST_ENTRY Current;
    PAVRF_DEADLOCK_RESOURCE Resource;
    ULONG Counter;

    AVrfpDeadlockGlobals->ForgetHistoryCounter += 1;
    Counter = AVrfpDeadlockGlobals->ForgetHistoryCounter;
    Counter %= AVRF_DEADLOCK_FORGET_HISTORY_FREQUENCY;

    if (Counter == 0) {

        Current = HashList->Flink;

        while (Current != HashList) {

            Resource = CONTAINING_RECORD (Current,
                                          AVRF_DEADLOCK_RESOURCE,
                                          HashChainList);
            Current = Current->Flink;

            AVrfpDeadlockForgetResourceHistory (Resource, 
                                             AVrfpDeadlockTrimThreshold, 
                                             AVrfpDeadlockAgeWindow);
        }
    }
}

VOID
AVrfpDeadlockForgetResourceHistory (
    PAVRF_DEADLOCK_RESOURCE Resource,
    ULONG TrimThreshold,
    ULONG AgeThreshold
    )
/*++

Routine Description:

    This routine deletes sone of the nodes representing
    acquisitions of that resource. In essence we forget
    part of the history of that resource.

Arguments:

    Resource - resource for which we wipe out nodes.
    
    TrimThreshold - how many nodes should remain
    
    AgeThreshold - nodes older than this will go away

Return Value:

    None.

--*/    
{
    PLIST_ENTRY Current;
    PAVRF_DEADLOCK_NODE Node;
    ULONG NodesTrimmed = 0;
    ULONG SequenceNumber;

    ASSERT (Resource != NULL);

    //
    // If resource is owned we cannot do anything,
    //

    if (Resource->ThreadOwner) {
        return;
    }

    //
    // If resource has less than TrimThreshold nodes it is still fine.
    //

    if (Resource->NodeCount < TrimThreshold) {
        return;
    }

    //
    // Delete some nodes of the resource based on ageing.
    //

    SequenceNumber = AVrfpDeadlockGlobals->SequenceNumber;

    Current = Resource->ResourceList.Flink;

    while (Current != &(Resource->ResourceList)) {

        Node = CONTAINING_RECORD (Current,
                                  AVRF_DEADLOCK_NODE,
                                  ResourceList);


        Current = Current->Flink;

        ASSERT (Node->Root == Resource);

        //
        // Special care here because the sequence numbers are 32bits
        // and they can overflow. In an ideal world the global sequence
        // is always greater or equal to the node sequence but if it
        // overwrapped it can be the other way around.
        //

        if (SequenceNumber > Node->SequenceNumber) {

            if (SequenceNumber - Node->SequenceNumber > AgeThreshold) {

                AVrfpDeadlockDeleteNode (Node, FALSE);
                NodesTrimmed += 1;
            }
        }
        else {

            if (Node->SequenceNumber - SequenceNumber < AgeThreshold) {

                AVrfpDeadlockDeleteNode (Node, FALSE);
                NodesTrimmed += 1;
            }
        }
    }

    AVrfpDeadlockGlobals->NodesTrimmedBasedOnAge += NodesTrimmed;

    //
    // If resource has less than TrimThreshold nodes it is fine.
    //

    if (Resource->NodeCount < TrimThreshold) {
        return;
    }

    //
    // If we did not manage to trim the nodes by the age algorithm then
    // we  trim everything that we encounter.
    //

    NodesTrimmed = 0;

    Current = Resource->ResourceList.Flink;

    while (Current != &(Resource->ResourceList)) {

        if (Resource->NodeCount < TrimThreshold) {
            break;
        }

        Node = CONTAINING_RECORD (Current,
                                  AVRF_DEADLOCK_NODE,
                                  ResourceList);


        Current = Current->Flink;

        ASSERT (Node->Root == Resource);

        AVrfpDeadlockDeleteNode (Node, FALSE);
        NodesTrimmed += 1;
    }

    AVrfpDeadlockGlobals->NodesTrimmedBasedOnCount += NodesTrimmed;
}


VOID 
AVrfpDeadlockDeleteNode (
    PAVRF_DEADLOCK_NODE Node,
    BOOLEAN Cleanup
    )
/*++

Routine Description:

    This routine deletes a node from a graph and collapses the tree, 
    that is connects its childrend with its parent.
    
    If we are during a cleanup we will just delete the node without
    collapsing the tree.

Arguments:

    Node - node to be deleted.
    
    Cleanup - true if we are during a total cleanup
    
Return Value:

    None.

--*/    
{
    PLIST_ENTRY Current;
    PAVRF_DEADLOCK_NODE Child;
    ULONG Children;

    ASSERT (Node);

    //
    // If are during a cleanup just delete the node and return.
    //

    if (Cleanup) {

        RemoveEntryList (&(Node->ResourceList));
        AVrfpDeadlockFree (Node, AVrfpDeadlockNode);
        return;
    }

    //
    // If we are here we need to collapse the tree
    //

    if (Node->Parent) {

        //
        // All Node's children must become Parent's children
        //

        Current = Node->ChildrenList.Flink;

        while (Current != &(Node->ChildrenList)) {

            Child = CONTAINING_RECORD (Current,
                                       AVRF_DEADLOCK_NODE,
                                       SiblingsList);

            Current = Current->Flink;

            RemoveEntryList (&(Child->SiblingsList));

            Child->Parent = Node->Parent;

            InsertTailList (&(Node->Parent->ChildrenList), 
                            &(Child->SiblingsList));
        }

        RemoveEntryList (&(Node->SiblingsList));
    }
    else {

        //
        // All Node's children must become roots of the graph
        //

        Current = Node->ChildrenList.Flink;
        Children = 0;
        Child = NULL;

        while (Current != &(Node->ChildrenList)) {

            Children += 1;

            Child = CONTAINING_RECORD (Current,
                                       AVRF_DEADLOCK_NODE,
                                       SiblingsList);

            Current = Current->Flink;

            RemoveEntryList (&(Child->SiblingsList));

            Child->Parent = NULL;
            Child->SiblingsList.Flink = NULL;
            Child->SiblingsList.Blink = NULL;
        }
    }

    ASSERT (Node->Root);
    ASSERT (Node->Root->NodeCount > 0);

    Node->Root->NodeCount -= 1;

    RemoveEntryList (&(Node->ResourceList));
    AVrfpDeadlockFree (Node, AVrfpDeadlockNode);
}


ULONG
AVrfpDeadlockNodeLevel (
    PAVRF_DEADLOCK_NODE Node
    )
/*++

Routine Description:

    This routine computes the level of a graph node.

Arguments:

    Node - graph node

Return Value:

    Level of the node. A root node has level zero.
--*/    
{
    PAVRF_DEADLOCK_NODE Current;
    ULONG Level = 0;

    Current = Node->Parent;

    while (Current) {

        Level += 1;
        Current = Current->Parent;
    }

    return Level;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Incremental graph compression
/////////////////////////////////////////////////////////////////////

//
// SilviuC: should write a comment about graph compression
// This is a very smart and tricky algorithm :-)
//

VOID 
AVrfpDeadlockCheckDuplicatesAmongChildren (
    PAVRF_DEADLOCK_NODE Parent,
    PAVRF_DEADLOCK_NODE Child
    )
{
    PLIST_ENTRY Current;
    PAVRF_DEADLOCK_NODE Node;
    LOGICAL FoundOne;

    FoundOne = FALSE;
    Current = Parent->ChildrenList.Flink;

    while (Current != &(Parent->ChildrenList)) {

        Node = CONTAINING_RECORD (Current,
                                  AVRF_DEADLOCK_NODE,
                                  SiblingsList);

        ASSERT (Current->Flink);
        Current = Current->Flink;

        if (AVrfpDeadlockSimilarNodes (Node, Child)) {

            if (FoundOne == FALSE) {
                ASSERT (Node == Child);
                FoundOne = TRUE;
            }
            else {

                AVrfpDeadlockMergeNodes (Child, Node);
            }
        }
    }
}


VOID 
AVrfpDeadlockCheckDuplicatesAmongRoots (
    PAVRF_DEADLOCK_NODE Root
    )
{
    PLIST_ENTRY Current;
    PAVRF_DEADLOCK_NODE Node;
    PAVRF_DEADLOCK_RESOURCE Resource;
    LOGICAL FoundOne;

    FoundOne = FALSE;
    Resource = Root->Root;
    Current = Resource->ResourceList.Flink;

    while (Current != &(Resource->ResourceList)) {

        Node = CONTAINING_RECORD (Current,
                                  AVRF_DEADLOCK_NODE,
                                  ResourceList);

        ASSERT (Current->Flink);
        Current = Current->Flink;

        if (Node->Parent == NULL && AVrfpDeadlockSimilarNodes (Node, Root)) {

            if (FoundOne == FALSE) {
                ASSERT (Node == Root);
                FoundOne = TRUE;
            }
            else {

                AVrfpDeadlockMergeNodes (Root, Node);
            }
        }
    }
}


LOGICAL
AVrfpDeadlockSimilarNodes (
    PAVRF_DEADLOCK_NODE NodeA,
    PAVRF_DEADLOCK_NODE NodeB
    )
{
    if (NodeA->Root == NodeB->Root
        && NodeA->OnlyTryAcquireUsed == NodeB->OnlyTryAcquireUsed) {

        return TRUE;
    }
    else {

        return FALSE;
    }
}


VOID
AVrfpDeadlockMergeNodes (
    PAVRF_DEADLOCK_NODE NodeTo,
    PAVRF_DEADLOCK_NODE NodeFrom
    )
{
    PLIST_ENTRY Current;
    PAVRF_DEADLOCK_NODE Node;

    //
    // If NodeFrom is currently acquired then copy the same 
    // characteristics to NodeTo. Since the locks are exclusive
    // it is impossible to have NodeTo also acquired.
    //

    if (NodeFrom->ThreadEntry) {

        ASSERT (NodeTo->ThreadEntry == NULL);
        NodeTo->ThreadEntry = NodeFrom->ThreadEntry;        

        RtlCopyMemory (NodeTo->StackTrace,
                       NodeFrom->StackTrace,
                       sizeof (NodeTo->StackTrace));

        RtlCopyMemory (NodeTo->ParentStackTrace,
                       NodeFrom->ParentStackTrace,
                       sizeof (NodeTo->ParentStackTrace));
    }

    if (NodeFrom->Active) {

        ASSERT (NodeTo->Active == 0);
        NodeTo->Active = NodeFrom->Active;        
    }

    //
    // Move each child of NodeFrom as a child of NodeTo.
    //

    Current = NodeFrom->ChildrenList.Flink;

    while (Current != &(NodeFrom->ChildrenList)) {

        Node = CONTAINING_RECORD (Current,
                                  AVRF_DEADLOCK_NODE,
                                  SiblingsList);

        ASSERT (Current->Flink);
        Current = Current->Flink;

        RemoveEntryList (&(Node->SiblingsList));

        ASSERT (Node->Parent == NodeFrom);
        Node->Parent = NodeTo;

        InsertTailList (&(NodeTo->ChildrenList),
                        &(Node->SiblingsList));
    }

    //
    // NodeFrom is empty. Delete it.
    //

    ASSERT (IsListEmpty(&(NodeFrom->ChildrenList)));

    if (NodeFrom->Parent) {
        RemoveEntryList (&(NodeFrom->SiblingsList));
    }

    NodeFrom->Root->NodeCount -= 1;
    RemoveEntryList (&(NodeFrom->ResourceList));
    AVrfpDeadlockFree (NodeFrom, AVrfpDeadlockNode);
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////// Consistency checks
/////////////////////////////////////////////////////////////////////

//
//  Node             Resource            Thread
//
//  Root             ThreadOwner         CurrentNode
//  ThreadEntry      RecursionCount      NodeCount
//  Active           ResourceAddress     Thread
//
//
// 
//

VOID
AVrfpDeadlockCheckThreadConsistency (
    PAVRF_DEADLOCK_THREAD Thread,
    BOOLEAN Recursion
    )
{
    if (Thread->CurrentTopNode == NULL) {
        ASSERT (Thread->NodeCount == 0);
        return;
    }

    if (Thread->CurrentTopNode) {

        ASSERT (Thread->NodeCount > 0);
        ASSERT (Thread->CurrentTopNode->Active);    

        if (Recursion == FALSE) {
            AVrfpDeadlockCheckNodeConsistency (Thread->CurrentTopNode, TRUE);
            AVrfpDeadlockCheckResourceConsistency (Thread->CurrentTopNode->Root, TRUE);
        }
    }

    if (Thread->CurrentTopNode) {

        ASSERT (Thread->NodeCount > 0);
        ASSERT (Thread->CurrentTopNode->Active);    

        if (Recursion == FALSE) {
            AVrfpDeadlockCheckNodeConsistency (Thread->CurrentTopNode, TRUE);
            AVrfpDeadlockCheckResourceConsistency (Thread->CurrentTopNode->Root, TRUE);
        }
    }
}

VOID
AVrfpDeadlockCheckNodeConsistency (
    PAVRF_DEADLOCK_NODE Node,
    BOOLEAN Recursion
    )
{
    if (Node->ThreadEntry) {

        ASSERT (Node->Active == 1);

        if (Recursion == FALSE) {
            AVrfpDeadlockCheckThreadConsistency (Node->ThreadEntry, TRUE);
            AVrfpDeadlockCheckResourceConsistency (Node->Root, TRUE);
        }
    }
    else {

        ASSERT (Node->Active == 0);

        if (Recursion == FALSE) {
            AVrfpDeadlockCheckResourceConsistency (Node->Root, TRUE);
        }
    }
}

VOID
AVrfpDeadlockCheckResourceConsistency (
    PAVRF_DEADLOCK_RESOURCE Resource,
    BOOLEAN Recursion
    )
{
    if (Resource->ThreadOwner) {

        ASSERT (Resource->RecursionCount > 0);

        if (Recursion == FALSE) {

            AVrfpDeadlockCheckThreadConsistency (Resource->ThreadOwner, TRUE);

            AVrfpDeadlockCheckNodeConsistency (Resource->ThreadOwner->CurrentTopNode, TRUE);
        }
    }
    else {

        ASSERT (Resource->RecursionCount == 0);
    }
}

PAVRF_DEADLOCK_THREAD
AVrfpDeadlockCheckThreadReferences (
    PAVRF_DEADLOCK_NODE Node
    )
/*++

Routine Description:

    This routine iterates all threads in order to check if `Node' is
    referred in the `CurrentNode' field in any of them.

Arguments:

    Node - node to search

Return Value:

    If everything goes ok we should not find the node and the return
    value is null. Otherwise we return the thread referring to the node.        

--*/    
{
    ULONG Index;
    PLIST_ENTRY Current;
    PAVRF_DEADLOCK_THREAD Thread;

    for (Index = 0; Index < AVRF_DEADLOCK_HASH_BINS; Index += 1) {
        Current = AVrfpDeadlockGlobals->ThreadDatabase[Index].Flink;

        while (Current != &(AVrfpDeadlockGlobals->ThreadDatabase[Index])) {

            Thread = CONTAINING_RECORD (Current,
                                        AVRF_DEADLOCK_THREAD,
                                        ListEntry);

            if (Thread->CurrentTopNode == Node) {
                return Thread;                    
            }

            if (Thread->CurrentTopNode == Node) {
                return Thread;                    
            }

            Current = Current->Flink;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\logging.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    logging.c

Abstract:

    Verifier logging and verifier stop logic.

Author:

    Silviu Calinoiu (SilviuC) 9-May-2002
    Daniel Mihai (DMihai) 9-May-2002

--*/

#include "pch.h"

#include "verifier.h"
#include "logging.h"
#include "support.h"

//
// Verifier stop data.
//

ULONG_PTR AVrfpPreviousStopData[5];
ULONG_PTR AVrfpStopData[5];
LIST_ENTRY AVrfpDisabledStopsList;
ULONG AVrfpNumberOfStopsDisabled;

//
// AVrfpStopDataLock is used to protect any access to 
// AVrfpPreviousStopData, AVrfpStopData and AVrfpDisabledStopsList.
//

RTL_CRITICAL_SECTION AVrfpStopDataLock;

//
// Set this value to 0 in the debugger to see duplicate stops.
//

LOGICAL AVrfpAutomaticallyDisableStops = TRUE;

//
// If true then logging was successfully initialized and can be used.
// It is checked in VerifierLogMessage() to make sure we can log.
//

LOGICAL AVrfpLoggingInitialized;

//
// If true then logging was successfully initialized and it should be
// used instead of the verifier stop debugger messages. It is used
// in VerifierStopMessage().
//

LOGICAL AVrfpLoggingEnabled;

//
// True if process termination has been initiated after a 
// noncontinuable verifier stop.
//

LOGICAL AVrfpProcessBeingTerminated;

//
// Logging structures.
//

UNICODE_STRING AVrfpLoggingNtPath;
WCHAR AVrfpLoggingPathBuffer [DOS_MAX_PATH_LENGTH];
WCHAR AVrfpVariableValueBuffer [DOS_MAX_PATH_LENGTH];

#define MESSAGE_BUFFER_LENGTH 1024
CHAR AVrfpLoggingMessageBuffer [MESSAGE_BUFFER_LENGTH];

ULONG AVrfpLoggingFailures;

PWSTR AVrfpProcessFullName;

//
// Strings used for logging.
//

#define STR_VRF_LOG_STOP_MESSAGE        "\r\n# LOGENTRY VERIFIER STOP %p: pid 0x%X: %s \r\n" \
                                        "# DESCRIPTION BEGIN \r\n" \
                                        "\t%p : %s\r\n\t%p : %s\r\n\t%p : %s\r\n\t%p : %s\r\n" \
                                        "# DESCRIPTION END \r\n" 
#define STR_VRF_DBG_STOP_MESSAGE        "\n\n" \
                                        "===========================================================\n" \
                                        "VERIFIER STOP %p: pid 0x%X: %s \n" \
                                        "\n\t%p : %s\n\t%p : %s\n\t%p : %s\n\t%p : %s\n" \
                                        "===========================================================\n" \
                                        "%s\n" \
                                        "===========================================================\n\n"
#define STR_VRF_LOG_NOCONTINUE_MESSAGE  "\r\n# LOGENTRY VERIFIER: noncontinuable verifier stop" \
                                        " %p encountered. Terminating process. \r\n"
#define STR_VRF_DBG_NOCONTINUE_MESSAGE  "AVRF: Noncontinuable verifier stop %p encountered. " \
                                        "Terminating process ... \n"
#define STR_VRF_LOG_STACK_CHECKS_WARN   "# LOGENTRY VERIFIER WARNING: pid 0x%X: " \
                                        "stack checks have been disabled \r\n" \
                                        "# DESCRIPTION BEGIN \r\n" \
                                        "Stack checks require a debugger attached to the verified process. \r\n" \
                                        "# DESCRIPTION END \r\n"

#define STR_VRF_LOG_INITIAL_MESSAGE     "# LOG_BEGIN `%u/%u/%u %u:%u:%u.%u' `%ws' \r\n"
#define STR_VRF_LOG_INITIAL_SETTINGS    "# DESCRIPTION BEGIN \r\n" \
                                        "    Global flags: 0x%08X \r\n" \
                                        "    Verifier flags: 0x%08X \r\n" \
                                        "    Process debugger attached: %s \r\n" \
                                        "    Kernel debugger enabled: %s \r\n" \
                                        "    Log path: %ws \r\n" \
                                        "# DESCRIPTION END \r\n"
                                            
//
// Forward declarations.
//

LOGICAL
AVrfpIsCurrentStopDisabled (
    VOID
    );

VOID
AVrfpDisableCurrentStop (
    VOID
    );

NTSTATUS
AVrfpCreateLogFile (
    VOID
    );

int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
int __cdecl _snwprintf (wchar_t *, size_t, const wchar_t *, ...);

VOID
AVrfpLogInitialMessage (
    VOID
    );

LOGICAL
AVrfpIsDebuggerPresent (
    VOID
    );

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////// Application verifier stops
/////////////////////////////////////////////////////////////////////

VOID
VerifierStopMessage (
    ULONG_PTR Code,
    PCHAR Message,
    ULONG_PTR Param1, PCHAR Description1,
    ULONG_PTR Param2, PCHAR Description2,
    ULONG_PTR Param3, PCHAR Description3,
    ULONG_PTR Param4, PCHAR Description4
    )
/*++

Routine description:

    This routine is called by various verifier components to report errors found.
    The message is logged into the verifier log associated with the process and 
    also printed in the debugger console.
        
    There are two flags that can be OR'd into the verifier stop code to modify the
    behavior:
    
    APPLICATION_VERIFIER_DO_NOT_BREAK - if this bit is set then the verifier stop is
    logged in the log and dumped in the debugger console and then the thread execution
    continues. For all intents and purposes this is considered a continuable stop.
    
    APPLICATION_VERIFIER_CONTINUABLE_BREAK - if this bit is set the stop is continuable.
    The stop is logged and and then a breakpoint gets executed. After the user continues
    the execution this verifier stop will be skipped.
    
    If none of the flags above is set the stop is considered non-continuable. In this case
    the stop is logged in the log aND dumped in the debugger console and then the process 
    will be terminated. A final log entry will be logged to explain this action. 
    Hopefully in time most of the stop codes will be continuable.
    
Parameters:

    Code: Verifier stop code. The two flags described above can be OR'd into the code
        to change the behavior of the API. The verifier stop codes are defined in
        \base\published\nturtl.w and described in \base\win32\verifier\verifier_stop.doc.
        
    Message: Ascii string describing the failure. It is considered bad style to use several
        different messages with the same `Code'. Every different issue should have its own
        unique (Code, Message) pair.    

    Param1, Description1: First arbitrary pointer to information and ascii description.
    
    Param2, Description2: Second arbitrary pointer to information and ascii description.
    
    Param3, Description3: Third arbitrary pointer to information and ascii description.
    
    Param4, Description4: Fourth arbitrary pointer to information and ascii description.
    
Return value:

    None.

--*/
{
    LOGICAL DoNotBreak = FALSE;
    LOGICAL StopIsDisabled = FALSE;
    NTSTATUS Status;
    LOGICAL MustExitProcess = FALSE;
    LOGICAL ContinuableBreak = FALSE;
    LOGICAL BreakWasContinued = FALSE;
    PCHAR ContinueMessage;

    //
    // While process is getting terminated (due to a previous verifier stop)
    // we do not allow any new logging or dumping to debugger console.
    //

    if (AVrfpProcessBeingTerminated) {
        return;
    }

    //
    // Extract options from the stop code.
    //

    if ((Code & APPLICATION_VERIFIER_NO_BREAK)) {

        DoNotBreak = TRUE;
        Code &= ~APPLICATION_VERIFIER_NO_BREAK;
        
        //
        // A no_break is by design continuable.
        //
        
        ContinuableBreak = TRUE;
    }

    if ((Code & APPLICATION_VERIFIER_CONTINUABLE_BREAK)) {

        ContinuableBreak = TRUE;
        Code &= ~APPLICATION_VERIFIER_CONTINUABLE_BREAK;
    }

    //
    // Serialize multi-threaded access to the stop data.
    //

    RtlEnterCriticalSection (&AVrfpStopDataLock);

    //
    // Make it easy for a debugger to pick up the failure info.
    //

    RtlCopyMemory (AVrfpPreviousStopData, 
                   AVrfpStopData, 
                   sizeof AVrfpStopData);

    AVrfpStopData[0] = Code;
    AVrfpStopData[1] = Param1;
    AVrfpStopData[2] = Param2;
    AVrfpStopData[3] = Param3;
    AVrfpStopData[4] = Param4;

    //
    // Check if the current stop is disabled.
    //

    if (AVrfpAutomaticallyDisableStops != FALSE) {

        StopIsDisabled = AVrfpIsCurrentStopDisabled ();
    }

    //
    // If stop has not been encountered before we need to report it 
    // in the debugger console and the verifier log.
    //

    if (StopIsDisabled == FALSE) {

        if (AVrfpLoggingEnabled) {

            VerifierLogMessage (STR_VRF_LOG_STOP_MESSAGE,
                                Code, RtlGetCurrentProcessId(), Message,
                                Param1, Description1, 
                                Param2, Description2, 
                                Param3, Description3, 
                                Param4, Description4);
        }
        
        if (ContinuableBreak) {

            ContinueMessage = "This verifier stop is continuable. \n"
                              "After debugging it use `go' to continue.";
        }
        else {

            ContinueMessage = "This verifier stop is not continuable. Process will be terminated \n"
                              "when you use the `go' debugger command.";
        }

        DbgPrint (STR_VRF_DBG_STOP_MESSAGE,
                  Code, RtlGetCurrentProcessId(), Message,
                  Param1, Description1, 
                  Param2, Description2, 
                  Param3, Description3, 
                  Param4, Description4,
                  ContinueMessage);

        if (DoNotBreak == FALSE) {

            //
            // We do not really break if there is not a debugger around. If we do it
            // there will be an unhandle breakpoint exception in the process that
            // will be picked up by PC-Health. Since we do not break it will be as if
            // someone hit `go' in the debugger.
            //

            if (AVrfpIsDebuggerPresent() == TRUE) {
                DbgBreakPoint ();
            }
            
            BreakWasContinued = TRUE;
        }

        //
        // If the stop is not continuable (including the `donotbreak' flavor)
        // then we need to terminate the process. Otherwise register the current
        // stop as disabled so that we do not see it over and over again.
        //
        
        if (ContinuableBreak == FALSE && DoNotBreak == FALSE) {

            MustExitProcess = TRUE;
        }
        else {

            if (AVrfpAutomaticallyDisableStops) {

                AVrfpDisableCurrentStop ();
            }
        }
    }

    RtlLeaveCriticalSection (&AVrfpStopDataLock);

    if (MustExitProcess) {
        
        //
        // Hopefully in the future most of the verifier stops will be
        // continuable. Right now we just terminate the process.
        //

        if (AVrfpLoggingEnabled) {
            VerifierLogMessage (STR_VRF_LOG_NOCONTINUE_MESSAGE, Code);
        }
        
        DbgPrint (STR_VRF_DBG_NOCONTINUE_MESSAGE, Code);

        AVrfpProcessBeingTerminated = TRUE;

        Status = NtTerminateProcess (NtCurrentProcess(), STATUS_UNSUCCESSFUL);

        if (!NT_SUCCESS(Status)) {

            DbgPrint ("AVRF: Terminate process after verifier stop failed with %X \n", Status);
            DbgBreakPoint ();
        }
    }
}

/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////// Logging API
/////////////////////////////////////////////////////////////////////

NTSTATUS 
VerifierLogMessage (
    PCHAR Format,
    ...
    )
/*++

Routine description:

    This routine tries to open (non-shareable) the verifier log file 
    associated with the current process. If it cannot do it because it is
    opened for someone else it will retry a few times with a delay in between.
    This way it will effectively wait for some other thread that is currently
    logging. Other tools that try to look at the log while a process is running
    will have to do it quickly if they do not want to affect the logging. Since
    logging is a rare event this scheme seems to me solid enough. The function
    is designed to survive the situation where someone keeps the file open for
    too long by just skipping log messages.

Parameters:

    Format: string format parameters a la printf.
    
    ...: rest of the prinf-like parameters.

Return value:

    None. All errors encountered in the function are supposed to be continuable.
    
--*/
{
    va_list Params;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE LogHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER Offset;
    LONG MessageSize;
    ULONG OpenFlags;
    ULONG RetryCount;
    LARGE_INTEGER SleepTime;
    
    va_start (Params, Format);

    if (AVrfpLoggingInitialized == FALSE) {
        return STATUS_UNSUCCESSFUL;
    }

    OpenFlags = FILE_OPEN;

    SleepTime.QuadPart = - (10 * 1000 * 1000 * 1); // 1 sec.

    //
    // Attempt to get a handle to our log file.
    //
    
    InitializeObjectAttributes (&ObjectAttributes,
                                &AVrfpLoggingNtPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    RetryCount = 0;

    //
    // If somebody is actively logging into the file we will keep
    // looping for a while until the handle is closed or we tried enough
    // and did not succeed. This offers synchronization between competing 
    // threads logging simultaneously.
    //

    do {

        Status = NtCreateFile (&LogHandle,
                               FILE_APPEND_DATA | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               0,
                               OpenFlags,
                               0,
                               NULL,
                               0);

        if (Status == STATUS_SHARING_VIOLATION) {
            
            NtDelayExecution (FALSE, &SleepTime);
            RetryCount += 1;
        }

    } while (Status == STATUS_SHARING_VIOLATION && RetryCount < 5);

    if (! NT_SUCCESS(Status)) {

        if (Status == STATUS_SHARING_VIOLATION) {
            
            DbgPrint ("AVRF: verifier log file %ws kept open for too long (status %X)\n",
                      AVrfpLoggingNtPath.Buffer,
                      Status);
        }
        else {
            
            DbgPrint ("AVRF: failed to open verifier log file %ws (status %X)\n",
                      AVrfpLoggingNtPath.Buffer,
                      Status);
        }
        
        AVrfpLoggingFailures += 1;
        return Status;
    }

    //
    // Prepare and write the message. Write the data out to the file.
    // Synchronization to the preparation buffer is assured by the log file
    // handle opened in non-sharable mode which means no one can be in the same
    // state (writing into the buffer) right now.
    //
    
    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    Offset.LowPart  = 0;
    Offset.HighPart = 0;

    MessageSize = _vsnprintf (AVrfpLoggingMessageBuffer,
                              MESSAGE_BUFFER_LENGTH,
                              Format,
                              Params);
    if (MessageSize < 0) {
        
        DbgPrint ("AVRF: failed in _vsnprintf() to prepare log message\n");
        
        AVrfpLoggingFailures += 1;
        Status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    Status = NtWriteFile (LogHandle,
                          NULL,
                          NULL,
                          NULL,
                          &IoStatusBlock,
                          (PVOID)AVrfpLoggingMessageBuffer,
                          MessageSize,
                          &Offset,
                          NULL);
    
    if (Status == STATUS_PENDING) {
    
        //
        // We need to wait for the operation to complete.
        //
    
        Status = NtWaitForSingleObject (LogHandle, FALSE, NULL);
    
        if (NT_SUCCESS(Status)) {
            
            Status = IoStatusBlock.Status;
        }
        else {

            //
            // If this happens we need to debug it.
            //

            DbgPrint ("AVRF: Wait for pending write I/O operation failed with %X \n", Status);
            DbgBreakPoint (); 
        }
    }

    if (! NT_SUCCESS(Status)) {
        
        DbgPrint ("AVRF: failed to write into verifier log file %ws (status %X)\n",
                  AVrfpLoggingNtPath.Buffer,
                  Status);

        AVrfpLoggingFailures += 1;
        goto Exit;
    }

Exit:

    NtClose (LogHandle);
    return Status;
}



/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// Stop disabling
/////////////////////////////////////////////////////////////////////

VOID
AVrfpDisableCurrentStop (
    VOID
    )
/*++

Routine description:

    This routine inserts the values from AVrfpStopData
    into the list of disabled stops.

Parameters:

    None, using global AVrfpStopData and AVrfpDisabledStopsList.

Return value:

    None.
    
Environment:

    User mode, AVrfpStopDataLock held by the caller.

--*/
{
    PAVRFP_STOP_DATA StopData;

    StopData = AVrfpAllocate (sizeof *StopData);
    
    if (StopData != NULL) {

        ASSERT (sizeof (AVrfpStopData) == sizeof (StopData->Data));

        RtlCopyMemory (&StopData->Data, 
                        AVrfpStopData, 
                        sizeof AVrfpStopData);

        InsertHeadList (&AVrfpDisabledStopsList,
                        &StopData->ListEntry);
    
        AVrfpNumberOfStopsDisabled += 1;
    }
}


LOGICAL
AVrfpIsCurrentStopDisabled (
    VOID
    )
/*++

Routine description:

    This routine is searching for the stop data from AVrfpStopData
    in the list of disabled stops.

Parameters:

    None, using global AVrfpStopData and AVrfpDisabledStopsList.

Return value:

    TRUE if the current stop is disabled, FALSE otherwise.
    
Environment:

    User mode, AVrfpStopDataLock held by the caller.

--*/
{
    LOGICAL Disabled;
    PAVRFP_STOP_DATA StopData;
    PLIST_ENTRY Entry;
    ULONG Index;

    Disabled = FALSE;

    ASSERT (sizeof (AVrfpStopData) == sizeof (StopData->Data));
    ASSERT (sizeof (AVrfpStopData[0]) == sizeof (StopData->Data[0]));

    for (Entry = AVrfpDisabledStopsList.Flink; 
         Entry != &AVrfpDisabledStopsList; 
         Entry = Entry->Flink) {
        
        StopData = CONTAINING_RECORD (Entry,
                                      AVRFP_STOP_DATA,
                                      ListEntry);

        Disabled = TRUE;

        for (Index = 0; Index < sizeof (AVrfpStopData) / sizeof (AVrfpStopData[0]); Index += 1) {

            if (AVrfpStopData[Index] != StopData->Data[Index]) {

                Disabled = FALSE;
                break;
            }
        }

        if (Disabled != FALSE) {

            break;
        }
    }

    return Disabled;
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// Initialization
/////////////////////////////////////////////////////////////////////

LOGICAL
AVrfpIsDebuggerPresent (
    VOID
    )
/*++

Routine description:

    This routine checks out if we  have any kind of debuggers active.
    Note that we cannot do this check only once during process
    initialization because debuggers can be attached and detached
    from a process while the process is running.

Parameters:

    None.
    
Return value:

    TRUE if a user mode debugger is attached to the current process or
    kernel mode debugger is enabled.
    
--*/
{

    if (NtCurrentPeb()->BeingDebugged) {
        return TRUE;
    }

    if (USER_SHARED_DATA->KdDebuggerEnabled) {
        return TRUE;
    }

    return FALSE;
}


NTSTATUS
AVrfpInitializeVerifierStops (
    VOID
    )
/*++

Routine description:

    This routine initializes verifier stops logic.

Parameters:

    None.
    
Return value:

    STATUS_SUCCESS if enabled successfully. Various errors
    otherwise. 
    
--*/
{
    NTSTATUS Status;

    InitializeListHead (&AVrfpDisabledStopsList);
    
    Status = RtlInitializeCriticalSection (&AVrfpStopDataLock);

    return Status;
}


NTSTATUS
AVrfpInitializeVerifierLogging (
    VOID
    )
/*++

Routine description:

    This routine initializes verifier structures for logging. It is called 
    during verifier engine initialization (early process stage). 
    
    Stops will happen if a debugger is present and logging was 
    not requested explicitely. Al other combinations will enable
    logging. In addition if no user mode debugger is attached the
    stack overflow checking is disabled altogether.

Parameters:

    None.
    
Return value:

    STATUS_SUCCESS if logging was enabled successfully. Various errors
    otherwise. 
    
--*/
{
    NTSTATUS Status;

    //
    // Create the log file.
    //

    Status = AVrfpCreateLogFile ();

    if (! NT_SUCCESS(Status)) {
        return Status;
    }
    
    //
    // We are done now we can mark the logging initialization as successful.
    //

    AVrfpLoggingInitialized = TRUE;

    //
    // Stack overflow checking gets disabled if we no debugger attached because
    // it is impossible to recover from the failure and we cannot intercept
    // it to present a decent debugging message.
    //

    if (AVrfpProvider.VerifierFlags & RTL_VRF_FLG_STACK_CHECKS) {

        if (AVrfpIsDebuggerPresent() == FALSE) {

            VerifierLogMessage (STR_VRF_LOG_STACK_CHECKS_WARN,
                                RtlGetCurrentProcessId());
        }
    }
    
    //
    // Log startup information.
    //

    AVrfpLogInitialMessage ();

    //
    // Logging is always enabled except if the verifier is enabled system-wide.
    // For that case this function is not even called.
    //

    AVrfpLoggingEnabled = TRUE;
    
    return Status;
}


NTSTATUS
AVrfpCreateLogFile (
    VOID
    )
/*++

Routine description:

    This routine tries to create a log file unique for the current process.
    The path of the log file is either read from VERIFIER_LOG_PATH environment
    variable or the default value `%ALLUSERSPROFILE%\Documents\AppVerifierLogs'
    is used. The syntax of the log file name is `IMAGENAME.UNIQUEID.log'. The
    IMAGENAME includes the extension since there are executable files that have
    extensions different than .exe (e.g. .scr for screensavers).
    
    The routine will keep incrementing an integer ID (starting from zero) until
    it manages to create a file that did not exist before.

Parameters:

    None.

Return value:

    STATUS_SUCCESS if it was successful in creating an unique log file for this
    process. Various status errors otherwise.

--*/
{
    LOGICAL Success; 
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE LogHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG OpenFlags;
    PWSTR ProcessName;
    ULONG FileNameId;
    UNICODE_STRING LogPathVariableName;
    UNICODE_STRING LogPath;
    LOGICAL DefaultLogPath;
    PPEB Peb;
    
    OpenFlags = FILE_CREATE;

    FileNameId = 0; 

    Peb = NtCurrentPeb();

    {
        //
        // We need to find out the full path to the image being executed.
        // It is safe to read loader structures since this function
        // is called from verifier!DllMain and the loader lock is owned
        // by the current thread when this happens. This is the lock that 
        // protects access to the structures.
        //
        
        PPEB_LDR_DATA Ldr;
        PLIST_ENTRY Head;
        PLIST_ENTRY Next;
        PLDR_DATA_TABLE_ENTRY Entry;

        Ldr = Peb->Ldr;
        Head = &Ldr->InLoadOrderModuleList;
        Next = Head->Flink;

        Entry = CONTAINING_RECORD (Next, 
                                   LDR_DATA_TABLE_ENTRY, 
                                   InLoadOrderLinks);

        ProcessName = Entry->BaseDllName.Buffer;

        AVrfpProcessFullName = Entry->FullDllName.Buffer;
    }

    Status = STATUS_SUCCESS;

    DefaultLogPath = FALSE;

    //
    // Get the value of `VERIFIER_LOG_PATH' environment variable.
    //

    RtlInitUnicodeString (&LogPathVariableName,
                          L"VERIFIER_LOG_PATH");

    RtlInitEmptyUnicodeString (&LogPath,
                               AVrfpVariableValueBuffer,
                               DOS_MAX_PATH_LENGTH);

    Status = RtlQueryEnvironmentVariable_U (NULL,
                                            &LogPathVariableName,
                                            &LogPath);

    if (! NT_SUCCESS(Status)) {
        
        //
        // Get the value of `AllUsersProfile' environment variable.
        //

        RtlInitUnicodeString (&LogPathVariableName,
                              L"ALLUSERSPROFILE");

        RtlInitEmptyUnicodeString (&LogPath,
                                   AVrfpVariableValueBuffer,
                                   DOS_MAX_PATH_LENGTH);

        Status = RtlQueryEnvironmentVariable_U (NULL,
                                                &LogPathVariableName,
                                                &LogPath);

        if (! NT_SUCCESS(Status)) {

            DbgPrint ("AVRF: Failed to get environment variable (status %X)\n", Status);
            return Status;
        }
        
        DefaultLogPath = TRUE;
    }

    //
    // We try to create a log file with the proper name (given our convention)
    // that is unique for this process. If the file with that name already exists
    // we will get an error and we will try a different name.
    //

    do {

        //
        // Prepare log path name with unique Id appended.
        //
        
        if (DefaultLogPath) {

            _snwprintf (AVrfpLoggingPathBuffer, 
                        DOS_MAX_PATH_LENGTH - 1,
                        L"%ws\\Documents\\AppVerifierLogs\\%ws.%u.log",
                        AVrfpVariableValueBuffer,
                        ProcessName,
                        FileNameId);
        }
        else {

            _snwprintf (AVrfpLoggingPathBuffer, 
                        DOS_MAX_PATH_LENGTH - 1,
                        L"%ws\\%ws.%u.log",
                        AVrfpVariableValueBuffer,
                        ProcessName,
                        FileNameId);
        }

        Success = RtlDosPathNameToNtPathName_U (AVrfpLoggingPathBuffer, 
                                                &AVrfpLoggingNtPath, 
                                                NULL, 
                                                NULL);

        if (Success == FALSE) {

            DbgPrint ("AVRF: Failed to convert to an NT path the verifier log path.\n");
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Attempt to get a handle to our log file.
        //

        InitializeObjectAttributes (&ObjectAttributes,
                                    &AVrfpLoggingNtPath,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);

        Status = NtCreateFile (&LogHandle,
                               FILE_APPEND_DATA,
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               0,
                               OpenFlags,
                               0,
                               NULL,
                               0);

        if (Status == STATUS_OBJECT_NAME_COLLISION) {
            
            FileNameId += 1; 

            RtlFreeUnicodeString (&AVrfpLoggingNtPath);
        }

    } while (Status == STATUS_OBJECT_NAME_COLLISION); 

    if (! NT_SUCCESS(Status)) {

        DbgPrint ("AVRF: failed to create verifier log file %ws (status %X)\n",
                  AVrfpLoggingNtPath.Buffer,
                  Status);
        return Status;
    }

    NtClose (LogHandle);

    return Status;
}


VOID
AVrfpLogInitialMessage (
    VOID
    )
{
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;

    //
    // Read system time from shared region.
    //

    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    //
    // Convert to local time and split into fields.
    //
    
    LocalTime.QuadPart = 0;
    RtlSystemTimeToLocalTime (&SystemTime, &LocalTime);
    
    RtlZeroMemory (&TimeFields, sizeof TimeFields);
    RtlTimeToTimeFields(&LocalTime,&TimeFields);

    //
    // Dump time and process full path.
    //

    VerifierLogMessage (STR_VRF_LOG_INITIAL_MESSAGE,
                        (ULONG)TimeFields.Month,
                        (ULONG)TimeFields.Day,
                        (ULONG)TimeFields.Year,
                        (ULONG)TimeFields.Hour,
                        (ULONG)TimeFields.Minute,
                        (ULONG)TimeFields.Second,
                        (ULONG)TimeFields.Milliseconds,
                        AVrfpProcessFullName);

    //
    // Dump settings.
    //

    VerifierLogMessage (STR_VRF_LOG_INITIAL_SETTINGS,
                        NtCurrentPeb()->NtGlobalFlag,
                        AVrfpProvider.VerifierFlags,
                        (NtCurrentPeb()->BeingDebugged) ? "yes" : "no",
                        ((USER_SHARED_DATA->KdDebuggerEnabled)) ? "yes" : "no",
                        AVrfpLoggingPathBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\logging.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

    logging.h

Abstract:

    Verifier logging and verifier stop logic.

Author:

    Silviu Calinoiu (SilviuC) 9-May-2002

Revision History:

--*/

#ifndef _LOGGING_H_
#define _LOGGING_H_

typedef struct _AVRFP_STOP_DATA {

    LIST_ENTRY ListEntry;
    ULONG_PTR Data[5];

} AVRFP_STOP_DATA, *PAVRFP_STOP_DATA;

                            
NTSTATUS
AVrfpInitializeVerifierStops (
    VOID
    );

NTSTATUS
AVrfpInitializeVerifierLogging (
    VOID
    );

#define VERIFIER_STOP(Code, Msg, P1, S1, P2, S2, P3, S3, P4, S4) {  \
        VerifierStopMessage        ((Code),                         \
                                    (Msg),                          \
                                    (ULONG_PTR)(P1),(S1),           \
                                    (ULONG_PTR)(P2),(S2),           \
                                    (ULONG_PTR)(P3),(S3),           \
                                    (ULONG_PTR)(P4),(S4));          \
  }
                   

#endif // _LOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\heap.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    heap.c

Abstract:

    This module implements verification functions for 
    heap management interfaces.

Author:

    Silviu Calinoiu (SilviuC) 7-Mar-2001

Revision History:

--*/

#include "pch.h"

#include "verifier.h"
#include "support.h"
#include "critsect.h"
#include "faults.h"

//
// During manipulation of DPH_BLOCK_INFORMATION we get this because
// pointers have a default 8 byte aligned. However they will always
// be 16-byte aligned because they are derived from heap allocated
// blocks and these are 16 byte aligned anyway.
//
                              
#if defined(_WIN64)
#pragma warning(disable:4327) 
#endif

//
// Dirty unused portions of stack in order to catch usage of 
// uninitialized locals. 
//

#define AVRFP_DIRTY_STACK_FREQUENCY 16
LONG AVrfpDirtyStackCounter;

#define AVRFP_DIRTY_THREAD_STACK() { \
        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_DIRTY_STACKS) != 0) { \
            if ((InterlockedIncrement(&AVrfpDirtyStackCounter) % AVRFP_DIRTY_STACK_FREQUENCY) == 0) { \
                AVrfpDirtyThreadStack (); \
            } \
        } \
    }

//
// Simple test to figure out if a heap was created by page heap or it is
// just a normal heap.
//

#define IS_PAGE_HEAP(HeapHandle) (*(PULONG)HeapHandle == 0xEEEEEEEE)

#define RAISE_NO_MEMORY_EXCEPTION()             \
    {                                           \
        EXCEPTION_RECORD ER;                    \
        ER.ExceptionCode    = STATUS_NO_MEMORY; \
        ER.ExceptionFlags   = 0;                \
        ER.ExceptionRecord  = NULL;             \
        ER.ExceptionAddress = _ReturnAddress(); \
        ER.NumberParameters = 0;                \
        RtlRaiseException( &ER );               \
    }


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//NTSYSAPI
PVOID
NTAPI
AVrfpRtlAllocateHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    )
{
    PVOID Result;

    BUMP_COUNTER (CNT_HEAP_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_HEAP_ALLOC_APIS)) {
        
        BUMP_COUNTER (CNT_HEAP_ALLOC_FAILS);
        CHECK_BREAK (BRK_HEAP_ALLOC_FAIL);
        
        if ((Flags & HEAP_GENERATE_EXCEPTIONS)) {
            RAISE_NO_MEMORY_EXCEPTION ();
        }

        return NULL;
    }

    Result = RtlAllocateHeap (HeapHandle,
                              Flags,
                              Size);

    if (Result) {

        AVrfLogInTracker (AVrfHeapTracker,
                          TRACK_HEAP_ALLOCATE,
                          Result, (PVOID)Size, NULL, NULL, _ReturnAddress());
    }

    AVRFP_DIRTY_THREAD_STACK ();

    return Result;
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//NTSYSAPI
BOOLEAN
NTAPI
AVrfpRtlFreeHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )
{
    BOOLEAN Result;
    BOOL BogusAddress;
    SIZE_T RequestedSize;
    PDPH_BLOCK_INFORMATION BlockInformation;

    //
    // Initialize RequestedSize in order to be able to compile W4.
    // The variable gets actually initialized when it matters but
    // the compiler is not able to realize that. If while initializing
    // it we get an exception then we will not use it.
    //

    RequestedSize = 0;

    if (BaseAddress != NULL && IS_PAGE_HEAP (HeapHandle)) {

        BogusAddress = FALSE;

        BlockInformation = (PDPH_BLOCK_INFORMATION)BaseAddress - 1;

        try {

            RequestedSize = BlockInformation->RequestedSize;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // Let page heap handle the bogus block.
            //

            BogusAddress = TRUE;
        }

        if (BogusAddress == FALSE) {

            AVrfpFreeMemNotify (VerifierFreeMemTypeFreeHeap,
                                BaseAddress,
                                RequestedSize,
                                NULL);
        }
    }

    Result = RtlFreeHeap (HeapHandle,
                          Flags,
                          BaseAddress);

    if (Result) {
        
        AVrfLogInTracker (AVrfHeapTracker,
                          TRACK_HEAP_FREE,
                          BaseAddress, NULL, NULL, NULL, _ReturnAddress());
    }

    AVRFP_DIRTY_THREAD_STACK ();

    return Result;
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//NTSYSAPI
PVOID
NTAPI
AVrfpRtlReAllocateHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    )
{
    PVOID Result;
    BOOL BogusAddress;
    SIZE_T RequestedSize;
    PDPH_BLOCK_INFORMATION BlockInformation;

    BUMP_COUNTER (CNT_HEAP_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_HEAP_ALLOC_APIS)) {
        
        BUMP_COUNTER (CNT_HEAP_ALLOC_FAILS);
        CHECK_BREAK (BRK_HEAP_ALLOC_FAIL);
        
        if ((Flags & HEAP_GENERATE_EXCEPTIONS)) {
            RAISE_NO_MEMORY_EXCEPTION ();
        }

        return NULL;
    }
    
    //
    // Initialize RequestedSize in order to be able to compile W4.
    // The variable gets actually initialized when it matters but
    // the compiler is not able to realize that. If while initializing
    // it we get an exception then we will not use it.
    //

    RequestedSize = 0;
    
    if (BaseAddress != NULL && 
        IS_PAGE_HEAP (HeapHandle) && 
        ((Flags & HEAP_REALLOC_IN_PLACE_ONLY) != 0)) {

        BogusAddress = FALSE;

        BlockInformation = (PDPH_BLOCK_INFORMATION)BaseAddress - 1;

        try {

            RequestedSize = BlockInformation->RequestedSize;
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // Let page heap handle the bogus block.
            //

            BogusAddress = TRUE;
        }

        if (BogusAddress == FALSE) {

            AVrfpFreeMemNotify (VerifierFreeMemTypeFreeHeap,
                                BaseAddress,
                                RequestedSize,
                                NULL);
        }
    }

    Result = RtlReAllocateHeap (HeapHandle,
                                Flags,
                                BaseAddress,
                                Size);

    if (Result) {
        
        AVrfLogInTracker (AVrfHeapTracker,
                          TRACK_HEAP_REALLOCATE,
                          BaseAddress, Result, (PVOID)Size, NULL, _ReturnAddress());
    }

    AVRFP_DIRTY_THREAD_STACK ();

    return Result;
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
VOID
AVrfpNtdllHeapFreeCallback (
    PVOID AllocationBase,
    SIZE_T AllocationSize
    )
{
    AVrfpFreeMemNotify (VerifierFreeMemTypeFreeHeap,
                        AllocationBase,
                        AllocationSize,
                        NULL);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// kernel32.dll verified exports
/////////////////////////////////////////////////////////////////////

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//WINBASEAPI
HANDLE
WINAPI
AVrfpHeapCreate(
    IN DWORD flOptions,
    IN SIZE_T dwInitialSize,
    IN SIZE_T dwMaximumSize
    )
{
    typedef HANDLE (WINAPI * FUNCTION_TYPE) (DWORD, SIZE_T, SIZE_T);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_HEAPCREATE);

    BUMP_COUNTER (CNT_HEAPS_CREATED);
    return (* Function)(flOptions, dwInitialSize, dwMaximumSize);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//WINBASEAPI
BOOL
WINAPI
AVrfpHeapDestroy(
    IN OUT HANDLE hHeap
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (HANDLE);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_HEAPDESTROY);

    BUMP_COUNTER (CNT_HEAPS_DESTROYED);
    return (* Function)(hHeap);
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//WINBASEAPI
HGLOBAL
WINAPI
AVrfpGlobalAlloc(
    IN UINT uFlags,
    IN SIZE_T dwBytes
    )
{
    typedef HGLOBAL (WINAPI * FUNCTION_TYPE) (UINT, SIZE_T);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_GLOBALALLOC);


    BUMP_COUNTER (CNT_HEAP_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_HEAP_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_HEAP_ALLOC_FAILS);
        CHECK_BREAK (BRK_HEAP_ALLOC_FAIL);
        NtCurrentTeb()->LastErrorValue = ERROR_OUTOFMEMORY;
        return NULL;
    }
    
    return (* Function)(uFlags, dwBytes);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//WINBASEAPI
HGLOBAL
WINAPI
AVrfpGlobalReAlloc(
    IN HGLOBAL hMem,
    IN SIZE_T dwBytes,
    IN UINT uFlags
    )
{
    typedef HGLOBAL (WINAPI * FUNCTION_TYPE) (HGLOBAL, SIZE_T, UINT);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_GLOBALREALLOC);


    BUMP_COUNTER (CNT_HEAP_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_HEAP_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_HEAP_ALLOC_FAILS);
        CHECK_BREAK (BRK_HEAP_ALLOC_FAIL);
        NtCurrentTeb()->LastErrorValue = ERROR_OUTOFMEMORY;
        return NULL;
    }
    
    return (* Function)(hMem, dwBytes, uFlags);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//WINBASEAPI
HLOCAL
WINAPI
AVrfpLocalAlloc(
    IN UINT uFlags,
    IN SIZE_T uBytes
    )
{
    typedef HLOCAL (WINAPI * FUNCTION_TYPE) (UINT, SIZE_T);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_LOCALALLOC);


    BUMP_COUNTER (CNT_HEAP_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_HEAP_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_HEAP_ALLOC_FAILS);
        CHECK_BREAK (BRK_HEAP_ALLOC_FAIL);
        NtCurrentTeb()->LastErrorValue = ERROR_OUTOFMEMORY;
        return NULL;
    }
    
    return (* Function)(uFlags, uBytes);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
//WINBASEAPI
HLOCAL
WINAPI
AVrfpLocalReAlloc(
    IN HLOCAL hMem,
    IN SIZE_T uBytes,
    IN UINT uFlags
    )
{
    typedef HLOCAL (WINAPI * FUNCTION_TYPE) (HLOCAL, SIZE_T, UINT);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_LOCALREALLOC);


    BUMP_COUNTER (CNT_HEAP_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_HEAP_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_HEAP_ALLOC_FAILS);
        CHECK_BREAK (BRK_HEAP_ALLOC_FAIL);
        NtCurrentTeb()->LastErrorValue = ERROR_OUTOFMEMORY;
        return NULL;
    }
    
    return (* Function)(hMem, uBytes, uFlags);
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////// msvcrt allocation routines
/////////////////////////////////////////////////////////////////////

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
PVOID __cdecl
AVrfp_malloc (
    IN SIZE_T Size
    )
{
    typedef PVOID (__cdecl * FUNCTION_TYPE) (SIZE_T);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpMsvcrtThunks,
                                          AVRF_INDEX_MSVCRT_MALLOC);

    BUMP_COUNTER (CNT_HEAP_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_HEAP_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_HEAP_ALLOC_FAILS);
        CHECK_BREAK (BRK_HEAP_ALLOC_FAIL);
        return NULL;
    }
    
    return (* Function)(Size);
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
PVOID __cdecl
AVrfp_calloc (
    IN SIZE_T Number,
    IN SIZE_T Size
    )
{
    typedef PVOID (__cdecl * FUNCTION_TYPE) (SIZE_T, SIZE_T);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpMsvcrtThunks,
                                          AVRF_INDEX_MSVCRT_CALLOC);

    BUMP_COUNTER (CNT_HEAP_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_HEAP_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_HEAP_ALLOC_FAILS);
        CHECK_BREAK (BRK_HEAP_ALLOC_FAIL);
        return NULL;
    }
    
    return (* Function)(Number, Size);
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
PVOID __cdecl
AVrfp_realloc (
    IN PVOID Address,
    IN SIZE_T Size
    )
{
    typedef PVOID (__cdecl * FUNCTION_TYPE) (PVOID, SIZE_T);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpMsvcrtThunks,
                                          AVRF_INDEX_MSVCRT_REALLOC);

    BUMP_COUNTER (CNT_HEAP_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_HEAP_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_HEAP_ALLOC_FAILS);
        CHECK_BREAK (BRK_HEAP_ALLOC_FAIL);
        return NULL;
    }
    
    return (* Function)(Address, Size);
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
VOID __cdecl
AVrfp_free (
    IN PVOID Address
    )
{
    typedef VOID (__cdecl * FUNCTION_TYPE) (PVOID);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpMsvcrtThunks,
                                          AVRF_INDEX_MSVCRT_FREE);

    (* Function)(Address);
}


#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
PVOID __cdecl
AVrfp_new (
    IN SIZE_T Size
    )
{
    typedef PVOID (__cdecl * FUNCTION_TYPE) (SIZE_T);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpMsvcrtThunks,
                                          AVRF_INDEX_MSVCRT_NEW);

    BUMP_COUNTER (CNT_HEAP_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_HEAP_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_HEAP_ALLOC_FAILS);
        CHECK_BREAK (BRK_HEAP_ALLOC_FAIL);
        return NULL;
    }
    
    return (* Function)(Size);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
VOID __cdecl
AVrfp_delete (
    IN PVOID Address
    )
{
    typedef VOID (__cdecl * FUNCTION_TYPE) (PVOID);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpMsvcrtThunks,
                                          AVRF_INDEX_MSVCRT_DELETE);

    (* Function)(Address);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
PVOID __cdecl
AVrfp_newarray (
    IN SIZE_T Size
    )
{
    typedef PVOID (__cdecl * FUNCTION_TYPE) (SIZE_T);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpMsvcrtThunks,
                                          AVRF_INDEX_MSVCRT_NEWARRAY);

    BUMP_COUNTER (CNT_HEAP_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_HEAP_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_HEAP_ALLOC_FAILS);
        CHECK_BREAK (BRK_HEAP_ALLOC_FAIL);
        return NULL;
    }
    
    return (* Function)(Size);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
VOID __cdecl
AVrfp_deletearray (
    IN PVOID Address
    )
{
    typedef VOID (__cdecl * FUNCTION_TYPE) (PVOID);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpMsvcrtThunks,
                                          AVRF_INDEX_MSVCRT_DELETEARRAY);

    (* Function)(Address);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////// oleaut32 BSTR allocation routines
/////////////////////////////////////////////////////////////////////

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
BSTR
STDAPICALLTYPE 
AVrfpSysAllocString(const OLECHAR * String)
{
    typedef BSTR (STDAPICALLTYPE * FUNCTION_TYPE) (const OLECHAR *);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpOleaut32Thunks,
                                          AVRF_INDEX_OLEAUT32_SYSALLOCSTRING);

    BUMP_COUNTER (CNT_OLE_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_OLE_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_OLE_ALLOC_FAILS);
        CHECK_BREAK (BRK_OLE_ALLOC_FAIL);
        return NULL;
    }
    
    return (* Function)(String);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
INT
STDAPICALLTYPE 
AVrfpSysReAllocString(BSTR * BStr, const OLECHAR *String)
{
    typedef INT (STDAPICALLTYPE * FUNCTION_TYPE) (BSTR *, const OLECHAR *);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpOleaut32Thunks,
                                          AVRF_INDEX_OLEAUT32_SYSREALLOCSTRING);

    BUMP_COUNTER (CNT_OLE_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_OLE_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_OLE_ALLOC_FAILS);
        CHECK_BREAK (BRK_OLE_ALLOC_FAIL);
        return FALSE;
    }
    
    return (* Function)(BStr, String);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
BSTR
STDAPICALLTYPE 
AVrfpSysAllocStringLen(const OLECHAR *String, UINT Length)
{
    typedef BSTR (STDAPICALLTYPE * FUNCTION_TYPE) (const OLECHAR *, UINT);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpOleaut32Thunks,
                                          AVRF_INDEX_OLEAUT32_SYSALLOCSTRINGLEN);

    BUMP_COUNTER (CNT_OLE_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_OLE_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_OLE_ALLOC_FAILS);
        CHECK_BREAK (BRK_OLE_ALLOC_FAIL);
        return NULL;
    }
    
    return (* Function)(String, Length);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
INT
STDAPICALLTYPE 
AVrfpSysReAllocStringLen(BSTR * BStr, const OLECHAR * String, UINT Length)
{
    typedef INT (STDAPICALLTYPE * FUNCTION_TYPE) (BSTR *, const OLECHAR *, UINT);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpOleaut32Thunks,
                                          AVRF_INDEX_OLEAUT32_SYSREALLOCSTRINGLEN);

    BUMP_COUNTER (CNT_OLE_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_OLE_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_OLE_ALLOC_FAILS);
        CHECK_BREAK (BRK_OLE_ALLOC_FAIL);
        return FALSE;
    }
    
    return (* Function)(BStr, String, Length);
}

#if defined(_X86_)
#pragma optimize("y", off) // disable FPO
#endif
BSTR 
STDAPICALLTYPE 
AVrfpSysAllocStringByteLen(LPCSTR psz, UINT len)
{
    typedef BSTR (STDAPICALLTYPE * FUNCTION_TYPE) (LPCSTR, UINT);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpOleaut32Thunks,
                                          AVRF_INDEX_OLEAUT32_SYSALLOCSTRINGBYTELEN);

    BUMP_COUNTER (CNT_OLE_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_OLE_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_OLE_ALLOC_FAILS);
        CHECK_BREAK (BRK_OLE_ALLOC_FAIL);
        return NULL;
    }
    
    return (* Function)(psz, len);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\public.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

    public.h

Abstract:

    This header concentrates internal verifier types that need to be available
    in the public symbols for debugging reasons.      

Author:

    Silviu Calinoiu (SilviuC) 12-Mar-2002

Revision History:

--*/

#ifndef _PUBLIC_SYMBOLS_H_
#define _PUBLIC_SYMBOLS_H_

//
// Maximum runtime stack trace size.
//

#define MAX_TRACE_DEPTH 16


typedef struct _AVRF_EXCEPTION_LOG_ENTRY {

    HANDLE ThreadId;
    ULONG ExceptionCode;
    PVOID ExceptionAddress;
    PVOID ExceptionRecord;
    PVOID ContextRecord;

} AVRF_EXCEPTION_LOG_ENTRY, *PAVRF_EXCEPTION_LOG_ENTRY;


typedef struct _AVRF_THREAD_ENTRY {

    LIST_ENTRY HashChain;
    HANDLE Id;

    PTHREAD_START_ROUTINE Function;
    PVOID Parameter;

    HANDLE ParentThreadId;
    SIZE_T StackSize;
    ULONG CreationFlags;

} AVRF_THREAD_ENTRY, * PAVRF_THREAD_ENTRY;


typedef struct _CRITICAL_SECTION_SPLAY_NODE {

    RTL_SPLAY_LINKS	SplayLinks;
    PRTL_CRITICAL_SECTION CriticalSection;
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    HANDLE EnterThread;
    HANDLE WaitThread;
    HANDLE TryEnterThread;
    HANDLE LeaveThread;
} CRITICAL_SECTION_SPLAY_NODE, *PCRITICAL_SECTION_SPLAY_NODE;

#include "deadlock.h"

typedef struct _AVRF_VSPACE_REGION {

    LIST_ENTRY List;
    ULONG_PTR Address;
    ULONG_PTR Size;
    PVOID Trace[MAX_TRACE_DEPTH];

} AVRF_VSPACE_REGION, * PAVRF_VSPACE_REGION;


//
// Other public headers.
//

#include "tracker.h"


#endif // _PUBLIC_SYMBOLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\pch.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

    pch.h

Abstract:

    Precompiled header for the standard application verifier provider.

Author:

    Daniel Mihai (DMihai) 2-Feb-2001

Revision History:

--*/

#ifndef _VERIFIER_PCH_H_
#define _VERIFIER_PCH_H_

//
// Disable warnings coming from public headers so that we can compile
// verifier code at W4 warning level.
//      
      
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4152)   // function to data pointer conversion
#pragma warning(disable:4055)   // data to function pointer conversion

#include <..\..\ntos\inc\ntos.h> // for InterlockedXxx functions
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <oleauto.h>

#include <heap.h>
#include <heappagi.h>

#include "avrf.h"

//
// Inside verifier.dll we use VerifierStopMessage which is the actual
// stop reporting function. Therefore we need to undefine the
// macro we get from nturtl.h.
//

#undef VERIFIER_STOP

#endif // _VERIFIER_PCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\hooks.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    hooks.c

Abstract:

    This module implements verifier hooks for various
    APIs that do not fall in any specific category.

Author:

    Silviu Calinoiu (SilviuC) 3-Dec-2001

Revision History:

    3-Dec-2001 (SilviuC): initial version.

--*/

#include "pch.h"

#include "verifier.h"
#include "support.h"
#include "faults.h"

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////// Wait APIs
/////////////////////////////////////////////////////////////////////

//WINBASEAPI
DWORD
WINAPI
AVrfpWaitForSingleObject(
    IN HANDLE hHandle,
    IN DWORD dwMilliseconds
    )
{
    typedef DWORD (WINAPI * FUNCTION_TYPE) (HANDLE, DWORD);
    FUNCTION_TYPE Function;
    DWORD Result;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_WAITFORSINGLEOBJECT);

    BUMP_COUNTER (CNT_WAIT_SINGLE_CALLS);
    
    if (dwMilliseconds != INFINITE && dwMilliseconds != 0) {
        
        BUMP_COUNTER (CNT_WAIT_WITH_TIMEOUT_CALLS);

        if (SHOULD_FAULT_INJECT(CLS_WAIT_APIS)) {
            BUMP_COUNTER (CNT_WAIT_WITH_TIMEOUT_FAILS);
            CHECK_BREAK (BRK_WAIT_WITH_TIMEOUT_FAIL);
            return WAIT_TIMEOUT;
        }
    }

    Result = (* Function) (hHandle, dwMilliseconds);

    //
    // No matter if it fails or not we will introduce a random delay
    // in order to randomize the timings in the process.
    //

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RACE_CHECKS)) {
        AVrfpCreateRandomDelay ();
    }

    return Result;
}


//WINBASEAPI
DWORD
WINAPI
AVrfpWaitForMultipleObjects(
    IN DWORD nCount,
    IN CONST HANDLE *lpHandles,
    IN BOOL bWaitAll,
    IN DWORD dwMilliseconds
    )
{
    typedef DWORD (WINAPI * FUNCTION_TYPE) (DWORD, CONST HANDLE *, BOOL, DWORD);
    FUNCTION_TYPE Function;
    DWORD Result;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_WAITFORMULTIPLEOBJECTS);

    BUMP_COUNTER (CNT_WAIT_MULTIPLE_CALLS);
    
    if (dwMilliseconds != INFINITE && dwMilliseconds != 0) {
        
        BUMP_COUNTER (CNT_WAIT_WITH_TIMEOUT_CALLS);
        
        if (SHOULD_FAULT_INJECT(CLS_WAIT_APIS)) {
            BUMP_COUNTER (CNT_WAIT_WITH_TIMEOUT_FAILS);
            CHECK_BREAK (BRK_WAIT_WITH_TIMEOUT_FAIL);
            return WAIT_TIMEOUT;
        }
    }
    
    Result = (* Function) (nCount, lpHandles, bWaitAll, dwMilliseconds);

    //
    // No matter if it fails or not we will introduce a random delay
    // in order to randomize the timings in the process.
    //

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RACE_CHECKS)) {
        AVrfpCreateRandomDelay ();
    }

    return Result;
}


//WINBASEAPI
DWORD
WINAPI
AVrfpWaitForSingleObjectEx(
    IN HANDLE hHandle,
    IN DWORD dwMilliseconds,
    IN BOOL bAlertable
    )
{
    typedef DWORD (WINAPI * FUNCTION_TYPE) (HANDLE, DWORD, BOOL);
    FUNCTION_TYPE Function;
    DWORD Result;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_WAITFORSINGLEOBJECTEX);

    BUMP_COUNTER (CNT_WAIT_SINGLEEX_CALLS);
    
    if (dwMilliseconds != INFINITE && dwMilliseconds != 0) {
        
        BUMP_COUNTER (CNT_WAIT_WITH_TIMEOUT_CALLS);
        
        if (SHOULD_FAULT_INJECT(CLS_WAIT_APIS)) {
            BUMP_COUNTER (CNT_WAIT_WITH_TIMEOUT_FAILS);
            CHECK_BREAK (BRK_WAIT_WITH_TIMEOUT_FAIL);
            return WAIT_TIMEOUT;
        }
    }
    
    Result = (* Function) (hHandle, dwMilliseconds, bAlertable);

    //
    // No matter if it fails or not we will introduce a random delay
    // in order to randomize the timings in the process.
    //

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RACE_CHECKS)) {
        AVrfpCreateRandomDelay ();
    }

    return Result;
}


//WINBASEAPI
DWORD
WINAPI
AVrfpWaitForMultipleObjectsEx(
    IN DWORD nCount,
    IN CONST HANDLE *lpHandles,
    IN BOOL bWaitAll,
    IN DWORD dwMilliseconds,
    IN BOOL bAlertable
    )
{
    typedef DWORD (WINAPI * FUNCTION_TYPE) (DWORD, CONST HANDLE *, BOOL, DWORD, BOOL);
    FUNCTION_TYPE Function;
    DWORD Result;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_WAITFORMULTIPLEOBJECTSEX);

    BUMP_COUNTER (CNT_WAIT_MULTIPLEEX_CALLS);

    if (dwMilliseconds != INFINITE && dwMilliseconds != 0) {
        
        BUMP_COUNTER (CNT_WAIT_WITH_TIMEOUT_CALLS);
        
        if (SHOULD_FAULT_INJECT(CLS_WAIT_APIS)) {
            BUMP_COUNTER (CNT_WAIT_WITH_TIMEOUT_FAILS);
            CHECK_BREAK (BRK_WAIT_WITH_TIMEOUT_FAIL);
            return WAIT_TIMEOUT;
        }
    }
    
    Result = (* Function) (nCount, lpHandles, bWaitAll, dwMilliseconds, bAlertable);
    
    //
    // No matter if it fails or not we will introduce a random delay
    // in order to randomize the timings in the process.
    //

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RACE_CHECKS)) {
        AVrfpCreateRandomDelay ();
    }

    return Result;
}

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    NTSTATUS Status;

    //
    // Verify that it is legal to wait for this object
    // in the current state. One example of illegal wait
    // is waiting for a thread object while holding the 
    // loader lock. That thread will need the loader lock 
    // when calling ExitThread so it will most likely 
    // deadlock with the current thread.
    //

    AVrfpVerifyLegalWait (&Handle,
                          1,
                          TRUE);

    //
    // Call the original function.
    //

    Status = NtWaitForSingleObject (Handle,
                                    Alertable,
                                    Timeout);

    return Status;
}

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtWaitForMultipleObjects(
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    NTSTATUS Status;

    //
    // Verify that it is legal to wait for these objects
    // in the current state. One example of illegal wait
    // is waiting for a thread object while holding the 
    // loader lock. That thread will need the loader lock 
    // when calling ExitThread so it will most likely 
    // deadlock with the current thread.
    //

    AVrfpVerifyLegalWait (Handles,
                          Count,
                          (WaitType == WaitAll));

    //
    // Call the original function.
    //

    Status = NtWaitForMultipleObjects (Count,
                                       Handles,
                                       WaitType,
                                       Alertable,
                                       Timeout);

    return Status;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////// File APIs
/////////////////////////////////////////////////////////////////////

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    )
{
    NTSTATUS Status;

    if (SHOULD_FAULT_INJECT(CLS_FILE_APIS)) {
        CHECK_BREAK (BRK_CREATE_FILE_FAIL);
        return STATUS_NO_MEMORY;
    }
    
    Status = NtCreateFile (FileHandle,
                           DesiredAccess,
                           ObjectAttributes,
                           IoStatusBlock,
                           AllocationSize,
                           FileAttributes,
                           ShareAccess,
                           CreateDisposition,
                           CreateOptions,
                           EaBuffer,
                           EaLength);

    return Status;
}


//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    )
{
    NTSTATUS Status;

    if (SHOULD_FAULT_INJECT(CLS_FILE_APIS)) {
        CHECK_BREAK (BRK_CREATE_FILE_FAIL);
        return STATUS_NO_MEMORY;
    }
    
    Status = NtOpenFile (FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         ShareAccess,
                         OpenOptions);
    
    return Status;
}

//WINBASEAPI
HANDLE
WINAPI                          
AVrfpCreateFileA(
    IN LPCSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile
    )
{
    typedef HANDLE (WINAPI * FUNCTION_TYPE) 
        (LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES,
         DWORD, DWORD, HANDLE);

    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_CREATEFILEA);

    if (SHOULD_FAULT_INJECT(CLS_FILE_APIS)) {
        CHECK_BREAK (BRK_CREATE_FILE_FAIL);
        NtCurrentTeb()->LastErrorValue = ERROR_OUTOFMEMORY;
        return INVALID_HANDLE_VALUE;
    }
    
    return (* Function) (lpFileName,
                         dwDesiredAccess,
                         dwShareMode,
                         lpSecurityAttributes,
                         dwCreationDisposition,
                         dwFlagsAndAttributes,
                         hTemplateFile);
}

//WINBASEAPI
HANDLE
WINAPI
AVrfpCreateFileW(
    IN LPCWSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile
    )
{
    typedef HANDLE (WINAPI * FUNCTION_TYPE) 
        (LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES,
         DWORD, DWORD, HANDLE);

    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_CREATEFILEW);

    if (SHOULD_FAULT_INJECT(CLS_FILE_APIS)) {
        CHECK_BREAK (BRK_CREATE_FILE_FAIL);
        NtCurrentTeb()->LastErrorValue = ERROR_OUTOFMEMORY;
        return INVALID_HANDLE_VALUE;
    }
    
    return (* Function) (lpFileName,
                         dwDesiredAccess,
                         dwShareMode,
                         lpSecurityAttributes,
                         dwCreationDisposition,
                         dwFlagsAndAttributes,
                         hTemplateFile);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Registry APIs
/////////////////////////////////////////////////////////////////////

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    )
{
    NTSTATUS Status;

    if (SHOULD_FAULT_INJECT(CLS_REGISTRY_APIS)) {
        CHECK_BREAK (BRK_CREATE_KEY_FAIL);
        return STATUS_NO_MEMORY;
    }
    
    Status = NtCreateKey (KeyHandle,
                          DesiredAccess,
                          ObjectAttributes,
                          TitleIndex,
                          Class,
                          CreateOptions,
                          Disposition);
    
    return Status;
}

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    NTSTATUS Status;

    if (SHOULD_FAULT_INJECT(CLS_REGISTRY_APIS)) {
        CHECK_BREAK (BRK_CREATE_KEY_FAIL);
        return STATUS_NO_MEMORY;
    }
    
    Status = NtOpenKey (KeyHandle,
                        DesiredAccess,
                        ObjectAttributes);
    
    return Status;
}

//WINADVAPI
LONG
APIENTRY
AVrfpRegCreateKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    typedef LONG (APIENTRY * FUNCTION_TYPE) 
        (HKEY, LPCSTR, PHKEY);

    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpAdvapi32Thunks,
                                          AVRF_INDEX_ADVAPI32_REGCREATEKEYA);

    if (SHOULD_FAULT_INJECT(CLS_REGISTRY_APIS)) {
        CHECK_BREAK (BRK_CREATE_KEY_FAIL);
        return ERROR_OUTOFMEMORY;
    }
    
    return (* Function) (hKey, lpSubKey, phkResult);
}

//WINADVAPI
LONG
APIENTRY
AVrfpRegCreateKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    typedef LONG (APIENTRY * FUNCTION_TYPE) 
        (HKEY, LPCWSTR, PHKEY);

    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpAdvapi32Thunks,
                                          AVRF_INDEX_ADVAPI32_REGCREATEKEYW);

    if (SHOULD_FAULT_INJECT(CLS_REGISTRY_APIS)) {
        CHECK_BREAK (BRK_CREATE_KEY_FAIL);
        return ERROR_OUTOFMEMORY;
    }

    return (* Function) (hKey, lpSubKey, phkResult);
}

//WINADVAPI
LONG
APIENTRY
AVrfpRegCreateKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    )
{
    typedef LONG (APIENTRY * FUNCTION_TYPE) 
        (HKEY, LPCSTR, DWORD, LPSTR, DWORD, 
         REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);

    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpAdvapi32Thunks,
                                          AVRF_INDEX_ADVAPI32_REGCREATEKEYEXA);

    if (SHOULD_FAULT_INJECT(CLS_REGISTRY_APIS)) {
        CHECK_BREAK (BRK_CREATE_KEY_FAIL);
        return ERROR_OUTOFMEMORY;
    }

    return (* Function) (hKey,
                         lpSubKey,
                         Reserved,
                         lpClass,
                         dwOptions,
                         samDesired,
                         lpSecurityAttributes,
                         phkResult,
                         lpdwDisposition);
}

//WINADVAPI
LONG
APIENTRY
AVrfpRegCreateKeyExW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD Reserved,
    IN LPWSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    )
{
    typedef LONG (APIENTRY * FUNCTION_TYPE) 
        (HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, 
         REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);

    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpAdvapi32Thunks,
                                          AVRF_INDEX_ADVAPI32_REGCREATEKEYEXW);

    if (SHOULD_FAULT_INJECT(CLS_REGISTRY_APIS)) {
        CHECK_BREAK (BRK_CREATE_KEY_FAIL);
        return ERROR_OUTOFMEMORY;
    }
    
    return (* Function) (hKey,
                         lpSubKey,
                         Reserved,
                         lpClass,
                         dwOptions,
                         samDesired,
                         lpSecurityAttributes,
                         phkResult,
                         lpdwDisposition);
}

//WINADVAPI
LONG
APIENTRY
AVrfpRegOpenKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    typedef LONG (APIENTRY * FUNCTION_TYPE) 
        (HKEY, LPCSTR, PHKEY);

    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpAdvapi32Thunks,
                                          AVRF_INDEX_ADVAPI32_REGOPENKEYA);

    if (SHOULD_FAULT_INJECT(CLS_REGISTRY_APIS)) {
        CHECK_BREAK (BRK_CREATE_KEY_FAIL);
        return ERROR_OUTOFMEMORY;
    }

    return (* Function)(hKey, lpSubKey, phkResult);
}

//WINADVAPI
LONG
APIENTRY
AVrfpRegOpenKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    typedef LONG (APIENTRY * FUNCTION_TYPE) 
        (HKEY, LPCWSTR, PHKEY);

    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpAdvapi32Thunks,
                                          AVRF_INDEX_ADVAPI32_REGOPENKEYW);

    if (SHOULD_FAULT_INJECT(CLS_REGISTRY_APIS)) {
        CHECK_BREAK (BRK_CREATE_KEY_FAIL);
        return ERROR_OUTOFMEMORY;
    }

    return (* Function)(hKey, lpSubKey, phkResult);
}

//WINADVAPI
LONG
APIENTRY
AVrfpRegOpenKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )
{
    typedef LONG (APIENTRY * FUNCTION_TYPE) 
        (HKEY, LPCSTR, DWORD, REGSAM, PHKEY);

    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpAdvapi32Thunks,
                                          AVRF_INDEX_ADVAPI32_REGOPENKEYEXA);

    if (SHOULD_FAULT_INJECT(CLS_REGISTRY_APIS)) {
        CHECK_BREAK (BRK_CREATE_KEY_FAIL);
        return ERROR_OUTOFMEMORY;
    }

    return (* Function) (hKey,
                         lpSubKey,
                         ulOptions,
                         samDesired,
                         phkResult);
}

//WINADVAPI
LONG
APIENTRY
AVrfpRegOpenKeyExW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )
{
    typedef LONG (APIENTRY * FUNCTION_TYPE) 
        (HKEY, LPCWSTR, DWORD, REGSAM, PHKEY);

    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpAdvapi32Thunks,
                                          AVRF_INDEX_ADVAPI32_REGOPENKEYEXW);

    if (SHOULD_FAULT_INJECT(CLS_REGISTRY_APIS)) {
        CHECK_BREAK (BRK_CREATE_KEY_FAIL);
        return ERROR_OUTOFMEMORY;
    }

    return (* Function) (hKey,
                         lpSubKey,
                         ulOptions,
                         samDesired,
                         phkResult);
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// Read/Write File I/O
/////////////////////////////////////////////////////////////////////

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )
{
    NTSTATUS Status;

    //
    // Fill the I/O buffer with garbage.
    //
    // silviuc: should we link this fill to some feature?
    // In principle the operation of filling memory is peanuts
    // compared with the time taken by the i/o operation. 
    //

    RtlFillMemory (Buffer, Length, 0xFA);

    //
    // Call original API.
    //

    Status = NtReadFile (FileHandle,
                         Event,
                         ApcRoutine,
                         ApcContext,
                         IoStatusBlock,
                         Buffer,
                         Length,
                         ByteOffset,
                         Key);

    //
    // Asynchronous operations are delayed a bit. This conceivably
    // has good chances to randomize timings in the process.
    //

    if (Status == STATUS_PENDING) {
        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RACE_CHECKS)) {
            AVrfpCreateRandomDelay ();
        }
    }

    return Status;
}

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtReadFileScatter(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )
{
    NTSTATUS Status;

    //
    // silviuc: we should fill these buffers with garbage too.
    //

    //
    // Call original API.
    //

    Status = NtReadFileScatter (FileHandle,
                                Event,
                                ApcRoutine,
                                ApcContext,
                                IoStatusBlock,
                                SegmentArray,
                                Length,
                                ByteOffset,
                                Key);

    //
    // Asynchronous operations are delayed a bit. This conceivably
    // has good chances to randomize timings in the process.
    //

    if (Status == STATUS_PENDING) {
        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RACE_CHECKS)) {
            AVrfpCreateRandomDelay ();
        }
    }

    return Status;
}

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )
{
    NTSTATUS Status;

    //
    // Call original API.
    //

    Status = NtWriteFile (FileHandle,
                          Event,
                          ApcRoutine,
                          ApcContext,
                          IoStatusBlock,
                          Buffer,
                          Length,
                          ByteOffset,
                          Key);
    
    //
    // Asynchronous operations are delayed a bit. This conceivably
    // has good chances to randomize timings in the process.
    //

    if (Status == STATUS_PENDING) {
        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RACE_CHECKS)) {
            AVrfpCreateRandomDelay ();
        }
    }

    return Status;
}

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtWriteFileGather(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )
{
    NTSTATUS Status;

    //
    // Call original API.
    //

    Status = NtWriteFileGather (FileHandle,
                                Event,
                                ApcRoutine,
                                ApcContext,
                                IoStatusBlock,
                                SegmentArray,
                                Length,
                                ByteOffset,
                                Key);

    //
    // Asynchronous operations are delayed a bit. This conceivably
    // has good chances to randomize timings in the process.
    //

    if (Status == STATUS_PENDING) {
        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RACE_CHECKS)) {
            AVrfpCreateRandomDelay ();
        }
    }

    return Status;
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////// Tick count overlap
/////////////////////////////////////////////////////////////////////

//
// Special value so that the counter will overlap in 5 mins.
//

DWORD AVrfpTickCountOffset = 0xFFFFFFFF - 5 * 60 * 1000;

//WINBASEAPI
DWORD
WINAPI
AVrfpGetTickCount(
    VOID
    )
{
    typedef DWORD (WINAPI * FUNCTION_TYPE) (VOID);
    FUNCTION_TYPE Function;
    DWORD Result;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_GETTICKCOUNT);

    Result = (* Function) ();

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_MISCELLANEOUS_CHECKS)) {

        return Result + AVrfpTickCountOffset;
    }
    else {

        return Result;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\settings.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

    settings.h

Abstract:

    Interfaces for enabling verifier flags.

Author:

    Silviu Calinoiu (SilviuC) 17-Apr-2001

Revision History:

--*/

#ifndef _SETTINGS_H_
#define _SETTINGS_H_

NTSTATUS
VerifierSetFlags (
    PUNICODE_STRING ApplicationName,
    ULONG VerifierFlags,
    PVOID Details
    );

#endif // _SETTINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\support.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    support.c

Abstract:

    This module implements internal support routines 
    for the verification code.

Author:

    Silviu Calinoiu (SilviuC) 1-Mar-2001

Revision History:

--*/

#include "pch.h"

#include "verifier.h"
#include "support.h"
#include "critsect.h"
#include "vspace.h"
#include "logging.h"
#include "tracker.h"

//
// Global data.
//

SYSTEM_BASIC_INFORMATION AVrfpSysBasicInfo;

//
// Global counters (for statistics).
//

ULONG AVrfpCounter[CNT_MAXIMUM_INDEX];

//
// Break triggers.
//

ULONG AVrfpBreak [BRK_MAXIMUM_INDEX];


/////////////////////////////////////////////////////////////////////
////////////////////////////////// Private ntdll entrypoints pointers
/////////////////////////////////////////////////////////////////////

PFN_RTLP_DEBUG_PAGE_HEAP_CREATE AVrfpRtlpDebugPageHeapCreate;
PFN_RTLP_DEBUG_PAGE_HEAP_DESTROY AVrfpRtlpDebugPageHeapDestroy;
PFN_RTLP_GET_STACK_TRACE_ADDRESS AVrfpGetStackTraceAddress;

//
// Exception logging support.
//

PAVRF_EXCEPTION_LOG_ENTRY AVrfpExceptionLog = NULL;
const ULONG AVrfpExceptionLogEntriesNo = 128;
LONG AVrfpExceptionLogCurrentIndex = 0;

PVOID AVrfpVectoredExceptionPointer;

//
// Internal functions declarations
//

LONG 
NTAPI
AVrfpVectoredExceptionHandler (
    struct _EXCEPTION_POINTERS * ExceptionPointers
    );

VOID
AVrfpCheckFirstChanceException (
    struct _EXCEPTION_POINTERS * ExceptionPointers
    );

VOID
AVrfpInitializeExceptionChecking (
    VOID
    )
{
    PVOID Handler;

    //
    // Establish a first chance exception handler.
    //

    Handler = RtlAddVectoredExceptionHandler (1, AVrfpVectoredExceptionHandler);
    AVrfpVectoredExceptionPointer = Handler;

    //
    // Allocate memory for our exception logging database.
    // If the allocation fails we will simply continue execution
    // with this feature disabled.
    //

    ASSERT (AVrfpExceptionLog == NULL);

    AVrfpExceptionLog = (PAVRF_EXCEPTION_LOG_ENTRY) 
        AVrfpAllocate (AVrfpExceptionLogEntriesNo * sizeof (AVRF_EXCEPTION_LOG_ENTRY));
}


VOID
AVrfpCleanupExceptionChecking (
    VOID
    )
{
    //
    // Establish a first chance exception handler.
    //

    if (AVrfpVectoredExceptionPointer) {
        
        RtlRemoveVectoredExceptionHandler (AVrfpVectoredExceptionPointer);
    }

    //
    // Free exception log database.
    //

    if (AVrfpExceptionLog) {
        
        AVrfpFree (AVrfpExceptionLog);
        AVrfpExceptionLog = NULL;
    }

}


VOID
AVrfpLogException (
    struct _EXCEPTION_POINTERS * ExceptionPointers
    )
{
    ULONG NewIndex;

    if (AVrfpExceptionLog != NULL) {

        NewIndex = (ULONG)InterlockedIncrement (&AVrfpExceptionLogCurrentIndex) % AVrfpExceptionLogEntriesNo;

        AVrfpExceptionLog[NewIndex].ThreadId = NtCurrentTeb()->ClientId.UniqueThread;
        AVrfpExceptionLog[NewIndex].ExceptionCode = ExceptionPointers->ExceptionRecord->ExceptionCode;
        AVrfpExceptionLog[NewIndex].ExceptionAddress = ExceptionPointers->ExceptionRecord->ExceptionAddress;
        AVrfpExceptionLog[NewIndex].ExceptionRecord = ExceptionPointers->ExceptionRecord;
        AVrfpExceptionLog[NewIndex].ContextRecord = ExceptionPointers->ContextRecord;
    }
}


LONG 
NTAPI
AVrfpVectoredExceptionHandler (
    struct _EXCEPTION_POINTERS * ExceptionPointers
    )
{
    DWORD ExceptionCode;

    //
    // We are holding RtlpCalloutEntryLock at this point 
    // so we are trying to protect ourselves with this other
    // try...except against possible other exceptions 
    // (e.g. an inpage error) that could leave the lock orphaned.
    //

    try {

        AVrfpLogException (ExceptionPointers);

        AVrfpCheckFirstChanceException (ExceptionPointers);

        ExceptionCode = ExceptionPointers->ExceptionRecord->ExceptionCode;

        if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_EXCEPTIONS) != 0) {

            DbgPrint ("AVRF: Exception %x from address %p\n",
                      ExceptionCode,
                      ExceptionPointers->ExceptionRecord->ExceptionAddress);
        }

        if (ExceptionCode == STATUS_INVALID_HANDLE) {

            //
            // RPC is using STATUS_INVALID_HANDLE exceptions with EXCEPTION_NONCONTINUABLE
            // for a private notification mechanism. The exceptions we are looking for 
            // are coming from the kernel code and they don't have the EXCEPTION_NONCONTINUABLE
            // flag set.
            //

            if ((ExceptionPointers->ExceptionRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE) == 0) {

                //
                // Note. When run under debugger this message will not kick in when an
                // exception gets raised because the debugger will break on first chance
                // exception. Only if the debugger is launched with `-xd ch' (ignore
                // first chance invalid handle exception) the message will be seen first.
                // Otherwise you see a plain exception and only after you hit go in
                // the debugger console you get the message.
                //

                VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_HANDLE | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "invalid handle exception for current stack trace",
                               ExceptionCode, "Exception code.",
                               ExceptionPointers->ExceptionRecord, "Exception record. Use .exr to display it.", 
                               ExceptionPointers->ContextRecord, "Context record. Use .cxr to display it.", 
                               0, "");

                //
                // We are hiding this exception after the verifier stop so the callers
                // of APIs like SetEvent with an invalid handle will not see the exception.
                //

                return EXCEPTION_CONTINUE_EXECUTION;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        // NOTHING;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}


VOID
AVrfpDirtyThreadStack (
    VOID
    )
{
    PTEB Teb = NtCurrentTeb();
    ULONG_PTR StackStart;
    ULONG_PTR StackEnd;

    try {

        StackStart = (ULONG_PTR)(Teb->NtTib.StackLimit);
        
        //
        // We dirty stacks only on x86 architectures. 
        //

#if defined(_X86_)
        _asm mov StackEnd, ESP;
#else
        StackEnd = StackStart;
#endif

        //
        // Limit stack dirtying to only 8K.
        //

        if (StackStart  < StackEnd - 0x2000) {
            StackStart = StackEnd - 0x2000;
        }

        if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_DIRTY_STACKS) != 0) {

            DbgPrint ("Dirtying stack range %p - %p for thread %p \n",
                      StackStart, StackEnd, Teb->ClientId.UniqueThread);
        }

        while (StackStart < StackEnd) {
            *((PULONG)StackStart) = 0xBAD1BAD1;
            StackStart += sizeof(ULONG);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
    
        // nothing
    }
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// Per thread table
/////////////////////////////////////////////////////////////////////

#define THREAD_TABLE_SIZE 61

LIST_ENTRY AVrfpThreadTable [THREAD_TABLE_SIZE];
RTL_CRITICAL_SECTION AVrfpThreadTableLock;

//
// Keep this constant so the debugger can read it.
//

const ULONG AVrfpThreadTableEntriesNo = THREAD_TABLE_SIZE;

//
// Keep this for debugging purposes.
//

AVRF_THREAD_ENTRY AVrfpMostRecentRemovedThreadEntry;

NTSTATUS
AVrfpThreadTableInitialize (
    VOID
    )
{
    PAVRF_THREAD_ENTRY Entry;
    ULONG I;
    NTSTATUS Status;

    Status = RtlInitializeCriticalSection (&AVrfpThreadTableLock);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    for (I = 0; I < THREAD_TABLE_SIZE; I += 1) {
        InitializeListHead (&(AVrfpThreadTable[I]));
    }

    //
    // Create an entry for the current thread (main thread). The function
    // is called during verifier!DllMain when there is a single thread
    // running in the process.
    //

    Entry = AVrfpAllocate (sizeof *Entry);

    if (Entry == NULL) {
        return STATUS_NO_MEMORY;
    }

    Entry->Id = NtCurrentTeb()->ClientId.UniqueThread;

    AVrfpThreadTableAddEntry (Entry);

    return STATUS_SUCCESS;
}


VOID
AVrfpThreadTableAddEntry (
    PAVRF_THREAD_ENTRY Entry
    )
{
    ULONG ChainIndex;

    ASSERT (Entry != NULL);
    ASSERT (Entry->Id != NULL);

    ChainIndex = (HandleToUlong(Entry->Id) >> 2) % THREAD_TABLE_SIZE;

    RtlEnterCriticalSection (&AVrfpThreadTableLock);

    //
    // It is important to add the new entry at the head of the list
    // (not tail) because the list can contain zombies left after someone
    // called TerminateThread and the thread handle value got reused.
    //

    InsertHeadList (&(AVrfpThreadTable[ChainIndex]),
                    &(Entry->HashChain));

    RtlLeaveCriticalSection (&AVrfpThreadTableLock);
}


VOID
AVrfpThreadTableRemoveEntry (
    PAVRF_THREAD_ENTRY Entry
    )
{
    RtlEnterCriticalSection (&AVrfpThreadTableLock);

    RtlCopyMemory (&AVrfpMostRecentRemovedThreadEntry,
                   Entry,
                   sizeof (AVrfpMostRecentRemovedThreadEntry));

    RemoveEntryList (&(Entry->HashChain));

    RtlLeaveCriticalSection (&AVrfpThreadTableLock);
}


PAVRF_THREAD_ENTRY
AVrfpThreadTableSearchEntry (
    HANDLE Id
    )
{
    ULONG ChainIndex;
    PLIST_ENTRY Current;
    PAVRF_THREAD_ENTRY Entry;
    PAVRF_THREAD_ENTRY Result;

    ChainIndex = (HandleToUlong(Id) >> 2) % THREAD_TABLE_SIZE;

    Result = NULL;

    RtlEnterCriticalSection (&AVrfpThreadTableLock);
    
    Current = AVrfpThreadTable[ChainIndex].Flink;

    while (Current != &(AVrfpThreadTable[ChainIndex])) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_THREAD_ENTRY,
                                   HashChain);

        if (Entry->Id == Id) {
            Result = Entry;
            goto Exit;
        }

        Current = Current->Flink;
    }


    Exit:

    RtlLeaveCriticalSection (&AVrfpThreadTableLock);

    return Result;
}



/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Verifier TLS slot
/////////////////////////////////////////////////////////////////////

#define INVALID_TLS_INDEX 0xFFFFFFFF
ULONG AVrfpTlsIndex = INVALID_TLS_INDEX;

AVRF_TLS_STRUCT AVrfpFirstThreadTlsStruct = { 0 };

LIST_ENTRY AVrfpTlsListHead;

NTSTATUS
AVrfpAllocateVerifierTlsSlot (
    VOID
    )
{
    PPEB Peb;
    PTEB Teb;
    DWORD Index;
    NTSTATUS Status;

    InitializeListHead (&AVrfpTlsListHead);

    Peb = NtCurrentPeb();
    Teb = NtCurrentTeb();
    Status = STATUS_SUCCESS;

    RtlAcquirePebLock();

    //
    // This function is called very early during process startup therefore
    // we expect to find a TLS index in the first slots (most typically
    // it is zero although we do not do anything specific to enforce that).
    //

    Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->TlsBitmap,1,0);

    if (Index == INVALID_TLS_INDEX) {

        DbgPrint ("AVRF: failed to allocated a verifier TLS slot.\n");

        Status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    AVrfpTlsIndex = Index;
    
    AVrfpFirstThreadTlsStruct.Teb = Teb;
    AVrfpFirstThreadTlsStruct.ThreadId = Teb->ClientId.UniqueThread;

    InsertHeadList (&AVrfpTlsListHead,
                    &AVrfpFirstThreadTlsStruct.ListEntry);
    Teb->TlsSlots[Index] = &AVrfpFirstThreadTlsStruct;

    Exit:

    RtlReleasePebLock();
    return Status;
}


PAVRF_TLS_STRUCT
AVrfpGetVerifierTlsValue(
    VOID
    )
{
    PTEB Teb;
    PVOID *Slot;

    if (AVrfpTlsIndex == INVALID_TLS_INDEX) {
        return NULL;
    }

    Teb = NtCurrentTeb();

    Slot = &Teb->TlsSlots[AVrfpTlsIndex];
    return (PAVRF_TLS_STRUCT)*Slot;
}


VOID
AVrfpSetVerifierTlsValue(
    PAVRF_TLS_STRUCT Value
    )
{
    PTEB Teb;

    if (AVrfpTlsIndex == INVALID_TLS_INDEX) {
        return;
    }

    Teb = NtCurrentTeb();

    Teb->TlsSlots[AVrfpTlsIndex] = Value;
}


VOID
AvrfpThreadAttach (
    VOID
    )
{
    PAVRF_TLS_STRUCT TlsStruct;
    PTEB Teb;

    ASSERT (AVrfpGetVerifierTlsValue () == NULL);

    TlsStruct = (PAVRF_TLS_STRUCT) AVrfpAllocate (sizeof *TlsStruct);

    if (TlsStruct != NULL) {

        Teb = NtCurrentTeb();
        TlsStruct->ThreadId = Teb->ClientId.UniqueThread;
        TlsStruct->Teb = Teb;

        //
        // We are protected by the loader lock so we shouldn't 
        // need any additional synchronization here.
        //

        InsertHeadList (&AVrfpTlsListHead,
                        &TlsStruct->ListEntry);
        
        AVrfpSetVerifierTlsValue (TlsStruct);
    }
}


VOID
AvrfpThreadDetach (
    VOID
    )
{
    volatile PAVRF_TLS_STRUCT TlsStruct;
    PTEB Teb;

    TlsStruct = AVrfpGetVerifierTlsValue();

    if (TlsStruct != NULL && TlsStruct != &AVrfpFirstThreadTlsStruct) {

        //
        // We are protected by the loader lock so we shouldn't 
        // need any additional synchronization here.
        //
            
        Teb = NtCurrentTeb();
        if (TlsStruct->Teb != Teb || TlsStruct->ThreadId != Teb->ClientId.UniqueThread) {

            VERIFIER_STOP (APPLICATION_VERIFIER_INTERNAL_ERROR,
                           "Corrupted TLS structure",
                           TlsStruct->Teb, "TEB address",
                           Teb, "Expected TEB address",
                           TlsStruct->ThreadId, "Thread ID",
                           Teb->ClientId.UniqueThread, "Expected Thread ID");
        }

        RemoveEntryList (&TlsStruct->ListEntry);

        AVrfpFree (TlsStruct);

        AVrfpSetVerifierTlsValue (NULL);
    }

    //
    // Delete the virtual space region containing the thread's stack from
    // the tracked. Since the stack is freed from kernel mode we will miss
    // the operation otherwise.
    //

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING) != 0) {
        AVrfpVsTrackDeleteRegionContainingAddress (&TlsStruct);
    }
}   


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// Dll entry point hooking
/////////////////////////////////////////////////////////////////////

typedef struct _DLL_ENTRY_POINT_INFO {

    LIST_ENTRY List;

    PVOID DllBase;
    PDLL_INIT_ROUTINE EntryPoint;
    PLDR_DATA_TABLE_ENTRY Ldr;

} DLL_ENTRY_POINT_INFO, * PDLL_ENTRY_POINT_INFO;

LIST_ENTRY DllLoadListHead;
RTL_CRITICAL_SECTION DllLoadListLock;


PDLL_ENTRY_POINT_INFO 
AVrfpFindDllEntryPoint (
    PVOID DllBase
    );

BOOLEAN
AVrfpStandardDllEntryPointRoutine (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    );

ULONG
AVrfpDllEntryPointExceptionFilter (
    ULONG ExceptionCode,
    PVOID ExceptionRecord,
    PDLL_ENTRY_POINT_INFO DllInfo
    );

NTSTATUS
AVrfpDllInitialize (
    VOID
    )
/*++

Routine description:

    This routine initializes dll entry point hooking structures.
    
    It is called during the PROCESS_VERIFIER for verifier.dll.
    It cannot be called during PROCESS_ATTACH because it is too late and
    by that time we already need the structures initialized.

Parameters:

    None. 
    
Return value:

    None.
    
--*/
{
    NTSTATUS Status;

    InitializeListHead (&DllLoadListHead);

    Status = RtlInitializeCriticalSection (&DllLoadListLock);

    return Status;
}


VOID
AVrfpDllLoadCallback (
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved
    )
/*++

Routine description:

    This routine is a dll load callback called by the verifier engine 
    (from ntdll.dll) whenever a dll gets loaded.

Parameters:

    DllName - name of the dll
    
    DllBase - base load address 
    
    DllSize - size of the dll
    
    Reserved - pointer to the LDR_DATA_TABLE_ENTRY structure maintained by the
        loader for this dll.
    
Return value:

    None.
    
--*/
{
    PLDR_DATA_TABLE_ENTRY Ldr;
    PDLL_ENTRY_POINT_INFO Info;

    UNREFERENCED_PARAMETER (DllBase);
    UNREFERENCED_PARAMETER (DllSize);

    Ldr = (PLDR_DATA_TABLE_ENTRY)Reserved;

    ASSERT (Ldr != NULL);

    //
    // Make sure we do not have a null entry point. We will ignore
    // these ones. No harm done. 
    //

    if (Ldr->EntryPoint == NULL) {
        
        if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_DLLMAIN_HOOKING) != 0) {
            DbgPrint ("AVRF: %ws: null entry point.\n", DllName);
        }
        
        return;
    }
    else {
        
        if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_DLLMAIN_HOOKING) != 0) {
            
            DbgPrint ("AVRF: %ws @ %p: entry point @ %p .\n", 
                      DllName, Ldr->DllBase, Ldr->EntryPoint);
        }
    }

    //
    // We will change the dll entry point.
    //

    Info = AVrfpAllocate (sizeof *Info);

    if (Info == NULL) {

        //
        // If we cannot allocate the dll info we will let everything
        // continue. We will just not verify this dll entry.
        //

        if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_DLLMAIN_HOOKING) != 0) {
            DbgPrint ("AVRF: low memory: will not verify entry point for %ws .\n", DllName);
        }
        
        return;
    }

    Info->EntryPoint = (PDLL_INIT_ROUTINE)(Ldr->EntryPoint);
    Info->DllBase = Ldr->DllBase;
    Info->Ldr = Ldr;

    RtlEnterCriticalSection (&DllLoadListLock);

    try {

        Ldr->EntryPoint = AVrfpStandardDllEntryPointRoutine;
        InsertTailList (&DllLoadListHead, &(Info->List));
    }
    finally {

        RtlLeaveCriticalSection (&DllLoadListLock);
    }
    
    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_DLLMAIN_HOOKING) != 0) {
        DbgPrint ("AVRF: hooked dll entry point for dll %ws \n", DllName);
    }
}


VOID
AVrfpDllUnloadCallback (
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved
    )
/*++

Routine description:

    This routine is a dll unload callback called by the verifier engine 
    (from ntdll.dll) whenever a dll gets unloaded.

Parameters:

    DllName - name of the dll
    
    DllBase - base load address 
    
    DllSize - size of the dll
    
    Reserved - pointer to the LDR_DATA_TABLE_ENTRY structure maintained by the
        loader for this dll.
    
Return value:

    None.
    
--*/
{
    PDLL_ENTRY_POINT_INFO Info;
    BOOLEAN FoundEntry;

    UNREFERENCED_PARAMETER (Reserved);

    FoundEntry = FALSE;
    Info = NULL;

    ASSERT (DllBase != NULL);

    //
    // Notify anybody interested in checking the fact that DLL's virtual
    // region will be discarded.
    //

    AVrfpFreeMemNotify (VerifierFreeMemTypeUnloadDll,
                        DllBase,
                        DllSize,
                        DllName);

    //
    // We need to find the dll in our own dll list, remove it from 
    // the list and free entry point information. There are a few cases
    // where there might be no entry there so we have to protect against
    // that (null entry point in the first place or low memory).
    //

    RtlEnterCriticalSection (&DllLoadListLock);

    try {
        
        Info = AVrfpFindDllEntryPoint (DllBase);

        if (Info) {
            RemoveEntryList (&(Info->List));
        }
    }
    finally {

        RtlLeaveCriticalSection (&DllLoadListLock);
    }

    if (Info) {
        AVrfpFree (Info);
    }
}


PDLL_ENTRY_POINT_INFO 
AVrfpFindDllEntryPoint (
    PVOID DllBase
    )
/*++

Routine description:

    This routine searches for a dll entry point descriptor in the list of
    descriptors kept by verifier for one that matches the dll base address
    passed as a parameter.                
    
    Before calling this function the DllLoadListLock must be acquired.
                
Parameters:

    DllBase - dll base load address for the dll to be found. 
    
Return value:

    A pointer to a dll descriptor if an entry was found and null otherwise.
    
--*/
{
    PDLL_ENTRY_POINT_INFO Info;
    BOOLEAN FoundEntry;
    PLIST_ENTRY Current;

    FoundEntry = FALSE;
    Info = NULL;

    ASSERT (DllBase != NULL);

    //
    // Search for the dll in our own dll list.
    //

    Current = DllLoadListHead.Flink;

    while (Current != &DllLoadListHead) {

        Info = CONTAINING_RECORD (Current,
                                  DLL_ENTRY_POINT_INFO,
                                  List);

        Current = Current->Flink;

        if (Info->DllBase == DllBase) {

            FoundEntry = TRUE;

            break;
        }
    }

    if (FoundEntry == FALSE) {

        return NULL;
    }
    else {

        return Info;
    }
}



BOOLEAN
AVrfpStandardDllEntryPointRoutine (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
/*++

Routine description:

    This routine is the standard DllMain routine that replaces all the entry points
    hooked. It will call in turn the original entry point.

Parameters:

    Same as the original dll entry point.
    
Return value:

    Same as the original dll entry point.
    
--*/
{
    PDLL_ENTRY_POINT_INFO DllInfo;
    BOOLEAN Result;
    PAVRF_TLS_STRUCT TlsStruct;

    Result = FALSE;
    DllInfo = NULL;

    //
    // Search a dll entry point descriptor for this dll address.
    //

    RtlEnterCriticalSection (&DllLoadListLock);

    try {
        
        DllInfo = AVrfpFindDllEntryPoint (DllHandle);
        
        //
        // If we did not manage to find a dll descriptor for this one it is
        // weird. For out of memory conditions we do not change the original
        // entry point therefore we should never get into this function w/o
        // a descriptor in the dll list.
        //

        if (DllInfo == NULL) {

            DbgPrint ("AVRF: warning: no descriptor for DLL loaded @ %p .\n", DllHandle);

            ASSERT (DllInfo != NULL);

            //
            // Simulate a successful return;
            //

            RtlLeaveCriticalSection (&DllLoadListLock);
            return TRUE;
        }
        else {

            //
            // If we found a dll entry but the entry point is null we just
            // simulate a successful return from DllMain.
            //

            if (DllInfo->EntryPoint == NULL) {

                DbgPrint ("AVRF: warning: null entry point for DLL descriptor @ %p .\n", DllInfo);

                ASSERT (DllInfo->EntryPoint != NULL);

                RtlLeaveCriticalSection (&DllLoadListLock);
                return TRUE;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
    }

    RtlLeaveCriticalSection (&DllLoadListLock);

    //
    // Mark this thread as loader lock owner.
    // If the real DllMain later on calls WaitForSingleObject 
    // on another thread handle we will use this flag to detect the issue 
    // and break into debugger because that other thread will need the 
    // loader lock when it will call ExitThread.
    //

    TlsStruct = AVrfpGetVerifierTlsValue();

    if (TlsStruct != NULL) {

        TlsStruct->Flags |= VRFP_THREAD_FLAGS_LOADER_LOCK_OWNER;
    }

    //
    // Call the real entry point wrapped in try/except.
    //

    try {

        try {

            if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_DLLMAIN_CALL) != 0) {
            
                DbgPrint ("AVRF: dll entry @ %p (%ws, %x) \n",
                        DllInfo->EntryPoint,
                        DllInfo->Ldr->FullDllName.Buffer,
                        Reason);
            }
            
            Result = (DllInfo->EntryPoint) (DllHandle, Reason, Context);
        }
        except (AVrfpDllEntryPointExceptionFilter (_exception_code(), _exception_info(), DllInfo)) {

            NOTHING;
        }
    }
    finally {

        if (TlsStruct != NULL) {

            TlsStruct->Flags &= ~VRFP_THREAD_FLAGS_LOADER_LOCK_OWNER;
        }
    }

    return Result;
}


ULONG
AVrfpDllEntryPointExceptionFilter (
    ULONG ExceptionCode,
    PVOID ExceptionRecord,
    PDLL_ENTRY_POINT_INFO DllInfo
    )
/*++

Routine description:

    This routine is the exception filter used to cath exceptions raised
    from a dll initialization function.

Parameters:

    ExceptionCode - exception code.
    
    ExceptionRecord - exception pointers.
    
Return value:

    Returns EXCEPTION_CONTINUE_SEARCH.
    
--*/
{                     
    PEXCEPTION_POINTERS Exception;

    //
    // Skip timeout and breakpoint exceptions.
    //

    if (ExceptionCode != STATUS_POSSIBLE_DEADLOCK &&
        ExceptionCode != STATUS_BREAKPOINT) {

        Exception = (PEXCEPTION_POINTERS)ExceptionRecord;

        VERIFIER_STOP (APPLICATION_VERIFIER_UNEXPECTED_EXCEPTION | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                       "unexpected exception raised in DLL entry point routine",
                       DllInfo->Ldr->BaseDllName.Buffer, "DLL name (use du to dump it)",
                       Exception->ExceptionRecord, "Exception record (.exr THIS-ADDRESS)",
                       Exception->ContextRecord, "Context record (.cxr THIS-ADDRESS)",
                       DllInfo, "Verifier dll descriptor");
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

VOID
AVrfpVerifyLegalWait (
    CONST HANDLE *Handles,
    DWORD Count,
    BOOL WaitAll
    )
{
    DWORD Index;
    PAVRF_TLS_STRUCT TlsStruct;
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION ThreadInfo;
    BYTE QueryBuffer[200];
    POBJECT_TYPE_INFORMATION TypeInfo = (POBJECT_TYPE_INFORMATION)QueryBuffer;

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_HANDLE_CHECKS) == 0) {

        goto Done;
    }

    if (Handles == NULL || Count == 0) {

        VERIFIER_STOP (APPLICATION_VERIFIER_INCORRECT_WAIT_CALL | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                       "incorrect Wait call",
                       Handles, "Address of object handle(s)",
                       Count, "Number of handles",
                       NULL, "",
                       NULL, "");
    }
    else {

        //
        // Check if the current thread owns the loader lock.
        //

        TlsStruct = AVrfpGetVerifierTlsValue();

        for (Index = 0; Index < Count; Index += 1) {

            //
            // Verify that the handle is not NULL.
            //
            
            if (Handles[Index] == NULL) {

                VERIFIER_STOP (APPLICATION_VERIFIER_NULL_HANDLE | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "using NULL handle",
                               NULL, "",
                               NULL, "",
                               NULL, "",
                               NULL, "");

                continue;
            }

            if ((TlsStruct == NULL) || 
                ((TlsStruct->Flags & VRFP_THREAD_FLAGS_LOADER_LOCK_OWNER) == 0) ||
                (RtlDllShutdownInProgress() != FALSE) ||
                (WaitAll == FALSE)) {

                continue;
            }

            //
            // The current thread is the loader lock owner.
            // Check if any of the objects we are about to wait on is
            // a thread in the current process. This would be illegal because 
            // that thread will need the loader lock when calling ExitThread
            // so we will most likely deadlock.
            //

            Status = NtQueryObject (Handles[Index],
                                    ObjectTypeInformation,
                                    QueryBuffer,
                                    sizeof (QueryBuffer),
                                    NULL);
            
            if (NT_SUCCESS(Status) && 
                RtlEqualUnicodeString (&AVrfpThreadObjectName,
                                       &(((POBJECT_TYPE_INFORMATION)TypeInfo)->TypeName),
                                       FALSE)) {
                
                //
                // We are trying to wait on this thread handle.
                // Check if this thread is in the current process. 
                //
    
                Status = NtQueryInformationThread (Handles[Index],
                                                   ThreadBasicInformation,
                                                   &ThreadInfo,
                                                   sizeof (ThreadInfo),
                                                   NULL);

                if (NT_SUCCESS(Status) &&
                    ThreadInfo.ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) {
    
                    VERIFIER_STOP (APPLICATION_VERIFIER_WAIT_IN_DLLMAIN | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                   "waiting on a thread handle in DllMain",
                                   Handles[Index], "Thread handle",
                                   NULL, "",
                                   NULL, "",
                                   NULL, "");
                }
            }
        }
    }

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Race verifier
/////////////////////////////////////////////////////////////////////

//
// Race verifier
//
// Race verifier introduces short random delays immediately after
// a thread acquires a resource (successful wait or enter/tryenter
// critical section). The idea behind it is that this will create
// a significant amount of timing randomization in the process.
//

ULONG AVrfpRaceDelayInitialSeed;
ULONG AVrfpRaceDelaySeed;
ULONG AVrfpRaceProbability = 5; // 5%

VOID
AVrfpCreateRandomDelay (
    VOID
    )
{
    LARGE_INTEGER PerformanceCounter;
    LARGE_INTEGER TimeOut;
    ULONG Random;

    if (AVrfpRaceDelayInitialSeed == 0) {

        NtQueryPerformanceCounter (&PerformanceCounter, NULL);
        AVrfpRaceDelayInitialSeed = PerformanceCounter.LowPart;
        AVrfpRaceDelaySeed = AVrfpRaceDelayInitialSeed;
    }

    Random = RtlRandom (&AVrfpRaceDelaySeed) % 100;

    if (Random <= AVrfpRaceProbability) {
        
        //
        // A null timeout means the thread will just release
        // the rest of the time slice it has on this processor.
        //

        TimeOut.QuadPart = (LONGLONG)0;

        NtDelayExecution (FALSE, &TimeOut);

        BUMP_COUNTER (CNT_RACE_DELAYS_INJECTED);
    }
    else {

        BUMP_COUNTER (CNT_RACE_DELAYS_SKIPPED);
    }
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// First chance AV logic
/////////////////////////////////////////////////////////////////////


VOID
AVrfpCheckFirstChanceException (
    struct _EXCEPTION_POINTERS * ExceptionPointers
    )
{
    DWORD ExceptionCode;

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_FIRST_CHANCE_EXCEPTION_CHECKS) == 0) {
        return;
    }

    ExceptionCode = ExceptionPointers->ExceptionRecord->ExceptionCode;

    if (ExceptionCode == STATUS_ACCESS_VIOLATION) {

        if (NtCurrentPeb()->BeingDebugged) {

            if (ExceptionPointers->ExceptionRecord->NumberParameters > 1) {

                if (ExceptionPointers->ExceptionRecord->ExceptionInformation[1] > 0x10000) {

                    VERIFIER_STOP (APPLICATION_VERIFIER_ACCESS_VIOLATION | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                   "first chance access violation for current stack trace",
                                   ExceptionPointers->ExceptionRecord->ExceptionInformation[1],
                                   "Invalid address being accessed",
                                   ExceptionPointers->ExceptionRecord->ExceptionAddress,
                                   "Code performing invalid access",
                                   ExceptionPointers->ExceptionRecord, 
                                   "Exception record. Use .exr to display it.", 
                                   ExceptionPointers->ContextRecord, 
                                   "Context record. Use .cxr to display it.");
                }
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////// Free memory checks
/////////////////////////////////////////////////////////////////////

#define AVRF_FREE_MEMORY_CALLBACKS 16

#define FREE_CALLBACK_OK_TO_CALL  0
#define FREE_CALLBACK_ACTIVE      1
#define FREE_CALLBACK_DELETING    2

LONG AVrfpFreeCallbackState;
LONG AVrfpFreeCallbackCallers;

PVOID AVrfpFreeMemoryCallbacks[AVRF_FREE_MEMORY_CALLBACKS];


NTSTATUS
AVrfpAddFreeMemoryCallback (
    VERIFIER_FREE_MEMORY_CALLBACK Callback
    )
{
    ULONG Index;
    PVOID Value;

    for (Index = 0; Index < AVRF_FREE_MEMORY_CALLBACKS; Index += 1) {
        
        Value = InterlockedCompareExchangePointer (&(AVrfpFreeMemoryCallbacks[Index]),
                                                   Callback,
                                                   NULL);
        if (Value == NULL) {
            return STATUS_SUCCESS;
        }
    }

    DbgPrint ("AVRF: failed to add free memory callback @ %p \n", Callback);
    DbgBreakPoint ();

    return STATUS_NO_MEMORY;
}


NTSTATUS
AVrfpDeleteFreeMemoryCallback (
    VERIFIER_FREE_MEMORY_CALLBACK Callback
    )
{
    ULONG Index;
    PVOID Value;
    LONG State;

    //
    // Spin until we can delete a callback. If some region got freed and some 
    // callbacks are running we will wait until they finish. 
    //

    do {
        State = InterlockedCompareExchange (&AVrfpFreeCallbackState,
                                            FREE_CALLBACK_DELETING,
                                            FREE_CALLBACK_OK_TO_CALL);
    
    } while (State != FREE_CALLBACK_OK_TO_CALL);

    for (Index = 0; Index < AVRF_FREE_MEMORY_CALLBACKS; Index += 1) {
        
        Value = InterlockedCompareExchangePointer (&(AVrfpFreeMemoryCallbacks[Index]),
                                                   NULL,
                                                   Callback);
        if (Value == Callback) {

            InterlockedExchange (&AVrfpFreeCallbackState,
                                 FREE_CALLBACK_OK_TO_CALL);

            return STATUS_SUCCESS;
        }
    }

    DbgPrint ("AVRF: attempt to delete invalid free memory callback @ %p \n", Callback);
    DbgBreakPoint ();

    InterlockedExchange (&AVrfpFreeCallbackState,
                         FREE_CALLBACK_OK_TO_CALL);

    return STATUS_UNSUCCESSFUL;
}


VOID 
AVrfpCallFreeMemoryCallbacks (
    PVOID StartAddress,
    SIZE_T RegionSize,
    PWSTR UnloadedDllName
    )
{
    ULONG Index;
    PVOID Value;
    LONG State;
    LONG Callers;

    //
    // If some thread is deleting a callback then we will not call any
    // callback. Since this is a rare event (callbacks do not get
    // deleted often) we will not lose bugs (maybe a few weird ones).
    //
    // If zero or more threads execute callbacks it is ok to call them also
    // from this thread. 
    //

    //
    // Callers++ will prevent the State to go from Active to OkToCall. 
    // Therefore we block any deletes.
    //

    InterlockedIncrement (&AVrfpFreeCallbackCallers);

    State = InterlockedCompareExchange (&AVrfpFreeCallbackState,
                                        FREE_CALLBACK_ACTIVE,
                                        FREE_CALLBACK_OK_TO_CALL);

    if (State != FREE_CALLBACK_DELETING) {

        for (Index = 0; Index < AVRF_FREE_MEMORY_CALLBACKS; Index += 1) {

            Value = InterlockedCompareExchangePointer (&(AVrfpFreeMemoryCallbacks[Index]),
                                                       NULL,
                                                       NULL);
            if (Value != NULL) {

                ((VERIFIER_FREE_MEMORY_CALLBACK)Value) (StartAddress,
                                                        RegionSize,
                                                        UnloadedDllName);
            }
        }

        //
        // Exit protocol. If callers == 1 then this thread needs to change from Active
        // to OkToCall. This way we give green light for possible deletes.
        // 

        Callers = InterlockedCompareExchange (&AVrfpFreeCallbackCallers,
                                              0,
                                              1);

        if (Callers == 1) {

            InterlockedExchange (&AVrfpFreeCallbackState,
                                 FREE_CALLBACK_OK_TO_CALL);
        }
        else {

            InterlockedDecrement (&AVrfpFreeCallbackCallers);
        }
    }
    else {

        //
        // Some other thread deletes callbacks. 
        // We will skip them this time.
        //

        InterlockedDecrement (&AVrfpFreeCallbackCallers);
    }
}


BOOL
AVrfpFreeMemSanityChecks (
    VERIFIER_DLL_FREEMEM_TYPE FreeMemType,
    PVOID StartAddress,
    SIZE_T RegionSize,
    PWSTR UnloadedDllName
    )
{
    BOOL Success = TRUE;

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) == 0) {

        goto Done;
    }

    //
    // Break for invalid StartAddress/RegionSize combinations.
    //

    if ((AVrfpSysBasicInfo.MaximumUserModeAddress <= (ULONG_PTR)StartAddress) ||
        ((AVrfpSysBasicInfo.MaximumUserModeAddress - (ULONG_PTR)StartAddress) < RegionSize)) {

        Success = FALSE;

        switch (FreeMemType) {

        case VerifierFreeMemTypeFreeHeap:

            //
            // Nothing. Let page heap handle the bogus block.
            //

            break;

        case VerifierFreeMemTypeVirtualFree:
        case VerifierFreeMemTypeUnmap:

            //
            // Our caller is AVrfpFreeVirtualMemNotify and that should have
            // signaled this error already.
            //

            break;

        case VerifierFreeMemTypeUnloadDll:

            ASSERT (UnloadedDllName != NULL);

            VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_FREEMEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                           "Unloading DLL with invalid size or start address",
                           StartAddress, "Allocation base address",
                           RegionSize, "Memory region size",
                           UnloadedDllName, "DLL name address. Use du to dump it.",
                           NULL, "" );
            break;

        default:

            ASSERT (FALSE );
            break;
        }
    }
    else {

        //
        // Verify that we are not trying to free a portion of the current thread's stack (!)
        //

        if (((StartAddress >= NtCurrentTeb()->DeallocationStack) && (StartAddress < NtCurrentTeb()->NtTib.StackBase)) ||
            ((StartAddress < NtCurrentTeb()->DeallocationStack) && ((PCHAR)StartAddress + RegionSize > (PCHAR)NtCurrentTeb()->DeallocationStack)))
        {
            Success = FALSE;

            switch (FreeMemType) {

            case VerifierFreeMemTypeFreeHeap:

                VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_FREEMEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "Freeing heap memory block inside current thread's stack address range",
                               StartAddress, "Allocation base address",
                               RegionSize, "Memory region size",
                               NtCurrentTeb()->DeallocationStack, "Stack low limit address",
                               NtCurrentTeb()->NtTib.StackBase, "Stack high limit address" );
                break;

            case VerifierFreeMemTypeVirtualFree:
                
                VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_FREEMEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "Freeing memory block inside current thread's stack address range",
                               StartAddress, "Allocation base address",
                               RegionSize, "Memory region size",
                               NtCurrentTeb()->DeallocationStack, "Stack low limit address",
                               NtCurrentTeb()->NtTib.StackBase, "Stack high limit address" );
                break;

            case VerifierFreeMemTypeUnloadDll:

                ASSERT (UnloadedDllName != NULL);

                VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_FREEMEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "Unloading DLL inside current thread's stack address range",
                               StartAddress, "Allocation base address",
                               RegionSize, "Memory region size",
                               UnloadedDllName, "DLL name address. Use du to dump it.",
                               NtCurrentTeb()->DeallocationStack, "Stack low limit address");
                break;

            case VerifierFreeMemTypeUnmap:
                
                VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_FREEMEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "Unmapping memory region inside current thread's stack address range",
                               StartAddress, "Allocation base address",
                               RegionSize, "Memory region size",
                               NtCurrentTeb()->DeallocationStack, "Stack low limit address",
                               NtCurrentTeb()->NtTib.StackBase, "Stack high limit address" );

                break;

            default:

                ASSERT (FALSE );
                break;
            }
        }
    }

Done:

    return Success;
}


VOID 
AVrfpFreeMemNotify (
    VERIFIER_DLL_FREEMEM_TYPE FreeMemType,
    PVOID StartAddress,
    SIZE_T RegionSize,
    PWSTR UnloadedDllName
    )
{
    BOOL Success;

    //
    // Simple checks for allocation start address and size.
    //

    Success = AVrfpFreeMemSanityChecks (FreeMemType,
                                        StartAddress,
                                        RegionSize,
                                        UnloadedDllName);
    if (Success != FALSE) {

        //
        // Verify if there are any active critical section
        // in the memory we are freeing.
        //
        
        AVrfpFreeMemLockChecks (FreeMemType,
                                StartAddress,
                                RegionSize,
                                UnloadedDllName);
    }

    //
    // Call free memory callbacks.
    //

    AVrfpCallFreeMemoryCallbacks (StartAddress,
                                  RegionSize,
                                  UnloadedDllName);
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////// Verifier private heap APIs
/////////////////////////////////////////////////////////////////////

PVOID AVrfpHeap;

PVOID
AVrfpAllocate (
    SIZE_T Size
    )
{
    ASSERT (AVrfpHeap != NULL);
    ASSERT (Size > 0);

    return RtlAllocateHeap (AVrfpHeap,
                              HEAP_ZERO_MEMORY,
                              Size);
}


VOID
AVrfpFree (
    PVOID Address
    )
{
    ASSERT (AVrfpHeap != NULL);
    ASSERT (Address != NULL);
    
    RtlFreeHeap (AVrfpHeap,
                 0,
                 Address);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Call trackers
/////////////////////////////////////////////////////////////////////

PAVRF_TRACKER AVrfThreadTracker;
PAVRF_TRACKER AVrfHeapTracker;
PAVRF_TRACKER AVrfVspaceTracker;

NTSTATUS
AVrfCreateTrackers (
    VOID
    )
{
    if ((AVrfThreadTracker = AVrfCreateTracker (16)) == NULL) {
        goto CLEANUP_AND_FAIL;
    }

    if ((AVrfHeapTracker = AVrfCreateTracker (8192)) == NULL) {
        goto CLEANUP_AND_FAIL;
    }

    if ((AVrfVspaceTracker = AVrfCreateTracker (8192)) == NULL) {
        goto CLEANUP_AND_FAIL;
    }

    return STATUS_SUCCESS;

CLEANUP_AND_FAIL:

    AVrfDestroyTracker (AVrfThreadTracker);
    AVrfDestroyTracker (AVrfHeapTracker);
    AVrfDestroyTracker (AVrfVspaceTracker);

    return STATUS_NO_MEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\support.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

    support.h

Abstract:

    Internal support interfaces for the standard 
    application verifier provider.

Author:

    Silviu Calinoiu (SilviuC) 1-Mar-2001

Revision History:

--*/

#ifndef _SUPPORT_H_
#define _SUPPORT_H_

#include "public.h"

//
// Internal verifier debug flags.
//

#define VRFP_DEBUG_GENERIC                  0x00000100
#define VRFP_DEBUG_LOCKS_VERIFIER           0x00000200
#define VRFP_DEBUG_LOCKS_DUMP_TREE          0x00000400
#define VRFP_DEBUG_LOCKS_INITIALIZE_DELETE  0x00000800
#define VRFP_DEBUG_DIRTY_STACKS             0x00001000
#define VRFP_DEBUG_EXCEPTIONS               0x00002000
#define VRFP_DEBUG_LOADLIBRARY_CALLS        0x00004000
#define VRFP_DEBUG_LOADLIBRARY_THUNKED      0x00008000
#define VRFP_DEBUG_DLLMAIN_HOOKING          0x00010000
#define VRFP_DEBUG_DLLMAIN_CALL             0x00020000
#define VRFP_DEBUG_SHOW_VSPACE_OPERATIONS   0x00040000
#define VRFP_DEBUG_SHOW_VSPACE_TRACKING     0x00080000

//
// Global data.
//

extern SYSTEM_BASIC_INFORMATION AVrfpSysBasicInfo;

//
// Useful macro
//

#define ROUND_UP(VALUE,ROUND) ((SIZE_T)(((SIZE_T)VALUE + \
                               ((SIZE_T)ROUND - 1L)) & (~((SIZE_T)ROUND - 1L))))

//
// Exception logging support.
//

VOID
AVrfpInitializeExceptionChecking (
    VOID
    );

VOID
AVrfpCleanupExceptionChecking (
    VOID
    );

//
// Write garbage in unused areas of stack.
//

VOID
AVrfpDirtyThreadStack (
    );

VOID
AVrfpDllLoadCallback (
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved
    );

VOID
AVrfpDllUnloadCallback( 
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved
    );

VOID
AVrfpNtdllHeapFreeCallback (
    PVOID AllocationBase,
    SIZE_T AllocationSize
    );

NTSTATUS
AVrfpDllInitialize (
    VOID
    );

/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// Per thread table
/////////////////////////////////////////////////////////////////////

NTSTATUS
AVrfpThreadTableInitialize (
    VOID
    );

VOID
AVrfpThreadTableAddEntry (
    PAVRF_THREAD_ENTRY Entry
    );

VOID
AVrfpThreadTableRemoveEntry (
    PAVRF_THREAD_ENTRY Entry
    );

PAVRF_THREAD_ENTRY
AVrfpThreadTableSearchEntry (
    HANDLE Id
    );

/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Global counters
/////////////////////////////////////////////////////////////////////

#define BUMP_COUNTER(cnt) InterlockedIncrement((PLONG)(&(AVrfpCounter[(cnt)])))

#define CNT_WAIT_SINGLE_CALLS                 0
#define CNT_WAIT_SINGLEEX_CALLS               1
#define CNT_WAIT_MULTIPLE_CALLS               2
#define CNT_WAIT_MULTIPLEEX_CALLS             3
#define CNT_WAIT_WITH_TIMEOUT_CALLS           4
#define CNT_WAIT_WITH_TIMEOUT_FAILS           5
#define CNT_CREATE_EVENT_CALLS                6
#define CNT_CREATE_EVENT_FAILS                7
#define CNT_HEAP_ALLOC_CALLS                  8
#define CNT_HEAP_ALLOC_FAILS                  9
#define CNT_CLOSE_NULL_HANDLE_CALLS           10
#define CNT_CLOSE_PSEUDO_HANDLE_CALLS         11
#define CNT_HEAPS_CREATED                     12
#define CNT_HEAPS_DESTROYED                   13
#define CNT_VIRTUAL_ALLOC_CALLS               14
#define CNT_VIRTUAL_ALLOC_FAILS               15
#define CNT_MAP_VIEW_CALLS                    16
#define CNT_MAP_VIEW_FAILS                    17
#define CNT_OLE_ALLOC_CALLS                   18
#define CNT_OLE_ALLOC_FAILS                   19
#define CNT_RACE_DELAYS_INJECTED              20
#define CNT_RACE_DELAYS_SKIPPED               21

#define CNT_MAXIMUM_INDEX                     64

extern ULONG AVrfpCounter[CNT_MAXIMUM_INDEX];

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// Break triggers
/////////////////////////////////////////////////////////////////////

#define BRK_CLOSE_NULL_HANDLE                  0
#define BRK_CLOSE_PSEUDO_HANDLE                1
#define BRK_CREATE_EVENT_FAIL                  2
#define BRK_HEAP_ALLOC_FAIL                    3
#define BRK_WAIT_WITH_TIMEOUT_FAIL             4
#define BRK_VIRTUAL_ALLOC_FAIL                 5
#define BRK_MAP_VIEW_FAIL                      6
#define BRK_CREATE_FILE_FAIL                   7
#define BRK_CREATE_KEY_FAIL                    8
#define BRK_OLE_ALLOC_FAIL                     9

#define BRK_MAXIMUM_INDEX                      64

extern ULONG AVrfpBreak [BRK_MAXIMUM_INDEX];

#define CHECK_BREAK(indx)                        \
        if (AVrfpBreak[(indx)] != 0) {           \
            DbgPrint ("AVRF: conditional breakpoint %X hit.\n", (indx)); \
            DbgBreakPoint ();                    \
        }

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Verifier TLS slot
/////////////////////////////////////////////////////////////////////

typedef struct _AVRF_TLS_STRUCT {

    LONG CountOfOwnedCriticalSections;
    ULONG Flags;
    LIST_ENTRY ListEntry;
    HANDLE ThreadId;
    PVOID Teb;
    PRTL_CRITICAL_SECTION IgnoredIncorrectDeleteCS;

} AVRF_TLS_STRUCT, *PAVRF_TLS_STRUCT;

//
// Possible values for TlsStruct->Flags.
//

#define VRFP_THREAD_FLAGS_LOADER_LOCK_OWNER 0x1


NTSTATUS
AVrfpAllocateVerifierTlsSlot (
    VOID
    );

PAVRF_TLS_STRUCT
AVrfpGetVerifierTlsValue(
    VOID
    );

VOID
AVrfpSetVerifierTlsValue(
    PAVRF_TLS_STRUCT Value
    );

VOID
AvrfpThreadAttach (
    VOID
    );

VOID
AvrfpThreadDetach (
    VOID
    );

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// DllMain checks 
/////////////////////////////////////////////////////////////////////

extern UNICODE_STRING AVrfpThreadObjectName;

VOID
AVrfpVerifyLegalWait (
    CONST HANDLE *Handles,
    DWORD Count,
    BOOL WaitAll
    );

/////////////////////////////////////////////////////////////////////
//////////////////////////// Signatures for private ntdll entrypoints
/////////////////////////////////////////////////////////////////////

typedef PVOID (NTAPI * PFN_RTLP_DEBUG_PAGE_HEAP_CREATE) (
    IN ULONG Flags,
    IN PVOID HeapBase OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize OPTIONAL,
    IN PVOID Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    );

typedef PVOID (NTAPI * PFN_RTLP_DEBUG_PAGE_HEAP_DESTROY) (
    IN PVOID HeapHandle
    );

extern PFN_RTLP_DEBUG_PAGE_HEAP_CREATE AVrfpRtlpDebugPageHeapCreate;
extern PFN_RTLP_DEBUG_PAGE_HEAP_DESTROY AVrfpRtlpDebugPageHeapDestroy;

typedef PVOID (* PFN_RTLP_GET_STACK_TRACE_ADDRESS) (
    USHORT Index
    );

extern PFN_RTLP_GET_STACK_TRACE_ADDRESS AVrfpGetStackTraceAddress;

/////////////////////////////////////////////////////////////////////
///////////////////////////////////// Random delays for race verifier
/////////////////////////////////////////////////////////////////////

VOID
AVrfpCreateRandomDelay (
    VOID
    );

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////// Free memory checks
/////////////////////////////////////////////////////////////////////

typedef enum {

    VerifierFreeMemTypeFreeHeap,
    VerifierFreeMemTypeVirtualFree,
    VerifierFreeMemTypeUnloadDll,
    VerifierFreeMemTypeUnmap

} VERIFIER_DLL_FREEMEM_TYPE;

VOID 
AVrfpFreeMemNotify (
    VERIFIER_DLL_FREEMEM_TYPE FreeMemType,
    PVOID StartAddress,
    SIZE_T RegionSize,
    PWSTR UnloadedDllName
    );

NTSTATUS
AVrfpAddFreeMemoryCallback (
    VERIFIER_FREE_MEMORY_CALLBACK Callback
    );

NTSTATUS
AVrfpDeleteFreeMemoryCallback (
    VERIFIER_FREE_MEMORY_CALLBACK Callback
    );

VOID 
AVrfpCallFreeMemoryCallbacks (
    PVOID StartAddress,
    SIZE_T RegionSize,
    PWSTR UnloadedDllName
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////// Private verifier heap allocations
/////////////////////////////////////////////////////////////////////

extern PVOID AVrfpHeap;

PVOID
AVrfpAllocate (
    SIZE_T Size
    );

VOID
AVrfpFree (
    PVOID Address
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Call trackers
/////////////////////////////////////////////////////////////////////

extern PAVRF_TRACKER AVrfThreadTracker;
extern PAVRF_TRACKER AVrfHeapTracker;
extern PAVRF_TRACKER AVrfVspaceTracker;

NTSTATUS
AVrfCreateTrackers (
    VOID
    );


#endif // _SUPPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\settings.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    settings.c

Abstract:

    This module implements interfaces for enabling application
    verifier flags persistently (registry).

Author:

    Silviu Calinoiu (SilviuC) 17-Apr-2001

Revision History:

--*/

//
// IMPORTANT NOTE.
//
// This dll cannot contain non-ntdll dependencies. This way it allows
// verifier to be run system wide including for processes like smss and csrss.
//
// This explains why we load dynamically advapi32 dll and pick up the functions
// for registry manipulation. It is safe to do that for interfaces that set
// flags because they are called only in contexts where it is safe to load 
// additional dlls.
//

#include "pch.h"

#include "verifier.h"
#include "settings.h"
#include "support.h"

//
// Handy functions exported by ntdll.dll
//                       
int __cdecl sscanf(const char *, const char *, ...);
int __cdecl swprintf(wchar_t *, const wchar_t *, ...);

//
// Signatures for registry functions
//

typedef LONG (APIENTRY * PFN_REG_CREATE_KEY) (HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
typedef LONG (APIENTRY * PFN_REG_CLOSE_KEY)(HKEY);
typedef LONG (APIENTRY * PFN_REG_QUERY_VALUE) (HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef LONG (APIENTRY * PFN_REG_SET_VALUE) (HKEY, LPCWSTR, DWORD, DWORD, CONST BYTE *, DWORD);
typedef LONG (APIENTRY * PFN_REG_DELETE_VALUE) (HKEY, LPCWSTR);

//
// Dynamically detected registry functions
//

PFN_REG_CREATE_KEY FnRegCreateKey;
PFN_REG_CLOSE_KEY FnRegCloseKey;
PFN_REG_QUERY_VALUE FnRegQueryValue;
PFN_REG_SET_VALUE FnRegSetValue;
PFN_REG_DELETE_VALUE FnRegDeleteValue;

//
// Registry path to `image file execution options' key
//

#define EXECUTION_OPTIONS_KEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\"

//
// Internal functions
//

NTSTATUS
AVrfpGetRegistryInterfaces (
    PVOID DllHandle
    );

HKEY
AVrfpOpenImageKey (
    PWSTR Name
    );

VOID
AVrfpCloseImageKey (
    HKEY Key
    );

BOOL
AVrfpReadGlobalFlags (
    HKEY Key,
    PDWORD Value
    );

BOOL
AVrfpWriteGlobalFlags (
    HKEY Key,
    DWORD Value
    );

BOOL
AVrfpDeleteGlobalFlags (
    HKEY Key
    );

BOOL
AVrfpReadVerifierFlags (
    HKEY Key,
    PDWORD Value
    );

BOOL
AVrfpWriteVerifierFlags (
    HKEY Key,
    DWORD Value
    );

BOOL
AVrfpDeleteVerifierFlags (
    HKEY Key
    );


NTSTATUS
VerifierSetFlags (
    PUNICODE_STRING ApplicationName,
    ULONG VerifierFlags,
    PVOID Details
    )
/*++

Routine Description:

    This routine enables persistently (through registry) application
    verifier flags for a specified application.

Arguments:

    ApplicationName - name of the application to  be verifier. The path should
        not be included. The extension should be included. Some examples of
        correct names are: `services.exe', `logon.scr'. Incorrect examples are:
        `c:\winnt\system32\notepad.exe' or just `notepad'. If we persist a setting
        for `xxx.exe' then every time a process whose binary is xxx.exe is launched
        application verifier will kick in no matter in what user context or from what
        disk location this happens.
        
    VerifierFlags - bit field with verifier flags to be enabled. The legal bits are
        declared in sdk\inc\nturtl.h (and winnt.h) as constants names RTL_VRF_FLG_XXX.
        For example RTL_VRF_FLG_FULL_PAGE_HEAP. If a zero value is used then all
        registry values related to verifier will b e deleted from registry.
        
    Details - Ignored right now. In the future this structure will support various
        extensions of the API (e.g. page heap flags, per dll page heap settings, etc.).            

Return Value:

    STATUS_SUCCESS if all flags requested have been enabled. It can return
    STATUS_NOT_IMPLEMENTED if one of the flags requested is not yet implemented
    or we decided to block it internally due to a bug. It can also return
    STATUS_INVALID_PARAMETER if the application name or other parameters
    are ill-formed.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING AdvapiName;
    PVOID AdvapiHandle;
    HKEY Key;
    DWORD Flags;

    UNREFERENCED_PARAMETER (Details);

    if (ApplicationName == NULL || ApplicationName->Buffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }
    
    //
    // Load advapi32.dll and get registry manipulation functions.
    //

    RtlInitUnicodeString (&AdvapiName, L"advapi32.dll");
    Status = LdrLoadDll (NULL, NULL, &AdvapiName, &AdvapiHandle);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = AVrfpGetRegistryInterfaces (AdvapiHandle);

    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // Open `image file execution options\xxx.exe' key. If the key does not
    // exist it will be created.
    //

    Key = AVrfpOpenImageKey (ApplicationName->Buffer);

    if (Key == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Create verifier settings.
    //

    if (VerifierFlags == 0) {
        
        Flags = 0;
        AVrfpReadGlobalFlags (Key, &Flags);
        Flags &= ~FLG_APPLICATION_VERIFIER;

        if (Flags == 0) {
            AVrfpDeleteGlobalFlags (Key);
        }
        else {
            AVrfpWriteGlobalFlags (Key, Flags);
        }
        
        AVrfpDeleteVerifierFlags (Key);
    }
    else {
        
        Flags = 0;
        AVrfpReadGlobalFlags (Key, &Flags);
        Flags |= FLG_APPLICATION_VERIFIER;
        AVrfpWriteGlobalFlags (Key, Flags);

        Flags = VerifierFlags;
        AVrfpWriteVerifierFlags (Key, Flags);
    }

    //
    // Cleanup and return.
    //

    AVrfpCloseImageKey (Key);

    Exit:

    LdrUnloadDll (AdvapiHandle);

    return Status;
}

NTSTATUS
AVrfpGetRegistryInterfaces (
    PVOID AdvapiHandle
    )
{
    NTSTATUS Status;
    ANSI_STRING FunctionName;
    PVOID FunctionAddress;

    RtlInitAnsiString (&FunctionName, "RegCreateKeyExW");
    Status = LdrGetProcedureAddress (AdvapiHandle, &FunctionName, 0, &FunctionAddress);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    FnRegCreateKey = (PFN_REG_CREATE_KEY)FunctionAddress;

    RtlInitAnsiString (&FunctionName, "RegCloseKey");
    Status = LdrGetProcedureAddress (AdvapiHandle, &FunctionName, 0, &FunctionAddress);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    FnRegCloseKey = (PFN_REG_CLOSE_KEY)FunctionAddress;

    RtlInitAnsiString (&FunctionName, "RegQueryValueExW");
    Status = LdrGetProcedureAddress (AdvapiHandle, &FunctionName, 0, &FunctionAddress);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    FnRegQueryValue = (PFN_REG_QUERY_VALUE)FunctionAddress;

    RtlInitAnsiString (&FunctionName, "RegSetValueExW");
    Status = LdrGetProcedureAddress (AdvapiHandle, &FunctionName, 0, &FunctionAddress);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    FnRegSetValue = (PFN_REG_SET_VALUE)FunctionAddress;
    
    RtlInitAnsiString (&FunctionName, "RegDeleteValueW");
    Status = LdrGetProcedureAddress (AdvapiHandle, &FunctionName, 0, &FunctionAddress);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    FnRegDeleteValue = (PFN_REG_DELETE_VALUE)FunctionAddress;

    return Status;
}

HKEY
AVrfpOpenImageKey (
    PWSTR Name
    )
{
    HKEY Key;
    LONG Result;
    WCHAR Buffer [MAX_PATH];

    wcscpy (Buffer, EXECUTION_OPTIONS_KEY);
    
    wcsncat (Buffer, 
             Name, 
             (sizeof (Buffer) / sizeof (Buffer[0])) - wcslen(Buffer) - 1);

    Buffer[(sizeof (Buffer) / sizeof (Buffer[0])) - 1] = 0;
        
    Result = FnRegCreateKey (HKEY_LOCAL_MACHINE,
                          Buffer,
                          0,
                          0,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &Key,
                          NULL);

    if (Result != ERROR_SUCCESS) {
        return NULL;
    }
    else {
        return Key;
    }
}

VOID
AVrfpCloseImageKey (
    HKEY Key
    )
{
    FnRegCloseKey (Key);
}

BOOL
AVrfpReadGlobalFlags (
    HKEY Key,
    PDWORD Value
    )
{
    LONG Result;
    DWORD Type;
    BYTE Buffer[32];
    BYTE Buffer2[32];
    DWORD BytesRead;
    DWORD FlagValue;
    DWORD I;
     
    BytesRead = sizeof Buffer;

    Result = FnRegQueryValue (Key,
                           L"GlobalFlag",
                           0,
                           &Type,
                           (LPBYTE)Buffer,
                           &BytesRead);

    if (Result != ERROR_SUCCESS || Type != REG_SZ) {
        
        DbgPrint ("AVRF: settings: result %u \n", 
                  Result);
        
        return FALSE;
    }
    else {
        
        for (I = 0; Buffer[2 * I] != L'\0'; I += 1) {
            Buffer2[I] = Buffer[2 * I];
        }

        Buffer2[I] = 0;
        FlagValue = 0;

        if( sscanf ((const char *)Buffer2, "%x", &FlagValue) == 1 && Value != NULL ) {

            *Value = FlagValue;
        }

        return TRUE;
    }
}

BOOL
AVrfpWriteGlobalFlags (
    HKEY Key,
    DWORD Value
    )
{
    LONG Result;
    WCHAR Buffer[16];
    DWORD Length;

    swprintf (Buffer, L"0x%08X", Value);
    Length = (DWORD)((wcslen(Buffer) + 1) * sizeof (WCHAR));

    Result = FnRegSetValue (Key,
                         L"GlobalFlag",
                         0,
                         REG_SZ,
                         (LPBYTE)Buffer,
                         Length);

    return (Result == ERROR_SUCCESS);
}

BOOL
AVrfpDeleteGlobalFlags (
    HKEY Key
    )
{
    LONG Result;

    Result = FnRegDeleteValue (Key, L"GlobalFlag");
    return (Result == ERROR_SUCCESS);
}

BOOL
AVrfpReadVerifierFlags (
    HKEY Key,
    PDWORD Value
    )
{
    LONG Result;
    DWORD Type;
    DWORD BytesRead;

    BytesRead = sizeof *Value;

    Result = FnRegQueryValue (Key,
                           L"VerifierValue",
                           0,
                           &Type,
                           (LPBYTE)Value,
                           &BytesRead);

    return (Result == ERROR_SUCCESS && Type != REG_DWORD);
}

BOOL
AVrfpWriteVerifierFlags (
    HKEY Key,
    DWORD Value
    )
{
    LONG Result;

    Result = FnRegSetValue (Key,
                         L"VerifierFlags",
                         0,
                         REG_DWORD,
                         (LPBYTE)(&Value),
                         sizeof Value);

    return (Result == ERROR_SUCCESS);
}

BOOL
AVrfpDeleteVerifierFlags (
    HKEY Key
    )
{
    LONG Result;

    Result = FnRegDeleteValue (Key, L"VerifierFlags");
    return (Result == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\tracker.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

    tracker.h

Abstract:

    Verifier call history tracker.

Author:

    Silviu Calinoiu (SilviuC) Jul-11-2002

Revision History:

--*/

#ifndef _TRACKER_H_
#define _TRACKER_H_

//
// This codes are used also by the !avrf debugger extension.
//
                                         
#define TRACK_HEAP_ALLOCATE             1
#define TRACK_HEAP_REALLOCATE           2
#define TRACK_HEAP_FREE                 3
#define TRACK_VIRTUAL_ALLOCATE          4
#define TRACK_VIRTUAL_FREE              5
#define TRACK_VIRTUAL_PROTECT           6
#define TRACK_MAP_VIEW_OF_SECTION       7
#define TRACK_UNMAP_VIEW_OF_SECTION     8
#define TRACK_EXIT_PROCESS              9
#define TRACK_TERMINATE_THREAD          10
#define TRACK_SUSPEND_THREAD            11
          
typedef struct _AVRF_TRACKER_ENTRY {

    USHORT Type;
    USHORT TraceDepth;
    PVOID Info[4];
    PVOID Trace [MAX_TRACE_DEPTH];

} AVRF_TRACKER_ENTRY, *PAVRF_TRACKER_ENTRY;
                     

typedef struct _AVRF_TRACKER {

    ULONG Size;
    ULONG Index;

    AVRF_TRACKER_ENTRY Entry[1];

} AVRF_TRACKER, *PAVRF_TRACKER;
                     
                     
PAVRF_TRACKER 
AVrfCreateTracker (
    ULONG Size
    );

VOID
AVrfDestroyTracker (
    PAVRF_TRACKER Tracker
    );

VOID
AVrfLogInTracker (
    PAVRF_TRACKER Tracker,
    USHORT EntryType,
    PVOID EntryParam1,
    PVOID EntryParam2,
    PVOID EntryParam3,
    PVOID EntryParam4,
    PVOID ReturnAddress
    );

#endif // _TRACKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\thread.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    thread.c

Abstract:

    This module implements verification functions for thread interfaces.

Author:

    Silviu Calinoiu (SilviuC) 22-Feb-2001

Revision History:

    Daniel Mihai (DMihai) 25-Apr-2002

        Hook thread pool and WMI threads.
--*/

#include "pch.h"

#include "verifier.h"
#include "support.h"
#include "logging.h"
#include "tracker.h"

//
// Why do we hook Exit/TerminateThread instead of NtTerminateThread?
//
// Because kernel32 calls NtTerminateThread in legitimate contexts.
// After all this is the implementation for Exit/TerminateThread.
// It would be difficult to discriminate good calls from bad calls.
// So we prefer to intercept Exit/Thread and returns from thread
// functions.
//

//
// Standard function used for hooking a thread function.
//

DWORD
WINAPI
AVrfpStandardThreadFunction (
    LPVOID Info
    );

//
// Common point to check for thread termination.
//

VOID
AVrfpCheckThreadTermination (
    HANDLE Thread
    );

VOID
AVrfpCheckCurrentThreadTermination (
    VOID
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

//WINBASEAPI
DECLSPEC_NORETURN
VOID
WINAPI
AVrfpExitProcess(
    IN UINT uExitCode
    )
{
    typedef VOID (WINAPI * FUNCTION_TYPE) (UINT);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_EXITPROCESS);

    //
    // Check out if there are other threads running while ExitProcess 
    // gets called. This can cause problems because the threads are 
    // terminated unconditionally and then ExitProcess() calls 
    // LdrShutdownProcess() which will try to notify all DLLs to cleanup.
    // During cleanup any number of operations can happen that will result
    // in deadlocks since all those threads have been terminated 
    // unconditionally
    //
#if 0
    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_DANGEROUS_APIS) != 0) {

        PCHAR InfoBuffer;
        ULONG RequiredLength = 0;
        ULONG NumberOfThreads;
        ULONG EntryOffset;
        PSYSTEM_PROCESS_INFORMATION ProcessInfo;
        NTSTATUS Status;

        Status = NtQuerySystemInformation (SystemProcessInformation,
                                           NULL,
                                           0,
                                           &RequiredLength);

        if (Status == STATUS_INFO_LENGTH_MISMATCH && RequiredLength != 0) {
            
            InfoBuffer = AVrfpAllocate (RequiredLength);

            if (InfoBuffer) {
                
                //
                // Note that the RequiredLength is not 100% guaranteed to be good
                // since in between the two query calls several other processes
                // may have been created. If this is the case we bail out and skip
                // the verification.
                //

                Status = NtQuerySystemInformation (SystemProcessInformation,
                                                   InfoBuffer,
                                                   RequiredLength,
                                                   NULL);

                if (NT_SUCCESS(Status)) {

                    EntryOffset = 0;
                    NumberOfThreads = 0;

                    do {
                        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&InfoBuffer[EntryOffset];
                        
                        if (ProcessInfo->UniqueProcessId == NtCurrentTeb()->ClientId.UniqueProcess) {
                            NumberOfThreads = ProcessInfo->NumberOfThreads;
                            break;
                        }
                        
                        EntryOffset += ProcessInfo->NextEntryOffset;

                    } while(ProcessInfo->NextEntryOffset != 0);

                    ASSERT (NumberOfThreads > 0);

                    if (NumberOfThreads > 1) {

                        VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_EXIT_PROCESS_CALL | APPLICATION_VERIFIER_NO_BREAK,
                                       "ExitProcess() called while multiple threads are running",
                                       NumberOfThreads, "Number of threads running",
                                       0, NULL, 0, NULL, 0, NULL);

                    }
                } 
                else {

                    DbgPrint ("AVRF: NtQuerySystemInformation(SystemProcessInformation) "
                              "failed with %X \n",
                              Status);

                }

                //
                // We are done with the buffer. Time to free it.
                //

                AVrfpFree (InfoBuffer);
            }
        }
        else {

            DbgPrint ("AVRF: NtQuerySystemInformation(SystemProcessInformation, null) "
                      "failed with %X \n",
                      Status);

        }
    }
#endif // #if 0

    //
    // Make a note of who called ExitProcess(). This can be helpful for debugging
    // weird process shutdown hangs.
    //

    AVrfLogInTracker (AVrfThreadTracker, 
                      TRACK_EXIT_PROCESS,
                      (PVOID)(ULONG_PTR)uExitCode, 
                      NULL, NULL, NULL, _ReturnAddress());

    //
    // Call the real thing.
    //

    (* Function)(uExitCode);

}

//WINBASEAPI
DECLSPEC_NORETURN
VOID
WINAPI
AVrfpExitThread(
    IN DWORD dwExitCode
    )
{
    typedef VOID (WINAPI * FUNCTION_TYPE) (DWORD);
    FUNCTION_TYPE Function;
    PAVRF_THREAD_ENTRY Entry;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_EXITTHREAD);

    //
    // Perform all typical checks for a thread that will exit.
    //

    AVrfpCheckCurrentThreadTermination ();

    //
    // Before calling the real ExitThread we need to free the thread
    // entry from the thread table.
    //

    Entry = AVrfpThreadTableSearchEntry (NtCurrentTeb()->ClientId.UniqueThread);

    //
    // N.B. It is possible to not find an entry in the thread table if the
    //      thread was not created using CreateThread but rather some more
    //      basic function from ntdll.dll.
    //

    if (Entry != NULL) {
        
        AVrfpThreadTableRemoveEntry (Entry);
        AVrfpFree (Entry);
    }

    //
    // Call the real thing.
    //

    (* Function)(dwExitCode);
}


//WINBASEAPI
DECLSPEC_NORETURN
VOID
WINAPI
AVrfpFreeLibraryAndExitThread(
    IN HMODULE hLibModule,
    IN DWORD dwExitCode
    )
{
    typedef VOID (WINAPI * FUNCTION_TYPE) (HMODULE, DWORD);
    FUNCTION_TYPE Function;
    PAVRF_THREAD_ENTRY Entry;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_FREELIBRARYANDEXITTHREAD);

    //
    // Perform all typical checks for a thread that will exit.
    //

    AVrfpCheckCurrentThreadTermination ();

    //
    // Before calling the real FreeLibraryAndExitThread we need to free the thread
    // entry from the thread table.
    //

    Entry = AVrfpThreadTableSearchEntry (NtCurrentTeb()->ClientId.UniqueThread);

    //
    // N.B. It is possible to not find an entry in the thread table if the
    //      thread was not created using CreateThread but rather some more
    //      basic function from ntdll.dll.
    //

    if (Entry != NULL) {
        
        AVrfpThreadTableRemoveEntry (Entry);
        AVrfpFree (Entry);
    }

    //
    // Call the real thing.
    //

    (* Function)(hLibModule, dwExitCode);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////// Terminate thread / Suspend thread
/////////////////////////////////////////////////////////////////////

//WINBASEAPI
BOOL
WINAPI
AVrfpTerminateThread(
    IN OUT HANDLE hThread,
    IN DWORD dwExitCode
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (HANDLE, DWORD);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_TERMINATETHREAD);

    //
    // Keep track of who calls TerminateThread() even if we are going to break
    // for it. This helps investigations of deadlocked processes that have run
    // without the dangerous_apis check enabled.
    //

    AVrfLogInTracker (AVrfThreadTracker, 
                      TRACK_TERMINATE_THREAD,
                      hThread, 
                      NULL, NULL, NULL, _ReturnAddress());

    //
    // Perform all typical checks for a thread that will exit.
    //

    AVrfpCheckThreadTermination (hThread);

    //
    // This API should not be called. We need to report this.
    // This is useful if we did not detect any orphans but we still want
    // to complain.
    //

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_DANGEROUS_APIS) != 0) {

        VERIFIER_STOP (APPLICATION_VERIFIER_TERMINATE_THREAD_CALL | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                       "TerminateThread() called. This function should not be used.",
                       NtCurrentTeb()->ClientId.UniqueThread, "Caller thread ID", 
                       0, NULL, 0, NULL, 0, NULL);
    }

    return (* Function)(hThread, dwExitCode);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

//WINBASEAPI
DWORD
WINAPI
AVrfpSuspendThread(
    IN HANDLE hThread
    )
{
    typedef DWORD (WINAPI * FUNCTION_TYPE) (HANDLE);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_SUSPENDTHREAD);

    //
    // Keep track of who calls SuspendThread() even if we are not going to break
    // for it. This helps investigations of deadlocked processes.
    //

    AVrfLogInTracker (AVrfThreadTracker, 
                      TRACK_SUSPEND_THREAD,
                      hThread, 
                      NULL, NULL, NULL, _ReturnAddress());

    //
    // One might think that we can check for orphan locks at this point
    // by calling RtlCheckForOrphanedCriticalSections(hThread).
    // Unfortunately this cannot be done because garbage collectors
    // for various virtual machines (Java, C#) can do this in valid
    // conditions.
    //

    return (* Function)(hThread);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

//WINBASEAPI
HANDLE
WINAPI
AVrfpCreateThread(
    IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
    IN SIZE_T dwStackSize,
    IN LPTHREAD_START_ROUTINE lpStartAddress,
    IN LPVOID lpParameter,
    IN DWORD dwCreationFlags,
    OUT LPDWORD lpThreadId
    )
/*++

CreateThread hook

--*/
{
    typedef HANDLE (WINAPI * FUNCTION_TYPE) (LPSECURITY_ATTRIBUTES,
                                             SIZE_T,
                                             LPTHREAD_START_ROUTINE,
                                             LPVOID,
                                             DWORD,
                                             LPDWORD);
    FUNCTION_TYPE Function;
    HANDLE Result;
    PAVRF_THREAD_ENTRY Info;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_CREATETHREAD);

    Info = AVrfpAllocate (sizeof *Info);

    if (Info == NULL) {
        
        NtCurrentTeb()->LastErrorValue = ERROR_NOT_ENOUGH_MEMORY;
        return NULL;
    }

    Info->Parameter = lpParameter;
    Info->Function = lpStartAddress;
    Info->ParentThreadId = NtCurrentTeb()->ClientId.UniqueThread;
    Info->StackSize = dwStackSize;
    Info->CreationFlags = dwCreationFlags;

    Result = (* Function) (lpThreadAttributes,
                           dwStackSize,
                           AVrfpStandardThreadFunction,
                           (PVOID)Info,
                           dwCreationFlags,
                           lpThreadId);

    if (Result == FALSE) {

        AVrfpFree (Info);
    }

    return Result;
}


ULONG
AVrfpThreadFunctionExceptionFilter (
    ULONG ExceptionCode,
    PVOID ExceptionRecord
    )
{
    //
    // Skip timeout exceptions because they are dealt with in
    // the default exception handler.
    //

    if (ExceptionCode == STATUS_POSSIBLE_DEADLOCK) {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    //
    // Skip breakpoint exceptions raised within thread functions.
    //

    if (ExceptionCode == STATUS_BREAKPOINT) {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    VERIFIER_STOP (APPLICATION_VERIFIER_UNEXPECTED_EXCEPTION | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                   "unexpected exception raised in thread function",
                   ExceptionCode, "Exception code.",
                   ((PEXCEPTION_POINTERS)ExceptionRecord)->ExceptionRecord, "Exception record. Use .exr to display it.",
                   ((PEXCEPTION_POINTERS)ExceptionRecord)->ContextRecord, "Context record. Use .cxr to display it.",
                   0, "");

    //
    // After we issued a verifier stop, if we decide to continue then
    // we need to look for the next exception handler.
    //

    return EXCEPTION_CONTINUE_SEARCH;
}


DWORD
WINAPI
AVrfpStandardThreadFunction (
    LPVOID Context
    )
{
    PAVRF_THREAD_ENTRY Info = (PAVRF_THREAD_ENTRY)Context;
    DWORD Result;
    PAVRF_THREAD_ENTRY SearchEntry;

    //
    // The initialization below matters only in case the thread function raises
    // an access violation. In most cases this will terminate the entire
    // process.
    //

    Result = 0;

    try {
    
        //
        // Add the thread entry to the thread table.
        //

        Info->Id = NtCurrentTeb()->ClientId.UniqueThread;
        AVrfpThreadTableAddEntry (Info);

        //
        // Call the real thing.
        //

        Result = (Info->Function)(Info->Parameter);            
    }
    except (AVrfpThreadFunctionExceptionFilter (_exception_code(), _exception_info())) {

        //
        // Nothing.
        //
    }
    
    //
    // Perform all typical checks for a thread that has just finished.
    //

    AVrfpCheckCurrentThreadTermination ();

    //
    // The thread entry should be `Info' but we will search it in the thread
    // table nevertheless because there is a case when they can be different.
    // This happens if fibers are used and a fiber starts in one thread and
    // exits in another one. It is not clear if this is a safe programming
    // practice but it is not rejected by current implementation and
    // documentation.
    //

    SearchEntry = AVrfpThreadTableSearchEntry (NtCurrentTeb()->ClientId.UniqueThread);

    if (SearchEntry != NULL) {

        AVrfpThreadTableRemoveEntry (SearchEntry);
        AVrfpFree (SearchEntry);
    }
    
    return Result;
}

/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// thread pool thread hook
/////////////////////////////////////////////////////////////////////

PRTLP_START_THREAD AVrfpBaseCreateThreadPoolThreadOriginal;
PRTLP_EXIT_THREAD AVrfpBaseExitThreadPoolThreadOriginal;

NTSTATUS
NTAPI
AVrfpBaseCreateThreadPoolThread(
    PUSER_THREAD_START_ROUTINE Function,
    PVOID Parameter,
    HANDLE * ThreadHandleReturn
    )
{
    PAVRF_THREAD_ENTRY Info;
    PTEB Teb;
    NTSTATUS Status = STATUS_SUCCESS;
    
    Teb = NtCurrentTeb();

    Info = AVrfpAllocate (sizeof *Info);

    if (Info == NULL) {
        
        Status = STATUS_NO_MEMORY;
        goto Done;
    }

    Info->Parameter = Parameter;
    Info->Function = (PTHREAD_START_ROUTINE)Function;
    Info->ParentThreadId = Teb->ClientId.UniqueThread;

    Status = (*AVrfpBaseCreateThreadPoolThreadOriginal) ((PUSER_THREAD_START_ROUTINE)AVrfpStandardThreadFunction,
                                                         Info,
                                                         ThreadHandleReturn);

Done:

    if (!NT_SUCCESS(Status)) {

        if (Info != NULL) {

            AVrfpFree (Info);
        }

        Teb->LastStatusValue = Status;
    }

    return Status;
}

NTSTATUS
NTAPI
AVrfpBaseExitThreadPoolThread(
    NTSTATUS Status
    )
{
    PAVRF_THREAD_ENTRY Entry;

    //
    // Perform all typical checks for a thread that will exit.
    //

    AVrfpCheckCurrentThreadTermination ();

    //
    // Before calling the real ExitThread we need to free the thread
    // entry from the thread table.
    //

    Entry = AVrfpThreadTableSearchEntry (NtCurrentTeb()->ClientId.UniqueThread);

    if (Entry != NULL) {
        
        AVrfpThreadTableRemoveEntry (Entry);
        AVrfpFree (Entry);
    }

    //
    // Call the real thing.
    //

    return (*AVrfpBaseExitThreadPoolThreadOriginal) (Status);
}


NTSTATUS
NTAPI
AVrfpRtlSetThreadPoolStartFunc(
    PRTLP_START_THREAD StartFunc,
    PRTLP_EXIT_THREAD ExitFunc
    )
{
    //
    // Save the original thread pool start and exit functions.
    //

    AVrfpBaseCreateThreadPoolThreadOriginal = StartFunc;
    AVrfpBaseExitThreadPoolThreadOriginal = ExitFunc;

    //
    // Hook the thread pool start and exit functions to our private version.
    //

    return RtlSetThreadPoolStartFunc (AVrfpBaseCreateThreadPoolThread,
                                      AVrfpBaseExitThreadPoolThread);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID
AVrfpCheckThreadTermination (
    HANDLE Thread
    )
{
    //
    // Traverse the list of critical sections and look for any that 
    // have issues (double initialized, corrupted, etc.). The function
    // will also break for locks abandoned (owned by the thread just 
    // about to terminate).
    //

    RtlCheckForOrphanedCriticalSections (Thread);
}

VOID
AVrfpCheckCurrentThreadTermination (
    VOID
    )
{
    PAVRF_TLS_STRUCT TlsStruct;

    TlsStruct = AVrfpGetVerifierTlsValue();

    if (TlsStruct != NULL && TlsStruct->CountOfOwnedCriticalSections > 0) {

        AVrfpCheckThreadTermination (NtCurrentThread());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\tls.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tls.c

Abstract:

    This module implements verification functions for TLS (thread
    local storage) interfaces.

Author:

    Silviu Calinoiu (SilviuC) 3-Jul-2001

Revision History:

    3-Jul-2001 (SilviuC): initial version.

--*/

#include "pch.h"

#include "verifier.h"
#include "support.h"
#include "logging.h"

//
// TLS (thread local storage) checks.
//
// If more than 2**16 indeces are requested the functions will start
// to fail TLS index allocations.
//
// N.B. The MSDN documentation volunteered a limit of 1088 for a TLS
// index. This is an internal implementation detail that should never
// made it to outside world. Because of it some application that
// actually checks for the index to be lower than this will get confused
// by the values coming from verifier because they are guaranteed to be
// bigger than that. 
//

#define TLS_MAXIMUM_INDEX  0xFFFF
#define TLS_MAGIC_PATTERN  0xABBA

//
// The break for invalid TLS indexes can be disabled using this value. 
//

BOOL AVrfpBreakForInvalidTlsValue = TRUE;


DWORD
ScrambleTlsIndex (
    DWORD Index
    )
{
    return (Index << 16) | TLS_MAGIC_PATTERN;
}


DWORD
UnscrambleTlsIndex (
    DWORD Index
    )
{
    return (Index >> 16);
}


BOOL 
CheckTlsIndex (
    DWORD Index
    )
{
    DWORD Tid;
    BOOL TlsIndexValid;

    TlsIndexValid = TRUE;

    if (AVrfpBreakForInvalidTlsValue != FALSE) {

        Tid = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);

        //
        // Check the TLS index value.
        //

        if ((Index & 0xFFFF) != TLS_MAGIC_PATTERN) {

            VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_TLS_VALUE | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                           "Invalid TLS index used in current stack (use kb).",
                           Index, "Invalid TLS index",
                           TLS_MAGIC_PATTERN, "Expected lower part of the index",
                           0,  NULL, 0, NULL);

            TlsIndexValid = FALSE;
        }
    }

    return TlsIndexValid;
}



//WINBASEAPI
DWORD
WINAPI
AVrfpTlsAlloc(
    VOID
    )
{
    typedef DWORD (WINAPI * FUNCTION_TYPE) (VOID);
    FUNCTION_TYPE Function;
    DWORD Index;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_TLSALLOC);

    Index = (*Function)();

    //
    // If we get a TLS index bigger than maximum possible index
    // return failure.
    //

    if (Index > TLS_MAXIMUM_INDEX) {
        return TLS_OUT_OF_INDEXES;
    }

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_TLS_CHECKS) != 0) {

        //
        // Scramble the TLS index and return it.
        //

        Index = ScrambleTlsIndex (Index);
    }

    return Index;
}


//WINBASEAPI
BOOL
WINAPI
AVrfpTlsFree(
    IN DWORD dwTlsIndex
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (DWORD);
    FUNCTION_TYPE Function;
    BOOL Result;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_TLSFREE);

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_TLS_CHECKS) != 0) {

        Result = CheckTlsIndex (dwTlsIndex);

        if (Result == FALSE) {

            return FALSE;
        }

        dwTlsIndex = UnscrambleTlsIndex (dwTlsIndex);
    }

    return (*Function)(dwTlsIndex);
}


//WINBASEAPI
LPVOID
WINAPI
AVrfpTlsGetValue(
    IN DWORD dwTlsIndex
    )
{
    typedef LPVOID (WINAPI * FUNCTION_TYPE) (DWORD);
    FUNCTION_TYPE Function;
    LPVOID Value;
    BOOL Result;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_TLSGETVALUE);

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_TLS_CHECKS) != 0) {

        Result = CheckTlsIndex (dwTlsIndex);

        if (Result == FALSE) {

            return NULL;
        }

        dwTlsIndex = UnscrambleTlsIndex (dwTlsIndex);
    }

    Value = (*Function)(dwTlsIndex);

    return Value;
}


//WINBASEAPI
BOOL
WINAPI
AVrfpTlsSetValue(
    IN DWORD dwTlsIndex,
    IN LPVOID lpTlsValue
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (DWORD, LPVOID);
    FUNCTION_TYPE Function;
    BOOL Result;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_TLSSETVALUE);


    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_TLS_CHECKS) != 0) {

        Result = CheckTlsIndex (dwTlsIndex);

        if (Result == FALSE) {

            return FALSE;
        }

        dwTlsIndex = UnscrambleTlsIndex (dwTlsIndex);
    }

    return (*Function)(dwTlsIndex, lpTlsValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\tracker.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

    tracker.h

Abstract:

    Verifier call history tracker.

Author:

    Silviu Calinoiu (SilviuC) Jul-11-2002

Revision History:

--*/

#include "pch.h"

#include "verifier.h"
#include "support.h"
#include "tracker.h"


PAVRF_TRACKER 
AVrfCreateTracker (
    ULONG Size
    )
{
    PAVRF_TRACKER Tracker;

    //
    // Do not accept bogus sizes.
    //
        
    if (Size <= 1) {
        
        ASSERT (Size > 1);
        return NULL;
    }

    //
    // We allocate `Size - 1' tracker entries because we have already
    // an entry in the main tracker structure.
    //

    Tracker = AVrfpAllocate (sizeof(*Tracker) + (Size - 1) * sizeof(AVRF_TRACKER_ENTRY));

    if (Tracker == NULL) {
        return NULL;
    }

    //
    // We set the size. No other initialization is required since AVrfpAllocate zeroes 
    // the memory just allocated.
    //

    Tracker->Size = Size;

    return Tracker;
}


VOID
AVrfDestroyTracker (
    PAVRF_TRACKER Tracker
    )
{
    //
    // Safety checks.
    //

    if (Tracker == NULL) {
        return;
    }
    AVrfpFree (Tracker);
}


VOID
AVrfLogInTracker (
    PAVRF_TRACKER Tracker,
    USHORT EntryType,
    PVOID EntryParam1,
    PVOID EntryParam2,
    PVOID EntryParam3,
    PVOID EntryParam4,
    PVOID ReturnAddress
    )
{
    ULONG Index;
    USHORT Count;

    //
    // Safety checks.
    //

    if (Tracker == NULL) {
        return;
    }

    //
    // Get the index for the tracker entry that will be filled.
    //

    Index = (ULONG)InterlockedIncrement ((PLONG)(&(Tracker->Index)));
    Index %= Tracker->Size;

    //
    // If a null return address is passed then we need to
    // walk the stack and get a full stack trace.
    //

    Tracker->Entry[Index].Type = EntryType;
    Tracker->Entry[Index].Info[0] = EntryParam1;
    Tracker->Entry[Index].Info[1] = EntryParam2;
    Tracker->Entry[Index].Info[2] = EntryParam3;
    Tracker->Entry[Index].Info[3] = EntryParam4;

    Count = RtlCaptureStackBackTrace (2, 
                                      MAX_TRACE_DEPTH,
                                      Tracker->Entry[Index].Trace,
                                      NULL);

    if (Count == 0) {
        
        Tracker->Entry[Index].TraceDepth = 1;
        Tracker->Entry[Index].Trace[0] = ReturnAddress;
    }
    else {

        Tracker->Entry[Index].TraceDepth = Count;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\verifier.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

    verifier.h

Abstract:

    Internal interfaces for the standard application verifier provider.

Author:

    Silviu Calinoiu (SilviuC) 2-Feb-2001

Revision History:

--*/

#ifndef _VERIFIER_H_
#define _VERIFIER_H_

//
// Some global things.
//
                                                      
extern RTL_VERIFIER_THUNK_DESCRIPTOR AVrfpNtdllThunks[];
extern RTL_VERIFIER_THUNK_DESCRIPTOR AVrfpKernel32Thunks[];
extern RTL_VERIFIER_THUNK_DESCRIPTOR AVrfpAdvapi32Thunks[];
extern RTL_VERIFIER_THUNK_DESCRIPTOR AVrfpMsvcrtThunks[];
extern RTL_VERIFIER_THUNK_DESCRIPTOR AVrfpOleaut32Thunks[];

PRTL_VERIFIER_THUNK_DESCRIPTOR 
AVrfpGetThunkDescriptor (
    PRTL_VERIFIER_THUNK_DESCRIPTOR DllThunks,
    ULONG Index);

#define AVRFP_GET_ORIGINAL_EXPORT(DllThunks, Index) \
    (FUNCTION_TYPE)(AVrfpGetThunkDescriptor(DllThunks, Index)->ThunkOldAddress)

extern RTL_VERIFIER_PROVIDER_DESCRIPTOR AVrfpProvider;

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////// ntdll.dll verified exports
/////////////////////////////////////////////////////////////////////

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    );
       
//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

//NTSYSAPI
BOOL
NTAPI
AVrfpRtlTryEnterCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlEnterCriticalSection(
    volatile RTL_CRITICAL_SECTION *CriticalSection
    );

//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlLeaveCriticalSection(
    volatile RTL_CRITICAL_SECTION *CriticalSection
    );

//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlInitializeCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlInitializeCriticalSectionAndSpinCount(
    PRTL_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    );

//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlDeleteCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

VOID
AVrfpRtlInitializeResource(
    IN PRTL_RESOURCE Resource
    );

VOID
AVrfpRtlDeleteResource (
    IN PRTL_RESOURCE Resource
    );

BOOLEAN
AVrfpRtlAcquireResourceShared (
    IN PRTL_RESOURCE Resource,
    IN BOOLEAN Wait
    );

BOOLEAN
AVrfpRtlAcquireResourceExclusive (
    IN PRTL_RESOURCE Resource,
    IN BOOLEAN Wait
    );

VOID
AVrfpRtlReleaseResource (
    IN PRTL_RESOURCE Resource
    );

VOID
AVrfpRtlConvertSharedToExclusive(
    IN PRTL_RESOURCE Resource
    );

VOID
AVrfpRtlConvertExclusiveToShared (
    IN PRTL_RESOURCE Resource
    );


//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtClose(
    IN HANDLE Handle
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );

//NTSYSAPI
PVOID
NTAPI
AVrfpRtlAllocateHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

//NTSYSAPI
BOOLEAN
NTAPI
AVrfpRtlFreeHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

//NTSYSAPI
PVOID
NTAPI
AVrfpRtlReAllocateHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    );

//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlQueueWorkItem(
    IN  WORKERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  Flags
    );

//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlRegisterWait (
    OUT PHANDLE WaitHandle,
    IN  HANDLE  Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  Milliseconds,
    IN  ULONG  Flags
    );

//NTSYSAPI
NTSTATUS
NTAPI
AVrfpRtlCreateTimer(
    IN  HANDLE TimerQueueHandle,
    OUT HANDLE *Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  DueTime,
    IN  ULONG  Period,
    IN  ULONG  Flags
    );

NTSTATUS
NTAPI
AVrfpLdrGetProcedureAddress(
    IN PVOID DllHandle,
    IN CONST ANSI_STRING* ProcedureName OPTIONAL,
    IN ULONG ProcedureNumber OPTIONAL,
    OUT PVOID *ProcedureAddress
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtReadFileScatter(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtWriteFileGather(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtWaitForMultipleObjects(
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

NTSTATUS
NTAPI
AVrfpRtlSetThreadPoolStartFunc(
    PRTLP_START_THREAD StartFunc,
    PRTLP_EXIT_THREAD ExitFunc
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// kernel32.dll verified exports
/////////////////////////////////////////////////////////////////////

#define AVRF_INDEX_KERNEL32_HEAPCREATE                0
#define AVRF_INDEX_KERNEL32_HEAPDESTROY               1
#define AVRF_INDEX_KERNEL32_CLOSEHANDLE               2
#define AVRF_INDEX_KERNEL32_EXITTHREAD                3
#define AVRF_INDEX_KERNEL32_TERMINATETHREAD           4
#define AVRF_INDEX_KERNEL32_SUSPENDTHREAD             5
#define AVRF_INDEX_KERNEL32_TLSALLOC                  6
#define AVRF_INDEX_KERNEL32_TLSFREE                   7
#define AVRF_INDEX_KERNEL32_TLSGETVALUE               8
#define AVRF_INDEX_KERNEL32_TLSSETVALUE               9
#define AVRF_INDEX_KERNEL32_CREATETHREAD              10
#define AVRF_INDEX_KERNEL32_GETPROCADDRESS            11
#define AVRF_INDEX_KERNEL32_WAITFORSINGLEOBJECT       12
#define AVRF_INDEX_KERNEL32_WAITFORMULTIPLEOBJECTS    13
#define AVRF_INDEX_KERNEL32_WAITFORSINGLEOBJECTEX     14
#define AVRF_INDEX_KERNEL32_WAITFORMULTIPLEOBJECTSEX  15
#define AVRF_INDEX_KERNEL32_GLOBALALLOC               16
#define AVRF_INDEX_KERNEL32_GLOBALREALLOC             17
#define AVRF_INDEX_KERNEL32_LOCALALLOC                18
#define AVRF_INDEX_KERNEL32_LOCALREALLOC              19
#define AVRF_INDEX_KERNEL32_CREATEFILEA               20
#define AVRF_INDEX_KERNEL32_CREATEFILEW               21
#define AVRF_INDEX_KERNEL32_FREELIBRARYANDEXITTHREAD  22
#define AVRF_INDEX_KERNEL32_GETTICKCOUNT              23
#define AVRF_INDEX_KERNEL32_ISBADREADPTR              24
#define AVRF_INDEX_KERNEL32_ISBADHUGEREADPTR          25
#define AVRF_INDEX_KERNEL32_ISBADWRITEPTR             26
#define AVRF_INDEX_KERNEL32_ISBADHUGEWRITEPTR         27
#define AVRF_INDEX_KERNEL32_ISBADCODEPTR              28
#define AVRF_INDEX_KERNEL32_ISBADSTRINGPTRA           29
#define AVRF_INDEX_KERNEL32_ISBADSTRINGPTRW           30
#define AVRF_INDEX_KERNEL32_EXITPROCESS               31
#define AVRF_INDEX_KERNEL32_VIRTUALFREE               32
#define AVRF_INDEX_KERNEL32_VIRTUALFREEEX             33


//WINBASEAPI
HANDLE
WINAPI
AVrfpHeapCreate(
    IN DWORD flOptions,
    IN SIZE_T dwInitialSize,
    IN SIZE_T dwMaximumSize
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpHeapDestroy(
    IN OUT HANDLE hHeap
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpCloseHandle(
    IN OUT HANDLE hObject
    );

//WINBASEAPI
DECLSPEC_NORETURN
VOID
WINAPI
AVrfpExitThread(
    IN DWORD dwExitCode
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpTerminateThread(
    IN OUT HANDLE hThread,
    IN DWORD dwExitCode
    );

//WINBASEAPI
DWORD
WINAPI
AVrfpSuspendThread(
    IN HANDLE hThread
    );

//WINBASEAPI
HANDLE
WINAPI
AVrfpCreateThread(
    IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
    IN SIZE_T dwStackSize,
    IN LPTHREAD_START_ROUTINE lpStartAddress,
    IN LPVOID lpParameter,
    IN DWORD dwCreationFlags,
    OUT LPDWORD lpThreadId
    );

//WINBASEAPI
DWORD
WINAPI
AVrfpTlsAlloc(
    VOID
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpTlsFree(
    IN DWORD dwTlsIndex
    );

//WINBASEAPI
LPVOID
WINAPI
AVrfpTlsGetValue(
    IN DWORD dwTlsIndex
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpTlsSetValue(
    IN DWORD dwTlsIndex,
    IN LPVOID lpTlsValue
    );

//WINBASEAPI
FARPROC
WINAPI
AVrfpGetProcAddress(
    IN HMODULE hModule,
    IN LPCSTR lpProcName
    );

//WINBASEAPI
DWORD
WINAPI
AVrfpWaitForSingleObject(
    IN HANDLE hHandle,
    IN DWORD dwMilliseconds
    );

//WINBASEAPI
DWORD
WINAPI
AVrfpWaitForMultipleObjects(
    IN DWORD nCount,
    IN CONST HANDLE *lpHandles,
    IN BOOL bWaitAll,
    IN DWORD dwMilliseconds
    );

//WINBASEAPI
DWORD
WINAPI
AVrfpWaitForSingleObjectEx(
    IN HANDLE hHandle,
    IN DWORD dwMilliseconds,
    IN BOOL bAlertable
    );

//WINBASEAPI
DWORD
WINAPI
AVrfpWaitForMultipleObjectsEx(
    IN DWORD nCount,
    IN CONST HANDLE *lpHandles,
    IN BOOL bWaitAll,
    IN DWORD dwMilliseconds,
    IN BOOL bAlertable
    );

//WINBASEAPI
HGLOBAL
WINAPI
AVrfpGlobalAlloc(
    IN UINT uFlags,
    IN SIZE_T dwBytes
    );

//WINBASEAPI
HGLOBAL
WINAPI
AVrfpGlobalReAlloc(
    IN HGLOBAL hMem,
    IN SIZE_T dwBytes,
    IN UINT uFlags
    );

//WINBASEAPI
HLOCAL
WINAPI
AVrfpLocalAlloc(
    IN UINT uFlags,
    IN SIZE_T uBytes
    );

//WINBASEAPI
HLOCAL
WINAPI
AVrfpLocalReAlloc(
    IN HLOCAL hMem,
    IN SIZE_T uBytes,
    IN UINT uFlags
    );

//WINBASEAPI
HANDLE
WINAPI
AVrfpCreateFileA(
    IN LPCSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile
    );

//WINBASEAPI
HANDLE
WINAPI
AVrfpCreateFileW(
    IN LPCWSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile
    );

//WINBASEAPI
DECLSPEC_NORETURN
VOID
WINAPI
AVrfpFreeLibraryAndExitThread(
    IN HMODULE hLibModule,
    IN DWORD dwExitCode
    );

//WINBASEAPI
DWORD
WINAPI
AVrfpGetTickCount(
    VOID
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadReadPtr(
    CONST VOID *lp,
    UINT_PTR cb
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadHugeReadPtr(
    CONST VOID *lp,
    UINT_PTR cb
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadWritePtr(
    LPVOID lp,
    UINT_PTR cb
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadHugeWritePtr(
    LPVOID lp,
    UINT_PTR cb
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadCodePtr(
    FARPROC lpfn
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadStringPtrA(
    LPCSTR lpsz,
    UINT_PTR cchMax
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadStringPtrW(
    LPCWSTR lpsz,
    UINT_PTR cchMax
    );

//WINBASEAPI
DECLSPEC_NORETURN
VOID
WINAPI
AVrfpExitProcess(
    IN UINT uExitCode
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpVirtualFree(
    IN LPVOID lpAddress,
    IN SIZE_T dwSize,
    IN DWORD dwFreeType
    );

//WINBASEAPI
BOOL
WINAPI
AVrfpVirtualFreeEx(
    IN HANDLE hProcess,
    IN LPVOID lpAddress,
    IN SIZE_T dwSize,
    IN DWORD dwFreeType
    );


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// advapi32.dll verified exports
/////////////////////////////////////////////////////////////////////

typedef ACCESS_MASK REGSAM;

#define AVRF_INDEX_ADVAPI32_REGCREATEKEYA     0
#define AVRF_INDEX_ADVAPI32_REGCREATEKEYW     1
#define AVRF_INDEX_ADVAPI32_REGCREATEKEYEXA   2
#define AVRF_INDEX_ADVAPI32_REGCREATEKEYEXW   3
#define AVRF_INDEX_ADVAPI32_REGOPENKEYA       4
#define AVRF_INDEX_ADVAPI32_REGOPENKEYW       5
#define AVRF_INDEX_ADVAPI32_REGOPENKEYEXA     6
#define AVRF_INDEX_ADVAPI32_REGOPENKEYEXW     7

//WINADVAPI
LONG
APIENTRY
AVrfpRegCreateKeyExW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD Reserved,
    IN LPWSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    );

//WINADVAPI
LONG
APIENTRY
AVrfpRegCreateKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    OUT PHKEY phkResult
    );

//WINADVAPI
LONG
APIENTRY
AVrfpRegCreateKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    );

//WINADVAPI
LONG
APIENTRY
AVrfpRegCreateKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    );

//WINADVAPI
LONG
APIENTRY
AVrfpRegCreateKeyExW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD Reserved,
    IN LPWSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    );

//WINADVAPI
LONG
APIENTRY
AVrfpRegOpenKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    OUT PHKEY phkResult
    );

//WINADVAPI
LONG
APIENTRY
AVrfpRegOpenKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    );

//WINADVAPI
LONG
APIENTRY
AVrfpRegOpenKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    );

//WINADVAPI
LONG
APIENTRY
AVrfpRegOpenKeyExW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// msvcrt.dll verified exports
/////////////////////////////////////////////////////////////////////

#define AVRF_INDEX_MSVCRT_MALLOC       0
#define AVRF_INDEX_MSVCRT_CALLOC       1
#define AVRF_INDEX_MSVCRT_REALLOC      2
#define AVRF_INDEX_MSVCRT_FREE         3
#define AVRF_INDEX_MSVCRT_NEW          4
#define AVRF_INDEX_MSVCRT_DELETE       5
#define AVRF_INDEX_MSVCRT_NEWARRAY     6
#define AVRF_INDEX_MSVCRT_DELETEARRAY  7

PVOID __cdecl
AVrfp_malloc (
    IN SIZE_T Size
    );

PVOID __cdecl
AVrfp_calloc (
    IN SIZE_T Number,
    IN SIZE_T Size
    );

PVOID __cdecl
AVrfp_realloc (
    IN PVOID Address,
    IN SIZE_T Size
    );

VOID __cdecl
AVrfp_free (
    IN PVOID Address
    );

PVOID __cdecl
AVrfp_new (
    IN SIZE_T Size
    );

VOID __cdecl
AVrfp_delete (
    IN PVOID Address
    );

PVOID __cdecl
AVrfp_newarray (
    IN SIZE_T Size
    );

VOID __cdecl
AVrfp_deletearray (
    IN PVOID Address
    );

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////// ole32.dll verified exports
/////////////////////////////////////////////////////////////////////

#define AVRF_INDEX_OLEAUT32_SYSALLOCSTRING            0
#define AVRF_INDEX_OLEAUT32_SYSREALLOCSTRING          1
#define AVRF_INDEX_OLEAUT32_SYSALLOCSTRINGLEN         2
#define AVRF_INDEX_OLEAUT32_SYSREALLOCSTRINGLEN       3
#define AVRF_INDEX_OLEAUT32_SYSALLOCSTRINGBYTELEN     4

typedef WCHAR OLECHAR;

BSTR STDAPICALLTYPE AVrfpSysAllocString(const OLECHAR *);
INT STDAPICALLTYPE  AVrfpSysReAllocString(BSTR *, const OLECHAR *);
BSTR STDAPICALLTYPE AVrfpSysAllocStringLen(const OLECHAR *, UINT);
INT STDAPICALLTYPE  AVrfpSysReAllocStringLen(BSTR *, const OLECHAR *, UINT);
BSTR STDAPICALLTYPE AVrfpSysAllocStringByteLen(LPCSTR psz, UINT len);


#endif // _VERIFIER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\verifier.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    verifier.c

Abstract:

    This module implements the main entry points for
    the base application verifier provider (verifier.dll).

Author:

    Silviu Calinoiu (SilviuC) 2-Feb-2001

Revision History:

--*/

//
// IMPORTANT NOTE.
//
// This dll cannot contain non-ntdll dependencies. This way we can run
// verifier systemwide for any process (including smss and csrss).
//


#include "pch.h"

#include "verifier.h"
#include "support.h"
#include "settings.h"
#include "critsect.h"
#include "faults.h"
#include "deadlock.h"
#include "vspace.h"
#include "logging.h"

//
// ntdll.dll thunks
//

RTL_VERIFIER_THUNK_DESCRIPTOR AVrfpNtdllThunks [] =
{
    {"NtAllocateVirtualMemory", NULL, AVrfpNtAllocateVirtualMemory},
    {"NtFreeVirtualMemory", NULL, AVrfpNtFreeVirtualMemory},
    {"NtMapViewOfSection", NULL, AVrfpNtMapViewOfSection},
    {"NtUnmapViewOfSection", NULL, AVrfpNtUnmapViewOfSection},
    {"NtCreateSection", NULL, AVrfpNtCreateSection},
    {"NtOpenSection", NULL, AVrfpNtOpenSection},
    {"NtCreateFile", NULL, AVrfpNtCreateFile},
    {"NtOpenFile", NULL, AVrfpNtOpenFile},
    {"NtCreateKey", NULL, AVrfpNtCreateKey},
    {"NtOpenKey", NULL, AVrfpNtOpenKey},
    {"LdrGetProcedureAddress", NULL, AVrfpLdrGetProcedureAddress},
    
    {"RtlTryEnterCriticalSection", NULL, AVrfpRtlTryEnterCriticalSection},
    {"RtlEnterCriticalSection", NULL, AVrfpRtlEnterCriticalSection},
    {"RtlLeaveCriticalSection", NULL, AVrfpRtlLeaveCriticalSection},
    {"RtlInitializeCriticalSection", NULL, AVrfpRtlInitializeCriticalSection},
    {"RtlInitializeCriticalSectionAndSpinCount", NULL, AVrfpRtlInitializeCriticalSectionAndSpinCount},
    {"RtlDeleteCriticalSection", NULL, AVrfpRtlDeleteCriticalSection},
    {"RtlInitializeResource", NULL, AVrfpRtlInitializeResource},
    {"RtlDeleteResource", NULL, AVrfpRtlDeleteResource},
    {"RtlAcquireResourceShared", NULL, AVrfpRtlAcquireResourceShared},
    {"RtlAcquireResourceExclusive", NULL, AVrfpRtlAcquireResourceExclusive},
    {"RtlReleaseResource", NULL, AVrfpRtlReleaseResource},
    {"RtlConvertSharedToExclusive", NULL, AVrfpRtlConvertSharedToExclusive},
    {"RtlConvertExclusiveToShared", NULL, AVrfpRtlConvertExclusiveToShared},

    {"NtCreateEvent", NULL, AVrfpNtCreateEvent },
    {"NtClose", NULL, AVrfpNtClose},

    {"RtlAllocateHeap", NULL, AVrfpRtlAllocateHeap },
    {"RtlReAllocateHeap", NULL, AVrfpRtlReAllocateHeap },
    {"RtlFreeHeap", NULL, AVrfpRtlFreeHeap },
    
    {"NtReadFile", NULL, AVrfpNtReadFile},
    {"NtReadFileScatter", NULL, AVrfpNtReadFileScatter},
    {"NtWriteFile", NULL, AVrfpNtWriteFile},
    {"NtWriteFileGather", NULL, AVrfpNtWriteFileGather},

    {"NtWaitForSingleObject", NULL, AVrfpNtWaitForSingleObject},
    {"NtWaitForMultipleObjects", NULL, AVrfpNtWaitForMultipleObjects},

    {"RtlSetThreadPoolStartFunc", NULL, AVrfpRtlSetThreadPoolStartFunc},

    {NULL, NULL, NULL}
};

//
// kernel32.dll thunks
//

RTL_VERIFIER_THUNK_DESCRIPTOR AVrfpKernel32Thunks [] =
{
    {"HeapCreate", NULL, AVrfpHeapCreate},
    {"HeapDestroy", NULL, AVrfpHeapDestroy},
    {"CloseHandle", NULL, AVrfpCloseHandle},
    {"ExitThread", NULL, AVrfpExitThread},
    {"TerminateThread", NULL, AVrfpTerminateThread},
    {"SuspendThread", NULL, AVrfpSuspendThread},
    {"TlsAlloc", NULL, AVrfpTlsAlloc},
    {"TlsFree", NULL, AVrfpTlsFree},
    {"TlsGetValue", NULL, AVrfpTlsGetValue},
    {"TlsSetValue", NULL, AVrfpTlsSetValue},
    {"CreateThread", NULL, AVrfpCreateThread},
    {"GetProcAddress", NULL, AVrfpGetProcAddress},
    {"WaitForSingleObject", NULL, AVrfpWaitForSingleObject},
    {"WaitForMultipleObjects", NULL, AVrfpWaitForMultipleObjects},
    {"WaitForSingleObjectEx", NULL, AVrfpWaitForSingleObjectEx},
    {"WaitForMultipleObjectsEx", NULL, AVrfpWaitForMultipleObjectsEx},
    {"GlobalAlloc", NULL, AVrfpGlobalAlloc},
    {"GlobalReAlloc", NULL, AVrfpGlobalReAlloc},
    {"LocalAlloc", NULL, AVrfpLocalAlloc},
    {"LocalReAlloc", NULL, AVrfpLocalReAlloc},
    {"CreateFileA", NULL, AVrfpCreateFileA},
    {"CreateFileW", NULL, AVrfpCreateFileW},
    {"FreeLibraryAndExitThread", NULL, AVrfpFreeLibraryAndExitThread},
    {"GetTickCount", NULL, AVrfpGetTickCount},
    {"IsBadReadPtr", NULL, AVrfpIsBadReadPtr},
    {"IsBadHugeReadPtr", NULL, AVrfpIsBadHugeReadPtr},
    {"IsBadWritePtr", NULL, AVrfpIsBadWritePtr},
    {"IsBadHugeWritePtr", NULL, AVrfpIsBadHugeWritePtr},
    {"IsBadCodePtr", NULL, AVrfpIsBadCodePtr},
    {"IsBadStringPtrA", NULL, AVrfpIsBadStringPtrA},
    {"IsBadStringPtrW", NULL, AVrfpIsBadStringPtrW},
    {"ExitProcess", NULL, AVrfpExitProcess},
    {"VirtualFree", NULL, AVrfpVirtualFree},
    {"VirtualFreeEx", NULL, AVrfpVirtualFreeEx},
    
    {NULL, NULL, NULL}
};

//
// advapi32.dll thunks
//

RTL_VERIFIER_THUNK_DESCRIPTOR AVrfpAdvapi32Thunks [] =
{
    {"RegCreateKeyA", NULL, AVrfpRegCreateKeyA},
    {"RegCreateKeyW", NULL, AVrfpRegCreateKeyW},
    {"RegCreateKeyExA", NULL, AVrfpRegCreateKeyExA},
    {"RegCreateKeyExW", NULL, AVrfpRegCreateKeyExW},
    {"RegOpenKeyA", NULL, AVrfpRegOpenKeyA},
    {"RegOpenKeyW", NULL, AVrfpRegOpenKeyW},
    {"RegOpenKeyExA", NULL, AVrfpRegOpenKeyExA},
    {"RegOpenKeyExW", NULL, AVrfpRegOpenKeyExW},

    {NULL, NULL, NULL}
};

//
// msvcrt.dll thunks
//

RTL_VERIFIER_THUNK_DESCRIPTOR AVrfpMsvcrtThunks [] =
{
    {"malloc", NULL, AVrfp_malloc},
    {"calloc", NULL, AVrfp_calloc},
    {"realloc", NULL, AVrfp_realloc},
    {"free", NULL, AVrfp_free},
#if defined(_X86_) // compilers for various architectures decorate slightly different
    {"??2@YAPAXI@Z", NULL, AVrfp_new},
    {"??3@YAXPAX@Z", NULL, AVrfp_delete},
    {"??_U@YAPAXI@Z", NULL, AVrfp_newarray},
    {"??_V@YAXPAX@Z", NULL, AVrfp_deletearray},
#elif defined(_IA64_)
    {"??2@YAPEAX_K@Z", NULL, AVrfp_new},
    {"??3@YAXPEAX@Z", NULL, AVrfp_delete},
    {"??_U@YAPEAX_K@Z", NULL, AVrfp_newarray},
    {"??_V@YAXPEAX@Z", NULL, AVrfp_deletearray},
#elif defined(_AMD64_)
    {"??2@YAPAX_K@Z", NULL, AVrfp_new},
    {"??3@YAXPAX@Z", NULL, AVrfp_delete},
    {"??_U@YAPAX_K@Z", NULL, AVrfp_newarray},
    {"??_V@YAXPAX@Z", NULL, AVrfp_deletearray},
#else
#error Unknown architecture
#endif
     
    {NULL, NULL, NULL}
};

//
// oleaut32.dll thunks
//

RTL_VERIFIER_THUNK_DESCRIPTOR AVrfpOleaut32Thunks [] =
{
    {"SysAllocString", NULL, AVrfpSysAllocString},
    {"SysReAllocString", NULL, AVrfpSysReAllocString},
    {"SysAllocStringLen", NULL, AVrfpSysAllocStringLen},
    {"SysReAllocStringLen", NULL, AVrfpSysReAllocStringLen},
    {"SysAllocStringByteLen", NULL, AVrfpSysAllocStringByteLen},
     
    {NULL, NULL, NULL}
};

//
// dll's providing thunks verified.
//

RTL_VERIFIER_DLL_DESCRIPTOR AVrfpExportDlls [] =
{
    {L"ntdll.dll", 0, NULL, AVrfpNtdllThunks},
    {L"kernel32.dll", 0, NULL, AVrfpKernel32Thunks},
    {L"advapi32.dll", 0, NULL, AVrfpAdvapi32Thunks},
    {L"msvcrt.dll", 0, NULL, AVrfpMsvcrtThunks},

    //
    // Special care in what new dlls are added here. It is important
    // when running in back compat mode. For instance oleaut32.dll
    // cannot be hooked in WinXP due to a bug in ntdll\verifier.c
    // that has been fixed. Unfortunately when we put the latest verifier
    // on WinXP we need to workaround this.
    //
    
    {L"oleaut32.dll", 0, NULL, AVrfpOleaut32Thunks},

    {NULL, 0, NULL, NULL}
};


RTL_VERIFIER_PROVIDER_DESCRIPTOR AVrfpProvider = 
{
    sizeof (RTL_VERIFIER_PROVIDER_DESCRIPTOR),
    AVrfpExportDlls,
    AVrfpDllLoadCallback,   // callback for DLL load events
    AVrfpDllUnloadCallback, // callback for DLL unload events
    
    NULL,                   // image name (filled by verifier engine)
    0,                      // verifier flags (filled by verifier engine)
    0,                      // debug flags (filled by verifier engine)
    
    NULL,                   // RtlpGetStackTraceAddress
    NULL,                   // RtlpDebugPageHeapCreate
    NULL,                   // RtlpDebugPageHeapDestroy

    AVrfpNtdllHeapFreeCallback   // callback for HeapFree events inside the ntdll code (e.g. HeapDestroy);
                                 // the HeapFree calls from the other DLLs are already hooked using AVrfpRtlFreeHeap. 
};

//
// Mark if we have been called with PROCESS_ATTACH once.
// In some cases the fusion code loads dynamically kernel32.dll and enforces
// the run of all initialization routines and causes us to get called
// twice.
//

BOOL AVrfpProcessAttachCalled; 
BOOL AVrfpProcessAttachResult = TRUE;

//
// Global data.
//

const WCHAR AVrfpThreadName[] = L"Thread";
UNICODE_STRING AVrfpThreadObjectName;

//
// Provider descriptor from WinXP timeframe.
// Used to make verifier backwards compatible.
//
typedef struct _RTL_VERIFIER_PROVIDER_DESCRIPTOR_WINXP {

    ULONG Length;        
    PRTL_VERIFIER_DLL_DESCRIPTOR ProviderDlls;
    RTL_VERIFIER_DLL_LOAD_CALLBACK ProviderDllLoadCallback;
    RTL_VERIFIER_DLL_UNLOAD_CALLBACK ProviderDllUnloadCallback;
        
    PWSTR VerifierImage;
    ULONG VerifierFlags;
    ULONG VerifierDebug;
    
    //PVOID RtlpGetStackTraceAddress;
    //PVOID RtlpDebugPageHeapCreate;
    //PVOID RtlpDebugPageHeapDestroy;

} RTL_VERIFIER_PROVIDER_DESCRIPTOR_WINXP, *PRTL_VERIFIER_PROVIDER_DESCRIPTOR_WINXP;

#define WINXP_BUILD_NUMBER 2600
ULONG AVrfpBuildNumber;

PVOID 
AVrfpWinXPFakeGetStackTraceAddress (
    USHORT Index
    )
{
    UNREFERENCED_PARAMETER(Index);
    return NULL;
}

//
// DllMain
//

BOOL 
DllMainWithoutVerifierEnabled (
    DWORD Reason
    );

NTSTATUS
AVrfpRedirectNtdllStopFunction (
    VOID
    );

BOOL 
WINAPI 
DllMain(
  HINSTANCE hInstDll,  // handle to the DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{
    NTSTATUS Status;

    UNREFERENCED_PARAMETER (hInstDll);

    //
    // This function will call a light version of DllMain that enables only
    // the stop logic and logging logic for the cases where verifier.dll
    // is dynamically loaded by verifier shims just for that functionality.
    // For such cases the verifier flag will not be set.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return DllMainWithoutVerifierEnabled (fdwReason);
    }

    //
    // DllMain code when verifier flag is set.
    //

    switch (fdwReason) {
        
        case DLL_PROCESS_VERIFIER:

            //
            // DllMain gets called with this special reason by the verifier engine.
            // Minimal code should execute here (e.g. passing back the provider
            // descriptor). The rest should be postponed to PROCESS_ATTACH moment.
            //

            AVrfpBuildNumber = NtCurrentPeb()->OSBuildNumber;

            if (lpvReserved) {

                //
                // If we are running on WinXP the latest verifier.dll then we change 
                // the length to the old one and we disable hooks for oleaut32. A bug
                // in ntdll\verifier.c prevents this from being hooked correctly. The
                // bug was fixed but we still need to workaround it when running in
                // backcompat mode.
                //

                if (AVrfpBuildNumber == WINXP_BUILD_NUMBER) {

                    PRTL_VERIFIER_DLL_DESCRIPTOR Descriptor;

                    AVrfpProvider.Length = sizeof (RTL_VERIFIER_PROVIDER_DESCRIPTOR_WINXP);

                    Descriptor = &AVrfpExportDlls[0];

                    while (Descriptor->DllName != NULL) {
                        
                        if (_wcsicmp (Descriptor->DllName, L"oleaut32.dll") == 0) {
                            
                            RtlZeroMemory (Descriptor, sizeof *Descriptor);
                            break;
                        }

                        Descriptor += 1;
                    }
                }

                *((PRTL_VERIFIER_PROVIDER_DESCRIPTOR *)lpvReserved) = &AVrfpProvider;

                Status = AVrfpDllInitialize ();
                
                if (! NT_SUCCESS (Status)) {
                    return FALSE;
                }

                //
                // Create private verifier heap. We need to do it here because in
                // PROCESS_ATTACH it is too late. Verifier will receive a dll load
                // notification for kernel32 before verifier DllMain is called
                // with PROCESS_ATTACH.
                //

                AVrfpHeap = RtlCreateHeap (HEAP_CLASS_1 | HEAP_GROWABLE, 
                                           NULL, 
                                           0, 
                                           0, 
                                           NULL, 
                                           NULL);

                if (AVrfpHeap == NULL) {
                    DbgPrint ("AVRF: failed to create verifier heap. \n");
                    return FALSE;
                }

                //
                // Initialize verifier stops and logging.
                //

                Status = AVrfpInitializeVerifierStops();

                if (!NT_SUCCESS(Status)) {
                    DbgPrint ("AVRF: failed to initialize verifier stop logic (%X). \n", Status);
                    return FALSE;
                }

                //
                // Create call trackers.
                //

                Status = AVrfCreateTrackers ();
                
                if (!NT_SUCCESS(Status)) {
                    DbgPrint ("AVRF: failed to initialize call trackers (%X). \n", Status);
                    return FALSE;
                }
            }
            
            break;

        case DLL_PROCESS_ATTACH:

            //
            // Execute only minimal code here and avoid too many DLL dependencies.
            //

            if (! AVrfpProcessAttachCalled) {

                AVrfpProcessAttachCalled = TRUE;

                //
                // Pickup private ntdll entrypoints required by verifier.
                //

                if (AVrfpBuildNumber == WINXP_BUILD_NUMBER) {
                    
                    AVrfpGetStackTraceAddress = AVrfpWinXPFakeGetStackTraceAddress;
                    AVrfpRtlpDebugPageHeapCreate = NULL;
                    AVrfpRtlpDebugPageHeapDestroy = NULL;
                }
                else {

                    AVrfpGetStackTraceAddress = (PFN_RTLP_GET_STACK_TRACE_ADDRESS)(AVrfpProvider.RtlpGetStackTraceAddress);
                    AVrfpRtlpDebugPageHeapCreate = (PFN_RTLP_DEBUG_PAGE_HEAP_CREATE)(AVrfpProvider.RtlpDebugPageHeapCreate);
                    AVrfpRtlpDebugPageHeapDestroy = (PFN_RTLP_DEBUG_PAGE_HEAP_DESTROY)(AVrfpProvider.RtlpDebugPageHeapDestroy);
                }

                //
                // Cache some basic system information for later use.
                //

                Status = NtQuerySystemInformation (SystemBasicInformation,
                                                   &AVrfpSysBasicInfo,
                                                   sizeof (AVrfpSysBasicInfo),
                                                   NULL);

                if (! NT_SUCCESS (Status)) {

                    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_GENERIC) != 0) {

                        DbgPrint ("AVRF: NtQuerySystemInformation (SystemBasicInformation) failed, status %#x\n",
                                  Status);
                    }

                    AVrfpProcessAttachResult = FALSE;
                    return AVrfpProcessAttachResult;
                }

                //
                // For XP client only try to patch old stop function from ntdll
                // so that it jumps unconditionally into the better stop function
                // from verifier.dll.
                //

                if (AVrfpBuildNumber == WINXP_BUILD_NUMBER) {

                    Status = AVrfpRedirectNtdllStopFunction ();

                    if (! NT_SUCCESS (Status)) {
                        
                        DbgPrint ("AVRF: failed to patch old stop function (%X). \n", Status);

                        AVrfpProcessAttachResult = FALSE;
                        return AVrfpProcessAttachResult;
                    }
                }

                RtlInitUnicodeString(&AVrfpThreadObjectName,
                                     AVrfpThreadName);

                //
                // Initialize various sub-modules.
                //

                if (AVrfpProvider.VerifierImage) {

                    try {

                        //
                        // Initialize exception checking support (logging etc.).
                        //

                        AVrfpInitializeExceptionChecking ();

                        //
                        // Reserve a TLS slot for verifier.
                        //

                        Status = AVrfpAllocateVerifierTlsSlot ();

                        if (! NT_SUCCESS (Status)) {

                            AVrfpProcessAttachResult = FALSE;
                            return AVrfpProcessAttachResult;
                        }

                        //
                        // Initialize the thread hash table.
                        //

                        Status = AVrfpThreadTableInitialize();

                        if (! NT_SUCCESS (Status)) {

                            AVrfpProcessAttachResult = FALSE;
                            return AVrfpProcessAttachResult;
                        }

                        //
                        // Initialize the fault injection support.
                        //

                        Status = AVrfpInitializeFaultInjectionSupport ();

                        if (! NT_SUCCESS (Status)) {

                            AVrfpProcessAttachResult = FALSE;
                            return AVrfpProcessAttachResult;
                        }

                        //
                        // Initialize the lock verifier package.
                        //

                        Status = CritSectInitialize ();

                        if (! NT_SUCCESS (Status)) {

                            AVrfpProcessAttachResult = FALSE;
                            return AVrfpProcessAttachResult;
                        }

                        //
                        // Initialize deadlock verifier. If anything goes
                        // wrong during initialization we clean up and 
                        // verifier will march forward. Just deadlock verifier
                        // will be disabled.
                        //

                        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_DEADLOCK_CHECKS) != 0) {
                            
                            AVrfDeadlockDetectionInitialize ();
                        }

                        //
                        // Initialize the virtual space tracker.
                        //
                        
                        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING) != 0) {

                            Status = AVrfpVsTrackInitialize ();
                            
                            if (! NT_SUCCESS (Status)) {

                                AVrfpProcessAttachResult = FALSE;
                                return AVrfpProcessAttachResult;
                            }
                        }

                        //
                        // Enable logging logic. We do this here separate from the 
                        // initialization done in PROCESS_VERIFIER for verifier 
                        // stops because we need to check the verifier flags and 
                        // verifier image name and these are passed from ntdll.dll to
                        // verifier.dll only during PROCESS_ATTACH.
                        //
                        // Note. If verifier is enabled system wide we do not enable
                        // logging. This is a special case for internal users where
                        // it is assumed you have a kernel debugger attached and you 
                        // are ready to deal with failures this way.
                        //

                        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_ENABLED_SYSTEM_WIDE) == 0) {

                            Status = AVrfpInitializeVerifierLogging();

                            if (!NT_SUCCESS(Status)) {

                                //
                                // Failure to initialize logging is not fatal. This can happen
                                // in out of memory conditions or for early processes like smss.exe.
                                //
                                
                                DbgPrint ("AVRF: failed to initialize verifier logging (%X). \n", Status);
                            }
                        }
                    }
                    except (EXCEPTION_EXECUTE_HANDLER) {

                        AVrfpProcessAttachResult = FALSE;
                        return AVrfpProcessAttachResult;
                    }

                    //
                    // Print a successful message.
                    //

                    DbgPrint ("AVRF: verifier.dll provider initialized for %ws with flags 0x%X\n",
                              AVrfpProvider.VerifierImage,
                              AVrfpProvider.VerifierFlags);
                }
            }
            else {

                //
                // This is the second time our DllMain (DLL_PROCESS_ATTACH) gets called. 
                // Return the same result as last time.
                //

                return AVrfpProcessAttachResult;
            }

            break;

        case DLL_PROCESS_DETACH:

            //
            // Cleanup exception checking support.
            //

            AVrfpCleanupExceptionChecking ();

            //
            // Uninitialize the locks checking packages.
            //

            CritSectUninitialize ();

            break;

        case DLL_THREAD_ATTACH:

            AvrfpThreadAttach ();

            break;

        case DLL_THREAD_DETACH:

            AvrfpThreadDetach ();

            break;

        default:

            break;
    }

    return TRUE;
}


BOOL 
DllMainWithoutVerifierEnabled (
    DWORD Reason
    )
{
    NTSTATUS Status;

    switch (Reason) {
        
        case DLL_PROCESS_ATTACH:

            //
            // Create private verifier heap. Since we run in a mode where verifier.dll
            // is used only for verifier stops and logging it is ok to create the
            // verifier private heap so late. The heap is used by verifier stops
            // to keep a list of stops that should be skipped.
            //

            AVrfpHeap = RtlCreateHeap (HEAP_CLASS_1 | HEAP_GROWABLE, 
                                       NULL, 
                                       0, 
                                       0, 
                                       NULL, 
                                       NULL);

            if (AVrfpHeap == NULL) {
                DbgPrint ("AVRF: failed to create verifier heap. \n");
                return FALSE;
            }

            //
            // Initialize verifier stops and logging.
            //

            Status = AVrfpInitializeVerifierStops();

            if (!NT_SUCCESS(Status)) {
                DbgPrint ("AVRF: failed to initialize verifier stop logic (%X). \n", Status);
                return FALSE;
            }
            
            Status = AVrfpInitializeVerifierLogging();

            if (! NT_SUCCESS(Status)) {
                DbgPrint ("AVRF: failed to initialize verifier logging (%X). \n", Status);
                return FALSE;
            }

            break;
        
        default:

            return FALSE;
    }

    return TRUE;
}


PRTL_VERIFIER_THUNK_DESCRIPTOR 
AVrfpGetThunkDescriptor (
    PRTL_VERIFIER_THUNK_DESCRIPTOR DllThunks,
    ULONG Index)
{
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunk = NULL;

    Thunk = &(DllThunks[Index]);

    if (Thunk->ThunkNewAddress == NULL) {

        DbgPrint ("AVRF: internal error: we do not have a replace for %s !!! \n",
                  Thunk->ThunkName);
        DbgBreakPoint ();
    }

    return Thunk;
}


//WINBASEAPI
BOOL
WINAPI
AVrfpCloseHandle(
    IN OUT HANDLE hObject
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (HANDLE);
    FUNCTION_TYPE Function;

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_CLOSEHANDLE);

    if (hObject == NULL) {
        BUMP_COUNTER(CNT_CLOSE_NULL_HANDLE_CALLS);
        CHECK_BREAK(BRK_CLOSE_NULL_HANDLE);
    }
    else if (hObject == NtCurrentProcess() ||
             hObject == NtCurrentThread()) {
        BUMP_COUNTER(CNT_CLOSE_PSEUDO_HANDLE_CALLS);
        CHECK_BREAK(BRK_CLOSE_PSEUDO_HANDLE);
    }

    return (* Function)(hObject);
}


//WINBASEAPI
FARPROC
WINAPI
AVrfpGetProcAddress(
    IN HMODULE hModule,
    IN LPCSTR lpProcName
    )
{
    typedef FARPROC (WINAPI * FUNCTION_TYPE) (HMODULE, LPCSTR);
    FUNCTION_TYPE Function;
    ULONG DllIndex;
    ULONG ThunkIndex;
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks;
    FARPROC ProcAddress;

    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOADLIBRARY_CALLS) != 0) {

        DbgPrint ("AVRF: AVrfpGetProcAddress (%p, %s)\n",
                  hModule,
                  lpProcName);
    }

    //
    // Call the original GetProcAddress from kernel32.
    //

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_GETPROCADDRESS);

    ProcAddress = (* Function)(hModule, lpProcName);

    //
    // Check if we want to thunk this export on the fly.
    //

    if (ProcAddress != NULL) {

        //
        // Parse all thunked DLLs. 
        //
        // N.B.
        //
        // We cannot look only for thunked functions inside 
        // the hModule DLL because that can be forwarded to another thunked DLL. 
        // (e.g. kernel32!TryEnterCriticalSection is forwarded
        // to ntdll!RtlTryEnterCriticalSection).
        //

        for (DllIndex = 0; AVrfpExportDlls[DllIndex].DllName != NULL; DllIndex += 1) {

            //
            // Parse all thunks for this DLL. 
            //

            Thunks = AVrfpExportDlls[ DllIndex ].DllThunks;

            for (ThunkIndex = 0; Thunks[ ThunkIndex ].ThunkName != NULL; ThunkIndex += 1) {

                if (Thunks[ ThunkIndex ].ThunkOldAddress == ProcAddress) {

                    ProcAddress = Thunks[ ThunkIndex ].ThunkNewAddress;

                    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOADLIBRARY_THUNKED) != 0) {

                        DbgPrint ("AVRF: AVrfpGetProcAddress (%p, %s) -> thunk address %p\n",
                                  hModule,
                                  lpProcName,
                                  ProcAddress);
                    }

                    goto Done;
                }
            }
        }

    }

Done:

    return ProcAddress;
}


NTSTATUS
NTAPI
AVrfpLdrGetProcedureAddress(
    IN PVOID DllHandle,
    IN CONST ANSI_STRING* ProcedureName OPTIONAL,
    IN ULONG ProcedureNumber OPTIONAL,
    OUT PVOID *ProcedureAddress
    )
/*++

Routine description:

    This routine is used to chain APIs hooked by other hook engines.
    If the routine searched is one already hooked by verifier
    then the verifier replacement is returned instead of the
    original export. 
    
--*/
{
    NTSTATUS Status;
    ULONG DllIndex;
    ULONG ThunkIndex;
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks;

    Status = LdrGetProcedureAddress (DllHandle,
                                     ProcedureName,
                                     ProcedureNumber,
                                     ProcedureAddress);

    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Parse all thunks with hooks for this DLL. 
    //

    for (DllIndex = 0; AVrfpExportDlls[DllIndex].DllName != NULL; DllIndex += 1) {

        Thunks = AVrfpExportDlls[DllIndex].DllThunks;

        for (ThunkIndex = 0; Thunks[ThunkIndex].ThunkName != NULL; ThunkIndex += 1) {

            if (Thunks[ThunkIndex].ThunkOldAddress == *ProcedureAddress) {

                *ProcedureAddress = Thunks[ThunkIndex].ThunkNewAddress;

                if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_LOADLIBRARY_THUNKED) != 0) {

                    DbgPrint ("AVRF: AVrfpLdrGetProcedureAddress (%p, %s) -> new address %p\n",
                              DllHandle,
                              Thunks[ThunkIndex].ThunkName,
                              *ProcedureAddress);
                }

                goto Exit;
            }
        }
    }

Exit:

    return Status;
}


#define READ_POINTER(Address, Bias) (*((PLONG_PTR)((PBYTE)(LONG_PTR)(Address) + (Bias))))

NTSTATUS
AVrfpRedirectNtdllStopFunction (
    VOID
    )
/*++

Routine description:

    This function is called only on XP client to patch RtlApplicationVerifierStop
    so that it jumps unconditionally to the better VerifierStopMessage. For .NET
    server and later this is not an issue but for XP client there is code in ntdll
    (namely page heap) that calls this old function that is not flexible enough.
    The main drawback is that it breaks into debugger no questions asked. The
    newer function is more sophisticated (it logs, skips known stops, etc.). 
    Since verifier.dll can be refreshed on an XP client system through the
    verifier package but ntdll.dll remains the one shipped with XP client
    we need this patching solution. 
    
    The patching works by writing an unconditional jump at the start of
    RtlApplicationVerifieStop to the better function VerifierStopMessage.
    
Parameters:

    None.
    
Return value:

    STATUS_SUCCESS or various failure codes.

--*/
{
#if defined(_X86_)

    PVOID TargetAddress;
    PVOID ThunkAddress;
    PVOID SourceAddress;
    PVOID ProtectAddress;
    BYTE JumpCode[5];
    LONG_PTR JumpAddress;
    NTSTATUS Status;
    ULONG OldProtection;
    SIZE_T PageSize;
    SIZE_T ProtectSize;

    //
    // Sanity check. The function should be called only for XP client.
    //

    if (AVrfpBuildNumber != WINXP_BUILD_NUMBER) {

        ASSERT (AVrfpBuildNumber == WINXP_BUILD_NUMBER);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Prepare the code to be patched. The code layout is explained below.
    //
    // RtlApplicationVerifierStop points to 0xFF 0x25 THUNKADDRESS
    // THUNKADDRESS points NTDLL_ADDRESS
    //


    ThunkAddress = (PVOID)READ_POINTER(RtlApplicationVerifierStop, 2); // FF 25 ADDRESS
    SourceAddress = (PVOID)READ_POINTER(ThunkAddress, 0); // ADDRESS

    TargetAddress = VerifierStopMessage;
    JumpAddress = (LONG_PTR)TargetAddress - (LONG_PTR)SourceAddress - sizeof JumpCode;

    JumpCode[0] = 0xE9; // unconditional jump X86 opcode
    *((LONG_PTR *)(JumpCode + 1)) = JumpAddress;

    PageSize = (SIZE_T)(AVrfpSysBasicInfo.PageSize);

    if (PageSize == 0) {

        ASSERT (PageSize != 0 && "AVrfpSysBasicInfo not initialized");
        PageSize = 0x1000;
    }

    //
    // Make R/W the start of the ntdll function to be patched.
    //

    ProtectAddress = SourceAddress;
    ProtectSize = PageSize;

    Status = NtProtectVirtualMemory (NtCurrentProcess(),
                                     &ProtectAddress,
                                     &ProtectSize, 
                                     PAGE_READWRITE,
                                     &OldProtection);

    if (! NT_SUCCESS(Status)) {

        DbgPrint ("AVRF: failed to make R/W old verifier stop function @ %p (%X) \n",
                  SourceAddress, 
                  Status);

        return Status;
    }

    //
    // Write patch code over old function.
    //

    RtlCopyMemory (SourceAddress, JumpCode, sizeof JumpCode);

    //
    // Change the protection back. 
    //

    Status = NtProtectVirtualMemory (NtCurrentProcess(),
                                     &ProtectAddress,
                                     &ProtectSize, 
                                     OldProtection,
                                     &OldProtection);

    if (! NT_SUCCESS(Status)) {

        DbgPrint ("AVRF: failed to revert protection of old verifier stop function @ %p (%X) \n",
                  SourceAddress, 
                  Status);

        //
        // At this point we managed to patch the code so we will not fail the function
        // since this will actually fail process startup. 
        //

        Status = STATUS_SUCCESS;
    }

    return Status;

#else

    //
    // Just x86 for now. For other architectures the operation will be considered
    // successful. The side-effect of not patching is that some verification code
    // from ntdll will cause debugger breaks. So basically the verified process 
    // needs to be run under debugger for meaningful results.
    //
    // The only other architecture shipped for XP client is IA64 so eventually we
    // will need to write code for that too. 
    //

    return STATUS_SUCCESS;

#endif // #if defined(_X86_)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\vspace.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

    vspace.h

Abstract:

    Hooks for virtual space APIs and virtual space tracker.

Author:

    Silviu Calinoiu (SilviuC) 1-Mar-2001

Revision History:

--*/

#ifndef _VSPACE_H_
#define _VSPACE_H_

#include "public.h"

NTSTATUS
AVrfpVsTrackInitialize (
    VOID
    );
          
NTSTATUS
AVrfpVsTrackDeleteRegionContainingAddress (
    PVOID Address
    );

#endif // #ifndef _VSPACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\vrfsdk.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    vrfsdk.c

Abstract:

    This module implements verifier SDK exports that other verifiers
    can use.

Author:

    Silviu Calinoiu (SilviuC) 13-Feb-2002

Revision History:

--*/

#include "pch.h"

#include "verifier.h"
#include "support.h"

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Run-time settings
/////////////////////////////////////////////////////////////////////


NTSTATUS
VerifierSetRuntimeFlags (
    IN ULONG VerifierFlags
    )
/*++

Routine Description:

    This routine enables at runtime application verifier flags.
    Note that not all flags can be set or reset after process initialization.

Arguments:

    VerifierFlags - verifier flags to be set. This is a set of RTL_VRF_FLG_XXX bits.
    
Return Value:

    STATUS_SUCCESS if all flags requested have been enabled.
    
    STATUS_INVALID_PARAMETER if a flag was not set according to the mask or 
    if application verifier is not enabled for the process.

--*/
{
    NTSTATUS Status;

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {

        if ((VerifierFlags & RTL_VRF_FLG_RPC_CHECKS)) {
            AVrfpProvider.VerifierFlags |= RTL_VRF_FLG_RPC_CHECKS;
        }
        else {
            AVrfpProvider.VerifierFlags &= ~RTL_VRF_FLG_RPC_CHECKS;
        }

        Status = STATUS_SUCCESS;
    }
    else {

        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}


NTSTATUS
VerifierQueryRuntimeFlags (
    OUT PLOGICAL VerifierEnabled,
    OUT PULONG VerifierFlags
    )
/*++

Routine Description:

    This routine queries at runtime application verifier flags.

Arguments:

    VerifierEnabled - variable to pass true or false if verifier is enabled.

    VerifierFlags - variable to pass verifier flags. This is a set of RTL_VRF_FLG_XXX bits.
    
Return Value:

    STATUS_SUCCESS if the flags were successfully written.
    
    STATUS_INVALID_PARAMETER or exception code if the flags could not be
    written.

--*/
{
    NTSTATUS Status;

    try {
        
        if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {

            if (VerifierEnabled != NULL && VerifierFlags != NULL) {

                *VerifierEnabled = TRUE;
                *VerifierFlags = AVrfpProvider.VerifierFlags;
                
                Status = STATUS_SUCCESS;
            }
            else {

                Status = STATUS_INVALID_PARAMETER;
            }
        }
        else {

            if (VerifierEnabled != NULL && VerifierFlags != NULL) {

                *VerifierEnabled = FALSE;
                *VerifierFlags = 0;
                
                Status = STATUS_SUCCESS;
            }
            else {

                Status = STATUS_INVALID_PARAMETER;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        Status = _exception_code();
    }

    return Status;
}

/////////////////////////////////////////////////////////////////////
//////////////////////////////////////// RPC read-only page heap APIs
/////////////////////////////////////////////////////////////////////

PVOID
VerifierCreateRpcPageHeap (
    IN ULONG  Flags,
    IN PVOID  HeapBase    OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize  OPTIONAL,
    IN PVOID  Lock        OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Parameters);

    //
    // If application verifier is not enabled or RPC verifier is not enabled
    // the function will fail. This APIs are exclusively for RPC verifier.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return NULL;
    } 

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RPC_CHECKS) == 0) {
        return NULL;
    }

    //
    // Now call the page heap create API.
    //

    return AVrfpRtlpDebugPageHeapCreate (Flags,
                                         HeapBase,
                                         ReserveSize,
                                         CommitSize,
                                         Lock,
                                         (PVOID)-2);
}


PVOID
VerifierDestroyRpcPageHeap (
    IN PVOID HeapHandle
    )
{
    //
    // If application verifier is not enabled or RPC verifier is not enabled
    // the function will fail. This APIs are exclusively for RPC verifier.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return NULL;
    } 

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_RPC_CHECKS) == 0) {
        return NULL;
    }

    //
    // Now call the page heap destroy API.
    //

    return AVrfpRtlpDebugPageHeapDestroy (HeapHandle);
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// DLL related information
/////////////////////////////////////////////////////////////////////

LOGICAL
VerifierIsDllEntryActive (
    OUT PVOID * Reserved
    )
{
    PAVRF_TLS_STRUCT TlsStruct;

    UNREFERENCED_PARAMETER (Reserved);

    //
    // If application verifier is not enabled the function will return
    // false.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return FALSE;
    } 

    TlsStruct = AVrfpGetVerifierTlsValue();

    if (TlsStruct != NULL && 
        (TlsStruct->Flags & VRFP_THREAD_FLAGS_LOADER_LOCK_OWNER)) {

        return TRUE;
    }
    else {

        return FALSE;
    }
}


LOGICAL
VerifierIsCurrentThreadHoldingLocks (
    VOID
    )
{
    PAVRF_TLS_STRUCT TlsStruct;

    //
    // If application verifier is not enabled the function will return
    // false.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return FALSE;
    } 

    TlsStruct = AVrfpGetVerifierTlsValue();

    if (TlsStruct != NULL && 
        TlsStruct->CountOfOwnedCriticalSections > 0) {

        return TRUE;
    }
    else {

        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// Free memory callbacks
/////////////////////////////////////////////////////////////////////


NTSTATUS
VerifierAddFreeMemoryCallback (
    VERIFIER_FREE_MEMORY_CALLBACK Callback
    )
{
    NTSTATUS Status;
    
    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {

        Status = STATUS_INVALID_PARAMETER;
    }
    else {

        Status = AVrfpAddFreeMemoryCallback (Callback);
    }

    return Status;
}


NTSTATUS
VerifierDeleteFreeMemoryCallback (
    VERIFIER_FREE_MEMORY_CALLBACK Callback
    )
{
    NTSTATUS Status;
    
    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {

        Status = STATUS_INVALID_PARAMETER;
    }
    else {

        Status = AVrfpDeleteFreeMemoryCallback (Callback);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifiersym\makefile.inc ===
$(O)\verifier.c : syminfo.c
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifiersym\syminfo.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    syminfo.c

--*/


#include "ntos.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <heap.h>
#include <windows.h>
#include "verifier\public.h"
                    
#define DECLARE_TYPE(Name) Name _DECL_##Name

//
// verifier.dll types needed by verifier extensions.
//

DECLARE_TYPE (CRITICAL_SECTION_SPLAY_NODE);
DECLARE_TYPE (RTL_SPLAY_LINKS);
DECLARE_TYPE (AVRF_EXCEPTION_LOG_ENTRY);
DECLARE_TYPE (AVRF_DEADLOCK_GLOBALS);
DECLARE_TYPE (AVRF_DEADLOCK_RESOURCE);
DECLARE_TYPE (AVRF_DEADLOCK_NODE);
DECLARE_TYPE (AVRF_DEADLOCK_THREAD);
DECLARE_TYPE (AVRF_THREAD_ENTRY);
DECLARE_TYPE (AVRF_TRACKER);
DECLARE_TYPE (AVRF_TRACKER_ENTRY);


//
// Make it build
//

int __cdecl main() { 
    return 0; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\csrtables.c ===
/*++

Copyright (c) 1998-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    csrtables.c

Abstract:

    This module implements functions that are used by the functions in tables.c
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/



//
//  Include Files.
//

#include "nls.h"
#include "ntwow64n.h"





////////////////////////////////////////////////////////////////////////////
//
//  CsrBasepNlsSetUserInfo
//
////////////////////////////////////////////////////////////////////////////

NTSTATUS CsrBasepNlsCreateSection(
    IN UINT uiType,
    IN LCID Locale,
    OUT PHANDLE phSection)
{

#if defined(BUILD_WOW6432)

    return ( NtWow64CsrBasepNlsCreateSection( uiType,
                                              Locale,
                                              phSection ));

#else

    BASE_API_MSG m;
    PBASE_NLS_CREATE_SECTION_MSG a = &m.u.NlsCreateSection;

    a->Locale = Locale;
    a->uiType = uiType;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                             BasepNlsCreateSection),
                         sizeof(*a) );

    //
    //  Save the handle to the new section.
    //
    *phSection = a->hNewSection;

    return (m.ReturnValue);

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\ansi.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    ansi.c

Abstract:

    This file contains the ANSI versions of the NLS API functions.

    APIs found in this file:
      CompareStringA
      LCMapStringA
      GetLocaleInfoA
      SetLocaleInfoA
      GetCalendarInfoA
      SetCalendarInfoA
      GetTimeFormatA
      GetDateFormatA
      GetNumberFormatA
      GetCurrencyFormatA
      EnumCalendarInfoA
      EnumCalendarInfoExA
      EnumTimeFormatsA
      EnumDateFormatsA
      EnumDateFormatsExA
      GetStringTypeExA
      GetStringTypeA
      FoldStringA
      EnumSystemLanguageGroupsA
      EnumLanguageGroupLocalesA
      EnumUILanguagesA
      EnumSystemLocalesA
      EnumSystemCodePagesA
      GetCPInfoExA
      GetGeoInfoA


Revision History:

    11-10-93    JulieB    Created.
    07-03-00    lguindon  Began GEO API port

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"



//
//  Forward Declarations.
//

PCP_HASH
NlsGetACPFromLocale(
    LCID Locale,
    DWORD dwFlags);

BOOL
NlsAnsiToUnicode(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPCSTR pAnsiBuffer,
    int AnsiLength,
    LPWSTR *ppUnicodeBuffer,
    int *pUnicodeLength);

int
NlsUnicodeToAnsi(
    PCP_HASH pHashN,
    LPCWSTR pUnicodeBuffer,
    int UnicodeLength,
    LPSTR pAnsiBuffer,
    int AnsiLength);

BOOL
NlsEnumUnicodeToAnsi(
    PCP_HASH pHashN,
    LPCWSTR pUnicodeBuffer,
    LPSTR *ppAnsiBuffer);





//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  CompareStringA
//
//  Compares two wide character strings of the same locale according to the
//  supplied locale handle.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI CompareStringA(
    LCID Locale,
    DWORD dwCmpFlags,
    LPCSTR lpString1,
    int cchCount1,
    LPCSTR lpString2,
    int cchCount2)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    WCHAR pSTmp1[MAX_STRING_LEN]; // tmp Unicode buffer (string 1)
    WCHAR pSTmp2[MAX_STRING_LEN]; // tmp Unicode buffer (string 2)
    LPWSTR pUnicode1;             // ptr to unicode string 1
    LPWSTR pUnicode2;             // ptr to unicode string 2
    int UnicodeLength1;           // length of Unicode string 1
    int UnicodeLength2;           // length of Unicode string 2
    int ResultLen;                // result length
    BOOL fUseNegCounts = (cchCount1 < 0 && cchCount2 < 0);    // flag to use negative counts


    //
    //  Invalid Parameter Check:
    //    - Get the code page hash node for the given locale.
    //    - either string is null
    //
    pHashN = NlsGetACPFromLocale(Locale, dwCmpFlags);
    if ((pHashN == NULL) ||
        (lpString1 == NULL) || (lpString2 == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //    - invalid flags
    //
    if (dwCmpFlags & CS_INVALID_FLAG)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  Convert Ansi string 1 to Unicode.
    //
    pUnicode1 = pSTmp1;
    if (!NlsAnsiToUnicode( pHashN,
                           0,
                           lpString1,
                           cchCount1,
                           &pUnicode1,
                           &UnicodeLength1 ))
    {
        return (0);
    }

    //
    //  Convert Ansi string 2 to Unicode.
    //
    pUnicode2 = pSTmp2;
    if (!NlsAnsiToUnicode( pHashN,
                           0,
                           lpString2,
                           cchCount2,
                           &pUnicode2,
                           &UnicodeLength2 ))
    {
        NLS_FREE_TMP_BUFFER(pUnicode1, pSTmp1);
        return (0);
    }

    //
    //  Call the W version of the API.
    //
    ResultLen = CompareStringW( Locale,
                                dwCmpFlags,
                                pUnicode1,
                                (fUseNegCounts) ? -1 : UnicodeLength1,
                                pUnicode2,
                                (fUseNegCounts) ? -1 : UnicodeLength2);

    //
    //  Free the allocated source buffers (if they were allocated).
    //
    NLS_FREE_TMP_BUFFER(pUnicode1, pSTmp1);
    NLS_FREE_TMP_BUFFER(pUnicode2, pSTmp2);

    //
    //  Return the result of the call to CompareStringW.
    //
    return (ResultLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  LCMapStringA
//
//  Maps one wide character string to another performing the specified
//  translation.  This mapping routine only takes flags that are locale
//  dependent.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI LCMapStringA(
    LCID Locale,
    DWORD dwMapFlags,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    LPWSTR pUnicode;              // ptr to unicode string
    int UnicodeLength;            // length of Unicode string
    WCHAR pSTmp[MAX_STRING_LEN];  // tmp Unicode buffer (source)
    WCHAR pDTmp[MAX_STRING_LEN];  // tmp Unicode buffer (destination)
    LPWSTR pBuf;                  // ptr to destination buffer
    int ResultLen;                // result length


    //
    //  Get the code page hash node for the given locale.
    //
    pHashN = NlsGetACPFromLocale(Locale, dwMapFlags);

    //
    //  Invalid Parameter Check:
    //     - valid code page
    //     - destination buffer size is negative
    //     - length of dest string is NOT zero AND dest string is NULL
    //     - same buffer - src = destination
    //              if not UPPER or LOWER or
    //              UPPER or LOWER used with Japanese flags
    //
    if ((pHashN == NULL) ||
        (cchDest < 0) ||
        ((cchDest != 0) && (lpDestStr == NULL)) ||
        ((lpSrcStr == lpDestStr) &&
         ((!(dwMapFlags & (LCMAP_UPPERCASE | LCMAP_LOWERCASE))) ||
          (dwMapFlags & (LCMAP_HIRAGANA | LCMAP_KATAKANA |
                         LCMAP_HALFWIDTH | LCMAP_FULLWIDTH)))))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Convert Ansi string to Unicode.
    //
    pUnicode = pSTmp;
    if (!NlsAnsiToUnicode( pHashN,
                           0,
                           lpSrcStr,
                           cchSrc,
                           &pUnicode,
                           &UnicodeLength ))
    {
        return (0);
    }

    //
    //  Special case the sortkey flag, since the Unicode buffer does
    //  NOT need to be converted back to Ansi.
    //
    if (dwMapFlags & LCMAP_SORTKEY)
    {
        //
        //  Call the W version of the API.
        //
        ResultLen = LCMapStringW( Locale,
                                  dwMapFlags,
                                  pUnicode,
                                  UnicodeLength,
                                  (LPWSTR)lpDestStr,
                                  cchDest );

        //
        //  Free the allocated source buffer (if one was allocated).
        //
        NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);

        //
        //  Return the result of LCMapStringW.
        //
        return (ResultLen);
    }

    //
    //  Call the W version of the API.
    //
    pBuf = pDTmp;
    ResultLen = MAX_STRING_LEN;
    while (1)
    {
        ResultLen = LCMapStringW( Locale,
                                  dwMapFlags,
                                  pUnicode,
                                  UnicodeLength,
                                  pBuf,
                                  ResultLen );

        //
        //  Make sure the static buffer was large enough.
        //
        if ((ResultLen != 0) || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        {
            break;
        }

        //
        //  Get the size of the buffer needed for the mapping.
        //
        if (ResultLen = LCMapStringW( Locale,
                                      dwMapFlags,
                                      pUnicode,
                                      UnicodeLength,
                                      NULL,
                                      0 ))
        {
            //
            //  Allocate a buffer of the appropriate size.
            //
            if ((pBuf = (LPWSTR)NLS_ALLOC_MEM(ResultLen * sizeof(WCHAR))) == NULL)
            {
                NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);
                SetLastError(ERROR_OUTOFMEMORY);
                return (0);
            }
        }
    }

    //
    //  Free the allocated source buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);

    //
    //  Convert the destination Unicode buffer to the given Ansi buffer.
    //
    if (ResultLen > 0)
    {
        ResultLen = NlsUnicodeToAnsi( pHashN,
                                      pBuf,
                                      ResultLen,
                                      lpDestStr,
                                      cchDest );
    }

    //
    //  Free the allocated destination buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pBuf, pDTmp);

    //
    //  Return the result of the call to LCMapStringW.
    //
    return (ResultLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLocaleInfoA
//
//  Returns one of the various pieces of information about a particular
//  locale by querying the configuration registry.  This call also indicates
//  how much memory is necessary to contain the desired information.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetLocaleInfoA(
    LCID Locale,
    LCTYPE LCType,
    LPSTR lpLCData,
    int cchData)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    WCHAR pDTmp[MAX_STRING_LEN];  // tmp Unicode buffer (destination)
    LPWSTR pBuf;                  // ptr to destination buffer
    int ResultLen;                // result length


    //
    //  Invalid Parameter Check:
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //
    if ((cchData < 0) ||
        (lpLCData == NULL) && (cchData != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Call the W version of the API.
    //
    pBuf = pDTmp;
    ResultLen = MAX_STRING_LEN;
    while (1)
    {
        ResultLen = GetLocaleInfoW( Locale,
                                    LCType,
                                    pBuf,
                                    ResultLen );

        //
        //  Make sure the static buffer was large enough.
        //
        if ((ResultLen != 0) || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        {
            break;
        }

        //
        //  Get the size of the buffer needed for the mapping.
        //
        if (ResultLen = GetLocaleInfoW( Locale,
                                        LCType,
                                        NULL,
                                        0 ))
        {
            //
            //  Allocate a buffer of the appropriate size.
            //
            if ((pBuf = (LPWSTR)NLS_ALLOC_MEM(ResultLen * sizeof(WCHAR))) == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return (0);
            }
        }
    }

    //
    //  Convert the destination Unicode buffer to the given Ansi buffer.
    //
    if (ResultLen > 0)
    {
        if ((LCType & LOCALE_RETURN_NUMBER) ||
            (NLS_GET_LCTYPE_VALUE(LCType) == LOCALE_FONTSIGNATURE))
        {
            //
            //  For the font signature and number value, the result length
            //  will actually be twice the amount of the wide char version.
            //
            ResultLen *= 2;

            //
            //  Make sure we can use the buffer.
            //
            if (cchData)
            {
                //
                //  Make sure the buffer is large enough.
                //
                if (cchData < ResultLen)
                {
                    //
                    //  The buffer is too small.
                    //
                    NLS_FREE_TMP_BUFFER(pBuf, pDTmp);
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }

                //
                //  Convert the font signature or number value to its byte
                //  form.  Since it's already byte reversed, just do a move
                //  memory.
                //
                RtlMoveMemory(lpLCData, pBuf, ResultLen);
            }
        }
        else
        {
            //
            // If this is LCTYPE == LOCALE_SLANGUAGE, then use the
            // CP_ACP of the system. This is what Win9x has done,
            // and we need to be compatible with this.
            //
            if (NLS_GET_LCTYPE_VALUE(LCType) == LOCALE_SLANGUAGE)
            {
                LCType |= LOCALE_USE_CP_ACP;
            }

            //
            //  Get the code page hash node for the given locale.
            //
            pHashN = NlsGetACPFromLocale(Locale, LCType);
            if (pHashN == NULL)
            {
                ResultLen = 0;
            }
            else
            {
                //
                //  Convert to Ansi.
                //
                ResultLen = NlsUnicodeToAnsi( pHashN,
                                              pBuf,
                                              ResultLen,
                                              lpLCData,
                                              cchData );
            }
        }
    }

    //
    //  Free the allocated destination buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pBuf, pDTmp);

    //
    //  Return the result of the call to GetLocaleInfoW.
    //
    return (ResultLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetLocaleInfoA
//
//  Sets one of the various pieces of information about a particular
//  locale by making an entry in the user's portion of the configuration
//  registry.  This will only affect the user override portion of the locale
//  settings.  The system defaults will never be reset.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI SetLocaleInfoA(
    LCID Locale,
    LCTYPE LCType,
    LPCSTR lpLCData)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    LPWSTR pUnicode;              // ptr to unicode string
    int UnicodeLength;            // length of Unicode string
    WCHAR pSTmp[MAX_STRING_LEN];  // tmp Unicode buffer (source)
    BOOL Result;                  // result


    //
    //  Get the code page hash node for the given locale.
    //
    pHashN = NlsGetACPFromLocale(Locale, LCType);
    if (pHashN == NULL)
    {
        return (0);
    }

    //
    //  Convert Ansi string to Unicode.
    //
    pUnicode = pSTmp;
    if (!NlsAnsiToUnicode( pHashN,
                           0,
                           lpLCData,
                           -1,
                           &pUnicode,
                           &UnicodeLength ))
    {
        return (FALSE);
    }

    //
    //  Call the W version of the API.
    //
    Result = SetLocaleInfoW( Locale,
                             LCType,
                             pUnicode );

    //
    //  Free the allocated source buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);

    //
    //  Return the result of the call to SetLocaleInfoW.
    //
    return (Result);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCalendarInfoA
//
//  Returns one of the various pieces of information about a particular
//  calendar by querying the configuration registry.  This call also indicates
//  how much memory is necessary to contain the desired information.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetCalendarInfoA(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPSTR lpCalData,
    int cchData,
    LPDWORD lpValue)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    WCHAR pDTmp[MAX_STRING_LEN];  // tmp Unicode buffer (destination)
    LPWSTR pBuf;                  // ptr to destination buffer
    int ResultLen;                // result length


    //
    //  Invalid Parameter Check:
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //
    if ((cchData < 0) ||
        ((lpCalData == NULL) && (cchData != 0)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Need to check the parameters based on the CAL_RETURN_NUMBER
    //  CalType.
    //
    if (CalType & CAL_RETURN_NUMBER)
    {
        if ((lpCalData != NULL) || (cchData != 0) || (lpValue == NULL))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }
    else
    {
        if ((lpValue != NULL) ||
            (cchData < 0) ||
            ((lpCalData == NULL) && (cchData != 0)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    //
    //  Call the W version of the API.
    //
    pBuf = pDTmp;
    ResultLen = MAX_STRING_LEN;
    while (1)
    {
        ResultLen = GetCalendarInfoW( Locale,
                                      Calendar,
                                      CalType,
                                      lpCalData ? pBuf : NULL,
                                      lpCalData ? ResultLen : 0,
                                      lpValue );

        //
        //  Make sure the static buffer was large enough.
        //
        if ((ResultLen != 0) ||
            (lpValue != NULL) ||
            (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        {
            break;
        }

        //
        //  Get the size of the buffer needed for the mapping.
        //
        if (ResultLen = GetCalendarInfoW( Locale,
                                          Calendar,
                                          CalType,
                                          NULL,
                                          0,
                                          NULL ))
        {
            //
            //  Allocate a buffer of the appropriate size.
            //
            if ((pBuf = (LPWSTR)NLS_ALLOC_MEM(ResultLen * sizeof(WCHAR))) == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return (0);
            }
        }
    }

    //
    //  Convert the destination Unicode buffer to the given Ansi buffer.
    //
    if (ResultLen > 0)
    {
        if (CalType & CAL_RETURN_NUMBER)
        {
            //
            //  For the number value, the result length will actually be
            //  twice the amount of the wide char version.
            //
            ResultLen *= 2;

            //
            //  There is nothing else to do in this case, since the value
            //  has already been stored in lpValue.
            //
        }
        else
        {
            //
            //  Get the code page hash node for the given locale.
            //
            pHashN = NlsGetACPFromLocale(Locale, CalType);
            if (pHashN == NULL)
            {
                ResultLen = 0;
            }
            else
            {
                //
                //  Convert to Ansi.
                //
                ResultLen = NlsUnicodeToAnsi( pHashN,
                                              pBuf,
                                              ResultLen,
                                              lpCalData,
                                              cchData );
            }
        }
    }

    //
    //  Free the allocated destination buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pBuf, pDTmp);

    //
    //  Return the result of the call to GetCalendarInfoW.
    //
    return (ResultLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetCalendarInfoA
//
//  Sets one of the various pieces of information about a particular
//  calendar by making an entry in the user's portion of the configuration
//  registry.  This will only affect the user override portion of the
//  calendar settings.  The system defaults will never be reset.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI SetCalendarInfoA(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPCSTR lpCalData)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    LPWSTR pUnicode;              // ptr to unicode string
    int UnicodeLength;            // length of Unicode string
    WCHAR pSTmp[MAX_STRING_LEN];  // tmp Unicode buffer (source)
    BOOL Result;                  // result


    //
    //  Get the code page hash node for the given locale.
    //
    pHashN = NlsGetACPFromLocale(Locale, CalType);
    if (pHashN == NULL)
    {
        return (0);
    }

    //
    //  Convert Ansi string to Unicode.
    //
    pUnicode = pSTmp;
    if (!NlsAnsiToUnicode( pHashN,
                           0,
                           lpCalData,
                           -1,
                           &pUnicode,
                           &UnicodeLength ))
    {
        return (FALSE);
    }

    //
    //  Call the W version of the API.
    //
    Result = SetCalendarInfoW( Locale,
                               Calendar,
                               CalType,
                               pUnicode );

    //
    //  Free the allocated source buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);

    //
    //  Return the result of the call to SetCalendarInfoW.
    //
    return (Result);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTimeFormatA
//
//  Returns a properly formatted time string for the given locale.  It uses
//  either the system time or the specified time.  This call also indicates
//  how much memory is necessary to contain the desired information.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetTimeFormatA(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCSTR lpFormat,
    LPSTR lpTimeStr,
    int cchTime)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    LPWSTR pUnicode;              // ptr to unicode string
    int UnicodeLength;            // length of Unicode string
    WCHAR pSTmp[MAX_STRING_LEN];  // tmp Unicode buffer (source)
    WCHAR pDTmp[MAX_STRING_LEN];  // tmp Unicode buffer (destination)
    LPWSTR pBuf;                  // ptr to destination buffer
    int ResultLen;                // result length


    //
    //  Get the code page hash node for the given locale.
    //
    pHashN = NlsGetACPFromLocale(Locale, dwFlags);

    //
    //  Invalid Parameter Check:
    //    - valid code page
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //
    if ((pHashN == NULL) ||
        (cchTime < 0) ||
        ((lpTimeStr == NULL) && (cchTime != 0)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Convert Ansi string to Unicode.
    //
    pUnicode = pSTmp;
    if (!NlsAnsiToUnicode( pHashN,
                           0,
                           lpFormat,
                           -1,
                           &pUnicode,
                           &UnicodeLength ))
    {
        return (0);
    }

    //
    //  Call the W version of the API.
    //
    pBuf = pDTmp;
    ResultLen = MAX_STRING_LEN;
    while (1)
    {
        ResultLen = GetTimeFormatW( Locale,
                                    dwFlags,
                                    lpTime,
                                    pUnicode,
                                    pBuf,
                                    ResultLen );

        //
        //  Make sure the static buffer was large enough.
        //
        if ((ResultLen != 0) || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        {
            break;
        }

        //
        //  Get the size of the buffer needed for the mapping.
        //
        if (ResultLen = GetTimeFormatW( Locale,
                                        dwFlags,
                                        lpTime,
                                        pUnicode,
                                        NULL,
                                        0 ))
        {
            //
            //  Allocate a buffer of the appropriate size.
            //
            if ((pBuf = (LPWSTR)NLS_ALLOC_MEM(ResultLen * sizeof(WCHAR))) == NULL)
            {
                NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);
                SetLastError(ERROR_OUTOFMEMORY);
                return (0);
            }
        }
    }

    //
    //  Free the allocated source buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);

    //
    //  Convert the destination Unicode buffer to the given Ansi buffer.
    //
    if (ResultLen > 0)
    {
        ResultLen = NlsUnicodeToAnsi( pHashN,
                                      pBuf,
                                      ResultLen,
                                      lpTimeStr,
                                      cchTime );
    }

    //
    //  Free the allocated destination buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pBuf, pDTmp);

    //
    //  Return the result of the call to GetTimeFormatW.
    //
    return (ResultLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDateFormatA
//
//  Returns a properly formatted date string for the given locale.  It uses
//  either the system date or the specified date.  The user may specify
//  the short date format, the long date format, or the year/month format.
//  This call also indicates how much memory is necessary to contain the
//  desired information.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetDateFormatA(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCSTR lpFormat,
    LPSTR lpDateStr,
    int cchDate)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    LPWSTR pUnicode;              // ptr to unicode string
    int UnicodeLength;            // length of Unicode string
    WCHAR pSTmp[MAX_STRING_LEN];  // tmp Unicode buffer (source)
    WCHAR pDTmp[MAX_STRING_LEN];  // tmp Unicode buffer (destination)
    LPWSTR pBuf;                  // ptr to destination buffer
    int ResultLen;                // result length


    //
    //  Get the code page hash node for the given locale.
    //
    pHashN = NlsGetACPFromLocale(Locale, dwFlags);

    //
    //  Invalid Parameter Check:
    //    - valid code page
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //
    if ((pHashN == NULL) ||
        (cchDate < 0) ||
        ((lpDateStr == NULL) && (cchDate != 0)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //    - flags other than valid ones
    //    - more than one of either ltr reading or rtl reading
    //    - using LTR or RTL flag and not using cp 1255 or 1256
    //
    if ((dwFlags & GDF_INVALID_FLAG) ||
        (MORE_THAN_ONE(dwFlags, GDF_SINGLE_FLAG)) ||
        ((dwFlags & (DATE_LTRREADING | DATE_RTLREADING)) &&
         (pHashN->CodePage != 1255) && (pHashN->CodePage != 1256)))
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  Convert Ansi string to Unicode.
    //
    pUnicode = pSTmp;
    if (!NlsAnsiToUnicode( pHashN,
                           0,
                           lpFormat,
                           -1,
                           &pUnicode,
                           &UnicodeLength ))
    {
        return (0);
    }

    //
    //  Call the W version of the API.
    //
    pBuf = pDTmp;
    ResultLen = MAX_STRING_LEN;
    while (1)
    {
        ResultLen = GetDateFormatW( Locale,
                                    dwFlags,
                                    lpDate,
                                    pUnicode,
                                    pBuf,
                                    ResultLen );

        //
        //  Make sure the static buffer was large enough.
        //
        if ((ResultLen != 0) || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        {
            break;
        }

        //
        //  Get the size of the buffer needed for the mapping.
        //
        if (ResultLen = GetDateFormatW( Locale,
                                        dwFlags,
                                        lpDate,
                                        pUnicode,
                                        NULL,
                                        0 ))
        {
            //
            //  Allocate a buffer of the appropriate size.
            //
            if ((pBuf = (LPWSTR)NLS_ALLOC_MEM(ResultLen * sizeof(WCHAR))) == NULL)
            {
                NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);
                SetLastError(ERROR_OUTOFMEMORY);
                return (0);
            }
        }
    }

    //
    //  Free the allocated source buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);

    //
    //  Convert the destination Unicode buffer to the given Ansi buffer.
    //
    if (ResultLen > 0)
    {
        ResultLen = NlsUnicodeToAnsi( pHashN,
                                      pBuf,
                                      ResultLen,
                                      lpDateStr,
                                      cchDate );
    }

    //
    //  Free the allocated destination buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pBuf, pDTmp);

    //
    //  Return the result of the call to GetDateFormatW.
    //
    return (ResultLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetNumberFormatA
//
//  Returns a properly formatted number string for the given locale.
//  This call also indicates how much memory is necessary to contain
//  the desired information.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetNumberFormatA(
    LCID Locale,
    DWORD dwFlags,
    LPCSTR lpValue,
    CONST NUMBERFMTA *lpFormat,
    LPSTR lpNumberStr,
    int cchNumber)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    LPWSTR pValueU;               // ptr to unicode string
    int UnicodeLength;            // length of Unicode string
    WCHAR pSTmp[MAX_STRING_LEN];  // tmp Unicode buffer (source)
    WCHAR pDTmp[MAX_STRING_LEN];  // tmp Unicode buffer (destination)
    LPWSTR pBuf;                  // ptr to destination buffer
    int ResultLen;                // result length
    NUMBERFMTW FormatU;           // Unicode number format
    LPNUMBERFMTW pFormatU = NULL; // ptr to Unicode number format


    //
    //  Get the code page hash node for the given locale.
    //
    pHashN = NlsGetACPFromLocale(Locale, dwFlags);

    //
    //  Invalid Parameter Check:
    //    - valid code page
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //    - ptrs to string buffers same
    //
    if ((pHashN == NULL) ||
        (cchNumber < 0) ||
        ((lpNumberStr == NULL) && (cchNumber != 0)) ||
        (lpValue == lpNumberStr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Convert Ansi string to Unicode.
    //
    pValueU = pSTmp;
    if (!NlsAnsiToUnicode( pHashN,
                           0,
                           lpValue,
                           -1,
                           &pValueU,
                           &UnicodeLength ))
    {
        return (0);
    }

    //
    //  If the format structure exists, convert the strings
    //  in the structure.
    //
    if (lpFormat)
    {
        //
        //  Copy Ansi structure to Unicode structure.
        //
        FormatU = *(NUMBERFMTW *)lpFormat;
        FormatU.lpDecimalSep = NULL;
        FormatU.lpThousandSep = NULL;

        //
        //  Convert Ansi strings in structure to Unicode strings.
        //
        if (!NlsAnsiToUnicode( pHashN,
                               0,
                               lpFormat->lpDecimalSep,
                               -1,
                               &(FormatU.lpDecimalSep),
                               &UnicodeLength ) ||
            !NlsAnsiToUnicode( pHashN,
                               0,
                               lpFormat->lpThousandSep,
                               -1,
                               &(FormatU.lpThousandSep),
                               &UnicodeLength ))
        {
            NLS_FREE_TMP_BUFFER(pValueU, pSTmp);
            NLS_FREE_MEM(FormatU.lpDecimalSep);
            return (0);
        }

        pFormatU = &FormatU;
    }

    //
    //  Call the W version of the API.
    //
    pBuf = pDTmp;
    ResultLen = MAX_STRING_LEN;
    while (1)
    {
        ResultLen = GetNumberFormatW( Locale,
                                      dwFlags,
                                      pValueU,
                                      pFormatU,
                                      pBuf,
                                      ResultLen );

        //
        //  Make sure the static buffer was large enough.
        //
        if ((ResultLen != 0) || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        {
            break;
        }

        //
        //  Get the size of the buffer needed for the mapping.
        //
        if (ResultLen = GetNumberFormatW( Locale,
                                          dwFlags,
                                          pValueU,
                                          pFormatU,
                                          NULL,
                                          0 ))
        {
            //
            //  Allocate a buffer of the appropriate size.
            //
            if ((pBuf = (LPWSTR)NLS_ALLOC_MEM(ResultLen * sizeof(WCHAR))) == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                ResultLen = 0;
                break;
            }
        }
    }

    //
    //  Free the allocated source buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pValueU, pSTmp);
    if (lpFormat)
    {
        NLS_FREE_MEM(FormatU.lpDecimalSep);
        NLS_FREE_MEM(FormatU.lpThousandSep);
    }

    //
    //  Convert the destination Unicode buffer to the given Ansi buffer.
    //
    if (ResultLen > 0)
    {
        ResultLen = NlsUnicodeToAnsi( pHashN,
                                      pBuf,
                                      ResultLen,
                                      lpNumberStr,
                                      cchNumber );
    }

    //
    //  Free the allocated destination buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pBuf, pDTmp);

    //
    //  Return the result of the call to GetNumberFormatW.
    //
    return (ResultLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCurrencyFormatA
//
//  Returns a properly formatted currency string for the given locale.
//  This call also indicates how much memory is necessary to contain
//  the desired information.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetCurrencyFormatA(
    LCID Locale,
    DWORD dwFlags,
    LPCSTR lpValue,
    CONST CURRENCYFMTA *lpFormat,
    LPSTR lpCurrencyStr,
    int cchCurrency)
{
    PCP_HASH pHashN;                   // ptr to CP hash node
    LPWSTR pValueU;                    // ptr to unicode string
    int UnicodeLength;                 // length of Unicode string
    WCHAR pSTmp[MAX_STRING_LEN];       // tmp Unicode buffer (source)
    WCHAR pDTmp[MAX_STRING_LEN];       // tmp Unicode buffer (destination)
    LPWSTR pBuf;                       // ptr to destination buffer
    int ResultLen;                     // result length
    CURRENCYFMTW FormatU;              // Unicode currency format
    LPCURRENCYFMTW pFormatU = NULL;    // ptr to Unicode currency format


    //
    //  Get the code page hash node for the given locale.
    //
    pHashN = NlsGetACPFromLocale(Locale, dwFlags);

    //
    //  Invalid Parameter Check:
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //    - ptrs to string buffers same
    //
    if ((pHashN == NULL) ||
        (cchCurrency < 0) ||
        ((lpCurrencyStr == NULL) && (cchCurrency != 0)) ||
        (lpValue == lpCurrencyStr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Convert Ansi string to Unicode.
    //
    pValueU = pSTmp;
    if (!NlsAnsiToUnicode( pHashN,
                           0,
                           lpValue,
                           -1,
                           &pValueU,
                           &UnicodeLength ))
    {
        return (0);
    }

    //
    //  If the format structure exists, convert the strings
    //  in the structure.
    //
    if (lpFormat)
    {
        //
        //  Copy Ansi structure to Unicode structure.
        //
        FormatU = *(CURRENCYFMTW *)lpFormat;
        FormatU.lpDecimalSep = NULL;
        FormatU.lpThousandSep = NULL;
        FormatU.lpCurrencySymbol = NULL;

        //
        //  Convert Ansi strings in structure to Unicode strings.
        //
        if (!NlsAnsiToUnicode( pHashN,
                               0,
                               lpFormat->lpDecimalSep,
                               -1,
                               &(FormatU.lpDecimalSep),
                               &UnicodeLength ) ||
            !NlsAnsiToUnicode( pHashN,
                               0,
                               lpFormat->lpThousandSep,
                               -1,
                               &(FormatU.lpThousandSep),
                               &UnicodeLength ) ||
            !NlsAnsiToUnicode( pHashN,
                               0,
                               lpFormat->lpCurrencySymbol,
                               -1,
                               &(FormatU.lpCurrencySymbol),
                               &UnicodeLength ))
        {
            NLS_FREE_TMP_BUFFER(pValueU, pSTmp);
            NLS_FREE_MEM(FormatU.lpDecimalSep);
            NLS_FREE_MEM(FormatU.lpThousandSep);
            return (0);
        }

        pFormatU = &FormatU;
    }

    //
    //  Call the W version of the API.
    //
    pBuf = pDTmp;
    ResultLen = MAX_STRING_LEN;
    while (1)
    {
        ResultLen = GetCurrencyFormatW( Locale,
                                        dwFlags,
                                        pValueU,
                                        pFormatU,
                                        pBuf,
                                        ResultLen );

        //
        //  Make sure the static buffer was large enough.
        //
        if ((ResultLen != 0) || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        {
            break;
        }

        //
        //  Get the size of the buffer needed for the mapping.
        //
        if (ResultLen = GetCurrencyFormatW( Locale,
                                            dwFlags,
                                            pValueU,
                                            pFormatU,
                                            NULL,
                                            0 ))
        {
            //
            //  Allocate a buffer of the appropriate size.
            //
            if ((pBuf = (LPWSTR)NLS_ALLOC_MEM(ResultLen * sizeof(WCHAR))) == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                ResultLen = 0;
                break;
            }
        }
    }

    //
    //  Free the allocated source buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pValueU, pSTmp);
    if (lpFormat)
    {
        NLS_FREE_MEM(FormatU.lpDecimalSep);
        NLS_FREE_MEM(FormatU.lpThousandSep);
        NLS_FREE_MEM(FormatU.lpCurrencySymbol);
    }

    //
    //  Convert the destination Unicode buffer to the given Ansi buffer.
    //
    if (ResultLen > 0)
    {
        ResultLen = NlsUnicodeToAnsi( pHashN,
                                      pBuf,
                                      ResultLen,
                                      lpCurrencyStr,
                                      cchCurrency );
    }

    //
    //  Free the allocated destination buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pBuf, pDTmp);

    //
    //  Return the result of the call to GetCurrencyFormatW.
    //
    return (ResultLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumCalendarInfoA
//
//  Enumerates the specified calendar information that is available for the
//  specified locale, based on the CalType parameter.  It does so by
//  passing the pointer to the string buffer containing the calendar info
//  to an application-defined callback function.  It continues until the
//  last calendar info is found or the callback function returns FALSE.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumCalendarInfoA(
    CALINFO_ENUMPROCA lpCalInfoEnumProc,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType)
{
    return (Internal_EnumCalendarInfo( (NLS_ENUMPROC)lpCalInfoEnumProc,
                                        Locale,
                                        Calendar,
                                        CalType,
                                        FALSE,
                                        FALSE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumCalendarInfoExA
//
//  Enumerates the specified calendar information that is available for the
//  specified locale, based on the CalType parameter.  It does so by
//  passing the pointer to the string buffer containing the calendar info
//  and the calendar id to an application-defined callback function.  It
//  continues until the last calendar info is found or the callback function
//  returns FALSE.
//
//  10-14-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumCalendarInfoExA(
    CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType)
{
    return (Internal_EnumCalendarInfo( (NLS_ENUMPROC)lpCalInfoEnumProcEx,
                                        Locale,
                                        Calendar,
                                        CalType,
                                        FALSE,
                                        TRUE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumTimeFormatsA
//
//  Enumerates the time formats that are available for the
//  specified locale, based on the dwFlags parameter.  It does so by
//  passing the pointer to the string buffer containing the time format
//  to an application-defined callback function.  It continues until the
//  last time format is found or the callback function returns FALSE.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumTimeFormatsA(
    TIMEFMT_ENUMPROCA lpTimeFmtEnumProc,
    LCID Locale,
    DWORD dwFlags)
{
    return (Internal_EnumTimeFormats( (NLS_ENUMPROC)lpTimeFmtEnumProc,
                                       Locale,
                                       dwFlags,
                                       FALSE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumDateFormatsA
//
//  Enumerates the short date, long date, or year/month formats that are
//  available for the specified locale, based on the dwFlags parameter.
//  It does so by passing the pointer to the string buffer containing the
//  date format to an application-defined callback function.  It continues
//  until the last date format is found or the callback function returns
//  FALSE.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumDateFormatsA(
    DATEFMT_ENUMPROCA lpDateFmtEnumProc,
    LCID Locale,
    DWORD dwFlags)
{
    return (Internal_EnumDateFormats( (NLS_ENUMPROC)lpDateFmtEnumProc,
                                       Locale,
                                       dwFlags,
                                       FALSE,
                                       FALSE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumDateFormatsExA
//
//  Enumerates the short date, long date, or year/month formats that are
//  available for the specified locale, based on the dwFlags parameter.
//  It does so by passing the pointer to the string buffer containing the
//  date format and the calendar id to an application-defined callback
//  function.  It continues until the last date format is found or the
//  callback function returns FALSE.
//
//  10-14-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumDateFormatsExA(
    DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx,
    LCID Locale,
    DWORD dwFlags)
{
    return (Internal_EnumDateFormats( (NLS_ENUMPROC)lpDateFmtEnumProcEx,
                                       Locale,
                                       dwFlags,
                                       FALSE,
                                       TRUE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStringTypeExA
//
//  Returns character type information about a particular Ansi string.
//
//  01-18-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetStringTypeExA(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType)
{
    return (GetStringTypeA( Locale,
                            dwInfoType,
                            lpSrcStr,
                            cchSrc,
                            lpCharType));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStringTypeA
//
//  Returns character type information about a particular Ansi string.
//
//  NOTE:  The number of parameters is different from GetStringTypeW.
//         The 16-bit OLE product shipped this routine with the wrong
//         parameters (ported from Chicago) and now we must support it.
//
//         Use GetStringTypeEx to get the same set of parameters between
//         the A and W version.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetStringTypeA(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType)
{
    PCP_HASH pHashCP;             // ptr to CP hash node
    LPWSTR pUnicode;              // ptr to unicode string
    int UnicodeLength;            // length of Unicode string
    WCHAR pSTmp[MAX_STRING_LEN];  // tmp Unicode buffer (source)
    BOOL Result;                  // result


    //
    //  Get the code page hash node for the given locale.
    //  This will also return an error if the locale id is invalid,
    //  so there is no need to check the locale id separately.
    //
    pHashCP = NlsGetACPFromLocale(Locale, 0);

    //
    //  Invalid Parameter Check:
    //    - Validate LCID
    //    - valid code page
    //    - same buffer - src and destination
    //
    if ((pHashCP == NULL) ||
        (lpSrcStr == (LPSTR)lpCharType))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Convert Ansi string to Unicode.
    //
    pUnicode = pSTmp;
    if (!NlsAnsiToUnicode( pHashCP,
                           MB_INVALID_CHAR_CHECK,
                           lpSrcStr,
                           cchSrc,
                           &pUnicode,
                           &UnicodeLength ))
    {
        return (0);
    }

    //
    //  Call the W version of the API.
    //
    Result = GetStringTypeW( dwInfoType,
                             pUnicode,
                             UnicodeLength,
                             lpCharType );

    //
    //  Free the allocated source buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);

    //
    //  Return the result of the call to GetStringTypeW.
    //
    return (Result);
}


////////////////////////////////////////////////////////////////////////////
//
//  FoldStringA
//
//  Maps one wide character string to another performing the specified
//  translation.  This mapping routine only takes flags that are locale
//  independent.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI FoldStringA(
    DWORD dwMapFlags,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPWSTR pUnicode;              // ptr to unicode string
    int UnicodeLength;            // length of Unicode string
    WCHAR pSTmp[MAX_STRING_LEN];  // tmp Unicode buffer (source)
    WCHAR pDTmp[MAX_STRING_LEN];  // tmp Unicode buffer (destination)
    LPWSTR pBuf;                  // ptr to destination buffer
    int ResultLen;                // result length


    //
    //  Invalid Parameter Check:
    //     - dest buffer size is negative
    //     - length of dest string is NOT zero AND dest string is NULL
    //     - same buffer - src = destination
    //
    if ((cchDest < 0) ||
        ((cchDest != 0) && (lpDestStr == NULL)) ||
        (lpSrcStr == lpDestStr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }


    //
    //  Convert Ansi string to Unicode.
    //
    RtlZeroMemory(pSTmp, sizeof(pSTmp));
    pUnicode = pSTmp;
    if (!NlsAnsiToUnicode( gpACPHashN,
                           0,
                           lpSrcStr,
                           cchSrc,
                           &pUnicode,
                           &UnicodeLength ))
    {
        return (0);
    }

    //
    //  Call the W version of the API.
    //
    pBuf = pDTmp;
    ResultLen = MAX_STRING_LEN;
    while (1)
    {
        ResultLen = FoldStringW( dwMapFlags,
                                 pUnicode,
                                 UnicodeLength,
                                 pBuf,
                                 ResultLen );

        //
        //  Make sure the static buffer was large enough.
        //
        if ((ResultLen != 0) || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        {
            break;
        }

        //
        //  Get the size of the buffer needed for the mapping.
        //
        if (ResultLen = FoldStringW( dwMapFlags,
                                     pUnicode,
                                     UnicodeLength,
                                     NULL,
                                     0 ))
        {
            //
            //  Allocate a buffer of the appropriate size.
            //
            if ((pBuf = (LPWSTR)NLS_ALLOC_MEM(ResultLen * sizeof(WCHAR))) == NULL)
            {
                NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);
                SetLastError(ERROR_OUTOFMEMORY);
                return (0);
            }
        }
    }

    //
    //  Free the allocated source buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pUnicode, pSTmp);

    //
    //  Convert the destination Unicode buffer to the given Ansi buffer.
    //
    if (ResultLen > 0)
    {
        ResultLen = NlsUnicodeToAnsi( gpACPHashN,
                                      pBuf,
                                      ResultLen,
                                      lpDestStr,
                                      cchDest );
    }

    //
    //  Free the allocated destination buffer (if one was allocated).
    //
    NLS_FREE_TMP_BUFFER(pBuf, pDTmp);

    //
    //  Return the result of the call to FoldStringW.
    //
    return (ResultLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumSystemLanguageGroupsA
//
//  Enumerates the system language groups that are installed or supported,
//  based on the dwFlags parameter.  It does so by passing the pointer to
//  the string buffer containing the language group id to an
//  application-defined callback function.  It continues until the last
//  language group id is found or the callback function returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumSystemLanguageGroupsA(
    LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam)
{
    return (Internal_EnumSystemLanguageGroups(
                                       (NLS_ENUMPROC)lpLanguageGroupEnumProc,
                                       dwFlags,
                                       lParam,
                                       FALSE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumLanguageGroupLocalesA
//
//  Enumerates the locales in a given language group.  It does so by
//  passing the appropriate information to an application-defined
//  callback function.  It continues until the last locale in the language
//  group is found or the callback function returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumLanguageGroupLocalesA(
    LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc,
    LGRPID LanguageGroup,
    DWORD dwFlags,
    LONG_PTR lParam)
{
    return (Internal_EnumLanguageGroupLocales(
                                       (NLS_ENUMPROC)lpLangGroupLocaleEnumProc,
                                       LanguageGroup,
                                       dwFlags,
                                       lParam,
                                       FALSE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumUILanguagesA
//
//  Enumerates the system UI languages that are installed.  It does so by
//  passing the pointer to the string buffer containing the UI language id
//  to an application-defined callback function.  It continues until the
//  last UI language id is found or the callback function returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumUILanguagesA(
    UILANGUAGE_ENUMPROCA lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam)
{
    return (Internal_EnumUILanguages( (NLS_ENUMPROC)lpUILanguageEnumProc,
                                      dwFlags,
                                      lParam,
                                      FALSE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumSystemLocalesA
//
//  Enumerates the system locales that are installed or supported, based on
//  the dwFlags parameter.  It does so by passing the pointer to the string
//  buffer containing the locale id to an application-defined callback
//  function.  It continues until the last locale id is found or the
//  callback function returns FALSE.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumSystemLocalesA(
    LOCALE_ENUMPROCA lpLocaleEnumProc,
    DWORD dwFlags)
{
    return (Internal_EnumSystemLocales( (NLS_ENUMPROC)lpLocaleEnumProc,
                                         dwFlags,
                                         FALSE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumSystemCodePagesA
//
//  Enumerates the system code pages that are installed or supported, based on
//  the dwFlags parameter.  It does so by passing the pointer to the string
//  buffer containing the code page id to an application-defined callback
//  function.  It continues until the last code page is found or the
//  callback function returns FALSE.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumSystemCodePagesA(
    CODEPAGE_ENUMPROCA lpCodePageEnumProc,
    DWORD dwFlags)
{
    return (Internal_EnumSystemCodePages( (NLS_ENUMPROC)lpCodePageEnumProc,
                                          dwFlags,
                                          FALSE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCPInfoExA
//
//  Returns information about a given code page.
//
//  11-15-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetCPInfoExA(
    UINT CodePage,
    DWORD dwFlags,
    LPCPINFOEXA lpCPInfoEx)
{
    CPINFOEXW lpCPInfoExW;
    BOOL rc;


    //
    //  Invalid Parameter Check:
    //     - lpCPInfoEx is NULL
    //
    if (lpCPInfoEx == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Call the W version of the API.
    //
    rc = GetCPInfoExW(CodePage, dwFlags, &lpCPInfoExW);

    //
    //  Convert the code page name from Unicode to Ansi.
    //
    if (rc == TRUE)
    {
        if (!NlsUnicodeToAnsi( gpACPHashN,
                               lpCPInfoExW.CodePageName,
                               -1,
                               lpCPInfoEx->CodePageName,
                               MAX_PATH ))
        {
            return (FALSE);
        }
    }

    //
    //  Copy the rest of the information from the Unicode buffer to the
    //  Ansi buffer.
    //
    RtlMoveMemory( lpCPInfoEx,
                   &lpCPInfoExW,
                   FIELD_OFFSET(CPINFOEXW, CodePageName) );

    //
    //  Return the result.
    //
    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetGeoInfoA
//
//  Wrapper funtion of GetGeoInfoW for ANSI. This function return information
//  about a geographical region.
//
//  11-20-99    WeiWu     Created
//  07-03-00    lguindon  Began GEO API port
////////////////////////////////////////////////////////////////////////////

int WINAPI GetGeoInfoA(
    GEOID GeoId,
    DWORD GeoType,
    LPSTR lpGeoData,
    int cchData,
    LANGID LangId)
{
    int iRet = 0;

    //
    //  Create buffer initialized to zero.
    //
    WCHAR wszBuffer[MAX_REG_VAL_SIZE] = {0};

    //
    //  Sanity check.
    //
    if ((lpGeoData == NULL) && (cchData > 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (iRet);
    }

    //
    //  Call the unicode version.
    //
    iRet = GetGeoInfoW( GeoId,
                        GeoType,
                        wszBuffer,
                        sizeof(wszBuffer) / sizeof(WCHAR),
                        LangId );

    //
    //  Convert to ANSI if we get something.
    //
    if (iRet)
    {
        iRet = WideCharToMultiByte( CP_ACP,
                                    0,
                                    wszBuffer,
                                    iRet,
                                    lpGeoData,
                                    cchData,
                                    NULL,
                                    NULL );
    }

    return (iRet);
}





//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsGetACPFromLocale
//
//  Gets the CP hash node for the default ACP of the given locale.  If
//  either the locale or the code page are invalid, then NULL is returned.
//
//  01-19-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

PCP_HASH NlsGetACPFromLocale(
    LCID Locale,
    DWORD dwFlags)
{
    PLOC_HASH pHashN;                  // ptr to LOC hash node
    PCP_HASH pHashCP;                  // ptr to CP hash node
    UNICODE_STRING ObUnicodeStr;       // value string
    UINT CodePage;                     // code page value


    //
    //  See if the system ACP should be used.
    //
    if (dwFlags & (LOCALE_USE_CP_ACP | LOCALE_RETURN_NUMBER))
    {
        return (gpACPHashN);
    }

    //
    //  Get the locale hash node.
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if (pHashN == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (NULL);
    }

    //
    //  Get the ACP code page.  If it's equal to CP_ACP (0), then return
    //  the system ACP hash node.
    //
    CodePage = pHashN->pLocaleFixed->DefaultACP;
    if (CodePage == CP_ACP)
    {
        return (gpACPHashN);
    }

    //
    //  Get the CP hash node for the code page.
    //
    pHashCP = GetCPHashNode(CodePage);
    if (pHashCP == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    //
    //  Return the code page hash node.
    //
    return (pHashCP);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsAnsiToUnicode
//
//  Converts an Ansi string to a Unicode string.
//
//  NOTE:  The Unicode buffer is allocated if the routine succeeds, so the
//         caller will need to free the buffer when it is no longer needed.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL NlsAnsiToUnicode(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPCSTR pAnsiBuffer,
    int AnsiLength,
    LPWSTR *ppUnicodeBuffer,
    int *pUnicodeLength)
{
    LPWSTR pUnicode;              // ptr to Unicode buffer
    ULONG UnicodeLength;          // length of the Unicode string
    int ResultLength;             // result length of Unicode string


    //
    //  Make sure the pointer passed in is not null.
    //
    if (pAnsiBuffer == NULL)
    {
        *ppUnicodeBuffer = NULL;
        *pUnicodeLength = 0;
        return (TRUE);
    }

    //
    //  Make sure the Ansi length is set properly (in bytes).
    //
    if (AnsiLength < 0)
    {
        AnsiLength = strlen(pAnsiBuffer) + 1;
    }

    //
    //  See if the static buffer is big enough.
    //
    if ((*ppUnicodeBuffer == NULL) || (AnsiLength > (MAX_STRING_LEN - 1)))
    {
        //
        //  Get the size of the Unicode string, including the
        //  null terminator.
        //
        UnicodeLength = AnsiLength;

        //
        //  Allocate the Unicode buffer.
        //
        if ((pUnicode = (LPWSTR)NLS_ALLOC_MEM(
                            (UnicodeLength + 1) * sizeof(WCHAR) )) == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return (FALSE);
        }
    }
    else
    {
        UnicodeLength = MAX_STRING_LEN - 1;
        pUnicode = *ppUnicodeBuffer;
    }

    //
    //  Make sure the length of the Ansi string is not zero.
    //
    if (AnsiLength == 0)
    {
        pUnicode[0] = 0;
        *ppUnicodeBuffer = pUnicode;
        *pUnicodeLength = 0;
        return (TRUE);
    }

    //
    //  Convert the Ansi string to a Unicode string.
    //
    ResultLength = SpecialMBToWC( pHashN,
                                  dwFlags,
                                  pAnsiBuffer,
                                  AnsiLength,
                                  pUnicode,
                                  UnicodeLength );
    if (ResultLength == 0)
    {
        //
        //  Free the allocated Unicode buffer (if one was allocated).
        //
        NLS_FREE_TMP_BUFFER(pUnicode, *ppUnicodeBuffer);

        //
        //  See if the failure was due to insufficient buffer size.
        //
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            //  Get the size of the buffer needed to hold the
            //  Unicode string.
            //
            UnicodeLength = SpecialMBToWC( pHashN,
                                           dwFlags,
                                           pAnsiBuffer,
                                           AnsiLength,
                                           NULL,
                                           0 );
            //
            //  Allocate the Unicode buffer.
            //
            if ((pUnicode = (LPWSTR)NLS_ALLOC_MEM(
                                (UnicodeLength + 1) * sizeof(WCHAR) )) == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return (FALSE);
            }

            //
            //  Try the translation again.
            //
            ResultLength = SpecialMBToWC( pHashN,
                                          dwFlags,
                                          pAnsiBuffer,
                                          AnsiLength,
                                          pUnicode,
                                          UnicodeLength );
        }

        //
        //  If there was still an error, return failure.
        //
        if (ResultLength == 0)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (FALSE);
        }
    }

    //
    //  Make sure there is room in the buffer for the null terminator.
    //
    ASSERT(ResultLength <= (int)UnicodeLength);

    //
    //  Null terminate the string.
    //
    pUnicode[ResultLength] = UNICODE_NULL;

    //
    //  Return the Unicode buffer and success.
    //
    *ppUnicodeBuffer = pUnicode;
    *pUnicodeLength = ResultLength;
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsUnicodeToAnsi
//
//  Converts a Unicode string to an Ansi string.
//
//  This routine does NOT allocate the Ansi buffer.  Instead, it uses the
//  Ansi buffer passed in (unless AnsiLength is 0) and checks for buffer
//  overflow.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int NlsUnicodeToAnsi(
    PCP_HASH pHashN,
    LPCWSTR pUnicodeBuffer,
    int UnicodeLength,
    LPSTR pAnsiBuffer,
    int AnsiLength)
{
    //
    //  Convert the Unicode string to an Ansi string and return the
    //  result.  The last error will be set appropriately by
    //  WideCharToMultiByte.
    //
    return (WideCharToMultiByte( pHashN->CodePage,
                                 0,
                                 pUnicodeBuffer,
                                 UnicodeLength,
                                 pAnsiBuffer,
                                 AnsiLength,
                                 NULL,
                                 NULL ));
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsEnumUnicodeToAnsi
//
//  Converts a Unicode string to an Ansi string.
//
//  NOTE:  The Ansi buffer is allocated if the routine succeeds, so the
//         caller will need to free the buffer when it is no longer needed.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL NlsEnumUnicodeToAnsi(
    PCP_HASH pHashN,
    LPCWSTR pUnicodeBuffer,
    LPSTR *ppAnsiBuffer)
{
    LPSTR pAnsi;                  // ptr to Ansi buffer
    ULONG AnsiLength;             // length of the Ansi string
    ULONG UnicodeLength;          // length of the Unicode string
    ULONG ResultLength;           // result length of Ansi string


    //
    //  Get the length of the Unicode string (in bytes), including the
    //  null terminator.
    //
    UnicodeLength = NlsStrLenW(pUnicodeBuffer) + 1;

    //
    //  Get the size of the Ansi string (in bytes), including the
    //  null terminator.
    //
    AnsiLength = UnicodeLength * sizeof(WCHAR);

    //
    //  Allocate the Ansi buffer.
    //
    if ((pAnsi = (LPSTR)NLS_ALLOC_MEM(AnsiLength)) == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (FALSE);
    }

    //
    //  Convert the Unicode string to an Ansi string.
    //  It will already be null terminated.
    //
    ResultLength = WideCharToMultiByte( pHashN->CodePage,
                                        0,
                                        pUnicodeBuffer,
                                        UnicodeLength,
                                        pAnsi,
                                        AnsiLength,
                                        NULL,
                                        NULL );
    if (ResultLength == 0)
    {
        //
        //  Free the allocated Ansi buffer.
        //
        NLS_FREE_MEM(pAnsi);

        //
        //  See if the failure was due to insufficient buffer size.
        //
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            //  Get the size of the buffer needed to hold the
            //  ansi string.
            //
            AnsiLength = WideCharToMultiByte( pHashN->CodePage,
                                              0,
                                              pUnicodeBuffer,
                                              UnicodeLength,
                                              0,
                                              0,
                                              NULL,
                                              NULL );
            //
            //  Allocate the Ansi buffer.
            //
            if ((pAnsi = (LPSTR)NLS_ALLOC_MEM(AnsiLength)) == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return (FALSE);
            }

            //
            //  Try the translation again.
            //
            ResultLength = WideCharToMultiByte( pHashN->CodePage,
                                                0,
                                                pUnicodeBuffer,
                                                UnicodeLength,
                                                pAnsi,
                                                AnsiLength,
                                                NULL,
                                                NULL );
        }

        //
        //  If there was still an error, return failure.
        //
        if (ResultLength == 0)
        {
            NLS_FREE_MEM(pAnsi);
            SetLastError(ERROR_INVALID_PARAMETER);
            return (FALSE);
        }
    }

    //
    //  Return the Ansi buffer and success.
    //
    *ppAnsiBuffer = pAnsi;
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsDispatchAnsiEnumProc
//
//  Converts a Unicode string to an Ansi string.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL NlsDispatchAnsiEnumProc(
    LCID Locale,
    NLS_ENUMPROC pNlsEnumProc,
    DWORD dwFlags,
    LPWSTR pUnicodeBuffer1,
    LPWSTR pUnicodeBuffer2,
    DWORD dwValue1,
    DWORD dwValue2,
    LONG_PTR lParam,
    BOOL fVersion)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    LPSTR pAnsiBuffer1 = NULL;    // ptr to ansi buffer
    LPSTR pAnsiBuffer2 = NULL;    // ptr to ansi buffer
    BOOL rc = FALSE;              // return code


    //
    //  Get the code page hash node for the given locale.
    //
    pHashN = NlsGetACPFromLocale(Locale, dwFlags);
    if (pHashN == NULL)
    {
        return (0);
    }

    //
    //  Convert the null-terminated Unicode string to a
    //  null-terminated Ansi string.
    //
    if (!NlsEnumUnicodeToAnsi( pHashN,
                               pUnicodeBuffer1,
                               &pAnsiBuffer1 ))
    {
        return (FALSE);
    }

    if ((pUnicodeBuffer2 != NULL) &&
        (!NlsEnumUnicodeToAnsi( pHashN,
                                pUnicodeBuffer2,
                                &pAnsiBuffer2 )))
    {
        NLS_FREE_MEM(pAnsiBuffer1);
        return (FALSE);
    }

    //
    //  Call the callback function.
    //
    switch (fVersion)
    {
        case ( 0 ) :
        {
            rc = (*pNlsEnumProc)(pAnsiBuffer1);
            break;
        }
        case ( 1 ) :
        {
            rc = (*((NLS_ENUMPROCEX)pNlsEnumProc))(pAnsiBuffer1, dwValue1);
            break;
        }
        case ( 2 ) :
        {
            rc = (*((NLS_ENUMPROC2)pNlsEnumProc))( dwValue1,
                                                   dwValue2,
                                                   pAnsiBuffer1,
                                                   lParam );
            break;
        }
        case ( 3 ) :
        {
            rc = (*((NLS_ENUMPROC3)pNlsEnumProc))( dwValue1,
                                                   pAnsiBuffer1,
                                                   pAnsiBuffer2,
                                                   dwValue2,
                                                   lParam );
            break;
        }
        case  ( 4 ) :
        {
            rc = (*((NLS_ENUMPROC4)pNlsEnumProc))( pAnsiBuffer1,
                                                   lParam );
            break;

        }
    }

    //
    //  Free any allocated memory.
    //
    NLS_FREE_MEM(pAnsiBuffer1);
    if (pAnsiBuffer2)
    {
        NLS_FREE_MEM(pAnsiBuffer2);
    }

    //
    //  Return the result.
    //
    return (rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\vspace.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    vspace.c

Abstract:

    This module implements verification functions for 
    virtual address space management interfaces.

Author:

    Silviu Calinoiu (SilviuC) 22-Feb-2001

Revision History:

--*/

#include "pch.h"

#include "verifier.h"
#include "support.h"
#include "critsect.h"
#include "faults.h"
#include "vspace.h"
#include "public.h"
#include "logging.h"

//
// Internal functions declarations
//

VOID
AVrfpFreeVirtualMemNotify (
    HANDLE ProcessHandle,
    VERIFIER_DLL_FREEMEM_TYPE FreeMemType,
    PVOID BaseAddress,
    PSIZE_T RegionSize,
    ULONG VirtualFreeType
    );

NTSTATUS
AVrfpGetVadInformation (
    PVOID Address,
    PVOID * VadAddress,
    PSIZE_T VadSize
    );

NTSTATUS
AVrfpIsCurrentProcessHandle (
    HANDLE ProcessHandle,
    PLOGICAL IsCurrent
    );

NTSTATUS
AVrfpVsTrackAddRegion (
    ULONG_PTR Address,
    ULONG_PTR Size
    );

NTSTATUS
AVrfpVsTrackDeleteRegion (
    ULONG_PTR Address
    );

VOID
AVrfpVsTrackerLock (
    VOID
    );

VOID
AVrfpVsTrackerUnlock (
    VOID
    );


//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    )
{
    NTSTATUS Status;
    LOGICAL ShouldTrack = FALSE;

    BUMP_COUNTER (CNT_VIRTUAL_ALLOC_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_VIRTUAL_ALLOC_APIS)) {
        BUMP_COUNTER (CNT_VIRTUAL_ALLOC_FAILS);
        CHECK_BREAK (BRK_VIRTUAL_ALLOC_FAIL);
        return STATUS_NO_MEMORY;
    }

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

        if (BaseAddress == NULL || RegionSize == NULL) {

            VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_ALLOCMEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                           "Incorrect virtual alloc call",
                           BaseAddress, "Pointer to allocation base address",
                           RegionSize, "Pointer to memory region size",
                           NULL, "",
                           NULL, "" );
        }
        else {

            //
            // Allocate top-down for 64 bit systems or 3Gb systems.
            //

            if (*BaseAddress == NULL && AVrfpSysBasicInfo.MaximumUserModeAddress > (ULONG_PTR)0x80000000) {

                AllocationType |= MEM_TOP_DOWN;
            }
        }
    }

    //
    // Figure out if this is an allocation that should go into the 
    // virtual space tracker.
    //

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING) != 0) {
        
        if ((AllocationType & (MEM_PHYSICAL | MEM_RESET)) == 0) {

            if ((AllocationType & (MEM_RESERVE | MEM_COMMIT)) != 0) {

                Status = AVrfpIsCurrentProcessHandle (ProcessHandle, &ShouldTrack);

                if (! NT_SUCCESS(Status)) {
                    
                    return Status;
                }
            }
        }
    }

    //
    // Call the real function.
    //

    Status = NtAllocateVirtualMemory (ProcessHandle,
                                      BaseAddress,
                                      ZeroBits,
                                      RegionSize,
                                      AllocationType,
                                      Protect);

    if (NT_SUCCESS(Status)) {

        AVrfLogInTracker (AVrfVspaceTracker,
                          TRACK_VIRTUAL_ALLOCATE,
                          *BaseAddress,
                          (PVOID)*RegionSize,
                          (PVOID)(ULONG_PTR)AllocationType,
                          (PVOID)(ULONG_PTR)Protect,
                          _ReturnAddress());
        
        //
        // ShouldTrack is TRUE only if RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING bit is
        // set therefore there is no need to test this again.
        //

        if (ShouldTrack) {

            PVOID VadAddress;
            SIZE_T VadSize;

            Status = AVrfpGetVadInformation (*BaseAddress,
                                             &VadAddress,
                                             &VadSize);
            
            if (NT_SUCCESS(Status)) {

                AVrfpVsTrackerLock ();
                AVrfpVsTrackAddRegion ((ULONG_PTR)VadAddress, VadSize);
                AVrfpVsTrackerUnlock ();
            }
        }
    }

    return Status;
}


//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    )
{
    NTSTATUS Status;

    //
    // Protect ourselves against invalid calls to NtFreeVirtualMemory
    // with a NULL RegionSize or BaseAddress pointers. Note that this will 
    // never happen if the caller is using the Win32 VirtualFree.
    //

    if (RegionSize == NULL || BaseAddress == NULL) {

        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

            VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_FREEMEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                           "Freeing virtual memory block with invalid size or start address",
                           BaseAddress, "Pointer to allocation base address",
                           RegionSize, "Pointer to memory region size",
                           NULL, "",
                           NULL, "" );
        }
    }
    else {

        //
        // One of MEM_DECOMMIT or MEM_RELEASE must be specified, but not both.
        //

        if (FreeType != MEM_DECOMMIT && FreeType != MEM_RELEASE) {

            if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

                VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_FREEMEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "Incorrect FreeType parameter for VirtualFree operation",
                               FreeType, "Incorrect value used by the application",
                               MEM_DECOMMIT, "Expected correct value 1",
                               MEM_RELEASE, "Expected correct value 2",
                               NULL, "" );
            }
        }
        else {

            AVrfpFreeVirtualMemNotify (ProcessHandle,
                                    VerifierFreeMemTypeVirtualFree,
                                    *BaseAddress,
                                    RegionSize,
                                    FreeType);
        }
    }

    //
    // Call the real function.
    //

    Status = NtFreeVirtualMemory (ProcessHandle,
                                  BaseAddress,
                                  RegionSize,
                                  FreeType);
    
    if (NT_SUCCESS(Status)) {

        AVrfLogInTracker (AVrfVspaceTracker,
                          TRACK_VIRTUAL_FREE,
                          *BaseAddress,
                          (PVOID)*RegionSize,
                          (PVOID)(ULONG_PTR)FreeType,
                          NULL,
                          _ReturnAddress());
        
        //
        // If VS tracking is on check if this a free operation that should
        // be tracked.
        //

        if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING) != 0) {

            //
            // If this is a VS release in the current process we will try to track
            // it. If we got an error while figuring out if this is a handle for
            // the current process we just skip this free. The VS tracker is
            // resilient to alloc/free misses.
            //

            if ((FreeType & MEM_RELEASE) != 0) {

                LOGICAL SameProcess;
                NTSTATUS IsCurrentProcessStatus;

                IsCurrentProcessStatus = AVrfpIsCurrentProcessHandle (ProcessHandle,
                                                                      &SameProcess);

                if (NT_SUCCESS(IsCurrentProcessStatus)) {

                    if (SameProcess) {

                        AVrfpVsTrackerLock ();
                        AVrfpVsTrackDeleteRegion ((ULONG_PTR)(*BaseAddress));
                        AVrfpVsTrackerUnlock ();
                    }
                }
            }
        }
    }

    return Status;
}


//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    )
{
    NTSTATUS Status;

    BUMP_COUNTER (CNT_MAP_VIEW_CALLS);
    
    if (SHOULD_FAULT_INJECT(CLS_MAP_VIEW_APIS)) {
        BUMP_COUNTER (CNT_MAP_VIEW_FAILS);
        CHECK_BREAK (BRK_MAP_VIEW_FAIL);
        return STATUS_NO_MEMORY;
    }

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

        if (BaseAddress == NULL || ViewSize == NULL) {

            VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_MAPVIEW | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                           "Incorrect map view call",
                           BaseAddress, "Pointer to mapping base address",
                           ViewSize, "Pointer to view size",
                           NULL, "",
                           NULL, "" );
        }
        else {

            //
            // Allocate top-down for 64 bit systems or 3Gb systems.
            //

            if (*BaseAddress == NULL && AVrfpSysBasicInfo.MaximumUserModeAddress > (ULONG_PTR)0x80000000) {
                    
                AllocationType |= MEM_TOP_DOWN;
            }
        }
    }

    Status = NtMapViewOfSection (SectionHandle,
                                 ProcessHandle,
                                 BaseAddress,
                                 ZeroBits,
                                 CommitSize,
                                 SectionOffset,
                                 ViewSize,
                                 InheritDisposition,
                                 AllocationType,
                                 Protect);
    
    if (NT_SUCCESS(Status)) {

        AVrfLogInTracker (AVrfVspaceTracker,
                          TRACK_MAP_VIEW_OF_SECTION,
                          *BaseAddress,
                          (PVOID)*ViewSize,
                          (PVOID)(ULONG_PTR)AllocationType,
                          (PVOID)(ULONG_PTR)Protect,
                          _ReturnAddress());
    }

    return Status;
}


//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    )
{
    NTSTATUS Status;

    AVrfpFreeVirtualMemNotify (ProcessHandle,
                               VerifierFreeMemTypeUnmap,
                               BaseAddress,
                               NULL,
                               0);

    //
    // Unmap the memory.
    //

    Status = NtUnmapViewOfSection (ProcessHandle,
                                   BaseAddress);
    
    if (NT_SUCCESS(Status)) {

        AVrfLogInTracker (AVrfVspaceTracker,
                          TRACK_UNMAP_VIEW_OF_SECTION,
                          BaseAddress,
                          NULL,
                          NULL,
                          NULL,
                          _ReturnAddress());
    }

    return Status;
}


//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL
    )
{
    NTSTATUS Status;

    Status = NtCreateSection (SectionHandle,
                              DesiredAccess,
                              ObjectAttributes,
                              MaximumSize,
                              SectionPageProtection,
                              AllocationAttributes,
                              FileHandle);
    
    return Status;
}


//NTSYSCALLAPI
NTSTATUS
NTAPI
AVrfpNtOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    NTSTATUS Status;

    Status = NtOpenSection (SectionHandle,
                            DesiredAccess,
                            ObjectAttributes);
    
    return Status;
}


VOID
AVrfpFreeVirtualMemNotify (
    HANDLE ProcessHandle,
    VERIFIER_DLL_FREEMEM_TYPE FreeMemType,
    PVOID BaseAddress,
    PSIZE_T RegionSize,
    ULONG VirtualFreeType
    )
/*++

Routine description:

    This routine is called when a portion of virtual space gets freed (free
    or unmap). It will make some sanity checks of the free operation and then 
    it will call the common `memory free' notification routine (the one
    called for any free: dll unload, heap free, etc.).

Parameters:

    ProcessHandle: process handle.
    
    FreeMemType: type of free. The function is called only with 
        VerifierFreeMemTypeVirtualFree or VerifierFreeMemTypeVirtualUnmap.
        
    BaseAddress: start address.
    
    RegionSize: region size.
    
    VirtualFreeType: type of free operation requested by VirtualFree or UnmapView.

Return value:

    None.
    
--*/
{
    NTSTATUS Status;
    PVOID FreedBaseAddress;
    SIZE_T FreedSize;
    SIZE_T InfoLength;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    LOGICAL IsCurrentProcessHandle;

    //
    // Query the size of the allocation and verify that the memory
    // is not free already.
    //

    FreedBaseAddress = PAGE_ALIGN( BaseAddress );

    Status = NtQueryVirtualMemory (ProcessHandle,
                                   FreedBaseAddress,
                                   MemoryBasicInformation,
                                   &MemoryInformation,
                                   sizeof (MemoryInformation),
                                   &InfoLength);

    if (!NT_SUCCESS (Status)) {

        if (AVrfpProvider.VerifierDebug != 0) {

            DbgPrint ("AVrfpFreeVirtualMemNotify: NtQueryVirtualMemory( %p ) failed %x\n",
                      FreedBaseAddress,
                      Status);
        }
    }
    else {

        if (MemoryInformation.State == MEM_FREE) {

            //
            // We are trying to free memory that is already freed.
            // This can indicate a nasty bug in the app because the current thread 
            // is probably using a stale pointer and this memory could have been
            // reused for something else...
            //

            if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

                VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_FREEMEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "Trying to free virtual memory block that is already free",
                               BaseAddress, "Memory block address",
                               NULL, "",
                               NULL, "",
                               NULL, "" );
            }
        }
        else {

            //
            // Find out if we are freeing memory in the current process
            // or in another process. For the cross-process case we are not 
            // trying to catch any other possible bugs because we can get confused
            // if the current process is wow64 and the target is ia64, etc.
            //

            Status = AVrfpIsCurrentProcessHandle (ProcessHandle,
                                                  &IsCurrentProcessHandle);

            if (NT_SUCCESS(Status) && IsCurrentProcessHandle) {

                //
                // For VirtualFree (MEM_RELEASE, RegionSize == 0) or UnmapViewOfFile
                // the whole VAD will be freed so we will use its size.
                //

                if ((FreeMemType == VerifierFreeMemTypeUnmap) ||
                    ((FreeMemType == VerifierFreeMemTypeVirtualFree) &&
                     (((VirtualFreeType & MEM_RELEASE) != 0) && *RegionSize == 0))) {

                    FreedSize = MemoryInformation.RegionSize;
                }
                else {

                    ASSERT (RegionSize != NULL);
                    FreedSize = *RegionSize;
                }

                //
                // Sanity checks for the block start address and size.
                // These checks can be integrated in AVrfpFreeMemNotify 
                // but we want to make sure we are not using values that 
                // don't make sense in the FreedSize computation below.
                //

                if ((AVrfpSysBasicInfo.MaximumUserModeAddress <= (ULONG_PTR)FreedBaseAddress) ||
                    ((AVrfpSysBasicInfo.MaximumUserModeAddress - (ULONG_PTR)FreedBaseAddress) < FreedSize)) {
                    
                    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

                        VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_FREEMEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                       "Freeing virtual memory block with invalid size or start address",
                                       FreedBaseAddress, "Memory block address",
                                       FreedSize, "Memory region size",
                                       NULL, "",
                                       NULL, "" );
                    }
                }
                else {

                    FreedSize = (PCHAR)BaseAddress + FreedSize - (PCHAR)FreedBaseAddress;
                    FreedSize = ROUND_UP( FreedSize, PAGE_SIZE );
                
                    //
                    // Perform the rest of the checks, common for all memory free operations. 
                    // E.g.:
                    // - is this memory block part of the current thread's stack?
                    // - do we have active critical sections inside this memory block?
                    //

                    AVrfpFreeMemNotify (FreeMemType,
                                        FreedBaseAddress,
                                        FreedSize,
                                        NULL);
                }
            }
        }
    }
}


NTSTATUS
AVrfpIsCurrentProcessHandle (
    HANDLE ProcessHandle,
    PLOGICAL IsCurrent
    )
/*++

Routine description:

    This routine figures out if a handle represents the current process'
    handle. This means it is either a pseudohandle or a handle obtained
    by calling OpenProcess().

Parameters:

    ProcessHandle: handle to figure out.
    
    IsCurrent: address of a boolean to pass back the result.

Return value:

    STATUS_SUCCESS if the function managed to put a meaningful value in
    `*IsCurrent'. Various status errors otherwise.
    
--*/
{
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION BasicInfo;

    if (NtCurrentProcess() == ProcessHandle) {
        *IsCurrent = TRUE;
        return STATUS_SUCCESS;
    }

    Status = NtQueryInformationProcess (ProcessHandle,
                                        ProcessBasicInformation,
                                        &BasicInfo,
                                        sizeof(BasicInfo),
                                        NULL);

    if (! NT_SUCCESS(Status)) {
        return Status;
    }
    
    if (BasicInfo.UniqueProcessId == (ULONG_PTR)(NtCurrentTeb()->ClientId.UniqueProcess)) {

        *IsCurrent = TRUE;
    }
    else {

        *IsCurrent = FALSE;
    }

    return STATUS_SUCCESS;
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////// Virtual space trackker support
/////////////////////////////////////////////////////////////////////

//
// Unexpected frees/allocs happen when one operation happens in a tracked
// dll and the pair operation happens in ntdll.dll, kernel mode or
// cross-process. For example the allocation is made by a kernel mode
// component and the free is done in some dll. The virtual space tracker
// must be resilient to these situations in order to work for any type of 
// process.
//

RTL_CRITICAL_SECTION AVrfpVsTrackLock;
LIST_ENTRY AVrfpVsTrackList;

LONG AVrfpVsTrackRegionCount;
SIZE_T AVrfpVsTrackMemoryTotal;

LOGICAL AVrfpVsTrackDisabled;


VOID
AVrfpVsTrackerLock (
    VOID
    )
{
    RtlEnterCriticalSection (&AVrfpVsTrackLock);
}

VOID
AVrfpVsTrackerUnlock (
    VOID
    )
{
    RtlLeaveCriticalSection (&AVrfpVsTrackLock);
}


NTSTATUS
AVrfpVsTrackInitialize (
    VOID
    )
/*++

Routine description:

    This routine initializes virtual space tracker structures.

Parameters:

    None.

Return value:

    STATUS_SUCCESS if successful. Various status errors otherwise.
    
--*/
{
    NTSTATUS Status;

    InitializeListHead (&AVrfpVsTrackList);

    Status = RtlInitializeCriticalSection (&AVrfpVsTrackLock);

    return Status;
}


NTSTATUS
AVrfpVsTrackAddRegion (
    ULONG_PTR Address,
    ULONG_PTR Size
    )
/*++

Routine description:

    This routine adds a new virtual space region to the VS tracker. If there is
    already a region having exactly the same characteristics (address, size)
    the function does not do anything and returns successfully.
    
    The function is called with the VS track lock acquired.

Parameters:

    Address: start address of the new virtual space region.
    
    Size: size of the new virtual space region.

Return value:

    STATUS_SUCCESS if successful.
    
--*/
{
    PAVRF_VSPACE_REGION Region;
    PLIST_ENTRY Current;
    PAVRF_VSPACE_REGION NewRegion;
    LOGICAL ClashFound;

    if (AVrfpVsTrackDisabled) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Due to the fact that only virtual space operations coming from
    // DLLs (except ntdll.dll) are hooked this routine must be resilient
    // to various failures. For example if we try to add a region that
    // clashes with an existing region within the tracker it probably means
    // the free for the existing region has been missed.
    //

    ClashFound = FALSE;

    Current = AVrfpVsTrackList.Flink;

    NewRegion = NULL;

    while (Current != &AVrfpVsTrackList) {

        Region = CONTAINING_RECORD (Current,
                                    AVRF_VSPACE_REGION,
                                    List);

        if (Address < Region->Address + Region->Size) {

            if (Address + Size > Region->Address) {

                //
                // We will recycle `Region' since we missed its free.
                //

                AVrfpVsTrackRegionCount -= 1;
                AVrfpVsTrackMemoryTotal -= Region->Size;

                ClashFound = TRUE;
                NewRegion = Region;
                
                break;
            }
            else {

                //
                // We will add a new region in front of `Region'.
                //

                break;
            }
        }
        else {

            //
            // Move on to the next region in the list.
            //

            Current = Current->Flink;
        }
    }

    //
    // We need to create a new region before `Region' if 
    // NewRegion is null.
    // 

    if (NewRegion == NULL) {

        NewRegion = AVrfpAllocate (sizeof *NewRegion);
    }

    if (NewRegion == NULL) {

        //
        // Well, we could not allocate a new VS tracker node. Since add/delete
        // are resilient to these misses we will let it go.
        //

        return STATUS_NO_MEMORY;

    }

    //
    // We fill the  new virtual space region with information
    // and then return.
    //

    NewRegion->Address = Address;
    NewRegion->Size = Size;

    RtlCaptureStackBackTrace (3,
                              MAX_TRACE_DEPTH,
                              NewRegion->Trace,
                              NULL);

    AVrfpVsTrackRegionCount += 1;
    AVrfpVsTrackMemoryTotal += NewRegion->Size;

    if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_SHOW_VSPACE_TRACKING)) {
        DbgPrint ("AVRF: adding virtual space region @ %p (size %p) \n", Address, Size);
    }

    if (Current != &AVrfpVsTrackList) {

        //
        // We will add the new region before the current region in the list
        // traversal if this is a new region to be inserted and we do not
        // just recycle a clashing region.
        //
        // (Current->Blink)
        //     <== (NewRegion->List)
        // Current
        //

        if (ClashFound == FALSE) {

            NewRegion->List.Flink = Current;
            NewRegion->List.Blink = Current->Blink;

            Current->Blink->Flink = &(NewRegion->List);
            Current->Blink = &(NewRegion->List);
        }
    }
    else {

        //
        // If we finished the list of regions then this must be the 
        // last region.
        //

        InsertTailList (Current, &(NewRegion->List));
    }
    
    return STATUS_SUCCESS;
}


NTSTATUS
AVrfpVsTrackDeleteRegion (
    ULONG_PTR Address
    )
/*++

Routine description:

    This routine deletes a virtual space region from the tracker assuming
    there is a region starting exactly as the same address as parameter
    `Address'. If there is not an exact match an error is returned.

    The function is called with the VS track lock acquired.

Parameters:

    Address: start address of the region that must be deleted from the tracker.

Return value:

    STATUS_SUCCES if the virtual region has been successfully deleted.
    
--*/
{
    PAVRF_VSPACE_REGION Region;
    PLIST_ENTRY Current;

    if (AVrfpVsTrackDisabled) {
        return STATUS_UNSUCCESSFUL;
    }

    Current = AVrfpVsTrackList.Flink;

    while (Current != &AVrfpVsTrackList) {

        Region = CONTAINING_RECORD (Current,
                                    AVRF_VSPACE_REGION,
                                    List);

        if (Address >= Region->Address + Region->Size) {

            //
            // Move on to the next region in the list.
            //

            Current = Current->Flink;
        }
        else if (Address >= Region->Address) {

            //
            // Any region clashing with this one will be deleted. 
            //

            if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_SHOW_VSPACE_TRACKING)) {

                DbgPrint ("AVRF: deleting virtual space region @ %p (size %p) \n", 
                          Region->Address, Region->Size);
            }

            AVrfpVsTrackRegionCount -= 1;
            AVrfpVsTrackMemoryTotal -= Region->Size;
            
            RemoveEntryList (&(Region->List));

            AVrfpFree (Region);

            return STATUS_SUCCESS;
        }
        else {

            //
            // Virtual space tracker is sorted so there is no chance to find
            // a region containing the address any more.
            //

            break;
        }
    }
    
    return STATUS_SUCCESS;            
}


NTSTATUS
AVrfpGetVadInformation (
    PVOID Address,
    PVOID * VadAddress,
    PSIZE_T VadSize
    )
/*++

Routine description:

    This routine takes an arbitrary address in a virtual space region
    containing private memory and finds out the start address
    and size of the VAD containing it. 
    
    If the address points into some other type of memory (free, mapped, etc.)
    the function will return an error.
    
    The tricky part in the implementation is that a private VAD can have various
    portions committed or decommitted so a simple VirtualQuery() will not give
    all the information.

Parameters:

    Address: arbitrary address.
    
    VadAddress: pointer to variable where start address of the VAD region
        will be written.
    
    VadSize: pointer to variable where region size of the VAD will be 
        written.

Return value:

    STATUS_SUCCESS if the VAD contained private memory and the start address
    and size have been written.
    
--*/
{
    MEMORY_BASIC_INFORMATION MemoryInfo;
    NTSTATUS Status;
                
    //
    // Query the size of the allocation.
    //

    Status = NtQueryVirtualMemory (NtCurrentProcess (),
                                   Address,
                                   MemoryBasicInformation,
                                   &MemoryInfo,
                                   sizeof MemoryInfo,
                                   NULL);
    
    if (! NT_SUCCESS (Status) ) {
        
        //
        // For this case only we disable the VS tracker for good.
        // We do this so that the process can continue to run even if
        // the tracking infrastructure cannot be used any more.
        //

        AVrfpVsTrackDisabled = TRUE;

        return Status;
    }

    if (MemoryInfo.Type != MEM_PRIVATE) {
        return STATUS_NOT_IMPLEMENTED;
    }

    *VadAddress = MemoryInfo.AllocationBase;
    *VadSize = MemoryInfo.RegionSize;
    Address = *VadAddress;

    do {

        Address = (PVOID)((ULONG_PTR)Address + MemoryInfo.RegionSize);

        Status = NtQueryVirtualMemory (NtCurrentProcess (),
                                       Address,
                                       MemoryBasicInformation,
                                       &MemoryInfo,
                                       sizeof MemoryInfo,
                                       NULL);

        if (! NT_SUCCESS (Status) ) {
            
            //
            // For this case only we disable the VS tracker for good.
            // We do this so that the process can continue to run even if
            // the tracking infrastructure cannot be used any more.
            //

            AVrfpVsTrackDisabled = TRUE;

            return Status;
        }

        if (*VadAddress == MemoryInfo.AllocationBase) {
            *VadSize += MemoryInfo.RegionSize;
        }

    } while (*VadAddress == MemoryInfo.AllocationBase);

    return STATUS_SUCCESS;
}


NTSTATUS            
AVrfpVsTrackDeleteRegionContainingAddress (
    PVOID Address
    )
/*++

Routine description:

    This routine takes an arbitrary address and tries to delete the virtual
    region containing it from the VS tracker.
    
    If the address points into some other type of memory (free, mapped, etc.)
    the function will return an error.

Parameters:

    Address: arbitrary address.

Return value:

    STATUS_SUCCESS if the virtual region has been deleted.
    
--*/
{
    NTSTATUS Status;
    PVOID VadAddress;
    SIZE_T VadSize;
    
    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING) == 0) {
        return STATUS_NOT_IMPLEMENTED;
    }

    if (AVrfpVsTrackDisabled) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = AVrfpGetVadInformation (Address,
                                     &VadAddress,
                                     &VadSize);

    if (NT_SUCCESS(Status)) {

        if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_SHOW_VSPACE_TRACKING)) {
            DbgPrint ("AVRF: deleting stack @ %p \n", VadAddress);
        }

        AVrfpVsTrackerLock ();
        AVrfpVsTrackDeleteRegion ((ULONG_PTR)VadAddress);
        AVrfpVsTrackerUnlock ();
    }
    else {
        
        if ((AVrfpProvider.VerifierDebug & VRFP_DEBUG_SHOW_VSPACE_TRACKING)) {
            DbgPrint ("AVRF: failed to find a stack @ %p (%X)\n", VadAddress, Status);
        }
    }

    return Status;
}

/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// IsBadPtr checks
/////////////////////////////////////////////////////////////////////

ULONG
AVrfpProbeMemExceptionFilter (
    IN ULONG ExceptionCode,
    IN PVOID ExceptionRecord,
    IN CONST VOID *Address
    )
{
    VERIFIER_STOP (APPLICATION_VERIFIER_UNEXPECTED_EXCEPTION | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                   "unexpected exception raised while probing memory",
                   ExceptionCode, "Exception code.",
                   ((PEXCEPTION_POINTERS)ExceptionRecord)->ExceptionRecord, "Exception record. Use .exr to display it.",
                   ((PEXCEPTION_POINTERS)ExceptionRecord)->ContextRecord, "Context record. Use .cxr to display it.",
                   Address, "Memory address");

    return EXCEPTION_EXECUTE_HANDLER;
}

BOOL
AVrfpVerifyReadAccess (
    IN CONST VOID *UserStartAddress,
    IN UINT_PTR UserSize,
    IN CONST VOID *RegionStartAddress,
    OUT PUINT_PTR RegionSize
    )
{
    PVOID BaseAddress;
    BOOL Success;
    NTSTATUS Status;
    SIZE_T InfoLength;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    //
    // Assume success and block size == page size.
    // We will simply return these values in case NtQueryVirtualMemory fails
    // because that could happen in low memory conditions, etc.
    //

    Success = TRUE;
    *RegionSize = AVrfpSysBasicInfo.PageSize;

    BaseAddress = PAGE_ALIGN (RegionStartAddress);

    //
    // Sanity check for the based address.
    //

    if (AVrfpSysBasicInfo.MaximumUserModeAddress <= (ULONG_PTR)BaseAddress) {

        VERIFIER_STOP (APPLICATION_VERIFIER_PROBE_INVALID_ADDRESS | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                       "Probing invalid address",
                       UserStartAddress, "Start address",
                       UserSize, "Memory block size",
                       BaseAddress, "Invalid address",
                       NULL, "" );

        Success = FALSE;
    }
    else {

        //
        // Query the size of the allocation and verify that the memory
        // is not free already.
        //

        Status = NtQueryVirtualMemory (NtCurrentProcess (),
                                       BaseAddress,
                                       MemoryBasicInformation,
                                       &MemoryInformation,
                                       sizeof (MemoryInformation),
                                       &InfoLength);

        if (NT_SUCCESS (Status)) {

            if (MemoryInformation.State & MEM_FREE) {

                //
                // Probing free memory!
                //

                VERIFIER_STOP (APPLICATION_VERIFIER_PROBE_FREE_MEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "Probing free memory",
                               UserStartAddress, "Start address",
                               UserSize, "Memory block size",
                               BaseAddress, "Address of free memory page",
                               NULL, "" );

                Success = FALSE;
            }
            else if (MemoryInformation.AllocationProtect & PAGE_GUARD) {

                //
                // Probing a guard page, probably part of a stack!
                //

                VERIFIER_STOP (APPLICATION_VERIFIER_PROBE_GUARD_PAGE | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "Probing guard page",
                               UserStartAddress, "Start address",
                               UserSize, "Memory block size",
                               BaseAddress, "Address of guard page",
                               NULL, "" );

                Success = FALSE;
            }
            else {

                //
                // Everything seems to be OK. Return to the caller the number of bytes 
                // to skip up to the next memory region.
                //

                ASSERT ((MemoryInformation.RegionSize % AVrfpSysBasicInfo.PageSize) == 0);
                *RegionSize = MemoryInformation.RegionSize;
            }
        }
    }

    return Success;
}

BOOL
AVrfpProbeMemoryBlockChecks (
    IN CONST VOID *UserBaseAddress,
    IN UINT_PTR UserSize
    )
{
    PBYTE EndAddress;
    PBYTE StartAddress;
    ULONG PageSize;
    BOOL Success;
    UINT_PTR RegionSize;

    Success = TRUE;

    PageSize = AVrfpSysBasicInfo.PageSize;

    //
    // If the structure has zero length, then there is nothing to probe.
    //

    if (UserSize != 0) {

        if (UserBaseAddress == NULL) {

            VERIFIER_STOP (APPLICATION_VERIFIER_PROBE_NULL | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                           "Probing NULL address",
                           NULL, "",
                           NULL, "",
                           NULL, "",
                           NULL, "" );

            Success = FALSE;
        }
        else {

            StartAddress = (PBYTE)UserBaseAddress;
            EndAddress = StartAddress + UserSize - 1;

            if (EndAddress < StartAddress) {

                VERIFIER_STOP (APPLICATION_VERIFIER_PROBE_INVALID_START_OR_SIZE | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                               "Probing memory block with invalid start address or size",
                               StartAddress, "Start address",
                               UserSize, "Memory block size",
                               NULL, "",
                               NULL, "" );

                Success = FALSE;
            }
            else {

                //
                // Truncate the start and end to page size alignment
                // and verify every page in this memory block.
                //

                StartAddress = PAGE_ALIGN (StartAddress);
                EndAddress = PAGE_ALIGN (EndAddress);

                while (StartAddress <= EndAddress) {

                    Success = AVrfpVerifyReadAccess (UserBaseAddress,
                                                     UserSize,
                                                     StartAddress,
                                                     &RegionSize);
                    
                    if (Success != FALSE) {

                        ASSERT ((RegionSize % PageSize) == 0);

                        if (RegionSize <= (UINT_PTR)(EndAddress - StartAddress)) {

                            StartAddress = StartAddress + RegionSize;
                        }
                        else {

                            StartAddress = StartAddress + PageSize;
                        }
                    }
                    else {

                        //
                        // We have detected a problem already - bail out.
                        //

                        break;
                    }
                }
            }
        }
    }

    return Success;
}

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadReadPtr(
    CONST VOID *lp,
    UINT_PTR cb
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (CONST VOID *, UINT_PTR);
    FUNCTION_TYPE Function;

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

        AVrfpProbeMemoryBlockChecks (lp,
                                     cb);
    }

    //
    // Call the original funtion.
    //

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_ISBADREADPTR);

    return (*Function) (lp, cb);
}


//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadHugeReadPtr(
    CONST VOID *lp,
    UINT_PTR cb
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (CONST VOID *, UINT_PTR);
    FUNCTION_TYPE Function;

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

        AVrfpProbeMemoryBlockChecks (lp,
                                     cb);
    }

    //
    // Call the original funtion.
    //

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_ISBADHUGEREADPTR);

    return (*Function) (lp, cb);
}

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadWritePtr(
    LPVOID lp,
    UINT_PTR cb
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (LPVOID , UINT_PTR);
    FUNCTION_TYPE Function;

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

        AVrfpProbeMemoryBlockChecks (lp,
                                     cb);
    }

    //
    // Call the original funtion.
    //

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_ISBADWRITEPTR);

    return (*Function) (lp, cb);
}

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadHugeWritePtr(
    LPVOID lp,
    UINT_PTR cb
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (LPVOID , UINT_PTR);
    FUNCTION_TYPE Function;

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

        AVrfpProbeMemoryBlockChecks (lp,
                                     cb);
    }

    //
    // Call the original funtion.
    //

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_ISBADHUGEWRITEPTR);

    return (*Function) (lp, cb);
}

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadCodePtr(
    FARPROC lpfn
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (FARPROC);
    FUNCTION_TYPE Function;

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

        AVrfpProbeMemoryBlockChecks (lpfn,
                                     1);
    }

    //
    // Call the original funtion.
    //

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_ISBADCODEPTR);

    return (*Function) (lpfn);
}


//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadStringPtrA(
    LPCSTR lpsz,
    UINT_PTR cchMax
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (LPCSTR , UINT_PTR);
    FUNCTION_TYPE Function;
    ULONG PageSize;
    BOOL FoundNull;
    BOOL Success;
    LPCSTR StartAddress;
    LPCSTR EndAddress;
    CHAR Character;

    PageSize = AVrfpSysBasicInfo.PageSize;
    FoundNull = FALSE;

    StartAddress = lpsz;
    EndAddress = lpsz + cchMax - 1;

    while (StartAddress <= EndAddress && FoundNull == FALSE) {

        //
        // Verify read access to the current page.
        //

        Success = AVrfpProbeMemoryBlockChecks (StartAddress,
                                               sizeof (CHAR));

        if (Success == FALSE) {

            //
            // We have detected a problem already - bail out.
            //

            break;
        }
        else {

            //
            // Skip all the bytes up to the next page 
            // or the NULL string terminator.
            //

            while (TRUE) {

                //
                // Read the currect character, while protecting
                // ourselves against a possible exception (alignment, etc).
                //

                try {

                    Character = *StartAddress;
                }
                except (AVrfpProbeMemExceptionFilter (_exception_code(), _exception_info(), StartAddress)) {

                    //
                    // We have detected a problem already - bail out.
                    //

                    goto Done;
                }

                //
                // If we have found the NULL terminator we are done.
                //

                if (Character == 0) {

                    FoundNull = TRUE;
                    break;
                }

                //
                // Go to the next character. If that is at the beginning 
                // of a new page we have to check it's attributes.
                //

                StartAddress += 1;

                if (StartAddress > EndAddress) {

                    //
                    // We have reached the max length of the buffer.
                    //

                    break;
                }

                if (((ULONG_PTR)StartAddress % PageSize) < sizeof (CHAR)) {

                    //
                    // New page.
                    //

                    break;
                }
            }
        }
    }

Done:

    //
    // Call the original funtion.
    //

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_ISBADSTRINGPTRA);

    return (*Function) (lpsz, cchMax);
}

//WINBASEAPI
BOOL
WINAPI
AVrfpIsBadStringPtrW(
    LPCWSTR lpsz,
    UINT_PTR cchMax
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (LPCWSTR , UINT_PTR);
    FUNCTION_TYPE Function;
    ULONG PageSize;
    BOOL FoundNull;
    BOOL Success;
    LPCWSTR StartAddress;
    LPCWSTR EndAddress;
    WCHAR Character;

    PageSize = AVrfpSysBasicInfo.PageSize;
    FoundNull = FALSE;

    StartAddress = lpsz;
    EndAddress = lpsz + cchMax - 1;

    while (StartAddress <= EndAddress && FoundNull == FALSE) {

        //
        // Verify read access to the current page.
        //

        Success = AVrfpProbeMemoryBlockChecks (StartAddress,
                                               sizeof (WCHAR));

        if (Success == FALSE) {

            //
            // We have detected a problem already - bail out.
            //

            break;
        }
        else {

            //
            // Skip all the bytes up to the next page 
            // or the NULL string terminator.
            //

            while (TRUE) {

                //
                // Read the currect character, while protecting
                // ourselves against a possible exception (alignment, etc).
                //

                try {

                    Character = *StartAddress;
                }
                except (AVrfpProbeMemExceptionFilter (_exception_code(), _exception_info(), StartAddress)) {

                    //
                    // We have detected a problem already - bail out.
                    //

                    goto Done;
                }

                //
                // If we have found the NULL terminator we are done.
                //

                if (Character == 0) {

                    FoundNull = TRUE;
                    break;
                }

                //
                // Go to the next character. If that is at the beginning 
                // of a new page we have to check it's attributes.
                //

                StartAddress += 1;

                if (StartAddress > EndAddress) {

                    //
                    // We have reached the max length of the buffer.
                    //

                    break;
                }

                if (((ULONG_PTR)StartAddress % PageSize) < sizeof (WCHAR)) {

                    //
                    // New page.
                    //

                    break;
                }
            }
        }
    }

Done:

    //
    // Call the original funtion.
    //

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_ISBADSTRINGPTRW);

    return (*Function) (lpsz, cchMax);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// VirtualFree sanity checks
/////////////////////////////////////////////////////////////////////

VOID
AVrfVirtualFreeSanityChecks (
    IN SIZE_T dwSize,
    IN DWORD dwFreeType
    )
{
    //
    // The Win32 layer only allows MEM_RELEASE with Size == 0.
    //

    if (dwFreeType == MEM_RELEASE && dwSize != 0) {

        VERIFIER_STOP (APPLICATION_VERIFIER_INVALID_FREEMEM | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                        "Incorrect Size parameter for VirtualFree (MEM_RELEASE) operation",
                        dwSize, "Incorrect size used by the application",
                        0, "Expected correct size",
                        NULL, "",
                        NULL, "" );
    }
}

//WINBASEAPI
BOOL
WINAPI
AVrfpVirtualFree(
    IN LPVOID lpAddress,
    IN SIZE_T dwSize,
    IN DWORD dwFreeType
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (LPVOID , SIZE_T, DWORD);
    FUNCTION_TYPE Function;

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

        AVrfVirtualFreeSanityChecks (dwSize, dwFreeType);
    }

    //
    // Call the original funtion.
    //

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_VIRTUALFREE);

    return (*Function) (lpAddress, dwSize, dwFreeType);
}

//WINBASEAPI
BOOL
WINAPI
AVrfpVirtualFreeEx(
    IN HANDLE hProcess,
    IN LPVOID lpAddress,
    IN SIZE_T dwSize,
    IN DWORD dwFreeType
    )
{
    typedef BOOL (WINAPI * FUNCTION_TYPE) (HANDLE, LPVOID , SIZE_T, DWORD);
    FUNCTION_TYPE Function;

    if ((AVrfpProvider.VerifierFlags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) != 0) {

        AVrfVirtualFreeSanityChecks (dwSize, dwFreeType);
    }

    //
    // Call the original funtion.
    //

    Function = AVRFP_GET_ORIGINAL_EXPORT (AVrfpKernel32Thunks,
                                          AVRF_INDEX_KERNEL32_VIRTUALFREEEX);

    return (*Function) (hProcess, lpAddress, dwSize, dwFreeType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\datetime.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    datetime.c

Abstract:

    This file contains the API functions that form properly formatted date
    and time strings for a given locale.

    APIs found in this file:
      GetTimeFormatW
      GetDateFormatW

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"


//
//  Constant Declarations.
//

#define MAX_DATETIME_BUFFER  256            // max size of buffer

#define NLS_CHAR_LTR_MARK    L'\x200e'      // left to right reading order mark
#define NLS_CHAR_RTL_MARK    L'\x200f'      // right to left reading order mark

#define NLS_HEBREW_JUNE      6              // month of June (Hebrew lunar)




//
//  Forward Declarations.
//

BOOL
IsValidTime(
    LPSYSTEMTIME lpTime);

BOOL
IsValidDate(
    LPSYSTEMTIME lpDate);

WORD
GetCalendarYear(
    LPWORD *ppRange,
    CALID CalNum,
    PCALENDAR_VAR pCalInfo,
    WORD Year,
    WORD Month,
    WORD Day);

int
ParseTime(
    PLOC_HASH pHashN,
    LPSYSTEMTIME pLocalTime,
    LPWSTR pFormat,
    LPWSTR pTimeStr,
    DWORD dwFlags);

int
ParseDate(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPSYSTEMTIME pLocalDate,
    LPWSTR pFormat,
    LPWSTR pDateStr,
    CALID CalNum,
    PCALENDAR_VAR pCalInfo,
    BOOL fLunarLeap);

DWORD
GetAbsoluteDate(
    WORD Year,
    WORD Month,
    WORD Day);

void
GetHijriDate(
    LPSYSTEMTIME pDate,
    DWORD dwFlags);

LONG
GetAdvanceHijriDate(
    DWORD dwFlags);

DWORD
DaysUpToHijriYear(
    DWORD HijriYear);

BOOL
GetHebrewDate(
    LPSYSTEMTIME pDate,
    LPBOOL pLunarLeap);

BOOL
IsValidDateForHebrew(
    WORD Year,
    WORD Month,
    WORD Day);

BOOL
NumberToHebrewLetter(
    DWORD Number,
    LPWSTR szHebrewNum,
    int cchSize);





//-------------------------------------------------------------------------//
//                            INTERNAL MACROS                              //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NLS_COPY_UNICODE_STR
//
//  Copies a zero terminated string from pSrc to the pDest buffer.  The
//  pDest pointer is advanced to the end of the string. Also, the cchDest
//  member will be updated with the amount remaining
//
//  SECURITY: If the copy fails due to exceeding cchDest, then this macro 
//            will exit the calling function, returning rcFailure.
//
//  DEFINED AS A MACRO.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_COPY_UNICODE_STR( pDest,                                       \
                              cchDest,                                     \
                              pSrc,                                        \
                              rcFailure)                                   \
{                                                                          \
    /*                                                                     \
     *  Copy the string to the result buffer.                              \
     */                                                                    \
    if(FAILED(StringCchCopyExW(pDest,                                      \
                               cchDest,                                    \
                               pSrc,                                       \
                               &pDest,                                     \
                               &cchDest,                                   \
                               0)))                                        \
    {                                                                      \
            return(rcFailure);                                             \
    }                                                                      \
}

////////////////////////////////////////////////////////////////////////////
//
//  NLS_PAD_INT_TO_UNICODE_STR
//
//  Converts an integer value to a unicode string and stores it in the
//  buffer provided with the appropriate number of leading zeros.  The
//  pResultBuf pointer is advanced to the end of the string and the
//  cchResultBuf parasm is updated to the amount of space left.
//
//  SECURITY: Note that if an attempt is made to overrun our static buffer, 
//            this macro will exit the calling function (returning rcFailure). 
//
//  DEFINED AS A MACRO.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_PAD_INT_TO_UNICODE_STR( Value,                                 \
                                    Base,                                  \
                                    Padding,                               \
                                    pResultBuf,                            \
                                    cchResultBuf,                          \
                                    rcFailure)                             \
{                                                                          \
    UNICODE_STRING ObString;                     /* value string */        \
    WCHAR pBuffer[MAX_SMALL_BUF_LEN];            /* ptr to buffer */       \
    UINT LpCtr;                                  /* loop counter */        \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Set up unicode string structure.                                   \
     */                                                                    \
    ObString.Length = MAX_SMALL_BUF_LEN * sizeof(WCHAR);                   \
    ObString.MaximumLength = MAX_SMALL_BUF_LEN * sizeof(WCHAR);            \
    ObString.Buffer = pBuffer;                                             \
                                                                           \
    /*                                                                     \
     *  Get the value as a string.  If there is an error, then do nothing. \
     */                                                                    \
    if (!RtlIntegerToUnicodeString(Value, Base, &ObString))                \
    {                                                                      \
        /*                                                                 \
         *  Pad the string with the appropriate number of zeros.           \
         */                                                                \
        for (LpCtr = GET_WC_COUNT(ObString.Length);                        \
             LpCtr < Padding;                                              \
             LpCtr++, pResultBuf++, cchResultBuf--)                        \
        {                                                                  \
            *pResultBuf = NLS_CHAR_ZERO;                                   \
        }                                                                  \
                                                                           \
        /*                                                                 \
         *  Copy the string to the result buffer.                          \
         *  The pResultBuf pointer will be advanced in the macro.          \
         *  The cchResultsBuf value will be updated in the macro.          \
         */                                                                \
        NLS_COPY_UNICODE_STR(pResultBuf,                                   \
                             cchResultBuf,                                 \
                             ObString.Buffer, rcFailure)                   \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_STRING_TO_INTEGER
//
//  Converts a string to an integer value.
//
//  DEFINED AS A MACRO.
//
//  10-19-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_STRING_TO_INTEGER( CalNum,                                     \
                               pCalId )                                    \
{                                                                          \
    UNICODE_STRING ObUnicodeStr;       /* value string */                  \
                                                                           \
                                                                           \
    /*                                                                     \
     *  No need to check return value since the calendar number            \
     *  will be validated after this anyway.                               \
     */                                                                    \
    RtlInitUnicodeString(&ObUnicodeStr, pCalId);                           \
    RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &CalNum);                 \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_INSERT_BIDI_MARK
//
//  Based on the user's bidi mark preference, it either adds a
//  left to right mark or a right to left mark.
//  The pDest pointer is advanced to the next position.
//  The cchDest value is updated to the amount of space remaining in pDest.
//
//  SECURITY: Note that if an attempt is made to overrun our static buffer, 
//            this macro will exit the calling function (returning rcFailure). 
//
//  DEFINED AS A MACRO.
//
//  12-03-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_INSERT_BIDI_MARK(pDest, dwFlags, cchDest, rcFailure)           \
{                                                                          \
    if (dwFlags & (DATE_LTRREADING | DATE_RTLREADING))                     \
    {                                                                      \
        if(cchDest <= 1)                                                   \
        {                                                                  \
            return(rcFailure);                                             \
        }                                                                  \
        if (dwFlags & DATE_RTLREADING)                                     \
        {                                                                  \
            *pDest = NLS_CHAR_RTL_MARK;                                    \
        }                                                                  \
        else                                                               \
        {                                                                  \
            *pDest = NLS_CHAR_LTR_MARK;                                    \
        }                                                                  \
        pDest++;                                                           \
        cchDest--;                                                         \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_GREGORIAN_LEAP_YEAR
//
//  True if the given Gregorian year is a leap year.  False otherwise.
//
//  A year is a leap year if it is divisible by 4 and is not a century
//  year (multiple of 100) or if it is divisible by 400.
//
//  DEFINED AS A MACRO.
//
//  12-04-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_GREGORIAN_LEAP_YEAR(Year)                                      \
    ((Year % 4 == 0) && ((Year % 100 != 0) || (Year % 400 == 0)))


////////////////////////////////////////////////////////////////////////////
//
//  NLS_HIJRI_LEAP_YEAR
//
//  True if the given Hijri year is a leap year.  False otherwise.
//
//  A year is a leap year if it is the 2nd, 5th, 7th, 10th, 13th, 16th,
//  18th, 21st, 24th, 26th, or 29th year of a 30-year cycle.
//
//  DEFINED AS A MACRO.
//
//  12-04-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_HIJRI_LEAP_YEAR(Year)                                          \
    ((((Year * 11) + 14) % 30) < 11)




//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetTimeFormatW
//
//  Returns a properly formatted time string for the given locale.  It uses
//  either the system time or the specified time.  This call also indicates
//  how much memory is necessary to contain the desired information.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetTimeFormatW(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime)

{
    PLOC_HASH pHashN;                       // ptr to LOC hash node
    SYSTEMTIME LocalTime;                   // local time structure
    LPWSTR pFormat;                         // ptr to time format string
    int Length = 0;                         // number of characters written
    WCHAR pString[MAX_DATETIME_BUFFER];     // ptr to temporary buffer
    WCHAR pTemp[MAX_REG_VAL_SIZE];          // temp buffer


    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //    - lpFormat length > MAX_DATETIME_BUFFER if not null
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ( (pHashN == NULL) ||
         (cchTime < 0) ||
         ((lpTimeStr == NULL) && (cchTime != 0)) ||
         ((lpFormat) && (NlsStrLenW(lpFormat) >= MAX_DATETIME_BUFFER)) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //    - flags other than valid ones
    //    - lpFormat not NULL AND NoUserOverride flag is set
    //
    if ( (dwFlags & GTF_INVALID_FLAG) ||
         ((lpFormat != NULL) && (dwFlags & LOCALE_NOUSEROVERRIDE)) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  Set pFormat to point at the proper format string.
    //
    if (lpFormat == NULL)
    {
        //
        //  Get either the user's time format from the registry or
        //  the default time format from the locale file.
        //  This string may be a null string.
        //
        if (!(dwFlags & LOCALE_NOUSEROVERRIDE) &&
            GetUserInfo( Locale,
                         LOCALE_STIMEFORMAT,
                         FIELD_OFFSET(NLS_USER_INFO, sTimeFormat),
                         NLS_VALUE_STIMEFORMAT,
                         pTemp,
                         ARRAYSIZE(pTemp),
                         FALSE ))
        {
            pFormat = pTemp;
        }
        else
        {
            pFormat = (LPWORD)(pHashN->pLocaleHdr) +
                      pHashN->pLocaleHdr->STimeFormat;
        }
    }
    else
    {
        //
        //  Use the format string given by the caller.
        //
        pFormat = (LPWSTR)lpFormat;
    }

    //
    //  Get the current local system time if one is not given.
    //
    if (lpTime != NULL)
    {
        //
        //  Time is given by user.  Store in local structure and
        //  validate it.
        //
        LocalTime.wHour         = lpTime->wHour;
        LocalTime.wMinute       = lpTime->wMinute;
        LocalTime.wSecond       = lpTime->wSecond;
        LocalTime.wMilliseconds = lpTime->wMilliseconds;

        if (!IsValidTime(&LocalTime))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }
    else
    {
        GetLocalTime(&LocalTime);
    }

    //
    //  Parse the time format string.
    //
    Length = ParseTime( pHashN,
                        &LocalTime,
                        pFormat,
                        pString,
                        dwFlags );

    //
    //  Check cchTime for size of given buffer.
    //
    if (cchTime == 0)
    {
        //
        //  If cchTime is 0, then we can't use lpTimeStr.  In this
        //  case, we simply want to return the length (in characters) of
        //  the string to be copied.
        //
        return (Length);
    }
    else if (cchTime < Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }
    else if (0 == Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written. A good candidate for a return of
        //  ERROR_STACK_BUFFER_OVERRUN but thats a bit too much information
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Copy the time string to lpTimeStr and null terminate it.
    //  Return the number of characters copied.
    //
    if(FAILED(StringCchCopyW(lpTimeStr, Length, pString)))
    {
        //
        // Failure should in theory be impossible, but if we ignore the
        // return value, PREfast will complain.
        //
        SetLastError(ERROR_OUTOFMEMORY);
        return (0);
    }
    return (Length);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDateFormatW
//
//  Returns a properly formatted date string for the given locale.  It uses
//  either the system date or the specified date.  The user may specify
//  either the short date format or the long date format.  This call also
//  indicates how much memory is necessary to contain the desired information.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetDateFormatW(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate)

{
    PLOC_HASH pHashN;                       // ptr to LOC hash node
    LPWSTR pFormat;                         // ptr to format string
    SYSTEMTIME LocalDate;                   // local date structure
    int Length = 0;                         // number of characters written
    WCHAR pString[MAX_DATETIME_BUFFER];     // ptr to temporary buffer
    BOOL fAltCalendar;                      // if alternate cal flag set
    LPWSTR pOptCal;                         // ptr to optional calendar
    PCAL_INFO pCalInfo;                     // ptr to calendar info
    CALID CalNum = 0;                       // calendar number
    ULONG CalDateOffset;                    // offset to calendar data
    ULONG LocDateOffset;                    // offset to locale data
    SIZE_T CacheOffset = 0;                 // Offset to field in the cache.
    LPWSTR pValue;                          // ptr to registry value to get
    WCHAR pTemp[MAX_REG_VAL_SIZE];          // temp buffer
    BOOL fLunarLeap = FALSE;                // if Hebrew Lunar leap year
    LCTYPE LCType;


    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //    - lpFormat length > MAX_DATETIME_BUFFER if not null
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ( (pHashN == NULL) ||
         (cchDate < 0) ||
         ((lpDateStr == NULL) && (cchDate != 0)) ||
         ((lpFormat) && (NlsStrLenW(lpFormat) >= MAX_DATETIME_BUFFER)) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //    - flags other than valid ones
    //    - more than one of either ltr reading or rtl reading
    //    - lpFormat not NULL AND flags not zero
    //
    if ( (dwFlags & GDF_INVALID_FLAG) ||
         (MORE_THAN_ONE(dwFlags, GDF_SINGLE_FLAG)) ||
         ((lpFormat != NULL) &&
          (dwFlags & (DATE_SHORTDATE | DATE_LONGDATE |
                      DATE_YEARMONTH | LOCALE_NOUSEROVERRIDE))) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  See if the alternate calendar should be used.
    //
    if (fAltCalendar = (dwFlags & DATE_USE_ALT_CALENDAR))
    {
        //
        //  Get the default optional calendar.
        //
        pOptCal = (LPWORD)(pHashN->pLocaleHdr) +
                  pHashN->pLocaleHdr->IOptionalCal;

        //
        //  If there is an optional calendar, store the calendar id.
        //
        if (((POPT_CAL)pOptCal)->CalId != CAL_NO_OPTIONAL)
        {
            CalNum = ((POPT_CAL)pOptCal)->CalId;
        }
    }

    //
    //  If there was no alternate calendar, then try (in order):
    //     - the user's calendar type
    //     - the system default calendar type
    //
    if (CalNum == 0)
    {
        //
        //  Get the user's calendar type.
        //
        if ( !(dwFlags & LOCALE_NOUSEROVERRIDE) &&
             GetUserInfo( Locale,
                          LOCALE_ICALENDARTYPE,
                          FIELD_OFFSET(NLS_USER_INFO, iCalType),
                          NLS_VALUE_ICALENDARTYPE,
                          pTemp,
                          ARRAYSIZE(pTemp),
                          TRUE ) &&
             (pOptCal = IsValidCalendarTypeStr( pHashN, pTemp )) )
        {
            CalNum = ((POPT_CAL)pOptCal)->CalId;
        }
        else
        {
            //
            //  Get the system default calendar type.
            //
            NLS_STRING_TO_INTEGER( CalNum,
                                   pHashN->pLocaleFixed->szICalendarType );
        }
    }

    //
    //  Get the pointer to the appropriate calendar information.
    //
    if (GetCalendar(CalNum, &pCalInfo))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Set pFormat to point at the proper format string.
    //
    if (lpFormat == NULL)
    {
        //
        //  Find out which flag is set and save the appropriate
        //  information.
        //
        switch (dwFlags & (DATE_SHORTDATE | DATE_LONGDATE | DATE_YEARMONTH))
        {
            case ( 0 ) :
            case ( DATE_SHORTDATE ) :
            {
                //
                //  Get the offset values for the shortdate.
                //
                CalDateOffset = (ULONG)FIELD_OFFSET(CALENDAR_VAR, SShortDate);
                LocDateOffset = (ULONG)FIELD_OFFSET(LOCALE_VAR, SShortDate);
                CacheOffset = FIELD_OFFSET(NLS_USER_INFO, sShortDate);
                pValue = NLS_VALUE_SSHORTDATE;
                LCType = LOCALE_SSHORTDATE;

                break;
            }
            case ( DATE_LONGDATE ) :
            {
                //
                //  Get the offset values for the longdate.
                //
                CalDateOffset = (ULONG)FIELD_OFFSET(CALENDAR_VAR, SLongDate);
                LocDateOffset = (ULONG)FIELD_OFFSET(LOCALE_VAR, SLongDate);
                CacheOffset = FIELD_OFFSET(NLS_USER_INFO, sLongDate);
                pValue = NLS_VALUE_SLONGDATE;
                LCType = LOCALE_SLONGDATE;

                break;
            }
            case ( DATE_YEARMONTH ) :
            {
                //
                //  Get the offset values for the year/month.
                //
                CalDateOffset = (ULONG)FIELD_OFFSET(CALENDAR_VAR, SYearMonth);
                LocDateOffset = (ULONG)FIELD_OFFSET(LOCALE_VAR, SYearMonth);
                CacheOffset = FIELD_OFFSET(NLS_USER_INFO, sYearMonth);
                pValue = NLS_VALUE_SYEARMONTH;
                LCType = LOCALE_SYEARMONTH;

                break;
            }
            default :
            {
                SetLastError(ERROR_INVALID_FLAGS);
                return (0);
            }
        }

        //
        //  Get the proper format string for the given locale.
        //  This string may be a null string.
        //
        pFormat = NULL;
        if (fAltCalendar && (CalNum != CAL_GREGORIAN))
        {
            pFormat = (LPWORD)pCalInfo +
                      *((LPWORD)((LPBYTE)(pCalInfo) + CalDateOffset));

            if (*pFormat == 0)
            {
                pFormat = NULL;
            }
        }

        if (pFormat == NULL)
        {
            if (!(dwFlags & LOCALE_NOUSEROVERRIDE) &&
                GetUserInfo(Locale, LCType, CacheOffset, pValue, pTemp, ARRAYSIZE(pTemp), TRUE))
            {
                pFormat = pTemp;
            }
            else
            {
                pFormat = (LPWORD)pCalInfo +
                          *((LPWORD)((LPBYTE)(pCalInfo) + CalDateOffset));

                if (*pFormat == 0)
                {
                    pFormat = (LPWORD)(pHashN->pLocaleHdr) +
                              *((LPWORD)((LPBYTE)(pHashN->pLocaleHdr) +
                                         LocDateOffset));
                }
            }
        }
    }
    else
    {
        //
        //  Use the format string given by the caller.
        //
        pFormat = (LPWSTR)lpFormat;
    }

    //
    //  Get the current local system date if one is not given.
    //
    if (lpDate != NULL)
    {
        //
        //  Date is given by user.  Store in local structure and
        //  validate it.
        //
        LocalDate.wYear      = lpDate->wYear;
        LocalDate.wMonth     = lpDate->wMonth;
        LocalDate.wDayOfWeek = lpDate->wDayOfWeek;
        LocalDate.wDay       = lpDate->wDay;

        if (!IsValidDate(&LocalDate))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }
    else
    {
        GetLocalTime(&LocalDate);
    }

    //
    //  See if we're dealing with the Hijri or the Hebrew calendar.
    //
    if (CalNum == CAL_HIJRI)
    {
        GetHijriDate(&LocalDate, dwFlags);
    }
    else if (CalNum == CAL_HEBREW)
    {
        if (!GetHebrewDate(&LocalDate, &fLunarLeap))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    //
    //  Parse the date format string.
    //
    Length = ParseDate( pHashN,
                        dwFlags,
                        &LocalDate,
                        pFormat,
                        pString,
                        CalNum,
                        (PCALENDAR_VAR)pCalInfo,
                        fLunarLeap );

    //
    //  Check cchDate for size of given buffer.
    //
    if (cchDate == 0)
    {
        //
        //  If cchDate is 0, then we can't use lpDateStr.  In this
        //  case, we simply want to return the length (in characters) of
        //  the string to be copied.
        //
        return (Length);
    }
    else if (cchDate < Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }
    else if (0 == Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written. A good candidate for a return of
        //  ERROR_STACK_BUFFER_OVERRUN but thats a bit too much information
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    //
    //  Copy the date string to lpDateStr and null terminate it.
    //  Return the number of characters copied.
    //
    if(FAILED(StringCchCopyW(lpDateStr, Length, pString)))
    {
        //
        // Failure should in theory be impossible, but if we ignore the
        // return value, PREfast will complain.
        //
        SetLastError(ERROR_OUTOFMEMORY);
        return (0);
    }
    return (Length);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  IsValidTime
//
//  Returns TRUE if the given time is valid.  Otherwise, it returns FALSE.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidTime(
    LPSYSTEMTIME pTime)

{
    //
    //  Check for invalid time values.
    //
    if ( (pTime->wHour > 23) ||
         (pTime->wMinute > 59) ||
         (pTime->wSecond > 59) ||
         (pTime->wMilliseconds > 999) )
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidDate
//
//  Returns TRUE if the given date is valid.  Otherwise, it returns FALSE.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidDate(
    LPSYSTEMTIME pDate)

{
    LARGE_INTEGER Time;           // time as a large integer
    TIME_FIELDS TimeFields;       // time fields structure


    //
    //  Set up time fields structure with the given date.
    //  Only want to check the DATE values, so pass in a valid time.
    //
    TimeFields.Year         = pDate->wYear;
    TimeFields.Month        = pDate->wMonth;
    TimeFields.Day          = pDate->wDay;
    TimeFields.Hour         = 0;
    TimeFields.Minute       = 0;
    TimeFields.Second       = 0;
    TimeFields.Milliseconds = 0;

    //
    //  Check for invalid date values.
    //
    //  NOTE:  This routine ignores the Weekday field.
    //
    if (!RtlTimeFieldsToTime(&TimeFields, &Time))
    {
        return (FALSE);
    }

    //
    //  Make sure the given day of the week is valid for the given date.
    //
    RtlTimeToTimeFields(&Time, &TimeFields);
    pDate->wDayOfWeek = TimeFields.Weekday;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCalendarYear
//
//  Adjusts the given year to the given calendar's year.
//
//  10-15-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

WORD GetCalendarYear(
    LPWORD *ppRange,
    CALID CalNum,
    PCALENDAR_VAR pCalInfo,
    WORD Year,
    WORD Month,
    WORD Day)

{
    LPWORD pRange;                // ptr to range position
    LPWORD pEndRange;             // ptr to the end of the range


    //
    //  Initialize range pointer.
    //
    *ppRange = NULL;

    //
    //  Adjust the year based on the given calendar
    //
    switch (CalNum)
    {
        case ( 0 ) :
        case ( CAL_GREGORIAN ) :
        case ( CAL_GREGORIAN_US ) :
        default :
        {
            //
            //  Year value is not changed.
            //
            break;
        }
        case ( CAL_JAPAN ) :
        case ( CAL_TAIWAN ) :
        {
            //
            //  Get pointer to ranges.
            //
            pRange = ((LPWORD)pCalInfo) + pCalInfo->SEraRanges;
            pEndRange = ((LPWORD)pCalInfo) + pCalInfo->SShortDate;

            //
            //  Find the appropriate range.
            //
            while (pRange < pEndRange)
            {
                if ((Year > ((PERA_RANGE)pRange)->Year) ||
                    ((Year == ((PERA_RANGE)pRange)->Year) &&
                     ((Month > ((PERA_RANGE)pRange)->Month) ||
                      ((Month == ((PERA_RANGE)pRange)->Month) &&
                       (Day >= ((PERA_RANGE)pRange)->Day)))))
                {
                    break;
                }

                pRange += ((PERA_RANGE)pRange)->Offset;
            }

            //
            //  Make sure the year is within the given ranges.  If it
            //  is not, then leave the year in the Gregorian format.
            //
            if (pRange < pEndRange)
            {
                //
                //  Convert the year to the appropriate Era year.
                //     Year = Year - EraYear + 1
                //
                Year = Year - ((PERA_RANGE)pRange)->Year + 1;

                //
                //  Save the pointer to the range.
                //
                *ppRange = pRange;
            }

            break;
        }
        case ( CAL_KOREA ) :
        case ( CAL_THAI ) :
        {
            //
            //  Get the first range.
            //
            pRange = ((LPWORD)pCalInfo) + pCalInfo->SEraRanges;

            //
            //  Add the year offset to the given year.
            //     Year = Year + EraYear
            //
            Year += ((PERA_RANGE)pRange)->Year;

            //
            //  Save the range.
            //
            *ppRange = pRange;

            break;
        }
    }

    //
    //  Return the year.
    //
    return (Year);
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseTime
//
//  Parses the time format string and puts the properly formatted
//  local time into the given string buffer.  It returns the number of
//  characters written to the string buffer.
//
//  SECURITY: If an attempt is made to overrun our static buffer, return 0 
//  to trigger failure.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseTime(
    PLOC_HASH pHashN,
    LPSYSTEMTIME pLocalTime,
    LPWSTR pFormat,
    LPWSTR pTimeStr,
    DWORD dwFlags)

{
    LPWSTR pPos;                       // ptr to pTimeStr current position
    LPWSTR pLastPos;                   // ptr to pTimeStr last valid position
    LPWSTR pLastFormatPos;             // ptr to pFormat last parsed string
    int Repeat;                        // number of repetitions of same letter
    int BufferedSpaces;                // buffered spaces to copy to output buffer
    WORD wHour;                        // hour
    WCHAR wchar;                       // character in format string
    LPWSTR pAMPM;                      // ptr to AM/PM designator
    WCHAR pTemp[MAX_REG_VAL_SIZE];     // temp buffer
    BOOL bInQuote;                     // are we in a quoted string or not ?
    size_t cchRemaining;               // Count of how many charactrs are left in pTimeStr
    size_t cchLastRemaining;           // How many charactrs are left in pTimeStr at last valid pos


    //
    //  Initialize position pointer.
    //
    pPos = pTimeStr;
    pLastPos = pPos;
    pLastFormatPos = pFormat;
    cchRemaining = MAX_DATETIME_BUFFER;
    cchLastRemaining = cchRemaining;

    BufferedSpaces = 0L;

    //
    //  Parse through loop and store the appropriate time information
    //  in the pTimeStr buffer.
    //
    while (*pFormat)
    {
        switch (*pFormat)
        {
            case ( L'h' ) :
            {
                //
                //  Check for forced 24 hour time format.
                //
                wHour = pLocalTime->wHour;
                if (!(dwFlags & TIME_FORCE24HOURFORMAT))
                {
                    //
                    //  Use 12 hour format.
                    //
                    if (!(wHour %= 12))
                    {
                        wHour = 12;
                    }
                }

                //
                //  Get the number of 'h' repetitions in the format string.
                //
                pFormat++;
                for (Repeat = 0; (*pFormat == L'h'); Repeat++, pFormat++)
                    ;

                //
                //  Put any buffered spaces into the output buffer.
                //
                while (BufferedSpaces > 0)
                {
                    if( cchRemaining <= 1 )
                    {
                        // Our static buffer will be overrun if we continue, so bail
                        return(0);
                    }
                    BufferedSpaces--;
                    *pPos++ = L' ';
                    cchRemaining--;
                }

                switch (Repeat)
                {
                    case ( 0 ) :
                    {
                        //
                        //  Use NO leading zero for the hour.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        NLS_PAD_INT_TO_UNICODE_STR( wHour,
                                                    10,
                                                    1,
                                                    pPos,
                                                    cchRemaining,
                                                    0 );

                        break;
                    }
                    case ( 1 ) :
                    default :
                    {
                        //
                        //  Use leading zero for the hour.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        NLS_PAD_INT_TO_UNICODE_STR( wHour,
                                                    10,
                                                    2,
                                                    pPos,
                                                    cchRemaining,
                                                    0 );

                        break;
                    }
                }

                //
                //  Save the last position in case one of the NO_xxx
                //  flags is set.
                //
                pLastPos = pPos;
                cchLastRemaining = cchRemaining;
                pLastFormatPos = pFormat;

                break;
            }
            case ( L'H' ) :
            {
                //
                //  Get the number of 'H' repetitions in the format string.
                //
                pFormat++;
                for (Repeat = 0; (*pFormat == L'H'); Repeat++, pFormat++)
                    ;

                //
                //  Put any buffered spaces into the output buffer.
                //
                while (BufferedSpaces > 0)
                {
                    if( cchRemaining <= 1 )
                    {
                        // Our static buffer will be overrun if we continue, so bail
                        return(0);
                    }
                    BufferedSpaces--;
                    *pPos++ = L' ';
                    cchRemaining--;
                }

                switch (Repeat)
                {
                    case ( 0 ) :
                    {
                        //
                        //  Use NO leading zero for the hour.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        NLS_PAD_INT_TO_UNICODE_STR( pLocalTime->wHour,
                                                    10,
                                                    1,
                                                    pPos,
                                                    cchRemaining,
                                                    0 );

                        break;
                    }
                    case ( 1 ) :
                    default :
                    {
                        //
                        //  Use leading zero for the hour.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        NLS_PAD_INT_TO_UNICODE_STR( pLocalTime->wHour,
                                                    10,
                                                    2,
                                                    pPos,
                                                    cchRemaining,
                                                    0 );

                        break;
                    }
                }

                //
                //  Save the last position in case one of the NO_xxx
                //  flags is set.
                //
                pLastPos = pPos;
                cchLastRemaining = cchRemaining;
                pLastFormatPos = pFormat;

                break;
            }
            case ( L'm' ) :
            {
                //
                //  Get the number of 'm' repetitions in the format string.
                //
                pFormat++;
                for (Repeat = 0; (*pFormat == L'm'); Repeat++, pFormat++)
                    ;

                //
                //  If the flag TIME_NOMINUTESORSECONDS is set, then
                //  skip over the minutes.
                //
                if (dwFlags & TIME_NOMINUTESORSECONDS)
                {
                    //
                    //  Reset position pointer to last postion and break
                    //  out of this case statement.
                    //
                    //  This will remove any separator(s) between the
                    //  hours and minutes.
                    //
                    //  1- Go backward and leave only quoted text
                    //  2- Go forward and remove everything until hitting {hHt}
                    //
                    bInQuote = FALSE;
                    while (pFormat != pLastFormatPos)
                    {
                        if (*pLastFormatPos == NLS_CHAR_QUOTE)
                        {
                            bInQuote = !bInQuote;
                            pLastFormatPos++;
                            continue;
                        }
                        if (bInQuote)
                        {
                            *pLastPos = *pLastFormatPos;
                            pLastPos++;
                            cchLastRemaining--;
                        }
                        pLastFormatPos++;
                    }

                    bInQuote = FALSE;
                    BufferedSpaces = 0;
                    while (*pFormat)
                    {
                        if (*pLastFormatPos == NLS_CHAR_QUOTE)
                        {
                            bInQuote = !bInQuote;
                        }

                        if (!bInQuote)
                        {
                            if (*pFormat == L' ')
                            {
                                BufferedSpaces++;
                            }
                            else
                            {
                                if ((*pFormat == L'h') ||
                                    (*pFormat == L'H') ||
                                    (*pFormat == L't'))
                                {
                                    break;
                                }
                            }
                        }
                        pFormat++;
                    }

                    pPos = pLastPos;
                    cchRemaining = cchLastRemaining;
                    break;
                }

                //
                //  Put any buffered spaces into the output buffer.
                //
                while (BufferedSpaces > 0)
                {
                    if( cchRemaining <= 1 )
                    {
                        // Our static buffer will be overrun if we continue, so bail
                        return(0);
                    }
                    BufferedSpaces--;
                    *pPos++ = L' ';
                    cchRemaining--;
                }

                switch (Repeat)
                {
                    case ( 0 ) :
                    {
                        //
                        //  Use NO leading zero for the minute.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        NLS_PAD_INT_TO_UNICODE_STR( pLocalTime->wMinute,
                                                    10,
                                                    1,
                                                    pPos,
                                                    cchRemaining,
                                                    0 );

                        break;
                    }
                    case ( 1 ) :
                    default :
                    {
                        //
                        //  Use leading zero for the minute.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        NLS_PAD_INT_TO_UNICODE_STR( pLocalTime->wMinute,
                                                    10,
                                                    2,
                                                    pPos,
                                                    cchRemaining,
                                                    0 );

                        break;
                    }
                }

                //
                //  Save the last position in case one of the NO_xxx
                //  flags is set.
                //
                pLastPos = pPos;
                cchLastRemaining = cchRemaining;
                pLastFormatPos = pFormat;

                break;
            }
            case ( L's' ) :
            {
                //
                //  Get the number of 's' repetitions in the format string.
                //
                pFormat++;
                for (Repeat = 0; (*pFormat == L's'); Repeat++, pFormat++)
                    ;

                //
                //  If the flag TIME_NOMINUTESORSECONDS and/or TIME_NOSECONDS
                //  is set, then skip over the seconds.
                //
                if (dwFlags & (TIME_NOMINUTESORSECONDS | TIME_NOSECONDS))
                {
                    //
                    //  Reset position pointer to last postion and break
                    //  out of this case statement.
                    //
                    //  This will remove any separator(s) between the
                    //  minutes and seconds.
                    //

                    //
                    // 1- Go backward and leave only quoted text
                    // 2- Go forward and remove everything till hitting {hmHt}
                    //
                    bInQuote = FALSE;
                    while (pFormat != pLastFormatPos)
                    {
                        if (*pLastFormatPos == NLS_CHAR_QUOTE)
                        {
                            bInQuote = !bInQuote;
                            pLastFormatPos++;
                            continue;
                        }
                        if (bInQuote)
                        {
                            *pLastPos = *pLastFormatPos;
                            pLastPos++;
                            cchLastRemaining--;
                        }
                        pLastFormatPos++;
                    }

                    bInQuote = FALSE;
                    BufferedSpaces = 0;
                    while (*pFormat)
                    {
                        if (*pLastFormatPos == NLS_CHAR_QUOTE)
                        {
                            bInQuote = !bInQuote;
                        }

                        if (!bInQuote)
                        {
                            if (*pFormat == L' ')
                            {
                                BufferedSpaces++;
                            }
                            else
                            {
                                if ((*pFormat == L'h') ||
                                    (*pFormat == L'H') ||
                                    (*pFormat == L't') ||
                                    (*pFormat == L'm'))
                                {
                                    break;
                                }
                            }
                        }
                        pFormat++;
                    }

                    pPos = pLastPos;
                    cchRemaining = cchLastRemaining;
                    break;
                }

                //
                //  Put any buffered spaces into the output buffer.
                //
                while (BufferedSpaces > 0)
                {
                    if( cchRemaining <= 1 )
                    {
                        // Our static buffer will be overrun if we continue, so bail
                        return(0);
                    }
                    BufferedSpaces--;
                    *pPos++ = L' ';
                    cchRemaining--;
                }

                switch (Repeat)
                {
                    case ( 0 ) :
                    {
                        //
                        //  Use NO leading zero for the second.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        NLS_PAD_INT_TO_UNICODE_STR( pLocalTime->wSecond,
                                                    10,
                                                    1,
                                                    pPos,
                                                    cchRemaining,
                                                    0 );

                        break;
                    }
                    case ( 1 ) :
                    default :
                    {
                        //
                        //  Use leading zero for the second.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        NLS_PAD_INT_TO_UNICODE_STR( pLocalTime->wSecond,
                                                    10,
                                                    2,
                                                    pPos,
                                                    cchRemaining,
                                                    0 );

                        break;
                    }
                }

                //
                //  Save the last position in case one of the NO_xxx
                //  flags is set.
                //
                pLastPos = pPos;
                cchLastRemaining = cchRemaining;
                pLastFormatPos = pFormat;

                break;
            }
            case ( L't' ) :
            {
                //
                //  Get the number of 't' repetitions in the format string.
                //
                pFormat++;
                for (Repeat = 0; (*pFormat == L't'); Repeat++, pFormat++)
                    ;

                //
                //  Put any buffered spaces into the output buffer.
                //
                while (BufferedSpaces > 0)
                {
                    if( cchRemaining <= 1 )
                    {
                        // Our static buffer will be overrun if we continue, so bail
                        return(0);
                    }
                    BufferedSpaces--;
                    *pPos++ = L' ';
                    cchRemaining--;
                }

                //
                //  If the flag TIME_NOTIMEMARKER is set, then skip over
                //  the time marker info.
                //
                if (dwFlags & TIME_NOTIMEMARKER)
                {
                    //
                    //  Reset position pointer to last postion.
                    //
                    //  This will remove any separator(s) between the
                    //  time (hours, minutes, seconds) and the time
                    //  marker.
                    //
                    pPos = pLastPos;
                    cchRemaining = cchLastRemaining;
                    pLastFormatPos = pFormat;

                    //
                    //  Increment the format pointer until it reaches
                    //  an h, H, m, or s.  This will remove any
                    //  separator(s) following the time marker.
                    //
                    while ( (wchar = *pFormat) &&
                            (wchar != L'h') &&
                            (wchar != L'H') &&
                            (wchar != L'm') &&
                            (wchar != L's') )
                    {
                        pFormat++;
                    }

                    //
                    //  Break out of this case statement.
                    //
                    break;
                }
                else
                {
                    //
                    //  Get AM/PM designator.
                    //  This string may be a null string.
                    //
                    if (pLocalTime->wHour < 12)
                    {
                        if (!(dwFlags & LOCALE_NOUSEROVERRIDE) &&
                            GetUserInfo( pHashN->Locale,
                                         LOCALE_S1159,
                                         FIELD_OFFSET(NLS_USER_INFO, s1159),
                                         NLS_VALUE_S1159,
                                         pTemp,
                                         ARRAYSIZE(pTemp),
                                         FALSE ))
                        {
                            pAMPM = pTemp;
                        }
                        else
                        {
                            pAMPM = (LPWORD)(pHashN->pLocaleHdr) +
                                    pHashN->pLocaleHdr->S1159;
                        }
                    }
                    else
                    {
                        if (!(dwFlags & LOCALE_NOUSEROVERRIDE) &&
                            GetUserInfo( pHashN->Locale,
                                         LOCALE_S2359,
                                         FIELD_OFFSET(NLS_USER_INFO, s2359),
                                         NLS_VALUE_S2359,
                                         pTemp,
                                         ARRAYSIZE(pTemp),
                                         FALSE ))
                        {
                            pAMPM = pTemp;
                        }
                        else
                        {
                            pAMPM = (LPWORD)(pHashN->pLocaleHdr) +
                                    pHashN->pLocaleHdr->S2359;
                        }
                    }

                    if (*pAMPM == 0)
                    {
                        //
                        //  Reset position pointer to last postion and break
                        //  out of this case statement.
                        //
                        //  This will remove any separator(s) between the
                        //  time (hours, minutes, seconds) and the time
                        //  marker.
                        //
                        pPos = pLastPos;
                        cchRemaining = cchLastRemaining;
                        pLastFormatPos = pFormat;

                        break;
                    }
                }

                switch (Repeat)
                {
                    case ( 0 ) :
                    {
                        if( cchRemaining <= 1 )
                        {
                            // Our static buffer will be overrun if we continue, so bail
                            return(0);
                        }

                        //
                        //  One letter of AM/PM designator.
                        //
                        *pPos = *pAMPM;
                        pPos++;
                        cchRemaining--;

                        break;
                    }
                    case ( 1 ) :
                    default :
                    {
                        //
                        //  Use entire AM/PM designator string.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        NLS_COPY_UNICODE_STR(pPos, cchRemaining, pAMPM, 0); 
                        break;
                    }
                }

                //
                //  Save the last position in case one of the NO_xxx
                //  flags is set.
                //
                pLastPos = pPos;
                cchLastRemaining = cchRemaining;
                pLastFormatPos = pFormat;

                break;
            }
            case ( NLS_CHAR_QUOTE ) :
            {
                //
                //  Any text enclosed within single quotes should be left
                //  in the time string in its exact form (without the
                //  quotes), unless it is an escaped single quote ('').
                //
                pFormat++;
                while (*pFormat)
                {
                    if (*pFormat != NLS_CHAR_QUOTE)
                    {
                        if( cchRemaining <= 1 )
                        {
                            // Our static buffer will be overrun if we continue, so bail
                            return(0);
                        }

                        //
                        //  Still within the single quote, so copy
                        //  the character to the buffer.
                        //
                        *pPos = *pFormat;
                        pFormat++;
                        pPos++;
                        cchRemaining--;
                    }
                    else
                    {
                        //
                        //  Found another quote, so skip over it.
                        //
                        pFormat++;

                        //
                        //  Make sure it's not an escaped single quote.
                        //
                        if (*pFormat == NLS_CHAR_QUOTE)
                        {
                            if( cchRemaining <= 1 )
                            {
                                // Our static buffer will be overrun if we continue, so bail
                                return(0);
                            }

                            //
                            //  Escaped single quote, so just write the
                            //  single quote.
                            //
                            *pPos = *pFormat;
                            pFormat++;
                            pPos++;
                            cchRemaining--;
                        }
                        else
                        {
                            //
                            //  Found the end quote, so break out of loop.
                            //
                            break;
                        }
                    }
                }

                break;
            }

            default :
            {
                if( cchRemaining <= 1 )
                {
                    // Our static buffer will be overrun if we continue, so bail
                    return(0);
                }

                //
                //  Store the character in the buffer.  Should be the
                //  separator, but copy it even if it isn't.
                //
                *pPos = *pFormat;
                pFormat++;
                pPos++;
                cchRemaining--;

                break;
            }
        }
    }

    //
    //  Zero terminate the string.
    //
    *pPos = 0;

    //
    //  Return the number of characters written to the buffer, including
    //  the null terminator.
    //
    return ((int)((pPos - pTimeStr) + 1));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseDate
//
//  Parses the date format string and puts the properly formatted
//  local date into the given string buffer.  It returns the number of
//  characters written to the string buffer.
//
//  SECURITY: If an attempt is made to overrun our static buffer, return 0 
//  to trigger failure.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseDate(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPSYSTEMTIME pLocalDate,
    LPWSTR pFormat,
    LPWSTR pDateStr,
    CALID CalNum,
    PCALENDAR_VAR pCalInfo,
    BOOL fLunarLeap)

{
    LPWSTR pPos;                  // ptr to pDateStr current position
    LPWSTR pTemp;                 // ptr to temp position in format string
    int Repeat;                   // number of repetitions of same letter
    LPWORD pIncr;                 // ptr to increment amount (day, month)
    WORD Incr;                    // increment amount
    BOOL fDayExists = FALSE;      // numeric day precedes or follows month
    WORD Year;                    // year value
    LPWORD pRange = NULL;         // ptr to era ranges
    LPWORD pInfo;                 // ptr to locale or calendar info
    LPWORD pInfoC;                // ptr to calendar info
    WCHAR szHebrew[10];           // buffer for Hebrew
    size_t cchRemaining;          // Count of how many charactrs are left in pDateStr


    //
    //  Initialize position pointer.
    //
    pPos = pDateStr;
    cchRemaining = MAX_DATETIME_BUFFER;

    //
    //  Parse through loop and store the appropriate date information
    //  in the pDateStr buffer.
    //
    while (*pFormat)
    {
        switch (*pFormat)
        {
            case ( L'd' ) :
            {
                //
                //  Insert the layout direction flag, if requested.
                //
                NLS_INSERT_BIDI_MARK(pPos, dwFlags, cchRemaining, 0);

                //
                //  Get the number of 'd' repetitions in the format string.
                //
                pFormat++;
                for (Repeat = 0; (*pFormat == L'd'); Repeat++, pFormat++)
                    ;

                switch (Repeat)
                {
                    case ( 0 ) :
                    case ( 1 ) :
                    {
                        //
                        //  Set flag for day preceding month.  The flag
                        //  will be used when the MMMM case follows the
                        //  d or dd case.
                        //
                        fDayExists = TRUE;

                        //
                        //  Special case the Hebrew calendar.
                        //
                        if (CalNum == CAL_HEBREW)
                        {
                            //
                            //  Convert Day number to Hebrew letter and
                            //  write it to the buffer.
                            //
                            if( ! (NumberToHebrewLetter( pLocalDate->wDay,
                                                          szHebrew,
                                                          ARRAYSIZE(szHebrew) )))
                            {
                                //
                                // Operation tried to overrun the static buffer on the stack
                                //
                                return(0);
                            }

                            NLS_COPY_UNICODE_STR(pPos, cchRemaining, szHebrew, 0);
                            break;
                        }

                        //
                        //  Repeat Value:
                        //    0 : Use NO leading zero for the day of the month
                        //    1 : Use leading zero for the day of the month
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        NLS_PAD_INT_TO_UNICODE_STR( pLocalDate->wDay,
                                                    10,
                                                    (UINT)(Repeat + 1),
                                                    pPos,
                                                    cchRemaining,
                                                    0 );

                        break;
                    }
                    case ( 2 ) :
                    {
                        //
                        //  Set flag for day preceding month to be FALSE.
                        //
                        fDayExists = FALSE;

                        //
                        //  Get the abbreviated name for the day of the
                        //  week.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        //  NOTE: LocalTime structure uses:
                        //           0 = Sun, 1 = Mon, etc.
                        //        Locale file uses:
                        //           SAbbrevDayName1 = Mon, etc.
                        //
                        if (pCalInfo->IfNames &&
                            (pHashN->Locale != MAKELCID(MAKELANGID(LANG_DIVEHI,SUBLANG_DEFAULT),SORT_DEFAULT )))
                        {
                            pInfo = (LPWORD)pCalInfo;
                            pIncr = &(pCalInfo->SAbbrevDayName1);
                        }
                        else
                        {
                            pInfo = (LPWORD)(pHashN->pLocaleHdr);
                            pIncr = &(pHashN->pLocaleHdr->SAbbrevDayName1);
                        }
                        pIncr += (((pLocalDate->wDayOfWeek) + 6) % 7);

                        //
                        //  Copy the abbreviated day name.
                        //
                        NLS_COPY_UNICODE_STR(pPos, cchRemaining, ((LPWORD)(pInfo) + *pIncr), 0); 

                        break;
                    }
                    case ( 3 ) :
                    default :
                    {
                        //
                        //  Set flag for day preceding month to be FALSE.
                        //
                        fDayExists = FALSE;

                        //
                        //  Get the full name for the day of the week.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        //  NOTE: LocalTime structure uses:
                        //           0 = Sunday, 1 = Monday, etc.
                        //        Locale file uses:
                        //           SAbbrevDayName1 = Monday, etc.
                        //
                        if (pCalInfo->IfNames &&
                            (pHashN->Locale != MAKELCID(MAKELANGID(LANG_DIVEHI,SUBLANG_DEFAULT),SORT_DEFAULT )))
                        {
                            pInfo = (LPWORD)pCalInfo;
                            pIncr = &(pCalInfo->SDayName1);
                        }
                        else
                        {
                            pInfo = (LPWORD)(pHashN->pLocaleHdr);
                            pIncr = &(pHashN->pLocaleHdr->SDayName1);
                        }
                        pIncr += (((pLocalDate->wDayOfWeek) + 6) % 7);

                        //
                        //  Copy the abbreviated day name.
                        //
                        NLS_COPY_UNICODE_STR(pPos, cchRemaining, ((LPWORD)(pInfo) + *pIncr), 0);

                        break;
                    }
                }

                break;
            }
            case ( L'M' ) :
            {
                //
                //  Insert the layout direction flag, if requested.
                //
                NLS_INSERT_BIDI_MARK(pPos, dwFlags, cchRemaining, 0);

                //
                //  Get the number of 'M' repetitions in the format string.
                //
                pFormat++;
                for (Repeat = 0; (*pFormat == L'M'); Repeat++, pFormat++)
                    ;

                switch (Repeat)
                {
                    case ( 0 ) :
                    case ( 1 ) :
                    {
                        //
                        //  Special case the Hebrew calendar.
                        //
                        if (CalNum == CAL_HEBREW)
                        {
                            //
                            //  Convert Month number to Hebrew letter and
                            //  write it to the buffer.
                            //
                            if( ! (NumberToHebrewLetter( pLocalDate->wMonth,
                                                         szHebrew,
                                                         ARRAYSIZE(szHebrew) )))
                            {
                                //
                                // Operation tried to overrun the static buffer on the stack
                                //
                                return(0);
                            }

                            NLS_COPY_UNICODE_STR(pPos, cchRemaining, szHebrew, 0);

                            break;
                        }

                        //
                        //  Repeat Value:
                        //    0 : Use NO leading zero for the month
                        //    1 : Use leading zero for the month
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        NLS_PAD_INT_TO_UNICODE_STR( pLocalDate->wMonth,
                                                    10,
                                                    (UINT)(Repeat + 1),
                                                    pPos,
                                                    cchRemaining,
                                                    0 );

                        break;
                    }
                    case ( 2 ) :
                    case ( 3 ) :
                    default :
                    {
                        //
                        //  Check for abbreviated or full month name.
                        //
                        if (Repeat == 2)
                        {
                            pInfoC = &(pCalInfo->SAbbrevMonthName1);
                            pInfo  = &(pHashN->pLocaleHdr->SAbbrevMonthName1);
                        }
                        else
                        {
                            pInfoC = &(pCalInfo->SMonthName1);
                            pInfo  = &(pHashN->pLocaleHdr->SMonthName1);
                        }

                        //
                        //  Get the abbreviated name of the month.
                        //  The pPos pointer will be advanced in the macro.
                        //  The cchRemaining value will be updated in the macro.
                        //
                        if (pCalInfo->IfNames &&
                            (pHashN->Locale != MAKELCID(MAKELANGID(LANG_DIVEHI,SUBLANG_DEFAULT),SORT_DEFAULT )))
                        {
                            if ((CalNum == CAL_HEBREW) &&
                                (!fLunarLeap) &&
                                (pLocalDate->wMonth > NLS_HEBREW_JUNE))
                            {
                                //
                                //  Go passed Addar_B.
                                //
                                pIncr = (pInfoC) +
                                        (pLocalDate->wMonth);
                            }
                            else
                            {
                                pIncr = (pInfoC) +
                                        (pLocalDate->wMonth - 1);
                            }

                            //
                            //  Copy the abbreviated month name.
                            //
                            NLS_COPY_UNICODE_STR(pPos, cchRemaining, ((LPWORD)(pCalInfo) + *pIncr), 0);
                        }
                        else
                        {
                            pIncr = (pInfo) +
                                    (pLocalDate->wMonth - 1);

                            //
                            //  If we don't already have a numeric day
                            //  preceding the month name, then check for
                            //  a numeric day following the month name.
                            //
                            if (!fDayExists)
                            {
                                pTemp = pFormat;
                                while (*pTemp)
                                {
                                    if ((*pTemp == L'g') || (*pTemp == L'y'))
                                    {
                                        break;
                                    }
                                    if (*pTemp == L'd')
                                    {
                                        for (Repeat = 0;
                                             (*pTemp == L'd');
                                             Repeat++, pTemp++)
                                            ;
                                        if ((Repeat == 1) || (Repeat == 2))
                                        {
                                            fDayExists = TRUE;
                                        }
                                        break;
                                    }
                                    pTemp++;
                                }
                            }

                            //
                            //  Check for numeric day immediately preceding
                            //  or following the month name.
                            //
                            if (fDayExists)
                            {
                                Incr = *pIncr + 1 +
                                       NlsStrLenW(((LPWORD)(pHashN->pLocaleHdr) +
                                                  *pIncr));

                                if (Incr != *(pIncr + 1))
                                {
                                    //
                                    //  Copy the special month name -
                                    //  2nd one in list.
                                    //
                                    NLS_COPY_UNICODE_STR(pPos, cchRemaining, ((LPWORD)(pHashN->pLocaleHdr) + Incr), 0);
                                    break;
                                }
                            }

                            //
                            //  Just copy the month name.
                            //
                            NLS_COPY_UNICODE_STR(pPos, cchRemaining, ((LPWORD)(pHashN->pLocaleHdr) + *pIncr), 0);
                        }

                        break;
                    }
                }

                //
                //  Set flag for day preceding month to be FALSE.
                //
                fDayExists = FALSE;

                break;
            }
            case ( L'y' ) :
            {
                //
                //  Insert the layout direction flag, if requested.
                //
                NLS_INSERT_BIDI_MARK(pPos, dwFlags, cchRemaining, 0);

                //
                //  Get the number of 'y' repetitions in the format string.
                //
                pFormat++;
                for (Repeat = 0; (*pFormat == L'y'); Repeat++, pFormat++)
                    ;

                //
                //  Get proper year for calendar.
                //
                if (pCalInfo->NumRanges)
                {
                    if (!pRange)
                    {
                        //
                        //  Adjust the year for the given calendar.
                        //
                        Year = GetCalendarYear( &pRange,
                                                CalNum,
                                                pCalInfo,
                                                pLocalDate->wYear,
                                                pLocalDate->wMonth,
                                                pLocalDate->wDay );
                    }
                }
                else
                {
                    Year = pLocalDate->wYear;
                }

                //
                //  Special case the Hebrew calendar.
                //
                if (CalNum == CAL_HEBREW)
                {
                    //
                    //  Convert Year number to Hebrew letter and
                    //  write it to the buffer.
                    //
                    if( ! (NumberToHebrewLetter(Year, szHebrew, ARRAYSIZE(szHebrew))))
                    {
                        //
                        // Operation tried to overrun the static buffer on the stack
                        //
                        return(0);
                    }
                        
                    NLS_COPY_UNICODE_STR(pPos, cchRemaining, szHebrew, 0);
                }
                else
                {
                    //
                    //  Write the year string to the buffer.
                    //
                    switch (Repeat)
                    {
                        case ( 0 ) :
                        case ( 1 ) :
                        {
                            //
                            //  1-digit century or 2-digit century.
                            //  The pPos pointer will be advanced in the macro.
                            //  The cchRemaining value will be updated in the macro.
                            //
                            NLS_PAD_INT_TO_UNICODE_STR( (Year % 100),
                                                        10,
                                                        (UINT)(Repeat + 1),
                                                        pPos,
                                                        cchRemaining,
                                                        0 );

                            break;
                        }
                        case ( 2 ) :
                        case ( 3 ) :
                        default :
                        {
                            //
                            //  Full century.
                            //  The pPos pointer will be advanced in the macro.
                            //  The cchRemaining value will be updated in the macro.
                            //
                            NLS_PAD_INT_TO_UNICODE_STR( Year,
                                                        10,
                                                        2,
                                                        pPos,
                                                        cchRemaining,
                                                        0 );

                            break;
                        }
                    }
                }

                //
                //  Set flag for day preceding month to be FALSE.
                //
                fDayExists = FALSE;

                break;
            }
            case ( L'g' ) :
            {
                //
                //  Insert the layout direction flag, if requested.
                //
                NLS_INSERT_BIDI_MARK(pPos, dwFlags, cchRemaining, 0);

                //
                //  Get the number of 'g' repetitions in the format string.
                //
                //  NOTE: It doesn't matter how many g repetitions
                //        there are.  They all mean 'gg'.
                //
                pFormat++;
                while (*pFormat == L'g')
                {
                    pFormat++;
                }

                //
                //  Copy the era string for the current calendar.
                //
                if (pCalInfo->NumRanges)
                {
                    //
                    //  Make sure we have the pointer to the
                    //  appropriate range.
                    //
                    if (!pRange)
                    {
                        //
                        //  Get the pointer to the correct range and
                        //  adjust the year for the given calendar.
                        //
                        Year = GetCalendarYear( &pRange,
                                                CalNum,
                                                pCalInfo,
                                                pLocalDate->wYear,
                                                pLocalDate->wMonth,
                                                pLocalDate->wDay );
                    }

                    //
                    //  Copy the era string to the buffer, if one exists.
                    //
                    if (pRange)
                    {
                        NLS_COPY_UNICODE_STR(pPos, 
                                             cchRemaining, 
                                             ((PERA_RANGE)pRange)->pYearStr +
                                                NlsStrLenW(((PERA_RANGE)pRange)->pYearStr) + 1,
                                             0);
                    }
                }

                //
                //  Set flag for day preceding month to be FALSE.
                //
                fDayExists = FALSE;

                break;
            }
            case ( NLS_CHAR_QUOTE ) :
            {
                //
                //  Insert the layout direction flag, if requested.
                //
                NLS_INSERT_BIDI_MARK(pPos, dwFlags, cchRemaining, 0);

                //
                //  Any text enclosed within single quotes should be left
                //  in the date string in its exact form (without the
                //  quotes), unless it is an escaped single quote ('').
                //
                pFormat++;
                while (*pFormat)
                {
                    if (*pFormat != NLS_CHAR_QUOTE)
                    {
                        if( cchRemaining <= 1 )
                        {
                            // Our static buffer will be overrun if we continue, so bail
                            return(0);
                        }

                        //
                        //  Still within the single quote, so copy
                        //  the character to the buffer.
                        //
                        *pPos = *pFormat;
                        pFormat++;
                        pPos++;
                        cchRemaining--;
                    }
                    else
                    {
                        //
                        //  Found another quote, so skip over it.
                        //
                        pFormat++;

                        //
                        //  Make sure it's not an escaped single quote.
                        //
                        if (*pFormat == NLS_CHAR_QUOTE)
                        {
                            if( cchRemaining <= 1 )
                            {
                                // Our static buffer will be overrun if we continue, so bail
                                return(0);
                            }

                            //
                            //  Escaped single quote, so just write the
                            //  single quote.
                            //
                            *pPos = *pFormat;
                            pFormat++;
                            pPos++;
                            cchRemaining--;
                        }
                        else
                        {
                            //
                            //  Found the end quote, so break out of loop.
                            //
                            break;
                        }
                    }
                }

                break;
            }

            default :
            {
                if( cchRemaining <= 1 )
                {
                    // Our static buffer will be overrun if we continue, so bail
                    return(0);
                }

                //
                //  Store the character in the buffer.  Should be the
                //  separator, but copy it even if it isn't.
                //
                *pPos = *pFormat;
                pFormat++;
                pPos++;
                cchRemaining--;

                break;
            }
        }
    }

    //
    //  Zero terminate the string.
    //
    *pPos = 0;

    //
    //  Return the number of characters written to the buffer, including
    //  the null terminator.
    //
    return ((int)((pPos - pDateStr) + 1));
}




//-------------------------------------------------------------------------//
//                     MIDDLE EAST CALENDAR ROUTINES                       //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetAbsoluteDate
//
//  Gets the Absolute date for the given Gregorian date.
//
//  Computes:
//      Number of Days in Prior Years (both common and leap years) +
//      Number of Days in Prior Months of Current Year +
//      Number of Days in Current Month
//
//  12-04-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

DWORD GetAbsoluteDate(
    WORD Year,
    WORD Month,
    WORD Day)

{
    DWORD AbsoluteDate = 0;            // absolute date
    DWORD GregMonthDays[13] = {0,31,59,90,120,151,181,212,243,273,304,334,365};


    //
    //  Check to see if the current year is a Gregorian leap year.
    //  If so, add a day.
    //
    if (NLS_GREGORIAN_LEAP_YEAR(Year) && (Month > 2))
    {
        AbsoluteDate++;
    }

    //
    //  Add the Number of Days in the Prior Years.
    //
    if (Year = Year - 1)
    {
        AbsoluteDate += ((Year * 365L) + (Year / 4L) - (Year / 100L) + (Year / 400L));
    }

    //
    //  Add the Number of Days in the Prior Months of the Current Year.
    //
    AbsoluteDate += GregMonthDays[Month - 1];

    //
    //  Add the Number of Days in the Current Month.
    //
    AbsoluteDate += (DWORD)Day;

    //
    //  Return the absolute date.
    //
    return (AbsoluteDate);
}




//-------------------------------------------------------------------------//
//                         HIJRI CALENDAR ROUTINES                         //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetHijriDate
//
//  Converts the given Gregorian date to its equivalent Hijri (Islamic)
//  date.
//
//  Rules for the Hijri calendar:
//    - The Hijri calendar is a strictly Lunar calendar.
//    - Days begin at sunset.
//    - Islamic Year 1 (Muharram 1, 1 A.H.) is equivalent to absolute date
//        227015 (Friday, July 16, 622 C.E. - Julian).
//    - Leap Years occur in the 2, 5, 7, 10, 13, 16, 18, 21, 24, 26, & 29th
//        years of a 30-year cycle.  Year = leap iff ((11y+14) mod 30 < 11).
//    - There are 12 months which contain alternately 30 and 29 days.
//    - The 12th month, Dhu al-Hijjah, contains 30 days instead of 29 days
//        in a leap year.
//    - Common years have 354 days.  Leap years have 355 days.
//    - There are 10,631 days in a 30-year cycle.
//    - The Islamic months are:
//        1.  Muharram   (30 days)     7.  Rajab          (30 days)
//        2.  Safar      (29 days)     8.  Sha'ban        (29 days)
//        3.  Rabi I     (30 days)     9.  Ramadan        (30 days)
//        4.  Rabi II    (29 days)     10. Shawwal        (29 days)
//        5.  Jumada I   (30 days)     11. Dhu al-Qada    (30 days)
//        6.  Jumada II  (29 days)     12. Dhu al-Hijjah  (29 days) {30}
//
//  12-04-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void GetHijriDate(
    LPSYSTEMTIME pDate,
    DWORD dwFlags)

{
    DWORD AbsoluteDate;                // absolute date
    DWORD HijriYear;                   // Hijri year
    DWORD HijriMonth;                  // Hijri month
    DWORD HijriDay;                    // Hijri day
    DWORD NumDays;                     // number of days
    DWORD HijriMonthDays[13] = {0,30,59,89,118,148,177,207,236,266,295,325,355};


    //
    //  Get the absolute date.
    //
    AbsoluteDate = GetAbsoluteDate(pDate->wYear, pDate->wMonth, pDate->wDay);

    //
    //  See how much we need to backup or advance
    //
    (LONG)AbsoluteDate += GetAdvanceHijriDate(dwFlags);

    //
    //  Calculate the Hijri Year.
    //
    HijriYear = ((AbsoluteDate - 227013L) * 30L / 10631L) + 1;

    if (AbsoluteDate <= DaysUpToHijriYear(HijriYear))
    {
        HijriYear--;
    }
    else if (AbsoluteDate > DaysUpToHijriYear(HijriYear + 1))
    {
        HijriYear++;
    }

    //
    //  Calculate the Hijri Month.
    //
    HijriMonth = 1;
    NumDays = AbsoluteDate - DaysUpToHijriYear(HijriYear);
    while ((HijriMonth <= 12) && (NumDays > HijriMonthDays[HijriMonth - 1]))
    {
        HijriMonth++;
    }
    HijriMonth--;

    //
    //  Calculate the Hijri Day.
    //
    HijriDay = NumDays - HijriMonthDays[HijriMonth - 1];

    //
    //  Save the Hijri date and return.
    //
    pDate->wYear  = (WORD)HijriYear;
    pDate->wMonth = (WORD)HijriMonth;
    pDate->wDay   = (WORD)HijriDay;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetAdvanceHijriDate
//
//  Gets the AddHijriDate value from the registry.
//
//  12-04-96    JulieB    Created.
//  05-15-99    SamerA    Support +/-3 Advance Hijri Date
////////////////////////////////////////////////////////////////////////////

LONG GetAdvanceHijriDate(
    DWORD dwFlags)
{
    LONG lAdvance = 0L;                                 // advance hijri date
    HANDLE hKey = NULL;                                 // handle to intl key
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;          // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];               // ptr to static buffer
    BOOL IfAlloc = FALSE;                               // if buffer was allocated
    WCHAR wszAddHijriRegValue[] = L"AddHijriDate";      // registry value
    WCHAR wszAddHijriTempValue[] = L"AddHijriDateTemp"; // temp registry to use (intl.cpl use)
    INT AddHijriStringLength;
    PWSTR pwszValue;
    LONG lData;
    UNICODE_STRING ObUnicodeStr;
    ULONG rc = 0L;                                 // result code


    //
    //  Open the Control Panel International registry key.
    //
    OPEN_CPANEL_INTL_KEY(hKey, lAdvance, KEY_READ);

    //
    //  Query the registry for the AddHijriDate value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    rc = QueryRegValue( hKey,
                        (dwFlags & DATE_ADDHIJRIDATETEMP) ?
                        wszAddHijriTempValue :
                        wszAddHijriRegValue,
                        &pKeyValueFull,
                        MAX_KEY_VALUE_FULLINFO,
                        &IfAlloc );

    //
    //  Close the registry key.
    //
    CLOSE_REG_KEY(hKey);

    //
    //  Get the base value length without the NULL terminating char.
    //
    AddHijriStringLength = (sizeof(wszAddHijriRegValue) / sizeof(WCHAR)) - 1;

    //
    //  See if the AddHijriDate value is present.
    //
    if (rc != NO_ERROR)
    {
        return (lAdvance);
    }

    //
    //  See if the AddHijriDate data is present.  If it is, parse the
    //  Advance Hijri amount.
    //
    pwszValue = GET_VALUE_DATA_PTR(pKeyValueFull);

    if ((pKeyValueFull->DataLength > 2) &&
        (wcsncmp(pwszValue, wszAddHijriRegValue, AddHijriStringLength) == 0))
    {
        RtlInitUnicodeString( &ObUnicodeStr,
                              &pwszValue[AddHijriStringLength]);

        if (NT_SUCCESS(RtlUnicodeStringToInteger(&ObUnicodeStr,
                                                 10,
                                                 &lData)))
        {
            if ((lData > -3L) && (lData < 3L))
            {
                //
                //  AddHijriDate and AddHijriDate-1 both mean -1.
                //
                if (lData == 0L)
                {
                    lAdvance = -1L;
                }
                else
                {
                    lAdvance = lData;
                }
            }
        }
    }

    //
    //  Free the buffer used for the query.
    //
    if (IfAlloc)
    {
        NLS_FREE_MEM(pKeyValueFull);
    }

    //
    //  Return the result.
    //
    return (lAdvance);
}


////////////////////////////////////////////////////////////////////////////
//
//  DaysUpToHijriYear
//
//  Gets the total number of days (absolute date) up to the given Hijri
//  Year.
//
//  12-04-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

DWORD DaysUpToHijriYear(
    DWORD HijriYear)

{
    DWORD NumDays;           // number of absolute days
    DWORD NumYear30;         // number of years up to current 30 year cycle
    DWORD NumYearsLeft;      // number of years into 30 year cycle


    //
    //  Compute the number of years up to the current 30 year cycle.
    //
    NumYear30 = ((HijriYear - 1) / 30) * 30;

    //
    //  Compute the number of years left.  This is the number of years
    //  into the 30 year cycle for the given year.
    //
    NumYearsLeft = HijriYear - NumYear30 - 1;

    //
    //  Compute the number of absolute days up to the given year.
    //
    NumDays = ((NumYear30 * 10631L) / 30L) + 227013L;
    while (NumYearsLeft)
    {
        NumDays += 354L + NLS_HIJRI_LEAP_YEAR(NumYearsLeft);
        NumYearsLeft--;
    }

    //
    //  Return the number of absolute days.
    //
    return (NumDays);
}




//-------------------------------------------------------------------------//
//                         HEBREW CALENDAR ROUTINES                        //
//-------------------------------------------------------------------------//


//
//  Jewish Era in use today is dated from the supposed year of the
//  Creation with its beginning in 3761 B.C.
//
#define NLS_LUNAR_ERA_DIFF   3760


//
//  Hebrew Translation Table.
//
CONST BYTE HebrewTable[] =
{
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,7,3,17,3,
    0,4,11,2,21,6,1,3,13,2,
    25,4,5,3,16,2,27,6,9,1,
    20,2,0,6,11,3,23,4,4,2,
    14,3,27,4,8,2,18,3,28,6,
    11,1,22,5,2,3,12,3,25,4,
    6,2,16,3,26,6,8,2,20,1,
    0,6,11,2,24,4,4,3,15,2,
    25,6,8,1,19,2,29,6,9,3,
    22,4,3,2,13,3,25,4,6,3,
    17,2,27,6,7,3,19,2,31,4,
    11,3,23,4,5,2,15,3,25,6,
    6,2,19,1,29,6,10,2,22,4,
    3,3,14,2,24,6,6,1,17,3,
    28,5,8,3,20,1,32,5,12,3,
    22,6,4,1,16,2,26,6,6,3,
    17,2,0,4,10,3,22,4,3,2,
    14,3,24,6,5,2,17,1,28,6,
    9,2,19,3,31,4,13,2,23,6,
    3,3,15,1,27,5,7,3,17,3,
    29,4,11,2,21,6,3,1,14,2,
    25,6,5,3,16,2,28,4,9,3,
    20,2,0,6,12,1,23,6,4,2,
    14,3,26,4,8,2,18,3,0,4,
    10,3,21,5,1,3,13,1,24,5,
    5,3,15,3,27,4,8,2,19,3,
    29,6,10,2,22,4,3,3,14,2,
    26,4,6,3,18,2,28,6,10,1,
    20,6,2,2,12,3,24,4,5,2,
    16,3,28,4,8,3,19,2,0,6,
    12,1,23,5,3,3,14,3,26,4,
    7,2,17,3,28,6,9,2,21,4,
    1,3,13,2,25,4,5,3,16,2,
    27,6,9,1,19,3,0,5,11,3,
    23,4,4,2,14,3,25,6,7,1,
    18,2,28,6,9,3,21,4,2,2,
    12,3,25,4,6,2,16,3,26,6,
    8,2,20,1,0,6,11,2,22,6,
    4,1,15,2,25,6,6,3,18,1,
    29,5,9,3,22,4,2,3,13,2,
    23,6,4,3,15,2,27,4,7,3,
    19,2,31,4,11,3,21,6,3,2,
    15,1,25,6,6,2,17,3,29,4,
    10,2,20,6,3,1,13,3,24,5,
    4,3,16,1,27,5,7,3,17,3,
    0,4,11,2,21,6,1,3,13,2,
    25,4,5,3,16,2,29,4,9,3,
    19,6,30,2,13,1,23,6,4,2,
    14,3,27,4,8,2,18,3,0,4,
    11,3,22,5,2,3,14,1,26,5,
    6,3,16,3,28,4,10,2,20,6,
    30,3,11,2,24,4,4,3,15,2,
    25,6,8,1,19,2,29,6,9,3,
    22,4,3,2,13,3,25,4,7,2,
    17,3,27,6,9,1,21,5,1,3,
    11,3,23,4,5,2,15,3,25,6,
    6,2,19,1,29,6,10,2,22,4,
    3,3,14,2,24,6,6,1,18,2,
    28,6,8,3,20,4,2,2,12,3,
    24,4,4,3,16,2,26,6,6,3,
    17,2,0,4,10,3,22,4,3,2,
    14,3,24,6,5,2,17,1,28,6,
    9,2,21,4,1,3,13,2,23,6,
    5,1,15,3,27,5,7,3,19,1,
    0,5,10,3,22,4,2,3,13,2,
    24,6,4,3,15,2,27,4,8,3,
    20,4,1,2,11,3,22,6,3,2,
    15,1,25,6,7,2,17,3,29,4,
    10,2,21,6,1,3,13,1,24,5,
    5,3,15,3,27,4,8,2,19,6,
    1,1,12,2,22,6,3,3,14,2,
    26,4,6,3,18,2,28,6,10,1,
    20,6,2,2,12,3,24,4,5,2,
    16,3,28,4,9,2,19,6,30,3,
    12,1,23,5,3,3,14,3,26,4,
    7,2,17,3,28,6,9,2,21,4,
    1,3,13,2,25,4,5,3,16,2,
    27,6,9,1,19,6,30,2,11,3,
    23,4,4,2,14,3,27,4,7,3,
    18,2,28,6,11,1,22,5,2,3,
    12,3,25,4,6,2,16,3,26,6,
    8,2,20,4,30,3,11,2,24,4,
    4,3,15,2,25,6,8,1,18,3,
    29,5,9,3,22,4,3,2,13,3,
    23,6,6,1,17,2,27,6,7,3,
    20,4,1,2,11,3,23,4,5,2,
    15,3,25,6,6,2,19,1,29,6,
    10,2,20,6,3,1,14,2,24,6,
    4,3,17,1,28,5,8,3,20,4,
    1,3,12,2,22,6,2,3,14,2,
    26,4,6,3,17,2,0,4,10,3,
    20,6,1,2,14,1,24,6,5,2,
    15,3,28,4,9,2,19,6,1,1,
    12,3,23,5,3,3,15,1,27,5,
    7,3,17,3,29,4,11,2,21,6,
    1,3,12,2,25,4,5,3,16,2,
    28,4,9,3,19,6,30,2,12,1,
    23,6,4,2,14,3,26,4,8,2,
    18,3,0,4,10,3,22,5,2,3,
    14,1,25,5,6,3,16,3,28,4,
    9,2,20,6,30,3,11,2,23,4,
    4,3,15,2,27,4,7,3,19,2,
    29,6,11,1,21,6,3,2,13,3,
    25,4,6,2,17,3,27,6,9,1,
    20,5,30,3,10,3,22,4,3,2,
    14,3,24,6,5,2,17,1,28,6,
    9,2,21,4,1,3,13,2,23,6,
    5,1,16,2,27,6,7,3,19,4,
    30,2,11,3,23,4,3,3,14,2,
    25,6,5,3,16,2,28,4,9,3,
    21,4,2,2,12,3,23,6,4,2,
    16,1,26,6,8,2,20,4,30,3,
    11,2,22,6,4,1,14,3,25,5,
    6,3,18,1,29,5,9,3,22,4,
    2,3,13,2,23,6,4,3,15,2,
    27,4,7,3,20,4,1,2,11,3,
    21,6,3,2,15,1,25,6,6,2,
    17,3,29,4,10,2,20,6,3,1,
    13,3,24,5,4,3,17,1,28,5,
    8,3,18,6,1,1,12,2,22,6,
    2,3,14,2,26,4,6,3,17,2,
    28,6,10,1,20,6,1,2,12,3,
    24,4,5,2,15,3,28,4,9,2,
    19,6,33,3,12,1,23,5,3,3,
    13,3,25,4,6,2,16,3,26,6,
    8,2,20,4,30,3,11,2,24,4,
    4,3,15,2,25,6,8,1,18,6,
    33,2,9,3,22,4,3,2,13,3,
    25,4,6,3,17,2,27,6,9,1,
    21,5,1,3,11,3,23,4,5,2,
    15,3,25,6,6,2,19,4,33,3,
    10,2,22,4,3,3,14,2,24,6,
    6,1,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,
    99,99
};


//
//  The lunar calendar has 6 different variations of month lengths
//  within a year.
//
CONST BYTE LunarMonthLen[7][14] =
{
    0,00,00,00,00,00,00,00,00,00,00,00,00,0,
    0,30,29,29,29,30,29,30,29,30,29,30,29,0,     // 3 common year variations
    0,30,29,30,29,30,29,30,29,30,29,30,29,0,
    0,30,30,30,29,30,29,30,29,30,29,30,29,0,
    0,30,29,29,29,30,30,29,30,29,30,29,30,29,    // 3 leap year variations
    0,30,29,30,29,30,30,29,30,29,30,29,30,29,
    0,30,30,30,29,30,30,29,30,29,30,29,30,29
};




////////////////////////////////////////////////////////////////////////////
//
//  GetHebrewDate
//
//  Converts the given Gregorian date to its equivalent Hebrew date.
//
//  Rules for the Hebrew calendar:
//    - The Hebrew calendar is both a Lunar (months) and Solar (years)
//        calendar, but allows for a week of seven days.
//    - Days begin at sunset.
//    - Leap Years occur in the 3, 6, 8, 11, 14, 17, & 19th years of a
//        19-year cycle.  Year = leap iff ((7y+1) mod 19 < 7).
//    - There are 12 months in a common year and 13 months in a leap year.
//    - In a common year, the 12th month, Adar, has 29 days.  In a leap
//        year, the 12th month, Adar I, has 30 days and the 13th month,
//        Adar II, has 29 days.
//    - Common years have 353-355 days.  Leap years have 383-385 days.
//    - The Hebrew new year (Rosh HaShanah) begins on the 1st of Tishri,
//        the 7th month in the list below.
//        - The new year may not begin on Sunday, Wednesday, or Friday.
//        - If the new year would fall on a Tuesday and the conjunction of
//            the following year were at midday or later, the new year is
//            delayed until Thursday.
//        - If the new year would fall on a Monday after a leap year, the
//            new year is delayed until Tuesday.
//    - The length of the 8th and 9th months vary from year to year,
//        depending on the overall length of the year.
//        - The length of a year is determined by the dates of the new
//            years (Tishri 1) preceding and following the year in question.
//        - The 8th month is long (30 days) if the year has 355 or 385 days.
//        - The 9th month is short (29 days) if the year has 353 or 383 days.
//    - The Hebrew months are:
//        1.  Nisan      (30 days)     7.  Tishri         (30 days)
//        2.  Iyyar      (29 days)     8.  Heshvan        (29 or 30 days)
//        3.  Sivan      (30 days)     9.  Kislev         (29 or 30 days)
//        4.  Tammuz     (29 days)     10. Teveth         (29 days)
//        5.  Av         (30 days)     11. Shevat         (30 days)
//        6.  Elul       (29 days)    {12. Adar I         (30 days)}
//                                     12. {13.} Adar {II}(29 days)
//
//  12-04-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL GetHebrewDate(
    LPSYSTEMTIME pDate,
    LPBOOL pLunarLeap)

{
    WORD Year, Month, Day;             // initial year, month, day
    WORD WeekDay;                      // day of the week
    BYTE LunarYearCode;                // lunar year code
    BYTE LunarMonth, LunarDay;         // lunar month and day for Jan 1
    DWORD Absolute1600;                // absolute date 1/1/1600
    DWORD AbsoluteDate;                // absolute date - absolute date 1/1/1600
    LONG NumDays;                      // number of days since 1/1
    CONST BYTE *pLunarMonthLen;        // ptr to lunar month length array


    //
    //  Save the Gregorian date values.
    //
    Year = pDate->wYear;
    Month = pDate->wMonth;
    Day = pDate->wDay;

    //
    //  Make sure we have a valid Gregorian date that will fit into our
    //  Hebrew conversion limits.
    //
    if (!IsValidDateForHebrew(Year, Month, Day))
    {
        return (FALSE);
    }

    //
    //  Get the offset into the LunarMonthLen array and the lunar day
    //  for January 1st.
    //
    LunarYearCode = HebrewTable[(Year - 1500) * 2 + 1];
    LunarDay      = HebrewTable[(Year - 1500) * 2];

    //
    //  See if it's a Lunar leap year.
    //
    *pLunarLeap = (LunarYearCode >= 4);

    //
    //  Get the Lunar Month.
    //
    switch (LunarDay)
    {
        case ( 0 ) :                   // 1/1 is on Shvat 1
        {
            LunarMonth = 5;
            LunarDay = 1;
            break;
        }
        case ( 30 ) :                  // 1/1 is on Kislev 30
        {
            LunarMonth = 3;
            break;
        }
        case ( 31 ) :                  // 1/1 is on Shvat 2
        {
            LunarMonth = 5;
            LunarDay = 2;
            break;
        }
        case ( 32 ) :                  // 1/1 is on Shvat 3
        {
            LunarMonth = 5;
            LunarDay = 3;
            break;
        }
        case ( 33 ) :                  // 1/1 is on Kislev 29
        {
            LunarMonth = 3;
            LunarDay = 29;
            break;
        }
        default :                      // 1/1 is on Tevet
        {
            LunarMonth = 4;
            break;
        }
    }

    //
    //  Store the values for the start of the new year - 1/1.
    //
    pDate->wYear  = Year + NLS_LUNAR_ERA_DIFF;
    pDate->wMonth = (WORD)LunarMonth;
    pDate->wDay   = (WORD)LunarDay;

    //
    //  Get the absolute date from 1/1/1600.
    //
    Absolute1600 = GetAbsoluteDate(1600, 1, 1);
    AbsoluteDate = GetAbsoluteDate(Year, Month, Day) - Absolute1600;

    //
    //  Compute and save the day of the week (Sunday = 0).
    //
    WeekDay = (WORD)(AbsoluteDate % 7);
    pDate->wDayOfWeek = (WeekDay) ? (WeekDay - 1) : 6;

    //
    //  If the requested date was 1/1, then we're done.
    //
    if ((Month == 1) && (Day == 1))
    {
        return (TRUE);
    }

    //
    //  Calculate the number of days between 1/1 and the requested date.
    //
    NumDays = (LONG)(AbsoluteDate - (GetAbsoluteDate(Year, 1, 1) - Absolute1600));

    //
    //  If the requested date is within the current lunar month, then
    //  we're done.
    //
    pLunarMonthLen = &(LunarMonthLen[LunarYearCode][0]);
    if ((NumDays + (LONG)LunarDay) <= (LONG)(pLunarMonthLen[LunarMonth]))
    {
        pDate->wDay += (WORD)NumDays;
        return (TRUE);
    }

    //
    //  Adjust for the current partial month.
    //
    pDate->wMonth++;
    pDate->wDay = 1;

    //
    //  Adjust the Lunar Month and Year (if necessary) based on the number
    //  of days between 1/1 and the requested date.
    //
    //  Assumes Jan 1 can never translate to the last Lunar month, which
    //  is true.
    //
    NumDays -= (LONG)(pLunarMonthLen[LunarMonth] - LunarDay);
    if (NumDays == 1)
    {
        return (TRUE);
    }

    //
    //  Get the final Hebrew date.
    //
    do
    {
        //
        //  See if we're on the correct Lunar month.
        //
        if (NumDays <= (LONG)(pLunarMonthLen[pDate->wMonth]))
        {
            //
            //  Found the right Lunar month.
            //
            pDate->wDay += (WORD)(NumDays - 1);
            return (TRUE);
        }
        else
        {
            //
            //  Adjust the number of days and move to the next month.
            //
            NumDays -= (LONG)(pLunarMonthLen[pDate->wMonth++]);

            //
            //  See if we need to adjust the Year.
            //  Must handle both 12 and 13 month years.
            //
            if ((pDate->wMonth > 13) || (pLunarMonthLen[pDate->wMonth] == 0))
            {
                //
                //  Adjust the Year.
                //
                pDate->wYear++;
                LunarYearCode = HebrewTable[(Year + 1 - 1500) * 2 + 1];
                pLunarMonthLen = &(LunarMonthLen[LunarYearCode][0]);

                //
                //  Adjust the Month.
                //
                pDate->wMonth = 1;

                //
                //  See if this new Lunar year is a leap year.
                //
                *pLunarLeap = (LunarYearCode >= 4);
            }
        }
    } while (NumDays > 0);

    //
    //  Return success.
    //
    return (TRUE);
}



////////////////////////////////////////////////////////////////////////////
//
//  IsValidDateForHebrew
//
//  Checks to be sure the given Gregorian date is valid.  This validation
//  requires that the year be between 1600 and 2239.  If it is, it
//  returns TRUE.  Otherwise, it returns FALSE.
//
//  12-04-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidDateForHebrew(
    WORD Year,
    WORD Month,
    WORD Day)

{
    WORD GregMonthLen[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};


    //
    //  Make sure the Year is between 1600 and 2239.
    //
    if ((Year < 1600) || (Year > 2239))
    {
        return (FALSE);
    }

    //
    //  Make sure the Month is between 1 and 12.
    //
    if ((Month < 1) || (Month > 12))
    {
        return (FALSE);
    }

    //
    //  See if it's a Gregorian leap year.  If so, make sure February
    //  is allowed to have 29 days.
    //
    if (NLS_GREGORIAN_LEAP_YEAR(Year))
    {
        GregMonthLen[2] = 29;
    }

    //
    //  Make sure the Day is within the correct range for the given Month.
    //
    if ((Day < 1) || (Day > GregMonthLen[Month]))
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  NumberToHebrewLetter
//
//  Converts the given number to Hebrew letters according to the numeric
//  value of each Hebrew letter.  Basically, this converts the lunar year
//  and the lunar month to letters.
//
//  The character of a year is described by three letters of the Hebrew
//  alphabet, the first and third giving, respectively, the days of the
//  weeks on which the New Year occurs and Passover begins, while the
//  second is the initial of the Hebrew word for defective, normal, or
//  complete.
//
//  Defective Year : Both Heshvan and Kislev are defective (353 or 383 days)
//  Normal Year    : Heshvan is defective, Kislev is full  (354 or 384 days)
//  Complete Year  : Both Heshvan and Kislev are full      (355 or 385 days)
//
//  12-04-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL NumberToHebrewLetter(
    DWORD Number,
    LPWSTR szHebrew,
    int cchSize)

{
    WCHAR szHundreds[4];               // temp buffer for hundreds
    WCHAR cTens, cUnits;               // tens and units chars
    DWORD Hundreds, Tens;              // hundreds and tens values
    WCHAR szTemp[10];                  // temp buffer
    LPWSTR pTemp = szTemp;             // temp ptr to temp buffer
    int Length, Ctr;                   // loop counters


    //
    //  Sanity check.
    //
    if (cchSize > 10)
    {
        return (FALSE);
    }

    //
    //  Adjust the number if greater than 5000.
    //
    if (Number > 5000)
    {
        Number -= 5000;
    }

    //
    //  Clear out the temp buffer.
    //
    RtlZeroMemory(szHundreds, sizeof(szHundreds));

    //
    //  Get the Hundreds.
    //
    Hundreds = Number / 100;

    if (Hundreds)
    {
        Number -= Hundreds * 100;

        if (Hundreds > 3)
        {
            szHundreds[2] = L'\x05ea';      // Hebrew Letter Tav
            Hundreds -= 4;
        }

        if (Hundreds > 3)
        {
            szHundreds[1] = L'\x05ea';      // Hebrew Letter Tav
            Hundreds -= 4;
        }

        if (Hundreds > 0)
        {
            if (!szHundreds[1])
            {
                szHundreds[1] = (WCHAR)(L'\x05e6' + Hundreds);
            }
            else
            {
                szHundreds[0] = (WCHAR)(L'\x05e6' + Hundreds);
            }
        }

        if (!szHundreds[1])
        {
            szHundreds[0] = szHundreds[2];
        }
        else
        {
            if (!szHundreds[0])
            {
                szHundreds[0] = szHundreds[1];
                szHundreds[1] = szHundreds[2];
                szHundreds[2] = 0;
            }
        }
    }

    //
    //  Get the Tens.
    //
    Tens = Number / 10;

    if (Tens)
    {
        Number -= Tens * 10;

        switch (Tens)
        {
            case ( 1 ) :
            {
                cTens = L'\x05d9';          // Hebrew Letter Yod
                break;
            }
            case ( 2 ) :
            {
                cTens = L'\x05db';          // Hebrew Letter Kaf
                break;
            }
            case ( 3 ) :
            {
                cTens = L'\x05dc';          // Hebrew Letter Lamed
                break;
            }
            case ( 4 ) :
            {
                cTens = L'\x05de';          // Hebrew Letter Mem
                break;
            }
            case ( 5 ) :
            {
                cTens = L'\x05e0';          // Hebrew Letter Nun
                break;
            }
            case ( 6 ) :
            {
                cTens = L'\x05e1';          // Hebrew Letter Samekh
                break;
            }
            case ( 7 ) :
            {
                cTens = L'\x05e2';          // Hebrew Letter Ayin
                break;
            }
            case ( 8 ) :
            {
                cTens = L'\x05e4';          // Hebrew Letter Pe
                break;
            }
            case ( 9 ) :
            {
                cTens = L'\x05e6';          // Hebrew Letter Tsadi
                break;
            }
        }
    }
    else
    {
        cTens = 0;
    }

    //
    //  Get the Units.
    //
    cUnits = (WCHAR)(Number ? (L'\x05d0' + Number - 1) : 0);

    if ((cUnits == L'\x05d4') &&            // Hebrew Letter He
        (cTens == L'\x05d9'))               // Hebrew Letter Yod
    {
        cUnits = L'\x05d5';                 // Hebrew Letter Vav
        cTens  = L'\x05d8';                 // Hebrew Letter Tet
    }

    if ((cUnits == L'\x05d5') &&            // Hebrew Letter Vav
        (cTens == L'\x05d9'))               // Hebrew Letter Yod
    {
        cUnits = L'\x05d6';                 // Hebrew Letter Zayin
        cTens  = L'\x05d8';                 // Hebrew Letter Tet
    }

    //
    //  Clear out the temp buffer.
    //
    RtlZeroMemory(pTemp, sizeof(szTemp));

    //
    //  Copy the appropriate info to the given buffer.
    //
    if (cUnits)
    {
        *pTemp++ = cUnits;
    }

    if (cTens)
    {
        *pTemp++ = cTens;
    }

    if(FAILED(StringCchCopyW(pTemp, ARRAYSIZE(szTemp) - (pTemp - szTemp), szHundreds)))
    {
        //
        // Operation tried to overrun the static buffer on the stack
        //
        return(FALSE);
    }
    
    if(NlsStrLenW(szTemp) > 1)
    {
        RtlMoveMemory(szTemp + 2, szTemp + 1, NlsStrLenW(szTemp + 1) * sizeof(WCHAR));
        szTemp[1] = L'"';
    }
    else
    {
        szTemp[1] = szTemp[0];
        szTemp[0] = L'\'';
    }

    //
    //  Reverse the final string and store it in the given buffer.
    //
    Length = NlsStrLenW(szTemp) - 1;

    if( Length > (cchSize - 1) )
    {
        // Make sure that we wont overrun the szHebrew.
        return (FALSE);
    }

    for (Ctr = 0; Length >= 0; Ctr++)
    {
        szHebrew[Ctr] = szTemp[Length];
        Length--;
    }
    szHebrew[Ctr] = 0;

    //
    //  Return success.
    //
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\enum.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    enum.c

Abstract:

    This file contains functions that enumerate the user's portion of the
    registry for installed and supported locale ids and code page ids.

    APIs found in this file:
      EnumSystemLanguageGroupsW
      EnumLanguageGroupLocalesW
      EnumUILanguagesW
      EnumSystemLocalesW
      EnumSystemCodePagesW
      EnumCalendarInfoW
      EnumCalendarInfoExW
      EnumTimeFormatsW
      EnumDateFormatsW
      EnumDateFormatsExW

Revision History:

    08-02-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"



//
//  Constant Declarations
//

#define ENUM_BUF_SIZE        9    // buffer size (wchar) for lcid or cpid (incl null)
#define ENUM_MAX_CP_SIZE     5    // max size (wchar) for cp id in registry
#define ENUM_LOCALE_SIZE     8    // buffer size (wchar) for locale id in registry
#define ENUM_MAX_LG_SIZE     2    // max size (wchar) for language group id in registry
#define ENUM_MAX_UILANG_SIZE 4    // max size (wchar) for UI langguage id in registry




//
//  Forward Declarations.
//

BOOL
EnumDateTime(
    NLS_ENUMPROC lpDateTimeFmtEnumProc,
    LCID Locale,
    LCTYPE LCType,
    DWORD dwFlags,
    SIZE_T CacheOffset,
    LPWSTR pRegValue,
    PLOCALE_VAR pLocaleHdr,
    LPWSTR pDateTime,
    LPWSTR pEndDateTime,
    ULONG CalDateOffset,
    ULONG EndCalDateOffset,
    BOOL fCalendarInfo,
    BOOL fUnicodeVer,
    BOOL fExVersion);





//-------------------------------------------------------------------------//
//                            INTERNAL MACROS                              //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NLS_CALL_ENUMPROC_BREAK
//
//  Calls the appropriate EnumProc routine.  If the fUnicodeVer flag is TRUE,
//  then it calls the Unicode version of the callback function.  Otherwise,
//  it calls the Ansi dispatch routine to translate the string to Ansi and
//  then call the Ansi version of the callback function.
//
//  This macro will do a break if the enumeration routine returns FALSE.
//
//  DEFINED AS A MACRO.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_CALL_ENUMPROC_BREAK( Locale,                                   \
                                 lpNlsEnumProc,                            \
                                 dwFlags,                                  \
                                 pUnicodeBuffer,                           \
                                 fUnicodeVer )                             \
{                                                                          \
    /*                                                                     \
     *  Call the appropriate callback function.                            \
     */                                                                    \
    if (fUnicodeVer)                                                       \
    {                                                                      \
        /*                                                                 \
         *  Call the Unicode callback function.                            \
         */                                                                \
        if (((*lpNlsEnumProc)(pUnicodeBuffer)) != TRUE)                    \
        {                                                                  \
            break;                                                         \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Call the Ansi callback function.                               \
         */                                                                \
        if (NlsDispatchAnsiEnumProc( Locale,                               \
                                     lpNlsEnumProc,                        \
                                     dwFlags,                              \
                                     pUnicodeBuffer,                       \
                                     NULL,                                 \
                                     0,                                    \
                                     0,                                    \
                                     0,                                    \
                                     0 ) != TRUE)                          \
        {                                                                  \
            break;                                                         \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_CALL_ENUMPROC_BREAK_2
//
//  Calls the appropriate EnumProc routine.  If the fUnicodeVer flag is TRUE,
//  then it calls the Unicode version of the callback function.  Otherwise,
//  it calls the Ansi dispatch routine to translate the strings to Ansi and
//  then call the Ansi version of the callback function.
//
//  This macro will do a break if the enumeration routine returns FALSE.
//
//  DEFINED AS A MACRO.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_CALL_ENUMPROC_BREAK_2( Locale,                                 \
                                   lpNlsEnumProc,                          \
                                   dwFlags,                                \
                                   LanguageGroup,                          \
                                   EnumLocale,                             \
                                   pUnicodeBuffer,                         \
                                   lParam,                                 \
                                   fUnicodeVer )                           \
{                                                                          \
    /*                                                                     \
     *  Call the appropriate callback function.                            \
     */                                                                    \
    if (fUnicodeVer)                                                       \
    {                                                                      \
        /*                                                                 \
         *  Call the Unicode callback function.                            \
         */                                                                \
        if (((*((NLS_ENUMPROC2)lpNlsEnumProc))( LanguageGroup,             \
                                                EnumLocale,                \
                                                pUnicodeBuffer,            \
                                                lParam )) != TRUE)         \
        {                                                                  \
            break;                                                         \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Call the Ansi callback function.                               \
         */                                                                \
        if (NlsDispatchAnsiEnumProc( Locale,                               \
                                     lpNlsEnumProc,                        \
                                     dwFlags,                              \
                                     pUnicodeBuffer,                       \
                                     NULL,                                 \
                                     LanguageGroup,                        \
                                     EnumLocale,                           \
                                     lParam,                               \
                                     2 ) != TRUE)                          \
        {                                                                  \
            break;                                                         \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_CALL_ENUMPROC_BREAK_3
//
//  Calls the appropriate EnumProc routine.  If the fUnicodeVer flag is TRUE,
//  then it calls the Unicode version of the callback function.  Otherwise,
//  it calls the Ansi dispatch routine to translate the strings to Ansi and
//  then call the Ansi version of the callback function.
//
//  This macro will do a break if the enumeration routine returns FALSE.
//
//  DEFINED AS A MACRO.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_CALL_ENUMPROC_BREAK_3( Locale,                                 \
                                   lpNlsEnumProc,                          \
                                   dwFlags,                                \
                                   LanguageGroup,                          \
                                   pUnicodeBuffer1,                        \
                                   pUnicodeBuffer2,                        \
                                   dwInstall,                              \
                                   lParam,                                 \
                                   fUnicodeVer )                           \
{                                                                          \
    /*                                                                     \
     *  Call the appropriate callback function.                            \
     */                                                                    \
    if (fUnicodeVer)                                                       \
    {                                                                      \
        /*                                                                 \
         *  Call the Unicode callback function.                            \
         */                                                                \
        if (((*((NLS_ENUMPROC3)lpNlsEnumProc))( LanguageGroup,             \
                                                pUnicodeBuffer1,           \
                                                pUnicodeBuffer2,           \
                                                (dwInstall),               \
                                                lParam )) != TRUE)         \
        {                                                                  \
            break;                                                         \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Call the Ansi callback function.                               \
         */                                                                \
        if (NlsDispatchAnsiEnumProc( Locale,                               \
                                     lpNlsEnumProc,                        \
                                     dwFlags,                              \
                                     pUnicodeBuffer1,                      \
                                     pUnicodeBuffer2,                      \
                                     LanguageGroup,                        \
                                     (dwInstall),                          \
                                     lParam,                               \
                                     3 ) != TRUE)                          \
        {                                                                  \
            break;                                                         \
        }                                                                  \
    }                                                                      \
}

////////////////////////////////////////////////////////////////////////////
//
//  NLS_CALL_ENUMPROC_BREAK_4
//
//  Calls the appropriate EnumProc routine.  If the fUnicodeVer flag is TRUE,
//  then it calls the Unicode version of the callback function.  Otherwise,
//  it calls the Ansi dispatch routine to translate the string to Ansi and
//  then call the Ansi version of the callback function.
//
//  This macro will do a break if the enumeration routine returns FALSE.
//  Used by EnumUILanguages.
//
//  DEFINED AS A MACRO.
//
//  12-03-98    SamerA    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_CALL_ENUMPROC_BREAK_4( Locale,                                 \
                                   lpNlsEnumProc,                          \
                                   dwFlags,                                \
                                   pUnicodeBuffer,                         \
                                   lParam,                                 \
                                   fUnicodeVer )                           \
{                                                                          \
    /*                                                                     \
     *  Call the appropriate callback function.                            \
     */                                                                    \
    if (fUnicodeVer)                                                       \
    {                                                                      \
        /*                                                                 \
         *  Call the Unicode callback function.                            \
         */                                                                \
        if (((*((NLS_ENUMPROC4)lpNlsEnumProc))(pUnicodeBuffer,             \
                              lParam)) != TRUE)                            \
        {                                                                  \
            break;                                                         \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Call the Ansi callback function.                               \
         */                                                                \
        if (NlsDispatchAnsiEnumProc( Locale,                               \
                                     lpNlsEnumProc,                        \
                                     dwFlags,                              \
                                     pUnicodeBuffer,                       \
                                     NULL,                                 \
                                     0,                                    \
                                     0,                                    \
                                     lParam,                               \
                                     4 ) != TRUE)                          \
        {                                                                  \
            break;                                                         \
        }                                                                  \
    }                                                                      \
}

////////////////////////////////////////////////////////////////////////////
//
//  NLS_CALL_ENUMPROC_TRUE_4
//
//  Calls the appropriate EnumProc routine.  If the fUnicodeVer flag is TRUE,
//  then it calls the Unicode version of the callback function.  Otherwise,
//  it calls the Ansi dispatch routine to translate the string to Ansi and
//  then call the Ansi version of the callback function.
//
//  This macro will do a break if the enumeration routine returns FALSE.
//  Used by EnumUILanguages.
//
//  DEFINED AS A MACRO.
//
//  12-03-98    SamerA    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_CALL_ENUMPROC_TRUE_4( Locale,                                  \
                                  lpNlsEnumProc,                           \
                                  dwFlags,                                 \
                                  pUnicodeBuffer,                          \
                                  lParam,                                  \
                                  fUnicodeVer )                            \
{                                                                          \
    /*                                                                     \
     *  Call the appropriate callback function.                            \
     */                                                                    \
    if (fUnicodeVer)                                                       \
    {                                                                      \
        /*                                                                 \
         *  Call the Unicode callback function.                            \
         */                                                                \
        if (((*((NLS_ENUMPROC4)lpNlsEnumProc))(pUnicodeBuffer,             \
                              lParam)) != TRUE)                            \
        {                                                                  \
            return (TRUE);                                                 \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Call the Ansi callback function.                               \
         */                                                                \
        if (NlsDispatchAnsiEnumProc( Locale,                               \
                                     lpNlsEnumProc,                        \
                                     dwFlags,                              \
                                     pUnicodeBuffer,                       \
                                     NULL,                                 \
                                     0,                                    \
                                     0,                                    \
                                     lParam,                               \
                                     4 ) != TRUE)                          \
        {                                                                  \
            return (TRUE);                                                 \
        }                                                                  \
    }                                                                      \
}



////////////////////////////////////////////////////////////////////////////
//
//  NLS_CALL_ENUMPROC_TRUE
//
//  Calls the appropriate EnumProc routine.  If the fUnicodeVer flag is TRUE,
//  then it calls the Unicode version of the callback function.  Otherwise,
//  it calls the Ansi dispatch routine to translate the string to Ansi and
//  then call the Ansi version of the callback function.
//
//  This macro will return TRUE if the enumeration routine returns FALSE.
//
//  DEFINED AS A MACRO.
//
//  11-10-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_CALL_ENUMPROC_TRUE( Locale,                                    \
                                lpNlsEnumProc,                             \
                                dwFlags,                                   \
                                pUnicodeBuffer,                            \
                                CalId,                                     \
                                fUnicodeVer,                               \
                                fVer )                                     \
{                                                                          \
    /*                                                                     \
     *  Call the appropriate callback function.                            \
     */                                                                    \
    if (fUnicodeVer)                                                       \
    {                                                                      \
        /*                                                                 \
         *  Call the Unicode callback function.                            \
         */                                                                \
        if (fVer == 1)                                                     \
        {                                                                  \
            if (((*((NLS_ENUMPROCEX)lpNlsEnumProc))( pUnicodeBuffer,       \
                                                     CalId )) != TRUE)     \
            {                                                              \
                return (TRUE);                                             \
            }                                                              \
        }                                                                  \
        else   /* fVer == 0 */                                             \
        {                                                                  \
            if (((*lpNlsEnumProc)(pUnicodeBuffer)) != TRUE)                \
            {                                                              \
                return (TRUE);                                             \
            }                                                              \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Call the Ansi callback function.                               \
         */                                                                \
        if (NlsDispatchAnsiEnumProc( Locale,                               \
                                     lpNlsEnumProc,                        \
                                     dwFlags,                              \
                                     pUnicodeBuffer,                       \
                                     NULL,                                 \
                                     CalId,                                \
                                     0,                                    \
                                     0,                                    \
                                     fVer ) != TRUE)                       \
        {                                                                  \
            return (TRUE);                                                 \
        }                                                                  \
    }                                                                      \
}




//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  EnumSystemLanguageGroupsW
//
//  Enumerates the system language groups that are installed or supported,
//  based on the dwFlags parameter.  It does so by passing the pointer to
//  the string buffer containing the language group id to an
//  application-defined callback function.  It continues until the last
//  language group id is found or the callback function returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumSystemLanguageGroupsW(
    LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam)
{
    return (Internal_EnumSystemLanguageGroups(
                                       (NLS_ENUMPROC)lpLanguageGroupEnumProc,
                                       dwFlags,
                                       lParam,
                                       TRUE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumLanguageGroupLocalesW
//
//  Enumerates the locales in a given language group.  It does so by
//  passing the appropriate information to an application-defined
//  callback function.  It continues until the last locale in the language
//  group is found or the callback function returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumLanguageGroupLocalesW(
    LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc,
    LGRPID LanguageGroup,
    DWORD dwFlags,
    LONG_PTR lParam)
{
    return (Internal_EnumLanguageGroupLocales(
                                       (NLS_ENUMPROC)lpLangGroupLocaleEnumProc,
                                       LanguageGroup,
                                       dwFlags,
                                       lParam,
                                       TRUE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumUILanguagesW
//
//  Enumerates the system UI languages that are installed.  It does so by
//  passing the pointer to the string buffer containing the UI language id
//  to an application-defined callback function.  It continues until the
//  last UI language id is found or the callback function returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumUILanguagesW(
    UILANGUAGE_ENUMPROCW lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam)
{
    return (Internal_EnumUILanguages( (NLS_ENUMPROC)lpUILanguageEnumProc,
                                      dwFlags,
                                      lParam,
                                      TRUE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumSystemLocalesW
//
//  Enumerates the system locales that are installed or supported, based on
//  the dwFlags parameter.  It does so by passing the pointer to the string
//  buffer containing the locale id to an application-defined callback
//  function.  It continues until the last locale id is found or the
//  callback function returns FALSE.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumSystemLocalesW(
    LOCALE_ENUMPROCW lpLocaleEnumProc,
    DWORD dwFlags)
{
    return (Internal_EnumSystemLocales( (NLS_ENUMPROC)lpLocaleEnumProc,
                                        dwFlags,
                                        TRUE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumSystemCodePagesW
//
//  Enumerates the system code pages that are installed or supported, based on
//  the dwFlags parameter.  It does so by passing the pointer to the string
//  buffer containing the code page id to an application-defined callback
//  function.  It continues until the last code page is found or the
//  callback function returns FALSE.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumSystemCodePagesW(
    CODEPAGE_ENUMPROCW lpCodePageEnumProc,
    DWORD dwFlags)
{
    return (Internal_EnumSystemCodePages( (NLS_ENUMPROC)lpCodePageEnumProc,
                                          dwFlags,
                                          TRUE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumCalendarInfoW
//
//  Enumerates the specified calendar information that is available for the
//  specified locale, based on the CalType parameter.  It does so by
//  passing the pointer to the string buffer containing the calendar info
//  to an application-defined callback function.  It continues until the
//  last calendar info is found or the callback function returns FALSE.
//
//  10-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumCalendarInfoW(
    CALINFO_ENUMPROCW lpCalInfoEnumProc,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType)
{
    return (Internal_EnumCalendarInfo( (NLS_ENUMPROC)lpCalInfoEnumProc,
                                       Locale,
                                       Calendar,
                                       CalType,
                                       TRUE,
                                       FALSE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumCalendarInfoExW
//
//  Enumerates the specified calendar information that is available for the
//  specified locale, based on the CalType parameter.  It does so by
//  passing the pointer to the string buffer containing the calendar info
//  and the calendar id to an application-defined callback function.  It
//  continues until the last calendar info is found or the callback function
//  returns FALSE.
//
//  10-14-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumCalendarInfoExW(
    CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType)
{
    return (Internal_EnumCalendarInfo( (NLS_ENUMPROC)lpCalInfoEnumProcEx,
                                       Locale,
                                       Calendar,
                                       CalType,
                                       TRUE,
                                       TRUE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumTimeFormatsW
//
//  Enumerates the time formats that are available for the
//  specified locale, based on the dwFlags parameter.  It does so by
//  passing the pointer to the string buffer containing the time format
//  to an application-defined callback function.  It continues until the
//  last time format is found or the callback function returns FALSE.
//
//  10-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumTimeFormatsW(
    TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
    LCID Locale,
    DWORD dwFlags)
{
    return (Internal_EnumTimeFormats( (NLS_ENUMPROC)lpTimeFmtEnumProc,
                                       Locale,
                                       dwFlags,
                                       TRUE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumDateFormatsW
//
//  Enumerates the short date, long date, or year/month formats that are
//  available for the specified locale, based on the dwFlags parameter.
//  It does so by passing the pointer to the string buffer containing the
//  date format to an application-defined callback function.  It continues
//  until the last date format is found or the callback function returns
//  FALSE.
//
//  10-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumDateFormatsW(
    DATEFMT_ENUMPROCW lpDateFmtEnumProc,
    LCID Locale,
    DWORD dwFlags)
{
    return (Internal_EnumDateFormats( (NLS_ENUMPROC)lpDateFmtEnumProc,
                                       Locale,
                                       dwFlags,
                                       TRUE,
                                       FALSE ));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumDateFormatsExW
//
//  Enumerates the short date, long date, or year/month formats that are
//  available for the specified locale, based on the dwFlags parameter.
//  It does so by passing the pointer to the string buffer containing the
//  date format and the calendar id to an application-defined callback
//  function.  It continues until the last date format is found or the
//  callback function returns FALSE.
//
//  10-14-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumDateFormatsExW(
    DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx,
    LCID Locale,
    DWORD dwFlags)
{
    return (Internal_EnumDateFormats( (NLS_ENUMPROC)lpDateFmtEnumProcEx,
                                       Locale,
                                       dwFlags,
                                       TRUE,
                                       TRUE ));
}




//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  Internal_EnumSystemLanguageGroups
//
//  Enumerates the system language groups that are installed or supported,
//  based on the dwFlags parameter.  It does so by passing the pointer to
//  the string buffer containing the language group id to an
//  application-defined callback function.  It continues until the last
//  language group id is found or the callback function returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL Internal_EnumSystemLanguageGroups(
    NLS_ENUMPROC lpLanguageGroupEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam,
    BOOL fUnicodeVer)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull = NULL;
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];

    BOOL fInstalled;                   // if installed flag set
    ULONG Index;                       // index for enumeration
    ULONG ResultLength;                // # bytes written
    WCHAR wch;                         // first char of name
    LPWSTR pName;                      // ptr to name string from registry
    WCHAR szLGName[MAX_PATH];          // language group name
    UNICODE_STRING ObUnicodeStr;       // registry data value string
    DWORD Data;                        // registry data value
    ULONG NameLen;                     // length of name string
    LGRPID LangGroup;                    // language group id
    ULONG rc = 0L;                     // return code


    //
    //  Invalid Parameter Check:
    //    - function pointer is null
    //
    if (lpLanguageGroupEnumProc == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Invalid Flags Check:
    //    - flags other than valid ones
    //    - more than one of either supported or installed
    //
    if ( (dwFlags & ESLG_INVALID_FLAG) ||
         (MORE_THAN_ONE(dwFlags, ESLG_SINGLE_FLAG)) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (FALSE);
    }

    //
    //  Initialize flag option.
    //
    fInstalled = dwFlags & LGRPID_INSTALLED;

    //
    //  Initialize key handles.
    //
    OPEN_LANG_GROUPS_KEY(FALSE);

    //
    //  Loop through the language group ids in the registry, call the
    //  function pointer for each one that meets the flag criteria.
    //
    //  End loop if either FALSE is returned from the callback function
    //  or the end of the list is reached.
    //
    Index = 0;
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    RtlZeroMemory(pKeyValueFull, MAX_KEY_VALUE_FULLINFO);
    rc = NtEnumerateValueKey( hLangGroupsKey,
                              Index,
                              KeyValueFullInformation,
                              pKeyValueFull,
                              MAX_KEY_VALUE_FULLINFO,
                              &ResultLength );

    while (rc != STATUS_NO_MORE_ENTRIES)
    {
        if (!NT_SUCCESS(rc))
        {
            //
            //  If we get a different error, then the registry
            //  is corrupt.  Just return FALSE.
            //
            KdPrint(("NLSAPI: Language Group Enumeration Error - registry corrupt. - %lx.\n",
                     rc));
            SetLastError(ERROR_BADDB);
            return (FALSE);
        }

        //
        //  Skip over any entry that does not have data associated with it
        //  if the LGRPID_INSTALLED flag is set.
        //
        pName = pKeyValueFull->Name;
        wch = *pName;
        NameLen = pKeyValueFull->NameLength / sizeof(WCHAR);
        if ( (NameLen <= ENUM_MAX_LG_SIZE) &&
             (((wch >= NLS_CHAR_ZERO) && (wch <= NLS_CHAR_NINE)) ||
              (((wch | 0x0020) >= L'a') && ((wch | 0x0020) <= L'f'))) &&
              (!((fInstalled) && (pKeyValueFull->DataLength <= 2))) )
        {
            //
            //  See if the language group is installed or not.
            //
            Data = 0;
            if (pKeyValueFull->DataLength > 2)
            {
                RtlInitUnicodeString( &ObUnicodeStr,
                                      GET_VALUE_DATA_PTR(pKeyValueFull) );

                if (RtlUnicodeStringToInteger(&ObUnicodeStr, 16, &Data))
                {
                    Data = 0;
                }
            }

            //
            //  If the installed flag is set, then skip the language group
            //  if it is not already installed.
            //
            if ((fInstalled) && (Data != 1))
            {
                goto EnumNextLanguageGroup;
            }

            //
            //  Store the language group id string in the callback buffer.
            //
            pName[NameLen] = 0;

            //
            //  Get the language group id as a value and the localized
            //  language group name.
            //
            RtlInitUnicodeString(&ObUnicodeStr, pName);
            if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 16, &LangGroup)) ||
                (GetStringTableEntry( LangGroup,
                                      0,
                                      szLGName,
                                      MAX_PATH,
                                      RC_LANGUAGE_GROUP_NAME ) == 0))
            {
                goto EnumNextLanguageGroup;
            }

            //
            //  Call the appropriate callback function.
            //
            NLS_CALL_ENUMPROC_BREAK_3( gSystemLocale,
                                       lpLanguageGroupEnumProc,
                                       dwFlags,
                                       LangGroup,
                                       pName,
                                       szLGName,
                                       (Data == 1)
                                           ? LGRPID_INSTALLED
                                           : LGRPID_SUPPORTED,
                                       lParam,
                                       fUnicodeVer );
        }

EnumNextLanguageGroup:
        //
        //  Increment enumeration index value and get the next enumeration.
        //
        Index++;
        RtlZeroMemory(pKeyValueFull, MAX_KEY_VALUE_FULLINFO);
        rc = NtEnumerateValueKey( hLangGroupsKey,
                                  Index,
                                  KeyValueFullInformation,
                                  pKeyValueFull,
                                  MAX_KEY_VALUE_FULLINFO,
                                  &ResultLength );
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Internal_EnumLanguageGroupLocales
//
//  Enumerates the locales in a given language group.  It does so by
//  passing the appropriate information to an application-defined
//  callback function.  It continues until the last locale in the language
//  group is found or the callback function returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL Internal_EnumLanguageGroupLocales(
    NLS_ENUMPROC lpLangGroupLocaleEnumProc,
    LGRPID LanguageGroup,
    DWORD dwFlags,
    LONG_PTR lParam,
    BOOL fUnicodeVer)
{
    UNICODE_STRING ObUnicodeStr;            // locale string
    WCHAR szSectionName[MAX_PATH];          // section name in inf file
    WCHAR szBuffer[MAX_PATH * 4];           // buffer
    WCHAR szInfPath[MAX_PATH_LEN];          // inf file
    LPWSTR pStr, pEndStr;                   // ptr to szBuffer
    DWORD LocaleValue;                      // locale id value
    int Length;                             // length of string in buffer
    HRESULT hr;


    //
    //  Invalid Parameter Check:
    //    - function pointer is null
    //
    if (lpLangGroupLocaleEnumProc == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Invalid Flags Check:
    //    - flags must be 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (FALSE);
    }

    //
    //  Get INTL.INF section name - LOCALE_LIST_#.
    //
    if (NlsConvertIntegerToString( LanguageGroup,
                                   10,
                                   1,
                                   szBuffer,
                                   ENUM_BUF_SIZE ) != NO_ERROR)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    hr = StringCchCopyW(szSectionName, ARRAYSIZE(szSectionName), L"LOCALE_LIST_");
    if(FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        return (FALSE);
    }

    hr = StringCchCatW(szSectionName, ARRAYSIZE(szSectionName), szBuffer);
    if(FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        return (FALSE);
    }

    //
    //  Get the locale list from the intl.inf file.
    //
    szBuffer[0] = 0;
    if(0 == GetSystemWindowsDirectory(szInfPath, MAX_PATH_LEN))
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (FALSE);
    }

    hr = StringCchCatW(szInfPath, ARRAYSIZE(szInfPath), L"\\INF\\INTL.INF");
    if(FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        return (FALSE);
    }
    Length = GetPrivateProfileSection( szSectionName,
                                       szBuffer,
                                       MAX_PATH * 4,
                                       szInfPath );
    if (Length == 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Parse the buffer and call the callback function for each locale
    //  in the list.  The buffer is double null terminated.
    //
    pStr = szBuffer;
    pEndStr = szBuffer + Length;
    while ((pStr < pEndStr) && (*pStr))
    {
        //
        //  See if the value starts with 0x or 0X.  If so, go past it.
        //
        if ((*pStr == L'0') &&
            ((*(pStr + 1) == L'x') || (*(pStr + 1) == L'X')))
        {
            pStr += 2;
        }

        //
        //  Convert the string to an integer.
        //
        RtlInitUnicodeString(&ObUnicodeStr, pStr);
        if (RtlUnicodeStringToInteger(&ObUnicodeStr, 16, &LocaleValue) != NO_ERROR)
        {
            KdPrint(("NLSAPI: Language Group Locale Enumeration Error - intl.inf corrupt.\n"));
            SetLastError(ERROR_BADDB);
            return (FALSE);
        }

        //
        //  Call the appropriate callback function.
        //
        NLS_CALL_ENUMPROC_BREAK_2( gSystemLocale,
                                   lpLangGroupLocaleEnumProc,
                                   dwFlags,
                                   LanguageGroup,
                                   LocaleValue,
                                   pStr,
                                   lParam,
                                   fUnicodeVer );

        //
        //  Increment the pointer to the next string.
        //
        while (*pStr)
        {
            pStr++;
        }
        pStr++;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Internal_EnumUILanguages
//
//  Enumerates the system UI languages that are installed.  It does so by
//  passing the pointer to the string buffer containing the UI language id
//  to an application-defined callback function.  It continues until the
//  last UI language id is found or the callback function returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL Internal_EnumUILanguages(
    NLS_ENUMPROC lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam,
    BOOL fUnicodeVer)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull = NULL;
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];

    LANGID LangID;                     // language id
    WCHAR szLang[MAX_PATH];            // language id string
    HANDLE hKey = NULL;                // handle to muilang key
    ULONG Index;                       // index for enumeration
    ULONG ResultLength;                // # bytes written
    WCHAR wch;                         // first char of name
    LPWSTR pName;                      // ptr to name string from registry
    ULONG NameLen;                     // length of name string
    ULONG rc = 0L;                     // return code


    //
    //  Invalid Parameter Check:
    //    - function pointer is null
    //
    if (lpUILanguageEnumProc == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Invalid Flags Check:
    //    - flags must be 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (FALSE);
    }

    //
    //  Call the appropriate callback function with the user's UI
    //  language.
    //
    LangID = GetSystemDefaultUILanguage();
    if (NlsConvertIntegerToString(LangID, 16, 4, szLang, MAX_PATH) == NO_ERROR)
    {
        NLS_CALL_ENUMPROC_TRUE_4( gSystemLocale,
                                  lpUILanguageEnumProc,
                                  dwFlags,
                                  szLang,
                                  lParam,
                                  fUnicodeVer);
    }
    else
    {
        szLang[0] = 0;
    }

    //
    //  Open the MUILanguages registry key.  It is acceptable if the key
    //  does not exist, so return TRUE as there are no items to enumerate.
    //
    OPEN_MUILANG_KEY(hKey, TRUE);

    //
    //  Loop through the MUILanguage ids in the registry, call the
    //  function pointer for each.
    //
    //  End loop if either FALSE is returned from the callback function
    //  or the end of the list is reached.
    //
    Index = 0;
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    RtlZeroMemory(pKeyValueFull, MAX_KEY_VALUE_FULLINFO);
    rc = NtEnumerateValueKey( hKey,
                              Index,
                              KeyValueFullInformation,
                              pKeyValueFull,
                              MAX_KEY_VALUE_FULLINFO,
                              &ResultLength );

    while (rc != STATUS_NO_MORE_ENTRIES)
    {
        if (!NT_SUCCESS(rc))
        {
            //
            //  If we get a different error, then the registry
            //  is corrupt.  Just return FALSE.
            //
            KdPrint(("NLSAPI: MUI Languages Enumeration Error - registry corrupt. - %lx.\n",
                     rc));
            SetLastError(ERROR_BADDB);
            return (FALSE);
        }

        //
        //  Skip over any entry that does not have data associated with it.
        //
        pName = pKeyValueFull->Name;
        wch = *pName;
        NameLen = pKeyValueFull->NameLength / sizeof(WCHAR);
        if ( (NameLen == ENUM_MAX_UILANG_SIZE) &&
             (((wch >= NLS_CHAR_ZERO) && (wch <= NLS_CHAR_NINE)) ||
              (((wch | 0x0020) >= L'a') && ((wch | 0x0020) <= L'f'))) &&
              (pKeyValueFull->DataLength > 2) )
        {
            //
            //  Make sure the UI language is zero terminated.
            //
            pName[NameLen] = 0;

            //
            //  Make sure it's not the same as the user UI language
            //  that we already enumerated.
            //
            if (lstrcmp(szLang, pName) != 0)
            {
                //
                //  Call the appropriate callback function.
                //
                NLS_CALL_ENUMPROC_BREAK_4( gSystemLocale,
                                           lpUILanguageEnumProc,
                                           dwFlags,
                                           pName,
                                           lParam,
                                           fUnicodeVer );
            }
        }

        //
        //  Increment enumeration index value and get the next enumeration.
        //
        Index++;
        RtlZeroMemory(pKeyValueFull, MAX_KEY_VALUE_FULLINFO);
        rc = NtEnumerateValueKey( hKey,
                                  Index,
                                  KeyValueFullInformation,
                                  pKeyValueFull,
                                  MAX_KEY_VALUE_FULLINFO,
                                  &ResultLength );
    }

    //
    //  Close the registry key.
    //
    CLOSE_REG_KEY(hKey);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Internal_EnumSystemLocales
//
//  Enumerates the system locales that are installed or supported, based on
//  the dwFlags parameter.  It does so by passing the pointer to the string
//  buffer containing the locale id to an application-defined callback
//  function.  It continues until the last locale id is found or the
//  callback function returns FALSE.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL Internal_EnumSystemLocales(
    NLS_ENUMPROC lpLocaleEnumProc,
    DWORD dwFlags,
    BOOL fUnicodeVer)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull1 = NULL;
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull2 = NULL;
    BYTE pStatic1[MAX_KEY_VALUE_FULLINFO];
    BYTE pStatic2[MAX_KEY_VALUE_FULLINFO];

    BOOL fInstalled;                   // if installed flag set
    ULONG Index;                       // index for enumeration
    ULONG ResultLength;                // # bytes written
    WCHAR wch;                         // first char of name
    WCHAR pBuffer[ENUM_BUF_SIZE];      // ptr to callback string buffer
    LPWSTR pName;                      // ptr to name string from registry
    LPWSTR pData;                      // ptr to data string from registry
    UNICODE_STRING ObUnicodeStr;       // registry data value string
    DWORD Data;                        // registry data value
    HKEY hKey;                         // handle to registry key
    int Ctr;                           // loop counter
    ULONG rc = 0L;                     // return code


    //
    //  Invalid Parameter Check:
    //    - function pointer is null
    //
    if (lpLocaleEnumProc == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Invalid Flags Check:
    //    - flags other than valid ones
    //    - more than one of either supported or installed
    //
    if ( (dwFlags & ESL_INVALID_FLAG) ||
         (MORE_THAN_ONE(dwFlags, ESL_SINGLE_FLAG)) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (FALSE);
    }

    //
    //  Initialize flag option.
    //
    fInstalled = dwFlags & LCID_INSTALLED;

    //
    //  Initialize key handles.
    //
    OPEN_LOCALE_KEY(FALSE);
    OPEN_ALT_SORTS_KEY(FALSE);
    OPEN_LANG_GROUPS_KEY(FALSE);

    //
    //  Initialize the variables for the loop.
    //
    Ctr = 0;
    if (dwFlags & LCID_ALTERNATE_SORTS)
    {
        Ctr++;
        hKey = hAltSortsKey;
    }
    if (dwFlags != LCID_ALTERNATE_SORTS)
    {
        Ctr++;
        hKey = hLocaleKey;
    }

    //
    //  Loop through the locale ids and/or the alternate sort ids.
    //
    for (; Ctr > 0; Ctr--)
    {
        //
        //  Loop through the locale ids in the registry, call the function
        //  pointer for each one that meets the flag criteria.
        //
        //  End loop if either FALSE is returned from the callback function
        //  or the end of the list is reached.
        //
        //  Always need to ignore the DEFAULT entry.
        //
        Index = 0;
        pKeyValueFull1 = (PKEY_VALUE_FULL_INFORMATION)pStatic1;
        pKeyValueFull2 = (PKEY_VALUE_FULL_INFORMATION)pStatic2;
        RtlZeroMemory(pKeyValueFull1, MAX_KEY_VALUE_FULLINFO);
        rc = NtEnumerateValueKey( hKey,
                                  Index,
                                  KeyValueFullInformation,
                                  pKeyValueFull1,
                                  MAX_KEY_VALUE_FULLINFO,
                                  &ResultLength );

        while (rc != STATUS_NO_MORE_ENTRIES)
        {
            if (!NT_SUCCESS(rc))
            {
                //
                //  If we get a different error, then the registry
                //  is corrupt.  Just return FALSE.
                //
                KdPrint(("NLSAPI: LCID Enumeration Error - registry corrupt. - %lx.\n",
                         rc));
                SetLastError(ERROR_BADDB);
                return (FALSE);
            }

            //
            //  Skip over the Default entry in the registry and any
            //  entry that does not have data associated with it if the
            //  LCID_INSTALLED flag is set.
            //
            pName = pKeyValueFull1->Name;
            wch = *pName;
            if ((pKeyValueFull1->NameLength == (ENUM_LOCALE_SIZE * sizeof(WCHAR))) &&
                (((wch >= NLS_CHAR_ZERO) && (wch <= NLS_CHAR_NINE)) ||
                 (((wch | 0x0020) >= L'a') && ((wch | 0x0020) <= L'f'))))
            {
                //
                //  If the installed flag is set, then do some extra
                //  validation before calling the function proc.
                //
                if (fInstalled)
                {
                    if (pKeyValueFull1->DataLength <= 2)
                    {
                        goto EnumNextLocale;
                    }

                    RtlInitUnicodeString( &ObUnicodeStr,
                                          GET_VALUE_DATA_PTR(pKeyValueFull1) );

                    if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 16, &Data)) ||
                        (Data == 0) ||
                        (QueryRegValue( hLangGroupsKey,
                                        ObUnicodeStr.Buffer,
                                        &pKeyValueFull2,
                                        MAX_KEY_VALUE_FULLINFO,
                                        NULL ) != NO_ERROR) ||
                        (pKeyValueFull2->DataLength <= 2))
                    {
                        goto EnumNextLocale;
                    }
                    pData = GET_VALUE_DATA_PTR(pKeyValueFull2);
                    if ((pData[0] != L'1') || (pData[1] != 0))
                    {
                        goto EnumNextLocale;
                    }
                }

                //
                //  Store the locale id in the callback buffer.
                //
                *(pBuffer) = *pName;
                *(pBuffer + 1) = *(pName + 1);
                *(pBuffer + 2) = *(pName + 2);
                *(pBuffer + 3) = *(pName + 3);
                *(pBuffer + 4) = *(pName + 4);
                *(pBuffer + 5) = *(pName + 5);
                *(pBuffer + 6) = *(pName + 6);
                *(pBuffer + 7) = *(pName + 7);

                *(pBuffer + 8) = 0;

                //
                //  Call the appropriate callback function.
                //
                NLS_CALL_ENUMPROC_BREAK( gSystemLocale,
                                         lpLocaleEnumProc,
                                         dwFlags,
                                         pBuffer,
                                         fUnicodeVer );
            }

EnumNextLocale:
            //
            //  Increment enumeration index value and get the next enumeration.
            //
            Index++;
            RtlZeroMemory(pKeyValueFull1, MAX_KEY_VALUE_FULLINFO);
            rc = NtEnumerateValueKey( hKey,
                                      Index,
                                      KeyValueFullInformation,
                                      pKeyValueFull1,
                                      MAX_KEY_VALUE_FULLINFO,
                                      &ResultLength );
        }

        //
        //  The counter can be either 1 or 2 at this point.  If it's 2, then
        //  we've just done the Locale key and we need to do the alternate
        //  sorts key.  If it's 1, then it doesn't matter what this is set to
        //  since we're done with the loop.
        //
        hKey = hAltSortsKey;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Internal_EnumSystemCodePages
//
//  Enumerates the system code pages that are installed or supported, based
//  on the dwFlags parameter.  It does so by passing the pointer to the
//  string buffer containing the code page id to an application-defined
//  callback function.  It continues until the last code page is found or
//  the callback function returns FALSE.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL Internal_EnumSystemCodePages(
    NLS_ENUMPROC lpCodePageEnumProc,
    DWORD dwFlags,
    BOOL fUnicodeVer)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull = NULL;
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];

    BOOL fInstalled;              // if installed flag set
    ULONG Index = 0;              // index for enumeration
    ULONG ResultLength;           // # bytes written
    WCHAR wch;                    // first char of name
    LPWSTR pName;                 // ptr to name string from registry
    ULONG NameLen;                // length of name string
    ULONG rc = 0L;                // return code


    //
    //  Invalid Parameter Check:
    //    - function pointer is null
    //
    if (lpCodePageEnumProc == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Invalid Flags Check:
    //    - flags other than valid ones
    //    - more than one of either supported or installed
    //
    if ( (dwFlags & ESCP_INVALID_FLAG) ||
         (MORE_THAN_ONE(dwFlags, ESCP_SINGLE_FLAG)) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (FALSE);
    }

    //
    //  Initialize flag option.
    //
    fInstalled = dwFlags & CP_INSTALLED;

    //
    //  Loop through the code page ids in the registry, call the function
    //  pointer for each one that meets the flag criteria.
    //
    //  End loop if either FALSE is returned from the callback function
    //  or the end of the list is reached.
    //
    //  Always need to ignore the ACP, OEMCP, MACCP, and OEMHAL entries.
    //
    OPEN_CODEPAGE_KEY(FALSE);

    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    RtlZeroMemory(pKeyValueFull, MAX_KEY_VALUE_FULLINFO);
    rc = NtEnumerateValueKey( hCodePageKey,
                              Index,
                              KeyValueFullInformation,
                              pKeyValueFull,
                              MAX_KEY_VALUE_FULLINFO,
                              &ResultLength );

    while (rc != STATUS_NO_MORE_ENTRIES)
    {
        if (!NT_SUCCESS(rc))
        {
            //
            //  If we get a different error, then the registry
            //  is corrupt.  Just return FALSE.
            //
            KdPrint(("NLSAPI: CP Enumeration Error - registry corrupt. - %lx.\n",
                     rc));
            SetLastError(ERROR_BADDB);
            return (FALSE);
        }

        //
        //  Skip over the ACP, OEMCP, MACCP, and OEMHAL entries in the
        //  registry, and any entry that does not have data associated
        //  with it if the CP_INSTALLED flag is set.
        //
        pName = pKeyValueFull->Name;
        wch = *pName;
        NameLen = pKeyValueFull->NameLength / sizeof(WCHAR);
        if ( (NameLen <= ENUM_MAX_CP_SIZE) &&
             (wch >= NLS_CHAR_ZERO) && (wch <= NLS_CHAR_NINE) &&
             (!((fInstalled) && (pKeyValueFull->DataLength <= 2))) )
        {
            //
            //  Store the code page id string in the callback buffer.
            //
            pName[NameLen] = 0;

            //
            //  Call the appropriate callback function.
            //
            NLS_CALL_ENUMPROC_TRUE( gSystemLocale,
                                     lpCodePageEnumProc,
                                     dwFlags,
                                     pName,
                                     0,
                                     fUnicodeVer,
                                     0 );
        }

        //
        //  Increment enumeration index value and get the next enumeration.
        //
        Index++;
        RtlZeroMemory(pKeyValueFull, MAX_KEY_VALUE_FULLINFO);
        rc = NtEnumerateValueKey( hCodePageKey,
                                  Index,
                                  KeyValueFullInformation,
                                  pKeyValueFull,
                                  MAX_KEY_VALUE_FULLINFO,
                                  &ResultLength );
    }

    //
    //  Include UTF-7 and UTF-8 code pages in the enumeration -
    //  both installed and supported.
    //
    NLS_CALL_ENUMPROC_TRUE( gSystemLocale,
                            lpCodePageEnumProc,
                            dwFlags,
                            L"65000",
                            0,
                            fUnicodeVer,
                            0 );
    NLS_CALL_ENUMPROC_TRUE( gSystemLocale,
                            lpCodePageEnumProc,
                            dwFlags,
                            L"65001",
                            0,
                            fUnicodeVer,
                            0 );

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Internal_EnumCalendarInfo
//
//  Enumerates the specified calendar information that is available for the
//  specified locale, based on the CalType parameter.  It does so by
//  passing the pointer to the string buffer containing the calendar info
//  to an application-defined callback function.  It continues until the
//  last calendar info is found or the callback function returns FALSE.
//
//  10-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL Internal_EnumCalendarInfo(
    NLS_ENUMPROC lpCalInfoEnumProc,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    BOOL fUnicodeVer,
    BOOL fExVersion)
{
    PLOC_HASH pHashN;             // ptr to LOC hash node
    ULONG CalFieldOffset;         // field offset in calendar structure
    ULONG EndCalFieldOffset;      // field offset in calendar structure
    ULONG LocFieldOffset;         // field offset in locale structure
    ULONG EndLocFieldOffset;      // field offset in locale structure
    LPWSTR pOptCal;               // ptr to optional calendar values
    LPWSTR pEndOptCal;            // ptr to end of optional calendars
    PCAL_INFO pCalInfo;           // ptr to calendar info
    BOOL fIfName = FALSE;         // if caltype is a name
    UINT fEra = 0;                // if era caltype
    BOOL fLocaleInfo = TRUE;      // if locale information
    LPWSTR pString;               // ptr to enumeration string
    LPWSTR pEndString;            // ptr to end of enumeration string
    CALID CalNum;                 // calendar number
    DWORD UseCPACP;               // original caltype - if use system ACP
    WCHAR pTemp[MAX_REG_VAL_SIZE];// temp buffer to hold two-digit-year-max


    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - function pointer is null
    //
    //    - CalType will be checked in switch statement below.
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ((pHashN == NULL) || (lpCalInfoEnumProc == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Initialize the pointers to the optional calendar data.
    //
    if (Calendar == ENUM_ALL_CALENDARS)
    {
        pOptCal = (LPWORD)(pHashN->pLocaleHdr) + pHashN->pLocaleHdr->IOptionalCal;
        pEndOptCal = (LPWORD)(pHashN->pLocaleHdr) + pHashN->pLocaleHdr->SDayName1;
    }
    else
    {
        //
        //  Validate the Calendar parameter.
        //
        if ((pOptCal = IsValidCalendarType(pHashN, Calendar)) == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (FALSE);
        }
        pEndOptCal = pOptCal + ((POPT_CAL)pOptCal)->Offset;
    }

    //
    //  Enumerate the information based on CalType.
    //
    UseCPACP = (DWORD)CalType;
    CalType = NLS_GET_CALTYPE_VALUE(CalType);
    switch (CalType)
    {
        case ( CAL_ICALINTVALUE ) :
        {
            //
            //  Get the integer value for each of the alternate
            //  calendars (as a string).
            //
            while (pOptCal < pEndOptCal)
            {
                if (((POPT_CAL)pOptCal)->CalId != CAL_NO_OPTIONAL)
                {
                    //
                    //  Call the appropriate callback function.
                    //
                    NLS_CALL_ENUMPROC_TRUE( Locale,
                                            lpCalInfoEnumProc,
                                            UseCPACP,
                                            ((POPT_CAL)pOptCal)->pCalStr,
                                            ((POPT_CAL)pOptCal)->CalId,
                                            fUnicodeVer,
                                            fExVersion );
                }

                //
                //  Advance ptr to next optional calendar.
                //
                pOptCal += ((POPT_CAL)pOptCal)->Offset;
            }

            return (TRUE);

            break;
        }
        case ( CAL_SCALNAME ) :
        {
            //
            //  Get the calendar name for each of the alternate
            //  calendars.
            //
            while (pOptCal < pEndOptCal)
            {
                if (((POPT_CAL)pOptCal)->CalId != CAL_NO_OPTIONAL)
                {
                    //
                    //  Call the appropriate callback function.
                    //
                    NLS_CALL_ENUMPROC_TRUE(
                            Locale,
                            lpCalInfoEnumProc,
                            UseCPACP,
                            ((POPT_CAL)pOptCal)->pCalStr +
                            NlsStrLenW(((POPT_CAL)pOptCal)->pCalStr) + 1,
                            ((POPT_CAL)pOptCal)->CalId,
                            fUnicodeVer,
                            fExVersion );
                }

                //
                //  Advance ptr to next optional calendar.
                //
                pOptCal += ((POPT_CAL)pOptCal)->Offset;
            }

            return (TRUE);

            break;
        }
        case ( CAL_ITWODIGITYEARMAX ) :
        {
            fLocaleInfo = FALSE;
            CalFieldOffset    = FIELD_OFFSET(CALENDAR_VAR, STwoDigitYearMax);
            EndCalFieldOffset = FIELD_OFFSET(CALENDAR_VAR, SEraRanges);

            if (!(UseCPACP & CAL_NOUSEROVERRIDE))
            {
                while (pOptCal < pEndOptCal)
                {
                    CalNum = ((POPT_CAL)pOptCal)->CalId;

                    if (CalNum != CAL_NO_OPTIONAL)
                    {
                        //
                        // Look into the registry first
                        //
                        if (GetTwoDigitYearInfo(CalNum, pTemp, ARRAYSIZE(pTemp), NLS_POLICY_TWO_DIGIT_YEAR_KEY) ||
                            GetTwoDigitYearInfo(CalNum, pTemp, ARRAYSIZE(pTemp), NLS_TWO_DIGIT_YEAR_KEY))
                        {
                            NLS_CALL_ENUMPROC_TRUE(
                                    Locale,
                                    lpCalInfoEnumProc,
                                    UseCPACP,
                                    pTemp,
                                    CalNum,
                                    fUnicodeVer,
                                    fExVersion );
                        }
                        else
                        {
                            //
                            // Try to find the system default if we couldn't find the
                            // user setting in the registry or the user has asked for
                            // system default.
                            //
                            if (GetCalendar(CalNum, &pCalInfo) == NO_ERROR)
                            {
                                pString = (LPWORD)pCalInfo +
                                          *((LPWORD)((LPBYTE)(pCalInfo) + CalFieldOffset));
                                pEndString = (LPWORD)pCalInfo +
                                             *((LPWORD)((LPBYTE)(pCalInfo) + EndCalFieldOffset));

                                if (*pString)
                                {
                                   while (pString < pEndString)
                                   {
                                        //
                                        //  Make sure the string is NOT empty.
                                        //
                                        if (*pString)
                                        {
                                            //
                                            //  Call the appropriate callback function.
                                            //
                                            NLS_CALL_ENUMPROC_TRUE(
                                                    Locale,
                                                    lpCalInfoEnumProc,
                                                    UseCPACP,
                                                    pString,
                                                    CalNum,
                                                    fUnicodeVer,
                                                    fExVersion );
                                        }

                                        //
                                        //  Advance pointer to next string.
                                        //
                                        pString += NlsStrLenW(pString) + 1;
                                    }
                                }
                            }
                        }
                    }

                    //
                    //  Advance ptr to next optional calendar.
                    //
                    pOptCal += ((POPT_CAL)pOptCal)->Offset;
                }

                return (TRUE);
            }

            break;
        }
        case ( CAL_IYEAROFFSETRANGE ) :
        case ( CAL_SERASTRING ) :
        {
            fEra = CalType;
            CalFieldOffset    = FIELD_OFFSET(CALENDAR_VAR, SEraRanges);
            EndCalFieldOffset = FIELD_OFFSET(CALENDAR_VAR, SShortDate);

            break;
        }
        case ( CAL_SSHORTDATE ) :
        {
            CalFieldOffset    = FIELD_OFFSET(CALENDAR_VAR, SShortDate);
            EndCalFieldOffset = FIELD_OFFSET(CALENDAR_VAR, SYearMonth);
            LocFieldOffset    = FIELD_OFFSET(LOCALE_VAR, SShortDate);
            EndLocFieldOffset = FIELD_OFFSET(LOCALE_VAR, SDate);

            break;
        }
        case ( CAL_SLONGDATE ) :
        {
            CalFieldOffset    = FIELD_OFFSET(CALENDAR_VAR, SLongDate);
            EndCalFieldOffset = FIELD_OFFSET(CALENDAR_VAR, SDayName1);
            LocFieldOffset    = FIELD_OFFSET(LOCALE_VAR, SLongDate);
            EndLocFieldOffset = FIELD_OFFSET(LOCALE_VAR, IOptionalCal);

            break;
        }
        case ( CAL_SYEARMONTH ) :
        {
            CalFieldOffset    = FIELD_OFFSET(CALENDAR_VAR, SYearMonth);
            EndCalFieldOffset = FIELD_OFFSET(CALENDAR_VAR, SLongDate);
            LocFieldOffset    = FIELD_OFFSET(LOCALE_VAR, SYearMonth);
            EndLocFieldOffset = FIELD_OFFSET(LOCALE_VAR, SLongDate);

            break;
        }
        case ( CAL_SDAYNAME1 ) :
        case ( CAL_SDAYNAME2 ) :
        case ( CAL_SDAYNAME3 ) :
        case ( CAL_SDAYNAME4 ) :
        case ( CAL_SDAYNAME5 ) :
        case ( CAL_SDAYNAME6 ) :
        case ( CAL_SDAYNAME7 ) :
        case ( CAL_SABBREVDAYNAME1 ) :
        case ( CAL_SABBREVDAYNAME2 ) :
        case ( CAL_SABBREVDAYNAME3 ) :
        case ( CAL_SABBREVDAYNAME4 ) :
        case ( CAL_SABBREVDAYNAME5 ) :
        case ( CAL_SABBREVDAYNAME6 ) :
        case ( CAL_SABBREVDAYNAME7 ) :
        case ( CAL_SMONTHNAME1 ) :
        case ( CAL_SMONTHNAME2 ) :
        case ( CAL_SMONTHNAME3 ) :
        case ( CAL_SMONTHNAME4 ) :
        case ( CAL_SMONTHNAME5 ) :
        case ( CAL_SMONTHNAME6 ) :
        case ( CAL_SMONTHNAME7 ) :
        case ( CAL_SMONTHNAME8 ) :
        case ( CAL_SMONTHNAME9 ) :
        case ( CAL_SMONTHNAME10 ) :
        case ( CAL_SMONTHNAME11 ) :
        case ( CAL_SMONTHNAME12 ) :
        case ( CAL_SMONTHNAME13 ) :
        case ( CAL_SABBREVMONTHNAME1 ) :
        case ( CAL_SABBREVMONTHNAME2 ) :
        case ( CAL_SABBREVMONTHNAME3 ) :
        case ( CAL_SABBREVMONTHNAME4 ) :
        case ( CAL_SABBREVMONTHNAME5 ) :
        case ( CAL_SABBREVMONTHNAME6 ) :
        case ( CAL_SABBREVMONTHNAME7 ) :
        case ( CAL_SABBREVMONTHNAME8 ) :
        case ( CAL_SABBREVMONTHNAME9 ) :
        case ( CAL_SABBREVMONTHNAME10 ) :
        case ( CAL_SABBREVMONTHNAME11 ) :
        case ( CAL_SABBREVMONTHNAME12 ) :
        case ( CAL_SABBREVMONTHNAME13 ) :
        {
            fIfName = TRUE;
            CalFieldOffset    = FIELD_OFFSET(CALENDAR_VAR, SDayName1) +
                                ((CalType - CAL_SDAYNAME1) * sizeof(WORD));
            EndCalFieldOffset = FIELD_OFFSET(CALENDAR_VAR, SDayName1) +
                                ((CalType - CAL_SDAYNAME1 + 1) * sizeof(WORD));
            LocFieldOffset    = FIELD_OFFSET(LOCALE_VAR, SDayName1) +
                                ((CalType - CAL_SDAYNAME1) * sizeof(WORD));
            EndLocFieldOffset = FIELD_OFFSET(LOCALE_VAR, SDayName1) +
                                ((CalType - CAL_SDAYNAME1 + 1) * sizeof(WORD));

            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (FALSE);
        }
    }

    //
    //  Get the requested information for each of the alternate calendars.
    //
    //  This loop is used for the following CalTypes:
    //
    //     iYearOffsetRange         (fEra = TRUE)
    //     sEraString               (fEra = TRUE)
    //
    //     sShortDate
    //     sLongDate
    //     sYearMonth
    //
    //     sDayName1-7              (fIfName = TRUE)
    //     sAbbrevDayName1-7        (fIfName = TRUE)
    //     sMonthName1-7            (fIfName = TRUE)
    //     sAbbrevMonthName1-7      (fIfName = TRUE)
    //
    while (pOptCal < pEndOptCal)
    {
        //
        //  Get the pointer to the appropriate calendar.
        //
        CalNum = ((POPT_CAL)pOptCal)->CalId;
        if (GetCalendar(CalNum, &pCalInfo) == NO_ERROR)
        {
            //
            //  Check era information flag.
            //
            if (fEra)
            {
                //
                //  Get the pointer to the appropriate calendar string.
                //
                pString = (LPWORD)pCalInfo +
                          *((LPWORD)((LPBYTE)(pCalInfo) + CalFieldOffset));

                pEndString = (LPWORD)pCalInfo +
                             *((LPWORD)((LPBYTE)(pCalInfo) + EndCalFieldOffset));

                //
                //  Make sure the string is NOT empty.
                //
                if (*pString)
                {
                    //
                    //  See which era information to get.
                    //
                    if (fEra == CAL_IYEAROFFSETRANGE)
                    {
                        while (pString < pEndString)
                        {
                            //
                            //  Call the appropriate callback function.
                            //
                            NLS_CALL_ENUMPROC_TRUE(
                                    Locale,
                                    lpCalInfoEnumProc,
                                    UseCPACP,
                                    ((PERA_RANGE)pString)->pYearStr,
                                    CalNum,
                                    fUnicodeVer,
                                    fExVersion );

                            //
                            //  Advance pointer to next era range.
                            //
                            pString += ((PERA_RANGE)pString)->Offset;
                        }
                    }
                    else
                    {
                        while (pString < pEndString)
                        {
                            //
                            //  Call the appropriate callback function.
                            //
                            NLS_CALL_ENUMPROC_TRUE(
                                    Locale,
                                    lpCalInfoEnumProc,
                                    UseCPACP,
                                    ((PERA_RANGE)pString)->pYearStr +
                                    NlsStrLenW(((PERA_RANGE)pString)->pYearStr) + 1,
                                    CalNum,
                                    fUnicodeVer,
                                    fExVersion );

                            //
                            //  Advance pointer to next era range.
                            //
                            pString += ((PERA_RANGE)pString)->Offset;
                        }
                    }
                }
            }
            else
            {
                //
                //  Get the pointer to the appropriate calendar string.
                //
                if ((!fIfName) ||
                    (((PCALENDAR_VAR)pCalInfo)->IfNames))
                {
                    pString = (LPWORD)pCalInfo +
                              *((LPWORD)((LPBYTE)(pCalInfo) + CalFieldOffset));

                    pEndString = (LPWORD)pCalInfo +
                                 *((LPWORD)((LPBYTE)(pCalInfo) + EndCalFieldOffset));
                }
                else
                {
                    pString = L"";
                }

                //
                //  Make sure we have a string.  Otherwise, use the
                //  information from the locale section (if appropriate).
                //
                if ((*pString == 0) && (fLocaleInfo) &&
                    ((CalNum == CAL_GREGORIAN) ||
                     (Calendar != ENUM_ALL_CALENDARS)))
                {
                    //
                    //  Use the default locale string.
                    //
                    pString = (LPWORD)(pHashN->pLocaleHdr) +
                              *((LPWORD)((LPBYTE)(pHashN->pLocaleHdr) +
                                         LocFieldOffset));

                    pEndString = (LPWORD)(pHashN->pLocaleHdr) +
                                 *((LPWORD)((LPBYTE)(pHashN->pLocaleHdr) +
                                            EndLocFieldOffset));
                }

                //
                //  Go through each of the strings.
                //
                if (*pString)
                {
                    while (pString < pEndString)
                    {
                        //
                        //  Make sure the string is NOT empty.
                        //
                        if (*pString)
                        {
                            //
                            //  Call the appropriate callback function.
                            //
                            NLS_CALL_ENUMPROC_TRUE( Locale,
                                                    lpCalInfoEnumProc,
                                                    UseCPACP,
                                                    pString,
                                                    CalNum,
                                                    fUnicodeVer,
                                                    fExVersion );
                        }

                        //
                        //  Advance pointer to next string.
                        //
                        pString += NlsStrLenW(pString) + 1;
                    }
                }
            }
        }

        //
        //  Advance ptr to next optional calendar.
        //
        pOptCal += ((POPT_CAL)pOptCal)->Offset;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Internal_EnumTimeFormats
//
//  Enumerates the time formats that are available for the
//  specified locale, based on the dwFlags parameter.  It does so by
//  passing the pointer to the string buffer containing the time format
//  to an application-defined callback function.  It continues until the
//  last time format is found or the callback function returns FALSE.
//
//  10-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL Internal_EnumTimeFormats(
    NLS_ENUMPROC lpTimeFmtEnumProc,
    LCID Locale,
    DWORD dwFlags,
    BOOL fUnicodeVer)
{
    PLOC_HASH pHashN;             // ptr to LOC hash node


    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - function pointer is null
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ((pHashN == NULL) || (lpTimeFmtEnumProc == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Invalid Flags Check:
    //    - flags other than valid ones
    //
    if (dwFlags & ETF_INVALID_FLAG)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (FALSE);
    }

    //
    //  Enumerate the time formats.
    //
    return ( EnumDateTime( lpTimeFmtEnumProc,
                           Locale,
                           LOCALE_STIMEFORMAT,
                           dwFlags,
                           FIELD_OFFSET(NLS_USER_INFO, sTimeFormat),
                           NLS_VALUE_STIMEFORMAT,
                           pHashN->pLocaleHdr,
                           (LPWORD)(pHashN->pLocaleHdr) +
                             pHashN->pLocaleHdr->STimeFormat,
                           (LPWORD)(pHashN->pLocaleHdr) +
                             pHashN->pLocaleHdr->STime,
                           (ULONG)0,
                           (ULONG)0,
                           FALSE,
                           fUnicodeVer,
                           FALSE ) );
}


////////////////////////////////////////////////////////////////////////////
//
//  Internal_EnumDateFormats
//
//  Enumerates the short date, long date, or year/month formats that are
//  available for the specified locale, based on the dwFlags parameter.
//  It does so by passing the pointer to the string buffer containing the
//  date format (and the calendar id if called from the Ex version) to an
//  application-defined callback function.  It continues until the last
//  date format is found or the callback function returns FALSE.
//
//  10-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL Internal_EnumDateFormats(
    NLS_ENUMPROC lpDateFmtEnumProc,
    LCID Locale,
    DWORD dwFlags,
    BOOL fUnicodeVer,
    BOOL fExVersion)
{
    PLOC_HASH pHashN;             // ptr to LOC hash node


    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - function pointer is null
    //
    //    - flags will be validated in switch statement below
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ((pHashN == NULL) || (lpDateFmtEnumProc == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Enumerate the date pictures based on the flags.
    //
    switch (dwFlags & (~LOCALE_USE_CP_ACP))
    {
        case ( 0 ) :
        case ( DATE_SHORTDATE ) :
        {
            //
            //  Enumerate the short date formats.
            //
            return ( EnumDateTime( lpDateFmtEnumProc,
                                   Locale,
                                   LOCALE_SSHORTDATE,
                                   dwFlags,
                                   FIELD_OFFSET(NLS_USER_INFO, sShortDate),
                                   NLS_VALUE_SSHORTDATE,
                                   pHashN->pLocaleHdr,
                                   (LPWORD)(pHashN->pLocaleHdr) +
                                     pHashN->pLocaleHdr->SShortDate,
                                   (LPWORD)(pHashN->pLocaleHdr) +
                                     pHashN->pLocaleHdr->SDate,
                                   (ULONG)FIELD_OFFSET(CALENDAR_VAR, SShortDate),
                                   (ULONG)FIELD_OFFSET(CALENDAR_VAR, SYearMonth),
                                   TRUE,
                                   fUnicodeVer,
                                   fExVersion ) );

            break;
        }

        case ( DATE_LONGDATE ) :
        {
            //
            //  Enumerate the long date formats.
            //
            return ( EnumDateTime( lpDateFmtEnumProc,
                                   Locale,
                                   LOCALE_SLONGDATE,
                                   dwFlags,
                                   FIELD_OFFSET(NLS_USER_INFO, sLongDate),
                                   NLS_VALUE_SLONGDATE,
                                   pHashN->pLocaleHdr,
                                   (LPWORD)(pHashN->pLocaleHdr) +
                                     pHashN->pLocaleHdr->SLongDate,
                                   (LPWORD)(pHashN->pLocaleHdr) +
                                     pHashN->pLocaleHdr->IOptionalCal,
                                   (ULONG)FIELD_OFFSET(CALENDAR_VAR, SLongDate),
                                   (ULONG)FIELD_OFFSET(CALENDAR_VAR, SDayName1),
                                   TRUE,
                                   fUnicodeVer,
                                   fExVersion ) );

            break;
        }

        case ( DATE_YEARMONTH ) :
        {
            //
            //  Enumerate the year month formats.
            //
            return ( EnumDateTime( lpDateFmtEnumProc,
                                   Locale,
                                   LOCALE_SYEARMONTH,
                                   dwFlags,
                                   FIELD_OFFSET(NLS_USER_INFO, sYearMonth),
                                   NLS_VALUE_SYEARMONTH,
                                   pHashN->pLocaleHdr,
                                   (LPWORD)(pHashN->pLocaleHdr) +
                                     pHashN->pLocaleHdr->SYearMonth,
                                   (LPWORD)(pHashN->pLocaleHdr) +
                                     pHashN->pLocaleHdr->SLongDate,
                                   (ULONG)FIELD_OFFSET(CALENDAR_VAR, SYearMonth),
                                   (ULONG)FIELD_OFFSET(CALENDAR_VAR, SLongDate),
                                   TRUE,
                                   fUnicodeVer,
                                   fExVersion ) );

            break;
        }

        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (FALSE);
        }
    }
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  EnumDateTime
//
//  Enumerates the short date, long date, year/month, or time formats that
//  are available for the specified locale.  This is the worker routine for
//  the EnumTimeFormats and EnumDateFormats apis.
//
//  10-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL EnumDateTime(
    NLS_ENUMPROC lpDateTimeFmtEnumProc,
    LCID Locale,
    LCTYPE LCType,
    DWORD dwFlags,
    SIZE_T CacheOffset,
    LPWSTR pRegValue,
    PLOCALE_VAR pLocaleHdr,
    LPWSTR pDateTime,
    LPWSTR pEndDateTime,
    ULONG CalDateOffset,
    ULONG EndCalDateOffset,
    BOOL fCalendarInfo,
    BOOL fUnicodeVer,
    BOOL fExVersion)
{
    LPWSTR pUser = NULL;               // ptr to user date/time string
    LPWSTR pOptCal;                    // ptr to optional calendar values
    LPWSTR pEndOptCal;                 // ptr to end of optional calendars
    PCAL_INFO pCalInfo;                // ptr to calendar info
    CALID CalNum = 1;                  // calendar number
    WCHAR pTemp[MAX_REG_VAL_SIZE];     // temp buffer
    UNICODE_STRING ObUnicodeStr;       // calendar id string


    //
    //  Get the user's Calendar ID.
    //
    if (fExVersion)
    {
        if (GetUserInfo( Locale,
                         LOCALE_ICALENDARTYPE,
                         FIELD_OFFSET(NLS_USER_INFO, iCalType),                         
                         NLS_VALUE_ICALENDARTYPE,
                         pTemp,
                         ARRAYSIZE(pTemp),
                         TRUE ))
        {
            RtlInitUnicodeString(&ObUnicodeStr, pTemp);
            if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &CalNum)) ||
                (CalNum < 1) || (CalNum > CAL_LAST))
            {
                CalNum = 1;
            }
        }
    }

    //
    //  Get the user defined string.
    //
    if (GetUserInfo( Locale,
                     LCType,
                     CacheOffset,
                     pRegValue,
                     pTemp,
                     ARRAYSIZE(pTemp),
                     TRUE ))
    {
        pUser = pTemp;

        //
        //  Call the appropriate callback function.
        //
        NLS_CALL_ENUMPROC_TRUE( Locale,
                                lpDateTimeFmtEnumProc,
                                dwFlags,
                                pUser,
                                CalNum,
                                fUnicodeVer,
                                fExVersion );
    }

    //
    //  Get the default strings defined for the Gregorian
    //  calendar.
    //
    while (pDateTime < pEndDateTime)
    {
        //
        //  Call the callback function if the string is not
        //  the same as the user string.
        //
        if ((!pUser) || (!NlsStrEqualW(pUser, pDateTime)))
        {
            //
            //  Call the appropriate callback function.
            //
            NLS_CALL_ENUMPROC_TRUE( Locale,
                                    lpDateTimeFmtEnumProc,
                                    dwFlags,
                                    pDateTime,
                                    CAL_GREGORIAN,
                                    fUnicodeVer,
                                    fExVersion );
        }

        //
        //  Advance pDateTime pointer.
        //
        pDateTime += NlsStrLenW(pDateTime) + 1;
    }

    if (fCalendarInfo)
    {
        //
        //  Get any alternate calendar dates.
        //
        pOptCal = (LPWORD)(pLocaleHdr) + pLocaleHdr->IOptionalCal;
        if (((POPT_CAL)pOptCal)->CalId == CAL_NO_OPTIONAL)
        {
            //
            //  No optional calendars, so done.
            //
            return (TRUE);
        }

        //
        //  Get the requested information for each of the alternate
        //  calendars.
        //
        pEndOptCal = (LPWORD)(pLocaleHdr) + pLocaleHdr->SDayName1;
        while (pOptCal < pEndOptCal)
        {
            //
            //  Get the pointer to the calendar information.
            //
            CalNum = ((POPT_CAL)pOptCal)->CalId;
            if (GetCalendar(CalNum, &pCalInfo) == NO_ERROR)
            {
                //
                //  Get the pointer to the date/time information for the
                //  current calendar.
                //
                pDateTime = (LPWORD)pCalInfo +
                            *((LPWORD)((LPBYTE)(pCalInfo) + CalDateOffset));

                pEndDateTime = (LPWORD)pCalInfo +
                               *((LPWORD)((LPBYTE)(pCalInfo) + EndCalDateOffset));

                //
                //  Go through each of the strings.
                //
                while (pDateTime < pEndDateTime)
                {
                    //
                    //  Make sure the string is NOT empty and that it is
                    //  NOT the same as the user's string.
                    //
                    if ((*pDateTime) &&
                        ((!pUser) || (!NlsStrEqualW(pUser, pDateTime))))
                    {
                        //
                        //  Call the appropriate callback function.
                        //
                        NLS_CALL_ENUMPROC_TRUE( Locale,
                                                lpDateTimeFmtEnumProc,
                                                dwFlags,
                                                pDateTime,
                                                CalNum,
                                                fUnicodeVer,
                                                fExVersion );
                    }

                    //
                    //  Advance pointer to next date string.
                    //
                    pDateTime += NlsStrLenW(pDateTime) + 1;
                }
            }

            //
            //  Advance ptr to next optional calendar.
            //
            pOptCal += ((POPT_CAL)pOptCal)->Offset;
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\csrlocal.c ===
/*++

Copyright (c) 1998-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    csrlocal.c

Abstract:

    This module implements functions that are used by the functions in locale.c
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/



//
//  Include Files.
//

#include "nls.h"
#include "ntwow64n.h"





////////////////////////////////////////////////////////////////////////////
//
//  CsrBasepNlsSetUserInfo
//
//  Parameters:
//      LCType      The type of locale information to be set.
//      pData       The buffer which contains the information to be set.
//                  This is usually an Unicode string.
//      DataLength  The length of pData in BYTE.
//
//  Return:
//      STATUS_SUCCESS  if the locale information is set correctly.
//      Otherwise, a proper NTSTATUS error code is returned.
//
//  Note:
//      When kernel32.dll is complied for the WOW64 layer, we will call
//      a thunk function NtWow64CsrBasepNlsSetUserInfo(), and it will
//      in turn call the corresponding 64-bit version of this function.
//
////////////////////////////////////////////////////////////////////////////

NTSTATUS CsrBasepNlsSetUserInfo(
    IN LCTYPE LCType,
    IN LPWSTR pData,
    IN ULONG DataLength)
{

#if defined(BUILD_WOW6432)

    return (NtWow64CsrBasepNlsSetUserInfo( LCType,
                                           pData,
                                           DataLength ));

#else

    BASE_API_MSG m;
    PBASE_NLS_SET_USER_INFO_MSG a = &m.u.NlsSetUserInfo;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

    //
    //  Get the capture buffer for the strings.
    //
    CaptureBuffer = CsrAllocateCaptureBuffer( 1, DataLength );

    if (CaptureBuffer == NULL)
    {
        return (STATUS_NO_MEMORY);
    }

    if (CsrAllocateMessagePointer(CaptureBuffer, DataLength, (PVOID *)&(a->pData)) == 0)
    {
        goto exit;
    }

    RtlCopyMemory (a->pData, pData, DataLength);    

    //
    //  Save the pointer to the cache string.
    //
    a->LCType = LCType;

    //
    //  Save the length of the data in the msg structure.
    //
    a->DataLength = DataLength;

    //
    //  Call the server to set the registry value.
    //
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepNlsSetUserInfo ),
                         sizeof(*a) );

exit:
    //
    //  Free the capture buffer.
    //
    if (CaptureBuffer != NULL)
    {
        CsrFreeCaptureBuffer(CaptureBuffer);
    }

    return (m.ReturnValue);

#endif

}


////////////////////////////////////////////////////////////////////////////
//
//  CsrBasepNlsGetUserInfo
//      
//  This function uses LPC to call into server side (csrss.exe) to retrieve
//  the locale setting from the registry cache.
//
//  Parameters
//      Locale  The locale to be retrived.  Note that this could be different from 
//              the current user locale stored in the registry cache.
//              If that's the case, this function will return FALSE.
//      CacheOffset  The offset in BYTE for the field in the NLS_USER_INFO cache to retrieve.  
//                  FIELD_OFFSET(NLS_USER_INFO, fieldName) should be used to get the offset.
//      pData   The pointer which points to the target buffer
//      DataLength  The size of the target buffer in BYTE (the NULL terminator is included in the count)
//
//  BIGNOTE BIGNOTE
//      This function follows the convention of CsrBasepNlsSetUserInfo to use
//      DataLength in BYTE.
//
//  BIGNOTE BIGNOTE
//      This method should be called in a critical section protected by gcsNlsProcessCache
//      since it will copy data into the process-wide cache pNlsUserInfo.
//
////////////////////////////////////////////////////////////////////////////

NTSTATUS CsrBasepNlsGetUserInfo(
    IN PNLS_USER_INFO pNlsCache,
    IN ULONG DataLength)
{

#if defined(BUILD_WOW6432)

    return (NtWow64CsrBasepNlsGetUserInfo( pNlsCache, DataLength));

#else

    BASE_API_MSG m;
    PBASE_NLS_GET_USER_INFO_MSG a = &m.u.NlsGetUserInfo;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
    NTSTATUS rc;
    
    //
    //  Get the capture buffer for the strings.
    //
    CaptureBuffer = CsrAllocateCaptureBuffer( 1, DataLength );

    if (CaptureBuffer == NULL)
    {
        return (STATUS_NO_MEMORY);
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             NULL,
                             DataLength,
                             (PVOID *)&a->pData );

    //
    //  Save the length of the data in the msg structure.
    //
    a->DataLength = DataLength;

    //
    //  Call the server to set the registry value.
    //
    rc = CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepNlsGetUserInfo ),
                         sizeof(*a) );

    if (NT_SUCCESS(rc))
    {
        // NOTE: DataLength is in BYTE.
        RtlCopyMemory(pNlsCache, a->pData, DataLength);
    }
    //
    //  Free the capture buffer.
    //
    if (CaptureBuffer != NULL)
    {
        CsrFreeCaptureBuffer(CaptureBuffer);
    }

    return (rc);

#endif

}


////////////////////////////////////////////////////////////////////////////
//
//  CsrBasepNlsSetMultipleUserInfo
//
////////////////////////////////////////////////////////////////////////////

NTSTATUS CsrBasepNlsSetMultipleUserInfo(
    IN DWORD dwFlags,
    IN int cchData,
    IN LPCWSTR pPicture,
    IN LPCWSTR pSeparator,
    IN LPCWSTR pOrder,
    IN LPCWSTR pTLZero,
    IN LPCWSTR pTimeMarkPosn)
{

#if defined(BUILD_WOW6432)

    return (NtWow64CsrBasepNlsSetMultipleUserInfo( dwFlags,
                                                   cchData,
                                                   pPicture,
                                                   pSeparator,
                                                   pOrder,
                                                   pTLZero,
                                                   pTimeMarkPosn ));

#else

    ULONG CaptureLength;          // length of capture buffer
    ULONG Length;                 // temp storage for length of string

    BASE_API_MSG m;
    PBASE_NLS_SET_MULTIPLE_USER_INFO_MSG a = &m.u.NlsSetMultipleUserInfo;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

    //
    //  Initialize the msg structure to NULL.
    //
    RtlZeroMemory(a, sizeof(BASE_NLS_SET_MULTIPLE_USER_INFO_MSG));

    //
    //  Save the flags and the length of the data in the msg structure.
    //
    a->Flags = dwFlags;
    a->DataLength = cchData * sizeof(WCHAR);

    //
    //  Save the appropriate strings in the msg structure.
    //
    switch (dwFlags)
    {
        case ( LOCALE_STIMEFORMAT ) :
        {
            //
            //  Get the length of the capture buffer.
            //
            Length = wcslen(pSeparator) + 1;
            CaptureLength = (cchData + Length + 2 + 2 + 2) * sizeof(WCHAR);

            //
            //  Get the capture buffer for the strings.
            //
            CaptureBuffer = CsrAllocateCaptureBuffer( 5,
                                                      CaptureLength );
            if (CaptureBuffer != NULL)
            {
                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pPicture,
                                         cchData * sizeof(WCHAR),
                                         (PVOID *)&a->pPicture );

                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pSeparator,
                                         Length * sizeof(WCHAR),
                                         (PVOID *)&a->pSeparator );

                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pOrder,
                                         2 * sizeof(WCHAR),
                                         (PVOID *)&a->pOrder );

                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pTLZero,
                                         2 * sizeof(WCHAR),
                                         (PVOID *)&a->pTLZero );

                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pTimeMarkPosn,
                                         2 * sizeof(WCHAR),
                                         (PVOID *)&a->pTimeMarkPosn );
            }
            break;
        }
        case ( LOCALE_STIME ) :
        {
            //
            //  Get the length of the capture buffer.
            //
            Length = wcslen(pPicture) + 1;
            CaptureLength = (Length + cchData) * sizeof(WCHAR);

            //
            //  Get the capture buffer for the strings.
            //
            CaptureBuffer = CsrAllocateCaptureBuffer( 2,
                                                      CaptureLength );
            if (CaptureBuffer != NULL)
            {
                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pPicture,
                                         Length * sizeof(WCHAR),
                                         (PVOID *)&a->pPicture );

                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pSeparator,
                                         cchData * sizeof(WCHAR),
                                         (PVOID *)&a->pSeparator );
            }
            break;
        }
        case ( LOCALE_ITIME ) :
        {
            //
            //  Get the length of the capture buffer.
            //
            Length = wcslen(pPicture) + 1;
            CaptureLength = (Length + cchData) * sizeof(WCHAR);

            //
            //  Get the capture buffer for the strings.
            //
            CaptureBuffer = CsrAllocateCaptureBuffer( 2,
                                                      CaptureLength );
            if (CaptureBuffer != NULL)
            {
                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pPicture,
                                         Length * sizeof(WCHAR),
                                         (PVOID *)&a->pPicture );

                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pOrder,
                                         cchData * sizeof(WCHAR),
                                         (PVOID *)&a->pOrder );
            }
            break;
        }
        case ( LOCALE_SSHORTDATE ) :
        {
            //
            //  Get the length of the capture buffer.
            //
            Length = wcslen(pSeparator) + 1;
            CaptureLength = (cchData + Length + 2) * sizeof(WCHAR);

            //
            //  Get the capture buffer for the strings.
            //
            CaptureBuffer = CsrAllocateCaptureBuffer( 3,
                                                      CaptureLength );
            if (CaptureBuffer != NULL)
            {
                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pPicture,
                                         cchData * sizeof(WCHAR),
                                         (PVOID *)&a->pPicture );

                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pSeparator,
                                         Length * sizeof(WCHAR),
                                         (PVOID *)&a->pSeparator );

                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pOrder,
                                         2 * sizeof(WCHAR),
                                         (PVOID *)&a->pOrder );
            }
            break;
        }
        case ( LOCALE_SDATE ) :
        {
            //
            //  Get the length of the capture buffer.
            //
            Length = wcslen(pPicture) + 1;
            CaptureLength = (Length + cchData) * sizeof(WCHAR);

            //
            //  Get the capture buffer for the strings.
            //
            CaptureBuffer = CsrAllocateCaptureBuffer( 2,
                                                      CaptureLength );
            if (CaptureBuffer != NULL)
            {
                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pPicture,
                                         Length * sizeof(WCHAR),
                                         (PVOID *)&a->pPicture );

                CsrCaptureMessageBuffer( CaptureBuffer,
                                         (PCHAR)pSeparator,
                                         cchData * sizeof(WCHAR),
                                         (PVOID *)&a->pSeparator );
            }
            break;
        }
    }

    //
    //  Make sure the CaptureBuffer was created and filled in.
    //
    if (CaptureBuffer == NULL)
    {
        return (STATUS_NO_MEMORY);
    }

    //
    //  Call the server to set the registry values.
    //
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepNlsSetMultipleUserInfo ),
                         sizeof(*a) );

    //
    //  Free the capture buffer.
    //
    if (CaptureBuffer != NULL)
    {
        CsrFreeCaptureBuffer(CaptureBuffer);
    }

    return (m.ReturnValue);

#endif

}


////////////////////////////////////////////////////////////////////////////
//
//  CsrBasepNlsUpdateCacheCount
//
////////////////////////////////////////////////////////////////////////////

NTSTATUS CsrBasepNlsUpdateCacheCount()
{

#if defined(BUILD_WOW6432)

    return (NtWow64CsrBasepNlsUpdateCacheCount());

#else

    BASE_API_MSG m;
    PBASE_NLS_UPDATE_CACHE_COUNT_MSG a = &m.u.NlsCacheUpdateCount;

    a->Reserved = 0L;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepNlsUpdateCacheCount ),
                         sizeof(*a) );

    return (m.ReturnValue);

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\jamo.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    jamo.c

Abstract:

    This file contains functions that deal with the sorting of old Hangul.
    Korean characters (Hangul) can be composed by Jamos (U+1100 - U+11ff).
    However, some valid compositions of Jamo are not found in mordern
    Hangul (U+AC00 - U+D7AF).
    These valid compositions are called old Hangul.

    MapOldHangulSortKey() is called by CompareString() and MapSortKey() to
    handle the sorting of old Hangul.

Note:

    The Jamo composition means that several Jamo (Korean alpahbetic) composed
    a valid Hangul character or old Hangul character.
    Eg. U+1100 U+1103 U+1161 U+11a8 composes a valid old Hangul character.

    The following are data members of the global structure pTblPtrs used by
    old Hangul sorting:
        * pTblPtrs->pJamoIndex
            Given a Jamo, this is the index into the pJamoComposition state
              machine for this Jamo.
            The value for U+1100 is stored in pJamoIndex[0], U+1101 is in
              pJamoIndex[1], etc.
            The value for U+1100 is 1.  This means the state machine for
              U+1100 is stored in pJamoComposition[1].
            Note that not every Jamo can start a valid composition.  For
              those Jamos that can not start a valid composition, the table
              entry for that Jamo is 0.  E.g. the index for U+1101 is 0.

        * pTblPtrs->NumJamoIndex
            The number of entries in pJamoIndex.  Every index is a WORD.

        * pTblPtrs->pJamoComposition
            This is the Jamo composition state machine. It is used for two
            purposes:
                1. Used to verify a valid Jamo combination that composes an
                     old Hangul character.
                2. If a valid old Hangul composition is found, get the
                     SortInfo for the current combination.

        * pTblPtrs->NumJamoComposition
            The number of entires in pJamoComposition

Revision History:

    05-30-2000    JohnMcCo Create old Hangul sorting algorithm and sample.
    06-23-2000    YSLin    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"
#include "jamo.h"





//-------------------------------------------------------------------------//
//                           INTERNAL MACROS                               //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NOT_END_STRING
//
//  Checks to see if the search has reached the end of the string.
//  It returns TRUE if the counter is not at zero (counting backwards) and
//  the null termination has not been reached (if -2 was passed in the count
//  parameter.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NOT_END_STRING(ct, ptr, cchIn)                                     \
    ((ct != 0) && (!((*(ptr) == 0) && (cchIn == -2))))


////////////////////////////////////////////////////////////////////////////
//
//  GET_JAMO_INDEX
//
//  Update the global sort sequence info based on the new state.
//
////////////////////////////////////////////////////////////////////////////

#define GET_JAMO_INDEX(wch)   ((wch) - NLS_CHAR_FIRST_JAMO)





//-------------------------------------------------------------------------//
//                          INTERNAL ROUTINES                              //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UpdateJamoState
//
//  Update the sort result info based on the new state.
//
//  JamoClass   The current Jamo class (LeadingJamo/VowelJamo/TrailingJamo)
//  pSort       The sort information derived from the current state.
//  pSortResult The sort information for the final result.  Used to
//                collect info from pSort.
//
//  06-22-2000    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

void UpdateJamoState(
    int JamoClass,
    PJAMO_SORT_INFO pSort,
    PJAMO_SORT_INFOEX pSortResult)     // new sort sequence information
{
    //
    //  Record if this is a jamo unique to old Hangul.
    //
    pSortResult->m_bOld |= pSort->m_bOld;

    //
    //  Update the indices iff the new ones are higher than the current ones.
    //
    if (pSort->m_chLeadingIndex > pSortResult->m_chLeadingIndex)
    {
        pSortResult->m_chLeadingIndex = pSort->m_chLeadingIndex;
    }
    if (pSort->m_chVowelIndex > pSortResult->m_chVowelIndex)
    {
        pSortResult->m_chVowelIndex = pSort->m_chVowelIndex;
    }
    if (pSort->m_chTrailingIndex > pSortResult->m_chTrailingIndex)
    {
        pSortResult->m_chTrailingIndex = pSort->m_chTrailingIndex;
    }

    //
    //  Update the extra weights according to the current Jamo class.
    //
    switch (JamoClass)
    {
        case ( NLS_CLASS_LEADING_JAMO ) :
        {
            if (pSort->m_ExtraWeight > pSortResult->m_LeadingWeight)
            {
                pSortResult->m_LeadingWeight = pSort->m_ExtraWeight;
            }
            break;
        }
        case ( NLS_CLASS_VOWEL_JAMO ) :
        {
            if (pSort->m_ExtraWeight > pSortResult->m_VowelWeight)
            {
                pSortResult->m_VowelWeight = pSort->m_ExtraWeight;
            }
            break;
        }
        case ( NLS_CLASS_TRAILING_JAMO ) :
        {
            if (pSort->m_ExtraWeight > pSortResult->m_TrailingWeight)
            {
                pSortResult->m_TrailingWeight = pSort->m_ExtraWeight;
            }
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetJamoComposition
//
//  ppString                pointer to the current Jamo character
//  pCount                  pointer to the current character count (couting backwards)
//  cchSrc                  The total character count (if the value is -2, then the string is null-terminated)
//  currentJamoClass        the current Jamo class.
//  lpJamoTable             The entry in jamo table.
//  JamoSortInfo            the sort information for the final result.
//
//  NOTENOTE This function assumes that the character at *ppString is a leading Jamo.
//
//  06-12-2000    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

int GetJamoComposition(
    LPCWSTR* ppString,      // The pointer to the current character
    int* pCount,            // The current character count
    int cchSrc,             // The total character length
    int currentJamoClass,   // The current Jamo class.
    JAMO_SORT_INFOEX* JamoSortInfo    // The result Jamo sorting information.
    )
{
    WCHAR wch;
    int JamoClass;    
    int Index;
    PJAMO_TABLE pJamo;
    PJAMO_COMPOSE_STATE lpNext = NULL;
    PJAMO_COMPOSE_STATE pSearchEnd;

    wch = **ppString;
    //
    // Get the Jamo information for the current character.
    //
    pJamo = pTblPtrs->pJamoIndex + GET_JAMO_INDEX(wch);
    
    UpdateJamoState(currentJamoClass, &(pJamo->SortInfo), JamoSortInfo);

    //
    // Move on to next character.
    //
    (*ppString)++; 
    while (NOT_END_STRING(*pCount, *ppString, cchSrc))
    {
        wch = **ppString;
        if (!IsJamo(wch))
        {
            // The current character is not a Jamo. We are done with checking the Jamo composition.
            return (-1);
        }
        if (wch == 0x1160) {
            JamoSortInfo->m_bFiller = TRUE;
        }
        // Get the Jamo class of it.        
        if (IsLeadingJamo(wch))
        {
            JamoClass = NLS_CLASS_LEADING_JAMO;
        }
        else if (IsTrailingJamo(wch))
        {
            JamoClass = NLS_CLASS_TRAILING_JAMO;
        }
        else
        {
            JamoClass = NLS_CLASS_VOWEL_JAMO;
        }

        if (JamoClass != currentJamoClass)
        {
            return (JamoClass);
        }

        if (lpNext == NULL)
        {
            //
            // Get the index into the Jamo composition information.
            //
            Index = pJamo->Index;
            if (Index == 0)
            {
                return (JamoClass);
            }
            lpNext = pTblPtrs->pJamoComposition + Index;
            pSearchEnd = lpNext + pJamo->TransitionCount;
        }

        //
        // Push the current Jamo (pointed by pString) into a state machine,
        // to check if we have a valid old Hangul composition.
        // During the check, we will also update the sortkey result in JamoSortInfo.
        //        
        while (lpNext < pSearchEnd)
        {
            // Found a match--update the combination pointer and sort info.
            if (lpNext->m_wcCodePoint == wch)
            {
                UpdateJamoState(currentJamoClass, &(lpNext->m_SortInfo), JamoSortInfo);
                lpNext++;
                goto NextChar;
            }
            // No match -- skip all transitions beginning with this code point
            lpNext += lpNext->m_bTransitionCount + 1;
        }
        //
        // We didn't find a valid old Hangul composition for the current character.
        // So return the current Jamo class.
        //        
        return (JamoClass);

NextChar:        
        // We are still in a valid old Hangul composition. Go check the next character.
        (*ppString)++; (*pCount)--;
    }

    return (-1);
}





//-------------------------------------------------------------------------//
//                          EXTERNAL ROUTINES                              //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  MapOldHangulSortKey
//
//  Check if the given string has a valid old Hangul composition,
//  If yes, store the sortkey weights for the given string in the destination
//  buffer and return the number of CHARs consumed by the composition.
//  If not, return zero.
//
//  NOTENOTE: This function assumes that string starting from pSrc is a
//            leading Jamo.
//
//  06-12-2000    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

int MapOldHangulSortKey(
    PLOC_HASH pHashN,
    LPCWSTR pSrc,       // source string
    int cchSrc,         // the length of the string
    WORD* pUW,          // generated Unicode weight
    LPBYTE pXW,         // generated extra weight (3 bytes)
    BOOL fModify)
{
    LPCWSTR pString = pSrc;
    LPCWSTR pScan;
    JAMO_SORT_INFOEX JamoSortInfo;      // The result Jamo infomation.
    int Count = cchSrc;
    PSORTKEY pWeight;

    int JamoClass;                      // The current Jamo class.

    RtlZeroMemory(&JamoSortInfo, sizeof(JamoSortInfo));
    JamoClass = GetJamoComposition(&pString, &Count, cchSrc, NLS_CLASS_LEADING_JAMO, &JamoSortInfo);
        
    if (JamoClass == NLS_CLASS_VOWEL_JAMO) 
    {
        JamoClass = GetJamoComposition(&pString, &Count, cchSrc, NLS_CLASS_VOWEL_JAMO, &JamoSortInfo);
    }
    if (JamoClass == NLS_CLASS_TRAILING_JAMO)
    {
        GetJamoComposition(&pString, &Count, cchSrc, NLS_CLASS_TRAILING_JAMO, &JamoSortInfo);
    }
    
    //
    //  If we have a valid leading and vowel sequences and this is an old
    //  Hangul,...
    //
    if (JamoSortInfo.m_bOld)
    {
        //
        //  Compute the modern Hangul syllable prior to this composition.
        //    Uses formula from Unicode 3.0 Section 3.11 p54
        //    "Hangul Syllable Composition".
        //
        WCHAR wchModernHangul =
            (JamoSortInfo.m_chLeadingIndex * NLS_JAMO_VOWEL_COUNT + JamoSortInfo.m_chVowelIndex) * NLS_JAMO_TRAILING_COUNT
                + JamoSortInfo.m_chTrailingIndex
                + NLS_HANGUL_FIRST_SYLLABLE;

        if (JamoSortInfo.m_bFiller)
        {
            // Sort before the modern Hangul, instead of after.
            wchModernHangul--;
            // If we fall off the modern Hangul syllable block,... 
            if (wchModernHangul < NLS_HANGUL_FIRST_SYLLABLE)
            {
                // Sort after the previous character (Circled Hangul Kiyeok A)
                wchModernHangul = 0x326e;
            }
            // Shift the leading weight past any old Hangul that sorts after this modern Hangul
            JamoSortInfo.m_LeadingWeight += 0x80;
         }

        pWeight = &((pHashN->pSortkey)[wchModernHangul]);
        *pUW = GET_UNICODE_MOD(pWeight, fModify);
        pXW[0] = JamoSortInfo.m_LeadingWeight;
        pXW[1] = JamoSortInfo.m_VowelWeight;
        pXW[2] = JamoSortInfo.m_TrailingWeight;

        return (int)(pString - pSrc);
    }

    //
    //  Otherwise it isn't a valid old Hangul composition and we don't do
    //  anything with it.
    //
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\init.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    init.c

Abstract:

    This file contains the initialization code for the NLS APIs.

    External Routines found in this file:
      NlsDllInitialize

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"
#include "stdio.h"



//
//  Global Variables.
//

HANDLE                hModule;              // handle to module
RTL_CRITICAL_SECTION  gcsTblPtrs;           // critical section for tbl ptrs

UINT                  gAnsiCodePage;        // Ansi code page value
UINT                  gOemCodePage;         // OEM code page value
UINT                  gMacCodePage;         // MAC code page value
LCID                  gSystemLocale;        // system locale value
LANGID                gSystemInstallLang;   // system's original install language
PLOC_HASH             gpSysLocHashN;        // ptr to system loc hash node
PLOC_HASH             gpInvLocHashN;        // ptr to invariant loc hash node
PCP_HASH              gpACPHashN;           // ptr to ACP hash node
PCP_HASH              gpOEMCPHashN;         // ptr to OEMCP hash node
PCP_HASH              gpMACCPHashN;         // ptr to MACCP hash node

HANDLE                hCodePageKey;         // handle to System\Nls\CodePage key
HANDLE                hLocaleKey;           // handle to System\Nls\Locale key
HANDLE                hAltSortsKey;         // handle to Locale\Alternate Sorts key
HANDLE                hLangGroupsKey;       // handle to System\Nls\Language Groups key
PNLS_USER_INFO        pNlsUserInfo;         // ptr to the user info cache
PNLS_USER_INFO        pServerNlsUserInfo;   // ptr to the user info cache in the csrss.exe.

NLS_USER_INFO         gProcUserInfo;        // The user info cache for the process.
    // The values in this cached are updated from the content of the
    // server side cache (pNlsRegUserInfo in csrss.exe).
    // Every time when we read the cache, we will check a version count (ulCacheUpdateCount
    // field in NLS_USER_INFO) against the server-side cache (pNlsRegUserInfo) to
    // see if the process cache is still valid.  The ulCacheUpdateCount will be incremented
    // and sync'ed in the server-side when SetLocaleInfo() happens or intl registry key changes.

RTL_CRITICAL_SECTION  gcsNlsProcessCache;   // critical section for nls process cache




//
//  Forward Declarations.
//

ULONG
NlsServerInitialize(void);

ULONG
NlsProcessInitialize(void);

void
InitKoreanWeights(void);





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsDllInitialize
//
//  DLL Entry initialization procedure for NLSAPI.  This is called by
//  the base dll initialization.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOLEAN NlsDllInitialize(
    IN PVOID hMod,
    ULONG Reason,
    IN PBASE_STATIC_SERVER_DATA pBaseStaticServerData)
{
    if (Reason == DLL_PROCESS_ATTACH)
    {
        ULONG rc;

        //
        //  Save module handle for use later.
        //
        hModule = (HANDLE)hMod;

        //
        //  Initialize the cached user info pointer.
        //
        pServerNlsUserInfo = &(pBaseStaticServerData->NlsUserInfo);

        pNlsUserInfo = &gProcUserInfo;

        //
        //  Process attaching, so initialize tables.
        //
        rc = NlsServerInitialize();
        if (rc)
        {
            KdPrint(("NLSAPI: Could NOT initialize Server - %lx.\n", rc));
            return (FALSE);
        }

        rc = NlsProcessInitialize();
        if (rc)
        {
            KdPrint(("NLSAPI: Could NOT initialize Process - %lx.\n", rc));
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsThreadCleanup
//
//  Cleanup for thread resources when it terminates.
//
//  03-30-99    SamerA    Created.
////////////////////////////////////////////////////////////////////////////

VOID NlsThreadCleanup(
    VOID)
{
    if (NtCurrentTeb()->NlsCache)
    {
        CLOSE_REG_KEY( ((PNLS_LOCAL_CACHE)NtCurrentTeb()->NlsCache)->CurrentUserKeyHandle );
        RtlFreeHeap( RtlProcessHeap(),
                     0,
                     NtCurrentTeb()->NlsCache
                   );
    }
}


//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsServerInitialize
//
//  Server initialization procedure for NLSAPI.  This is the ONE-TIME
//  initialization code for the NLSAPI DLL.  It simply does the calls
//  to NtCreateSection for the code pages that are currently found in the
//  system.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG NlsServerInitialize(void)
{
    HANDLE hSec = (HANDLE)0;           // section handle
    ULONG rc;
    PPEB Peb;
#ifndef DOSWIN32
    PIMAGE_NT_HEADERS NtHeaders;
#endif

    Peb = NtCurrentPeb();

    //
    //  MultiUser NT (Hydra). SesssionId = 0 is the console CSRSS.
    //  If this is NOT the first server process, then just return success,
    //  since we only want to create the object directories once.
    //
    if (Peb->SessionId != 0)
    {
        return (NO_ERROR);
    }


#ifndef DOSWIN32

    //
    //  This is to avoid being initialized again when NTSD dynlinks to
    //  a server to get at its debugger extensions.
    //
    NtHeaders = RtlImageNtHeader(Peb->ImageBaseAddress);
    if (NtHeaders &&
        (NtHeaders->OptionalHeader.Subsystem != IMAGE_SUBSYSTEM_NATIVE))
    {
        return (NO_ERROR);
    }
#endif


    //
    //  Create the NLS object directory.
    //
    //  Must create a separate directory off the root in order to have
    //  CreateSection access on the fly.
    //
    if (rc = CreateNlsObjectDirectory())
    {
        return (rc);
    }

    //
    //  The ACP, OEMCP, and Default Language files are already created
    //  at boot time.  The pointers to the files are stored in the PEB.
    //
    //  Create the section for the following data files:
    //      UNICODE
    //      LOCALE
    //      CTYPE
    //      SORTKEY
    //      SORT TABLES
    //
    //  All other data files will have the sections created only as they
    //  are needed.
    //
    if ((!NT_SUCCESS(rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_UNICODE, 0, &hSec))) ||
        (!NT_SUCCESS(rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_LOCALE, 0, &hSec)))  ||
        (!NT_SUCCESS(rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_CTYPE, 0, &hSec)))   ||
        (!NT_SUCCESS(rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_SORTKEY, 0, &hSec))) ||
        (!NT_SUCCESS(rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_SORTTBLS, 0, &hSec))))
    {
        return (rc);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsProcessInitialize
//
//  Process initialization procedure for NLS API.  This routine sets up all
//  of the tables so that they are accessable from the current process.  If
//  it is unable to allocate the appropriate memory or memory map the
//  appropriate files, an error is returned.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG NlsProcessInitialize(void)
{
    ULONG rc;
    LPWORD pBaseAddr;                  // ptr to base address of section
    LCID UserLocale;                   // user locale id
    PLOC_HASH pUserLocHashN;           // ptr to user locale hash node
    PPEB Peb;

    Peb = NtCurrentPeb();

    //
    //  Initialize the critical section that protects the NLS cache for
    //  this process.
    //
    if ((rc = RtlInitializeCriticalSection(&gcsNlsProcessCache)) != ERROR_SUCCESS)
    {
        return (rc);
    }

    //
    //  Initialize the table pointers critical section.
    //  Enter the critical section to set up the tables.
    //
    if ((rc = RtlInitializeCriticalSectionAndSpinCount(&gcsTblPtrs, 4000)) != ERROR_SUCCESS)
    {
        return (rc);
    }
    RtlEnterCriticalSection(&gcsTblPtrs);

    //
    //  Allocate initial tables.
    //
    if (rc = AllocTables())
    {
        KdPrint(("AllocTables failed, rc %lx\n", rc));
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Initialize the handles to the various registry keys to NULL.
    //
    hCodePageKey = NULL;
    hLocaleKey = NULL;
    hAltSortsKey = NULL;
    hLangGroupsKey = NULL;

    //
    //  Get the ANSI code page value.
    //  Create the hash node for the ACP.
    //  Insert the hash node into the global CP hash table.
    //
    //  At this point, the ACP table has already been mapped into
    //  the process, so get the pointer from the PEB.
    //
    pBaseAddr = Peb->AnsiCodePageData;
    gAnsiCodePage = ((PCP_TABLE)(pBaseAddr + CP_HEADER))->CodePage;
    if (rc = MakeCPHashNode( gAnsiCodePage,
                             pBaseAddr,
                             &gpACPHashN,
                             FALSE,
                             NULL ))
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Get the OEM code page value.
    //  Create the hash node for the OEMCP.
    //  Insert the hash node into the global CP hash table.
    //
    //  At this point, the OEMCP table has already been mapped into
    //  the process, so get the pointer from the PEB.
    //
    pBaseAddr = Peb->OemCodePageData;
    gOemCodePage = ((PCP_TABLE)(pBaseAddr + CP_HEADER))->CodePage;
    if (gOemCodePage != gAnsiCodePage)
    {
        //
        //  Oem code page is different than the Ansi code page, so
        //  need to create and store the new hash node.
        //
        if (rc = MakeCPHashNode( gOemCodePage,
                                 pBaseAddr,
                                 &gpOEMCPHashN,
                                 FALSE,
                                 NULL ))
        {
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (rc);
        }
    }
    else
    {
        //
        //  Oem code page is the same as the Ansi code page, so set
        //  the oem cp hash node to be the same as the ansi cp hash node.
        //
        gpOEMCPHashN = gpACPHashN;
    }

    //
    //  Initialize the MAC code page values to 0.
    //  These values will be set the first time they are requested for use.
    //
    gMacCodePage = 0;
    gpMACCPHashN = NULL;

    //
    //  Open and Map a View of the Section for UNICODE.NLS.
    //  Save the pointers to the table information in the table ptrs
    //  structure.
    //
    if (rc = GetUnicodeFileInfo())
    {
        KdPrint(("GetUnicodeFileInfo failed, rc %lx\n", rc));
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Cache the system locale value.
    //
    rc = NtQueryDefaultLocale(FALSE, &gSystemLocale);
    if (!NT_SUCCESS(rc))
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Store the user locale value.
    //
    UserLocale = pNlsUserInfo->UserLocaleId;
    if (UserLocale == 0)
    {
        UserLocale = gSystemLocale;
    }

    //
    //  Initialize the system install language to zero.  This will only
    //  be retrieved on an as need basis.
    //
    gSystemInstallLang = 0;

    //
    //  Open and Map a View of the Section for LOCALE.NLS.
    //  Create and insert the hash node into the global Locale hash table
    //  for the system default locale.
    //
    if (rc = GetLocaleFileInfo( gSystemLocale,
                                &gpSysLocHashN,
                                TRUE ))
    {
        //
        //  Change the system locale to be the default (English).
        //
        if (GetLocaleFileInfo( MAKELCID(NLS_DEFAULT_LANGID, SORT_DEFAULT),
                               &gpSysLocHashN,
                               TRUE ))
        {
            KdPrint(("Couldn't do English\n"));
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (rc);
        }
        else
        {
            //
            //  Registry is corrupt, but allow the English default to
            //  work.  Need to reset the system default.
            //
            gSystemLocale = MAKELCID(NLS_DEFAULT_LANGID, SORT_DEFAULT);
            KdPrint(("NLSAPI: Registry is corrupt - Using Default Locale.\n"));
        }
    }

    //
    //  If the user default locale is different from the system default
    //  locale, then create and insert the hash node into the global
    //  Locale hash table for the user default locale.
    //
    //  NOTE:  The System Default Locale Hash Node should be
    //         created before this call.
    //
    if (UserLocale != gSystemLocale)
    {
        if (rc = GetLocaleFileInfo( UserLocale,
                                    &pUserLocHashN,
                                    TRUE ))
        {
            //
            //  Change the user locale to be equal to the system default.
            //
            UserLocale = gSystemLocale;
            KdPrint(("NLSAPI: Registry is corrupt - User Locale Now Equals System Locale.\n"));
        }
    }

    //
    //  Create and insert the hash node into the global Locale hash
    //  table for the invariant locale.
    //
    if (rc = GetLocaleFileInfo( LOCALE_INVARIANT,
                                &gpInvLocHashN,
                                TRUE ))
    {
        KdPrint(("NLSAPI: Registry is corrupt - Invariant Locale Cannot Be Initialized.\n"));
    }

    //
    //  Open and Map a View of the Section for SORTKEY.NLS.
    //  Save the pointers to the semaphore dword and the default sortkey
    //  table in the table ptrs structure.
    //
    if (rc = GetDefaultSortkeyFileInfo())
    {
        KdPrint(("NLSAPI: Initialization, GetDefaultSortkeyFileInfo failed with rc %lx.\n", rc));
//      RtlLeaveCriticalSection(&gcsTblPtrs);
//      return (rc);
    }

    //
    //  Open and Map a View of the Section for SORTTBLS.NLS.
    //  Save the pointers to the sort table information in the
    //  table ptrs structure.
    //
    if (rc = GetDefaultSortTablesFileInfo())
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Get the language information portion of the system locale.
    //
    //  NOTE:  GetDefaultSortkeyFileInfo and GetDefaultSortTablesFileInfo
    //         should be called before this so that the default sorting
    //         tables are already initialized at the time of the call.
    //
    if (rc = GetLanguageFileInfo( gSystemLocale,
                                  &gpSysLocHashN,
                                  FALSE,
                                  0 ))
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Get the language information portion of the invariant locale. We
    //  use the default locale (US English).
    //
    if (rc = GetLanguageFileInfo( MAKELCID(NLS_DEFAULT_LANGID, SORT_DEFAULT),
                                  &gpInvLocHashN,
                                  FALSE,
                                  0 ))
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  If the user default is different from the system default,
    //  get the language information portion of the user default locale.
    //
    //  NOTE:  GetDefaultSortkeyFileInfo and GetDefaultSortTablesFileInfo
    //         should be called before this so that the default sorting
    //         tables are already initialized at the time of the call.
    //
    if (gSystemLocale != UserLocale)
    {
        if (rc = MakeLangHashNode( UserLocale,
                                   NULL,
                                   &pUserLocHashN,
                                   FALSE ))
        {
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (rc);
        }
    }

    //
    //  Initialize the Korean SMWeight values.
    //
    InitKoreanWeights();

    //
    //  Leave the critical section.
    //
    RtlLeaveCriticalSection(&gcsTblPtrs);

    RtlEnterCriticalSection(&gcsNlsProcessCache);
    //
    // Fill up the cache from the cache in csrss.exe so that we have a fresh copy of cache
    // values.  We will retrieve a copy of ulCacheUpdateCount so that we can check
    // if the cache values are no longer valid after they are retrieved here.
    //
    // Enter a critical section gcsNlsProcessCache to provide synchronization between
    // threads since we are updating the process-wide cache.
    //
    if (!NT_SUCCESS(CsrBasepNlsGetUserInfo(pNlsUserInfo, sizeof(NLS_USER_INFO))))
    {
        RtlLeaveCriticalSection(&gcsNlsProcessCache);
        return (ERROR_INVALID_FUNCTION);
    }
    RtlLeaveCriticalSection(&gcsNlsProcessCache);

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitKoreanWeights
//
//  Creates the SMWeight array with the IDEOGRAPH script member sorting
//  before all other script members.
//
//  NOTE: This function assumes we're in a critical section.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void InitKoreanWeights()
{
    DWORD ctr;                                 // loop counter
    BYTE NewScript;                            // new script to store
    LPBYTE pSMWeight = pTblPtrs->SMWeight;     // ptr to script member weights
    PMULTI_WT pMulti;                          // ptr to multi weight


    //
    //  Set the 0 to FIRST_SCRIPT of script structure to its default
    //  value.
    //
    RtlZeroMemory(pSMWeight, NUM_SM);
    for (ctr = 1; ctr < FIRST_SCRIPT; ctr++)
    {
        pSMWeight[ctr] = (BYTE)ctr;
    }

    //
    //  Save the order in the SMWeight array.
    //
    NewScript = FIRST_SCRIPT;
    pSMWeight[IDEOGRAPH] = NewScript;
    NewScript++;

    //
    //  See if the script is part of a multiple weights script.
    //
    pMulti = pTblPtrs->pMultiWeight;
    for (ctr = pTblPtrs->NumMultiWeight; ctr > 0; ctr--, pMulti++)
    {
        if (pMulti->FirstSM == IDEOGRAPH)
        {
            //
            //  Part of multiple weight, so must move entire range
            //  by setting each value in range to NewScript and
            //  then incrementing NewScript.
            //
            //  NOTE:  May use 'ctr' here since it ALWAYS breaks
            //         out of outer for loop.
            //
            for (ctr = 1; ctr < pMulti->NumSM; ctr++)
            {
                pSMWeight[IDEOGRAPH + ctr] = NewScript;
                NewScript++;
            }
            break;
        }
    }

    //
    //  Must set each script member that has not yet been reset to its
    //  new order.
    //
    //  The default ordering is to assign:
    //       Order  =  Script Member Value
    //
    //  Therefore, can simply set each zero entry in order to the end
    //  of the array to the next 'NewScript' value.
    //
    for (ctr = FIRST_SCRIPT; ctr < NUM_SM; ctr++)
    {
        //
        //  If it's a zero value, set it to the next sorting order value.
        //
        if (pSMWeight[ctr] == 0)
        {
            pSMWeight[ctr] = NewScript;
            NewScript++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\map.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    map.c

Abstract:

    This file contains functions that deal with map tables.

    APIs found in this file:
      FoldStringW
      LCMapStringW

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"
#include "jamo.h"




//
//  Constant Declarations.
//

//
//  Invalid weight value.
//
#define MAP_INVALID_UW       0xffff

//
//  Number of bytes in each weight.
//
//  Note: Total number of bytes is limited by MAX_WEIGHTS definition.
//        The padding is needed if SW is not on a WORD boundary.
//
#define NUM_BYTES_UW         8
#define NUM_BYTES_DW         1
#define NUM_BYTES_CW         1
#define NUM_BYTES_XW         4
#define NUM_BYTES_PADDING    0
#define NUM_BYTES_SW         4

//
//  Flags to drop the 3rd weight (CW).
//
#define NORM_DROP_CW         (NORM_IGNORECASE | NORM_IGNOREWIDTH)

//
//  XW Values for FE Special Weights.
//
BYTE pXWDrop[] =                  // values to drop from XW
{
    0xc6,                         // weight 4
    0x03,                         // weight 5
    0xe4,                         // weight 6
    0xc5                          // weight 7
};
BYTE pXWSeparator[] =             // separator values for XW
{
    0xff,                         // weight 4
    0x02,                         // weight 5
    0xff,                         // weight 6
    0xff                          // weight 7
};




//
//  Forward Declarations.
//

int
FoldCZone(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
FoldDigits(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
FoldCZone_Digits(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int FoldLigatures(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
FoldPreComposed(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
FoldComposite(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
MapCase(
    PLOC_HASH pHashN,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PCASE pCaseTbl);

int
MapSortKey(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPBYTE pDest,
    int cchDest,
    BOOL fModify);

int
MapNormalization(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
MapKanaWidth(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
MapHalfKana(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PKANA pKana,
    PCASE pCase);

int
MapFullKana(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PKANA pKana,
    PCASE pCase);

int
MapTraditionalSimplified(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PCHINESE pChinese);





//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  FoldStringW
//
//  Maps one wide character string to another performing the specified
//  translation.  This mapping routine only takes flags that are locale
//  independent.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI FoldStringW(
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    int Count = 0;                // word count


    //
    //  Invalid Parameter Check:
    //     - length of src string is 0
    //     - either buffer size is negative (except cchSrc == -1)
    //     - src string is NULL
    //     - length of dest string is NOT zero AND dest string is NULL
    //     - same buffer - src = destination
    //
    //     - flags are checked in switch statement below
    //
    if ((cchSrc == 0) || (cchDest < 0) ||
        (lpSrcStr == NULL) ||
        ((cchDest != 0) && (lpDestStr == NULL)) ||
        (lpSrcStr == lpDestStr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  If cchSrc is -1, then the source string is null terminated and we
    //  need to get the length of the source string.  Add one to the
    //  length to include the null termination.
    //  (This will always be at least 1.)
    //
    if (cchSrc <= -1)
    {
        cchSrc = NlsStrLenW(lpSrcStr) + 1;
    }

    //
    //  Map the string based on the given flags.
    //
    switch (dwMapFlags)
    {
        case ( MAP_FOLDCZONE ) :
        {
            //
            //  Map the string to fold the Compatibility Zone.
            //
            Count = FoldCZone( lpSrcStr,
                               cchSrc,
                               lpDestStr,
                               cchDest );
            break;
        }
        case ( MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to fold the Ascii Digits.
            //
            Count = FoldDigits( lpSrcStr,
                                cchSrc,
                                lpDestStr,
                                cchDest );
            break;
        }
        case ( MAP_EXPAND_LIGATURES ) :
        {
            //
            //  Map the string to expand all Ligatures.
            //
            Count = FoldLigatures( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            break;
        }
        case ( MAP_PRECOMPOSED ) :
        {
            //
            //  Map the string to compress all composite forms of
            //  characters to their precomposed form.
            //
            Count = FoldPreComposed( lpSrcStr,
                                     cchSrc,
                                     lpDestStr,
                                     cchDest );
            break;
        }
        case ( MAP_COMPOSITE ) :
        {
            //
            //  Map the string to expand out all precomposed characters
            //  to their composite form.
            //
            Count = FoldComposite( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            break;
        }
        case ( MAP_FOLDCZONE | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to fold the Compatibility Zone and fold the
            //  Ascii Digits.
            //
            Count = FoldCZone_Digits( lpSrcStr,
                                      cchSrc,
                                      lpDestStr,
                                      cchDest );
            break;
        }
        case ( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE ) :
        {
            //
            //  Map the string to expand the ligatures and fold the
            //  Compatibility Zone.
            //
            Count = FoldLigatures( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldCZone( lpDestStr,
                               Count,
                               lpDestStr,
                               cchDest );
            break;
        }
        case ( MAP_EXPAND_LIGATURES | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to expand the ligatures and fold the
            //  Ascii Digits.
            //
            Count = FoldLigatures( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldDigits( lpDestStr,
                                Count,
                                lpDestStr,
                                cchDest );
            break;
        }
        case ( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to expand the ligatures, fold the
            //  Compatibility Zone and fold the Ascii Digits.
            //
            Count = FoldLigatures( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldCZone_Digits( lpDestStr,
                                      Count,
                                      lpDestStr,
                                      cchDest );
            break;
        }
        case ( MAP_PRECOMPOSED | MAP_FOLDCZONE ) :
        {
            //
            //  Map the string to convert to precomposed forms and to
            //  fold the Compatibility Zone.
            //
            Count = FoldPreComposed( lpSrcStr,
                                     cchSrc,
                                     lpDestStr,
                                     cchDest );
            Count = FoldCZone( lpDestStr,
                               Count,
                               lpDestStr,
                               cchDest );
            break;
        }
        case ( MAP_PRECOMPOSED | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to convert to precomposed forms and to
            //  fold the Ascii Digits.
            //
            Count = FoldPreComposed( lpSrcStr,
                                     cchSrc,
                                     lpDestStr,
                                     cchDest );
            Count = FoldDigits( lpDestStr,
                                Count,
                                lpDestStr,
                                cchDest );
            break;
        }
        case ( MAP_PRECOMPOSED | MAP_FOLDCZONE | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to convert to precomposed forms,
            //  fold the Compatibility Zone, and fold the Ascii Digits.
            //
            Count = FoldPreComposed( lpSrcStr,
                                     cchSrc,
                                     lpDestStr,
                                     cchDest );
            Count = FoldCZone_Digits( lpDestStr,
                                      Count,
                                      lpDestStr,
                                      cchDest );
            break;
        }
        case ( MAP_COMPOSITE | MAP_FOLDCZONE ) :
        {
            //
            //  Map the string to convert to composite forms and to
            //  fold the Compatibility Zone.
            //
            Count = FoldComposite( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldCZone( lpDestStr,
                               Count,
                               lpDestStr,
                               cchDest );
            break;
        }
        case ( MAP_COMPOSITE | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to convert to composite forms and to
            //  fold the Ascii Digits.
            //
            Count = FoldComposite( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldDigits( lpDestStr,
                                Count,
                                lpDestStr,
                                cchDest );
            break;
        }
        case ( MAP_COMPOSITE | MAP_FOLDCZONE | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to convert to composite forms,
            //  fold the Compatibility Zone, and fold the Ascii Digits.
            //
            Count = FoldComposite( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldCZone_Digits( lpDestStr,
                                      Count,
                                      lpDestStr,
                                      cchDest );
            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
    }

    //
    //  Return the number of characters written to the buffer.
    //  Or, if cchDest == 0, then return the number of characters
    //  that would have been written to the buffer.
    //
    return (Count);
}


////////////////////////////////////////////////////////////////////////////
//
//  LCMapStringW
//
//  Maps one wide character string to another performing the specified
//  translation.  This mapping routine only takes flags that are locale
//  dependent.
//
//  05-31-91    JulieB    Created.
//  07-26-93    JulieB    Added new flags for NT-J.
////////////////////////////////////////////////////////////////////////////

int WINAPI LCMapStringW(
    LCID Locale,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    PLOC_HASH pHashN;             // ptr to LOC hash node
    int Count = 0;                // word count or byte count
    int ctr;                      // loop counter


    //
    //  Invalid Parameter Check:
    //     - validate LCID
    //     - length of src string is 0
    //     - destination buffer size is negative
    //     - src string is NULL
    //     - length of dest string is NOT zero AND dest string is NULL
    //     - same buffer - src = destination
    //              if not UPPER or LOWER or
    //              UPPER or LOWER used with Japanese flags
    //
    VALIDATE_LANGUAGE(Locale, pHashN, dwMapFlags & LCMAP_LINGUISTIC_CASING, TRUE);
    if ( (pHashN == NULL) ||
         (cchSrc == 0) || (cchDest < 0) || (lpSrcStr == NULL) ||
         ((cchDest != 0) && (lpDestStr == NULL)) ||
         ((lpSrcStr == lpDestStr) &&
          ((!(dwMapFlags & (LCMAP_UPPERCASE | LCMAP_LOWERCASE))) ||
           (dwMapFlags & (LCMAP_HIRAGANA | LCMAP_KATAKANA |
                          LCMAP_HALFWIDTH | LCMAP_FULLWIDTH)))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - flags other than valid ones or 0
    //     - (any NORM_ flag) AND (any LCMAP_ flag except byterev and sortkey)
    //     - (NORM_ flags for sortkey) AND (NOT LCMAP_SORTKEY)
    //     - more than one of lower, upper, sortkey
    //     - more than one of hiragana, katakana, sortkey
    //     - more than one of half width, full width, sortkey
    //     - more than one of traditional, simplified, sortkey
    //     - (LINGUISTIC flag) AND (NOT LCMAP_UPPER OR LCMAP_LOWER)
    //
    dwMapFlags &= (~LOCALE_USE_CP_ACP);
    if ( (dwMapFlags & LCMS_INVALID_FLAG) || (dwMapFlags == 0) ||
         ((dwMapFlags & (NORM_ALL | SORT_STRINGSORT)) &&
          (dwMapFlags & LCMAP_NO_NORM)) ||
         ((dwMapFlags & NORM_SORTKEY_ONLY) &&
          (!(dwMapFlags & LCMAP_SORTKEY))) ||
         (MORE_THAN_ONE(dwMapFlags, LCMS1_SINGLE_FLAG)) ||
         (MORE_THAN_ONE(dwMapFlags, LCMS2_SINGLE_FLAG)) ||
         (MORE_THAN_ONE(dwMapFlags, LCMS3_SINGLE_FLAG)) ||
         (MORE_THAN_ONE(dwMapFlags, LCMS4_SINGLE_FLAG)) ||
         ((dwMapFlags & LCMAP_LINGUISTIC_CASING) &&
          (!(dwMapFlags & (LCMAP_UPPERCASE | LCMAP_LOWERCASE)))) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cchSrc is -1, then the source string is null terminated and we
    //  need to get the length of the source string.  Add one to the
    //  length to include the null termination.
    //  (This will always be at least 1.)
    //
    if (cchSrc <= -1)
    {
        cchSrc = NlsStrLenW(lpSrcStr) + 1;
    }

    //
    //  Map the string based on the given flags.
    //
    if (dwMapFlags & LCMAP_SORTKEY)
    {
        //
        //  Map the string to its sortkey.
        //
        //  NOTE:  This returns the number of BYTES, instead of the
        //         number of wide characters (words).
        //
        Count = MapSortKey( pHashN,
                            dwMapFlags,
                            lpSrcStr,
                            cchSrc,
                            (LPBYTE)lpDestStr,
                            cchDest,
                            IS_KOREAN(Locale) );
    }
    else
    {
        switch (dwMapFlags & ~(LCMAP_BYTEREV | LCMAP_LINGUISTIC_CASING))
        {
            case ( LCMAP_LOWERCASE ) :
            {
                //
                //  Map the string to Lower Case.
                //
                Count = MapCase( pHashN,
                                 lpSrcStr,
                                 cchSrc,
                                 lpDestStr,
                                 cchDest,
                                 (dwMapFlags & LCMAP_LINGUISTIC_CASING)
                                     ? pHashN->pLowerLinguist
                                     : pHashN->pLowerCase );
                break;
            }
            case ( LCMAP_UPPERCASE ) :
            {
                //
                //  Map the string to Upper Case.
                //
                Count = MapCase( pHashN,
                                 lpSrcStr,
                                 cchSrc,
                                 lpDestStr,
                                 cchDest,
                                 (dwMapFlags & LCMAP_LINGUISTIC_CASING)
                                     ? pHashN->pUpperLinguist
                                     : pHashN->pUpperCase );
                break;
            }
            case ( NORM_IGNORENONSPACE )                      :
            case ( NORM_IGNORESYMBOLS )                       :
            case ( NORM_IGNORENONSPACE | NORM_IGNORESYMBOLS ) :
            {
                //
                //  Map the string to strip out nonspace marks and/or symbols.
                //
                Count = MapNormalization( pHashN,
                                          dwMapFlags & ~LCMAP_BYTEREV,
                                          lpSrcStr,
                                          cchSrc,
                                          lpDestStr,
                                          cchDest );
                break;
            }
            case ( LCMAP_TRADITIONAL_CHINESE ) :
            case ( LCMAP_TRADITIONAL_CHINESE | LCMAP_LOWERCASE ) :
            case ( LCMAP_TRADITIONAL_CHINESE | LCMAP_UPPERCASE) :
            {
                //
                //  Map the string to Traditional Chinese.
                //
                Count = MapTraditionalSimplified( pHashN,
                                                  dwMapFlags & ~LCMAP_BYTEREV,
                                                  lpSrcStr,
                                                  cchSrc,
                                                  lpDestStr,
                                                  cchDest,
                                                  pTblPtrs->pTraditional );
                break;
            }
            case ( LCMAP_SIMPLIFIED_CHINESE )  :
            case ( LCMAP_SIMPLIFIED_CHINESE | LCMAP_LOWERCASE )  :
            case ( LCMAP_SIMPLIFIED_CHINESE | LCMAP_UPPERCASE )  :
            {
                //
                //  Map the string to Simplified Chinese.
                //
                Count = MapTraditionalSimplified( pHashN,
                                                  dwMapFlags & ~LCMAP_BYTEREV,
                                                  lpSrcStr,
                                                  cchSrc,
                                                  lpDestStr,
                                                  cchDest,
                                                  pTblPtrs->pSimplified );
                break;
            }
            default :
            {
                //
                //  Make sure the Chinese flags are not used with the
                //  Japanese flags.
                //
                if (dwMapFlags &
                     (LCMAP_TRADITIONAL_CHINESE | LCMAP_SIMPLIFIED_CHINESE))
                {
                    SetLastError(ERROR_INVALID_FLAGS);
                    return (0);
                }

                //
                //  The only flags not yet handled are the variations
                //  containing the Kana and/or Width flags.
                //  This handles all variations for:
                //      LCMAP_HIRAGANA
                //      LCMAP_KATAKANA
                //      LCMAP_HALFWIDTH
                //      LCMAP_FULLWIDTH
                //
                //      Allow LCMAP_LOWERCASE and LCMAP_UPPERCASE
                //      in combination with the kana and width flags.
                //
                Count = MapKanaWidth( pHashN,
                                      dwMapFlags & ~LCMAP_BYTEREV,
                                      lpSrcStr,
                                      cchSrc,
                                      lpDestStr,
                                      cchDest );
                break;
            }
        }
    }

    //
    //  Always check LCMAP_BYTEREV last and do it in place.
    //  LCMAP_BYTEREV may be used in combination with any other flag
    //  (except ignore case without sortkey) or by itself.
    //
    if (dwMapFlags & LCMAP_BYTEREV)
    {
        //
        //  Reverse the bytes of each word in the string.
        //
        if (dwMapFlags == LCMAP_BYTEREV)
        {
            //
            //  Byte Reversal flag is used by itself.
            //
            //  Make sure that the size of the destination buffer is
            //  larger than zero.  If it is zero, return the size of
            //  the source string only.  Do NOT touch lpDestStr.
            //
            if (cchDest != 0)
            {
                //
                //  Flag is used by itself.  Reverse the bytes from
                //  the source string and store them in the destination
                //  string.
                //
                if (cchSrc > cchDest)
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }

                for (ctr = 0; ctr < cchSrc; ctr++)
                {
                    lpDestStr[ctr] = MAKEWORD( HIBYTE(lpSrcStr[ctr]),
                                               LOBYTE(lpSrcStr[ctr]) );
                }
            }

            //
            //  Return the size of the source string.
            //
            Count = cchSrc;
        }
        else
        {
            //
            //  Make sure that the size of the destination buffer is
            //  larger than zero.  If it is zero, return the count and
            //  do NOT touch lpDestStr.
            //
            if (cchDest != 0)
            {
                //
                //  Check for sortkey flag.
                //
                if (dwMapFlags & LCMAP_SORTKEY)
                {
                    //
                    //  Sortkey flag is also set, so 'Count' contains the
                    //  number of BYTES instead of the number of words.
                    //
                    //  Reverse the bytes in place in the destination string.
                    //  No need to check the size of the destination buffer
                    //  here - it's been done elsewhere.
                    //
                    for (ctr = 0; ctr < Count / 2; ctr++)
                    {
                        lpDestStr[ctr] = MAKEWORD( HIBYTE(lpDestStr[ctr]),
                                                   LOBYTE(lpDestStr[ctr]) );
                    }
                }
                else
                {
                    //
                    //  Flag is used in combination with another flag.
                    //  Reverse the bytes in place in the destination string.
                    //  No need to check the size of the destination buffer
                    //  here - it's been done elsewhere.
                    //
                    for (ctr = 0; ctr < Count; ctr++)
                    {
                        lpDestStr[ctr] = MAKEWORD( HIBYTE(lpDestStr[ctr]),
                                                   LOBYTE(lpDestStr[ctr]) );
                    }
                }
            }
        }
    }

    //
    //  Return the number of characters (or number of bytes for sortkey)
    //  written to the buffer.
    //
    return (Count);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  FoldCZone
//
//  Stores the compatibility zone values for the given string in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  02-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldCZone(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr;                      // loop counter


    //
    //  If the destination value is zero, then just return the
    //  length of the source string.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        return (cchSrc);
    }

    //
    //  If cchSrc is greater than cchDest, then the destination buffer
    //  is too small to hold the new string.  Return an error.
    //
    if (cchSrc > cchDest)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Fold the Compatibility Zone and store it in the destination string.
    //
    for (ctr = 0; ctr < cchSrc; ctr++)
    {
        pDest[ctr] = GET_FOLD_CZONE(pTblPtrs->pCZone, pSrc[ctr]);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr);
}


////////////////////////////////////////////////////////////////////////////
//
//  FoldDigits
//
//  Stores the ascii digits values for the given string in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  02-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldDigits(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr;                      // loop counter


    //
    //  If the destination value is zero, then just return the
    //  length of the source string.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        return (cchSrc);
    }

    //
    //  If cchSrc is greater than cchDest, then the destination buffer
    //  is too small to hold the new string.  Return an error.
    //
    if (cchSrc > cchDest)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Fold the Ascii Digits and store it in the destination string.
    //
    for (ctr = 0; ctr < cchSrc; ctr++)
    {
        pDest[ctr] = GET_ASCII_DIGITS(pTblPtrs->pADigit, pSrc[ctr]);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr);
}


////////////////////////////////////////////////////////////////////////////
//
//  FoldCZone_Digits
//
//  Stores the compatibility zone and ascii digits values for the given
//  string in the destination buffer, and returns the number of wide
//  characters written to the buffer.
//
//  02-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldCZone_Digits(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr;                      // loop counter


    //
    //  If the destination value is zero, then just return the
    //  length of the source string.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        return (cchSrc);
    }

    //
    //  If cchSrc is greater than cchDest, then the destination buffer
    //  is too small to hold the new string.  Return an error.
    //
    if (cchSrc > cchDest)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Fold the compatibility zone and the ascii digits values and store
    //  it in the destination string.
    //
    for (ctr = 0; ctr < cchSrc; ctr++)
    {
        pDest[ctr] = GET_FOLD_CZONE(pTblPtrs->pCZone, pSrc[ctr]);
        pDest[ctr] = GET_ASCII_DIGITS(pTblPtrs->pADigit, pDest[ctr]);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr);
}


////////////////////////////////////////////////////////////////////////////
//
//  FoldLigatures
//
//  Stores the expanded ligature values for the given string in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  10-15-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldLigatures(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr  = 0;                 // source char counter
    int ctr2 = 0;                 // destination char counter
    DWORD Weight;                 // sort weight - used for expansions


    //
    //  Make sure the default sorting table is available.  If not,
    //  return an error.
    //
    if (pTblPtrs->pDefaultSortkey == NULL)
    {
        KdPrint(("NLSAPI: No Default Sorting Table Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  If the destination value is zero, then just return the
    //  length of the string that would be returned.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        //
        //  Convert the source string to expand all ligatures and calculate
        //  the number of characters that would have been written to a
        //  destination buffer.
        //
        while (ctr < cchSrc)
        {
            Weight = MAKE_SORTKEY_DWORD((pTblPtrs->pDefaultSortkey)[pSrc[ctr]]);
            if (GET_SCRIPT_MEMBER(&Weight) == EXPANSION)
            {
                do
                {
                    ctr2++;
                    Weight = MAKE_SORTKEY_DWORD(
                        (pTblPtrs->pDefaultSortkey)[GET_EXPANSION_2(&Weight)]);
                } while (GET_SCRIPT_MEMBER(&Weight) == EXPANSION);
                ctr2++;
            }
            else
            {
                ctr2++;
            }
            ctr++;
        }
    }
    else
    {
        //
        //  Convert the source string to expand all ligatures and store
        //  the result in the destination buffer.
        //
        while ((ctr < cchSrc) && (ctr2 < cchDest))
        {
            Weight = MAKE_SORTKEY_DWORD((pTblPtrs->pDefaultSortkey)[pSrc[ctr]]);
            if (GET_SCRIPT_MEMBER(&Weight) == EXPANSION)
            {
                do
                {
                    if ((ctr2 + 1) < cchDest)
                    {
                        pDest[ctr2]     = GET_EXPANSION_1(&Weight);
                        pDest[ctr2 + 1] = GET_EXPANSION_2(&Weight);
                        ctr2++;
                    }
                    else
                    {
                        ctr2++;
                        break;
                    }
                    Weight = MAKE_SORTKEY_DWORD(
                                 (pTblPtrs->pDefaultSortkey)[pDest[ctr2]]);
                } while (GET_SCRIPT_MEMBER(&Weight) == EXPANSION);

                if (ctr2 >= cchDest)
                {
                    break;
                }
                ctr2++;
            }
            else
            {
                pDest[ctr2] = pSrc[ctr];
                ctr2++;
            }
            ctr++;
        }
    }

    //
    //  Make sure destination buffer was large enough.
    //
    if (ctr < cchSrc)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr2);
}


////////////////////////////////////////////////////////////////////////////
//
//  FoldPreComposed
//
//  Stores the precomposed values for the given string in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  02-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldPreComposed(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr  = 0;                 // source char counter
    int ctr2 = 0;                 // destination char counter
    WCHAR wch = 0;                // wchar holder


    //
    //  Make sure the default sorting table is available.  If not,
    //  return an error.
    //
    if (pTblPtrs->pDefaultSortkey == NULL)
    {
        KdPrint(("NLSAPI: No Default Sorting Table Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  If the destination value is zero, then just return the
    //  length of the string that would be returned.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        //
        //  Convert the source string to precomposed and calculate the
        //  number of characters that would have been written to a
        //  destination buffer.
        //
        while (ctr < cchSrc)
        {
            if ((ctr2 != 0) &&
                (IS_NONSPACE_ONLY(pTblPtrs->pDefaultSortkey, pSrc[ctr])))
            {
                //
                //  Composite form.  Write the precomposed form.
                //
                //  If the precomposed character is written to the buffer,
                //  do NOT increment the destination pointer or the
                //  character count (the precomposed character was
                //  written over the previous character).
                //
                if (wch)
                {
                    if ((wch = GetPreComposedChar(pSrc[ctr], wch)) == 0)
                    {
                        //
                        //  No translation for composite form, so just
                        //  increment the destination counter.
                        //
                        ctr2++;
                    }
                }
                else
                {
                    if ((wch = GetPreComposedChar( pSrc[ctr],
                                                   pSrc[ctr - 1] )) == 0)
                    {
                        //
                        //  No translation for composite form, so just
                        //  increment the destination counter.
                        //
                        ctr2++;
                    }
                }
            }
            else
            {
                //
                //  Not part of a composite character, so just
                //  increment the destination counter.
                //
                wch = 0;
                ctr2++;
            }
            ctr++;
        }
    }
    else
    {
        //
        //  Convert the source string to precomposed and store it in the
        //  destination string.
        //
        while ((ctr < cchSrc) && (ctr2 < cchDest))
        {
            if ((ctr2 != 0) &&
                (IS_NONSPACE_ONLY(pTblPtrs->pDefaultSortkey, pSrc[ctr])))
            {
                //
                //  Composite form.  Write the precomposed form.
                //
                //  If the precomposed character is written to the buffer,
                //  do NOT increment the destination pointer or the
                //  character count (the precomposed character was
                //  written over the previous character).
                //
                wch = pDest[ctr2 - 1];
                if ((pDest[ctr2 - 1] =
                         GetPreComposedChar( pSrc[ctr],
                                             pDest[ctr2 - 1] )) == 0)
                {
                    //
                    //  No translation for composite form, so must
                    //  rewrite the base character and write the
                    //  composite character.
                    //
                    pDest[ctr2 - 1] = wch;
                    pDest[ctr2] = pSrc[ctr];
                    ctr2++;
                }
            }
            else
            {
                //
                //  Not part of a composite character, so just write
                //  the character to the destination string.
                //
                pDest[ctr2] = pSrc[ctr];
                ctr2++;
            }
            ctr++;
        }
    }

    //
    //  Make sure destination buffer was large enough.
    //
    if (ctr < cchSrc)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr2);
}


////////////////////////////////////////////////////////////////////////////
//
//  FoldComposite
//
//  Stores the composite values for the given string in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  02-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldComposite(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr  = 0;                 // source char counter
    int ctr2 = 0;                 // destination char counter
    LPWSTR pEndDest;              // ptr to end of destination string
    WCHAR pTmp[MAX_COMPOSITE];    // tmp buffer for composite chars


    //
    //  If the destination value is zero, then just return the
    //  length of the string that would be returned.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        //
        //  Get the end of the tmp buffer.
        //
        pEndDest = (LPWSTR)pTmp + MAX_COMPOSITE;

        //
        //  Convert the source string to precomposed and calculate the
        //  number of characters that would have been written to a
        //  destination buffer.
        //
        while (ctr < cchSrc)
        {
            //
            //  Write the character to the destination string.
            //
            *pTmp = pSrc[ctr];

            //
            //  See if it needs to be expanded to its composite form.
            //
            //  If no composite form is found, the routine returns 1 for
            //  the base character.  Simply increment by the return value.
            //
            ctr2 += InsertCompositeForm(pTmp, pEndDest);

            //
            //  Increment the source string counter.
            //
            ctr++;
        }
    }
    else
    {
        //
        //  Get the end of the destination string.
        //
        pEndDest = (LPWSTR)pDest + cchDest;

        //
        //  Convert the source string to precomposed and store it in the
        //  destination string.
        //
        while ((ctr < cchSrc) && (ctr2 < cchDest))
        {
            //
            //  Write the character to the destination string.
            //
            pDest[ctr2] = pSrc[ctr];

            //
            //  See if it needs to be expanded to its composite form.
            //
            //  If no composite form is found, the routine returns 1 for
            //  the base character.  Simply increment by the return value.
            //
            ctr2 += InsertCompositeForm(&(pDest[ctr2]), pEndDest);

            //
            //  Increment the source string counter.
            //
            ctr++;
        }
    }

    //
    //  Make sure destination buffer was large enough.
    //
    if (ctr < cchSrc)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr2);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapCase
//
//  Stores the lower or upper case values for the given string in the
//  destination buffer, and returns the number of wide characters written to
//  the buffer.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapCase(
    PLOC_HASH pHashN,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PCASE pCaseTbl)
{
    int ctr;                      // loop counter


    //
    //  If the destination value is zero, then just return the
    //  length of the source string.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        return (cchSrc);
    }

    //
    //  If cchSrc is greater than cchDest, then the destination buffer
    //  is too small to hold the lower or upper case string.  Return an
    //  error.
    //
    if (cchSrc > cchDest)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Lower or Upper case the source string and store it in the
    //  destination string.
    //
    for (ctr = 0; ctr < cchSrc; ctr++)
    {
        pDest[ctr] = GET_LOWER_UPPER_CASE(pCaseTbl, pSrc[ctr]);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr);
}


////////////////////////////////////////////////////////////////////////////
//
//  SPECIAL_CASE_HANDLER
//
//  Handles all of the special cases for each character.  This includes only
//  the valid values less than or equal to MAX_SPECIAL_CASE.
//
//  DEFINED AS A MACRO.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define EXTRA_WEIGHT_POS(WtNum)        (*(pPosXW + (WtNum * WeightLen)))

#define SPECIAL_CASE_HANDLER( SM,                                           \
                              pWeight,                                      \
                              pSortkey,                                     \
                              pExpand,                                      \
                              Position,                                     \
                              fStringSort,                                  \
                              fIgnoreSymbols,                               \
                              pCur,                                         \
                              pBegin,                                       \
                              fModify )                                     \
{                                                                           \
    PSORTKEY pExpWt;              /* weight of 1 expansion char */          \
    BYTE AW;                      /* alphanumeric weight */                 \
    BYTE XW;                      /* case weight value with extra bits */   \
    DWORD PrevWt;                 /* previous weight */                     \
    BYTE PrevSM;                  /* previous script member */              \
    BYTE PrevAW;                  /* previuos alphanumeric weight */        \
    BYTE PrevCW;                  /* previuos case weight */                \
    LPWSTR pPrev;                 /* ptr to previous char */                \
                                                                            \
                                                                            \
    switch (SM)                                                             \
    {                                                                       \
        case ( UNSORTABLE ) :                                               \
        {                                                                   \
            /*                                                              \
             *  Character is unsortable, so skip it.                        \
             */                                                             \
            break;                                                          \
        }                                                                   \
        case ( NONSPACE_MARK ) :                                            \
        {                                                                   \
            /*                                                              \
             *  Character is a nonspace mark, so only store                 \
             *  the diacritic weight.                                       \
             */                                                             \
            if (pPosDW > pDW)                                               \
            {                                                               \
                (*(pPosDW - 1)) += GET_DIACRITIC(pWeight);                  \
            }                                                               \
            else                                                            \
            {                                                               \
                *pPosDW = GET_DIACRITIC(pWeight);                           \
                pPosDW++;                                                   \
            }                                                               \
                                                                            \
            break;                                                          \
        }                                                                   \
        case ( EXPANSION ) :                                                \
        {                                                                   \
            /*                                                              \
             *  Expansion character - one character has 2                   \
             *  different weights.  Store each weight separately.           \
             */                                                             \
            pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP1]); \
            *pPosUW = GET_UNICODE_MOD(pExpWt, fModify);                     \
            *pPosDW = GET_DIACRITIC(pExpWt);                                \
            *pPosCW = GET_CASE(pExpWt) & CaseMask;                          \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP2]); \
            while (GET_SCRIPT_MEMBER(pExpWt) == EXPANSION)                  \
            {                                                               \
                pWeight = pExpWt;                                           \
                pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP1]); \
                *pPosUW = GET_UNICODE_MOD(pExpWt, fModify);                 \
                *pPosDW = GET_DIACRITIC(pExpWt);                            \
                *pPosCW = GET_CASE(pExpWt) & CaseMask;                      \
                pPosUW++;                                                   \
                pPosDW++;                                                   \
                pPosCW++;                                                   \
                pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP2]); \
            }                                                               \
            *pPosUW = GET_UNICODE_MOD(pExpWt, fModify);                     \
            *pPosDW = GET_DIACRITIC(pExpWt);                                \
            *pPosCW = GET_CASE(pExpWt) & CaseMask;                          \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            break;                                                          \
        }                                                                   \
        case ( PUNCTUATION ) :                                              \
        {                                                                   \
            if (!fStringSort)                                               \
            {                                                               \
                /*                                                          \
                 *  Word Sort Method.                                       \
                 *                                                          \
                 *  Character is punctuation, so only store the special     \
                 *  weight.                                                 \
                 */                                                         \
                *((LPBYTE)pPosSW)       = HIBYTE(GET_POSITION_SW(Position)); \
                *(((LPBYTE)pPosSW) + 1) = LOBYTE(GET_POSITION_SW(Position)); \
                pPosSW++;                                                   \
                *pPosSW = GET_SPECIAL_WEIGHT(pWeight);                      \
                pPosSW++;                                                   \
                                                                            \
                break;                                                      \
            }                                                               \
                                                                            \
            /*                                                              \
             *  If using STRING sort method, treat punctuation the same     \
             *  as symbol.  So, FALL THROUGH to the symbol cases.           \
             */                                                             \
        }                                                                   \
        case ( SYMBOL_1 ) :                                                 \
        case ( SYMBOL_2 ) :                                                 \
        case ( SYMBOL_3 ) :                                                 \
        case ( SYMBOL_4 ) :                                                 \
        case ( SYMBOL_5 ) :                                                 \
        {                                                                   \
            /*                                                              \
             *  Character is a symbol.                                      \
             *  Store the Unicode weights ONLY if the NORM_IGNORESYMBOLS    \
             *  flag is NOT set.                                            \
             */                                                             \
            if (!fIgnoreSymbols)                                            \
            {                                                               \
                *pPosUW = GET_UNICODE_MOD(pWeight, fModify);                \
                *pPosDW = GET_DIACRITIC(pWeight);                           \
                *pPosCW = GET_CASE(pWeight) & CaseMask;                     \
                pPosUW++;                                                   \
                pPosDW++;                                                   \
                pPosCW++;                                                   \
            }                                                               \
                                                                            \
            break;                                                          \
        }                                                                   \
        case ( FAREAST_SPECIAL ) :                                          \
        {                                                                   \
            /*                                                              \
             *  Get the alphanumeric weight and the case weight of the      \
             *  current code point.                                         \
             */                                                             \
            AW = GET_ALPHA_NUMERIC(pWeight);                                \
            XW = (GET_CASE(pWeight) & CaseMask) | CASE_XW_MASK;             \
                                                                            \
            /*                                                              \
             *  Special case Repeat and Cho-On.                             \
             *    AW = 0  =>  Repeat                                        \
             *    AW = 1  =>  Cho-On                                        \
             *    AW = 2+ =>  Kana                                          \
             */                                                             \
            if (AW <= MAX_SPECIAL_AW)                                       \
            {                                                               \
                /*                                                          \
                 *  If the script member of the previous character is       \
                 *  invalid, then give the special character an             \
                 *  invalid weight (highest possible weight) so that it     \
                 *  will sort AFTER everything else.                        \
                 */                                                         \
                pPrev = pCur - 1;                                           \
                *pPosUW = MAP_INVALID_UW;                                   \
                while (pPrev >= pBegin)                                     \
                {                                                           \
                    PrevWt = GET_DWORD_WEIGHT(pHashN, *pPrev);              \
                    PrevSM = GET_SCRIPT_MEMBER(&PrevWt);                    \
                    if (PrevSM < FAREAST_SPECIAL)                           \
                    {                                                       \
                        if (PrevSM != EXPANSION)                            \
                        {                                                   \
                            /*                                              \
                             *  UNSORTABLE or NONSPACE_MARK.                \
                             *                                              \
                             *  Just ignore these, since we only care       \
                             *  about the previous UW value.                \
                             */                                             \
                            pPrev--;                                        \
                            continue;                                       \
                        }                                                   \
                    }                                                       \
                    else if (PrevSM == FAREAST_SPECIAL)                     \
                    {                                                       \
                        PrevAW = GET_ALPHA_NUMERIC(&PrevWt);                \
                        if (PrevAW <= MAX_SPECIAL_AW)                       \
                        {                                                   \
                            /*                                              \
                             *  Handle case where two special chars follow  \
                             *  each other.  Keep going back in the string. \
                             */                                             \
                            pPrev--;                                        \
                            continue;                                       \
                        }                                                   \
                                                                            \
                        *pPosUW = MAKE_UNICODE_WT(KANA, PrevAW, fModify);   \
                                                                            \
                        /*                                                  \
                         *  Only build weights 4, 5, 6, and 7 if the        \
                         *  previous character is KANA.                     \
                         *                                                  \
                         *  Always:                                         \
                         *    4W = previous CW  &  ISOLATE_SMALL            \
                         *    6W = previous CW  &  ISOLATE_KANA             \
                         *                                                  \
                         */                                                 \
                        PrevCW = (GET_CASE(&PrevWt) & CaseMask) |           \
                                 CASE_XW_MASK;                              \
                                                                            \
                        EXTRA_WEIGHT_POS(0) = PrevCW & ISOLATE_SMALL;       \
                        EXTRA_WEIGHT_POS(2) = PrevCW & ISOLATE_KANA;        \
                                                                            \
                        if (AW == AW_REPEAT)                                \
                        {                                                   \
                            /*                                              \
                             *  Repeat:                                     \
                             *    UW = previous UW   (set above)            \
                             *    5W = WT_FIVE_REPEAT                       \
                             *    7W = previous CW  &  ISOLATE_WIDTH        \
                             */                                             \
                            EXTRA_WEIGHT_POS(1) = WT_FIVE_REPEAT;           \
                            EXTRA_WEIGHT_POS(3) = PrevCW & ISOLATE_WIDTH;   \
                        }                                                   \
                        else                                                \
                        {                                                   \
                            /*                                              \
                             *  Cho-On:                                     \
                             *    UW = previous UW  &  CHO_ON_UW_MASK       \
                             *    5W = WT_FIVE_CHO_ON                       \
                             *    7W = current  CW  &  ISOLATE_WIDTH        \
                             */                                             \
                            *pPosUW &= CHO_ON_UW_MASK;                      \
                            EXTRA_WEIGHT_POS(1) = WT_FIVE_CHO_ON;           \
                            EXTRA_WEIGHT_POS(3) = XW & ISOLATE_WIDTH;       \
                        }                                                   \
                                                                            \
                        pPosXW++;                                           \
                    }                                                       \
                    else                                                    \
                    {                                                       \
                        *pPosUW = GET_UNICODE_MOD(&PrevWt, fModify);        \
                    }                                                       \
                                                                            \
                    break;                                                  \
                }                                                           \
                                                                            \
                /*                                                          \
                 *  Make sure there is a valid UW.  If not, quit out        \
                 *  of switch case.                                         \
                 */                                                         \
                if (*pPosUW == MAP_INVALID_UW)                              \
                {                                                           \
                    pPosUW++;                                               \
                    break;                                                  \
                }                                                           \
            }                                                               \
            else                                                            \
            {                                                               \
                /*                                                          \
                 *  Kana:                                                   \
                 *    SM = KANA                                             \
                 *    AW = current AW                                       \
                 *    4W = current CW  &  ISOLATE_SMALL                     \
                 *    5W = WT_FIVE_KANA                                     \
                 *    6W = current CW  &  ISOLATE_KANA                      \
                 *    7W = current CW  &  ISOLATE_WIDTH                     \
                 */                                                         \
                *pPosUW = MAKE_UNICODE_WT(KANA, AW, fModify);               \
                EXTRA_WEIGHT_POS(0) = XW & ISOLATE_SMALL;                   \
                EXTRA_WEIGHT_POS(1) = WT_FIVE_KANA;                         \
                EXTRA_WEIGHT_POS(2) = XW & ISOLATE_KANA;                    \
                EXTRA_WEIGHT_POS(3) = XW & ISOLATE_WIDTH;                   \
                                                                            \
                pPosXW++;                                                   \
            }                                                               \
                                                                            \
            /*                                                              \
             *  Always:                                                     \
             *    DW = current DW                                           \
             *    CW = minimum CW                                           \
             */                                                             \
            *pPosDW = GET_DIACRITIC(pWeight);                               \
            *pPosCW = MIN_CW;                                               \
                                                                            \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            break;                                                          \
        }                                                                   \
        case ( JAMO_SPECIAL ) :                                             \
        {                                                                   \
            /*                                                              \
             *  See if it's a leading Jamo.                                 \
             */                                                             \
            if (IsLeadingJamo(*pPos))                                       \
            {                                                               \
                int OldHangulCount;   /* number of old Hangul found */      \
                WORD JamoUW;                                                \
                BYTE JamoXW[3];                                             \
                                                                            \
                /*                                                          \
                 *  If the characters beginning from pPos are a valid old   \
                 *  Hangul composition, create the sortkey according to     \
                 *  the old Hangul rule.                                    \
                 */                                                         \
                if ((OldHangulCount =                                       \
                        MapOldHangulSortKey( pHashN,                        \
                                             pPos,                          \
                                             cchSrc - PosCtr,               \
                                             &JamoUW,                       \
                                             JamoXW,                        \
                                             fModify )) > 0)                \
                {                                                           \
                    *pPosUW = JamoUW;                                       \
                    pPosUW++;                                               \
                    *pPosUW = MAKE_UNICODE_WT(SM_UW_XW, JamoXW[0], FALSE);  \
                    pPosUW++;                                               \
                    *pPosUW = MAKE_UNICODE_WT(SM_UW_XW, JamoXW[1], FALSE);  \
                    pPosUW++;                                               \
                    *pPosUW = MAKE_UNICODE_WT(SM_UW_XW, JamoXW[2], FALSE);  \
                    pPosUW++;                                               \
                                                                            \
                    *pPosDW = MIN_DW;                                       \
                    *pPosCW = MIN_CW;                                       \
                    pPosDW++;                                               \
                    pPosCW++;                                               \
                                                                            \
                    /*                                                      \
                     *  Decrement OldHangulCount because the for loop will  \
                     *  increase PosCtr and pPos as well.                   \
                     */                                                     \
                    OldHangulCount--;                                       \
                    PosCtr += OldHangulCount;                               \
                    pPos += OldHangulCount;                                 \
                                                                            \
                    break;                                                  \
                }                                                           \
            }                                                               \
                                                                            \
            /*                                                              \
             *  Otherwise, fall back to the normal behavior.                \
             *                                                              \
             *  No special case on character, so store the various          \
             *  weights for the character.                                  \
             */                                                             \
                                                                            \
            /*                                                              \
             *  We store the real script member in the diacritic weight     \
             *  since both the diacritic weight and case weight are not     \
             *  used in Korean.                                             \
             */                                                             \
            *pPosUW = MAKE_UNICODE_WT( GET_DIACRITIC(pWeight),              \
                                       GET_ALPHA_NUMERIC(pWeight),          \
                                       fModify );                           \
            *pPosDW = MIN_DW;                                               \
            *pPosCW = GET_CASE(pWeight);                                    \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            break;                                                          \
        }                                                                   \
        case ( EXTENSION_A ) :                                              \
        {                                                                   \
            /*                                                              \
             *  UW = SM_EXT_A, AW_EXT_A, AW, DW                             \
             *  DW = miniumum DW                                            \
             *  CW = minimum CW                                             \
             */                                                             \
            *pPosUW = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A, fModify);         \
            pPosUW++;                                                       \
                                                                            \
            *pPosUW = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(pWeight),          \
                                       GET_DIACRITIC(pWeight),              \
                                       FALSE );                             \
            pPosUW++;                                                       \
                                                                            \
            *pPosDW = MIN_DW;                                               \
            *pPosCW = MIN_CW;                                               \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            break;                                                          \
        }                                                                   \
    }                                                                       \
}


////////////////////////////////////////////////////////////////////////////
//
//  MapSortKey
//
//  Stores the sortkey weights for the given string in the destination
//  buffer and returns the number of BYTES written to the buffer.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapSortKey(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPBYTE pDest,
    int cbDest,
    BOOL fModify)
{
    register int WeightLen;       // length of one set of weights
    LPWSTR pUW;                   // ptr to Unicode Weights
    LPBYTE pDW;                   // ptr to Diacritic Weights
    LPBYTE pCW;                   // ptr to Case Weights
    LPBYTE pXW;                   // ptr to Extra Weights
    LPWSTR pSW;                   // ptr to Special Weights
    LPWSTR pPosUW;                // ptr to position in pUW buffer
    LPBYTE pPosDW;                // ptr to position in pDW buffer
    LPBYTE pPosCW;                // ptr to position in pCW buffer
    LPBYTE pPosXW;                // ptr to position in pXW buffer
    LPWSTR pPosSW;                // ptr to position in pSW buffer
    PSORTKEY pWeight;             // ptr to weight of character
    BYTE SM;                      // script member value
    BYTE CaseMask;                // mask for case weight
    int PosCtr;                   // position counter in string
    LPWSTR pPos;                  // ptr to position in string
    LPBYTE pTmp;                  // ptr to go through UW, XW, and SW
    LPBYTE pPosTmp;               // ptr to tmp position in XW
    PCOMPRESS_2 pComp2;           // ptr to compression 2 list
    PCOMPRESS_3 pComp3;           // ptr to compression 3 list
    WORD pBuffer[MAX_SORTKEY_BUF_LEN]; // buffer to hold weights
    int ctr;                      // loop counter
    BOOL IfDblCompress;           // if double compress possibility
    BOOL fStringSort;             // if using string sort method
    BOOL fIgnoreSymbols;          // if ignore symbols flag is set


    //
    //  Make sure the sorting information is available in the system.
    //
    if ((pHashN->pSortkey == NULL) ||
        (pHashN->IfIdeographFailure == TRUE))
    {
        KdPrint(("NLSAPI: Appropriate Sorting Tables Not Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  See if the length of the string is too large for the static
    //  buffer.  If so, allocate a buffer that is large enough.
    //
    if (cchSrc > MAX_SMALL_BUF_LEN)
    {
        //
        //  Allocate buffer to hold all of the weights.
        //     (cchSrc) * (max # of expansions) * (# of weights)
        //
        WeightLen = cchSrc * MAX_EXPANSION;
        if ((pUW = (LPWSTR)NLS_ALLOC_MEM( WeightLen * MAX_WEIGHTS *
                                          sizeof(WCHAR) )) == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return (0);
        }
    }
    else
    {
        WeightLen = MAX_SMALL_BUF_LEN * MAX_EXPANSION;
        pUW = (LPWSTR)pBuffer;
    }

    //
    //  Set the case weight mask based on the given flags.
    //  If none or all of the ignore case flags are set, then
    //  just leave the mask as 0xff.
    //
    CaseMask = 0xff;
    switch (dwFlags & NORM_ALL_CASE)
    {
        case ( NORM_IGNORECASE ) :
        {
            CaseMask &= CASE_UPPER_MASK;
            break;
        }
        case ( NORM_IGNOREKANATYPE ) :
        {
            CaseMask &= CASE_KANA_MASK;
            break;
        }
        case ( NORM_IGNOREWIDTH ) :
        {
            CaseMask &= CASE_WIDTH_MASK;
            break;
        }
        case ( NORM_IGNORECASE | NORM_IGNOREKANATYPE ) :
        {
            CaseMask &= (CASE_UPPER_MASK & CASE_KANA_MASK);
            break;
        }
        case ( NORM_IGNORECASE | NORM_IGNOREWIDTH ) :
        {
            CaseMask &= (CASE_UPPER_MASK & CASE_WIDTH_MASK);
            break;
        }
        case ( NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH ) :
        {
            CaseMask &= (CASE_KANA_MASK & CASE_WIDTH_MASK);
            break;
        }
        case ( NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH ) :
        {
            CaseMask &= (CASE_UPPER_MASK & CASE_KANA_MASK & CASE_WIDTH_MASK);
            break;
        }
    }

    //
    //  Set pointers to positions of weights in buffer.
    //
    //      UW  =>  4 word length  (extension A and Jamo need extra words)
    //      DW  =>  byte   length
    //      CW  =>  byte   length
    //      XW  =>  4 byte length  (4 weights, 1 byte each)   FE Special
    //      SW  =>  dword  length  (2 words each)
    //
    //  Note: SW must start on a WORD boundary, so XW needs to be padded
    //        appropriately.
    //
    pDW     = (LPBYTE)(pUW + (WeightLen * (NUM_BYTES_UW / sizeof(WCHAR))));
    pCW     = (LPBYTE)(pDW + (WeightLen *  NUM_BYTES_DW));
    pXW     = (LPBYTE)(pCW + (WeightLen *  NUM_BYTES_CW));
    pSW     = (LPWSTR)(pXW + (WeightLen * (NUM_BYTES_XW + NUM_BYTES_PADDING)));
    pPosUW  = pUW;
    pPosDW  = pDW;
    pPosCW  = pCW;
    pPosXW  = pXW;
    pPosSW  = pSW;

    //
    //  Initialize flags and loop values.
    //
    fStringSort = dwFlags & SORT_STRINGSORT;
    fIgnoreSymbols = dwFlags & NORM_IGNORESYMBOLS;
    pPos = (LPWSTR)pSrc;
    PosCtr = 1;

    //
    //  Check if given locale has compressions.
    //
    if (pHashN->IfCompression == FALSE)
    {
        //
        //  Go through string, code point by code point.
        //
        //  No compressions exist in the given locale, so
        //  DO NOT check for them.
        //
        for (; PosCtr <= cchSrc; PosCtr++, pPos++)
        {
            //
            //  Get weights.
            //
            pWeight = &((pHashN->pSortkey)[*pPos]);
            SM = GET_SCRIPT_MEMBER(pWeight);

            if (SM > MAX_SPECIAL_CASE)
            {
                //
                //  No special case on character, so store the
                //  various weights for the character.
                //
                *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                *pPosDW = GET_DIACRITIC(pWeight);
                *pPosCW = GET_CASE(pWeight) & CaseMask;
                pPosUW++;
                pPosDW++;
                pPosCW++;
            }
            else
            {
                SPECIAL_CASE_HANDLER( SM,
                                      pWeight,
                                      pHashN->pSortkey,
                                      pTblPtrs->pExpansion,
                                      pPosUW - pUW + 1,
                                      fStringSort,
                                      fIgnoreSymbols,
                                      pPos,
                                      (LPWSTR)pSrc,
                                      fModify );
            }
        }
    }
    else if (pHashN->IfDblCompression == FALSE)
    {
        //
        //  Go through string, code point by code point.
        //
        //  Compressions DO exist in the given locale, so
        //  check for them.
        //
        //  No double compressions exist in the given locale,
        //  so DO NOT check for them.
        //
        for (; PosCtr <= cchSrc; PosCtr++, pPos++)
        {
            //
            //  Get weights.
            //
            pWeight = &((pHashN->pSortkey)[*pPos]);
            SM = GET_SCRIPT_MEMBER(pWeight);

            if (SM > MAX_SPECIAL_CASE)
            {
                //
                //  No special case on character, but must check for
                //  compression characters.
                //
                switch (GET_COMPRESSION(pWeight))
                {
                    case ( COMPRESS_3_MASK ) :
                    {
                        if ((PosCtr + 2) <= cchSrc)
                        {
                            ctr = pHashN->pCompHdr->Num3;
                            pComp3 = pHashN->pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                if ((pComp3->UCP1 == *pPos) &&
                                    (pComp3->UCP2 == *(pPos + 1)) &&
                                    (pComp3->UCP3 == *(pPos + 2)))
                                {
                                    pWeight = &(pComp3->Weights);
                                    *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only two to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos += 2;
                                    PosCtr += 2;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                    }
                    case ( COMPRESS_2_MASK ) :
                    {
                        if ((PosCtr + 1) <= cchSrc)
                        {
                            ctr = pHashN->pCompHdr->Num2;
                            pComp2 = pHashN->pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                if ((pComp2->UCP1 == *pPos) &&
                                    (pComp2->UCP2 == *(pPos + 1)))
                                {
                                    pWeight = &(pComp2->Weights);
                                    *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only one to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos++;
                                    PosCtr++;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                    }
                    default :
                    {
                        //
                        //  No possible compression for character, so store
                        //  the various weights for the character.
                        //
                        *pPosUW = GET_UNICODE_SM_MOD(pWeight, SM, fModify);
                        *pPosDW = GET_DIACRITIC(pWeight);
                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                        pPosUW++;
                        pPosDW++;
                        pPosCW++;
                    }
                }
            }
            else
            {
                SPECIAL_CASE_HANDLER( SM,
                                      pWeight,
                                      pHashN->pSortkey,
                                      pTblPtrs->pExpansion,
                                      pPosUW - pUW + 1,
                                      fStringSort,
                                      fIgnoreSymbols,
                                      pPos,
                                      (LPWSTR)pSrc,
                                      fModify );
            }
        }
    }
    else
    {
        //
        //  Go through string, code point by code point.
        //
        //  Compressions DO exist in the given locale, so
        //  check for them.
        //
        //  Double Compressions also exist in the given locale,
        //  so check for them.
        //
        for (; PosCtr <= cchSrc; PosCtr++, pPos++)
        {
            //
            //  Get weights.
            //
            pWeight = &((pHashN->pSortkey)[*pPos]);
            SM = GET_SCRIPT_MEMBER(pWeight);

            if (SM > MAX_SPECIAL_CASE)
            {
                //
                //  No special case on character, but must check for
                //  compression characters and double compression
                //  characters.
                //
                IfDblCompress =
                  (((PosCtr + 1) <= cchSrc) &&
                   ((GET_DWORD_WEIGHT(pHashN, *pPos) & CMP_MASKOFF_CW) ==
                    (GET_DWORD_WEIGHT(pHashN, *(pPos + 1)) & CMP_MASKOFF_CW)))
                   ? 1
                   : 0;

                switch (GET_COMPRESSION(pWeight))
                {
                    case ( COMPRESS_3_MASK ) :
                    {
                        if (IfDblCompress)
                        {
                            if ((PosCtr + 3) <= cchSrc)
                            {
                                ctr = pHashN->pCompHdr->Num3;
                                pComp3 = pHashN->pCompress3;
                                for (; ctr > 0; ctr--, pComp3++)
                                {
                                    if ((pComp3->UCP1 == *(pPos + 1)) &&
                                        (pComp3->UCP2 == *(pPos + 2)) &&
                                        (pComp3->UCP3 == *(pPos + 3)))
                                    {
                                        pWeight = &(pComp3->Weights);
                                        *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                        *pPosDW = GET_DIACRITIC(pWeight);
                                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                                        *(pPosUW + 1) = *pPosUW;
                                        *(pPosDW + 1) = *pPosDW;
                                        *(pPosCW + 1) = *pPosCW;
                                        pPosUW += 2;
                                        pPosDW += 2;
                                        pPosCW += 2;

                                        //
                                        //  Add only three to source, since one
                                        //  will be added by "for" structure.
                                        //
                                        pPos += 3;
                                        PosCtr += 3;
                                        break;
                                    }
                                }
                                if (ctr > 0)
                                {
                                    break;
                                }
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                        if ((PosCtr + 2) <= cchSrc)
                        {
                            ctr = pHashN->pCompHdr->Num3;
                            pComp3 = pHashN->pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                if ((pComp3->UCP1 == *pPos) &&
                                    (pComp3->UCP2 == *(pPos + 1)) &&
                                    (pComp3->UCP3 == *(pPos + 2)))
                                {
                                    pWeight = &(pComp3->Weights);
                                    *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only two to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos += 2;
                                    PosCtr += 2;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }
                        //
                        //  Fall through if not found.
                        //
                    }
                    case ( COMPRESS_2_MASK ) :
                    {
                        if (IfDblCompress)
                        {
                            if ((PosCtr + 2) <= cchSrc)
                            {
                                ctr = pHashN->pCompHdr->Num2;
                                pComp2 = pHashN->pCompress2;
                                for (; ctr > 0; ctr--, pComp2++)
                                {
                                    if ((pComp2->UCP1 == *(pPos + 1)) &&
                                        (pComp2->UCP2 == *(pPos + 2)))
                                    {
                                        pWeight = &(pComp2->Weights);
                                        *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                        *pPosDW = GET_DIACRITIC(pWeight);
                                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                                        *(pPosUW + 1) = *pPosUW;
                                        *(pPosDW + 1) = *pPosDW;
                                        *(pPosCW + 1) = *pPosCW;
                                        pPosUW += 2;
                                        pPosDW += 2;
                                        pPosCW += 2;

                                        //
                                        //  Add only two to source, since one
                                        //  will be added by "for" structure.
                                        //
                                        pPos += 2;
                                        PosCtr += 2;
                                        break;
                                    }
                                }
                                if (ctr > 0)
                                {
                                    break;
                                }
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                        if ((PosCtr + 1) <= cchSrc)
                        {
                            ctr = pHashN->pCompHdr->Num2;
                            pComp2 = pHashN->pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                if ((pComp2->UCP1 == *pPos) &&
                                    (pComp2->UCP2 == *(pPos + 1)))
                                {
                                    pWeight = &(pComp2->Weights);
                                    *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only one to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos++;
                                    PosCtr++;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                    }
                    default :
                    {
                        //
                        //  No possible compression for character, so store
                        //  the various weights for the character.
                        //
                        *pPosUW = GET_UNICODE_SM_MOD(pWeight, SM, fModify);
                        *pPosDW = GET_DIACRITIC(pWeight);
                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                        pPosUW++;
                        pPosDW++;
                        pPosCW++;
                    }
                }
            }
            else
            {
                SPECIAL_CASE_HANDLER( SM,
                                      pWeight,
                                      pHashN->pSortkey,
                                      pTblPtrs->pExpansion,
                                      pPosUW - pUW + 1,
                                      fStringSort,
                                      fIgnoreSymbols,
                                      pPos,
                                      (LPWSTR)pSrc,
                                      fModify );
            }
        }
    }

    //
    //  Store the final sortkey weights in the destination buffer.
    //
    //  PosCtr will be a BYTE count.
    //
    PosCtr = 0;

    //
    //  If the destination value is zero, then just return the
    //  length of the string that would be returned.  Do NOT touch pDest.
    //
    if (cbDest == 0)
    {
        //
        //  Count the Unicode Weights.
        //
        PosCtr += (int)((LPBYTE)pPosUW - (LPBYTE)pUW);

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Diacritic Weights.
        //
        //    - Eliminate minimum DW.
        //    - Count the number of diacritic weights.
        //
        if (!(dwFlags & NORM_IGNORENONSPACE))
        {
            pPosDW--;
            if (pHashN->IfReverseDW == TRUE)
            {
                //
                //  Reverse diacritics:
                //    - remove diacritics from left  to right.
                //    - count  diacritics from right to left.
                //
                while ((pDW <= pPosDW) && (*pDW <= MIN_DW))
                {
                    pDW++;
                }
                PosCtr += (int)(pPosDW - pDW + 1);
            }
            else
            {
                //
                //  Regular diacritics:
                //    - remove diacritics from right to left.
                //    - count  diacritics from left  to right.
                //
                while ((pPosDW >= pDW) && (*pPosDW <= MIN_DW))
                {
                    pPosDW--;
                }
                PosCtr += (int)(pPosDW - pDW + 1);
            }
        }

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Case Weights.
        //
        //    - Eliminate minimum CW.
        //    - Count the number of case weights.
        //
        if ((dwFlags & NORM_DROP_CW) != NORM_DROP_CW)
        {
            pPosCW--;
            while ((pPosCW >= pCW) && (*pPosCW <= MIN_CW))
            {
                pPosCW--;
            }
            PosCtr += (int)(pPosCW - pCW + 1);
        }

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Extra Weights for Far East Special.
        //
        //    - Eliminate unnecessary XW.
        //    - Count the number of extra weights and separators.
        //
        if (pXW < pPosXW)
        {
            if (dwFlags & NORM_IGNORENONSPACE)
            {
                //
                //  Ignore 4W and 5W.  Must count separators for
                //  4W and 5W, though.
                //
                PosCtr += 2;
                ctr = 2;
            }
            else
            {
                ctr = 0;
            }

            pPosXW--;
            for (; ctr < NUM_BYTES_XW; ctr++)
            {
                pTmp = pXW + (WeightLen * ctr);
                pPosTmp = pPosXW + (WeightLen * ctr);
                while ((pPosTmp >= pTmp) && (*pPosTmp == pXWDrop[ctr]))
                {
                    pPosTmp--;
                }
                PosCtr += (int)(pPosTmp - pTmp + 1);

                //
                //  Count the Separator.
                //
                PosCtr++;
            }
        }

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Special Weights.
        //
        if (!fIgnoreSymbols)
        {
            PosCtr += (int)((LPBYTE)pPosSW - (LPBYTE)pSW);
        }

        //
        //  Count the Terminator.
        //
        PosCtr++;
    }
    else
    {
        //
        //  Store the Unicode Weights in the destination buffer.
        //
        //    - Make sure destination buffer is large enough.
        //    - Copy unicode weights to destination buffer.
        //
        //  NOTE:  cbDest is the number of BYTES.
        //         Also, must add one to length for separator.
        //
        if (cbDest < (((LPBYTE)pPosUW - (LPBYTE)pUW) + 1))
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
        pTmp = (LPBYTE)pUW;
        while (pTmp < (LPBYTE)pPosUW)
        {
            //
            //  Copy Unicode weight to destination buffer.
            //
            //  NOTE:  Unicode Weight is stored in the data file as
            //             Alphanumeric Weight, Script Member
            //         so that the WORD value will be read correctly.
            //
            pDest[PosCtr]     = *(pTmp + 1);
            pDest[PosCtr + 1] = *pTmp;
            PosCtr += 2;
            pTmp += 2;
        }

        //
        //  Copy Separator to destination buffer.
        //
        //  Destination buffer is large enough to hold the separator,
        //  since it was checked with the Unicode weights above.
        //
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Diacritic Weights in the destination buffer.
        //
        //    - Eliminate minimum DW.
        //    - Make sure destination buffer is large enough.
        //    - Copy diacritic weights to destination buffer.
        //
        if (!(dwFlags & NORM_IGNORENONSPACE))
        {
            pPosDW--;
            if (pHashN->IfReverseDW == TRUE)
            {
                //
                //  Reverse diacritics:
                //    - remove diacritics from left  to right.
                //    - store  diacritics from right to left.
                //
                while ((pDW <= pPosDW) && (*pDW <= MIN_DW))
                {
                    pDW++;
                }
                if ((cbDest - PosCtr) <= (pPosDW - pDW + 1))
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
                while (pPosDW >= pDW)
                {
                    pDest[PosCtr] = *pPosDW;
                    PosCtr++;
                    pPosDW--;
                }
            }
            else
            {
                //
                //  Regular diacritics:
                //    - remove diacritics from right to left.
                //    - store  diacritics from left  to right.
                //
                while ((pPosDW >= pDW) && (*pPosDW <= MIN_DW))
                {
                    pPosDW--;
                }
                if ((cbDest - PosCtr) <= (pPosDW - pDW + 1))
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
                while (pDW <= pPosDW)
                {
                    pDest[PosCtr] = *pDW;
                    PosCtr++;
                    pDW++;
                }
            }
        }

        //
        //  Copy Separator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Case Weights in the destination buffer.
        //
        //    - Eliminate minimum CW.
        //    - Make sure destination buffer is large enough.
        //    - Copy case weights to destination buffer.
        //
        if ((dwFlags & NORM_DROP_CW) != NORM_DROP_CW)
        {
            pPosCW--;
            while ((pPosCW >= pCW) && (*pPosCW <= MIN_CW))
            {
                pPosCW--;
            }
            if ((cbDest - PosCtr) <= (pPosCW - pCW + 1))
            {
                NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }
            while (pCW <= pPosCW)
            {
                pDest[PosCtr] = *pCW;
                PosCtr++;
                pCW++;
            }
        }

        //
        //  Copy Separator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Extra Weights in the destination buffer for
        //  Far East Special.
        //
        //    - Eliminate unnecessary XW.
        //    - Make sure destination buffer is large enough.
        //    - Copy extra weights to destination buffer.
        //
        if (pXW < pPosXW)
        {
            if (dwFlags & NORM_IGNORENONSPACE)
            {
                //
                //  Ignore 4W and 5W.  Must count separators for
                //  4W and 5W, though.
                //
                if ((cbDest - PosCtr) <= 2)
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }

                pDest[PosCtr] = pXWSeparator[0];
                pDest[PosCtr + 1] = pXWSeparator[1];
                PosCtr += 2;
                ctr = 2;
            }
            else
            {
                ctr = 0;
            }

            pPosXW--;
            for (; ctr < NUM_BYTES_XW; ctr++)
            {
                pTmp = pXW + (WeightLen * ctr);
                pPosTmp = pPosXW + (WeightLen * ctr);
                while ((pPosTmp >= pTmp) && (*pPosTmp == pXWDrop[ctr]))
                {
                    pPosTmp--;
                }
                if ((cbDest - PosCtr) <= (pPosTmp - pTmp + 1))
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
                while (pTmp <= pPosTmp)
                {
                    pDest[PosCtr] = *pTmp;
                    PosCtr++;
                    pTmp++;
                }

                //
                //  Copy Separator to destination buffer.
                //
                pDest[PosCtr] = pXWSeparator[ctr];
                PosCtr++;
            }
        }

        //
        //  Copy Separator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Special Weights in the destination buffer.
        //
        //    - Make sure destination buffer is large enough.
        //    - Copy special weights to destination buffer.
        //
        if (!fIgnoreSymbols)
        {
            if ((cbDest - PosCtr) <= (((LPBYTE)pPosSW - (LPBYTE)pSW)))
            {
                NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }
            pTmp = (LPBYTE)pSW;
            while (pTmp < (LPBYTE)pPosSW)
            {
                pDest[PosCtr]     = *pTmp;
                pDest[PosCtr + 1] = *(pTmp + 1);

                //
                //  NOTE:  Special Weight is stored in the data file as
                //             Weight, Script
                //         so that the WORD value will be read correctly.
                //
                pDest[PosCtr + 2] = *(pTmp + 3);
                pDest[PosCtr + 3] = *(pTmp + 2);

                PosCtr += 4;
                pTmp += 4;
            }
        }

        //
        //  Copy Terminator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_TERMINATOR;
        PosCtr++;
    }

    //
    //  Free the buffer used for the weights, if one was allocated.
    //
    NLS_FREE_TMP_BUFFER(pUW, pBuffer);

    //
    //  Return number of BYTES written to destination buffer.
    //
    return (PosCtr);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapNormalization
//
//  Stores the result of the normalization for the given string in the
//  destination buffer, and returns the number of wide characters written
//  to the buffer.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapNormalization(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr;                      // source char counter
    int ctr2 = 0;                 // destination char counter

    //
    //  Make sure the ctype table is available in the system.
    //
    if (GetCTypeFileInfo())
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  Make sure the sorting information is available in the system.
    //
    if ((pHashN->pSortkey == NULL) ||
        (pHashN->IfIdeographFailure == TRUE))
    {
        KdPrint(("NLSAPI: Appropriate Sorting Tables Not Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  Normalize based on the flags.
    //
    switch (dwFlags)
    {
        case ( NORM_IGNORENONSPACE ) :
        {
            //
            //  If the destination value is zero, then only return
            //  the count of characters.  Do NOT touch pDest.
            //
            if (cchDest == 0)
            {
                //
                //  Count the number of characters that would be written
                //  to the destination buffer.
                //
                for (ctr = 0, ctr2 = 0; ctr < cchSrc; ctr++)
                {
                    if (!IS_NONSPACE(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a nonspacing character, so just write the
                        //  character to the destination string.
                        //
                        ctr2++;
                    }
                    else if (!(IS_NONSPACE_ONLY(pHashN->pSortkey, pSrc[ctr])))
                    {
                        //
                        //  PreComposed Form.  Write the base character only.
                        //
                        ctr2++;
                    }
                    //
                    //  Else - nonspace character only, so don't write
                    //         anything.
                    //
                }
            }
            else
            {
                //
                //  Store the normalized string in the destination string.
                //
                for (ctr = 0, ctr2 = 0; (ctr < cchSrc) && (ctr2 < cchDest);
                     ctr++)
                {
                    if (!IS_NONSPACE(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a nonspacing character, so just write the
                        //  character to the destination string.
                        //
                        pDest[ctr2] = pSrc[ctr];
                        ctr2++;
                    }
                    else if (!(IS_NONSPACE_ONLY(pHashN->pSortkey, pSrc[ctr])))
                    {
                        //
                        //  PreComposed Form.  Write the base character only.
                        //
                        GET_BASE_CHAR(pSrc[ctr], pDest[ctr2]);
                        if (pDest[ctr2] == 0)
                        {
                            //
                            //  No translation for precomposed character,
                            //  so must write the precomposed character.
                            //
                            pDest[ctr2] = pSrc[ctr];
                        }
                        ctr2++;
                    }
                    //
                    //  Else - nonspace character only, so don't write
                    //         anything.
                    //
                }
            }

            break;
        }
        case ( NORM_IGNORESYMBOLS ) :
        {
            //
            //  If the destination value is zero, then only return
            //  the count of characters.  Do NOT touch pDest.
            //
            if (cchDest == 0)
            {
                //
                //  Count the number of characters that would be written
                //  to the destination buffer.
                //
                for (ctr = 0, ctr2 = 0; ctr < cchSrc; ctr++)
                {
                    if (!IS_SYMBOL(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a symbol, so write the character.
                        //
                        ctr2++;
                    }
                }
            }
            else
            {
                //
                //  Store the normalized string in the destination string.
                //
                for (ctr = 0, ctr2 = 0; (ctr < cchSrc) && (ctr2 < cchDest);
                     ctr++)
                {
                    if (!IS_SYMBOL(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a symbol, so write the character.
                        //
                        pDest[ctr2] = pSrc[ctr];
                        ctr2++;
                    }
                }
            }

            break;
        }
        case ( NORM_IGNORENONSPACE | NORM_IGNORESYMBOLS ) :
        {
            //
            //  If the destination value is zero, then only return
            //  the count of characters.  Do NOT touch pDest.
            //
            if (cchDest == 0)
            {
                //
                //  Count the number of characters that would be written
                //  to the destination buffer.
                //
                for (ctr = 0, ctr2 = 0; ctr < cchSrc; ctr++)
                {
                    if (!IS_SYMBOL(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a symbol, so check for nonspace.
                        //
                        if (!IS_NONSPACE(pHashN->pSortkey, pSrc[ctr]))
                        {
                            //
                            //  Not a nonspacing character, so just write the
                            //  character to the destination string.
                            //
                            ctr2++;
                        }
                        else if (!(IS_NONSPACE_ONLY( pHashN->pSortkey,
                                                     pSrc[ctr] )))
                        {
                            //
                            //  PreComposed Form.  Write the base character
                            //  only.
                            //
                            ctr2++;
                        }
                        //
                        //  Else - nonspace character only, so don't write
                        //         anything.
                        //
                    }
                }
            }
            else
            {
                //
                //  Store the normalized string in the destination string.
                //
                for (ctr = 0, ctr2 = 0; (ctr < cchSrc) && (ctr2 < cchDest);
                     ctr++)
                {
                    //
                    //  Check for symbol and nonspace.
                    //
                    if (!IS_SYMBOL(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a symbol, so check for nonspace.
                        //
                        if (!IS_NONSPACE(pHashN->pSortkey, pSrc[ctr]))
                        {
                            //
                            //  Not a nonspacing character, so just write the
                            //  character to the destination string.
                            //
                            pDest[ctr2] = pSrc[ctr];
                            ctr2++;
                        }
                        else if (!(IS_NONSPACE_ONLY( pHashN->pSortkey,
                                                     pSrc[ctr] )))
                        {
                            //
                            //  PreComposed Form.  Write the base character
                            //  only.
                            //
                            GET_BASE_CHAR(pSrc[ctr], pDest[ctr2]);
                            if (pDest[ctr2] == 0)
                            {
                                //
                                //  No translation for precomposed character,
                                //  so must write the precomposed character.
                                //
                                pDest[ctr2] = pSrc[ctr];
                            }
                            ctr2++;
                        }
                        //
                        //  Else - nonspace character only, so don't write
                        //         anything.
                        //
                    }
                }
            }

            break;
        }
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr2);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapKanaWidth
//
//  Stores the result of the Kana, Width, and/or Casing mappings for the
//  given string in the destination buffer, and returns the number of wide
//  characters written to the buffer.
//
//  07-26-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapKanaWidth(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr;                 // loop counter
    PCASE pCase;             // ptr to case table (if case flag is set)


    //
    //  See if lower or upper case flags are present.
    //
    if (dwFlags & LCMAP_LOWERCASE)
    {
        pCase = (dwFlags & LCMAP_LINGUISTIC_CASING)
                    ? pHashN->pLowerLinguist
                    : pHashN->pLowerCase;
    }
    else if (dwFlags & LCMAP_UPPERCASE)
    {
        pCase = (dwFlags & LCMAP_LINGUISTIC_CASING)
                    ? pHashN->pUpperLinguist
                    : pHashN->pUpperCase;
    }
    else
    {
        pCase = NULL;
    }

    //
    //  Remove lower, upper, and linguistic casing flags.
    //
    dwFlags &= ~(LCMAP_LOWERCASE | LCMAP_UPPERCASE | LCMAP_LINGUISTIC_CASING);

    //
    //  Map the string based on the given flags.
    //
    switch (dwFlags)
    {
        case ( LCMAP_HIRAGANA ) :
        case ( LCMAP_KATAKANA ) :
        {
            //
            //  If the destination value is zero, then just return the
            //  length of the source string.  Do NOT touch pDest.
            //
            if (cchDest == 0)
            {
                return (cchSrc);
            }

            //
            //  If cchSrc is greater than cchDest, then the destination
            //  buffer is too small to hold the string.  Return an error.
            //
            if (cchSrc > cchDest)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }

            if (dwFlags == LCMAP_HIRAGANA)
            {
                //
                //  Map all Katakana full width to Hiragana full width.
                //  Katakana half width will remain Katakana half width.
                //
                if (pCase)
                {
                    for (ctr = 0; ctr < cchSrc; ctr++)
                    {
                        pDest[ctr] = GET_KANA(pTblPtrs->pHiragana, pSrc[ctr]);

                        pDest[ctr] = GET_LOWER_UPPER_CASE(pCase, pDest[ctr]);
                    }
                }
                else
                {
                    for (ctr = 0; ctr < cchSrc; ctr++)
                    {
                        pDest[ctr] = GET_KANA(pTblPtrs->pHiragana, pSrc[ctr]);
                    }
                }
            }
            else
            {
                //
                //  Map all Hiragana full width to Katakana full width.
                //  Hiragana half width does not exist.
                //
                if (pCase)
                {
                    for (ctr = 0; ctr < cchSrc; ctr++)
                    {
                        pDest[ctr] = GET_KANA(pTblPtrs->pKatakana, pSrc[ctr]);

                        pDest[ctr] = GET_LOWER_UPPER_CASE(pCase, pDest[ctr]);
                    }
                }
                else
                {
                    for (ctr = 0; ctr < cchSrc; ctr++)
                    {
                        pDest[ctr] = GET_KANA(pTblPtrs->pKatakana, pSrc[ctr]);
                    }
                }
            }

            //
            //  Return the number of characters mapped.
            //
            return (cchSrc);

            break;
        }
        case ( LCMAP_HALFWIDTH ) :
        {
            //
            //  Map all chars to half width.
            //
            return (MapHalfKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 NULL,
                                 pCase ));

            break;
        }
        case ( LCMAP_FULLWIDTH ) :
        {
            //
            //  Map all chars to full width.
            //
            return (MapFullKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 NULL,
                                 pCase ));

            break;
        }
        case ( LCMAP_HIRAGANA | LCMAP_HALFWIDTH ) :
        {
            //
            //  This combination of flags is strange, because
            //  Hiragana is only full width.  So, the Hiragana flag
            //  is the most important.  Full width Katakana will be
            //  mapped to full width Hiragana, not half width
            //  Katakana.
            //
            //  Map to Hiragana, then Half Width.
            //
            return (MapHalfKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 pTblPtrs->pHiragana,
                                 pCase ));

            break;
        }
        case ( LCMAP_HIRAGANA | LCMAP_FULLWIDTH ) :
        {
            //
            //  Since Hiragana is only FULL width, the mapping to
            //  width must be done first to convert all half width
            //  Katakana to full width Katakana before trying to
            //  map to Hiragana.
            //
            //  Map to Full Width, then Hiragana.
            //
            return (MapFullKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 pTblPtrs->pHiragana,
                                 pCase ));

            break;
        }
        case ( LCMAP_KATAKANA | LCMAP_HALFWIDTH ) :
        {
            //
            //  Since Hiragana is only FULL width, the mapping to
            //  Katakana must be done first to convert all Hiragana
            //  to Katakana before trying to map to half width.
            //
            //  Map to Katakana, then Half Width.
            //
            return (MapHalfKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 pTblPtrs->pKatakana,
                                 pCase ));

            break;
        }
        case ( LCMAP_KATAKANA | LCMAP_FULLWIDTH ) :
        {
            //
            //  Since Hiragana is only FULL width, it doesn't matter
            //  which way the mapping is done for this combination.
            //
            //  Map to Full Width, then Katakana.
            //
            return (MapFullKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 pTblPtrs->pKatakana,
                                 pCase ));

            break;
        }
        default :
        {
            //
            //  Return error.
            //
            return (0);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapHalfKana
//
//  Stores the result of the half width and Kana mapping for the given string
//  in the destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  This first converts the precomposed characters to their composite forms,
//  and then maps all characters to their half width forms.  This handles the
//  case where the full width precomposed form should map to TWO half width
//  code points (composite form).  The half width precomposed forms do not
//  exist in Unicode.
//
//  11-04-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapHalfKana(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PKANA pKana,
    PCASE pCase)
{
    int Count;                    // count of characters written
    int ctr = 0;                  // loop counter
    int ct;                       // loop counter
    LPWSTR pBuf;                  // ptr to destination buffer
    LPWSTR pEndBuf;               // ptr to end of destination buffer
    LPWSTR pPosDest;              // ptr to position in destination buffer
    LPWSTR *ppIncr;               // points to ptr to increment
    WCHAR pTmp[MAX_COMPOSITE];    // ptr to temporary buffer
    LPWSTR pEndTmp;               // ptr to end of temporary buffer


    //
    //  Initialize the destination pointers.
    //
    pEndTmp = pTmp + MAX_COMPOSITE;
    if (cchDest == 0)
    {
        //
        //  Do not touch the pDest pointer.  Use the pTmp buffer and
        //  initialize the end pointer.
        //
        pBuf = pTmp;
        pEndBuf = pEndTmp;

        //
        //  This is a bogus pointer and will never be touched.  It just
        //  increments this pointer into oblivion.
        //
        pDest = pBuf;
        ppIncr = &pDest;
    }
    else
    {
        //
        //  Initialize the pointers.  Use the pDest buffer.
        //
        pBuf = pDest;
        pEndBuf = pBuf + cchDest;
        ppIncr = &pBuf;
    }

    //
    //  Search through the source string.  Convert all precomposed
    //  forms to their composite form before converting to half width.
    //
    while ((ctr < cchSrc) && (pBuf < pEndBuf))
    {
        //
        //  Get the character to convert.  If we need to convert to
        //  kana, do it.
        //
        if (pKana)
        {
            *pTmp = GET_KANA(pKana, pSrc[ctr]);
        }
        else
        {
            *pTmp = pSrc[ctr];
        }

        //
        //  Convert to its composite form (if exists).
        //
        //  NOTE: Must use the tmp buffer in case the destination buffer
        //        isn't large enough to hold the composite form.
        //
        Count = InsertCompositeForm(pTmp, pEndTmp);

        //
        //  Convert to half width (if exists) and case (if appropriate).
        //
        pPosDest = pTmp;
        if (pCase)
        {
            for (ct = Count; ct > 0; ct--)
            {
                *pPosDest = GET_HALF_WIDTH(pTblPtrs->pHalfWidth, *pPosDest);

                *pPosDest = GET_LOWER_UPPER_CASE(pCase, *pPosDest);

                pPosDest++;
            }
        }
        else
        {
            for (ct = Count; ct > 0; ct--)
            {
                *pPosDest = GET_HALF_WIDTH(pTblPtrs->pHalfWidth, *pPosDest);
                pPosDest++;
            }
        }

        //
        //  Convert back to its precomposed form (if exists).
        //
        if (Count > 1)
        {
            //
            //  Get the precomposed form.
            //
            //  ct is the number of code points used from the
            //  composite form.
            //
            ct = InsertPreComposedForm(pTmp, pPosDest, pBuf);
            if (ct > 1)
            {
                //
                //  Precomposed form was found.  Need to make sure all
                //  of the composite chars were used.
                //
                if (ct == Count)
                {
                    //
                    //  All composite chars were used.  Increment by 1.
                    //
                    (*ppIncr)++;
                }
                else
                {
                    //
                    //  Not all composite chars were used.  Need to copy
                    //  the rest of the composite chars from the tmp buffer
                    //  to the destination buffer.
                    //
                    (*ppIncr)++;
                    Count -= ct;
                    if (pBuf + Count > pEndBuf)
                    {
                        break;
                    }
                    RtlMoveMemory(pBuf, pTmp + ct, Count * sizeof(WCHAR));
                    (*ppIncr) += Count;
                }
            }
            else
            {
                //
                //  Precomposed form was NOT found.  Need to copy the
                //  composite form from the tmp buffer to the destination
                //  buffer.
                //
                if (pBuf + Count > pEndBuf)
                {
                    break;
                }
                RtlMoveMemory(pBuf, pTmp, Count * sizeof(WCHAR));
                (*ppIncr) += Count;
            }
        }
        else
        {
            //
            //  Only one character (no composite form), so just copy it
            //  from the tmp buffer to the destination buffer.
            //
            *pBuf = *pTmp;
            (*ppIncr)++;
        }

        ctr++;
    }

    //
    //  Return the appropriate number of characters.
    //
    if (cchDest == 0)
    {
        //
        //  Return the number of characters written to the buffer.
        //
        return ((int)((*ppIncr) - pTmp));
    }
    else
    {
        //
        //  Make sure the given buffer was large enough to hold the
        //  mapping.
        //
        if (ctr < cchSrc)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }

        //
        //  Return the number of characters written to the buffer.
        //
        return ((int)((*ppIncr) - pDest));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapFullKana
//
//  Stores the result of the full width and Kana mapping for the given string
//  in the destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  This first converts the characters to full width, and then maps all
//  composite characters to their precomposed forms.  This handles the case
//  where the half width composite form (TWO code points) should map to a
//  full width precomposed form (ONE full width code point).  The half
//  width precomposed forms do not exist in Unicode and we need the full
//  width precomposed forms to round trip with the TWO half width code
//  points.
//
//  11-04-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapFullKana(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PKANA pKana,
    PCASE pCase)
{
    int Count;                    // count of characters
    LPWSTR pPosSrc;               // ptr to position in source buffer
    LPWSTR pEndSrc;               // ptr to end of source buffer
    LPWSTR pBuf;                  // ptr to destination buffer
    LPWSTR pEndBuf;               // ptr to end of destination buffer
    LPWSTR *ppIncr;               // points to ptr to increment
    WCHAR pTmp[MAX_COMPOSITE];    // ptr to temporary buffer


    //
    //  Initialize source string pointers.
    //
    pPosSrc = (LPWSTR)pSrc;
    pEndSrc = pPosSrc + cchSrc;

    //
    //  Initialize the destination pointers.
    //
    if (cchDest == 0)
    {
        //
        //  Do not touch the pDest pointer.  Use the pTmp buffer and
        //  initialize the end pointer.
        //
        pBuf = pTmp;
        pEndBuf = pTmp + MAX_COMPOSITE;

        //
        //  This is a bogus pointer and will never be touched.  It just
        //  increments this pointer into oblivion.
        //
        pDest = pBuf;
        ppIncr = &pDest;
    }
    else
    {
        //
        //  Initialize the pointers.  Use the pDest buffer.
        //
        pBuf = pDest;
        pEndBuf = pBuf + cchDest;
        ppIncr = &pBuf;
    }

    //
    //  Search through the source string.  Convert all composite
    //  forms to their precomposed form before converting to full width.
    //
    while ((pPosSrc < pEndSrc) && (pBuf < pEndBuf))
    {
        //
        //  Convert a composite form to its full width precomposed
        //  form (if exists).  Also, convert to case if necessary.
        //
        Count = InsertFullWidthPreComposedForm( pPosSrc,
                                                pEndSrc,
                                                pBuf,
                                                pCase );
        pPosSrc += Count;

        //
        //  Convert to kana if necessary.
        //
        if (pKana)
        {
            *pBuf = GET_KANA(pKana, *pBuf);
        }

        //
        //  Increment the destination pointer.
        //
        (*ppIncr)++;
    }

    //
    //  Return the appropriate number of characters.
    //
    if (cchDest == 0)
    {
        //
        //  Return the number of characters written to the buffer.
        //
        return ((int)((*ppIncr) - pTmp));
    }
    else
    {
        //
        //  Make sure the given buffer was large enough to hold the
        //  mapping.
        //
        if (pPosSrc < pEndSrc)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }

        //
        //  Return the number of characters written to the buffer.
        //
        return ((int)((*ppIncr) - pDest));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapTraditionalSimplified
//
//  Stores the appropriate Traditional or Simplified Chinese values in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  05-07-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapTraditionalSimplified(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PCHINESE pChinese)
{
    int ctr;                 // loop counter
    PCASE pCase;             // ptr to case table (if case flag is set)


    //
    //  If the destination value is zero, then just return the
    //  length of the source string.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        return (cchSrc);
    }

    //
    //  If cchSrc is greater than cchDest, then the destination buffer
    //  is too small to hold the new string.  Return an error.
    //
    if (cchSrc > cchDest)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  See if lower or upper case flags are present.
    //
    if (dwFlags & LCMAP_LOWERCASE)
    {
        pCase = (dwFlags & LCMAP_LINGUISTIC_CASING)
                    ? pHashN->pLowerLinguist
                    : pHashN->pLowerCase;
    }
    else if (dwFlags & LCMAP_UPPERCASE)
    {
        pCase = (dwFlags & LCMAP_LINGUISTIC_CASING)
                    ? pHashN->pUpperLinguist
                    : pHashN->pUpperCase;
    }
    else
    {
        pCase = NULL;
    }

    //
    //  Map to Traditional/Simplified and store it in the destination string.
    //  Also map the case, if appropriate.
    //
    if (pCase)
    {
        for (ctr = 0; ctr < cchSrc; ctr++)
        {
            pDest[ctr] = GET_CHINESE(pChinese, pSrc[ctr]);

            pDest[ctr] = GET_LOWER_UPPER_CASE(pCase, pDest[ctr]);
        }
    }
    else
    {
        for (ctr = 0; ctr < cchSrc; ctr++)
        {
            pDest[ctr] = GET_CHINESE(pChinese, pSrc[ctr]);
        }
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\mbcs.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    mbcs.c

Abstract:

    This file contains functions that convert multibyte character strings
    to wide character strings, convert wide character strings to multibyte
    character strings, convert a multibyte character string from one code
    page to a multibyte character string of another code page, and get the
    DBCS leadbyte ranges for a given code page.

    APIs found in this file:
      IsValidCodePage
      GetACP
      GetOEMCP
      GetCPInfo
      GetCPInfoExW
      IsDBCSLeadByte
      IsDBCSLeadByteEx
      MultiByteToWideChar
      WideCharToMultiByte

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"




//
//  Forward Declarations.
//

int
GetWCCompSB(
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr);

int
GetWCCompMB(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPBYTE pEndMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    int *pmbIncr);

int
GetWCCompSBErr(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr);

int
GetWCCompMBErr(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPBYTE pEndMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    int *pmbIncr);

int
GetMBNoDefault(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    DWORD dwFlags);

int
GetMBDefault(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    WORD wDefault,
    LPBOOL pUsedDef,
    DWORD dwFlags);

int
GetMBDefaultComp(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    WORD wDefault,
    LPBOOL pUsedDef,
    DWORD dwFlags);

int
GetMBCompSB(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPWSTR pWCStr,
    LPBYTE pMBStr,
    int mbCount,
    WORD wDefault,
    LPBOOL pUsedDef);

int
GetMBCompMB(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPWSTR pWCStr,
    LPBYTE pMBStr,
    int mbCount,
    WORD wDefault,
    LPBOOL pUsedDef,
    BOOL *fError,
    BOOL fOnlyOne);

UINT
GetMacCodePage(void);





//-------------------------------------------------------------------------//
//                           INTERNAL MACROS                               //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  CHECK_DBCS_LEAD_BYTE
//
//  Returns the offset to the DBCS table for the given leadbyte character.
//  If the given character is not a leadbyte, then it returns zero (table
//  value).
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CHECK_DBCS_LEAD_BYTE(pDBCSOff, Ch)                                 \
    (pDBCSOff ? ((WORD)(pDBCSOff[Ch])) : ((WORD)0))


////////////////////////////////////////////////////////////////////////////
//
//  CHECK_ERROR_WC_SINGLE
//
//  Checks to see if the default character was used due to an invalid
//  character.  Sets last error and returns 0 characters written if an
//  invalid character was used.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CHECK_ERROR_WC_SINGLE( pHashN,                                     \
                               wch,                                        \
                               Ch )                                        \
{                                                                          \
    if ( ( (wch == pHashN->pCPInfo->wUniDefaultChar) &&                    \
           (Ch != pHashN->pCPInfo->wTransUniDefaultChar) ) ||              \
         ( (wch >= PRIVATE_USE_BEGIN) && (wch <= PRIVATE_USE_END) ) )      \
    {                                                                      \
        SetLastError(ERROR_NO_UNICODE_TRANSLATION);                        \
        return (0);                                                        \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  CHECK_ERROR_WC_MULTI
//
//  Checks to see if the default character was used due to an invalid
//  character.  Sets last error and returns 0 characters written if an
//  invalid character was used.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CHECK_ERROR_WC_MULTI( pHashN,                                      \
                              wch,                                         \
                              lead,                                        \
                              trail )                                      \
{                                                                          \
    if ((wch == pHashN->pCPInfo->wUniDefaultChar) &&                       \
        (MAKEWORD(trail, lead) != pHashN->pCPInfo->wTransUniDefaultChar))  \
    {                                                                      \
        SetLastError(ERROR_NO_UNICODE_TRANSLATION);                        \
        return (0);                                                        \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  CHECK_ERROR_WC_MULTI_SPECIAL
//
//  Checks to see if the default character was used due to an invalid
//  character.  Sets it to 0xffff if invalid.
//
//  DEFINED AS A MACRO.
//
//  08-21-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CHECK_ERROR_WC_MULTI_SPECIAL( pHashN,                              \
                                      pWCStr,                              \
                                      lead,                                \
                                      trail )                              \
{                                                                          \
    if ((*pWCStr == pHashN->pCPInfo->wUniDefaultChar) &&                   \
        (MAKEWORD(trail, lead) != pHashN->pCPInfo->wTransUniDefaultChar))  \
    {                                                                      \
        *pWCStr = 0xffff;                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_SINGLE
//
//  Fills in pWCStr with the wide character(s) for the corresponding single
//  byte character from the appropriate translation table.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_SINGLE( pMBTbl,                                             \
                       pMBStr,                                             \
                       pWCStr )                                            \
{                                                                          \
    *pWCStr = pMBTbl[*pMBStr];                                             \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_SINGLE_SPECIAL
//
//  Fills in pWCStr with the wide character(s) for the corresponding single
//  byte character from the appropriate translation table.  Also checks for
//  invalid characters - if invalid, it fills in 0xffff instead.
//
//  DEFINED AS A MACRO.
//
//  08-21-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_SINGLE_SPECIAL( pHashN,                                     \
                               pMBTbl,                                     \
                               pMBStr,                                     \
                               pWCStr )                                    \
{                                                                          \
    *pWCStr = pMBTbl[*pMBStr];                                             \
                                                                           \
    if ( ( (*pWCStr == pHashN->pCPInfo->wUniDefaultChar) &&                \
           (*pMBStr != pHashN->pCPInfo->wTransUniDefaultChar) ) ||         \
         ( (*pWCStr >= PRIVATE_USE_BEGIN) &&                               \
           (*pWCStr <= PRIVATE_USE_END) ) )                                \
    {                                                                      \
        *pWCStr = 0xffff;                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_MULTI
//
//  Fills in pWCStr with the wide character(s) for the corresponding multibyte
//  character from the appropriate translation table.  The number of bytes
//  used from the pMBStr buffer (single byte or double byte) is stored in
//  the mbIncr parameter.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_MULTI( pHashN,                                              \
                      pMBTbl,                                              \
                      pMBStr,                                              \
                      pEndMBStr,                                           \
                      pWCStr,                                              \
                      pEndWCStr,                                           \
                      mbIncr )                                             \
{                                                                          \
    WORD Offset;                  /* offset to DBCS table for range */     \
                                                                           \
                                                                           \
    if (Offset = CHECK_DBCS_LEAD_BYTE(pHashN->pDBCSOffsets, *pMBStr))      \
    {                                                                      \
        /*                                                                 \
         *  DBCS Lead Byte.  Make sure there is a trail byte with the      \
         *  lead byte.                                                     \
         */                                                                \
        if (pMBStr + 1 == pEndMBStr)                                       \
        {                                                                  \
            /*                                                             \
             *  There is no trail byte with the lead byte.  The lead byte  \
             *  is the LAST character in the string.  Translate to NULL.   \
             */                                                            \
            *pWCStr = (WCHAR)0;                                            \
            mbIncr = 1;                                                    \
        }                                                                  \
        else if (*(pMBStr + 1) == 0)                                       \
        {                                                                  \
            /*                                                             \
             *  There is no trail byte with the lead byte.  The lead byte  \
             *  is followed by a NULL.  Translate to NULL.                 \
             *                                                             \
             *  Increment by 2 so that the null is not counted twice.      \
             */                                                            \
            *pWCStr = (WCHAR)0;                                            \
            mbIncr = 2;                                                    \
        }                                                                  \
        else                                                               \
        {                                                                  \
            /*                                                             \
             *  Fill in the wide character translation from the double     \
             *  byte character table.                                      \
             */                                                            \
            *pWCStr = (pHashN->pDBCSOffsets + Offset)[*(pMBStr + 1)];      \
            mbIncr = 2;                                                    \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Not DBCS Lead Byte.  Fill in the wide character translation    \
         *  from the single byte character table.                          \
         */                                                                \
        *pWCStr = pMBTbl[*pMBStr];                                         \
        mbIncr = 1;                                                        \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_MULTI_ERR
//
//  Fills in pWCStr with the wide character(s) for the corresponding multibyte
//  character from the appropriate translation table.  The number of bytes
//  used from the pMBStr buffer (single byte or double byte) is stored in
//  the mbIncr parameter.
//
//  Once the character has been translated, it checks to be sure the
//  character was valid.  If not, it sets last error and return 0 characters
//  written.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_MULTI_ERR( pHashN,                                          \
                          pMBTbl,                                          \
                          pMBStr,                                          \
                          pEndMBStr,                                       \
                          pWCStr,                                          \
                          pEndWCStr,                                       \
                          mbIncr )                                         \
{                                                                          \
    WORD Offset;                  /* offset to DBCS table for range */     \
                                                                           \
                                                                           \
    if (Offset = CHECK_DBCS_LEAD_BYTE(pHashN->pDBCSOffsets, *pMBStr))      \
    {                                                                      \
        /*                                                                 \
         *  DBCS Lead Byte.  Make sure there is a trail byte with the      \
         *  lead byte.                                                     \
         */                                                                \
        if ((pMBStr + 1 == pEndMBStr) || (*(pMBStr + 1) == 0))             \
        {                                                                  \
            /*                                                             \
             *  There is no trail byte with the lead byte.  Return error.  \
             */                                                            \
            SetLastError(ERROR_NO_UNICODE_TRANSLATION);                    \
            return (0);                                                    \
        }                                                                  \
                                                                           \
        /*                                                                 \
         *  Fill in the wide character translation from the double         \
         *  byte character table.                                          \
         */                                                                \
        *pWCStr = (pHashN->pDBCSOffsets + Offset)[*(pMBStr + 1)];          \
        mbIncr = 2;                                                        \
                                                                           \
        /*                                                                 \
         *  Make sure an invalid character was not translated to           \
         *  the default char.  Return an error if invalid.                 \
         */                                                                \
        CHECK_ERROR_WC_MULTI( pHashN,                                      \
                              *pWCStr,                                     \
                              *pMBStr,                                     \
                              *(pMBStr + 1) );                             \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Not DBCS Lead Byte.  Fill in the wide character translation    \
         *  from the single byte character table.                          \
         */                                                                \
        *pWCStr = pMBTbl[*pMBStr];                                         \
        mbIncr = 1;                                                        \
                                                                           \
        /*                                                                 \
         *  Make sure an invalid character was not translated to           \
         *  the default char.  Return an error if invalid.                 \
         */                                                                \
        CHECK_ERROR_WC_SINGLE( pHashN,                                     \
                               *pWCStr,                                    \
                               *pMBStr );                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_MULTI_ERR_SPECIAL
//
//  Fills in pWCStr with the wide character(s) for the corresponding multibyte
//  character from the appropriate translation table.  The number of bytes
//  used from the pMBStr buffer (single byte or double byte) is stored in
//  the mbIncr parameter.
//
//  Once the character has been translated, it checks to be sure the
//  character was valid.  If not, it fills in 0xffff.
//
//  DEFINED AS A MACRO.
//
//  08-21-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_MULTI_ERR_SPECIAL( pHashN,                                  \
                                  pMBTbl,                                  \
                                  pMBStr,                                  \
                                  pEndMBStr,                               \
                                  pWCStr,                                  \
                                  pEndWCStr,                               \
                                  mbIncr )                                 \
{                                                                          \
    WORD Offset;                  /* offset to DBCS table for range */     \
                                                                           \
                                                                           \
    if (Offset = CHECK_DBCS_LEAD_BYTE(pHashN->pDBCSOffsets, *pMBStr))      \
    {                                                                      \
        /*                                                                 \
         *  DBCS Lead Byte.  Make sure there is a trail byte with the      \
         *  lead byte.                                                     \
         */                                                                \
        if ((pMBStr + 1 == pEndMBStr) || (*(pMBStr + 1) == 0))             \
        {                                                                  \
            /*                                                             \
             *  There is no trail byte with the lead byte.  The lead byte  \
             *  is the LAST character in the string.  Translate to 0xffff. \
             */                                                            \
            *pWCStr = (WCHAR)0xffff;                                       \
            mbIncr = 1;                                                    \
        }                                                                  \
        else                                                               \
        {                                                                  \
            /*                                                             \
             *  Fill in the wide character translation from the double     \
             *  byte character table.                                      \
             */                                                            \
            *pWCStr = (pHashN->pDBCSOffsets + Offset)[*(pMBStr + 1)];      \
            mbIncr = 2;                                                    \
                                                                           \
            /*                                                             \
             *  Make sure an invalid character was not translated to       \
             *  the default char.  Translate to 0xffff if invalid.         \
             */                                                            \
            CHECK_ERROR_WC_MULTI_SPECIAL( pHashN,                          \
                                          pWCStr,                          \
                                          *pMBStr,                         \
                                          *(pMBStr + 1) );                 \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Not DBCS Lead Byte.  Fill in the wide character translation    \
         *  from the single byte character table.                          \
         *  Make sure an invalid character was not translated to           \
         *  the default char.  Return an error if invalid.                 \
         */                                                                \
        GET_WC_SINGLE_SPECIAL( pHashN,                                     \
                               pMBTbl,                                     \
                               pMBStr,                                     \
                               pWCStr );                                   \
        mbIncr = 1;                                                        \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  COPY_MB_CHAR
//
//  Copies a multibyte character to the given string buffer.  If the
//  high byte of the multibyte word is zero, then it is a single byte
//  character and the number of characters written (returned) is 1.
//  Otherwise, it is a double byte character and the number of characters
//  written (returned) is 2.
//
//  NumByte will be 0 if the buffer is too small for the translation.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define COPY_MB_CHAR( mbChar,                                              \
                      pMBStr,                                              \
                      NumByte,                                             \
                      fOnlyOne )                                           \
{                                                                          \
    if (HIBYTE(mbChar))                                                    \
    {                                                                      \
        /*                                                                 \
         *  Make sure there is enough room in the buffer for both bytes.   \
         */                                                                \
        if (fOnlyOne)                                                      \
        {                                                                  \
            NumByte = 0;                                                   \
        }                                                                  \
        else                                                               \
        {                                                                  \
            /*                                                             \
             *  High Byte is NOT zero, so it's a DOUBLE byte char.         \
             *  Return 2 characters written.                               \
             */                                                            \
            *pMBStr = HIBYTE(mbChar);                                      \
            *(pMBStr + 1) = LOBYTE(mbChar);                                \
            NumByte = 2;                                                   \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  High Byte IS zero, so it's a SINGLE byte char.                 \
         *  Return 1 character written.                                    \
         */                                                                \
        *pMBStr = LOBYTE(mbChar);                                          \
        NumByte = 1;                                                       \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_SB
//
//  Fills in pMBStr with the single byte character for the corresponding
//  wide character from the appropriate translation table.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_SB( pWC,                                                       \
                wChar,                                                     \
                pMBStr )                                                   \
{                                                                          \
    *pMBStr = ((BYTE *)(pWC))[wChar];                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_MB
//
//  Fills in pMBStr with the multi byte character for the corresponding
//  wide character from the appropriate translation table.
//
//  mbCount will be 0 if the buffer is too small for the translation.
//
//    Broken Down Version:
//    --------------------
//        mbChar = ((WORD *)(pHashN->pWC))[wChar];
//        COPY_MB_CHAR(mbChar, pMBStr, mbCount);
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_MB( pWC,                                                       \
                wChar,                                                     \
                pMBStr,                                                    \
                mbCount,                                                   \
                fOnlyOne )                                                 \
{                                                                          \
    COPY_MB_CHAR( ((WORD *)(pWC))[wChar],                                  \
                  pMBStr,                                                  \
                  mbCount,                                                 \
                  fOnlyOne );                                              \
}


////////////////////////////////////////////////////////////////////////////
//
//  ELIMINATE_BEST_FIT_SB
//
//  Checks to see if a single byte Best Fit character was used.  If so,
//  it replaces it with a single byte default character.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define ELIMINATE_BEST_FIT_SB( pHashN,                                     \
                               wChar,                                      \
                               pMBStr )                                    \
{                                                                          \
    if ((pHashN->pMBTbl)[*pMBStr] != wChar)                                \
    {                                                                      \
        *pMBStr = LOBYTE(pHashN->pCPInfo->wDefaultChar);                   \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  ELIMINATE_BEST_FIT_MB
//
//  Checks to see if a multi byte Best Fit character was used.  If so,
//  it replaces it with a multi byte default character.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define ELIMINATE_BEST_FIT_MB( pHashN,                                     \
                               wChar,                                      \
                               pMBStr,                                     \
                               mbCount,                                    \
                               fOnlyOne )                                  \
{                                                                          \
    WORD Offset;                                                           \
    WORD wDefault;                                                         \
                                                                           \
    if (((mbCount == 1) && ((pHashN->pMBTbl)[*pMBStr] != wChar)) ||        \
        ((mbCount == 2) &&                                                 \
         (Offset = CHECK_DBCS_LEAD_BYTE(pHashN->pDBCSOffsets, *pMBStr)) && \
         (((pHashN->pDBCSOffsets + Offset)[*(pMBStr + 1)]) != wChar)))     \
    {                                                                      \
        wDefault = pHashN->pCPInfo->wDefaultChar;                          \
        if (HIBYTE(wDefault))                                              \
        {                                                                  \
            if (fOnlyOne)                                                  \
            {                                                              \
                mbCount = 0;                                               \
            }                                                              \
            else                                                           \
            {                                                              \
                *pMBStr = HIBYTE(wDefault);                                \
                *(pMBStr + 1) = LOBYTE(wDefault);                          \
                mbCount = 2;                                               \
            }                                                              \
        }                                                                  \
        else                                                               \
        {                                                                  \
            *pMBStr = LOBYTE(wDefault);                                    \
            mbCount = 1;                                                   \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_DEFAULT_WORD
//
//  Takes a pointer to a character string (either one or two characters),
//  and converts it to a WORD value.  If the character is not DBCS, then it
//  zero extends the high byte.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_DEFAULT_WORD(pOff, pDefault)                                   \
    (CHECK_DBCS_LEAD_BYTE(pOff, *pDefault)                                 \
         ? MAKEWORD(*(pDefault + 1), *pDefault)                            \
         : MAKEWORD(*pDefault, 0))


////////////////////////////////////////////////////////////////////////////
//
//  DEFAULT_CHAR_CHECK_SB
//
//  Checks to see if the default character is used.  If it is, it sets
//  pUsedDef to TRUE (if non-null).  If the user specified a default, then
//  the user's default character is used.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define DEFAULT_CHAR_CHECK_SB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               wDefChar,                                   \
                               pUsedDef )                                  \
{                                                                          \
    WORD wSysDefChar = pHashN->pCPInfo->wDefaultChar;                      \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Check for default character being used.                            \
     */                                                                    \
    if ((*pMBStr == (BYTE)wSysDefChar) &&                                  \
        (wch != pHashN->pCPInfo->wTransDefaultChar))                       \
    {                                                                      \
        /*                                                                 \
         *  Default was used.  Set the pUsedDef parameter to TRUE.         \
         */                                                                \
        *pUsedDef = TRUE;                                                  \
                                                                           \
        /*                                                                 \
         *  If the user specified a different default character than       \
         *  the system default, use that character instead.                \
         */                                                                \
        if (wSysDefChar != wDefChar)                                       \
        {                                                                  \
            *pMBStr = LOBYTE(wDefChar);                                    \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  DEFAULT_CHAR_CHECK_MB
//
//  Checks to see if the default character is used.  If it is, it sets
//  pUsedDef to TRUE (if non-null).  If the user specified a default, then
//  the user's default character is used.  The number of bytes written to
//  the buffer is returned.
//
//  NumByte will be -1 if the buffer is too small for the translation.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define DEFAULT_CHAR_CHECK_MB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               wDefChar,                                   \
                               pUsedDef,                                   \
                               NumByte,                                    \
                               fOnlyOne )                                  \
{                                                                          \
    WORD wSysDefChar = pHashN->pCPInfo->wDefaultChar;                      \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Set NumByte to zero for return (zero bytes written).               \
     */                                                                    \
    NumByte = 0;                                                           \
                                                                           \
    /*                                                                     \
     *  Check for default character being used.                            \
     */                                                                    \
    if ((*pMBStr == (BYTE)wSysDefChar) &&                                  \
        (wch != pHashN->pCPInfo->wTransDefaultChar))                       \
    {                                                                      \
        /*                                                                 \
         *  Default was used.  Set the pUsedDef parameter to TRUE.         \
         */                                                                \
        *pUsedDef = TRUE;                                                  \
                                                                           \
        /*                                                                 \
         *  If the user specified a different default character than       \
         *  the system default, use that character instead.                \
         */                                                                \
        if (wSysDefChar != wDefChar)                                       \
        {                                                                  \
            COPY_MB_CHAR( wDefChar,                                        \
                          pMBStr,                                          \
                          NumByte,                                         \
                          fOnlyOne );                                      \
            if (NumByte == 0)                                              \
            {                                                              \
                NumByte = -1;                                              \
            }                                                              \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_TRANSLATION_SB
//
//  Gets the 1:1 translation of a given wide character.  It fills in the
//  string pointer with the single byte character.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_TRANSLATION_SB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               wDefault,                                   \
                               pUsedDef,                                   \
                               dwFlags )                                   \
{                                                                          \
    GET_SB( pHashN->pWC,                                                   \
            wch,                                                           \
            pMBStr );                                                      \
    if (dwFlags & WC_NO_BEST_FIT_CHARS)                                    \
    {                                                                      \
        ELIMINATE_BEST_FIT_SB( pHashN,                                     \
                               wch,                                        \
                               pMBStr );                                   \
    }                                                                      \
    DEFAULT_CHAR_CHECK_SB( pHashN,                                         \
                           wch,                                            \
                           pMBStr,                                         \
                           wDefault,                                       \
                           pUsedDef );                                     \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_TRANSLATION_MB
//
//  Gets the 1:1 translation of a given wide character.  It fills in the
//  appropriate number of characters for the multibyte character and then
//  returns the number of characters written to the multibyte string.
//
//  mbCnt will be 0 if the buffer is too small for the translation.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_TRANSLATION_MB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               wDefault,                                   \
                               pUsedDef,                                   \
                               mbCnt,                                      \
                               fOnlyOne,                                   \
                               dwFlags )                                   \
{                                                                          \
    int mbCnt2;              /* number of characters written */            \
                                                                           \
                                                                           \
    GET_MB( pHashN->pWC,                                                   \
            wch,                                                           \
            pMBStr,                                                        \
            mbCnt,                                                         \
            fOnlyOne );                                                    \
    if (dwFlags & WC_NO_BEST_FIT_CHARS)                                    \
    {                                                                      \
        ELIMINATE_BEST_FIT_MB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               mbCnt,                                      \
                               fOnlyOne );                                 \
    }                                                                      \
    if (mbCnt)                                                             \
    {                                                                      \
        DEFAULT_CHAR_CHECK_MB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               wDefault,                                   \
                               pUsedDef,                                   \
                               mbCnt2,                                     \
                               fOnlyOne );                                 \
        if (mbCnt2 == -1)                                                  \
        {                                                                  \
            mbCnt = 0;                                                     \
        }                                                                  \
        else if (mbCnt2)                                                   \
        {                                                                  \
            mbCnt = mbCnt2;                                                \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_CP_HASH_NODE
//
//  Sets the code page value (if a special value is passed in) and the
//  hash node pointer.  If the code page value is invalid, the pointer
//  to the hash node will be set to NULL.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_CP_HASH_NODE( CodePage,                                        \
                          pHashN )                                         \
{                                                                          \
    PLOC_HASH pHashLoc;                                                    \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Check for the ACP, OEMCP, or MACCP.  Fill in the appropriate       \
     *  value for the code page if one of these values is given.           \
     *  Otherwise, just get the hash node for the given code page.         \
     */                                                                    \
    if (CodePage == gAnsiCodePage)                                         \
    {                                                                      \
        pHashN = gpACPHashN;                                               \
    }                                                                      \
    else if (CodePage == gOemCodePage)                                     \
    {                                                                      \
        pHashN = gpOEMCPHashN;                                             \
    }                                                                      \
    else if (CodePage == CP_ACP)                                           \
    {                                                                      \
        CodePage = gAnsiCodePage;                                          \
        pHashN = gpACPHashN;                                               \
    }                                                                      \
    else if (CodePage == CP_OEMCP)                                         \
    {                                                                      \
        CodePage = gOemCodePage;                                           \
        pHashN = gpOEMCPHashN;                                             \
    }                                                                      \
    else if (CodePage == CP_SYMBOL)                                        \
    {                                                                      \
        pHashN = NULL;                                                     \
    }                                                                      \
    else if (CodePage == CP_MACCP)                                         \
    {                                                                      \
        CodePage = GetMacCodePage();                                       \
        pHashN = gpMACCPHashN;                                             \
    }                                                                      \
    else if (CodePage == CP_THREAD_ACP)                                    \
    {                                                                      \
        VALIDATE_LOCALE(NtCurrentTeb()->CurrentLocale, pHashLoc, FALSE);   \
        if (pHashLoc != NULL)                                              \
        {                                                                  \
            CodePage = pHashLoc->pLocaleFixed->DefaultACP;                 \
        }                                                                  \
        if (CodePage == CP_ACP)                                            \
        {                                                                  \
            CodePage = gAnsiCodePage;                                      \
            pHashN = gpACPHashN;                                           \
        }                                                                  \
        else if (CodePage == CP_OEMCP)                                     \
        {                                                                  \
            CodePage = gOemCodePage;                                       \
            pHashN = gpOEMCPHashN;                                         \
        }                                                                  \
        else if (CodePage == CP_MACCP)                                     \
        {                                                                  \
            CodePage = GetMacCodePage();                                   \
            pHashN = gpMACCPHashN;                                         \
        }                                                                  \
        else                                                               \
        {                                                                  \
            pHashN = GetCPHashNode(CodePage);                              \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        pHashN = GetCPHashNode(CodePage);                                  \
    }                                                                      \
}




//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  IsValidCodePage
//
//  Checks that the given code page is a valid one.  It does so by querying
//  the registry.  If the code page is found, then TRUE is returned.
//  Otherwise, FALSE is returned.
//
//  05-31-1991  JulieB      Created.
//  05-31-2002  ShawnSte    Make it not force the loading of the code page 
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsValidCodePage(
    UINT CodePage)
{
    WCHAR wszFileName[MAX_SMALL_BUF_LEN];    // file name (Actually l2 chars is max: c_nlsXXXXX.nls\0
    WCHAR wszFilePath[MAX_PATH_LEN];         // ptr to full path

    //
    //  Do not allow special code page values to be valid here.
    //     (CP_ACP, CP_OEMCP, CP_MACCP, CP_THREAD_ACP, CP_SYMBOL are invalid)
    //

    //
    //  Do the quick check for the code page value equal to either
    //  the Ansi code page value or the OEM code page value.
    //
    if ((CodePage == gAnsiCodePage) || (CodePage == gOemCodePage) ||
        (CodePage == CP_UTF7) || (CodePage == CP_UTF8))
    {
        //
        //  Return success.
        //
        return (TRUE);
    }

    //
    //  Check for other code page values.
    //

    // If a node already exists, then we're OK
    if (IsCPHashNodeLoaded(CodePage) == TRUE)
    {
        //
        //  Return success.
        //
        return (TRUE);    
    }
    
    //
    //  Hash node doesn't exist.  Have to look in the registry.
    //  True if this works, false if it doesn't
    //

    if (FALSE == GetCPFileNameFromRegistry(CodePage, wszFileName, MAX_SMALL_BUF_LEN))
    {
        return FALSE;
    }

    // Guess we need a full path
    if((0 == GetSystemDirectoryW(wszFilePath, MAX_PATH_LEN)) ||
        FAILED(StringCchCatW(wszFilePath, MAX_PATH_LEN, L"\\")) ||
        FAILED(StringCchCatW(wszFilePath, MAX_PATH_LEN, wszFileName)))
    {
        // Best we can do.
        return FALSE;
    }

    if (INVALID_FILE_ATTRIBUTES == GetFileAttributesW(wszFilePath))
    {
        return FALSE;
    }
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetACP
//
//  Returns the ANSI code page for the system.  If the registry value is
//  not readable, then the chosen default ACP is used (NLS_DEFAULT_ACP).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

UINT WINAPI GetACP()
{
    //
    //  Return the ACP stored in the cache.
    //
    return (gAnsiCodePage);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetCPGlobal
//
//  Sets the code page global, used by Setup to force the code page into
//  the correct value during GUI mode.
//
//  02-15-99    JimSchm   Created.
////////////////////////////////////////////////////////////////////////////

UINT
WINAPI
SetCPGlobal (
    IN      UINT NewAcp
    )
{
    UINT oldVal;


    oldVal = gAnsiCodePage;

    //
    //  Sets the ACP global.  This is a private exported routine, not an API.
    //
    gAnsiCodePage = NewAcp;
    return oldVal;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetOEMCP
//
//  Returns the OEM code page for the system.  If the registry value is
//  not readable, then the chosen default ACP is used (NLS_DEFAULT_OEMCP).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

UINT WINAPI GetOEMCP()
{
    //
    //  Return the OEMCP stored in the cache.
    //
    return (gOemCodePage);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCPInfo
//
//  Returns information about a given code page.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    PCP_TABLE pInfo;              // ptr to CP information in file
    WORD wDefChar;                // default character
    BYTE *pLeadBytes;             // ptr to lead byte ranges
    UINT Ctr;                     // loop counter


    //
    //  See if it's a special code page value for UTF translations.
    //
    if (CodePage >= NLS_CP_ALGORITHM_RANGE)
    {
        return (UTFCPInfo(CodePage, lpCPInfo, FALSE));
    }

    //
    //  Get the code page value and the appropriate hash node.
    //
    GET_CP_HASH_NODE(CodePage, pHashN);

    //
    //  Invalid Parameter Check:
    //     - validate code page - get hash node containing translation tables
    //     - lpCPInfo is NULL
    //
    if ( (pHashN == NULL) ||
         ((pHashN->pCPInfo == NULL) && (pHashN->pfnCPProc == NULL)) ||
         (lpCPInfo == NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  See if the given code page is in the DLL range.
    //
    if (pHashN->pfnCPProc)
    {
        //
        //  Call the DLL to get the code page information.
        //
        return ( (*(pHashN->pfnCPProc))( CodePage,
                                         NLS_CP_CPINFO,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         lpCPInfo ) );
    }

    //
    //  Fill in the CPINFO structure with the appropriate information.
    //
    pInfo = pHashN->pCPInfo;

    //
    //  Get the max char size.
    //
    lpCPInfo->MaxCharSize = (UINT)((WORD)pInfo->MaxCharSize);

    //
    //  Get the default character.
    //
    wDefChar = pInfo->wDefaultChar;
    if (HIBYTE(wDefChar))
    {
        (lpCPInfo->DefaultChar)[0] = HIBYTE(wDefChar);
        (lpCPInfo->DefaultChar)[1] = LOBYTE(wDefChar);
    }
    else
    {
        (lpCPInfo->DefaultChar)[0] = LOBYTE(wDefChar);
        (lpCPInfo->DefaultChar)[1] = (BYTE)0;
    }

    //
    //  Get the leadbytes.
    //
    pLeadBytes = pInfo->LeadByte;
    for (Ctr = 0; Ctr < MAX_LEADBYTES; Ctr++)
    {
        (lpCPInfo->LeadByte)[Ctr] = pLeadBytes[Ctr];
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCPInfoExW
//
//  Returns information about a given code page.
//
//  11-15-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetCPInfoExW(
    UINT CodePage,
    DWORD dwFlags,
    LPCPINFOEXW lpCPInfoEx)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    PCP_TABLE pInfo;              // ptr to CP information in file
    WORD wDefChar;                // default character
    BYTE *pLeadBytes;             // ptr to lead byte ranges
    UINT Ctr;                     // loop counter


    //
    //  See if it's a special code page value for UTF translations.
    //
    if (CodePage >= NLS_CP_ALGORITHM_RANGE)
    {
        if (UTFCPInfo(CodePage, (LPCPINFO)lpCPInfoEx, TRUE))
        {
            if (GetStringTableEntry( CodePage,
                                     0,
                                     lpCPInfoEx->CodePageName,
                                     MAX_PATH,
                                     RC_CODE_PAGE_NAME ) != 0)
            {
                return (TRUE);
            }
        }
        return (FALSE);
    }

    //
    //  Get the code page value and the appropriate hash node.
    //
    GET_CP_HASH_NODE(CodePage, pHashN);

    //
    //  Invalid Parameter Check:
    //     - validate code page - get hash node containing translation tables
    //     - lpCPInfoEx is NULL
    //
    if ( (pHashN == NULL) ||
         ((pHashN->pCPInfo == NULL) && (pHashN->pfnCPProc == NULL)) ||
         (lpCPInfoEx == NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Invalid Flags Check:
    //     - flags not 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (FALSE);
    }

    //
    //  See if the given code page is in the DLL range.
    //
    if (pHashN->pfnCPProc)
    {
        //
        //  Call the DLL to get the code page information.
        //
        if (((*(pHashN->pfnCPProc))( CodePage,
                                     NLS_CP_CPINFOEX,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     (LPCPINFO)lpCPInfoEx )) == TRUE)
        {
            return (TRUE);
        }
        else
        {
            //
            //  See if the CPINFO will succeed.  If so, then add the
            //  default CPINFOEX info to the structure.
            //
            if (((*(pHashN->pfnCPProc))( CodePage,
                                         NLS_CP_CPINFO,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         (LPCPINFO)lpCPInfoEx )) == TRUE)
            {
                //
                //  Fill in the Ex version info.
                //
                lpCPInfoEx->UnicodeDefaultChar = L'?';
                lpCPInfoEx->CodePage = CodePage;
                GetStringTableEntry( CodePage,
                                     0,
                                     lpCPInfoEx->CodePageName,
                                     MAX_PATH,
                                     RC_CODE_PAGE_NAME );

                SetLastError(NO_ERROR);
                return (TRUE);
            }

            return (FALSE);
        }
    }

    //
    //  Fill in the CPINFO structure with the appropriate information.
    //
    pInfo = pHashN->pCPInfo;

    //
    //  Get the max char size.
    //
    lpCPInfoEx->MaxCharSize = (UINT)((WORD)pInfo->MaxCharSize);

    //
    //  Get the default character.
    //
    wDefChar = pInfo->wDefaultChar;
    if (HIBYTE(wDefChar))
    {
        (lpCPInfoEx->DefaultChar)[0] = HIBYTE(wDefChar);
        (lpCPInfoEx->DefaultChar)[1] = LOBYTE(wDefChar);
    }
    else
    {
        (lpCPInfoEx->DefaultChar)[0] = LOBYTE(wDefChar);
        (lpCPInfoEx->DefaultChar)[1] = (BYTE)0;
    }

    //
    //  Get the leadbytes.
    //
    pLeadBytes = pInfo->LeadByte;
    for (Ctr = 0; Ctr < MAX_LEADBYTES; Ctr++)
    {
        (lpCPInfoEx->LeadByte)[Ctr] = pLeadBytes[Ctr];
    }

    //
    //  Get the Unicode default character.
    //
    lpCPInfoEx->UnicodeDefaultChar = pInfo->wUniDefaultChar;

    //
    //  Get the code page id.
    //
    lpCPInfoEx->CodePage = CodePage;

    //
    //  Get the code page name.
    //
    if (GetStringTableEntry( CodePage,
                             0,
                             lpCPInfoEx->CodePageName,
                             MAX_PATH,
                             RC_CODE_PAGE_NAME ) == 0)
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsDBCSLeadByte
//
//  Checks to see if a given character is a DBCS lead byte in the ACP.
//  Returns TRUE if it is, FALSE if it is not.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsDBCSLeadByte(
    BYTE TestChar)
{
    //
    //  Get the hash node for the ACP.
    //
    if (gpACPHashN == NULL)
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (FALSE);
    }

    //
    //  See if the given character is a DBCS lead byte.
    //
    if (CHECK_DBCS_LEAD_BYTE(gpACPHashN->pDBCSOffsets, TestChar))
    {
        //
        //  Return success - IS a DBCS lead byte.
        //
        return (TRUE);
    }

    //
    //  Return failure - is NOT a DBCS lead byte.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsDBCSLeadByteEx
//
//  Checks to see if a given character is a DBCS lead byte in the given
//  code page.  Returns TRUE if it is, FALSE if it is not.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsDBCSLeadByteEx(
    UINT CodePage,
    BYTE TestChar)
{
    PCP_HASH pHashN;              // ptr to CP hash node

    //
    //  See if it's a special code page value for UTF translations.
    //
    if (CodePage >= NLS_CP_ALGORITHM_RANGE)
    {
    	if (CodePage != CP_UTF8 && CodePage != CP_UTF7) 
    	{
    		// NOTE: This condition has to be updated if we have more codepages in
    		// the NLS_CP_ALGORITHM_RANGE.
    		SetLastError(ERROR_INVALID_PARAMETER);	
    	}
        //
        //  Return that it's not a DBCS leadbyte.
        //
        return (FALSE);
    }

    //
    //  Get the code page value and the appropriate hash node.
    //
    GET_CP_HASH_NODE(CodePage, pHashN);

    //
    //  Invalid Parameter Check:
    //     - validate code page
    //
    if (pHashN == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }


    //
    //  See if the given character is a DBCS lead byte.
    //
    if (CHECK_DBCS_LEAD_BYTE(pHashN->pDBCSOffsets, TestChar))
    {
        //
        //  Return success - IS a DBCS lead byte.
        //
        return (TRUE);
    }

    //
    //  Return failure - is NOT a DBCS lead byte.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MultiByteToWideChar
//
//  Maps a multibyte character string to its wide character string
//  counterpart.
//
//  05-31-91    JulieB    Created.
//  09-01-93    JulieB    Add support for MB_ERR_INVALID_CHARS flag.
////////////////////////////////////////////////////////////////////////////

int WINAPI MultiByteToWideChar(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    register LPBYTE pMBStr;       // ptr to search through MB string
    register LPWSTR pWCStr;       // ptr to search through WC string
    LPBYTE pEndMBStr;             // ptr to end of MB search string
    LPWSTR pEndWCStr;             // ptr to end of WC string buffer
    int wcIncr;                   // amount to increment pWCStr
    int mbIncr;                   // amount to increment pMBStr
    int wcCount = 0;              // count of wide chars written
    int CompSet;                  // if MB_COMPOSITE flag is set
    PMB_TABLE pMBTbl;             // ptr to correct MB table (MB or GLYPH)
    int ctr;                      // loop counter


    //
    //  See if it's a special code page value for UTF translations.
    //
    if (CodePage >= NLS_CP_ALGORITHM_RANGE)
    {
        return (UTFToUnicode( CodePage,
                              dwFlags,
                              lpMultiByteStr,
                              cbMultiByte,
                              lpWideCharStr,
                              cchWideChar ));
    }

    //
    //  Get the code page value and the appropriate hash node.
    //
    GET_CP_HASH_NODE(CodePage, pHashN);

    //
    //  Invalid Parameter Check:
    //     - length of MB string is 0
    //     - wide char buffer size is negative
    //     - MB string is NULL
    //     - length of WC string is NOT zero AND
    //         (WC string is NULL OR src and dest pointers equal)
    //
    if ( (cbMultiByte == 0) || (cchWideChar < 0) ||
         (lpMultiByteStr == NULL) ||
         ((cchWideChar != 0) &&
          ((lpWideCharStr == NULL) ||
           (lpMultiByteStr == (LPSTR)lpWideCharStr))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  If cbMultiByte is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cbMultiByte <= -1)
    {
        cbMultiByte = strlen(lpMultiByteStr) + 1;
    }

    //
    //  Check for valid code page.
    //
    if (pHashN == NULL)
    {
        //
        //  Special case the CP_SYMBOL code page.
        //
        if ((CodePage == CP_SYMBOL) && (dwFlags == 0))
        {
            //
            //  If the caller just wants the size of the buffer needed
            //  to do this translation, return the size of the MB string.
            //
            if (cchWideChar == 0)
            {
                return (cbMultiByte);
            }

            //
            //  Make sure the buffer is large enough.
            //
            if (cchWideChar < cbMultiByte)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }

            //
            //  Translate SB char xx to Unicode f0xx.
            //    0x00->0x1f map to 0x0000->0x001f
            //    0x20->0xff map to 0xf020->0xf0ff
            //
            for (ctr = 0; ctr < cbMultiByte; ctr++)
            {
                lpWideCharStr[ctr] = ((BYTE)(lpMultiByteStr[ctr]) < 0x20)
                                       ? (WCHAR)lpMultiByteStr[ctr]
                                       : MAKEWORD(lpMultiByteStr[ctr], 0xf0);
            }
            return (cbMultiByte);
        }
        else
        {
            SetLastError(((CodePage == CP_SYMBOL) && (dwFlags != 0))
                           ? ERROR_INVALID_FLAGS
                           : ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    //
    //  See if the given code page is in the DLL range.
    //
    if (pHashN->pfnCPProc)
    {
        //
        //  Invalid Flags Check:
        //     - flags not 0
        //
        if (dwFlags != 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }

        //
        //  Call the DLL to do the translation.
        //
        return ( (*(pHashN->pfnCPProc))( CodePage,
                                         NLS_CP_MBTOWC,
                                         (LPSTR)lpMultiByteStr,
                                         cbMultiByte,
                                         (LPWSTR)lpWideCharStr,
                                         cchWideChar,
                                         NULL ) );
    }

    //
    //  Invalid Flags Check:
    //     - flags other than valid ones
    //     - composite and precomposed both set
    //
    if ( (dwFlags & MB_INVALID_FLAG) ||
         ((dwFlags & MB_PRECOMPOSED) && (dwFlags & MB_COMPOSITE)) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  Initialize multibyte character loop pointers.
    //
    pMBStr = (LPBYTE)lpMultiByteStr;
    pEndMBStr = pMBStr + cbMultiByte;
    CompSet = dwFlags & MB_COMPOSITE;

    //
    //  Get the correct MB table (MB or GLYPH).
    //
    if ((dwFlags & MB_USEGLYPHCHARS) && (pHashN->pGlyphTbl != NULL))
    {
        pMBTbl = pHashN->pGlyphTbl;
    }
    else
    {
        pMBTbl = pHashN->pMBTbl;
    }

    //
    //  If cchWideChar is 0, then we can't use lpWideCharStr.  In this
    //  case, we simply want to count the number of characters that would
    //  be written to the buffer.
    //
    if (cchWideChar == 0)
    {
        WCHAR pTempStr[MAX_COMPOSITE];   // tmp buffer - max for composite

        //
        //  For each multibyte char, translate it to its corresponding
        //  wide char and increment the wide character count.
        //
        pEndWCStr = pTempStr + MAX_COMPOSITE;
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            if (CompSet)
            {
                //
                //  Composite flag is set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        if (!(wcIncr = GetWCCompSBErr( pHashN,
                                                       pMBTbl,
                                                       pMBStr,
                                                       pTempStr,
                                                       pEndWCStr )))
                        {
                            return (0);
                        }
                        pMBStr++;
                        wcCount += wcIncr;
                    }
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        wcCount += GetWCCompSB( pMBTbl,
                                                pMBStr,
                                                pTempStr,
                                                pEndWCStr );
                        pMBStr++;
                    }
                }
            }
            else
            {
                //
                //  Composite flag is NOT set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    wcCount = (int)(pEndMBStr - pMBStr);
                    while (pMBStr < pEndMBStr)
                    {
                        GET_WC_SINGLE( pMBTbl,
                                       pMBStr,
                                       pTempStr );
                        CHECK_ERROR_WC_SINGLE( pHashN,
                                               *pTempStr,
                                               *pMBStr );
                        pMBStr++;
                    }
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    //  Just return the size of the MB string, since
                    //  it's a 1:1 translation.
                    //
                    wcCount = (int)(pEndMBStr - pMBStr);
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (CompSet)
            {
                //
                //  Composite flag is set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        if (!(wcIncr = GetWCCompMBErr( pHashN,
                                                       pMBTbl,
                                                       pMBStr,
                                                       pEndMBStr,
                                                       pTempStr,
                                                       pEndWCStr,
                                                       &mbIncr )))
                        {
                            return (0);
                        }
                        pMBStr += mbIncr;
                        wcCount += wcIncr;
                    }
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        wcCount += GetWCCompMB( pHashN,
                                                pMBTbl,
                                                pMBStr,
                                                pEndMBStr,
                                                pTempStr,
                                                pEndWCStr,
                                                &mbIncr );
                        pMBStr += mbIncr;
                    }
                }
            }
            else
            {
                //
                //  Composite flag is NOT set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        GET_WC_MULTI_ERR( pHashN,
                                          pMBTbl,
                                          pMBStr,
                                          pEndMBStr,
                                          pTempStr,
                                          pEndWCStr,
                                          mbIncr );
                        pMBStr += mbIncr;
                        wcCount++;
                    }
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        GET_WC_MULTI( pHashN,
                                      pMBTbl,
                                      pMBStr,
                                      pEndMBStr,
                                      pTempStr,
                                      pEndWCStr,
                                      mbIncr );
                        pMBStr += mbIncr;
                        wcCount++;
                    }
                }
            }
        }
    }
    else
    {
        //
        //  Initialize wide character loop pointers.
        //
        pWCStr = lpWideCharStr;
        pEndWCStr = pWCStr + cchWideChar;

        //
        //  For each multibyte char, translate it to its corresponding
        //  wide char, store it in lpWideCharStr, and increment the wide
        //  character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            if (CompSet)
            {
                //
                //  Composite flag is set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        if (!(wcIncr = GetWCCompSBErr( pHashN,
                                                       pMBTbl,
                                                       pMBStr,
                                                       pWCStr,
                                                       pEndWCStr )))
                        {
                            return (0);
                        }
                        pMBStr++;
                        pWCStr += wcIncr;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        pWCStr += GetWCCompSB( pMBTbl,
                                               pMBStr,
                                               pWCStr,
                                               pEndWCStr );
                        pMBStr++;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
            }
            else
            {
                //
                //  Composite flag is NOT set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    wcCount = (int)(pEndMBStr - pMBStr);
                    if ((pEndWCStr - pWCStr) < wcCount)
                    {
                        wcCount = (int)(pEndWCStr - pWCStr);
                    }
                    for (ctr = wcCount; ctr > 0; ctr--)
                    {
                        GET_WC_SINGLE( pMBTbl,
                                       pMBStr,
                                       pWCStr );
                        CHECK_ERROR_WC_SINGLE( pHashN,
                                               *pWCStr,
                                               *pMBStr );
                        pMBStr++;
                        pWCStr++;
                    }
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    wcCount = (int)(pEndMBStr - pMBStr);
                    if ((pEndWCStr - pWCStr) < wcCount)
                    {
                        wcCount = (int)(pEndWCStr - pWCStr);
                    }
                    for (ctr = wcCount; ctr > 0; ctr--)
                    {
                        GET_WC_SINGLE( pMBTbl,
                                       pMBStr,
                                       pWCStr );
                        pMBStr++;
                        pWCStr++;
                    }
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (CompSet)
            {
                //
                //  Composite flag is set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        if (!(wcIncr = GetWCCompMBErr( pHashN,
                                                       pMBTbl,
                                                       pMBStr,
                                                       pEndMBStr,
                                                       pWCStr,
                                                       pEndWCStr,
                                                       &mbIncr )))
                        {
                            return (0);
                        }
                        pMBStr += mbIncr;
                        pWCStr += wcIncr;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        pWCStr += GetWCCompMB( pHashN,
                                               pMBTbl,
                                               pMBStr,
                                               pEndMBStr,
                                               pWCStr,
                                               pEndWCStr,
                                               &mbIncr );
                        pMBStr += mbIncr;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
            }
            else
            {
                //
                //  Composite flag is NOT set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        GET_WC_MULTI_ERR( pHashN,
                                          pMBTbl,
                                          pMBStr,
                                          pEndMBStr,
                                          pWCStr,
                                          pEndWCStr,
                                          mbIncr );
                        pMBStr += mbIncr;
                        pWCStr++;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        GET_WC_MULTI( pHashN,
                                      pMBTbl,
                                      pMBStr,
                                      pEndMBStr,
                                      pWCStr,
                                      pEndWCStr,
                                      mbIncr );
                        pMBStr += mbIncr;
                        pWCStr++;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
            }
        }

        //
        //  Make sure wide character buffer was large enough.
        //
        if (pMBStr < pEndMBStr)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of characters written (or that would have
    //  been written) to the buffer.
    //
    return (wcCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  WideCharToMultiByte
//
//  Maps a wide character string to its multibyte character string
//  counterpart.
//
//  NOTE:  Most significant bit of dwFlags parameter is used by this routine
//         to indicate that the caller only wants the count of the number of
//         characters written, not the string (ie. do not back up in buffer).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI WideCharToMultiByte(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cbMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    LPWSTR pWCStr;                // ptr to search through WC string
    LPWSTR pEndWCStr;             // ptr to end of WC string buffer
    WORD wDefault = 0;            // default character as a word
    int IfNoDefault;              // if default check is to be made
    int IfCompositeChk;           // if check for composite
    BOOL TmpUsed;                 // temp storage for default used
    int ctr;                      // loop counter


    //
    //  See if it's a special code page value for UTF translations.
    //
    if (CodePage >= NLS_CP_ALGORITHM_RANGE)
    {
        return (UnicodeToUTF( CodePage,
                              dwFlags,
                              lpWideCharStr,
                              cchWideChar,
                              lpMultiByteStr,
                              cbMultiByte,
                              lpDefaultChar,
                              lpUsedDefaultChar ));
    }

    //
    //  Get the code page value and the appropriate hash node.
    //
    GET_CP_HASH_NODE(CodePage, pHashN);

    //
    //  Invalid Parameter Check:
    //     - length of WC string is 0
    //     - multibyte buffer size is negative
    //     - WC string is NULL
    //     - length of WC string is NOT zero AND
    //         (MB string is NULL OR src and dest pointers equal)
    //
    if ( (cchWideChar == 0) || (cbMultiByte < 0) ||
         (lpWideCharStr == NULL) ||
         ((cbMultiByte != 0) &&
          ((lpMultiByteStr == NULL) ||
           (lpWideCharStr == (LPWSTR)lpMultiByteStr))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  If cchWideChar is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cchWideChar <= -1)
    {
        cchWideChar = NlsStrLenW(lpWideCharStr) + 1;
    }

    //
    //  Check for valid code page.
    //
    if (pHashN == NULL)
    {
        //
        //  Special case the CP_SYMBOL code page.
        //
        if ((CodePage == CP_SYMBOL) && (dwFlags == 0) &&
            (lpDefaultChar == NULL) && (lpUsedDefaultChar == NULL))
        {
            //
            //  If the caller just wants the size of the buffer needed
            //  to do this translation, return the size of the MB string.
            //
            if (cbMultiByte == 0)
            {
                return (cchWideChar);
            }

            //
            //  Make sure the buffer is large enough.
            //
            if (cbMultiByte < cchWideChar)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }

            //
            //  Translate Unicode char f0xx to SB xx.
            //    0x0000->0x001f map to 0x00->0x1f
            //    0xf020->0xf0ff map to 0x20->0xff
            //
            for (ctr = 0; ctr < cchWideChar; ctr++)
            {
                if ((lpWideCharStr[ctr] >= 0x0020) &&
                    ((lpWideCharStr[ctr] < 0xf020) ||
                     (lpWideCharStr[ctr] > 0xf0ff)))
                {
                    SetLastError(ERROR_NO_UNICODE_TRANSLATION);                        \
                    return (0);
                }
                lpMultiByteStr[ctr] = (BYTE)lpWideCharStr[ctr];
            }
            return (cchWideChar);
        }
        else
        {
            SetLastError(((CodePage == CP_SYMBOL) && (dwFlags != 0))
                           ? ERROR_INVALID_FLAGS
                           : ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    //
    //  See if the given code page is in the DLL range.
    //
    if (pHashN->pfnCPProc)
    {
        //
        //  Invalid Parameter Check:
        //     - lpDefaultChar not NULL
        //     - lpUsedDefaultChar not NULL
        //
        if ((lpDefaultChar != NULL) || (lpUsedDefaultChar != NULL))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }

        //
        //  Invalid Flags Check:
        //     - flags not 0
        //
        if (dwFlags != 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }

        //
        //  Call the DLL to do the translation.
        //
        return ( (*(pHashN->pfnCPProc))( CodePage,
                                         NLS_CP_WCTOMB,
                                         (LPSTR)lpMultiByteStr,
                                         cbMultiByte,
                                         (LPWSTR)lpWideCharStr,
                                         cchWideChar,
                                         NULL ) );
    }

    //
    //  Invalid Flags Check:
    //     - compositechk flag is not set AND any of comp flags are set
    //     - flags other than valid ones
    //
    if ( ((!(IfCompositeChk = (dwFlags & WC_COMPOSITECHECK))) &&
          (dwFlags & WC_COMPCHK_FLAGS)) ||
         (dwFlags & WC_INVALID_FLAG) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  Initialize wide character loop pointers.
    //
    pWCStr = (LPWSTR)lpWideCharStr;
    pEndWCStr = pWCStr + cchWideChar;

    //
    //  Set the IfNoDefault parameter to TRUE if both lpDefaultChar and
    //  lpUsedDefaultChar are NULL.
    //
    IfNoDefault = ((lpDefaultChar == NULL) && (lpUsedDefaultChar == NULL));

    //
    //  If the composite check flag is NOT set AND both of the default
    //  parameters (lpDefaultChar and lpUsedDefaultChar) are null, then
    //  do the quick translation.
    //
    if (IfNoDefault && !IfCompositeChk)
    {
        //
        //  Translate WC string to MB string, ignoring default chars.
        //
        return (GetMBNoDefault( pHashN,
                                pWCStr,
                                pEndWCStr,
                                (LPBYTE)lpMultiByteStr,
                                cbMultiByte,
                                dwFlags ));
    }

    //
    //  Set the system default character.
    //
    wDefault = pHashN->pCPInfo->wDefaultChar;

    //
    //  See if the default check is needed.
    //
    if (!IfNoDefault)
    {
        //
        //  If lpDefaultChar is NULL, then use the system default.
        //  Form a word out of the default character.  Single byte
        //  characters are zero extended, DBCS characters are as is.
        //
        if (lpDefaultChar != NULL)
        {
            wDefault = GET_DEFAULT_WORD( pHashN->pDBCSOffsets,
                                         (LPBYTE)lpDefaultChar );
        }

        //
        //  If lpUsedDefaultChar is NULL, then it won't be used later
        //  on if a default character is detected.  Otherwise, we need
        //  to initialize it.
        //
        if (lpUsedDefaultChar == NULL)
        {
            lpUsedDefaultChar = &TmpUsed;
        }
        *lpUsedDefaultChar = FALSE;

        //
        //  Check for "composite check" flag.
        //
        if (!IfCompositeChk)
        {
            //
            //  Translate WC string to MB string, checking for the use of the
            //  default character.
            //
            return (GetMBDefault( pHashN,
                                  pWCStr,
                                  pEndWCStr,
                                  (LPBYTE)lpMultiByteStr,
                                  cbMultiByte,
                                  wDefault,
                                  lpUsedDefaultChar,
                                  dwFlags ));
        }
        else
        {
            //
            //  Translate WC string to MB string, checking for the use of the
            //  default character.
            //
            return (GetMBDefaultComp( pHashN,
                                      pWCStr,
                                      pEndWCStr,
                                      (LPBYTE)lpMultiByteStr,
                                      cbMultiByte,
                                      wDefault,
                                      lpUsedDefaultChar,
                                      dwFlags ));
        }
    }
    else
    {
        //
        //  The only case left here is that the Composite check
        //  flag IS set and the default check flag is NOT set.
        //
        //  Translate WC string to MB string, checking for the use of the
        //  default character.
        //
        return (GetMBDefaultComp( pHashN,
                                  pWCStr,
                                  pEndWCStr,
                                  (LPBYTE)lpMultiByteStr,
                                  cbMultiByte,
                                  wDefault,
                                  &TmpUsed,
                                  dwFlags ));
    }
}




//-------------------------------------------------------------------------//
//                          INTERNAL ROUTINES                              //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetWCCompSB
//
//  Fills in pWCStr with the wide character(s) for the corresponding single
//  byte character from the appropriate translation table and returns the
//  number of wide characters written.  This routine should only be called
//  when the precomposed forms need to be translated to composite.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetWCCompSB(
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr)
{
    //
    //  Get the single byte to wide character translation.
    //
    GET_WC_SINGLE(pMBTbl, pMBStr, pWCStr);

    //
    //  Fill in the composite form of the character (if one exists)
    //  and return the number of wide characters written.
    //
    return (InsertCompositeForm(pWCStr, pEndWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetWCCompMB
//
//  Fills in pWCStr with the wide character(s) for the corresponding multibyte
//  character from the appropriate translation table and returns the number
//  of wide characters written.  The number of bytes used from the pMBStr
//  buffer (single byte or double byte) is returned in the mbIncr parameter.
//  This routine should only be called when the precomposed forms need to be
//  translated to composite.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetWCCompMB(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPBYTE pEndMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    int *pmbIncr)
{
    //
    //  Get the multibyte to wide char translation.
    //
    GET_WC_MULTI( pHashN,
                  pMBTbl,
                  pMBStr,
                  pEndMBStr,
                  pWCStr,
                  pEndWCStr,
                  *pmbIncr );

    //
    //  Fill in the composite form of the character (if one exists)
    //  and return the number of wide characters written.
    //
    return (InsertCompositeForm(pWCStr, pEndWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetWCCompSBErr
//
//  Fills in pWCStr with the wide character(s) for the corresponding single
//  byte character from the appropriate translation table and returns the
//  number of wide characters written.  This routine should only be called
//  when the precomposed forms need to be translated to composite.
//
//  Checks to be sure an invalid character is not translated to the default
//  character.  If so, it sets last error and returns 0 characters written.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetWCCompSBErr(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr)
{
    //
    //  Get the single byte to wide character translation.
    //
    GET_WC_SINGLE(pMBTbl, pMBStr, pWCStr);

    //
    //  Make sure an invalid character was not translated to the
    //  default char.  If it was, set last error and return 0
    //  characters written.
    //
    CHECK_ERROR_WC_SINGLE(pHashN, *pWCStr, *pMBStr);

    //
    //  Fill in the composite form of the character (if one exists)
    //  and return the number of wide characters written.
    //
    return (InsertCompositeForm(pWCStr, pEndWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetWCCompMBErr
//
//  Fills in pWCStr with the wide character(s) for the corresponding multibyte
//  character from the appropriate translation table and returns the number
//  of wide characters written.  The number of bytes used from the pMBStr
//  buffer (single byte or double byte) is returned in the mbIncr parameter.
//  This routine should only be called when the precomposed forms need to be
//  translated to composite.
//
//  Checks to be sure an invalid character is not translated to the default
//  character.  If so, it sets last error and returns 0 characters written.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetWCCompMBErr(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPBYTE pEndMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    int *pmbIncr)
{
    //
    //  Get the multibyte to wide char translation.
    //
    //  Make sure an invalid character was not translated to the
    //  default char.  If it was, set last error and return 0
    //  characters written.
    //
    GET_WC_MULTI_ERR( pHashN,
                      pMBTbl,
                      pMBStr,
                      pEndMBStr,
                      pWCStr,
                      pEndWCStr,
                      *pmbIncr );

    //
    //  Fill in the composite form of the character (if one exists)
    //  and return the number of wide characters written.
    //
    return (InsertCompositeForm(pWCStr, pEndWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMBNoDefault
//
//  Translates the wide character string to a multibyte string and returns
//  the number of bytes written.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetMBNoDefault(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    DWORD dwFlags)
{
    int mbIncr;                   // amount to increment pMBStr
    int mbCount = 0;              // count of multibyte chars written
    LPBYTE pEndMBStr;             // ptr to end of MB string buffer
    PWC_TABLE pWC = pHashN->pWC;  // ptr to WC table
    int ctr;                      // loop counter


    //
    //  If cbMultiByte is 0, then we can't use pMBStr.  In this
    //  case, we simply want to count the number of characters that
    //  would be written to the buffer.
    //
    if (cbMultiByte == 0)
    {
        BYTE pTempStr[2];             // tmp buffer - 2 bytes for DBCS

        //
        //  For each wide char, translate it to its corresponding multibyte
        //  char and increment the multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            //  Just return the count of characters - it will be the
            //  same number of characters as the source string.
            //
            mbCount = (int)(pEndWCStr - pWCStr);
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pTempStr,
                            mbIncr,
                            FALSE );
                    ELIMINATE_BEST_FIT_MB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           mbIncr,
                                           FALSE );
                    pWCStr++;
                    mbCount += mbIncr;
                }
            }
            else
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pTempStr,
                            mbIncr,
                            FALSE );
                    pWCStr++;
                    mbCount += mbIncr;
                }
            }
        }
    }
    else
    {
        //
        //  Initialize multibyte loop pointers.
        //
        pEndMBStr = pMBStr + cbMultiByte;

        //
        //  For each wide char, translate it to its corresponding
        //  multibyte char, store it in pMBStr, and increment the
        //  multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            mbCount = (int)(pEndWCStr - pWCStr);
            if ((pEndMBStr - pMBStr) < mbCount)
            {
                mbCount = (int)(pEndMBStr - pMBStr);
            }
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                for (ctr = mbCount; ctr > 0; ctr--)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pMBStr );
                    ELIMINATE_BEST_FIT_SB( pHashN,
                                           *pWCStr,
                                           pMBStr );
                    pWCStr++;
                    pMBStr++;
                }
            }
            else
            {
                for (ctr = mbCount; ctr > 0; ctr--)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pMBStr );
                    pWCStr++;
                    pMBStr++;
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pMBStr,
                            mbIncr,
                            ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    ELIMINATE_BEST_FIT_MB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           mbIncr,
                                           ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    if (mbIncr == 0)
                    {
                        //
                        //  Not enough space in buffer.
                        //
                        break;
                    }

                    pWCStr++;
                    mbCount += mbIncr;
                    pMBStr += mbIncr;
                }
            }
            else
            {
                while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pMBStr,
                            mbIncr,
                            ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    if (mbIncr == 0)
                    {
                        //
                        //  Not enough space in buffer.
                        //
                        break;
                    }

                    pWCStr++;
                    mbCount += mbIncr;
                    pMBStr += mbIncr;
                }
            }
        }

        //
        //  Make sure multibyte character buffer was large enough.
        //
        if (pWCStr < pEndWCStr)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of characters written (or that would have
    //  been written) to the buffer.
    //
    return (mbCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMBDefault
//
//  Translates the wide character string to a multibyte string and returns
//  the number of bytes written.  This also checks for the use of the default
//  character, so the translation is slower.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetMBDefault(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    WORD wDefault,
    LPBOOL pUsedDef,
    DWORD dwFlags)
{
    int mbIncr;                   // amount to increment pMBStr
    int mbIncr2;                  // amount to increment pMBStr
    int mbCount = 0;              // count of multibyte chars written
    LPBYTE pEndMBStr;             // ptr to end of MB string buffer
    PWC_TABLE pWC = pHashN->pWC;  // ptr to WC table
    int ctr;                      // loop counter


    //
    //  If cbMultiByte is 0, then we can't use pMBStr.  In this
    //  case, we simply want to count the number of characters that
    //  would be written to the buffer.
    //
    if (cbMultiByte == 0)
    {
        BYTE pTempStr[2];             // tmp buffer - 2 bytes for DBCS

        //
        //  For each wide char, translate it to its corresponding multibyte
        //  char and increment the multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            mbCount = (int)(pEndWCStr - pWCStr);
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pTempStr );
                    ELIMINATE_BEST_FIT_SB( pHashN,
                                           *pWCStr,
                                           pTempStr );
                    DEFAULT_CHAR_CHECK_SB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           wDefault,
                                           pUsedDef );
                    pWCStr++;
                }
            }
            else
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pTempStr );
                    DEFAULT_CHAR_CHECK_SB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           wDefault,
                                           pUsedDef );
                    pWCStr++;
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pTempStr,
                            mbIncr,
                            FALSE );
                    ELIMINATE_BEST_FIT_MB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           mbIncr,
                                           FALSE );
                    DEFAULT_CHAR_CHECK_MB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           wDefault,
                                           pUsedDef,
                                           mbIncr2,
                                           FALSE );
                    mbCount += (mbIncr2) ? (mbIncr2) : (mbIncr);
                    pWCStr++;
                }
            }
            else
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pTempStr,
                            mbIncr,
                            FALSE );
                    DEFAULT_CHAR_CHECK_MB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           wDefault,
                                           pUsedDef,
                                           mbIncr2,
                                           FALSE );
                    mbCount += (mbIncr2) ? (mbIncr2) : (mbIncr);
                    pWCStr++;
                }
            }
        }
    }
    else
    {
        //
        //  Initialize multibyte loop pointers.
        //
        pEndMBStr = pMBStr + cbMultiByte;

        //
        //  For each wide char, translate it to its corresponding
        //  multibyte char, store it in pMBStr, and increment the
        //  multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            mbCount = (int)(pEndWCStr - pWCStr);
            if ((pEndMBStr - pMBStr) < mbCount)
            {
                mbCount = (int)(pEndMBStr - pMBStr);
            }
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                for (ctr = mbCount; ctr > 0; ctr--)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pMBStr );
                    ELIMINATE_BEST_FIT_SB( pHashN,
                                           *pWCStr,
                                           pMBStr );
                    DEFAULT_CHAR_CHECK_SB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           wDefault,
                                           pUsedDef );
                    pWCStr++;
                    pMBStr++;
                }
            }
            else
            {
                for (ctr = mbCount; ctr > 0; ctr--)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pMBStr );
                    DEFAULT_CHAR_CHECK_SB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           wDefault,
                                           pUsedDef );
                    pWCStr++;
                    pMBStr++;
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pMBStr,
                            mbIncr,
                            ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    ELIMINATE_BEST_FIT_MB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           mbIncr,
                                           ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    DEFAULT_CHAR_CHECK_MB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           wDefault,
                                           pUsedDef,
                                           mbIncr2,
                                           ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    if ((mbIncr == 0) || (mbIncr2 == -1))
                    {
                        //
                        //  Not enough room in buffer.
                        //
                        break;
                    }

                    mbCount += (mbIncr2) ? (mbIncr2) : (mbIncr);
                    pWCStr++;
                    pMBStr += mbIncr;
                }
            }
            else
            {
                while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pMBStr,
                            mbIncr,
                            ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    DEFAULT_CHAR_CHECK_MB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           wDefault,
                                           pUsedDef,
                                           mbIncr2,
                                           ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    if ((mbIncr == 0) || (mbIncr2 == -1))
                    {
                        //
                        //  Not enough room in buffer.
                        //
                        break;
                    }

                    mbCount += (mbIncr2) ? (mbIncr2) : (mbIncr);
                    pWCStr++;
                    pMBStr += mbIncr;
                }
            }
        }

        //
        //  Make sure multibyte character buffer was large enough.
        //
        if (pWCStr < pEndWCStr)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of characters written (or that would have
    //  been written) to the buffer.
    //
    return (mbCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMBDefaultComp
//
//  Translates the wide character string to a multibyte string and returns
//  the number of bytes written.  This also checks for the use of the default
//  character and tries to convert composite forms to precomposed forms, so
//  the translation is a lot slower.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetMBDefaultComp(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    WORD wDefault,
    LPBOOL pUsedDef,
    DWORD dwFlags)
{
    int mbIncr;                   // amount to increment pMBStr
    int mbCount = 0;              // count of multibyte chars written
    LPBYTE pEndMBStr;             // ptr to end of MB string buffer
    BOOL fError;                  // if error during MB conversion


    //
    //  If cbMultiByte is 0, then we can't use pMBStr.  In this
    //  case, we simply want to count the number of characters that
    //  would be written to the buffer.
    //
    if (cbMultiByte == 0)
    {
        BYTE pTempStr[2];             // tmp buffer - 2 bytes for DBCS

        //
        //  Set most significant bit of flags to indicate to the
        //  GetMBComp routine that it's using a temporary storage
        //  area, so don't back up in the buffer.
        //
        SET_MSB(dwFlags);

        //
        //  For each wide char, translate it to its corresponding multibyte
        //  char and increment the multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            while (pWCStr < pEndWCStr)
            {
                //
                //  Get the translation.
                //
                mbCount += GetMBCompSB( pHashN,
                                        dwFlags,
                                        pWCStr,
                                        pTempStr,
                                        mbCount,
                                        wDefault,
                                        pUsedDef );
                pWCStr++;
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            while (pWCStr < pEndWCStr)
            {
                //
                //  Get the translation.
                //
                mbCount += GetMBCompMB( pHashN,
                                        dwFlags,
                                        pWCStr,
                                        pTempStr,
                                        mbCount,
                                        wDefault,
                                        pUsedDef,
                                        &fError,
                                        FALSE );
                pWCStr++;
            }
        }
    }
    else
    {
        //
        //  Initialize multibyte loop pointers.
        //
        pEndMBStr = pMBStr + cbMultiByte;

        //
        //  For each wide char, translate it to its corresponding
        //  multibyte char, store it in pMBStr, and increment the
        //  multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
            {
                //
                //  Get the translation.
                //
                mbIncr = GetMBCompSB( pHashN,
                                      dwFlags,
                                      pWCStr,
                                      pMBStr,
                                      mbCount,
                                      wDefault,
                                      pUsedDef );
                pWCStr++;
                mbCount += mbIncr;
                pMBStr += mbIncr;
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
            {
                //
                //  Get the translation.
                //
                mbIncr = GetMBCompMB( pHashN,
                                      dwFlags,
                                      pWCStr,
                                      pMBStr,
                                      mbCount,
                                      wDefault,
                                      pUsedDef,
                                      &fError,
                                      ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                if (fError)
                {
                    //
                    //  Not enough room in the buffer.
                    //
                    break;
                }

                pWCStr++;
                mbCount += mbIncr;
                pMBStr += mbIncr;
            }
        }

        //
        //  Make sure multibyte character buffer was large enough.
        //
        if (pWCStr < pEndWCStr)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of characters written (or that would have
    //  been written) to the buffer.
    //
    return (mbCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMBCompSB
//
//  Fills in pMBStr with the byte character(s) for the corresponding wide
//  character from the appropriate translation table and returns the number
//  of byte characters written to pMBStr.  This routine is only called if
//  the defaultcheck and compositecheck flags were both set.
//
//  NOTE:  Most significant bit of dwFlags parameter is used by this routine
//         to indicate that the caller only wants the count of the number of
//         characters written, not the string (ie. do not back up in buffer).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetMBCompSB(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPWSTR pWCStr,
    LPBYTE pMBStr,
    int mbCount,
    WORD wDefault,
    LPBOOL pUsedDef)
{
    WCHAR PreComp;                // precomposed wide character


    if ((pTblPtrs->pDefaultSortkey == NULL) ||
        (!IS_NONSPACE_ONLY(pTblPtrs->pDefaultSortkey, *pWCStr)))
    {
        //
        //  Get the 1:1 translation from wide char to single byte.
        //
        GET_WC_TRANSLATION_SB( pHashN,
                               *pWCStr,
                               pMBStr,
                               wDefault,
                               pUsedDef,
                               dwFlags );
        return (1);
    }
    else
    {
        if (mbCount < 1)
        {
            //
            //  Need to handle the nonspace character by itself, since
            //  it is the first character in the string.
            //
            if (dwFlags & WC_DISCARDNS)
            {
                //
                //  Discard the non-spacing char, so just return with
                //  zero chars written.
                //
                return (0);
            }
            else if (dwFlags & WC_DEFAULTCHAR)
            {
                //
                //  Need to replace the nonspace character with the default
                //  character and return the number of characters written
                //  to the multibyte string.
                //
                *pUsedDef = TRUE;
                *pMBStr = LOBYTE(wDefault);
                return (1);
            }
            else                  // WC_SEPCHARS - default
            {
                //
                //  Get the 1:1 translation from wide char to multibyte
                //  of the non-spacing char and return the number of
                //  characters written to the multibyte string.
                //
                GET_WC_TRANSLATION_SB( pHashN,
                                       *pWCStr,
                                       pMBStr,
                                       wDefault,
                                       pUsedDef,
                                       dwFlags );
                return (1);
            }
        }
        else if (PreComp = GetPreComposedChar(*pWCStr, *(pWCStr - 1)))
        {
            //
            //  Back up in the single byte string and write the
            //  precomposed char.
            //
            if (!IS_MSB(dwFlags))
            {
                pMBStr--;
            }

            GET_WC_TRANSLATION_SB( pHashN,
                                   PreComp,
                                   pMBStr,
                                   wDefault,
                                   pUsedDef,
                                   dwFlags );
            return (0);
        }
        else
        {
            if (dwFlags & WC_DISCARDNS)
            {
                //
                //  Discard the non-spacing char, so just return with
                //  zero chars written.
                //
                return (0);
            }
            else if (dwFlags & WC_DEFAULTCHAR)
            {
                //
                //  Need to replace the base character with the default
                //  character.  Since we've already written the base
                //  translation char in the single byte string, we need to
                //  back up in the single byte string and write the default
                //  char.
                //
                if (!IS_MSB(dwFlags))
                {
                    pMBStr--;
                }

                *pUsedDef = TRUE;
                *pMBStr = LOBYTE(wDefault);
                return (0);
            }
            else                  // WC_SEPCHARS - default
            {
                //
                //  Get the 1:1 translation from wide char to multibyte
                //  of the non-spacing char and return the number of
                //  characters written to the multibyte string.
                //
                GET_WC_TRANSLATION_SB( pHashN,
                                       *pWCStr,
                                       pMBStr,
                                       wDefault,
                                       pUsedDef,
                                       dwFlags );
                return (1);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMBCompMB
//
//  Fills in pMBStr with the byte character(s) for the corresponding wide
//  character from the appropriate translation table and returns the number
//  of byte characters written to pMBStr.  This routine is only called if
//  the defaultcheck and compositecheck flags were both set.
//
//  If the buffer was too small, the fError flag will be set to TRUE.
//
//  NOTE:  Most significant bit of dwFlags parameter is used by this routine
//         to indicate that the caller only wants the count of the number of
//         characters written, not the string (ie. do not back up in buffer).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetMBCompMB(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPWSTR pWCStr,
    LPBYTE pMBStr,
    int mbCount,
    WORD wDefault,
    LPBOOL pUsedDef,
    BOOL *fError,
    BOOL fOnlyOne)
{
    WCHAR PreComp;                // precomposed wide character
    BYTE pTmpSp[2];               // temp space - 2 bytes for DBCS
    int nCnt;                     // number of characters written


    *fError = FALSE;
    if ((pTblPtrs->pDefaultSortkey == NULL) ||
        (!IS_NONSPACE_ONLY(pTblPtrs->pDefaultSortkey, *pWCStr)))
    {
        //
        //  Get the 1:1 translation from wide char to multibyte.
        //  This also handles DBCS and returns the number of characters
        //  written to the multibyte string.
        //
        GET_WC_TRANSLATION_MB( pHashN,
                               *pWCStr,
                               pMBStr,
                               wDefault,
                               pUsedDef,
                               nCnt,
                               fOnlyOne,
                               dwFlags );
        if (nCnt == 0)
        {
            *fError = TRUE;
        }
        return (nCnt);
    }
    else
    {
        if (mbCount < 1)
        {
            //
            //  Need to handle the nonspace character by itself, since
            //  it is the first character in the string.
            //
            if (dwFlags & WC_DISCARDNS)
            {
                //
                //  Discard the non-spacing char, so just return with
                //  zero chars written.
                //
                return (0);
            }
            else if (dwFlags & WC_DEFAULTCHAR)
            {
                //
                //  Need to replace the nonspace character with the default
                //  character and return the number of characters written
                //  to the multibyte string.
                //
                *pUsedDef = TRUE;
                COPY_MB_CHAR( wDefault,
                              pMBStr,
                              nCnt,
                              fOnlyOne );
                if (nCnt == 0)
                {
                    *fError = TRUE;
                }
                return (nCnt);
            }
            else                  // WC_SEPCHARS - default
            {
                //
                //  Get the 1:1 translation from wide char to multibyte
                //  of the non-spacing char and return the number of
                //  characters written to the multibyte string.
                //
                GET_WC_TRANSLATION_MB( pHashN,
                                       *pWCStr,
                                       pMBStr,
                                       wDefault,
                                       pUsedDef,
                                       nCnt,
                                       fOnlyOne,
                                       dwFlags );
                if (nCnt == 0)
                {
                    *fError = TRUE;
                }
                return (nCnt);
            }

        }
        else if (PreComp = GetPreComposedChar(*pWCStr, *(pWCStr - 1)))
        {
            //
            //  Get the 1:1 translation from wide char to multibyte
            //  of the precomposed char, back up in the multibyte string,
            //  write the precomposed char, and return the DIFFERENCE of
            //  the number of characters written to the the multibyte
            //  string.
            //
            GET_WC_TRANSLATION_MB( pHashN,
                                   *(pWCStr - 1),
                                   pTmpSp,
                                   wDefault,
                                   pUsedDef,
                                   nCnt,
                                   fOnlyOne,
                                   dwFlags );
            if (nCnt == 0)
            {
                *fError = TRUE;
                return (nCnt);
            }

            if (!IS_MSB(dwFlags))
            {
                pMBStr -= nCnt;
            }

            GET_WC_TRANSLATION_MB( pHashN,
                                   PreComp,
                                   pMBStr,
                                   wDefault,
                                   pUsedDef,
                                   mbCount,
                                   fOnlyOne,
                                   dwFlags );
            if (mbCount == 0)
            {
                *fError = TRUE;
            }
            return (mbCount - nCnt);
        }
        else
        {
            if (dwFlags & WC_DISCARDNS)
            {
                //
                //  Discard the non-spacing char, so just return with
                //  zero chars written.
                //
                return (0);
            }
            else if (dwFlags & WC_DEFAULTCHAR)
            {
                //
                //  Need to replace the base character with the default
                //  character.  Since we've already written the base
                //  translation char in the multibyte string, we need to
                //  back up in the multibyte string and return the
                //  DIFFERENCE of the number of characters written
                //  (could be negative).
                //

                //
                //  If the previous character written is the default
                //  character, then the base character for this nonspace
                //  character has already been replaced.  Simply throw
                //  this character away and return zero chars written.
                //
                if (!IS_MSB(dwFlags))
                {
                    //
                    //  Not using a temporary buffer, so find out if the
                    //  previous character translated was the default char.
                    //
                    if ((MAKEWORD(*(pMBStr - 1), 0) == wDefault) ||
                        ((mbCount > 1) &&
                         (MAKEWORD(*(pMBStr - 1), *(pMBStr - 2)) == wDefault)))
                    {
                        return (0);
                    }
                }
                else
                {
                    //
                    //  Using a temporary buffer.  The temp buffer is 2 bytes
                    //  in length and contains the previous character written.
                    //
                    if ((MAKEWORD(*pMBStr, 0) == wDefault) ||
                        ((mbCount > 1) &&
                         (MAKEWORD(*pMBStr, *(pMBStr + 1)) == wDefault)))
                    {
                        return (0);
                    }
                }

                //
                //  Get the 1:1 translation from wide char to multibyte
                //  of the base char, back up in the multibyte string,
                //  write the default char, and return the DIFFERENCE of
                //  the number of characters written to the the multibyte
                //  string.
                //
                GET_WC_TRANSLATION_MB( pHashN,
                                       *(pWCStr - 1),
                                       pTmpSp,
                                       wDefault,
                                       pUsedDef,
                                       nCnt,
                                       fOnlyOne,
                                       dwFlags );
                if (nCnt == 0)
                {
                    *fError = TRUE;
                    return (nCnt);
                }

                if (!IS_MSB(dwFlags))
                {
                    pMBStr -= nCnt;
                }

                *pUsedDef = TRUE;
                COPY_MB_CHAR( wDefault,
                              pMBStr,
                              mbCount,
                              fOnlyOne );
                if (mbCount == 0)
                {
                    *fError = TRUE;
                }
                return (mbCount - nCnt);
            }
            else                  // WC_SEPCHARS - default
            {
                //
                //  Get the 1:1 translation from wide char to multibyte
                //  of the non-spacing char and return the number of
                //  characters written to the multibyte string.
                //
                GET_WC_TRANSLATION_MB( pHashN,
                                       *pWCStr,
                                       pMBStr,
                                       wDefault,
                                       pUsedDef,
                                       nCnt,
                                       fOnlyOne,
                                       dwFlags );
                if (nCnt == 0)
                {
                    *fError = TRUE;
                }
                return (nCnt);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMacCodePage
//
//  Returns the system default Mac code page.
//
//  09-22-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

UINT GetMacCodePage()
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query information
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    UNICODE_STRING ObUnicodeStr;                 // unicode string
    UINT CodePage;                               // code page value
    PCP_HASH pHashN;                             // ptr to hash node


    //
    //  See if the Mac code page globals have been initialized yet.
    //  If they have, return the mac code page value.
    //
    if (gMacCodePage != 0)
    {
        return (gMacCodePage);
    }

    //
    //  Make sure code page key is open.
    //
    OPEN_CODEPAGE_KEY(NLS_DEFAULT_MACCP);

    //
    //  Query the registry for the Mac CP value.
    //
    CodePage = 0;
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    if ((QueryRegValue( hCodePageKey,
                        NLS_VALUE_MACCP,
                        &pKeyValueFull,
                        MAX_KEY_VALUE_FULLINFO,
                        NULL )) == NO_ERROR)
    {
        //
        //  Convert the value to an integer.
        //
        RtlInitUnicodeString(&ObUnicodeStr, GET_VALUE_DATA_PTR(pKeyValueFull));
        if (RtlUnicodeStringToInteger(&ObUnicodeStr, 10, (PULONG)&CodePage))
        {
            CodePage = 0;
        }
    }

    //
    //  Make sure the CodePage value was set.
    //
    if (CodePage == 0)
    {
        //
        //  Registry value is corrupt, so use default Mac code page.
        //
        CodePage = NLS_DEFAULT_MACCP;
    }

    //
    //  Get the hash node for the Mac code page.
    //
    pHashN = GetCPHashNode(CodePage);

    //
    //  Make sure the Mac hash node is valid.
    //
    if (pHashN == NULL)
    {
        //
        //  Invalid hash node, which means either the registry is
        //  corrupt, or setup failed to install a file.  Use the
        //  Ansi code page values.
        //
        CodePage = gAnsiCodePage;
        pHashN = gpACPHashN;
    }

    //
    //  Set the final MAC CP values.
    //
    RtlEnterCriticalSection(&gcsTblPtrs);

    if (gMacCodePage == 0)
    {
        gpMACCPHashN = pHashN;
        gMacCodePage = CodePage;
    }

    RtlLeaveCriticalSection(&gcsTblPtrs);

    //
    //  Return the Mac code page value.
    //
    return (gMacCodePage);
}


////////////////////////////////////////////////////////////////////////////
//
//  SpecialMBToWC
//
//  Maps a multibyte character string to its wide character string
//  counterpart.
//
//  08-21-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int SpecialMBToWC(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    register LPBYTE pMBStr;       // ptr to search through MB string
    register LPWSTR pWCStr;       // ptr to search through WC string
    LPBYTE pEndMBStr;             // ptr to end of MB search string
    LPWSTR pEndWCStr;             // ptr to end of WC string buffer
    int mbIncr;                   // amount to increment pMBStr
    int wcCount = 0;              // count of wide chars written
    PMB_TABLE pMBTbl;             // ptr to MB table
    int ctr;                      // loop counter


    //
    //  Initialize multibyte character loop pointers.
    //
    pMBStr = (LPBYTE)lpMultiByteStr;
    pEndMBStr = pMBStr + cbMultiByte;

    //
    //  Get the MB table.
    //
    pMBTbl = pHashN->pMBTbl;

    //
    //  If cchWideChar is 0, then we can't use lpWideCharStr.  In this
    //  case, we simply want to count the number of characters that would
    //  be written to the buffer.
    //
    if (cchWideChar == 0)
    {
        //
        //  For each multibyte char, translate it to its corresponding
        //  wide char and increment the wide character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            wcCount = (int)(pEndMBStr - pMBStr);
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            WCHAR pTempStr[MAX_COMPOSITE];   // tmp buffer

            pEndWCStr = pTempStr + MAX_COMPOSITE;
            while (pMBStr < pEndMBStr)
            {
                GET_WC_MULTI( pHashN,
                              pMBTbl,
                              pMBStr,
                              pEndMBStr,
                              pTempStr,
                              pEndWCStr,
                              mbIncr );
                pMBStr += mbIncr;
                wcCount++;
            }
        }
    }
    else
    {
        //
        //  Initialize wide character loop pointers.
        //
        pWCStr = lpWideCharStr;
        pEndWCStr = pWCStr + cchWideChar;

        //
        //  For each multibyte char, translate it to its corresponding
        //  wide char, store it in lpWideCharStr, and increment the wide
        //  character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            wcCount = (int)(pEndMBStr - pMBStr);
            if ((pEndWCStr - pWCStr) < wcCount)
            {
                wcCount = (int)(pEndWCStr - pWCStr);
            }

            if (dwFlags & MB_INVALID_CHAR_CHECK)
            {
                //
                //  Error check flag is set.
                //
                for (ctr = wcCount; ctr > 0; ctr--)
                {
                    GET_WC_SINGLE_SPECIAL( pHashN,
                                           pMBTbl,
                                           pMBStr,
                                           pWCStr );
                    pMBStr++;
                    pWCStr++;
                }
            }
            else
            {
                //
                //  Error check flag is NOT set.
                //
                for (ctr = wcCount; ctr > 0; ctr--)
                {
                    GET_WC_SINGLE( pMBTbl,
                                   pMBStr,
                                   pWCStr );
                    pMBStr++;
                    pWCStr++;
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (dwFlags & MB_INVALID_CHAR_CHECK)
            {
                //
                //  Error check flag is set.
                //
                while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                {
                    GET_WC_MULTI_ERR_SPECIAL( pHashN,
                                              pMBTbl,
                                              pMBStr,
                                              pEndMBStr,
                                              pWCStr,
                                              pEndWCStr,
                                              mbIncr );
                    pMBStr += mbIncr;
                    pWCStr++;
                }
                wcCount = (int)(pWCStr - lpWideCharStr);
            }
            else
            {
                //
                //  Error check flag is NOT set.
                //
                while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                {
                    GET_WC_MULTI( pHashN,
                                  pMBTbl,
                                  pMBStr,
                                  pEndMBStr,
                                  pWCStr,
                                  pEndWCStr,
                                  mbIncr );
                    pMBStr += mbIncr;
                    pWCStr++;
                }
                wcCount = (int)(pWCStr - lpWideCharStr);
            }
        }

        //
        //  Make sure wide character buffer was large enough.
        //
        if (pMBStr < pEndMBStr)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of characters written (or that would have
    //  been written) to the buffer.
    //
    return (wcCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\jamo.h ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    jamo.h

Abstract:

    This file contains the header information for the sorting of Old Hangul.

Revision History:

    06-23-2000    YSLin    Created.

--*/



#ifndef _JAMO_H
#define _JAMO_H





////////////////////////////////////////////////////////////////////////////
//
//  Constant Declarations.
//
////////////////////////////////////////////////////////////////////////////

//
//  Some Significant Values for Korean Jamo.
//
#define NLS_CHAR_FIRST_JAMO     L'\x1100'       // Beginning of the jamo range
#define NLS_CHAR_LAST_JAMO      L'\x11f9'         // End of the jamo range
#define NLS_CHAR_FIRST_VOWEL_JAMO       L'\x1160'   // First Vowel Jamo
#define NLS_CHAR_FIRST_TRAILING_JAMO    L'\x11a8'   // First Trailing Jamo

#define NLS_JAMO_VOWEL_COUNT 21      // Number of modern vowel jamo
#define NLS_JAMO_TRAILING_COUNT 28   // Number of modern trailing consonant jamo
#define NLS_HANGUL_FIRST_SYLLABLE       L'\xac00'   // Beginning of the modern syllable range

//
//  Jamo classes for leading Jamo/Vowel Jamo/Trailing Jamo.
//
#define NLS_CLASS_LEADING_JAMO 1
#define NLS_CLASS_VOWEL_JAMO 2
#define NLS_CLASS_TRAILING_JAMO 3





////////////////////////////////////////////////////////////////////////////
//
//  Typedef Declarations.
//
////////////////////////////////////////////////////////////////////////////

//
//  Expanded Jamo Sequence Sorting Info.
//  The JAMO_SORT_INFO.ExtraWeight is expanded to
//     Leading Weight/Vowel Weight/Trailing Weight
//  according to the current Jamo class.
//
typedef struct {
    BYTE m_bOld;               // sequence occurs only in old Hangul flag
    BOOL m_bFiller;            // Indicate if U+1160 (Hangul Jungseong Filler is used.
    CHAR m_chLeadingIndex;     // indices used to locate the prior
    CHAR m_chVowelIndex;       //     modern Hangul syllable
    CHAR m_chTrailingIndex;    //
    BYTE m_LeadingWeight;      // extra weights that distinguish this from
    BYTE m_VowelWeight;        //      other old Hangul syllables
    BYTE m_TrailingWeight;     //
} JAMO_SORT_INFOEX, *PJAMO_SORT_INFOEX;





////////////////////////////////////////////////////////////////////////////
//
//  Macro Definitions.
//
////////////////////////////////////////////////////////////////////////////

#define IS_JAMO(wch) \
    ((wch) >= NLS_CHAR_FIRST_JAMO && (wch) <= NLS_CHAR_LAST_JAMO)

#define IsJamo(wch) \
    ((wch) >= NLS_CHAR_FIRST_JAMO && (wch) <= NLS_CHAR_LAST_JAMO)

#define IsLeadingJamo(wch) \
    ((wch) < NLS_CHAR_FIRST_VOWEL_JAMO)

#define IsVowelJamo(wch) \
    ((wch) >= NLS_CHAR_FIRST_VOWEL_JAMO && (wch) < NLS_CHAR_FIRST_TRAILING_JAMO)

#define IsTrailingJamo(wch) \
    ((wch) >= NLS_CHAR_FIRST_TRAILING_JAMO)





////////////////////////////////////////////////////////////////////////////
//
//  Function Prototypes.
//
////////////////////////////////////////////////////////////////////////////

int
MapOldHangulSortKey(
    PLOC_HASH pHashN,
    LPCWSTR pSrc,       // source string
    int cchSrc,         // the length of the string
//  LPWSTR* pPosUW,     // generated Unicode weight
    WORD* pUW,          // generated Unicode weight
    LPBYTE pXW,         // generated extra weight (3 bytes)
    BOOL fModify);


#endif   // _JAMO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\geo.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    geo.c

Abstract:

    This file contains the system APIs that provide geographical information.

    Private APIs found in this file:
        GetIS0639
        GetGeoLCID

    External Routines found in this file:
        GetGeoInfoW
        GetUserGeoID
        SetUserGeoID
        EnumSystemGeoID

    Revision History:

        11-20-99    WeiWu     Created
        03-07-00    lguindon  Began Geo API port

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"




//
//  Global Variables.
//

PGEOTABLEHDR  gpGeoTableHdr = NULL;
PGEOINFO      gpGeoInfo = NULL;
PGEOLCID      gpGeoLCID = NULL;





////////////////////////////////////////////////////////////////////////////
//
//  GetGeoLCID
//
//  Returns the Locale ID associated with the Language Identifier and
//  Geographical Identifier.  This routine scans the mapping table for the
//  corresponding combination.  If nothing is found, the function returns
//  0 as the Locale Identifier.
//
////////////////////////////////////////////////////////////////////////////

LCID GetGeoLCID(
    GEOID GeoId,
    LANGID LangId)
{
    int ctr1, ctr2;

    if (pTblPtrs->pGeoInfo == NULL)
    {
        if (GetGeoFileInfo())
        {
            return (0);
        }
    }

    //
    //  Search for GEOID.
    //
    //  Note: We can have more then one Language ID for one GEOID.
    //
    for (ctr1 = 0; ctr1 < pTblPtrs->nGeoLCID; ctr1++)
    {
        if (GeoId == pTblPtrs->pGeoLCID[ctr1].GeoId)
        {
            //
            //  Search for Language ID
            //
            for (ctr2 = ctr1;
                 ctr2 < pTblPtrs->nGeoLCID && pTblPtrs->pGeoLCID[ctr2].GeoId == GeoId;
                 ctr2++)
            {
                if (pTblPtrs->pGeoLCID[ctr2].LangId == LangId)
                {
                    return (pTblPtrs->pGeoLCID[ctr2].lcid);
                }
            }
            break;
        }
    }

    //
    //  Nothing found, return zero
    //
    return ((LCID)0);
}




//-------------------------------------------------------------------------//
//                        EXTERNAL API ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetGeoInfoW
//
//  Retrieves information about a geographical location on earth.  The
//  required size is the number of characters.  If cchData is zero, the
//  function returns the number of characters needed to copy to caller's
//  buffer.  Otherwise, the function returns the number of characters copied
//  to caller's buffer if caller provided proper lpGeoData and cchData.
//  The function returns zero in the case of failure.
//
////////////////////////////////////////////////////////////////////////////

int WINAPI GetGeoInfoW(
    GEOID GeoId,
    DWORD GeoType,
    LPWSTR lpGeoData,
    int cchData,
    LANGID LangId)
{
    int ctr1, ctr2, ctr3;
    int Length = 0;
    LPWSTR pString = NULL;
    WCHAR pTemp[MAX_REG_VAL_SIZE] = {0};
    LCID Locale;
    LANGID DefaultLangId;
    PLOC_HASH pHashN;

    //
    //  Invalid Parameter Check:
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //    - invalid lang id
    //
    //  NOTE: Invalid geo id is checked in the binary search below.
    //        Invalid type is checked in the switch statement below.
    //
    Locale = MAKELCID(LangId, SORT_DEFAULT);
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ((cchData < 0) ||
        ((lpGeoData == NULL) && (cchData > 0)) ||
        (pHashN == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Check if the section is mapped into memory.
    //
    if (pTblPtrs->pGeoInfo == NULL)
    {
        if (GetGeoFileInfo())
        {
            return (0);
        }
    }

    //
    //  Check if we are dealing with an invalid geoid.
    //
    if (GeoId == GEOID_NOT_AVAILABLE)
    {
        return (0);
    }

    //
    //  Initialize variables for the binary search.
    //
    ctr1 = 0;
    ctr2 = pTblPtrs->nGeoInfo - 1;
    ctr3 = ctr2 >> 1;

    //
    //  Binary search GEO data.
    //
    while (ctr1 <= ctr2)
    {
        if (GeoId == pTblPtrs->pGeoInfo[ctr3].GeoId)
        {
            //
            //  Jump out of the loop.
            //
            break;
        }
        else
        {
            if (GeoId < pTblPtrs->pGeoInfo[ctr3].GeoId)
            {
                ctr2 = ctr3 - 1;
            }
            else
            {
                ctr1 = ctr3 + 1;
            }
            ctr3 = (ctr1 + ctr2) >> 1;
        }
    }

    //
    //  See if we have found the requested element.
    //
    if (ctr1 > ctr2)
    {
        //
        //  Could not find the Geo ID.
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Get the appropriate information based on the requested GeoType.
    //
    switch (GeoType)
    {
        case ( GEO_NATION ) :
        {
            if (pTblPtrs->pGeoInfo[ctr3].GeoClass == GEOCLASS_NATION)
            {
                NlsConvertIntegerToString(
                                  (UINT)(pTblPtrs->pGeoInfo[ctr3].GeoId),
                                  10,
                                  0,
                                  pTemp,
                                  MAX_REG_VAL_SIZE );
                pString = pTemp;
            }
            break;
        }
        case ( GEO_LATITUDE ) :
        {
            pString = pTblPtrs->pGeoInfo[ctr3].szLatitude;
            break;
        }
        case ( GEO_LONGITUDE ) :
        {
            pString = pTblPtrs->pGeoInfo[ctr3].szLongitude;
            break;
        }
        case ( GEO_ISO2 ) :
        {
            pString = pTblPtrs->pGeoInfo[ctr3].szISO3166Abbrev2;
            break;
        }
        case ( GEO_ISO3 ) :
        {
            pString = pTblPtrs->pGeoInfo[ctr3].szISO3166Abbrev3;
            break;
        }
        case ( GEO_RFC1766 ) :
        {
            //
            //  Check if it's a valid LANGID.  If not, get the default.
            //
            if (LangId == 0)
            {
                LangId = GetUserDefaultLangID();
            }

            //
            //  Make the corresponding LCID.
            //
            Locale = MAKELCID(LangId, SORT_DEFAULT);

            //
            //  Get IS0639 value associated with the LANGID.
            //
            if (!GetLocaleInfoW( Locale,
                                 LOCALE_SISO639LANGNAME,
                                 pTemp,
                                 MAX_REG_VAL_SIZE ))
            {
                //
                //  Try the Primary Language Identifier.
                //
                DefaultLangId = MAKELANGID(PRIMARYLANGID(LangId), SUBLANG_DEFAULT);
                if (DefaultLangId != LangId)
                {
                    Locale = MAKELCID(DefaultLangId, SORT_DEFAULT);
                    GetLocaleInfoW( Locale,
                                    LOCALE_SISO639LANGNAME,
                                    pTemp,
                                    MAX_REG_VAL_SIZE );
                }
            }

            if (pTemp[0] != 0)
            {
                //
                //  Construct the name to fit the form xx-yy where
                //  xx is ISO639_1 name associated with the LANGID
                //  and yy is the ISO3166 name 2 char abreviation.
                //
                if( FAILED(StringCchCatW(pTemp, ARRAYSIZE(pTemp), L"-")) ||
                    FAILED(StringCchCatW(pTemp, ARRAYSIZE(pTemp), pTblPtrs->pGeoInfo[ctr3].szISO3166Abbrev2)))
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return(0);
                }

                _wcslwr(pTemp);

                pString = pTemp;
            }

            break;
        }
        case ( GEO_LCID ) :
        {
            //
            //  Check if the we have a valid LANGID. If not, retrieve
            //  the default one.
            //
            if (LangId == 0)
            {
                LangId = GetUserDefaultLangID();
            }

            //
            //  Try to get a valid LCID from the GEOID and the LANGID.
            //
            if ((Locale = GetGeoLCID(GeoId, LangId)) == 0)
            {
                //
                //  Try the Primary Language Identifier.
                //
                DefaultLangId = MAKELANGID(PRIMARYLANGID(LangId), SUBLANG_DEFAULT);
                if (DefaultLangId != LangId)
                {
                    Locale = GetGeoLCID(GeoId, DefaultLangId);
                }

                //
                //  Check if the Locale returned is valid.
                //
                if (Locale == 0)
                {
                    //
                    //  Nothing found, make something with the LangId.
                    //  If Language ID already contains a sub-language,
                    //  we'll use it directly.
                    //
                    if (SUBLANGID(LangId) != 0)
                    {
                        Locale = MAKELCID(LangId, SORT_DEFAULT);
                    }
                    else
                    {
                        Locale = MAKELCID(MAKELANGID(LangId, SUBLANG_DEFAULT), SORT_DEFAULT);
                    }
                }
            }

            //
            //  Convert the value found into a string.
            //
            if (Locale != 0)
            {
                NlsConvertIntegerToString( Locale,
                                           16,
                                           8,
                                           pTemp,
                                           MAX_REG_VAL_SIZE );
                pString = pTemp;
            }
            break;
        }
        case ( GEO_FRIENDLYNAME ) :
        {
            Length = GetStringTableEntry( GeoId,
                                          LangId,
                                          pTemp,
                                          MAX_REG_VAL_SIZE,
                                          RC_GEO_FRIENDLY_NAME );
            if (Length == 0)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (0);
            }
            pString = pTemp;
            break;
        }
        case ( GEO_OFFICIALNAME ) :
        {
            Length = GetStringTableEntry( GeoId,
                                          LangId,
                                          pTemp,
                                          MAX_REG_VAL_SIZE,
                                          RC_GEO_OFFICIAL_NAME );
            if (Length == 0)
            {
                //
                //  If the official name is not there, fall back on
                //  the friendly name.
                //
                Length = GetStringTableEntry( GeoId,
                                              LangId,
                                              pTemp,
                                              MAX_REG_VAL_SIZE,
                                              RC_GEO_FRIENDLY_NAME );
                if (Length == 0)
                {
                    SetLastError(ERROR_INVALID_PARAMETER);
                    return (0);
                }
            }
            pString = pTemp;
            break;
        }
        case ( GEO_TIMEZONES ) :
        {
            // Not implemented
            break;
        }
        case ( GEO_OFFICIALLANGUAGES ) :
        {
            // Not implemented
            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            break;
        }
    }

    //
    //  Make sure the pointer is valid.  If not, return failure.
    //
    if (pString == NULL)
    {
        return (0);
    }

    //
    //  Get the length (in characters) of the string to copy.
    //
    if (Length == 0)
    {
        Length = NlsStrLenW(pString);
    }

    //
    //  Add one for null termination.  All strings should be null
    //  terminated.
    //
    Length++;

    //
    //  Check cchData for size of given buffer.
    //
    if (cchData == 0)
    {
        //
        //  If cchData is 0, then we can't use lpGeoData.  In this
        //  case, we simply want to return the length (in characters) of
        //  the string to be copied.
        //
        return (Length);
    }
    else if (cchData < Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Copy the string to lpGeoData and null terminate it.
    //  Return the number of characters copied.
    //
    wcsncpy(lpGeoData, pString, Length - 1);
    lpGeoData[Length - 1] = 0;
    return (Length);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumSystemGeoID
//
//  Enumerates the GEOIDs that are available on the system. This function
//  returns TRUE if it succeeds, FALSE if it fails.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI EnumSystemGeoID(
    GEOCLASS GeoClass,
    GEOID ParentGeoId,
    GEO_ENUMPROC lpGeoEnumProc)
{
    int ctr1;

    if ((lpGeoEnumProc == NULL) ||
        (0 != ParentGeoId) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    if (GeoClass != GEOCLASS_NATION)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (FALSE);
    }

    if (pTblPtrs->pGeoInfo == NULL)
    {
        if (GetGeoFileInfo())
        {
            return (FALSE);
        }
    }

    for (ctr1 = 0; ctr1 < pTblPtrs->nGeoInfo; ctr1++)
    {
        if (pTblPtrs->pGeoInfo[ctr1].GeoClass == GeoClass)
        {
            if (!lpGeoEnumProc(pTblPtrs->pGeoInfo[ctr1].GeoId))
            {
                return (TRUE);
            }
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUserGeoID
//
//  Retrieves information about the geographical location of the user.
//  This function returns a valid GEOID or the value GEOID_NOT_AVAILABLE.
//
////////////////////////////////////////////////////////////////////////////

GEOID WINAPI GetUserGeoID(
    GEOCLASS GeoClass)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE buffer[MAX_KEY_VALUE_FULLINFO];         // buffer
    HANDLE hKey = NULL;                          // handle to geo key
    WCHAR wszGeoRegStr[48];                      // ptr to class key
    GEOID GeoId = GEOID_NOT_AVAILABLE;           // GEOID to default
    UNICODE_STRING ObUnicodeStr;                 // registry data value string

    switch (GeoClass)
    {
        case ( GEOCLASS_NATION ) :
        {
            if(FAILED(StringCchCopyW(wszGeoRegStr, ARRAYSIZE(wszGeoRegStr), GEO_REG_NATION)))
            {
                //
                // Failure should in theory be impossible, but if we ignore the
                // return value, PREfast will complain.
                //
                return(GEOID_NOT_AVAILABLE);
            }
            break;
        }
        case ( GEOCLASS_REGION ) :
        {
            if(FAILED(StringCchCopyW(wszGeoRegStr, ARRAYSIZE(wszGeoRegStr), GEO_REG_REGION)))
            {
                //
                // Failure should in theory be impossible, but if we ignore the
                // return value, PREfast will complain.
                //
                return(GEOID_NOT_AVAILABLE);
            }
            break;
        }
        default :
        {
            return (GeoId);
        }
    }

    //
    //  Open the Control Panel International registry key.
    //
    OPEN_GEO_KEY(hKey, GEOID_NOT_AVAILABLE, KEY_READ);

    //
    //  Query the registry value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)buffer;
    if (QueryRegValue( hKey,
                       wszGeoRegStr,
                       &pKeyValueFull,
                       MAX_KEY_VALUE_FULLINFO,
                       NULL ) == NO_ERROR)
    {
        //
        //  Convert the string to a value.
        //
        GeoId = _wtol(GET_VALUE_DATA_PTR(pKeyValueFull));
    }

    //
    //  Close the registry key.
    //
    CLOSE_REG_KEY(hKey);

    //
    //  Return the Geo Id.
    //
    return (GeoId);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetUserGeoID
//
//  Sets information about the geographical location of the user.  This
//  function returns TRUE if it succeeds, FALSE if it fails.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI SetUserGeoID(
    GEOID GeoId)
{
    int ctr1, ctr2, ctr3;
    WCHAR wszRegStr[MAX_REG_VAL_SIZE];
    HANDLE hKey = NULL;
    BOOL bRet = FALSE;
    WCHAR wszBuffer[MAX_REG_VAL_SIZE] = {0};

    if (pTblPtrs->pGeoInfo == NULL)
    {
        if (GetGeoFileInfo())
        {
            return (FALSE);
        }
    }

    ctr1 = 0;
    ctr2 = pTblPtrs->nGeoInfo - 1;
    ctr3 = ctr2 >> 1;

    //
    //  Binary searching the GEOID's GEOCLASS type.
    //
    while (ctr1 <= ctr2)
    {
        if (GeoId == pTblPtrs->pGeoInfo[ctr3].GeoId)
        {
            switch (pTblPtrs->pGeoInfo[ctr3].GeoClass)
            {
                case ( GEOCLASS_NATION ) :
                {
                    if(FAILED(StringCchCopyW(wszRegStr, ARRAYSIZE(wszRegStr), GEO_REG_NATION)))
                    {
                        //
                        // Failure should in theory be impossible, but if we ignore the
                        // return value, PREfast will complain.
                        //
                        return(FALSE);
                    }
                    break;
                }
                case ( GEOCLASS_REGION ) :
                {
                    if(FAILED(StringCchCopyW(wszRegStr, ARRAYSIZE(wszRegStr), GEO_REG_REGION)))
                    {
                        //
                        // Failure should in theory be impossible, but if we ignore the
                        // return value, PREfast will complain.
                        //
                        return(FALSE);
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }

            break;
        }
        else
        {
            if (GeoId < pTblPtrs->pGeoInfo[ctr3].GeoId)
            {
                ctr2 = ctr3 - 1;
            }
            else
            {
                ctr1 = ctr3 + 1;
            }
            ctr3 = (ctr1 + ctr2) >> 1;
        }
    }

    //
    //  Not a valid GEOID or available GEOID if we can't find it in our
    //  GEO table.
    //
    if (ctr1 > ctr2)
    {
        return (FALSE);
    }

    //
    //  If the registry key does not exist, create a new one.
    //
    if (CreateRegKey( &hKey,
                      NULL,
                      GEO_REG_KEY,
                      KEY_READ | KEY_WRITE ) != NO_ERROR)
    {
        return (FALSE);
    }

    //
    //  Convert to decimal string.
    //
    NlsConvertIntegerToString((UINT)GeoId, 10, 0, wszBuffer, MAX_REG_VAL_SIZE);

    //
    //  Set the new GEOID value.
    //
    if (SetRegValue( hKey,
                     wszRegStr,
                     wszBuffer,
                     (NlsStrLenW(wszBuffer) + 1) * sizeof(WCHAR) ) == NO_ERROR)
    {
        bRet = TRUE;
    }

    //
    //  Close the registry key.
    //
    CLOSE_REG_KEY(hKey);

    //
    //  Return the result.
    //
    return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\locale.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    locale.c

Abstract:

    This file contains functions that return information about a
    language group, a UI language, a locale, or a calendar.

    APIs found in this file:
      IsValidLanguageGroup
      IsValidLocale
      IsValidUILanguage
      ConvertDefaultLocale
      GetThreadLocale
      SetThreadLocale
      SetThreadUILanguage
      GetSystemDefaultUILanguage
      GetUserDefaultUILanguage
      GetSystemDefaultLangID
      GetUserDefaultLangID
      GetSystemDefaultLCID
      GetUserDefaultLCID
      VerLanguageNameW
      VerLanguageNameA
      GetLocaleInfoW
      SetLocaleInfoW
      GetCalendarInfoW
      SetCalendarInfoW

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"



//
//  Allow this file to build without warnings when the DUnicode switch
//  is turned off.
//
#undef MAKEINTRESOURCE
#define MAKEINTRESOURCE MAKEINTRESOURCEW


////////////////////////////////////////////////////////////////////////////
//
//  NLS_STRING_TO_INTEGER
//
//  Converts a string to an integer value.
//
//  DEFINED AS A MACRO.
//
//  10-19-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_STRING_TO_INTEGER( CalData,                                    \
                               pCalData )                                  \
{                                                                          \
    UNICODE_STRING ObUnicodeStrCalData; /* value string */                 \
                                                                           \
                                                                           \
    /*                                                                     \
     *  No need to check return value since the calendar number            \
     *  will be validated after this anyway.                               \
     */                                                                    \
    RtlInitUnicodeString(&ObUnicodeStrCalData, pCalData);                  \
    RtlUnicodeStringToInteger(&ObUnicodeStrCalData, 10, &CalData);         \
}




//
//  Global Variables.
//

LCID gProcessLocale;




//
//  Forward Declarations.
//

BOOL
SetUserInfo(
    LCTYPE LCType,
    LPWSTR pData,
    ULONG DataLength);

BOOL SetCurrentUserRegValue(
    LCTYPE   LCType,
    LPWSTR pData,
    ULONG DataLength);

BOOL
SetMultipleUserInfo(
    DWORD dwFlags,
    int cchData,
    LPCWSTR pPicture,
    LPCWSTR pSeparator,
    LPCWSTR pOrder,
    LPCWSTR pTLZero,
    LPCWSTR pTimeMarkPosn);


BOOL
SetTwoDigitYearInfo(
    CALID Calendar,
    LPCWSTR pYearInfo,
    int cchData);

void
GetInstallLanguageFromRegistry();




//-------------------------------------------------------------------------//
//                          PRIVATE API ROUTINES                           //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsResetProcessLocale
//
////////////////////////////////////////////////////////////////////////////

void NlsResetProcessLocale(void)
{

    //
    //  If the thread isn't impersonating, then re-read the process locale
    //  from the current user's registry.
    //
    if (NtCurrentTeb()->IsImpersonating == 0L)
    {
        NlsFlushProcessCache(LOCALE_SLOCALE);
        NlsGetUserLocale(&gProcessLocale);
    }

    return;
}




//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  IsValidLanguageGroup
//
//  Determines whether or not a language group is installed in the system
//  if the LGRPID_INSTALLED flag is set, or whether or not a language group
//  is supported in the system if the LGRPID_SUPPORTED flag is set.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsValidLanguageGroup(
    LGRPID LanguageGroup,
    DWORD dwFlags)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];

    WCHAR pTmpBuf[MAX_PATH];           // temp buffer
    UNICODE_STRING ObUnicodeStr;       // registry data value string
    LPWSTR pData;                      // ptr to registry data


    //
    //  Invalid Flags Check:
    //     - flags other than valid ones
    //     - more than one of either supported or installed
    //
    if ((dwFlags & IVLG_INVALID_FLAG) ||
        (MORE_THAN_ONE(dwFlags, IVLG_SINGLE_FLAG)))
    {
        return (FALSE);
    }

    //
    //  Open the Language Groups registry key.
    //
    OPEN_LANG_GROUPS_KEY(FALSE);

    //
    //  Convert language group value to Unicode string.
    //
    if (NlsConvertIntegerToString(LanguageGroup, 16, 1, pTmpBuf, MAX_PATH))
    {
        return (FALSE);
    }

    //
    //  Query the registry for the value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    if ((QueryRegValue( hLangGroupsKey,
                        pTmpBuf,
                        &pKeyValueFull,
                        MAX_KEY_VALUE_FULLINFO,
                        NULL ) != NO_ERROR))
    {
        return (FALSE);
    }

    //
    //  Language Group is SUPPORTED.  If the INSTALLED flag is NOT set, then
    //  return success.
    //
    if (!(dwFlags & LGRPID_INSTALLED))
    {
        return (TRUE);
    }

    //
    //  Need to find out if it's installed.
    //
    if (pKeyValueFull->DataLength > 2)
    {
        pData = GET_VALUE_DATA_PTR(pKeyValueFull);
        if ((pData[0] == L'1') && (pData[1] == 0))
        {
            return (TRUE);
        }
    }

    //
    //  Return result.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidLocale
//
//  Determines whether or not a locale is installed in the system if the
//  LCID_INSTALLED flag is set, or whether or not a locale is supported in
//  the system if the LCID_SUPPORTED flag is set.
//
//  07-26-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsValidLocale(
    LCID Locale,
    DWORD dwFlags)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;
    BYTE pStatic1[MAX_KEY_VALUE_FULLINFO];
    BYTE pStatic2[MAX_KEY_VALUE_FULLINFO];

    WCHAR pTmpBuf[MAX_PATH];           // temp buffer
    UNICODE_STRING ObUnicodeStr;       // registry data value string
    DWORD Data;                        // registry data value
    LPWSTR pData;                      // ptr to registry data
    BOOL bResult = FALSE;              // result value


    //
    //  Invalid Flags Check:
    //     - flags other than valid ones
    //     - more than one of either supported or installed
    //
    if ((dwFlags & IVL_INVALID_FLAG) ||
        (MORE_THAN_ONE(dwFlags, IVL_SINGLE_FLAG)))
    {
        //
        //  The ME release of NT 4 did a really bad thing and allowed 0x39
        //  to be passed in as a valid flag value for Arabic and Hebrew.
        //  As a result, we need to allow this flag combination for
        //  the Arabic and Hebrew locales.
        //
        if ((dwFlags == 0x39) &&
            ((Locale == MAKELCID(MAKELANGID(LANG_ARABIC, SUBLANG_DEFAULT), SORT_DEFAULT)) ||
             (Locale == MAKELCID(MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT), SORT_DEFAULT))))
        {
            dwFlags = LCID_INSTALLED;
        }
        else
        {
            return (FALSE);
        }
    }

    //
    //  Invalid Locale Check.
    //
    if (IS_INVALID_LOCALE(Locale))
    {
        return (FALSE);
    }

    //
    //  See if the LOCALE information is in the system for the
    //  given locale.
    //
    if (GetLocHashNode(Locale) == NULL)
    {
        //
        //  Return failure.
        //
        return (FALSE);
    }

    //
    //  Locale is SUPPORTED.  If the INSTALLED flag is NOT set, then
    //  return success.
    //
    if (!(dwFlags & LCID_INSTALLED))
    {
        return (TRUE);
    }

    //
    //  Open the Locale, the Alternate Sorts, and the Language Groups
    //  registry keys.
    //
    OPEN_LOCALE_KEY(FALSE);
    OPEN_ALT_SORTS_KEY(FALSE);
    OPEN_LANG_GROUPS_KEY(FALSE);

    //
    //  Convert locale value to Unicode string.
    //
    if (NlsConvertIntegerToString(Locale, 16, 8, pTmpBuf, MAX_PATH))
    {
        return (FALSE);
    }

    //
    //  Query the registry for the value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic1;
    if (((QueryRegValue( hLocaleKey,
                         pTmpBuf,
                         &pKeyValueFull,
                         MAX_KEY_VALUE_FULLINFO,
                         NULL ) == NO_ERROR) ||
         (QueryRegValue( hAltSortsKey,
                         pTmpBuf,
                         &pKeyValueFull,
                         MAX_KEY_VALUE_FULLINFO,
                         NULL ) == NO_ERROR)) &&
        (pKeyValueFull->DataLength > 2))
    {
        RtlInitUnicodeString(&ObUnicodeStr, GET_VALUE_DATA_PTR(pKeyValueFull));
        if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 16, &Data) == NO_ERROR) &&
            (Data != 0))
        {
            pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic2;
            if ((QueryRegValue( hLangGroupsKey,
                                ObUnicodeStr.Buffer,
                                &pKeyValueFull,
                                MAX_KEY_VALUE_FULLINFO,
                                NULL ) == NO_ERROR) &&
                (pKeyValueFull->DataLength > 2))
            {
                pData = GET_VALUE_DATA_PTR(pKeyValueFull);
                if ((pData[0] == L'1') && (pData[1] == 0))
                {
                    bResult = TRUE;
                }
            }
        }
    }

    //
    //  Return result.
    //
    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidUILanguage
//
//  Determines whether or not the specified UI language is installed in the system.
//
//
//  12-03-00    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsValidUILanguage(LANGID UILangID)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE Key;
    WCHAR UILangIDStr[5];
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;

    ULONG Value = 0, Digit, i;
    WCHAR c;

    BOOL Result = FALSE;

    RtlInitUnicodeString(&KeyPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\MUILanguages");

    if (!NlsConvertIntegerToHexStringW(UILangID, FALSE, UILangIDStr, sizeof(UILangIDStr)/sizeof(WCHAR)))
    {
        return (FALSE);
    }
    RtlInitUnicodeString(&KeyValueName, UILangIDStr);

    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    if (NT_SUCCESS(NtOpenKey (&Key, KEY_READ, &ObjectAttributes)))
    {
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
        Status = NtQueryValueKey(Key,
                                 &KeyValueName,
                                 KeyValuePartialInformation,
                                 KeyValueInformation,
                                 sizeof( KeyValueBuffer ),
                                 &ResultLength
                                );
        if (NT_SUCCESS(Status))
        {
            if (KeyValueInformation->Type == REG_SZ && *((PWSTR)(KeyValueInformation->Data)) == L'1')
            {
                Result = TRUE;
            }
        }
        NtClose(Key);
    }
    return (Result);
}


////////////////////////////////////////////////////////////////////////////
//
//  ConvertDefaultLocale
//
//  Converts any of the special case locale values to an actual locale id.
//  If none of the special case locales was given, the given locale id
//  is returned.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LCID WINAPI ConvertDefaultLocale(
    LCID Locale)
{
    //
    //  Check for the special locale values.
    //
    CHECK_SPECIAL_LOCALES(Locale, FALSE);

    //
    //  Return the locale id.
    //
    return (Locale);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetThreadLocale
//
//  Returns the locale id for the current thread.
//
//  03-11-93    JulieB    Moved from base\client.
////////////////////////////////////////////////////////////////////////////

LCID WINAPI GetThreadLocale()
{
    //
    //  Return the locale id stored in the TEB.
    //
    return ((LCID)(NtCurrentTeb()->CurrentLocale));
}


////////////////////////////////////////////////////////////////////////////
//
//  SetThreadLocale
//
//  Resets the locale id for the current thread.  Any locale-dependent
//  functions will reflect the new locale.  If the locale passed in is
//  not a valid locale id, then FALSE is returned.
//
//  03-11-93    JulieB    Moved from base\client; Added Locale Validation.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI SetThreadLocale(
    LCID Locale)
{
    PLOC_HASH pHashN;             // ptr to hash node


    //
    //  Validate locale id.
    //
    VALIDATE_LANGUAGE(Locale, pHashN, 0, FALSE);
    if (pHashN == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Set the locale id in the TEB.
    //
    NtCurrentTeb()->CurrentLocale = (ULONG)Locale;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetThreadUILanguage
//
//  This routine sets the thread UI language based on the console codepage.
//
//  9-29-00    WeiWu    Created.
////////////////////////////////////////////////////////////////////////////

LANGID WINAPI SetThreadUILanguage(
    WORD wReserved)
{
    //
    //  Cache system locale and CP info
    // 
    static LCID s_lidSystem = 0;
    static UINT s_uiSysCp = 0;
    static UINT s_uiSysOEMCp = 0;

    UINT uiUserUICp;
    UINT uiUserUIOEMCp;
    WCHAR szData[16];

    LANGID lidUserUI = GetUserDefaultUILanguage();
    LCID lcidThreadOld = GetThreadLocale();

    //
    //  Set default thread locale to EN-US
    //
    //  This allow us to fall back to English UI to avoid trashed characters 
    //  when console doesn't meet the criteria of rendering native UI.
    //
    LCID lcidThread = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
    UINT uiConsoleCp = GetConsoleOutputCP();

    //
    //  Make sure nobody uses it yet
    //
    ASSERT(wReserved == 0);

    //
    //  Get cached system locale and CP info.
    //
    if (!s_uiSysCp)
    {
        LCID lcidSystem = GetSystemDefaultLCID();

        if (lcidSystem)
        {
            //
            // Get ANSI CP
            //
            GetLocaleInfoW(lcidSystem, LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
            NlsConvertStringToIntegerW(szData, 10, -1, &s_uiSysCp);

            //
            // Get OEM CP
            //
            GetLocaleInfoW(lcidSystem, LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
            NlsConvertStringToIntegerW(szData, 10, -1, &s_uiSysOEMCp);
            
            //
            // Cache system primary langauge
            //
            s_lidSystem = PRIMARYLANGID(LANGIDFROMLCID(lcidSystem));
        }
    }

    //
    //  Don't cache user UI language and CP info, UI language can be changed without system reboot.
    //
    if (lidUserUI)
    {
        GetLocaleInfoW(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
        NlsConvertStringToIntegerW(szData, 10, -1, &uiUserUICp);

        GetLocaleInfoW(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
        NlsConvertStringToIntegerW(szData, 10, -1, &uiUserUIOEMCp);
    }

    //
    //  Complex scripts cannot be rendered in the console, so we
    //  force the English (US) resource.
    //
    if (uiConsoleCp)
    {
        if (s_lidSystem != LANG_ARABIC && 
            s_lidSystem != LANG_HEBREW &&
            s_lidSystem != LANG_VIETNAMESE && 
            s_lidSystem != LANG_THAI)
        {
            //
            //  Use UI language for console only when console CP, system CP and UI language CP match.
            //
            if ((uiConsoleCp == s_uiSysCp || uiConsoleCp == s_uiSysOEMCp) && 
                (uiConsoleCp == uiUserUICp || uiConsoleCp == uiUserUIOEMCp))
            {
                lcidThread = MAKELCID(lidUserUI, SORT_DEFAULT);
            }
        }
    }
    else
    {
        //
        // No console window, keep the original thread locale
        //
        lcidThread = lcidThreadOld;
    }

    //
    //  Set the thread locale if it's different from the currently set
    //  thread locale.
    //
    if ((lcidThread != lcidThreadOld) && (!SetThreadLocale(lcidThread)))
    {
        lcidThread = lcidThreadOld;
    }

    //
    //  Return the thread locale that was set.
    //
    return (LANGIDFROMLCID(lcidThread));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetSystemDefaultUILanguage
//
//  Returns the language of the original install.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LANGID WINAPI GetSystemDefaultUILanguage()
{
    //
    //  Get the original install language and return it.
    //
    if (gSystemInstallLang == 0)
    {
        if (NtQueryInstallUILanguage(&gSystemInstallLang) != STATUS_SUCCESS)
        {
            gSystemInstallLang = 0;
            return (NLS_DEFAULT_UILANG);
        }
    }

    return (gSystemInstallLang);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUserDefaultUILanguage
//
//  Returns the current User's UI language selection.  If the UI language
//  is not available, then the chosen default UI language is used
//  (NLS_DEFAULT_UILANG).
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LANGID WINAPI GetUserDefaultUILanguage()
{
    LANGID DefaultUILang;
    LANGID SystemUILang;

    //
    // Note that the default UI language is coming from HKCU.  However,
    // in the roaming profile situation, the default UI language for the
    // user may be not installed in the roamming machine, therefore we will
    // need to check if the DefaultUILang is a valid UI language installed
    // in the machine (the check is based in HKLM).
    //
    if (NtQueryDefaultUILanguage(&DefaultUILang) != STATUS_SUCCESS)
    {
        if ((SystemUILang = GetSystemDefaultUILanguage()) == 0)
        {
            return (NLS_DEFAULT_UILANG);
        }
        return (SystemUILang);
    }
    return (DefaultUILang);
}

////////////////////////////////////////////////////////////////////////////
//
//  GetSystemDefaultLangID
//
//  Returns the default language for the system.  If the registry value is
//  not readable, then the chosen default language is used
//  (NLS_DEFAULT_LANGID).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LANGID WINAPI GetSystemDefaultLangID()
{
    //
    //  Get the language id from the locale id stored in the cache
    //  and return it.
    //
    return (LANGIDFROMLCID(gSystemLocale));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUserDefaultLangID
//
//  Returns the default language for the current user.  If the current user's
//  language is not set, then the system default language id is returned.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LANGID WINAPI GetUserDefaultLangID()
{
    //
    //  Get the language id from the locale id stored in the cache
    //  and return it.
    //
    return (LANGIDFROMLCID(GetUserDefaultLCID()));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetSystemDefaultLCID
//
//  Returns the default locale for the system.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LCID WINAPI GetSystemDefaultLCID()
{
    //
    //  Return the locale id stored in the cache.
    //
    return (gSystemLocale);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUserDefaultLCID
//
//  Returns the default locale for the current user.  If current user's locale
//  is not set, then the system default locale id is returned.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LCID WINAPI GetUserDefaultLCID()
{
    LCID Lcid = NtCurrentTeb()->ImpersonationLocale;

    switch (Lcid)
    {
        case ( -1 ) :
        {
            //
            //  Thread is being impersonated.
            //
            if (NT_SUCCESS( NlsGetUserLocale(&Lcid) ))
            {
                NtCurrentTeb()->ImpersonationLocale = Lcid;
            }
            else
            {
                //
                // If we can't get it from the registry, then let's use the
                // system locale since it won't be resolved by calling
                // GetUserDefaultLCID() again.
                //
                Lcid = NtCurrentTeb()->ImpersonationLocale = gSystemLocale;
            }
            break;
        }
        case ( 0 ) :
        {
            //
            //  Thread hasn't been impersonated.
            //  If we are running in the interactive logged on user, then
            //  use the one cached in CSRSS if the cache is valid.  Otherwise,
            //  use the process cached locale.
            //
            if (gInteractiveLogonUserProcess == (BOOL) -1)
            {
                NlsIsInteractiveUserProcess();
            }

            if ((gInteractiveLogonUserProcess == FALSE) ||
                ((Lcid = pNlsUserInfo->UserLocaleId) == 0))
            {
                if (!gProcessLocale)
                {
                    if (!NT_SUCCESS (NlsGetUserLocale(&gProcessLocale)) )
                    {
                        gProcessLocale = gSystemLocale;
                    }
                }

                Lcid = gProcessLocale;
            }

            break;
        }
    }

    return (Lcid);
}


////////////////////////////////////////////////////////////////////////////
//
//  VerLanguageNameW
//
//  Returns the language name of the given language id in the language of
//  the current user.
//
//  05-31-91    JulieB    Moved and Rewrote from Version Library.
////////////////////////////////////////////////////////////////////////////

DWORD WINAPI VerLanguageNameW(
    DWORD wLang,
    LPWSTR szLang,
    DWORD wSize)
{
    DWORD Length = 0;                      // length of string
    WCHAR pTemp[MAX_REG_VAL_SIZE];         // temp buffer


    //
    //  Make sure we have a buffer.
    //
    if ((wSize == 0) || (szLang == NULL))
    {
        return (0);
    }

    //
    //  Try to get the localized language name for the given ID.
    //
    pTemp[0] = 0;
    if (!(Length = GetStringTableEntry( wLang,
                                        0,
                                        pTemp,
                                        MAX_REG_VAL_SIZE,
                                        RC_LANGUAGE_NAME )))
    {
        //
        //  Can't get the name of the language id passed in, so get
        //  the "language neutral" name.
        //
        Length = GetStringTableEntry( LANG_NEUTRAL,
                                      0,
                                      pTemp,
                                      MAX_REG_VAL_SIZE,
                                      RC_LANGUAGE_NAME );
    }

    //
    //  If the length is too big for the buffer, then reset the length
    //  to the size of the given buffer.
    //
    if (Length >= wSize)
    {
        Length = wSize - 1;
    }

    //
    //  Copy the string to the buffer and zero terminate it.
    //
    if (Length > 0)
    {
        wcsncpy(szLang, pTemp, Length);
        szLang[Length] = 0;
    }

    //
    //  Return the number of characters in the string, NOT including
    //  the null termination.
    //
    return (Length);
}


////////////////////////////////////////////////////////////////////////////
//
//  VerLanguageNameA
//
//  Returns the language name of the given language id in the language of
//  the current user.
//
//  05-31-91    JulieB    Moved from Version Library.
////////////////////////////////////////////////////////////////////////////

DWORD WINAPI VerLanguageNameA(
    DWORD wLang,
    LPSTR szLang,
    DWORD wSize)
{
    UNICODE_STRING Language;           // unicode string buffer
    ANSI_STRING AnsiString;            // ansi string buffer
    DWORD Status;                      // return status


    //
    //  Make sure we have a buffer.
    //
    if ((wSize == 0) || (szLang == NULL))
    {
        return (0);
    }

    //
    //  Allocate Unicode string structure and set the fields with the
    //  given parameters.
    //
    Language.Buffer = RtlAllocateHeap( RtlProcessHeap(),
                                       0,
                                       sizeof(WCHAR) * wSize );

    Language.MaximumLength = (USHORT)(wSize * sizeof(WCHAR));

    //
    //  Make sure the allocation succeeded.
    //
    if (Language.Buffer == NULL)
    {
        return (FALSE);
    }

    //
    //  Get the language name (in Unicode).
    //
    Status = VerLanguageNameW( wLang,
                               Language.Buffer,
                               wSize );

    Language.Length = (USHORT)(Status * sizeof(WCHAR));

    //
    //  Convert unicode string to ansi.
    //
    AnsiString.Buffer = szLang;
    AnsiString.Length = AnsiString.MaximumLength = (USHORT)wSize;
    RtlUnicodeStringToAnsiString(&AnsiString, &Language, FALSE);
    Status = AnsiString.Length;
    RtlFreeUnicodeString(&Language);

    //
    //  Return the value returned from VerLanguageNameW.
    //
    return (Status);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLocaleInfoW
//
//  Returns one of the various pieces of information about a particular
//  locale by querying the configuration registry.  This call also indicates
//  how much memory is necessary to contain the desired information.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetLocaleInfoW(
    LCID Locale,
    LCTYPE LCType,
    LPWSTR lpLCData,
    int cchData)
{
    PLOC_HASH pHashN;                       // ptr to LOC hash node
    int Length = 0;                         // length of info string
    LPWSTR pString;                         // ptr to the info string
    LPWORD pStart;                          // ptr to starting point
    BOOL UserOverride = TRUE;               // use user override
    BOOL ReturnNum = FALSE;                 // return number instead of string
    LPWSTR pTmp;                            // tmp ptr to info string
    int Repeat;                             // # repetitions of same letter
    WCHAR pTemp[MAX_REG_VAL_SIZE];          // temp buffer
    UNICODE_STRING ObUnicodeStr;            // value string
    int Base = 0;                           // base for str to int conversion
    static LANGID lidSystem = 0;            // system default UI language

    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //
    //  NOTE: invalid type is checked in the switch statement below.
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ( (pHashN == NULL) ||
         (cchData < 0) ||
         ((lpLCData == NULL) && (cchData != 0)) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Set the base value to add to in order to get the variable
    //  length strings.
    //
    pStart = (LPWORD)(pHashN->pLocaleHdr);

    //
    //  Check for NO USER OVERRIDE flag and remove the USE CP ACP flag.
    //
    if (LCType & LOCALE_NOUSEROVERRIDE)
    {
        //
        //  Flag is set, so set the boolean value and remove the flag
        //  from the LCType parameter (for switch statement).
        //
        UserOverride = FALSE;
    }
    if (LCType & LOCALE_RETURN_NUMBER)
    {
        //
        //  Flag is set, so set the boolean value and remove the flag
        //  from the LCType parameter (for switch statement).
        //
        ReturnNum = TRUE;
    }
    LCType = NLS_GET_LCTYPE_VALUE(LCType);

    //
    //  Initialize temp buffer.
    //
    pTemp[0] = 0;

    //
    //  Return the appropriate information for the given LCTYPE.
    //  If user information exists for the given LCTYPE, then
    //  the user default is returned instead of the system default.
    //
    switch (LCType)
    {
        case ( LOCALE_ILANGUAGE ) :
        {
            Base = 16;
            pString = pHashN->pLocaleFixed->szILanguage;
            break;
        }
        case ( LOCALE_SLANGUAGE ) :
        {
            if (!lidSystem)
            {
                lidSystem = GetSystemDefaultUILanguage();
            }

            //
            //  Get the information from the RC file.
            //
            //  Use system installed language resource if we're not under MUI.
            //  Otherwise, let resource loader load the default language resource.
            //
            Length = GetStringTableEntry( LANGIDFROMLCID(Locale),
                                          GetUserDefaultUILanguage() == lidSystem? lidSystem : 0,
                                          pTemp,
                                          MAX_REG_VAL_SIZE,
                                          RC_LANGUAGE_NAME );
            if (Length == 0)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (0);
            }
            pString = pTemp;
            break;
        }
        case ( LOCALE_SENGLANGUAGE ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SEngLanguage;
            break;
        }
        case ( LOCALE_SABBREVLANGNAME ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sAbbrevLangName),
                             NLS_VALUE_SLANGUAGE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SAbbrevLang;
            }
            break;
        }
        case ( LOCALE_SISO639LANGNAME ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevLangISO;
            break;
        }
        case ( LOCALE_SNATIVELANGNAME ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SNativeLang;
            break;
        }
        case ( LOCALE_ICOUNTRY ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iCountry),
                             NLS_VALUE_ICOUNTRY,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szICountry;
            }
            break;
        }
        case ( LOCALE_SCOUNTRY ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sCountry),
                             NLS_VALUE_SCOUNTRY,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                //
                //  Get the information from the RC file.
                //
                Length = GetStringTableEntry( LANGIDFROMLCID(Locale),
                                              0,
                                              pTemp,
                                              MAX_REG_VAL_SIZE,
                                              RC_COUNTRY_NAME );
                if (Length == 0)
                {
                    SetLastError(ERROR_INVALID_PARAMETER);
                    return (0);
                }
                pString = pTemp;
                break;
            }
            break;
        }
        case ( LOCALE_SENGCOUNTRY ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SEngCountry;
            break;
        }
        case ( LOCALE_SABBREVCTRYNAME ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevCtry;
            break;
        }
        case ( LOCALE_SISO3166CTRYNAME ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevCtryISO;
            break;
        }
        case ( LOCALE_SNATIVECTRYNAME ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SNativeCtry;
            break;
        }
        case ( LOCALE_IGEOID ) :
        {
            Base = 10;
            pString = pHashN->pLocaleFixed->szIGeoID;
            break;
        }
        case ( LOCALE_SSORTNAME ) :
        {
            //
            //  Get the information from the RC file.
            //
            Length = GetStringTableEntry( LANGIDFROMLCID(Locale),
                                          0,
                                          pTemp,
                                          MAX_REG_VAL_SIZE,
                                          RC_SORT_NAMES + SORTIDFROMLCID(Locale) );
            if (Length == 0)
            {
                //
                //  If the sort name doesn't exist for the given locale id,
                //  then try to get the Default name.  This is stored in the
                //  0x0000 entry.
                //
                Length = GetStringTableEntry( 0x0000,
                                              0,
                                              pTemp,
                                              MAX_REG_VAL_SIZE,
                                              RC_SORT_NAMES + SORTIDFROMLCID(Locale) );
                if (Length == 0)
                {
                    SetLastError(ERROR_INVALID_PARAMETER);
                    return (0);
                }
            }
            pString = pTemp;
            break;
        }
        case ( LOCALE_IDEFAULTLANGUAGE ) :
        {
            Base = 16;
            pString = pHashN->pLocaleFixed->szIDefaultLang;
            break;
        }
        case ( LOCALE_IDEFAULTCOUNTRY ) :
        {
            Base = 10;
            pString = pHashN->pLocaleFixed->szIDefaultCtry;
            break;
        }
        case ( LOCALE_IDEFAULTANSICODEPAGE ) :
        {
            if (ReturnNum)
            {
                if (cchData < 2)
                {
                    if (cchData == 0)
                    {
                        //
                        //  DWORD is needed for this option (2 WORDS),
                        //  so return 2.
                        //
                        return (2);
                    }

                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }

                //
                //  Copy the value to lpLCData and return 2
                //  (2 WORDS = 1 DWORD).
                //
                *((LPDWORD)lpLCData) = (DWORD)(pHashN->pLocaleFixed->DefaultACP);
                return (2);
            }

            pString = pHashN->pLocaleFixed->szIDefaultACP;
            break;
        }
        case ( LOCALE_IDEFAULTCODEPAGE ) :
        {
            Base = 10;
            pString = pHashN->pLocaleFixed->szIDefaultOCP;
            break;
        }
        case ( LOCALE_IDEFAULTMACCODEPAGE ) :
        {
            Base = 10;
            pString = pHashN->pLocaleFixed->szIDefaultMACCP;
            break;
        }
        case ( LOCALE_IDEFAULTEBCDICCODEPAGE ) :
        {
            Base = 10;
            pString = pHashN->pLocaleFixed->szIDefaultEBCDICCP;
            break;
        }
        case ( LOCALE_SLIST ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sList),
                             NLS_VALUE_SLIST,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SList;
            }
            break;
        }
        case ( LOCALE_IMEASURE ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iMeasure),
                             NLS_VALUE_IMEASURE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIMeasure;
            }
            break;
        }
        case ( LOCALE_IPAPERSIZE ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iPaperSize),
                             NLS_VALUE_IPAPERSIZE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIPaperSize;
            }
            break;
        }
        case ( LOCALE_SDECIMAL ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sDecimal),
                             NLS_VALUE_SDECIMAL,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SDecimal;
            }
            break;
        }
        case ( LOCALE_STHOUSAND ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sThousand),
                             NLS_VALUE_STHOUSAND,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SThousand;
            }
            break;
        }
        case ( LOCALE_SGROUPING ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sGrouping),
                             NLS_VALUE_SGROUPING,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SGrouping;
            }
            break;
        }
        case ( LOCALE_IDIGITS ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iDigits),
                             NLS_VALUE_IDIGITS,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIDigits;
            }
            break;
        }
        case ( LOCALE_ILZERO ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iLZero),
                             NLS_VALUE_ILZERO,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szILZero;
            }
            break;
        }
        case ( LOCALE_INEGNUMBER ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iNegNumber),
                             NLS_VALUE_INEGNUMBER,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szINegNumber;
            }
            break;
        }
        case ( LOCALE_SNATIVEDIGITS ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sNativeDigits),
                             NLS_VALUE_SNATIVEDIGITS,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SNativeDigits;
            }
            break;
        }
        case ( LOCALE_IDIGITSUBSTITUTION ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iDigitSubstitution),
                             NLS_VALUE_IDIGITSUBST,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIDigitSubstitution;
            }
            break;
        }
        case ( LOCALE_SCURRENCY ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sCurrency),
                             NLS_VALUE_SCURRENCY,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SCurrency;
            }
            break;
        }
        case ( LOCALE_SINTLSYMBOL ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SIntlSymbol;
            break;
        }
        case ( LOCALE_SENGCURRNAME ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SEngCurrName;
            break;
        }
        case ( LOCALE_SNATIVECURRNAME ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SNativeCurrName;
            break;
        }
        case ( LOCALE_SMONDECIMALSEP ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sMonDecSep),
                             NLS_VALUE_SMONDECIMALSEP,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SMonDecSep;
            }
            break;
        }
        case ( LOCALE_SMONTHOUSANDSEP ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sMonThouSep),
                             NLS_VALUE_SMONTHOUSANDSEP,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SMonThousSep;
            }
            break;
        }
        case ( LOCALE_SMONGROUPING ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sMonGrouping),
                             NLS_VALUE_SMONGROUPING,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SMonGrouping;
            }
            break;
        }
        case ( LOCALE_ICURRDIGITS ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iCurrDigits),
                             NLS_VALUE_ICURRDIGITS,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szICurrDigits;
            }
            break;
        }
        case ( LOCALE_IINTLCURRDIGITS ) :
        {
            Base = 10;
            pString = pHashN->pLocaleFixed->szIIntlCurrDigits;
            break;
        }
        case ( LOCALE_ICURRENCY ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iCurrency),
                             NLS_VALUE_ICURRENCY,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szICurrency;
            }
            break;
        }
        case ( LOCALE_INEGCURR ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                             NLS_VALUE_INEGCURR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szINegCurr;
            }
            break;
        }
        case ( LOCALE_SPOSITIVESIGN ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sPosSign),
                             NLS_VALUE_SPOSITIVESIGN,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SPositiveSign;
            }
            break;
        }
        case ( LOCALE_SNEGATIVESIGN ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sNegSign),
                             NLS_VALUE_SNEGATIVESIGN,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SNegativeSign;
            }
            break;
        }
        case ( LOCALE_IPOSSIGNPOSN ) :
        {
            //
            //  Since there is no positive sign in any of the ICURRENCY
            //  options, use the INEGCURR options instead.  All known
            //  locales would use the positive sign in the same position
            //  as the negative sign.
            //
            //  NOTE:  For the 2 options that use parenthesis, put the
            //         positive sign at the beginning of the string
            //         (where the opening parenthesis is).
            //
            //      1  =>  4, 5, 8, 15
            //      2  =>  3, 11
            //      3  =>  0, 1, 6, 9, 13, 14
            //      4  =>  2, 7, 10, 12
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                             NLS_VALUE_INEGCURR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'4' ) :
                    case ( L'5' ) :
                    case ( L'8' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'3' ) :
                    {
                        *pString = L'2';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'0' ) :
                    case ( L'6' ) :
                    case ( L'9' ) :
                    {
                        *pString = L'3';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'2' ) :
                    case ( L'7' ) :
                    {
                        *pString = L'4';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'1' ) :
                    {
                        switch (*(pString + 1))
                        {
                            case ( 0 ) :
                            case ( L'3' ) :
                            case ( L'4' ) :
                            default :
                            {
                                *pString = L'3';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'0' ) :
                            case ( L'2' ) :
                            {
                                *pString = L'4';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'1' ) :
                            {
                                *pString = L'2';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'5' ) :
                            {
                                *pString = L'1';
                                *(pString + 1) = 0;
                                break;
                            }
                        }
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szIPosSignPosn;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIPosSignPosn;
            }
            break;
        }
        case ( LOCALE_INEGSIGNPOSN ) :
        {
            //
            //  Use the INEGCURR value from the user portion of the
            //  registry, if it exists.
            //
            //      0  =>  0, 4, 14, 15
            //      1  =>  5, 8
            //      2  =>  3, 11
            //      3  =>  1, 6, 9, 13
            //      4  =>  2, 7, 10, 12
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                             NLS_VALUE_INEGCURR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'0' ) :
                    case ( L'4' ) :
                    {
                        *pString = L'0';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'5' ) :
                    case ( L'8' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'3' ) :
                    {
                        *pString = L'2';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'6' ) :
                    case ( L'9' ) :
                    {
                        *pString = L'3';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'2' ) :
                    case ( L'7' ) :
                    {
                        *pString = L'4';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'1' ) :
                    {
                        switch (*(pString + 1))
                        {
                            case ( 0 ) :
                            case ( L'3' ) :
                            default :
                            {
                                *pString = L'3';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'0' ) :
                            case ( L'2' ) :
                            {
                                *pString = L'4';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'1' ) :
                            {
                                *pString = L'2';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'4' ) :
                            case ( L'5' ) :
                            {
                                *pString = L'0';
                                *(pString + 1) = 0;
                                break;
                            }
                        }
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szINegSignPosn;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szINegSignPosn;
            }
            break;
        }
        case ( LOCALE_IPOSSYMPRECEDES ) :
        {
            //
            //  Use the ICURRENCY value from the user portion of the
            //  registry, if it exists.
            //
            //      0  =>  1, 3
            //      1  =>  0, 2
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iCurrency),
                             NLS_VALUE_ICURRENCY,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'1' ) :
                    case ( L'3' ) :
                    {
                        *pString = L'0';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'0' ) :
                    case ( L'2' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szIPosSymPrecedes;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIPosSymPrecedes;
            }
            break;
        }
        case ( LOCALE_IPOSSEPBYSPACE ) :
        {
            //
            //  Use the ICURRENCY value from the user portion of the
            //  registry, if it exists.
            //
            //      0  =>  0, 1
            //      1  =>  2, 3
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iCurrency),
                             NLS_VALUE_ICURRENCY,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'0' ) :
                    case ( L'1' ) :
                    {
                        *pString = L'0';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'2' ) :
                    case ( L'3' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szIPosSepBySpace;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIPosSepBySpace;
            }
            break;
        }
        case ( LOCALE_INEGSYMPRECEDES ) :
        {
            //
            //  Use the INEGCURR value from the user portion of the
            //  registry, if it exists.
            //
            //      0  =>  4, 5, 6, 7, 8, 10, 13, 15
            //      1  =>  0, 1, 2, 3, 9, 11, 12, 14
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                             NLS_VALUE_INEGCURR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'4' ) :
                    case ( L'5' ) :
                    case ( L'6' ) :
                    case ( L'7' ) :
                    case ( L'8' ) :
                    {
                        *pString = L'0';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'0' ) :
                    case ( L'2' ) :
                    case ( L'3' ) :
                    case ( L'9' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'1' ) :
                    {
                        if ((*(pString + 1) == L'0') ||
                            (*(pString + 1) == L'3') ||
                            (*(pString + 1) == L'5'))
                        {
                            *pString = L'0';
                            *(pString + 1) = 0;
                        }
                        else
                        {
                            *pString = L'1';
                            *(pString + 1) = 0;
                        }
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szINegSymPrecedes;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szINegSymPrecedes;
            }
            break;
        }
        case ( LOCALE_INEGSEPBYSPACE ) :
        {
            //
            //  Use the INEGCURR value from the user portion of the
            //  registry, if it exists.
            //
            //      0  =>  0, 1, 2, 3, 4, 5, 6, 7
            //      1  =>  8, 9, 10, 11, 12, 13, 14, 15
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                             NLS_VALUE_INEGCURR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'0' ) :
                    case ( L'2' ) :
                    case ( L'3' ) :
                    case ( L'4' ) :
                    case ( L'5' ) :
                    case ( L'6' ) :
                    case ( L'7' ) :
                    {
                        *pString = L'0';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'8' ) :
                    case ( L'9' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'1' ) :
                    {
                        if (*(pString + 1) == 0)
                        {
                            *pString = L'0';
                            *(pString + 1) = 0;
                        }
                        else
                        {
                            *pString = L'1';
                            *(pString + 1) = 0;
                        }
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szINegSepBySpace;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szINegSepBySpace;
            }
            break;
        }
        case ( LOCALE_STIMEFORMAT ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sTimeFormat),
                             NLS_VALUE_STIMEFORMAT,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->STimeFormat;
            }
            break;
        }
        case ( LOCALE_STIME ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sTime),
                             NLS_VALUE_STIME,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->STime;
            }
            break;
        }
        case ( LOCALE_ITIME ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iTime),
                             NLS_VALUE_ITIME,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szITime;
            }
            break;
        }
        case ( LOCALE_ITLZERO ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iTLZero),
                             NLS_VALUE_ITLZERO,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szITLZero;
            }
            break;
        }
        case ( LOCALE_ITIMEMARKPOSN ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iTimeMarkPosn),
                             NLS_VALUE_ITIMEMARKPOSN,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szITimeMarkPosn;
            }
            break;
        }
        case ( LOCALE_S1159 ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, s1159),
                             NLS_VALUE_S1159,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->S1159;
            }
            break;
        }
        case ( LOCALE_S2359 ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, s2359),
                             NLS_VALUE_S2359,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->S2359;
            }
            break;
        }
        case ( LOCALE_SSHORTDATE ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sShortDate),
                             NLS_VALUE_SSHORTDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SShortDate;
            }
            break;
        }
        case ( LOCALE_SDATE ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sDate),
                             NLS_VALUE_SDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SDate;
            }
            break;
        }
        case ( LOCALE_IDATE ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iDate),
                             NLS_VALUE_IDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIDate;
            }
            break;
        }
        case ( LOCALE_ICENTURY ) :
        {
            //
            //  Use the short date picture to get this information.
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sShortDate),
                             NLS_VALUE_SSHORTDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Find out how many y's in string.
                //  No need to ignore quotes in short date.
                //
                pTmp = pString;
                while ((*pTmp) &&
                       (*pTmp != L'y'))
                {
                    pTmp++;
                }

                //
                //  Set the appropriate value in pString.
                //
                if (*pTmp == L'y')
                {
                    //
                    //  Get the number of 'y' repetitions in the format string.
                    //
                    pTmp++;
                    for (Repeat = 0; (*pTmp == L'y'); Repeat++, pTmp++)
                        ;

                    switch (Repeat)
                    {
                        case ( 0 ) :
                        case ( 1 ) :
                        {
                            //
                            //  Two-digit century with leading zero.
                            //
                            *pString = L'0';
                            *(pString + 1) = 0;

                            break;
                        }

                        case ( 2 ) :
                        case ( 3 ) :
                        default :
                        {
                            //
                            //  Full century.
                            //
                            *pString = L'1';
                            *(pString + 1) = 0;

                            break;
                        }
                    }

                    break;
                }
            }

            //
            //  Use the system default value.
            //
            pString = pHashN->pLocaleFixed->szICentury;

            break;
        }
        case ( LOCALE_IDAYLZERO ) :
        {
            //
            //  Use the short date picture to get this information.
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sShortDate),
                             NLS_VALUE_SSHORTDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Find out how many d's in string.
                //  No need to ignore quotes in short date.
                //
                pTmp = pString;
                while ((*pTmp) &&
                       (*pTmp != L'd'))
                {
                    pTmp++;
                }

                //
                //  Set the appropriate value in pString.
                //
                if (*pTmp == L'd')
                {
                    //
                    //  Get the number of 'd' repetitions in the format string.
                    //
                    pTmp++;
                    for (Repeat = 0; (*pTmp == L'd'); Repeat++, pTmp++)
                        ;

                    switch (Repeat)
                    {
                        case ( 0 ) :
                        {
                            //
                            //  No leading zero.
                            //
                            *pString = L'0';
                            *(pString + 1) = 0;

                            break;
                        }

                        case ( 1 ) :
                        default :
                        {
                            //
                            //  Use leading zero.
                            //
                            *pString = L'1';
                            *(pString + 1) = 0;

                            break;
                        }
                    }

                    break;
                }
            }

            //
            //  Use the system default value.
            //
            pString = pHashN->pLocaleFixed->szIDayLZero;

            break;
        }
        case ( LOCALE_IMONLZERO ) :
        {
            //
            //  Use the short date picture to get this information.
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sShortDate),
                             NLS_VALUE_SSHORTDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Find out how many M's in string.
                //  No need to ignore quotes in short date.
                //
                pTmp = pString;
                while ((*pTmp) &&
                       (*pTmp != L'M'))
                {
                    pTmp++;
                }

                //
                //  Set the appropriate value in pString.
                //
                if (*pTmp == L'M')
                {
                    //
                    //  Get the number of 'M' repetitions in the format string.
                    //
                    pTmp++;
                    for (Repeat = 0; (*pTmp == L'M'); Repeat++, pTmp++)
                        ;

                    switch (Repeat)
                    {
                        case ( 0 ) :
                        {
                            //
                            //  No leading zero.
                            //
                            *pString = L'0';
                            *(pString + 1) = 0;

                            break;
                        }

                        case ( 1 ) :
                        default :
                        {
                            //
                            //  Use leading zero.
                            //
                            *pString = L'1';
                            *(pString + 1) = 0;

                            break;
                        }
                    }

                    break;
                }
            }

            //
            //  Use the system default value.
            //
            pString = pHashN->pLocaleFixed->szIMonLZero;

            break;
        }
        case ( LOCALE_SYEARMONTH ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sYearMonth),
                             NLS_VALUE_SYEARMONTH,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SYearMonth;
            }
            break;
        }
        case ( LOCALE_SLONGDATE ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sLongDate),
                             NLS_VALUE_SLONGDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SLongDate;
            }
            break;
        }
        case ( LOCALE_ILDATE ) :
        {
            //
            //  Use the long date picture to get this information.
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sLongDate),
                             NLS_VALUE_SLONGDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Find out if d, M, or y is first, but ignore quotes.
                //  Also, if "ddd" or "dddd" is found, then skip it.  Only
                //  want "d" or "dd".
                //
                pTmp = pString;
                while (pTmp = wcspbrk(pTmp, L"dMy'"))
                {
                    //
                    //  Check special cases.
                    //
                    if (*pTmp == L'd')
                    {
                        //
                        //  Check for d's.  Ignore more than 2 d's.
                        //
                        for (Repeat = 0; (*pTmp == L'd'); Repeat++, pTmp++)
                            ;

                        if (Repeat < 3)
                        {
                            //
                            //  Break out of while loop.  Found "d" or "dd".
                            //
                            pTmp--;
                            break;
                        }
                    }
                    else if (*pTmp == NLS_CHAR_QUOTE)
                    {
                        //
                        //  Ignore quotes.
                        //
                        pTmp++;
                        while ((*pTmp) && (*pTmp != NLS_CHAR_QUOTE))
                        {
                            pTmp++;
                        }
                        pTmp++;
                    }
                    else
                    {
                        //
                        //  Found one of the values, so break out of
                        //  while loop.
                        //
                        break;
                    }
                }

                //
                //  Set the appropriate value in pString.
                //
                if (pTmp)
                {
                    switch (*pTmp)
                    {
                        case ( L'd' ) :
                        {
                            *pString = L'1';
                            break;
                        }
                        case ( L'M' ) :
                        {
                            *pString = L'0';
                            break;
                        }
                        case ( L'y' ) :
                        {
                            *pString = L'2';
                            break;
                        }
                    }

                    //
                    //  Null terminate the string.
                    //
                    *(pString + 1) = 0;

                    break;
                }
            }

            //
            //  Use the default value.
            //
            pString = pHashN->pLocaleFixed->szILDate;

            break;
        }
        case ( LOCALE_ICALENDARTYPE ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iCalType),
                             NLS_VALUE_ICALENDARTYPE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szICalendarType;
            }
            break;
        }
        case ( LOCALE_IOPTIONALCALENDAR ) :
        {
            Base = 10;
            pString = pStart + pHashN->pLocaleHdr->IOptionalCal;
            pString = ((POPT_CAL)pString)->pCalStr;
            break;
        }
        case ( LOCALE_IFIRSTDAYOFWEEK ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iFirstDay),
                             NLS_VALUE_IFIRSTDAYOFWEEK,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIFirstDayOfWk;
            }
            break;
        }
        case ( LOCALE_IFIRSTWEEKOFYEAR ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iFirstWeek),
                             NLS_VALUE_IFIRSTWEEKOFYEAR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIFirstWkOfYr;
            }
            break;
        }
        case ( LOCALE_SDAYNAME1 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName1;
            break;
        }
        case ( LOCALE_SDAYNAME2 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName2;
            break;
        }
        case ( LOCALE_SDAYNAME3 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName3;
            break;
        }
        case ( LOCALE_SDAYNAME4 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName4;
            break;
        }
        case ( LOCALE_SDAYNAME5 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName5;
            break;
        }
        case ( LOCALE_SDAYNAME6 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName6;
            break;
        }
        case ( LOCALE_SDAYNAME7 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName7;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME1 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName1;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME2 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName2;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME3 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName3;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME4 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName4;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME5 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName5;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME6 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName6;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME7 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName7;
            break;
        }
        case ( LOCALE_SMONTHNAME1 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName1;
            break;
        }
        case ( LOCALE_SMONTHNAME2 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName2;
            break;
        }
        case ( LOCALE_SMONTHNAME3 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName3;
            break;
        }
        case ( LOCALE_SMONTHNAME4 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName4;
            break;
        }
        case ( LOCALE_SMONTHNAME5 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName5;
            break;
        }
        case ( LOCALE_SMONTHNAME6 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName6;
            break;
        }
        case ( LOCALE_SMONTHNAME7 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName7;
            break;
        }
        case ( LOCALE_SMONTHNAME8 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName8;
            break;
        }
        case ( LOCALE_SMONTHNAME9 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName9;
            break;
        }
        case ( LOCALE_SMONTHNAME10 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName10;
            break;
        }
        case ( LOCALE_SMONTHNAME11 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName11;
            break;
        }
        case ( LOCALE_SMONTHNAME12 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName12;
            break;
        }
        case ( LOCALE_SMONTHNAME13 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName13;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME1 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName1;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME2 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName2;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME3 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName3;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME4 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName4;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME5 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName5;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME6 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName6;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME7 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName7;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME8 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName8;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME9 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName9;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME10 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName10;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME11 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName11;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME12 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName12;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME13 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName13;
            break;
        }
        case ( LOCALE_FONTSIGNATURE ) :
        {
            //
            //  Check cchData for size of given buffer.
            //
            if (cchData == 0)
            {
                return (MAX_FONTSIGNATURE);
            }
            else if (cchData < MAX_FONTSIGNATURE)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }

            //
            //  This string does NOT get zero terminated.
            //
            pString = pHashN->pLocaleFixed->szFontSignature;

            //
            //  Copy the string to lpLCData and return the number of
            //  characters copied.
            //
            RtlMoveMemory(lpLCData, pString, MAX_FONTSIGNATURE * sizeof(WCHAR));
            return (MAX_FONTSIGNATURE);

            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
    }

    //
    //  See if the caller wants the value in the form of a number instead
    //  of a string.
    //
    if (ReturnNum)
    {
        //
        //  Make sure the flags are valid and there is enough buffer
        //  space.
        //
        if (Base == 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
        if (cchData < 2)
        {
            if (cchData == 0)
            {
                //
                //  DWORD is needed for this option (2 WORDS), so return 2.
                //
                return (2);
            }

            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }

        //
        //  Convert the string to an int and return 2 (1 DWORD = 2 WORDS).
        //
        RtlInitUnicodeString(&ObUnicodeStr, pString);
        if (RtlUnicodeStringToInteger(&ObUnicodeStr, Base, (LPDWORD)lpLCData))
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
        return (2);
    }

    //
    //  Get the length (in characters) of the string to copy.
    //
    if (Length == 0)
    {
        Length = NlsStrLenW(pString);
    }

    //
    //  Add one for the null termination.  All strings should be null
    //  terminated.
    //
    Length++;

    //
    //  Check cchData for size of given buffer.
    //
    if (cchData == 0)
    {
        //
        //  If cchData is 0, then we can't use lpLCData.  In this
        //  case, we simply want to return the length (in characters) of
        //  the string to be copied.
        //
        return (Length);
    }
    else if (cchData < Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Copy the string to lpLCData and null terminate it.
    //  Return the number of characters copied.
    //
    wcsncpy(lpLCData, pString, Length - 1);
    lpLCData[Length - 1] = 0;
    return (Length);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetLocaleInfoW
//
//  Sets one of the various pieces of information about a particular
//  locale by making an entry in the user's portion of the configuration
//  registry.  This will only affect the user override portion of the locale
//  settings.  The system defaults will never be reset.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI SetLocaleInfoW(
    LCID Locale,
    LCTYPE LCType,
    LPCWSTR lpLCData)
{
    PLOC_HASH pHashN;                       // ptr to LOC hash node
    int cchData;                            // length of lpLCData
    LPWSTR pString;                         // ptr to info string to change
    LPWSTR pPos;                            // ptr to position in info string
    LPWSTR pPos2;                           // ptr to position in info string
    LPWSTR pSep;                            // ptr to separator string
    WCHAR pTemp[MAX_PATH_LEN];              // ptr to temp storage buffer
    WCHAR pOutput[MAX_REG_VAL_SIZE];        // ptr to output for GetInfo call
    WCHAR pOutput2[MAX_REG_VAL_SIZE];       // ptr to output for GetInfo call
    UINT Order;                             // date or time order value
    UINT TLZero;                            // time leading zero value
    UINT TimeMarkPosn;                      // time mark position value
    WCHAR pFind[3];                         // ptr to chars to find
    int SepLen;                             // length of separator string
    UNICODE_STRING ObUnicodeStr;            // value string
    int Value;                              // value


    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - NULL data pointer
    //
    //  NOTE: invalid type is checked in the switch statement below.
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ((pHashN == NULL) || (lpLCData == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Get the length of the buffer.
    //
    cchData = NlsStrLenW(lpLCData) + 1;

    //
    //  Initialize temp buffer.
    //
    pTemp[0] = 0;

    //
    //  Set the appropriate user information for the given LCTYPE.
    //
    LCType &= (~LOCALE_USE_CP_ACP);
    switch (LCType)
    {
        case ( LOCALE_SLIST ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SLIST wide characters in length.
            //
            if (cchData > MAX_SLIST)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SLIST string.
            //
            return (SetUserInfo( LOCALE_SLIST,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IMEASURE ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_IMEASURE wide characters in length.
            //  It should be between 0 and MAX_VALUE_IMEASURE.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_IMEASURE is 2.
            //
            if ((cchData != MAX_IMEASURE) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_IMEASURE))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IMEASURE string.
            //
            return (SetUserInfo( LOCALE_IMEASURE,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IPAPERSIZE ) :
        {
            //
            //  Validate the new value.
            //  It should be between DMPAPER_LETTER and DMPAPER_LAST.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            RtlInitUnicodeString(&ObUnicodeStr, lpLCData);
            if ((cchData < 2) ||
                (RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value)) ||
                (Value < DMPAPER_LETTER) || (Value > DMPAPER_LAST))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IPAPERSIZE string.
            //
            return (SetUserInfo( LOCALE_IPAPERSIZE,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SDECIMAL ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SDECIMAL wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SDECIMAL,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SDECIMAL string.
            //
            return (SetUserInfo( LOCALE_SDECIMAL,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_STHOUSAND ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_STHOUSAND wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_STHOUSAND,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new STHOUSAND string.
            //
            return (SetUserInfo( LOCALE_STHOUSAND,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SGROUPING ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SGROUPING wide characters in length and should
            //  contain alternating integer and semicolon values.
            //       (eg. 3;2;0  or  3;0  or  0)
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if (!IsValidGroupingString( lpLCData,
                                        MAX_SGROUPING,
                                        TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SGROUPING string.
            //
            return (SetUserInfo( LOCALE_SGROUPING,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IDIGITS ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_IDIGITS wide characters in length.
            //  The value should be between 0 and MAX_VALUE_IDIGITS.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_IDIGITS is 2.
            //
            if ((cchData != MAX_IDIGITS) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_IDIGITS))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IDIGITS string.
            //
            return (SetUserInfo( LOCALE_IDIGITS,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_ILZERO ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_ILZERO wide characters in length.
            //  The value should be between 0 and MAX_VALUE_ILZERO.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_ILZERO is 2.
            //
            if ((cchData != MAX_ILZERO) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_ILZERO))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new ILZERO string.
            //
            return (SetUserInfo( LOCALE_ILZERO,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_INEGNUMBER ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_INEGNUMBER wide characters in length.
            //  The value should be between 0 and MAX_VALUE_INEGNUMBER.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_INEGNUMBER is 2.
            //
            if ((cchData != MAX_INEGNUMBER) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_INEGNUMBER))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new INEGNUMBER string.
            //
            return (SetUserInfo( LOCALE_INEGNUMBER,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SNATIVEDIGITS ) :
        {
            //
            //  Validate the new value.  It should be exactly
            //  MAX_SNATIVEDIGITS wide characters in length.
            //
            if (cchData != MAX_SNATIVEDIGITS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SNATIVEDIGITS string.
            //
            return (SetUserInfo( LOCALE_SNATIVEDIGITS,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IDIGITSUBSTITUTION ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_IDIGITSUBST wide characters in length.
            //  The value should be between 0 and MAX_VALUE_IDIGITSUBST.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_IDIGITSUBST is 2.
            //
            if ((cchData != MAX_IDIGITSUBST) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_IDIGITSUBST))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IDIGITSUBST string.
            //
            return (SetUserInfo( LOCALE_IDIGITSUBSTITUTION,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SCURRENCY ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SCURRENCY wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SCURRENCY,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SCURRENCY string.
            //
            return (SetUserInfo( LOCALE_SCURRENCY,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SMONDECIMALSEP ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SMONDECSEP wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SMONDECSEP,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SMONDECIMALSEP string.
            //
            return (SetUserInfo( LOCALE_SMONDECIMALSEP,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SMONTHOUSANDSEP ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SMONTHOUSEP wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SMONTHOUSEP,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SMONTHOUSANDSEP string.
            //
            return (SetUserInfo( LOCALE_SMONTHOUSANDSEP,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SMONGROUPING ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SMONGROUPING wide characters in length and should
            //  contain alternating integer and semicolon values.
            //       (eg. 3;2;0  or  3;0  or  0)
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if (!IsValidGroupingString( lpLCData,
                                        MAX_SMONGROUPING,
                                        TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SMONGROUPING string.
            //
            return (SetUserInfo( LOCALE_SMONGROUPING,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_ICURRDIGITS ) :
        {
            //
            //  Validate the new value.
            //  The value should be between 0 and MAX_VALUE_ICURRDIGITS.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            RtlInitUnicodeString(&ObUnicodeStr, lpLCData);
            if ((cchData < 2) ||
                (RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value)) ||
                (Value < 0) || (Value > MAX_VALUE_ICURRDIGITS) ||
                ((Value == 0) &&
                 ((*lpLCData != NLS_CHAR_ZERO) || (cchData != 2))))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new ICURRDIGITS string.
            //
            return (SetUserInfo( LOCALE_ICURRDIGITS,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_ICURRENCY ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_ICURRENCY wide characters in length.
            //  The value should be between 0 and MAX_VALUE_ICURRENCY.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_ICURRENCY is 2.
            //
            if ((cchData != MAX_ICURRENCY) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_ICURRENCY))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new ICURRENCY string.
            //
            return (SetUserInfo( LOCALE_ICURRENCY,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_INEGCURR ) :
        {
            //
            //  Validate the new value.
            //  The value should be between 0 and MAX_VALUE_INEGCURR.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            RtlInitUnicodeString(&ObUnicodeStr, lpLCData);
            if ((cchData < 2) ||
                (RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value)) ||
                (Value < 0) || (Value > MAX_VALUE_INEGCURR) ||
                ((Value == 0) &&
                 ((*lpLCData != NLS_CHAR_ZERO) || (cchData != 2))))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new INEGCURR string.
            //
            return (SetUserInfo( LOCALE_INEGCURR,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SPOSITIVESIGN ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SPOSSIGN wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SPOSSIGN,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SPOSITIVESIGN string.
            //
            return (SetUserInfo( LOCALE_SPOSITIVESIGN,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SNEGATIVESIGN ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SNEGSIGN wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SNEGSIGN,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SNEGATIVESIGN string.
            //
            return (SetUserInfo( LOCALE_SNEGATIVESIGN,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_STIMEFORMAT ) :
        {
            BOOL bInsideQuotedString = FALSE;

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_STIMEFORMAT wide characters in length.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).  This is checked below
            //        in the check for whether or not there is an hour
            //        delimeter.
            //
            if (cchData > MAX_STIMEFORMAT)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  NOTE: Must link the STIME, ITIME, ITLZERO, and
            //        ITIMEMARKPOSN values in the registry.
            //

            //
            //  Search for H or h, so that iTime and iTLZero can be
            //  set.  If no H or h exists, return an error. Note: the
            //  combinations "hH" or "Hh" are invalid.
            //
            pPos = (LPWSTR)lpLCData;
            while ((pPos = wcspbrk(pPos, L"Hh'")))
            {
                if (*pPos == L'\'')
                {
                    //
                    //  Enter or leave a quoted string.
                    //
                    bInsideQuotedString &= ~TRUE;
                }
                else if (*pPos == L'H')
                {
                    //
                    //  Found an H.
                    //
                    if (!bInsideQuotedString)
                    {
                        //
                        //  Get the appropriate ITIME value.
                        //
                        Order = 1;

                        //
                        //  Get the appropriate ITLZERO value.
                        //
                        if (*(pPos + 1) == L'H')
                        {
                            TLZero = 1;
                            break;
                        }
                        else if (*(pPos + 1) == L'h')
                        {
                            //
                            //  Invalid combination.
                            //
                            pPos = NULL;
                            break;
                        }
                        else
                        {
                            TLZero = 0;
                            break;
                        }
                    }
                }
                else if (*pPos == L'h')
                {
                    //
                    //  Found an h.
                    //
                    if (!bInsideQuotedString)
                    {
                        //
                        //  Get the appropriate ITIME value.
                        //
                        Order = 0;

                        //
                        //  Get the appropriate ITLZERO value.
                        //
                        if (*(pPos + 1) == L'h')
                        {
                            TLZero = 1;
                            break;
                        }
                        else if (*(pPos + 1) == L'H')
                        {
                            //
                            //  Invalid combination.
                            //
                            pPos = NULL;
                            break;
                        }
                        else
                        {
                            TLZero = 0;
                            break;
                        }
                    }
                }
                pPos++;
            }

            //
            //  If pPos == NULL, then one of two things happened:
            //    - reached the end of the string without finding "H" or "h"
            //    - found an invalid combination like "hH" or "Hh"
            //
            if (!pPos)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Search for tt, so that ITIMEMARKPOSN can be
            //  set.  If no tt exists, do not change the value.
            //
            bInsideQuotedString = FALSE;
            pPos = (LPWSTR)lpLCData;
            while ((pPos = wcspbrk(pPos, L"t'")))
            {
                if (*pPos == L'\'')
                {
                    //
                    //  Enter or leave a quoted string.
                    //
                    bInsideQuotedString &= ~TRUE;
                }
                else if (*(pPos + 1) == L't')
                {
                    if (!bInsideQuotedString)
                    {
                        //
                        //  The string "tt" is found.
                        //
                        break;
                    }
                }
                pPos++;
            }
            if (pPos)
            {
                //
                //  Get the appropriate ITIMEMARKPOSN value.
                //
                bInsideQuotedString = FALSE;
                pPos2 = (LPWSTR)lpLCData;
                while ((pPos2 = wcspbrk(pPos2, L"Hhmst'")))
                {
                    if (*pPos == L'\'')
                    {
                        //
                        //  Enter or leave a quoted string.
                        //
                        bInsideQuotedString &= ~TRUE;
                    }
                    else
                    {
                        if (!bInsideQuotedString)
                        {
                            //
                            //  Get the appropriate ITIMEMARKPOSN value.
                            //
                            TimeMarkPosn = (pPos == pPos2) ? 1 : 0;
                            break;
                        }
                    }
                    pPos2++;
                }
            }

            //
            //  Find the time separator so that STIME can be set.
            //
            bInsideQuotedString = FALSE;
            pPos = (LPWSTR)lpLCData;
            while (pPos = wcspbrk(pPos, L"Hhms'"))
            {
                if (*pPos == L'\'')
                {
                    //
                    //  Enter or leave a quoted string.
                    //
                    bInsideQuotedString &= ~TRUE;
                    pPos++;
                }
                else
                {
                    if (!bInsideQuotedString)
                    {
                        //
                        //  Look for the beginning of the time separator.
                        //
                        pPos++;
                        while ((*pPos) && (wcschr(L"Hhms", *pPos)))
                        {
                            pPos++;
                        }

                        //
                        //  Look for the end of the time separator.
                        //
                        if (*pPos)
                        {
                            //
                            //  Find the end of the separator string.
                            //
                            pPos2 = wcspbrk(pPos, L"Hhmst");
                            if (pPos2)
                            {
                                if (*pPos2 == L't')
                                {
                                    //
                                    //  Found a time marker, so need to start
                                    //  over in search for separator.  There
                                    //  are no separators around the time
                                    //  marker.
                                    //
                                    pPos = pPos2 + 1;
                                }
                                else
                                {
                                    //
                                    //  Found end of separator, so break out of
                                    //  while loop.
                                    //
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        pPos++;
                    }
                }
            }

            //
            //  Get the appropriate STIME string.
            //
            if (pPos)
            {
                //
                //  Copy to temp buffer so that it's zero terminated.
                //
                pString = pTemp;
                while (pPos != pPos2)
                {
                    //
                    //  If there is a quoted string in the separator, then
                    //  just put in a white space, since there is no meaning
                    //  for time field separator anymore.
                    //
                    if (*pPos == L'\'')
                    {
                        pString = pTemp;
                        *pString++ = L' ';
                        break;
                    }

                    *pString = *pPos;
                    pPos++;
                    pString++;
                }
                *pString = 0;
            }
            else
            {
                //
                //  There is no time separator, so use NULL.
                //
                *pTemp = 0;
            }

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_STIME wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if (!IsValidSeparatorString( pTemp,
                                         MAX_STIME,
                                         TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure that the time separator does NOT contain any
            //  of the special time picture characters - h, H, m, s, t, '.
            //
            if (wcspbrk(pTemp, L"Hhmst'"))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Call the server to set the registry.
            //
            return (SetMultipleUserInfo( LCType,
                                         cchData,
                                         lpLCData,
                                         pTemp,
                                         (Order == 0) ? L"0" : L"1",
                                         (TLZero == 0) ? L"0" : L"1",
                                         (TimeMarkPosn == 0) ? L"0" : L"1" ));
            break;
        }
        case ( LOCALE_STIME ) :
        {
            //
            //  NOTE: Must link the STIMEFORMAT value in the registry.
            //

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_STIME wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_STIME,
                                         TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure that the time separator does NOT contain any
            //  of the special time picture characters - h, H, m, s, t, '.
            //
            if (wcspbrk(lpLCData, L"Hhmst'"))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Get the current setting for STIMEFORMAT.
            //
            if (GetUserInfo( Locale,
                             LOCALE_STIMEFORMAT,
                             FIELD_OFFSET(NLS_USER_INFO, sTimeFormat),
                             NLS_VALUE_STIMEFORMAT,
                             pOutput,
                             ARRAYSIZE(pOutput),
                             TRUE ))
            {
                pString = pOutput;
            }
            else
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          pHashN->pLocaleHdr->STimeFormat;
            }

            //
            //  Get the current setting for STIME.
            //
            if (GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sTime),
                             NLS_VALUE_STIME,
                             pOutput2,
                             ARRAYSIZE(pOutput2),
                             TRUE ))
            {
                pSep = pOutput2;
            }
            else
            {
                pSep = (LPWORD)(pHashN->pLocaleHdr) +
                       pHashN->pLocaleHdr->STime;
            }

            //
            //  Get the length of the separator string.
            //
            SepLen = NlsStrLenW(pSep);

            //
            //  Setup the string containing the characters to find in
            //  the timeformat string.
            //
            pFind[0] = NLS_CHAR_QUOTE;
            pFind[1] = *pSep;
            pFind[2] = 0;

            //
            //  Find the time separator in the STIMEFORMAT string and
            //  replace it with the new time separator.
            //
            //  The new separator may be a different length than
            //  the old one, so must use a static buffer for the new
            //  time format string.
            //
            pPos = pTemp;
            while (pPos2 = wcspbrk(pString, pFind))
            {
                //
                //  Copy format string up to pPos2.
                //
                while (pString < pPos2)
                {
                    *pPos = *pString;
                    pPos++;
                    pString++;
                }

                switch (*pPos2)
                {
                    case ( NLS_CHAR_QUOTE ) :
                    {
                        //
                        //  Copy the quote.
                        //
                        *pPos = *pString;
                        pPos++;
                        pString++;

                        //
                        //  Copy what's inside the quotes.
                        //
                        while ((*pString) && (*pString != NLS_CHAR_QUOTE))
                        {
                            *pPos = *pString;
                            pPos++;
                            pString++;
                        }

                        //
                        //  Copy the end quote.
                        //
                        *pPos = NLS_CHAR_QUOTE;
                        pPos++;
                        if (*pString)
                        {
                            pString++;
                        }

                        break;
                    }
                    default :
                    {
                        //
                        //  Make sure it's the old separator.
                        //
                        if (NlsStrNEqualW(pString, pSep, SepLen))
                        {
                            //
                            //  Adjust pointer to skip over old separator.
                            //
                            pString += SepLen;

                            //
                            //  Copy the new separator.
                            //
                            pPos2 = (LPWSTR)lpLCData;
                            while (*pPos2)
                            {
                                *pPos = *pPos2;
                                pPos++;
                                pPos2++;
                            }
                        }
                        else
                        {
                            //
                            //  Copy the code point and continue.
                            //
                            *pPos = *pString;
                            pPos++;
                            pString++;
                        }

                        break;
                    }
                }
            }

            //
            //  Copy to the end of the string and null terminate it.
            //
            while (*pString)
            {
                *pPos = *pString;
                pPos++;
                pString++;
            }
            *pPos = 0;

            //
            //  Call the server to set the registry.
            //
            return (SetMultipleUserInfo( LCType,
                                         cchData,
                                         pTemp,
                                         lpLCData,
                                         NULL,
                                         NULL,
                                         NULL ));
            break;
        }
        case ( LOCALE_ITIME ) :
        {
            //
            //  NOTE: Must link the STIMEFORMAT value in the registry.
            //

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_ITIME wide characters in length.
            //  The value should be either 0 or MAX_VALUE_ITIME.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_ITIME is 2.
            //
            if ((cchData != MAX_ITIME) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_ITIME))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Get the current setting for STIMEFORMAT.
            //
            if (GetUserInfo( Locale,
                             LOCALE_STIMEFORMAT,
                             FIELD_OFFSET(NLS_USER_INFO, sTimeFormat),
                             NLS_VALUE_STIMEFORMAT,
                             pOutput,
                             ARRAYSIZE(pOutput),
                             TRUE ))
            {
                pString = pOutput;
            }
            else
            {
                //
                //  Copy system default to temp buffer.
                //
                if(FAILED( StringCchCopyW( pTemp,
                                            ARRAYSIZE(pTemp),
                                            (LPWORD)(pHashN->pLocaleHdr) +
                                            pHashN->pLocaleHdr->STimeFormat ) ))
                {
                    //
                    // Failure should in theory be impossible, but if we ignore the
                    // return value, PREfast will complain.
                    //
                    SetLastError(ERROR_OUTOFMEMORY);
                    return(FALSE);
                }
                pString = pTemp;
            }

            //
            //  Search down the STIMEFORMAT string.
            //  If iTime = 0, then H -> h.
            //  If iTime = 1, then h -> H.
            //
            pPos = pString;
            if (*lpLCData == NLS_CHAR_ZERO)
            {
                while (*pPos)
                {
                    if (*pPos == L'H')
                    {
                        *pPos = L'h';
                    }
                    pPos++;
                }
            }
            else
            {
                while (*pPos)
                {
                    if (*pPos == L'h')
                    {
                        *pPos = L'H';
                    }
                    pPos++;
                }
            }

            //
            //  Call the server to set the registry.
            //
            return (SetMultipleUserInfo( LCType,
                                         cchData,
                                         pString,
                                         NULL,
                                         lpLCData,
                                         NULL,
                                         NULL ));
            break;
        }
        case ( LOCALE_S1159 ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_S1159 wide characters in length.
            //
            if (cchData > MAX_S1159)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new S1159 string.
            //
            return (SetUserInfo( LOCALE_S1159,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_S2359 ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_S2359 wide characters in length.
            //
            if (cchData > MAX_S2359)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new S2359 string.
            //
            return (SetUserInfo( LOCALE_S2359,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SSHORTDATE ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SSHORTDATE wide characters in length.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).  This is checked below
            //        in the check for whether or not there is a date,
            //        month, or year delimeter.
            //
            if (cchData > MAX_SSHORTDATE)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  NOTE: Must link the IDATE and SDATE values in the registry.
            //

            //
            //  Search for the 'd' or 'M' or 'y' sequence in the date format
            //  string to set the new IDATE value.
            //
            //  If none of these symbols exist in the date format string,
            //  then return an error.
            //
            pPos = wcspbrk(lpLCData, L"dMy");
            if (!pPos)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the appropriate IDATE string.
            //
            switch (*pPos)
            {
                case ( L'M' ) :
                {
                    Order = 0;
                    break;
                }

                case ( L'd' ) :
                {
                    Order = 1;
                    break;
                }

                case ( L'y' ) :
                {
                    Order = 2;
                    break;
                }
            }

            //
            //  Set the registry with the appropriate SDATE string.
            //
            //  The ptr "pPos" is pointing at either d, M, or y.
            //  Go to the next position past sequence of d, M, or y.
            //
            pPos++;
            while ((*pPos) && (wcschr( L"dMy", *pPos )))
            {
                pPos++;
            }

            *pTemp = 0;
            if (*pPos)
            {
                //
                //  Find the end of the separator string.
                //
                pPos2 = wcspbrk(pPos, L"dMy");
                if (pPos2)
                {
                    //
                    //  Copy to temp buffer so that it's zero terminated.
                    //
                    pString = pTemp;
                    while (pPos != pPos2)
                    {
                        //
                        // If there is a quoted string in the separator, then
                        // just punch in a white space, since there is no meaning
                        // for short date field separator anymore.
                        //
                        if (*pPos == L'\'')
                        {
                            pString = pTemp;
                            *pString++ = L' ';
                            break;
                        }
                        *pString = *pPos;
                        pPos++;
                        pString++;
                    }
                    *pString = 0;
                }
            }

            //
            // Since the date separator (LOCALE_SDATE) is being set here, we
            // should do the same validation as LOCALE_SDATE.
            //
            if (!IsValidSeparatorString( pTemp,
                                         MAX_SDATE,
                                         TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure that the date separator does NOT contain any
            //  of the special date picture characters - d, M, y, g, '.
            //
            if (wcspbrk(pTemp, L"dMyg'"))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }



            //
            //  Call the server to set the registry.
            //
            return (SetMultipleUserInfo( LCType,
                                         cchData,
                                         lpLCData,
                                         pTemp,
                                         (Order == 0) ? L"0" :
                                             ((Order == 1) ? L"1" : L"2"),
                                         NULL,
                                         NULL ));
            break;
        }
        case ( LOCALE_SDATE ) :
        {
            //
            //  NOTE: Must link the SSHORTDATE value in the registry.
            //

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SDATE wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SDATE,
                                         TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure that the date separator does NOT contain any
            //  of the special date picture characters - d, M, y, g, '.
            //
            if (wcspbrk(lpLCData, L"dMyg'"))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Get the current setting for SSHORTDATE.
            //
            if (GetUserInfo( Locale,
                             LOCALE_SSHORTDATE,
                             FIELD_OFFSET(NLS_USER_INFO, sShortDate),
                             NLS_VALUE_SSHORTDATE,
                             pOutput,
                             ARRAYSIZE(pOutput),
                             TRUE ))
            {
                pString = pOutput;
            }
            else
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          pHashN->pLocaleHdr->SShortDate;
            }

            //
            //  Get the current setting for SDATE.
            //
            if (GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sDate),
                             NLS_VALUE_SDATE,
                             pOutput2,
                             ARRAYSIZE(pOutput2),
                             TRUE ))
            {
                pSep = pOutput2;
            }
            else
            {
                pSep = (LPWORD)(pHashN->pLocaleHdr) +
                       pHashN->pLocaleHdr->SDate;
            }

            //
            //  Get the length of the separator string.
            //
            SepLen = NlsStrLenW(pSep);

            //
            //  Setup the string containing the characters to find in
            //  the shortdate string.
            //
            pFind[0] = NLS_CHAR_QUOTE;
            pFind[1] = *pSep;
            pFind[2] = 0;

            //
            //  Find the date separator in the SSHORTDATE string and
            //  replace it with the new date separator.
            //
            //  The new separator may be a different length than
            //  the old one, so must use a static buffer for the new
            //  short date format string.
            //
            pPos = pTemp;
            while (pPos2 = wcspbrk(pString, pFind))
            {
                //
                //  Copy format string up to pPos2.
                //
                while (pString < pPos2)
                {
                    *pPos = *pString;
                    pPos++;
                    pString++;
                }

                switch (*pPos2)
                {
                    case ( NLS_CHAR_QUOTE ) :
                    {
                        //
                        //  Copy the quote.
                        //
                        *pPos = *pString;
                        pPos++;
                        pString++;

                        //
                        //  Copy what's inside the quotes.
                        //
                        while ((*pString) && (*pString != NLS_CHAR_QUOTE))
                        {
                            *pPos = *pString;
                            pPos++;
                            pString++;
                        }

                        //
                        //  Copy the end quote.
                        //
                        *pPos = NLS_CHAR_QUOTE;
                        pPos++;
                        if (*pString)
                        {
                            pString++;
                        }

                        break;
                    }
                    default :
                    {
                        //
                        //  Make sure it's the old separator.
                        //
                        if (NlsStrNEqualW(pString, pSep, SepLen))
                        {
                            //
                            //  Adjust pointer to skip over old separator.
                            //
                            pString += SepLen;

                            //
                            //  Copy the new separator.
                            //
                            pPos2 = (LPWSTR)lpLCData;
                            while (*pPos2)
                            {
                                *pPos = *pPos2;
                                pPos++;
                                pPos2++;
                            }
                        }
                        else
                        {
                            //
                            //  Copy the code point and continue.
                            //
                            *pPos = *pString;
                            pPos++;
                            pString++;
                        }

                        break;
                    }
                }
            }

            //
            //  Copy to the end of the string and null terminate it.
            //
            while (*pString)
            {
                *pPos = *pString;
                pPos++;
                pString++;
            }
            *pPos = 0;

            //
            //  Call the server to set the registry.
            //
            return (SetMultipleUserInfo( LCType,
                                         cchData,
                                         pTemp,
                                         lpLCData,
                                         NULL,
                                         NULL,
                                         NULL ));
            break;
        }
        case ( LOCALE_SYEARMONTH ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SYEARMONTH wide characters in length.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).  This is checked below
            //        in the check for whether or not there is a date,
            //        month, or year delimeter.
            //
            if (cchData > MAX_SYEARMONTH)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure one of 'M' or 'y' exists in the date
            //  format string.  If it does not, then return an error.
            //
            pPos = wcspbrk(lpLCData, L"My");
            if (!pPos)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SYEARMONTH string.
            //
            return (SetUserInfo( LOCALE_SYEARMONTH,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SLONGDATE ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SLONGDATE wide characters in length.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).  This is checked below
            //        in the check for whether or not there is a date,
            //        month, or year delimeter.
            //
            if (cchData > MAX_SLONGDATE)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure one of 'd' or 'M' or 'y' exists in the date
            //  format string.  If it does not, then return an error.
            //
            pPos = wcspbrk(lpLCData, L"dMy");
            if (!pPos)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SLONGDATE string.
            //
            return (SetUserInfo( LOCALE_SLONGDATE,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_ICALENDARTYPE ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_ICALTYPE wide characters in length.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if ((cchData < 2) || (cchData > MAX_ICALTYPE) ||
                (!IsValidCalendarTypeStr(pHashN, lpLCData)))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new ICALENDARTYPE string.
            //
            return (SetUserInfo( LOCALE_ICALENDARTYPE,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IFIRSTDAYOFWEEK ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_IFIRSTDAY wide characters in length.
            //  The value should be between 0 and MAX_VALUE_IFIRSTDAY.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_IFIRSTDAY is 2.
            //
            if ((cchData != MAX_IFIRSTDAY) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_IFIRSTDAY))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IFIRSTDAYOFWEEK string.
            //
            return (SetUserInfo( LOCALE_IFIRSTDAYOFWEEK,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IFIRSTWEEKOFYEAR ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_IFIRSTWEEK wide characters in length.
            //  The value should be between 0 and MAX_VALUE_IFIRSTWEEK.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_IFIRSTWEEK is 2.
            //
            if ((cchData != MAX_IFIRSTWEEK) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_IFIRSTWEEK))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IFIRSTWEEKOFYEAR string.
            //
            return (SetUserInfo( LOCALE_IFIRSTWEEKOFYEAR,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCalendarInfoW
//
//  Returns one of the various pieces of information about a particular
//  calendar by querying the configuration registry.  This call also
//  indicates how much memory is necessary to contain the desired
//  information.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetCalendarInfoW(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPWSTR lpCalData,
    int cchData,
    LPDWORD lpValue)
{
    PLOC_HASH pHashN;                       // ptr to LOC hash node
    int Length = 0;                         // length of info string
    LPWSTR pString;                         // ptr to the info string
    BOOL UserOverride = TRUE;               // use user override
    BOOL ReturnNum = FALSE;                 // return number instead of string
    WCHAR pTemp[MAX_REG_VAL_SIZE];          // temp buffer
    UNICODE_STRING ObUnicodeStr;            // value string
    int Base = 0;                           // base for str to int conversion
    LPWSTR pOptCal;                         // ptr to optional calendar values
    PCAL_INFO pCalInfo;                     // ptr to calendar info


    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ((pHashN == NULL) ||
        (cchData < 0) ||
        ((lpCalData == NULL) && (cchData != 0)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Need to check the parameters based on the CAL_RETURN_NUMBER
    //  CalType.
    //
    if (CalType & CAL_RETURN_NUMBER)
    {
        if ((lpCalData != NULL) || (cchData != 0) || (lpValue == NULL))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }
    else
    {
        if ((lpValue != NULL) ||
            (cchData < 0) ||
            ((lpCalData == NULL) && (cchData != 0)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    //
    //  Check for NO USER OVERRIDE flag and remove the USE CP ACP flag.
    //
    if (CalType & CAL_NOUSEROVERRIDE)
    {
        //
        //  Flag is set, so set the boolean value and remove the flag
        //  from the CalType parameter (for switch statement).
        //
        UserOverride = FALSE;
    }
    if (CalType & CAL_RETURN_NUMBER)
    {
        //
        //  Flag is set, so set the boolean value and remove the flag
        //  from the CalType parameter (for switch statement).
        //
        ReturnNum = TRUE;
    }
    CalType &= (~(CAL_NOUSEROVERRIDE | CAL_USE_CP_ACP | CAL_RETURN_NUMBER));

    //
    //  Validate the Calendar parameter.
    //
    if (((CalType != CAL_ITWODIGITYEARMAX) &&
         ((pOptCal = IsValidCalendarType(pHashN, Calendar)) == NULL)) ||
        (GetCalendar(Calendar, &pCalInfo) != NO_ERROR))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Return the appropriate information for the given CALTYPE.
    //  If user information exists for the given CALTYPE, then
    //  the user default is returned instead of the system default.
    //
    switch (CalType)
    {
        case ( CAL_ICALINTVALUE ) :
        {
            Base = 10;

            //
            //  Get the integer value for the given calendar.
            //
            pString = ((POPT_CAL)pOptCal)->pCalStr;

            break;
        }
        case ( CAL_SCALNAME ) :
        {
            //
            //  Get the calendar name for the given calendar.
            //
            pString = ((POPT_CAL)pOptCal)->pCalStr +
                      NlsStrLenW(((POPT_CAL)pOptCal)->pCalStr) + 1;

            break;
        }
        case ( CAL_ITWODIGITYEARMAX ) :
        {
            Base = 10;

            //
            // Check if a policy is enforced for the current user,
            // and if so, let's use it.
            //
            if (GetTwoDigitYearInfo(Calendar, pTemp, ARRAYSIZE(pTemp), NLS_POLICY_TWO_DIGIT_YEAR_KEY))
            {
                pString = pTemp;
            }
            else
            {
                if (UserOverride &&
                    GetTwoDigitYearInfo(Calendar, pTemp, ARRAYSIZE(pTemp), NLS_TWO_DIGIT_YEAR_KEY))
                {
                    pString = pTemp;
                }
                else
                {
                    //
                    //  Use the default.
                    //
                    pString = (LPWORD)pCalInfo +
                              (((PCALENDAR_VAR)pCalInfo)->STwoDigitYearMax);
                }
            }

            break;
        }
        case ( CAL_IYEAROFFSETRANGE ) :
        {
            Base = 10;

            //
            //  Get the pointer to the appropriate calendar string.
            //
            pString = (LPWORD)pCalInfo +
                      (((PCALENDAR_VAR)pCalInfo)->SEraRanges);

            //
            //  Make sure the string is NOT empty.
            //
            if (*pString)
            {
                pString = ((PERA_RANGE)pString)->pYearStr;
            }
            else
            {
                pString = L"0";
            }

            break;
        }
        case ( CAL_SERASTRING ) :
        {
            //
            //  Get the pointer to the appropriate calendar string.
            //
            pString = (LPWORD)pCalInfo +
                      (((PCALENDAR_VAR)pCalInfo)->SEraRanges);

            //
            //  Make sure the string is NOT empty.  If it is, return the
            //  empty string.
            //
            if (*pString)
            {
                pString = ((PERA_RANGE)pString)->pYearStr +
                          NlsStrLenW(((PERA_RANGE)pString)->pYearStr) + 1;
            }

            break;
        }
        case ( CAL_SSHORTDATE ) :
        {
            //
            //  Get the pointer to the appropriate calendar string.
            //
            pString = (LPWORD)pCalInfo +
                      (((PCALENDAR_VAR)pCalInfo)->SShortDate);

            //
            //  Make sure the string is NOT empty.  If it is, use the
            //  locale's short date string.
            //
            if (*pString == 0)
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          pHashN->pLocaleHdr->SShortDate;
            }

            break;
        }
        case ( CAL_SLONGDATE ) :
        {
            //
            //  Get the pointer to the appropriate calendar string.
            //
            pString = (LPWORD)pCalInfo +
                      (((PCALENDAR_VAR)pCalInfo)->SLongDate);

            //
            //  Make sure the string is NOT empty.  If it is, use the
            //  locale's long date string.
            //
            if (*pString == 0)
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          pHashN->pLocaleHdr->SLongDate;
            }

            break;
        }
        case ( CAL_SYEARMONTH ) :
        {
            //
            //  Get the pointer to the appropriate calendar string.
            //
            pString = (LPWORD)pCalInfo +
                      (((PCALENDAR_VAR)pCalInfo)->SYearMonth);

            //
            //  Make sure the string is NOT empty.  If it is, use the
            //  locale's year month string.
            //
            if (*pString == 0)
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          pHashN->pLocaleHdr->SYearMonth;
            }

            break;
        }
        case ( CAL_SDAYNAME1 ) :
        case ( CAL_SDAYNAME2 ) :
        case ( CAL_SDAYNAME3 ) :
        case ( CAL_SDAYNAME4 ) :
        case ( CAL_SDAYNAME5 ) :
        case ( CAL_SDAYNAME6 ) :
        case ( CAL_SDAYNAME7 ) :
        case ( CAL_SABBREVDAYNAME1 ) :
        case ( CAL_SABBREVDAYNAME2 ) :
        case ( CAL_SABBREVDAYNAME3 ) :
        case ( CAL_SABBREVDAYNAME4 ) :
        case ( CAL_SABBREVDAYNAME5 ) :
        case ( CAL_SABBREVDAYNAME6 ) :
        case ( CAL_SABBREVDAYNAME7 ) :
        case ( CAL_SMONTHNAME1 ) :
        case ( CAL_SMONTHNAME2 ) :
        case ( CAL_SMONTHNAME3 ) :
        case ( CAL_SMONTHNAME4 ) :
        case ( CAL_SMONTHNAME5 ) :
        case ( CAL_SMONTHNAME6 ) :
        case ( CAL_SMONTHNAME7 ) :
        case ( CAL_SMONTHNAME8 ) :
        case ( CAL_SMONTHNAME9 ) :
        case ( CAL_SMONTHNAME10 ) :
        case ( CAL_SMONTHNAME11 ) :
        case ( CAL_SMONTHNAME12 ) :
        case ( CAL_SMONTHNAME13 ) :
        case ( CAL_SABBREVMONTHNAME1 ) :
        case ( CAL_SABBREVMONTHNAME2 ) :
        case ( CAL_SABBREVMONTHNAME3 ) :
        case ( CAL_SABBREVMONTHNAME4 ) :
        case ( CAL_SABBREVMONTHNAME5 ) :
        case ( CAL_SABBREVMONTHNAME6 ) :
        case ( CAL_SABBREVMONTHNAME7 ) :
        case ( CAL_SABBREVMONTHNAME8 ) :
        case ( CAL_SABBREVMONTHNAME9 ) :
        case ( CAL_SABBREVMONTHNAME10 ) :
        case ( CAL_SABBREVMONTHNAME11 ) :
        case ( CAL_SABBREVMONTHNAME12 ) :
        case ( CAL_SABBREVMONTHNAME13 ) :
        {
            //
            //  Get the pointer to the appropriate calendar string if the
            //  IfNames flag is set for the calendar.
            //
            pString = NULL;
            if (((PCALENDAR_VAR)pCalInfo)->IfNames)
            {
                pString = (LPWORD)pCalInfo +
                          *((LPWORD)((LPBYTE)(pCalInfo) +
                                     (FIELD_OFFSET(CALENDAR_VAR, SDayName1) +
                                      ((CalType - CAL_SDAYNAME1) * sizeof(WORD)))));
            }

            //
            //  Make sure the string is NOT empty.  If it is, use the
            //  locale's string.
            //
            if ((pString == NULL) || (*pString == 0))
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          *((LPWORD)((LPBYTE)(pHashN->pLocaleHdr) +
                                     (FIELD_OFFSET(LOCALE_VAR, SDayName1) +
                                      ((CalType - CAL_SDAYNAME1) * sizeof(WORD)))));
            }

            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
    }

    //
    //  See if the caller wants the value in the form of a number instead
    //  of a string.
    //
    if (ReturnNum)
    {
        //
        //  Make sure the flags are valid and that the DWORD buffer
        //  is not NULL.
        //
        if (Base == 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }

        if (lpValue == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }

        //
        //  Convert the string to an int and return 2 (1 DWORD = 2 WORDS).
        //
        RtlInitUnicodeString(&ObUnicodeStr, pString);
        if (RtlUnicodeStringToInteger(&ObUnicodeStr, Base, lpValue))
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
        return (2);
    }

    //
    //  Get the length (in characters) of the string to copy.
    //
    if (Length == 0)
    {
        Length = NlsStrLenW(pString);
    }

    //
    //  Add one for the null termination.  All strings should be null
    //  terminated.
    //
    Length++;

    //
    //  Check cchData for size of given buffer.
    //
    if (cchData == 0)
    {
        //
        //  If cchData is 0, then we can't use lpCalData.  In this
        //  case, we simply want to return the length (in characters) of
        //  the string to be copied.
        //
        return (Length);
    }
    else if (cchData < Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Copy the string to lpCalData and null terminate it.
    //  Return the number of characters copied.
    //
    wcsncpy(lpCalData, pString, Length - 1);
    lpCalData[Length - 1] = 0;
    return (Length);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetCalendarInfoW
//
//  Sets one of the various pieces of information about a particular
//  calendar by making an entry in the user's portion of the configuration
//  registry.  This will only affect the user override portion of the
//  calendar settings.  The system defaults will never be reset.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI SetCalendarInfoW(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPCWSTR lpCalData)
{
    PLOC_HASH pHashN;                       // ptr to LOC hash node
    int cchData;                            // length of lpLCData
    PCAL_INFO pCalInfo;                     // ptr to calendar info
    UNICODE_STRING ObUnicodeStr;            // value string
    DWORD Value;                            // value


    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - NULL data pointer
    //
    //  NOTE: invalid type is checked in the switch statement below.
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ((pHashN == NULL) || (lpCalData == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Get the length of the buffer.
    //
    cchData = NlsStrLenW(lpCalData) + 1;

    //
    //  Validate the Calendar parameter.
    //
    if (GetCalendar(Calendar, &pCalInfo) != NO_ERROR)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Set the appropriate user information for the given CALTYPE.
    //
    CalType &= (~CAL_USE_CP_ACP);
    switch (CalType)
    {
        case ( CAL_ITWODIGITYEARMAX ) :
        {
            //
            //  Get the default value to make sure the calendar is
            //  allowed to be set.  Things like the Japanese Era calendar
            //  may not be set.
            //
            RtlInitUnicodeString( &ObUnicodeStr,
                                  ((LPWORD)pCalInfo +
                                   (((PCALENDAR_VAR)pCalInfo)->STwoDigitYearMax)) );
            RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value);
            if (Value <= 99)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Convert the user data so it can be validated
            //
            Value = 0;
            NLS_STRING_TO_INTEGER(Value, lpCalData);

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_ITWODIGITYEAR wide characters in length.
            //  It should be between 99 and 9999.
            //
            if ((cchData > MAX_ITWODIGITYEAR) ||
                (Value < 99) ||
                (Value > 9999))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new TwoDigitYearMax string.
            //
            return (SetTwoDigitYearInfo(Calendar, lpCalData, cchData));
            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  SetUserInfo
//
//  This routine sets the given value in the registry with the given data.
//  All values must be of the type REG_SZ.
//
//  NOTE: The handle to the registry key must be closed by the CALLER if
//        the return value is NO_ERROR.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL SetUserInfo(
    LCTYPE   LCType,
    LPWSTR pData,
    ULONG DataLength)
{

    NTSTATUS Status;

    //
    //  Get the length of the value string.
    //
    DataLength *= sizeof(WCHAR);

    //
    // If there is no logged on user or the current security context
    // isn't the logged-on interactive user, then set the registry
    // value directly.
    //
    if (! NT_SUCCESS( NlsCheckForInteractiveUser() ))
    {
        return (SetCurrentUserRegValue(LCType, pData, DataLength));
    }

    // Call into server side (csrss.exe) to set the registry and update the cache for the current user.
    Status = CsrBasepNlsSetUserInfo(LCType,
                                    pData,
                                    DataLength);

    //
    //  Check to see if the "set" operation succeeded.
    //
    if (!NT_SUCCESS(Status))
    {
        //
        //  We got a failure.  Try using just the registry apis to set the
        //  registry.  It's possible that the cache is not valid yet if this
        //  is called from setup or winlogon.
        //
        return (SetCurrentUserRegValue(LCType, pData, DataLength));
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetCurrentUserRegValue
//
//  Set the registry value for the current security context. This routine
//  is called when the current security context is different from the logged
//  on user.
//
//  12-26-98    SamerA    Created.
////////////////////////////////////////////////////////////////////////////

BOOL SetCurrentUserRegValue(
    LCTYPE   LCType,
    LPWSTR pData,
    ULONG DataLength)
{
    HANDLE hKey = NULL;
    LPWSTR pValue;
    LPWSTR pCache;

    if (0 == ValidateLCType(pNlsUserInfo, LCType, &pValue, &pCache))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Open the registry for the current security context
    //
    OPEN_CPANEL_INTL_KEY(hKey, FALSE, KEY_READ | KEY_WRITE);
    if (SetRegValue(hKey, pValue, pData, DataLength) != NO_ERROR)
    {
        CLOSE_REG_KEY(hKey);
        SetLastError(ERROR_INVALID_ACCESS);
        return (FALSE);
    }

    CLOSE_REG_KEY(hKey);

    //
    // Flush the process cache entry, if needed.
    //
    NlsFlushProcessCache(LCType);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetMultipleUserInfoInRegistry
//
//  This routine sets the given multiple values in the registry with the
//  given data.  All values must be of the type REG_SZ.
//
//  06-11-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL SetMultipleUserInfoInRegistry(
    DWORD dwFlags,
    int cchData,
    LPCWSTR pPicture,
    LPCWSTR pSeparator,
    LPCWSTR pOrder,
    LPCWSTR pTLZero,
    LPCWSTR pTimeMarkPosn)
{
    HANDLE hKey = NULL;
    ULONG rc = 0L;


    //
    //  Open the Control Panel International registry key.
    //
    OPEN_CPANEL_INTL_KEY(hKey, FALSE, KEY_READ | KEY_WRITE);

    //
    //  Save the appropriate values in the registry based on the flags.
    //
    switch (dwFlags)
    {
        case ( LOCALE_STIMEFORMAT ) :
        {
            rc = SetRegValue( hKey,
                              NLS_VALUE_STIMEFORMAT,
                              pPicture,
                              cchData * sizeof(WCHAR) );
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_STIMEFORMAT);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_STIME,
                                  pSeparator,
                                  (lstrlen(pSeparator) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_STIME);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_ITIME,
                                  pOrder,
                                  (lstrlen(pOrder) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_ITIME);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_ITLZERO,
                                  pTLZero,
                                  (lstrlen(pTLZero) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_ITLZERO);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_ITIMEMARKPOSN,
                                  pTimeMarkPosn,
                                  (lstrlen(pTimeMarkPosn) + 1) * sizeof(WCHAR) );

                if (NT_SUCCESS(rc))
                {
                    NlsFlushProcessCache(LOCALE_ITIMEMARKPOSN);
                }
            }

            break;
        }
        case ( LOCALE_STIME ) :
        {
            rc = SetRegValue( hKey,
                              NLS_VALUE_STIME,
                              pSeparator,
                              cchData * sizeof(WCHAR) );
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_STIME);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_STIMEFORMAT,
                                  pPicture,
                                  (lstrlen(pPicture) + 1) * sizeof(WCHAR) );

                if (NT_SUCCESS(rc))
                {
                    NlsFlushProcessCache(LOCALE_STIMEFORMAT);
                }
            }

            break;
        }
        case ( LOCALE_ITIME ) :
        {
            rc = SetRegValue( hKey,
                              NLS_VALUE_ITIME,
                              pOrder,
                              cchData * sizeof(WCHAR) );
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_ITIME);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_STIMEFORMAT,
                                  pPicture,
                                  (lstrlen(pPicture) + 1) * sizeof(WCHAR) );

                if (NT_SUCCESS(rc))
                {
                    NlsFlushProcessCache(LOCALE_STIMEFORMAT);
                }
            }

            break;
        }
        case ( LOCALE_SSHORTDATE ) :
        {
            rc = SetRegValue( hKey,
                              NLS_VALUE_SSHORTDATE,
                              pPicture,
                              cchData * sizeof(WCHAR) );
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_SSHORTDATE);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_SDATE,
                                  pSeparator,
                                  (lstrlen(pSeparator) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_SDATE);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_IDATE,
                                  pOrder,
                                  (lstrlen(pOrder) + 1) * sizeof(WCHAR) );

                if (NT_SUCCESS(rc))
                {
                    NlsFlushProcessCache(LOCALE_IDATE);
                }
            }

            break;
        }
        case ( LOCALE_SDATE ) :
        {
            rc = SetRegValue( hKey,
                              NLS_VALUE_SDATE,
                              pSeparator,
                              cchData * sizeof(WCHAR) );
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_SDATE);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_SSHORTDATE,
                                  pPicture,
                                  (lstrlen(pPicture) + 1) * sizeof(WCHAR) );

                if (NT_SUCCESS(rc))
                {
                    NlsFlushProcessCache(LOCALE_SSHORTDATE);
                }
            }

            break;
        }
        default :
        {
            CLOSE_REG_KEY(hKey);
            return (FALSE);
        }
    }

    //
    //  Close the registry key.
    //
    CLOSE_REG_KEY(hKey);

    //
    //  Return the result.
    //
    return (rc == NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetMultipleUserInfo
//
//  This routine calls the server to set multiple registry values.  This way,
//  only one client/server transition is necessary.
//
//  08-19-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL SetMultipleUserInfo(
    DWORD dwFlags,
    int cchData,
    LPCWSTR pPicture,
    LPCWSTR pSeparator,
    LPCWSTR pOrder,
    LPCWSTR pTLZero,
    LPCWSTR pTimeMarkPosn)
{
    NTSTATUS Status;

    //
    // If there is no logged on user or the current security context
    // isn't the logged-on interactive user, then set the registry
    // value directly.
    //
    if (! NT_SUCCESS( NlsCheckForInteractiveUser() ))
    {
        if (SetMultipleUserInfoInRegistry( dwFlags,
                                           cchData,
                                           pPicture,
                                           pSeparator,
                                           pOrder,
                                           pTLZero,
                                           pTimeMarkPosn ) == FALSE)
        {
            SetLastError(ERROR_INVALID_ACCESS);
            return (FALSE);
        }

        return (TRUE);
    }

    Status = CsrBasepNlsSetMultipleUserInfo(dwFlags,
                                            cchData,
                                            pPicture,
                                            pSeparator,
                                            pOrder,
                                            pTLZero,
                                            pTimeMarkPosn
                                            );
    //
    //  Check to see if the "set" operation succeeded.
    //

    if (!NT_SUCCESS(Status))
    {
        //
        //  We got a failure.  Try using just the registry apis to set the
        //  registry.  It's possible that the cache is not valid yet if this
        //  is called from setup or winlogon.
        //
        if (SetMultipleUserInfoInRegistry( dwFlags,
                                           cchData,
                                           pPicture,
                                           pSeparator,
                                           pOrder,
                                           pTLZero,
                                           pTimeMarkPosn ) == FALSE)
        {
            SetLastError(ERROR_INVALID_ACCESS);
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTwoDigitYearInfo
//
//  This routine gets the two digit year info from the registry.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL GetTwoDigitYearInfo(
    CALID Calendar,
    LPWSTR pYearInfo,
    size_t cchYearInfo,
    PWSTR pwszKeyPath)
{
    HANDLE hKey = NULL;                          // handle to key
    WCHAR pCalStr[MAX_PATH];                     // ptr to calendar id string
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    BOOL IfAlloc = FALSE;                        // if buffer was allocated
    ULONG rc = 0L;                               // return code
    BOOL bResult = FALSE;                        // result
    UNICODE_STRING ObUnicodeStr;                 // year string
    DWORD Year;                                  // year value


    //
    //  Open the Control Panel International registry key.
    //
    if (OpenRegKey( &hKey,
                    NULL,
                    pwszKeyPath,
                    KEY_READ ) != NO_ERROR)
    {
        return (FALSE);
    }

    //
    //  Convert calendar value to Unicode string.
    //
    if (NlsConvertIntegerToString(Calendar, 10, 0, pCalStr, MAX_PATH))
    {
        NtClose(hKey);
        return (FALSE);
    }

    //
    //  Query the registry for the TwoDigitYearMax value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    rc = QueryRegValue( hKey,
                        pCalStr,
                        &pKeyValueFull,
                        MAX_KEY_VALUE_FULLINFO,
                        &IfAlloc );

    //
    //  Close the registry key.
    //
    NtClose(hKey);

    //
    //  See if the TwoDigitYearMax value is present.
    //
    if (rc != NO_ERROR)
    {
        return (FALSE);
    }

    //
    //  See if the TwoDigitYearMax data is present.
    //
    if (pKeyValueFull->DataLength > 2)
    {
        //
        //  Copy the info
        //
        if(FAILED(StringCchCopyW(pYearInfo, cchYearInfo, GET_VALUE_DATA_PTR(pKeyValueFull))))
        {
            return(FALSE);
        }

        //
        //  Make sure the value is between 99 and 9999.
        //
        RtlInitUnicodeString(&ObUnicodeStr, pYearInfo);
        if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Year) == NO_ERROR) &&
            (Year >= 99) && (Year <= 9999))
        {
            bResult = TRUE;
        }
    }

    //
    //  Free the buffer used for the query.
    //
    if (IfAlloc)
    {
        NLS_FREE_MEM(pKeyValueFull);
    }

    //
    //  Return the result.
    //
    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetTwoDigitYearInfo
//
//  This routine sets the two digit year info in the registry.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL SetTwoDigitYearInfo(
    CALID Calendar,
    LPCWSTR pYearInfo,
    int cchData)
{
    HANDLE hKey = NULL;                          // handle to key
    WCHAR pCalStr[MAX_PATH];                     // ptr to calendar id string
    ULONG rc = 0L;                               // return code


    //
    //  Open the Control Panel International registry key.
    //  If it doesn't exist, then we have to create each subkey
    //  separately.
    //
    if (OpenRegKey( &hKey,
                    NULL,
                    NLS_TWO_DIGIT_YEAR_KEY,
                    KEY_READ | KEY_WRITE ) != NO_ERROR)
    {
        //
        //  Registry key does not exist, so create each subkey
        //  separately.
        //
        if (CreateRegKey( &hKey,
                          NULL,
                          NLS_CALENDARS_KEY,
                          KEY_READ | KEY_WRITE ) == NO_ERROR)
        {
            NtClose(hKey);
            if (CreateRegKey( &hKey,
                              NULL,
                              NLS_TWO_DIGIT_YEAR_KEY,
                              KEY_READ | KEY_WRITE ) != NO_ERROR)
            {
                return (FALSE);
            }
        }
        else
        {
            return (FALSE);
        }
    }

    //
    //  Make sure all Gregorian calendars are set to the same value.
    //
    switch (Calendar)
    {
        case ( 1 ) :
        case ( 2 ) :
        case ( 9 ) :
        case ( 10 ) :
        case ( 11 ) :
        case ( 12 ) :
        {
            rc = SetRegValue(hKey, L"1", pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            if (rc == NO_ERROR)
            {
                rc = SetRegValue(hKey, L"2", pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            }
            if (rc == NO_ERROR)
            {
                rc = SetRegValue(hKey, L"9",  pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            }
            if (rc == NO_ERROR)
            {
                rc = SetRegValue(hKey, L"10", pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            }
            if (rc == NO_ERROR)
            {
                rc = SetRegValue(hKey, L"11", pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            }
            if (rc == NO_ERROR)
            {
                rc = SetRegValue(hKey, L"12", pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            }

            break;
        }
        default :
        {
            //
            //  Convert calendar value to Unicode string.
            //
            if (NlsConvertIntegerToString(Calendar, 10, 0, pCalStr, MAX_PATH))
            {
                NtClose(hKey);
                return (FALSE);
            }

            //
            //  Set the TwoDigitYearMax value in the registry.
            //
            rc = SetRegValue(hKey, pCalStr, pYearInfo, (ULONG)cchData * sizeof(WCHAR));

            break;
        }
    }

    //
    // Update the NlsCacheUpdateCount inside csrss
    //
    if (rc == NO_ERROR)
    {
        CsrBasepNlsUpdateCacheCount();
    }

    //
    //  Close the registry key.
    //
    NtClose(hKey);

    //
    //  Return the result.
    //
    return (rc == NO_ERROR);
}

////////////////////////////////////////////////////////////////////////////
//
//  GetNLSVersion
//
//  Return the version of a specific NLS function.
//
//  08-15-2001    LGuindon    Created.
////////////////////////////////////////////////////////////////////////////
BOOL WINAPI GetNLSVersion(
    NLS_FUNCTION     function,
    LCID             locale,
    LPNLSVERSIONINFO lpVersionInformation)
{
    PLOC_HASH pHashN;
    
    //
    //  Invalid parameter check:
    //    - validate LCID
    //    - NULL data pointer
    //
    //  NOTE: invalid function is checked in the switch statement below.
    //
    VALIDATE_LOCALE(locale, pHashN, FALSE);
    if ((lpVersionInformation == NULL) || (pHashN == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Buffer size check.
    //
    if (lpVersionInformation->dwNLSVersionInfoSize != sizeof(NLSVERSIONINFO)) 
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return (FALSE);
    }

    //
    //  Make sure the appropriate tables are available.  If not,
    //  return an error.
    //
    if (pTblPtrs->pSortVersion == NULL )
    {
        KdPrint(("NLSAPI: Appropriate Versioning Table Not Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (FALSE);
    }

    //
    //  Make sure the appropriate tables are available.  If not,
    //  return an error.
    //
    if (pTblPtrs->pDefinedVersion == NULL)
    {
        KdPrint(("NLSAPI: Appropriate Defined Code Point Table Not Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (FALSE);
    }
    
    //
    //  Check which NLS functionnality version is requested.
    //
    switch (function)
    {
        case (COMPARE_STRING):
            {
                UINT i;
                
                //
                //  Get the Defined version. Always the first entry
                //  in the Defined Code Point version table. The first
                //  entry represent the current Defined version.
                //
                
                lpVersionInformation->dwDefinedVersion = (pTblPtrs->pDefinedVersion)[0].Version;
                
                //
                //  Get the NLS sorting version. Search specific locale 
                //  version info. Start from the second entry; after default
                //  value.
                //
                lpVersionInformation->dwNLSVersion = (pTblPtrs->pSortVersion)[0].Version;
                for (i = 1; i < pTblPtrs->NumSortVersion; i++)
                {
                    if (pHashN->Locale == (pTblPtrs->pSortVersion)[i].Locale)
                    {
                        lpVersionInformation->dwNLSVersion = (pTblPtrs->pSortVersion)[i].Version;
                        break;
                    }
                }

                break;
            }
//        case (NORMALIZE_STRING):
//            {
//                //
//                //  Not implemented yet.
//                //
//                SetLastError(ERROR_NOT_SUPPORTED);
//                return (FALSE);
//            }
        default:
            {
                SetLastError(ERROR_INVALID_FLAGS);
                return (FALSE);
            }
    }

    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  IsNLSDefinedString
//
//  This routine looks for code points inside a string to see if they are
//  defined within the NSL context. If lpVersionInformation is NULL, the 
//  version is the current version. Same thing the dwDefinedVersion is equal
//  to zero.
//
//  08-20-2001    LGuindon    Created.
////////////////////////////////////////////////////////////////////////////
BOOL WINAPI IsNLSDefinedString(
    NLS_FUNCTION     Function,
    DWORD            dwFlags,
    LPNLSVERSIONINFO lpVersionInformation,
    LPCWSTR          lpString,
    INT              cchStr)
{
    //
    //  Invalid Parameter Check:
    //    - string is null
    //    - length of src string is 0
    //
    //  NOTE: 
    //    - invalid function is checked in the switch statement below.
    //    - version validity is checked below.
    //    - dwNLSVersionInfoSize is checked later in IsSortingCodePointDefined().
    //    - we don't check lpVersionInformation for NULL, since NULL means the current defined version.
    //
    if ((cchStr == 0) ||
        (lpString == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Invalid Flag Check:
    //    - dwFlags is not zero
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (FALSE);
    }

    //
    //  Buffer size check is checked below.
    //


    //
    //  Check string length.
    //
    if (cchStr <= (-1))
    {
        cchStr = NlsStrLenW(lpString); 
    }

    //
    //  Check which NLS functionnality version is requested.
    //
    switch (Function)
    {
        case (COMPARE_STRING):
            {
                return (IsSortingCodePointDefined(lpVersionInformation, lpString, cchStr));
            }
//        case (NORMALIZE_STRING):
//            {
                //
                //  Not implemented yet.
                //
//                SetLastError(ERROR_NOT_SUPPORTED);
//                return (FALSE);
//            }
        default:
            {
                SetLastError(ERROR_INVALID_FLAGS);
                return (FALSE);
            }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\nls.h ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    nls.h

Abstract:

    This file contains the header information shared by all of the modules
    of NLS.

Revision History:

    05-31-91    JulieB    Created.
    03-07-00    lguindon  Began Geo API port

--*/



#ifndef _NLS_
#define _NLS_




////////////////////////////////////////////////////////////////////////////
//
//  RTL Includes Files.
//
////////////////////////////////////////////////////////////////////////////

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif



////////////////////////////////////////////////////////////////////////////
//
//  Include Files.
//
////////////////////////////////////////////////////////////////////////////

#include <base.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>
#include <basemsg.h>
#include <windows.h>
#include <winnlsp.h>
#include <winerror.h>
#include <string.h>
#include <stdlib.h>


////////////////////////////////////////////////////////////////////////////
//
//  Constant Declarations.
//
////////////////////////////////////////////////////////////////////////////

//
//  Code Page Ranges.
//
#define NLS_CP_TABLE_RANGE        0         // begin code page Table range
#define NLS_CP_DLL_RANGE          50000     // begin code page DLL range
#define NLS_CP_ALGORITHM_RANGE    60000     // begin code page Algorithm range


//
//  Table Values.
//
#define MB_TBL_SIZE               256  // size of MB tables
#define GLYPH_TBL_SIZE            256  // size of GLYPH tables
#define DBCS_TBL_SIZE             256  // size of DBCS tables

#define CP_TBL_SIZE               197  // size of code page hash table (prime #)
#define LOC_TBL_SIZE              197  // size of locale hash table (prime #)


//
//  String Constants.
//
#define MAX_PATH_LEN              512  // max length of path name
#define MAX_STRING_LEN            128  // max string length for static buffer
#define MAX_SMALL_BUF_LEN         64   // max length of small buffer

#define MAX_COMPOSITE             5    // max number of composite characters
#define MAX_EXPANSION             3    // max number of expansion characters
#define MAX_TBL_EXPANSION         2    // max expansion chars per table entry
#define MAX_WEIGHTS               9    // max number of words in all weights

#define MAX_SECURITY_BUF_LEN      128  // max length of security descriptor buffer

// length of sortkey static buffer
#define MAX_SORTKEY_BUF_LEN       ( MAX_SMALL_BUF_LEN * MAX_EXPANSION * MAX_WEIGHTS )


#define MAX_FONTSIGNATURE         16   // length of font signature string

// SetLocaleInfo string constants
#define MAX_SLIST                 4    // max wide chars in sList
#define MAX_IMEASURE              2    // max wide chars in iMeasure
#define MAX_SDECIMAL              4    // max wide chars in sDecimal
#define MAX_STHOUSAND             4    // max wide chars in sThousand
#define MAX_SGROUPING             10   // max wide chars in sGrouping
#define MAX_IDIGITS               2    // max wide chars in iDigits
#define MAX_ILZERO                2    // max wide chars in iLZero
#define MAX_INEGNUMBER            2    // max wide chars in iNegNumber
#define MAX_SNATIVEDIGITS         11   // max wide chars in sNativeDigits
#define MAX_IDIGITSUBST           2    // max wide chars in iDigitSubstitution
#define MAX_SCURRENCY             6    // max wide chars in sCurrency
#define MAX_SMONDECSEP            4    // max wide chars in sMonDecimalSep
#define MAX_SMONTHOUSEP           4    // max wide chars in sMonThousandSep
#define MAX_SMONGROUPING          10   // max wide chars in sMonGrouping
#define MAX_ICURRENCY             2    // max wide chars in iCurrency
#define MAX_SPOSSIGN              5    // max wide chars in sPositiveSign
#define MAX_SNEGSIGN              5    // max wide chars in sNegativeSign
#define MAX_STIMEFORMAT           MAX_REG_VAL_SIZE   // max wide chars in sTimeFormat
#define MAX_STIME                 4    // max wide chars in sTime
#define MAX_ITIME                 2    // max wide chars in iTime
#define MAX_S1159                 15   // max wide chars in s1159
#define MAX_S2359                 15   // max wide chars in s2359
#define MAX_SSHORTDATE            MAX_REG_VAL_SIZE   // max wide chars in sShortDate
#define MAX_SDATE                 4    // max wide chars in sDate
#define MAX_SYEARMONTH            MAX_REG_VAL_SIZE   // max wide chars in sYearMonth
#define MAX_SLONGDATE             MAX_REG_VAL_SIZE   // max wide chars in sLongDate
#define MAX_ICALTYPE              3    // max wide chars in iCalendarType
#define MAX_IFIRSTDAY             2    // max wide chars in iFirstDayOfWeek
#define MAX_IFIRSTWEEK            2    // max wide chars in iFirstWeekOfYear

//
//  NOTE:  If any of the MAX_VALUE_ values change, then the corresponding
//         MAX_CHAR_ value must also change.
//
#define MAX_VALUE_IMEASURE        1    // max value for iMeasure
#define MAX_VALUE_IDIGITS         9    // max value for iDigits
#define MAX_VALUE_ILZERO          1    // max value for iLZero
#define MAX_VALUE_INEGNUMBER      4    // max value for iNegNumber
#define MAX_VALUE_IDIGITSUBST     2    // max value for iDigitSubstitution
#define MAX_VALUE_ICURRDIGITS     99   // max value for iCurrDigits
#define MAX_VALUE_ICURRENCY       3    // max value for iCurrency
#define MAX_VALUE_INEGCURR        15   // max value for iNegCurr
#define MAX_VALUE_ITIME           1    // max value for iTime
#define MAX_VALUE_IFIRSTDAY       6    // max value for iFirstDayOfWeek
#define MAX_VALUE_IFIRSTWEEK      2    // max value for iFirstWeekOfYear

#define MAX_CHAR_IMEASURE       L'1'   // max char value for iMeasure
#define MAX_CHAR_IDIGITS        L'9'   // max char value for iDigits
#define MAX_CHAR_ILZERO         L'1'   // max char value for iLZero
#define MAX_CHAR_INEGNUMBER     L'4'   // max char value for iNegNumber
#define MAX_CHAR_IDIGITSUBST    L'2'   // max char value for iDigitSubstitution
#define MAX_CHAR_ICURRENCY      L'3'   // max char value for iCurrency
#define MAX_CHAR_ITIME          L'1'   // max char value for iTime
#define MAX_CHAR_IFIRSTDAY      L'6'   // max char value for iFirstDayOfWeek
#define MAX_CHAR_IFIRSTWEEK     L'2'   // max char value for iFirstWeekOfYear


// SetCalendarInfo string constants
#define MAX_ITWODIGITYEAR         5    // max wide chars in TwoDigitYearMax


#define NLS_CHAR_ZERO           L'0'   // digit 0 character
#define NLS_CHAR_ONE            L'1'   // digit 1 character
#define NLS_CHAR_NINE           L'9'   // digit 9 character
#define NLS_CHAR_SEMICOLON      L';'   // semicolon character
#define NLS_CHAR_PERIOD         L'.'   // period character
#define NLS_CHAR_QUOTE          L'\''  // single quote character
#define NLS_CHAR_SPACE          L' '   // space character
#define NLS_CHAR_HYPHEN         L'-'   // hyphen/minus character
#define NLS_CHAR_OPEN_PAREN     L'('   // open parenthesis character
#define NLS_CHAR_CLOSE_PAREN    L')'   // close parenthesis character

#define MAX_BLANKS                1    // max successive blanks in number string


//
//  RC File Constants.
//
#define NLS_SORT_RES_PREFIX       L"SORT_"
#define NLS_SORT_RES_DEFAULT      L"SORT_00000000"


//
//  Size of stack buffer for PKEY_VALUE_FULL_INFORMATION pointer.
//
#define MAX_KEY_VALUE_FULLINFO                                             \
    ( FIELD_OFFSET( KEY_VALUE_FULL_INFORMATION, Name ) + MAX_PATH_LEN )


//
//  Paths to registry keys.
//
#define NLS_HKLM_SYSTEM    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control"
#define NLS_HKLM_SOFTWARE  L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion"


//
//  Names of Registry Key Entries.
//
#define NLS_CODEPAGE_KEY           L"\\Nls\\Codepage"
#define NLS_LANGUAGE_GROUPS_KEY    L"\\Nls\\Language Groups"
#define NLS_LOCALE_KEY             L"\\Nls\\Locale"
#define NLS_ALT_SORTS_KEY          L"\\Nls\\Locale\\Alternate Sorts"
#define NLS_MUILANG_KEY            L"\\Nls\\MUILanguages"

//
//  User Info.
//
#define NLS_CTRL_PANEL_KEY         L"Control Panel\\International"
#define NLS_CALENDARS_KEY          L"Control Panel\\International\\Calendars"
#define NLS_TWO_DIGIT_YEAR_KEY     L"Control Panel\\International\\Calendars\\TwoDigitYearMax"
#define NLS_POLICY_TWO_DIGIT_YEAR_KEY L"Software\\Policies\\Microsoft\\Control Panel\\International\\Calendars\\TwoDigitYearMax"

//
//  GEO Registry Keys.
//
#define GEO_REG_KEY         L"Control Panel\\International\\Geo"
#define GEO_REG_NATION      L"Nation"
#define GEO_REG_REGION      L"Region"
#define GEO_REG_STATE       L"State"
#define GEO_REG_CITY        L"City"

//
//  Name of NLS Object Directory.
//  Must create this in order to have "create access" on the fly.
//
#define NLS_OBJECT_DIRECTORY_NAME  L"\\NLS"

//
//  Default values.
//
#define NLS_DEFAULT_ACP           1252
#define NLS_DEFAULT_OEMCP         437
#define NLS_DEFAULT_MACCP         10000
#define NLS_DEFAULT_LANGID        0x0409
#define NLS_DEFAULT_UILANG        0x0409


//
//  DLL Translation Function Names.
//
//  ****  Must be an ANSI string for GetProcAddress call.  ****
//
#define NLS_CP_DLL_PROC_NAME      "NlsDllCodePageTranslation"


//
//  Flag Constants.
//
#define MSB_FLAG         0x80000000    // most significant bit set


//
//  Table Header Constants  (all sizes in WORDS).
//
#define CP_HEADER                 1    // size of CP Info table header
#define MB_HEADER                 1    // size of MB table header
#define GLYPH_HEADER              1    // size of GLYPH table header
#define DBCS_HEADER               1    // size of DBCS table header
#define WC_HEADER                 1    // size of WC table header
#define CT_HEADER                 2    // size of CTYPE table header
#define LANG_HDR_OFFSET           0    // offset to LANGUAGE file header
#define LANG_HEADER               1    // size of language file header
#define UP_HEADER                 1    // size of UPPERCASE table header
#define LO_HEADER                 1    // size of LOWERCASE table header
#define L_EXCEPT_HDR_OFFSET       2    // offset to LANGUAGE EXCEPTION header
#define AD_HEADER                 1    // size of ASCIIDIGITS table header
#define CZ_HEADER                 1    // size of FOLDCZONE table header
#define HG_HEADER                 1    // size of HIRAGANA table header
#define KK_HEADER                 1    // size of KATAKANA table header
#define HW_HEADER                 1    // size of HALF WIDTH table header
#define FW_HEADER                 1    // size of FULL WIDTH table header
#define TR_HEADER                 1    // size of TRADITIONAL CHINESE table header
#define SP_HEADER                 1    // size of SIMPLIFIED CHINESE table header
#define PC_HEADER                 1    // size of PRECOMPOSED table header
#define CO_HEADER                 3    // size of COMPOSITE table header
#define SORTKEY_HEADER            2    // size of SORTKEY table header
#define REV_DW_HEADER             2    // size of REVERSE DW table header
#define DBL_COMP_HEADER           2    // size of DOUBLE COMPRESS table header
#define IDEO_LCID_HEADER          2    // size of IDEOGRAPH LCID table header
#define EXPAND_HEADER             2    // size of EXPANSION table header
#define COMPRESS_HDR_OFFSET       2    // offset to COMPRESSION header
#define EXCEPT_HDR_OFFSET         2    // offset to EXCEPTION header
#define MULTI_WT_HEADER           1    // size of MULTIPLE WEIGHTS table header
#define JAMO_INDEX_HEADER         1    // size of Jamo Index table header
#define JAMO_COMPOSITION_HEADER   1    // size of Jamo Composition state machine table header
#define SORTVERINFO_HEADER        2    // size of Sort Version Info table header
#define NLSDEFINED_HEADER         2    // size of NLS Defined Code point table header
#define NLSDEFINED_ITEM_SIZE      2+2  // size of an item in the NLSDEFINED table header (VERSION is in DWORD, and offset is in DWORD)

//
//  Invalid Flag Checks.
//
#define MB_INVALID_FLAG   (~(MB_PRECOMPOSED   | MB_COMPOSITE |              \
                             MB_USEGLYPHCHARS | MB_ERR_INVALID_CHARS))
#define WC_INVALID_FLAG   (~(WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK |     \
                             WC_DISCARDNS | WC_SEPCHARS | WC_DEFAULTCHAR))
#define CS_INVALID_FLAG   (~(NORM_IGNORECASE    | NORM_IGNORENONSPACE |     \
                             NORM_IGNORESYMBOLS | NORM_IGNOREKANATYPE |     \
                             NORM_IGNOREWIDTH   | SORT_STRINGSORT     |     \
                             LOCALE_USE_CP_ACP  | NORM_STOP_ON_NULL))
#define FS_INVALID_FLAG   (~(MAP_FOLDCZONE | MAP_PRECOMPOSED |              \
                             MAP_COMPOSITE | MAP_FOLDDIGITS))
#define LCMS_INVALID_FLAG (~(LCMAP_LOWERCASE | LCMAP_UPPERCASE |            \
                             LCMAP_LINGUISTIC_CASING |                      \
                             LCMAP_SORTKEY   | LCMAP_BYTEREV   |            \
                             LCMAP_HIRAGANA  | LCMAP_KATAKANA  |            \
                             LCMAP_HALFWIDTH | LCMAP_FULLWIDTH |            \
                             LCMAP_TRADITIONAL_CHINESE |                    \
                             LCMAP_SIMPLIFIED_CHINESE  |                    \
                             NORM_IGNORECASE    | NORM_IGNORENONSPACE |     \
                             NORM_IGNORESYMBOLS | NORM_IGNOREKANATYPE |     \
                             NORM_IGNOREWIDTH   | SORT_STRINGSORT     |     \
                             LOCALE_USE_CP_ACP))
#define GTF_INVALID_FLAG  (~(LOCALE_NOUSEROVERRIDE | LOCALE_USE_CP_ACP |    \
                             TIME_NOMINUTESORSECONDS                   |    \
                             TIME_NOSECONDS | TIME_NOTIMEMARKER        |    \
                             TIME_FORCE24HOURFORMAT))
#define GDF_INVALID_FLAG  (~(LOCALE_NOUSEROVERRIDE | LOCALE_USE_CP_ACP |    \
                             DATE_LTRREADING       | DATE_RTLREADING   |    \
                             DATE_SHORTDATE        | DATE_LONGDATE     |    \
                             DATE_YEARMONTH        | DATE_USE_ALT_CALENDAR |\
                             DATE_ADDHIJRIDATETEMP))
#define IVLG_INVALID_FLAG (~(LGRPID_INSTALLED | LGRPID_SUPPORTED))
#define IVL_INVALID_FLAG  (~(LCID_INSTALLED | LCID_SUPPORTED))
#define GNF_INVALID_FLAG  (~(LOCALE_NOUSEROVERRIDE | LOCALE_USE_CP_ACP))
#define GCF_INVALID_FLAG  (~(LOCALE_NOUSEROVERRIDE | LOCALE_USE_CP_ACP))
#define ESLG_INVALID_FLAG (~(LGRPID_INSTALLED | LGRPID_SUPPORTED))
#define ESL_INVALID_FLAG  (~(LCID_INSTALLED | LCID_SUPPORTED |             \
                             LCID_ALTERNATE_SORTS))
#define ESCP_INVALID_FLAG (~(CP_INSTALLED | CP_SUPPORTED))
#define ETF_INVALID_FLAG  (~(LOCALE_USE_CP_ACP))


//
//  Single Flags (only one at a time is valid).
//
#define LCMS1_SINGLE_FLAG (LCMAP_LOWERCASE | LCMAP_UPPERCASE |             \
                           LCMAP_SORTKEY)
#define LCMS2_SINGLE_FLAG (LCMAP_HIRAGANA  | LCMAP_KATAKANA  |             \
                           LCMAP_SORTKEY)
#define LCMS3_SINGLE_FLAG (LCMAP_HALFWIDTH | LCMAP_FULLWIDTH |             \
                           LCMAP_SORTKEY)
#define LCMS4_SINGLE_FLAG (LCMAP_TRADITIONAL_CHINESE |                     \
                           LCMAP_SIMPLIFIED_CHINESE  |                     \
                           LCMAP_SORTKEY)
#define GDF_SINGLE_FLAG   (DATE_LTRREADING | DATE_RTLREADING)
#define IVLG_SINGLE_FLAG  (LGRPID_INSTALLED  | LGRPID_SUPPORTED)
#define IVL_SINGLE_FLAG   (LCID_INSTALLED  | LCID_SUPPORTED)
#define ESLG_SINGLE_FLAG  (LGRPID_INSTALLED  | LGRPID_SUPPORTED)
#define ESL_SINGLE_FLAG   (LCID_INSTALLED  | LCID_SUPPORTED)
#define ESCP_SINGLE_FLAG  (CP_INSTALLED    | CP_SUPPORTED)


//
//  Flag combinations.
//
#define WC_COMPCHK_FLAGS  (WC_DISCARDNS | WC_SEPCHARS | WC_DEFAULTCHAR)
#define NORM_ALL          (NORM_IGNORECASE    | NORM_IGNORENONSPACE |      \
                           NORM_IGNORESYMBOLS | NORM_IGNOREKANATYPE |      \
                           NORM_IGNOREWIDTH)
#define NORM_SORTKEY_ONLY (NORM_IGNORECASE    | NORM_IGNOREKANATYPE |      \
                           NORM_IGNOREWIDTH   | SORT_STRINGSORT)
#define NORM_ALL_CASE     (NORM_IGNORECASE    | NORM_IGNOREKANATYPE |      \
                           NORM_IGNOREWIDTH)
#define LCMAP_NO_NORM     (LCMAP_LOWERCASE    | LCMAP_UPPERCASE     |      \
                           LCMAP_HIRAGANA     | LCMAP_KATAKANA      |      \
                           LCMAP_HALFWIDTH    | LCMAP_FULLWIDTH     |      \
                           LCMAP_TRADITIONAL_CHINESE                |      \
                           LCMAP_SIMPLIFIED_CHINESE)

//
//  Get the LCType value from an LCType.
//
#define NLS_GET_LCTYPE_VALUE(x)  (x & ~(LOCALE_NOUSEROVERRIDE |  \
                                        LOCALE_USE_CP_ACP     |  \
                                        LOCALE_RETURN_NUMBER))

//
//  Get the CalType value from a CalType.
//
#define NLS_GET_CALTYPE_VALUE(x) (x & ~(CAL_NOUSEROVERRIDE |  \
                                        CAL_USE_CP_ACP     |  \
                                        CAL_RETURN_NUMBER))

//
//  Separator and Terminator Values - Sortkey String.
//
#define SORTKEY_SEPARATOR    0x01
#define SORTKEY_TERMINATOR   0x00


//
//  Lowest weight values.
//  Used to remove trailing DW and CW values.
//
#define MIN_DW  2
#define MIN_CW  2


//
//  Bit mask values.
//
//  Case Weight (CW) - 8 bits:
//    bit 0   => width
//    bit 1,2 => small kana, sei-on
//    bit 3,4 => upper/lower case
//    bit 5   => kana
//    bit 6,7 => compression
//
#define COMPRESS_3_MASK      0xc0      // compress 3-to-1 or 2-to-1
#define COMPRESS_2_MASK      0x80      // compress 2-to-1

#define CASE_MASK            0x3f      // zero out compression bits

#define CASE_UPPER_MASK      0xe7      // zero out case bits
#define CASE_SMALL_MASK      0xf9      // zero out small modifier bits
#define CASE_KANA_MASK       0xdf      // zero out kana bit
#define CASE_WIDTH_MASK      0xfe      // zero out width bit

#define SW_POSITION_MASK     0x8003    // avoid 0 or 1 in bytes of word

//
//  Bit Mask Values for CompareString.
//
//  NOTE: Due to intel byte reversal, the DWORD value is backwards:
//                CW   DW   SM   AW
//
//  Case Weight (CW) - 8 bits:
//    bit 0   => width
//    bit 4   => case
//    bit 5   => kana
//    bit 6,7 => compression
//
#define CMP_MASKOFF_NONE          0xffffffff
#define CMP_MASKOFF_DW            0xff00ffff
#define CMP_MASKOFF_CW            0xe7ffffff
#define CMP_MASKOFF_DW_CW         0xe700ffff
#define CMP_MASKOFF_COMPRESSION   0x3fffffff

#define CMP_MASKOFF_KANA          0xdfffffff
#define CMP_MASKOFF_WIDTH         0xfeffffff
#define CMP_MASKOFF_KANA_WIDTH    0xdeffffff

//
//  Masks to isolate the various bits in the case weight.
//
//  NOTE: Bit 2 must always equal 1 to avoid getting a byte value
//        of either 0 or 1.
//
#define CASE_XW_MASK         0xc4

#define ISOLATE_SMALL        ( (BYTE)((~CASE_SMALL_MASK) | CASE_XW_MASK) )
#define ISOLATE_KANA         ( (BYTE)((~CASE_KANA_MASK)  | CASE_XW_MASK) )
#define ISOLATE_WIDTH        ( (BYTE)((~CASE_WIDTH_MASK) | CASE_XW_MASK) )

//
//  UW Mask for Cho-On:
//    Leaves bit 7 on in AW, so it becomes Repeat if it follows Kana N.
//
#define CHO_ON_UW_MASK       0xff87

//
//  Values for fareast special case alphanumeric weights.
//
#define AW_REPEAT            0
#define AW_CHO_ON            1
#define MAX_SPECIAL_AW       AW_CHO_ON

//
//  Values for weight 5 - East Asia Extra Weights.
//
#define WT_FIVE_KANA         3
#define WT_FIVE_REPEAT       4
#define WT_FIVE_CHO_ON       5

//
//  Values for CJK Unified Ideographs Extension A range.
//    0x3400 thru 0x4dbf
//
#define SM_EXT_A                  254       // SM for Extension A
#define AW_EXT_A                  255       // AW for Extension A

//
//  Values for UW extra weights (e.g. Jamo (old Hangul)).
//
#define SM_UW_XW                  255       // SM for extra UW weights


//
//  Script Member Values.
//
#define UNSORTABLE           0
#define NONSPACE_MARK        1
#define EXPANSION            2
#define FAREAST_SPECIAL      3
#define JAMO_SPECIAL         4
#define EXTENSION_A          5

#define PUNCTUATION          6

#define SYMBOL_1             7
#define SYMBOL_2             8
#define SYMBOL_3             9
#define SYMBOL_4             10
#define SYMBOL_5             11

#define NUMERIC_1            12
#define NUMERIC_2            13

#define LATIN                14
#define GREEK                15
#define CYRILLIC             16
#define ARMENIAN             17
#define HEBREW               18
#define ARABIC               19
#define DEVANAGARI           20
#define BENGALI              21
#define GURMUKKHI            22
#define GUJARATI             23
#define ORIYA                24
#define TAMIL                25
#define TELUGU               26
#define KANNADA              27
#define MALAYLAM             28
#define SINHALESE            29
#define THAI                 30
#define LAO                  31
#define TIBETAN              32
#define GEORGIAN             33
#define KANA                 34
#define BOPOMOFO             35
#define HANGUL               36
#define IDEOGRAPH            128

#define MAX_SPECIAL_CASE     SYMBOL_5
#define FIRST_SCRIPT         LATIN


//
//  Calendar Type Values.
//
#define CAL_NO_OPTIONAL      0                          // no optional calendars
#define CAL_LAST             CAL_GREGORIAN_XLIT_FRENCH  // greatest calendar value

//
//  The following calendars are defined in winnls.w:
//
//  #define CAL_GREGORIAN                  1
//  #define CAL_GREGORIAN_US               2
//  #define CAL_JAPAN                      3
//  #define CAL_TAIWAN                     4
//  #define CAL_KOREA                      5
//  #define CAL_HIJRI                      6
//  #define CAL_THAI                       7
//  #define CAL_HEBREW                     8
//  #define CAL_GREGORIAN_ME_FRENCH        9
//  #define CAL_GREGORIAN_ARABIC           10
//  #define CAL_GREGORIAN_XLIT_ENGLISH     11
//  #define CAL_GREGORIAN_XLIT_FRENCH      12
//


//
//  Constants to define range of Unicode private use area.
//
#define PRIVATE_USE_BEGIN    0xe000
#define PRIVATE_USE_END      0xf8ff


//
//  Internal flag for SpecialMBToWC routine.
//
#define MB_INVALID_CHAR_CHECK     MB_ERR_INVALID_CHARS

//
//  Geo values.
//
#define MAX_GEO_STRING_SIZE       1024

//
//  Resource String Table Values.
//
#define RC_STRING_SEPARATOR       '$'

#define RC_LANGUAGE_NAME          0
#define RC_COUNTRY_NAME           1
#define RC_LANGUAGE_GROUP_NAME    2
#define RC_CODE_PAGE_NAME         3
#define RC_GEO_FRIENDLY_NAME      4
#define RC_GEO_OFFICIAL_NAME      5
#define RC_SORT_NAMES             6




////////////////////////////////////////////////////////////////////////////
//
//  Typedef Declarations.
//
////////////////////////////////////////////////////////////////////////////

//
//  Constant Types
//
typedef  LPWORD        P844_TABLE;     // ptr to 8:4:4 table

typedef  LPWORD        PMB_TABLE;      // ptr to MB translation table
typedef  PMB_TABLE     PGLYPH_TABLE;   // ptr to GLYPH translation table
typedef  LPWORD        PDBCS_RANGE;    // ptr to DBCS range
typedef  LPWORD        PDBCS_OFFSETS;  // ptr to DBCS offset section
typedef  LPWORD        PDBCS_TABLE;    // ptr to DBCS translation table
typedef  PVOID         PWC_TABLE;      // ptr to WC translation table
typedef  P844_TABLE    PCTYPE;         // ptr to Character Type table
typedef  P844_TABLE    PCASE;          // ptr to Lower or Upper Case table
typedef  P844_TABLE    PADIGIT;        // ptr to Ascii Digits table
typedef  P844_TABLE    PCZONE;         // ptr to Fold Compat. Zone table
typedef  P844_TABLE    PKANA;          // ptr to Hiragana/Katakana table
typedef  P844_TABLE    PHALFWIDTH;     // ptr to Half Width table
typedef  P844_TABLE    PFULLWIDTH;     // ptr to Full Width table
typedef  P844_TABLE    PCHINESE;       // ptr to Traditional/Simplified Chinese table
typedef  P844_TABLE    PPRECOMP;       // ptr to PreComposed table
typedef  LPWORD        PCOMP_GRID;     // ptr to Composite table 2D grid
typedef  LPWORD        PLOC_INFO;      // ptr to locale information
typedef  LPWORD        PCAL_INFO;      // ptr to calendar information

typedef  DWORD         REVERSE_DW;     // reverse diacritic table
typedef  REVERSE_DW   *PREVERSE_DW;    // ptr to reverse diacritic table
typedef  DWORD         DBL_COMPRESS;   // double compression table
typedef  DBL_COMPRESS *PDBL_COMPRESS;  // ptr to double compression table
typedef  LPWORD        PCOMPRESS;      // ptr to compression table (2 or 3)

typedef  DWORD         NLSDEFINED;     // NLS defined codepoint table
typedef  NLSDEFINED   *PNLSDEFINED;    // ptr to NLS defined code point table

//
//  Proc Definition for Code Page DLL Routine.
//
typedef DWORD (*LPFN_CP_PROC)(DWORD, DWORD, LPSTR, int, LPWSTR, int, LPCPINFO);


//
//  CP Information Table Structure (as it is in the data file).
//
typedef struct cp_table_s {
    WORD      CodePage;                // code page number
    WORD      MaxCharSize;             // max length (bytes) of a char
    WORD      wDefaultChar;            // default character (MB)
    WORD      wUniDefaultChar;         // default character (Unicode)
    WORD      wTransDefaultChar;       // translation of wDefaultChar (Unicode)
    WORD      wTransUniDefaultChar;    // translation of wUniDefaultChar (MB)
    BYTE      LeadByte[MAX_LEADBYTES]; // lead byte ranges
} CP_TABLE, *PCP_TABLE;


//
//  Composite Information Structure.
//
typedef struct comp_info_s {
    BYTE           NumBase;            // number base chars in grid
    BYTE           NumNonSp;           // number non space chars in grid
    P844_TABLE     pBase;              // ptr to base char table
    P844_TABLE     pNonSp;             // ptr to nonspace char table
    PCOMP_GRID     pGrid;              // ptr to 2D grid
} COMP_INFO, *PCOMP_INFO;


//
//  Code Page Hash Table Structure.
//
typedef struct cp_hash_s {
    UINT           CodePage;           // codepage ID
    LPFN_CP_PROC   pfnCPProc;          // ptr to code page function proc
    PCP_TABLE      pCPInfo;            // ptr to CPINFO table
    PMB_TABLE      pMBTbl;             // ptr to MB translation table
    PGLYPH_TABLE   pGlyphTbl;          // ptr to GLYPH translation table
    PDBCS_RANGE    pDBCSRanges;        // ptr to DBCS ranges
    PDBCS_OFFSETS  pDBCSOffsets;       // ptr to DBCS offsets
    PWC_TABLE      pWC;                // ptr to WC table
    struct cp_hash_s *pNext;           // ptr to next CP hash node
} CP_HASH, *PCP_HASH;


//
//  Language Exception Header Structure.
//
typedef struct l_except_hdr_s {
    DWORD     Locale;                  // locale id
    DWORD     Offset;                  // offset to exception nodes (words)
    DWORD     NumUpEntries;            // number of upper case entries
    DWORD     NumLoEntries;            // number of lower case entries
} L_EXCEPT_HDR, *PL_EXCEPT_HDR;


//
//  Language Exception Structure.
//
typedef struct l_except_s
{
    WORD      UCP;                     // unicode code point
    WORD      AddAmount;               // amount to add to code point
} L_EXCEPT, *PL_EXCEPT;


//
//  CType header structure.
//
typedef struct ctype_hdr_s {
    WORD      TblSize;                 // size of ctype table
    WORD      MapSize;                 // size of mapping table
} CTYPE_HDR, *PCTYPE_HDR;


//
//  CType Table Structure (Mapping table structure).
//
typedef struct ct_values_s {
    WORD      CType1;                  // ctype 1 value
    WORD      CType2;                  // ctype 2 value
    WORD      CType3;                  // ctype 3 value
} CT_VALUES, *PCT_VALUES;


//
//  Sortkey Structure.
//
typedef struct sortkey_s {

    union {
        struct sm_aw_s {
            BYTE   Alpha;              // alphanumeric weight
            BYTE   Script;             // script member
        } SM_AW;

        WORD  Unicode;                 // unicode weight

    } UW;

    BYTE      Diacritic;               // diacritic weight
    BYTE      Case;                    // case weight (with COMP)

} SORTKEY, *PSORTKEY;


//
//  Sorting Version Info Structure.
//
typedef  struct _sortverinfo{
    LCID  Locale;       // Locale identifier
    DWORD Version;      // Sort version for this locale
}SORTVERINFO, *PSORTVERINFO;


//
//  Defined Code Point Version Info Structure.
//
typedef  struct _definedverinfo{
    DWORD       Version;          // Version of the Code Point table
    DWORD       dwOffset;         // Offset to the Defined Code Point table.
}DEFVERINFO, *PDEFVERINFO;


//
//  Extra Weight Structure.
//
typedef struct extra_wt_s {
    BYTE      Four;                    // weight 4
    BYTE      Five;                    // weight 5
    BYTE      Six;                     // weight 6
    BYTE      Seven;                   // weight 7
} EXTRA_WT, *PEXTRA_WT;


//
//  Compression Header Structure.
//  This is the header for the compression tables.
//
typedef struct compress_hdr_s {
    DWORD     Locale;                  // locale id
    DWORD     Offset;                  // offset (in words)
    WORD      Num2;                    // Number of 2 compressions
    WORD      Num3;                    // Number of 3 compressions
} COMPRESS_HDR, *PCOMPRESS_HDR;


//
//  Compression 2 Structure.
//  This is for a 2 code point compression - 2 code points
//  compress to ONE weight.
//
typedef struct compress_2_s {
    WCHAR     UCP1;                    // Unicode code point 1
    WCHAR     UCP2;                    // Unicode code point 2
    SORTKEY   Weights;                 // sortkey weights
} COMPRESS_2, *PCOMPRESS_2;


//
//  Compression 3 Structure.
//  This is for a 3 code point compression - 3 code points
//  compress to ONE weight.
//
typedef struct compress_3_s {
    WCHAR     UCP1;                    // Unicode code point 1
    WCHAR     UCP2;                    // Unicode code point 2
    WCHAR     UCP3;                    // Unicode code point 3
    WCHAR     Reserved;                // dword alignment
    SORTKEY   Weights;                 // sortkey weights
} COMPRESS_3, *PCOMPRESS_3;


//
//  Multiple Weight Structure.
//
typedef struct multiwt_s {
    BYTE      FirstSM;                 // value of first script member
    BYTE      NumSM;                   // number of script members in range
} MULTI_WT, *PMULTI_WT;


//
//  Ideograph Lcid Exception Structure.
//
typedef struct ideograph_lcid_s {
    DWORD     Locale;                  // locale id
    WORD      pFileName[14];           // ptr to file name
} IDEOGRAPH_LCID, *PIDEOGRAPH_LCID;


//
//  Expansion Structure.
//
typedef struct expand_s {
    WCHAR     UCP1;                    // Unicode code point 1
    WCHAR     UCP2;                    // Unicode code point 2
} EXPAND, *PEXPAND;


//
//  Exception Header Structure.
//  This is the header for the exception tables.
//
typedef struct except_hdr_s {
    DWORD     Locale;                  // locale id
    DWORD     Offset;                  // offset to exception nodes (words)
    DWORD     NumEntries;              // number of entries for locale id
} EXCEPT_HDR, *PEXCEPT_HDR;


//
//  Exception Structure.
//
//  NOTE: May also be used for Ideograph Exceptions (4 column tables).
//
typedef struct except_s
{
    WORD      UCP;                     // unicode code point
    WORD      Unicode;                 // unicode weight
    BYTE      Diacritic;               // diacritic weight
    BYTE      Case;                    // case weight
} EXCEPT, *PEXCEPT;


//
//  Ideograph Exception Header Structure.
//
typedef struct ideograph_except_hdr_s
{
    DWORD     NumEntries;              // number of entries in table
    DWORD     NumColumns;              // number of columns in table (2 or 4)
} IDEOGRAPH_EXCEPT_HDR, *PIDEOGRAPH_EXCEPT_HDR;


//
//  Ideograph Exception Structure.
//
typedef struct ideograph_except_s
{
    WORD      UCP;                     // unicode code point
    WORD      Unicode;                 // unicode weight
} IDEOGRAPH_EXCEPT, *PIDEOGRAPH_EXCEPT;


//
//  Locale Information Structures.
//
//  This is the format in which the locale information is kept in the
//  locale data file.  These structures are only used for offsets into
//  the data file, not to store information.
//

//
//  Header at the top of the locale.nls file.
//
typedef struct loc_cal_hdr_s
{
    DWORD     NumLocales;              // number of locales
    DWORD     NumCalendars;            // number of calendars
    DWORD     CalOffset;               // offset to calendar info (words)
} LOC_CAL_HDR, *PLOC_CAL_HDR;

#define LOCALE_HDR_OFFSET    (sizeof(LOC_CAL_HDR) / sizeof(WORD))

//
//  Per entry locale header.
//
//  The locale header structure contains the information given in one entry
//  of the header for the locale information.
//
typedef struct locale_hdr_s {
    DWORD     Locale;                  // locale ID
    DWORD     Offset;                  // offset to locale information
} LOCALE_HDR, *PLOCALE_HDR;

#define LOCALE_HDR_SIZE  (sizeof(LOCALE_HDR) / sizeof(WORD))

//
//  The fixed structure contains the locale information that is of
//  fixed length and in the order in which it is given in the file.
//
typedef struct locale_fixed_s
{
    WORD      DefaultACP;              // default ACP - integer format
    WORD      szILanguage[5];          // language id
    WORD      szICountry[6];           // country id
    WORD      szIGeoID[8];            // geographical location identifier
    WORD      szIDefaultLang[5];       // default language ID
    WORD      szIDefaultCtry[6];       // default country ID
    WORD      szIDefaultACP[6];        // default ansi code page ID
    WORD      szIDefaultOCP[6];        // default oem code page ID
    WORD      szIDefaultMACCP[6];      // default mac code page ID
    WORD      szIDefaultEBCDICCP[6];   // default ebcdic code page ID
    WORD      szIMeasure[2];           // system of measurement
    WORD      szIPaperSize[2];         // default paper size
    WORD      szIDigits[3];            // number of fractional digits
    WORD      szILZero[2];             // leading zeros for decimal
    WORD      szINegNumber[2];         // negative number format
    WORD      szIDigitSubstitution[2]; // digit substitution
    WORD      szICurrDigits[3];        // # local monetary fractional digits
    WORD      szIIntlCurrDigits[3];    // # intl monetary fractional digits
    WORD      szICurrency[2];          // positive currency format
    WORD      szINegCurr[3];           // negative currency format
    WORD      szIPosSignPosn[2];       // format of positive sign
    WORD      szIPosSymPrecedes[2];    // if mon symbol precedes positive
    WORD      szIPosSepBySpace[2];     // if mon symbol separated by space
    WORD      szINegSignPosn[2];       // format of negative sign
    WORD      szINegSymPrecedes[2];    // if mon symbol precedes negative
    WORD      szINegSepBySpace[2];     // if mon symbol separated by space
    WORD      szITime[2];              // time format
    WORD      szITLZero[2];            // leading zeros for time field
    WORD      szITimeMarkPosn[2];      // time marker position
    WORD      szIDate[2];              // short date order
    WORD      szICentury[2];           // century format (short date)
    WORD      szIDayLZero[2];          // leading zeros for day field (short date)
    WORD      szIMonLZero[2];          // leading zeros for month field (short date)
    WORD      szILDate[2];             // long date order
    WORD      szICalendarType[3];      // type of calendar
    WORD      szIFirstDayOfWk[2];      // first day of week
    WORD      szIFirstWkOfYr[2];       // first week of year
    WORD      szFontSignature[MAX_FONTSIGNATURE];
} LOCALE_FIXED, *PLOCALE_FIXED;

//
//  The variable structure contains the offsets to the various pieces of
//  locale information that is of variable length.  It is in the order
//  in which it is given in the file.
//
typedef struct locale_var_s
{
    WORD      SEngLanguage;            // English language name
    WORD      SAbbrevLang;             // abbreviated language name
    WORD      SAbbrevLangISO;          // ISO abbreviated language name
    WORD      SNativeLang;             // native language name
    WORD      SEngCountry;             // English country name
    WORD      SAbbrevCtry;             // abbreviated country name
    WORD      SAbbrevCtryISO;          // ISO abbreviated country name
    WORD      SNativeCtry;             // native country name
    WORD      SList;                   // list separator
    WORD      SDecimal;                // decimal separator
    WORD      SThousand;               // thousands separator
    WORD      SGrouping;               // grouping of digits
    WORD      SNativeDigits;           // native digits 0-9
    WORD      SCurrency;               // local monetary symbol
    WORD      SIntlSymbol;             // international monetary symbol
    WORD      SEngCurrName;            // English currency name
    WORD      SNativeCurrName;         // native currency name
    WORD      SMonDecSep;              // monetary decimal separator
    WORD      SMonThousSep;            // monetary thousands separator
    WORD      SMonGrouping;            // monetary grouping of digits
    WORD      SPositiveSign;           // positive sign
    WORD      SNegativeSign;           // negative sign
    WORD      STimeFormat;             // time format
    WORD      STime;                   // time separator
    WORD      S1159;                   // AM designator
    WORD      S2359;                   // PM designator
    WORD      SShortDate;              // short date format
    WORD      SDate;                   // date separator
    WORD      SYearMonth;              // year month format
    WORD      SLongDate;               // long date format
    WORD      IOptionalCal;            // additional calendar type(s)
    WORD      SDayName1;               // day name 1
    WORD      SDayName2;               // day name 2
    WORD      SDayName3;               // day name 3
    WORD      SDayName4;               // day name 4
    WORD      SDayName5;               // day name 5
    WORD      SDayName6;               // day name 6
    WORD      SDayName7;               // day name 7
    WORD      SAbbrevDayName1;         // abbreviated day name 1
    WORD      SAbbrevDayName2;         // abbreviated day name 2
    WORD      SAbbrevDayName3;         // abbreviated day name 3
    WORD      SAbbrevDayName4;         // abbreviated day name 4
    WORD      SAbbrevDayName5;         // abbreviated day name 5
    WORD      SAbbrevDayName6;         // abbreviated day name 6
    WORD      SAbbrevDayName7;         // abbreviated day name 7
    WORD      SMonthName1;             // month name 1
    WORD      SMonthName2;             // month name 2
    WORD      SMonthName3;             // month name 3
    WORD      SMonthName4;             // month name 4
    WORD      SMonthName5;             // month name 5
    WORD      SMonthName6;             // month name 6
    WORD      SMonthName7;             // month name 7
    WORD      SMonthName8;             // month name 8
    WORD      SMonthName9;             // month name 9
    WORD      SMonthName10;            // month name 10
    WORD      SMonthName11;            // month name 11
    WORD      SMonthName12;            // month name 12
    WORD      SMonthName13;            // month name 13 (if exists)
    WORD      SAbbrevMonthName1;       // abbreviated month name 1
    WORD      SAbbrevMonthName2;       // abbreviated month name 2
    WORD      SAbbrevMonthName3;       // abbreviated month name 3
    WORD      SAbbrevMonthName4;       // abbreviated month name 4
    WORD      SAbbrevMonthName5;       // abbreviated month name 5
    WORD      SAbbrevMonthName6;       // abbreviated month name 6
    WORD      SAbbrevMonthName7;       // abbreviated month name 7
    WORD      SAbbrevMonthName8;       // abbreviated month name 8
    WORD      SAbbrevMonthName9;       // abbreviated month name 9
    WORD      SAbbrevMonthName10;      // abbreviated month name 10
    WORD      SAbbrevMonthName11;      // abbreviated month name 11
    WORD      SAbbrevMonthName12;      // abbreviated month name 12
    WORD      SAbbrevMonthName13;      // abbreviated month name 13 (if exists)
    WORD      SEndOfLocale;            // end of locale information
} LOCALE_VAR, *PLOCALE_VAR;


//
//  Per entry calendar header.
//
//  The calendar header structure contains the information given in one entry
//  of the header for the calendar information.
//
typedef struct calendar_hdr_s
{
    WORD      Calendar;                // calendar id
    WORD      Offset;                  // offset to calendar info (words)
} CALENDAR_HDR, *PCALENDAR_HDR;

#define CALENDAR_HDR_SIZE  (sizeof(CALENDAR_HDR) / sizeof(WORD))

//
//  The variable structure contains the offsets to the various pieces of
//  calendar information that is of variable length.  It is in the order
//  in which it is given in the file.
//
//  The NumRanges value is the number of era ranges.  If this value is zero,
//  then there are no year offsets.
//
//  The IfNames value is a boolean.  If it is 0, then there are NO special
//  day or month names for the calendar.  If it is 1, then there ARE
//  special day and month names for the calendar.
//
//  The rest of the values are offsets to the appropriate strings.
//
typedef struct calendar_var_s
{
    WORD      NumRanges;               // number of era ranges
    WORD      IfNames;                 // if any day or month names exist
    WORD      SCalendar;               // calendar id
    WORD      STwoDigitYearMax;        // two digit year max
    WORD      SEraRanges;              // era ranges
    WORD      SShortDate;              // short date format
    WORD      SYearMonth;              // year month format
    WORD      SLongDate;               // long date format
    WORD      SDayName1;               // day name 1
    WORD      SDayName2;               // day name 2
    WORD      SDayName3;               // day name 3
    WORD      SDayName4;               // day name 4
    WORD      SDayName5;               // day name 5
    WORD      SDayName6;               // day name 6
    WORD      SDayName7;               // day name 7
    WORD      SAbbrevDayName1;         // abbreviated day name 1
    WORD      SAbbrevDayName2;         // abbreviated day name 2
    WORD      SAbbrevDayName3;         // abbreviated day name 3
    WORD      SAbbrevDayName4;         // abbreviated day name 4
    WORD      SAbbrevDayName5;         // abbreviated day name 5
    WORD      SAbbrevDayName6;         // abbreviated day name 6
    WORD      SAbbrevDayName7;         // abbreviated day name 7
    WORD      SMonthName1;             // month name 1
    WORD      SMonthName2;             // month name 2
    WORD      SMonthName3;             // month name 3
    WORD      SMonthName4;             // month name 4
    WORD      SMonthName5;             // month name 5
    WORD      SMonthName6;             // month name 6
    WORD      SMonthName7;             // month name 7
    WORD      SMonthName8;             // month name 8
    WORD      SMonthName9;             // month name 9
    WORD      SMonthName10;            // month name 10
    WORD      SMonthName11;            // month name 11
    WORD      SMonthName12;            // month name 12
    WORD      SMonthName13;            // month name 13
    WORD      SAbbrevMonthName1;       // abbreviated month name 1
    WORD      SAbbrevMonthName2;       // abbreviated month name 2
    WORD      SAbbrevMonthName3;       // abbreviated month name 3
    WORD      SAbbrevMonthName4;       // abbreviated month name 4
    WORD      SAbbrevMonthName5;       // abbreviated month name 5
    WORD      SAbbrevMonthName6;       // abbreviated month name 6
    WORD      SAbbrevMonthName7;       // abbreviated month name 7
    WORD      SAbbrevMonthName8;       // abbreviated month name 8
    WORD      SAbbrevMonthName9;       // abbreviated month name 9
    WORD      SAbbrevMonthName10;      // abbreviated month name 10
    WORD      SAbbrevMonthName11;      // abbreviated month name 11
    WORD      SAbbrevMonthName12;      // abbreviated month name 12
    WORD      SAbbrevMonthName13;      // abbreviated month name 13
    WORD      SEndOfCalendar;          // end of calendar information
} CALENDAR_VAR, *PCALENDAR_VAR;

//
//  IOptionalCalendar structure (locale info).
//
typedef struct opt_cal_s
{
    WORD      CalId;                   // calendar id
    WORD      Offset;                  // offset to next optional calendar
    WORD      pCalStr[1];              // calendar id string (variable length)
//  WORD      pCalNameStr[1];          // calendar name string (variable length)
} OPT_CAL, *POPT_CAL;


//
//  SEraRanges structure inside calendar info.
//
typedef struct era_range_s
{
    WORD      Month;                   // month of era beginning
    WORD      Day;                     // day of era beginning
    WORD      Year;                    // year of era beginning
    WORD      Offset;                  // offset to next era info block
    WORD      pYearStr[1];             // year string (variable length)
//  WORD      pEraNameStr[1];          // era name string (variable length)
} ERA_RANGE, *PERA_RANGE;


//
//  Locale Hash Table Structure.
//
typedef struct loc_hash_s {
    LCID           Locale;             // locale ID
    PLOCALE_VAR    pLocaleHdr;         // ptr to locale header info
    PLOCALE_FIXED  pLocaleFixed;       // ptr to locale fixed size info
    PCASE          pUpperCase;         // ptr to Upper Case table
    PCASE          pLowerCase;         // ptr to Lower Case table
    PCASE          pUpperLinguist;     // ptr to Upper Case Linguistic table
    PCASE          pLowerLinguist;     // ptr to Lower Case Linguistic table
    PSORTKEY       pSortkey;           // ptr to sortkey table
    BOOL           IfReverseDW;        // if DW should go from right to left
    BOOL           IfCompression;      // if compression code points exist
    BOOL           IfDblCompression;   // if double compression exists
    BOOL           IfIdeographFailure; // if ideograph table failed to load
    PCOMPRESS_HDR  pCompHdr;           // ptr to compression header
    PCOMPRESS_2    pCompress2;         // ptr to 2 compression table
    PCOMPRESS_3    pCompress3;         // ptr to 3 compression table
    struct loc_hash_s *pNext;          // ptr to next locale hash node
} LOC_HASH, *PLOC_HASH;


//
//  Hash Table Pointers.
//
typedef  PCP_HASH  *PCP_HASH_TBL;      // ptr to a code page hash table
typedef  PLOC_HASH *PLOC_HASH_TBL;     // ptr to a locale hash table


//
//  Geo Information structure. This structure holds information about
//  a geographical location on earth.
//
typedef struct tagGeoInfo {
    GEOID       GeoId;
    WCHAR       szLatitude[12];
    WCHAR       szLongitude[12];
    GEOCLASS    GeoClass;
    GEOID       ParentGeoId;
    WCHAR       szISO3166Abbrev2[4];
    WCHAR       szISO3166Abbrev3[4];
    WORD        wISO3166;
    WORD        Reserved;              // dword alignment
} GEOINFO, *PGEOINFO;


//
//  GEOID/LCID structure. This structure is used to navigate through
//  the table that maps corresponding Language ID and Geo ID.
//
typedef struct tagGEOIDLCID {
    LCID    lcid;
    GEOID   GeoId;
    LANGID  LangId;
    WORD    Reserved;                  // dword alignment
} GEOLCID, *PGEOLCID;


//
//  GEO tables structure. This structure is used to get information
//  related to all geo tables.
//
typedef struct tagGeoTableHdr {
    WCHAR           szSig[4];
    unsigned long   nFileSize;
    DWORD           dwOffsetGeoInfo;
    long            nGeoInfo;
    DWORD           dwOffsetGeoLCID;
    long            nGeoLCID;
} GEOTABLEHDR, *PGEOTABLEHDR;


//
//  Jamo Sequence Sorting Info.
//
typedef struct {
    BYTE m_bOld;                  // sequence occurs only in old Hangul flag
    CHAR m_chLeadingIndex;        // indices used to locate prior modern Hangul syllable
    CHAR m_chVowelIndex;
    CHAR m_chTrailingIndex;
    BYTE m_ExtraWeight;           // extra weights that distinguish this from
                                  //   other old Hangul syllables, depending
                                  //   on the jamo, this can be a weight for
                                  //   leading jamo, vowel jamo, or trailing jamo.
} JAMO_SORT_INFO, *PJAMO_SORT_INFO;

//
//  Jamo Index Table Entry.
//
typedef struct {
    JAMO_SORT_INFO SortInfo;      // sequence sorting info
    BYTE Index;                   // index into the composition array
    BYTE TransitionCount;         // # of possible transitions from this state
    BYTE Reserved;                // word alignment
} JAMO_TABLE, *PJAMO_TABLE;


//
//  Jamo Combination Table Entry.
//
//  NOTE: Make sure this structure is WORD aligned.  Otherwise, code will
//        fail in GetDefaultSortTable().
//
typedef struct {
    WCHAR m_wcCodePoint;          // Code point value that enters this state
    JAMO_SORT_INFO m_SortInfo;    // Sequence sorting info
    BYTE m_bTransitionCount;      // # of possible transitions from this state
} JAMO_COMPOSE_STATE, *PJAMO_COMPOSE_STATE;


//
//  Table Pointers Structure.  This structure contains pointers to
//  the various tables needed for the NLS APIs.  There should be only
//  ONE of these for each process, and the information should be
//  global to the process.
//
#define NUM_SM     256                  // total number of script members
#define NUM_CAL    64                   // total number calendars allowed

typedef struct tbl_ptrs_s {
    PCP_HASH_TBL    pCPHashTbl;         // ptr to Code Page hash table
    PLOC_HASH_TBL   pLocHashTbl;        // ptr to Locale hash table
    PLOC_INFO       pLocaleInfo;        // ptr to locale table (all locales)
    DWORD           NumCalendars;       // number of calendars
    PCAL_INFO       pCalendarInfo;      // ptr to beginning of calendar info
    PCAL_INFO       pCalTbl[NUM_CAL];   // ptr to calendar table array
    P844_TABLE      pDefaultLanguage;   // ptr to default language table
    P844_TABLE      pLinguistLanguage;  // ptr to default linguistic lang table
    LARGE_INTEGER   LinguistLangSize;   // size of linguistic lang table
    int             NumLangException;   // number of language exceptions
    PL_EXCEPT_HDR   pLangExceptHdr;     // ptr to lang exception table header
    PL_EXCEPT       pLangException;     // ptr to lang exception tables
    PCT_VALUES      pCTypeMap;          // ptr to Ctype Mapping table
    PCTYPE          pCType844;          // ptr to Ctype 8:4:4 table
    PADIGIT         pADigit;            // ptr to Ascii Digits table
    PCZONE          pCZone;             // ptr to Compatibility Zone table
    PKANA           pHiragana;          // ptr to Hiragana table
    PKANA           pKatakana;          // ptr to Katakana table
    PHALFWIDTH      pHalfWidth;         // ptr to Half Width table
    PFULLWIDTH      pFullWidth;         // ptr to Full Width table
    PCHINESE        pTraditional;       // ptr to Traditional Chinese table
    PCHINESE        pSimplified;        // ptr to Simplified Chinese table
    PPRECOMP        pPreComposed;       // ptr to PreComposed Table
    PCOMP_INFO      pComposite;         // ptr to Composite info structure
    DWORD           NumReverseDW;       // number of REVERSE DIACRITICS
    DWORD           NumDblCompression;  // number of DOUBLE COMPRESSION locales
    DWORD           NumIdeographLcid;   // number of IDEOGRAPH LCIDs
    DWORD           NumExpansion;       // number of EXPANSIONS
    DWORD           NumCompression;     // number of COMPRESSION locales
    DWORD           NumException;       // number of EXCEPTION locales
    DWORD           NumMultiWeight;     // number of MULTIPLE WEIGHTS
    int             NumJamoIndex;       // number of entires for Jamo Index Table
    int             NumJamoComposition; // number of entires for Jamo Composition Table
    PSORTKEY        pDefaultSortkey;    // ptr to default sortkey table
    LARGE_INTEGER   DefaultSortkeySize; // size of default sortkey section
    PREVERSE_DW     pReverseDW;         // ptr to reverse diacritic table
    PDBL_COMPRESS   pDblCompression;    // ptr to double compression table
    PIDEOGRAPH_LCID pIdeographLcid;     // ptr to ideograph lcid table
    PEXPAND         pExpansion;         // ptr to expansion table
    PCOMPRESS_HDR   pCompressHdr;       // ptr to compression table header
    PCOMPRESS       pCompression;       // ptr to compression tables
    PEXCEPT_HDR     pExceptHdr;         // ptr to exception table header
    PEXCEPT         pException;         // ptr to exception tables
    PMULTI_WT       pMultiWeight;       // ptr to multiple weights table
    BYTE            SMWeight[NUM_SM];   // script member weights
    PJAMO_TABLE     pJamoIndex;         // ptr ot Jamo Index table
    PJAMO_COMPOSE_STATE pJamoComposition;  // ptr to Jamo Composition state machine table
    long            nGeoInfo;           // number of GEOINFO entries
    PGEOINFO        pGeoInfo;           // ptr to gegraphical info location table
    long            nGeoLCID;           // number of GEOID/LCID entries
    PGEOLCID        pGeoLCID;           // ptr to GEOID/LCID mapping table
    DWORD           NumSortVersion;     // number of sorting version
    PSORTVERINFO    pSortVersion;       // ptr sorting version info
    DWORD           NumDefinedVersion;  // number of defined code point version 
    PDEFVERINFO     pDefinedVersion;    // ptr defined code point version
    LPWORD          pSortingTableFileBase;  // The base address of sorting table file
} TBL_PTRS, *PTBL_PTRS;

typedef struct nls_locale_cache
{
    NLS_USER_INFO NlsInfo;              // NLS cached information
    HKEY CurrentUserKeyHandle;          // Cached key handle thread impersonation

} NLS_LOCAL_CACHE, *PNLS_LOCAL_CACHE;


//
//  Generic Enum Proc Definitions.
//
typedef BOOL (CALLBACK* NLS_ENUMPROC)(PVOID);
typedef BOOL (CALLBACK* NLS_ENUMPROCEX)(PVOID, DWORD);
typedef BOOL (CALLBACK* NLS_ENUMPROC2)(DWORD, DWORD, PVOID, LONG_PTR);
typedef BOOL (CALLBACK* NLS_ENUMPROC3)(DWORD, PVOID, PVOID, DWORD, LONG_PTR);
typedef BOOL (CALLBACK* NLS_ENUMPROC4)(PVOID, LONG_PTR);





////////////////////////////////////////////////////////////////////////////
//
//  Macro Definitions.
//
////////////////////////////////////////////////////////////////////////////

//
//  Get the wide character count from a byte count.
//
#define GET_WC_COUNT(bc)          ((bc) / sizeof(WCHAR))

//
//  Get the data pointer for the KEY_VALUE_FULL_INFORMATION structure.
//
#define GET_VALUE_DATA_PTR(p)     ((LPWSTR)((PBYTE)(p) + (p)->DataOffset))

//
//  Macros For High and Low Nibbles of a BYTE.
//
#define LO_NIBBLE(b)              ((BYTE)((BYTE)(b) & 0xF))
#define HI_NIBBLE(b)              ((BYTE)(((BYTE)(b) >> 4) & 0xF))

//
//  Macros for Extracting the 8:4:4 Index Values.
//
#define GET8(w)                   (HIBYTE(w))
#define GETHI4(w)                 (HI_NIBBLE(LOBYTE(w)))
#define GETLO4(w)                 (LO_NIBBLE(LOBYTE(w)))


//
//  Macros for setting and checking most significant bit of flag.
//
#define SET_MSB(fl)               (fl |= MSB_FLAG)
#define IS_MSB(fl)                (fl & MSB_FLAG)

//
//  Macro to check if more than one bit is set.
//  Returns 1 if more than one bit set, 0 otherwise.
//
#define MORE_THAN_ONE(f, bits)    (((f & bits) - 1) & (f & bits))

//
//  Macros for single and double byte code pages.
//
#define IS_SBCS_CP(pHash)         (pHash->pCPInfo->MaxCharSize == 1)
#define IS_DBCS_CP(pHash)         (pHash->pCPInfo->MaxCharSize == 2)


////////////////////////////////////////////////////////////////////////////
//
//  TRAVERSE_844_B
//
//  Traverses the 8:4:4 translation table for the given wide character.  It
//  returns the final value of the 8:4:4 table, which is a BYTE in length.
//
//  NOTE: Offsets in table are in BYTES.
//
//    Broken Down Version:
//    --------------------
//        Incr = pTable[GET8(wch)] / sizeof(WORD);
//        Incr = pTable[Incr + GETHI4(wch)];
//        Value = (BYTE *)pTable[Incr + GETLO4(wch)];
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define TRAVERSE_844_B(pTable, wch)                                        \
    (((BYTE *)pTable)[pTable[(pTable[GET8(wch)] / sizeof(WORD)) +          \
                               GETHI4(wch)] +                              \
                      GETLO4(wch)])


////////////////////////////////////////////////////////////////////////////
//
//  TRAVERSE_844_W
//
//  Traverses the 8:4:4 translation table for the given wide character.  It
//  returns the final value of the 8:4:4 table, which is a WORD in length.
//
//    Broken Down Version:
//    --------------------
//        Incr = pTable[GET8(wch)];
//        Incr = pTable[Incr + GETHI4(wch)];
//        Value = pTable[Incr + GETLO4(wch)];
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define TRAVERSE_844_W(pTable, wch)                                        \
    (pTable[pTable[pTable[GET8(wch)] + GETHI4(wch)] + GETLO4(wch)])


////////////////////////////////////////////////////////////////////////////
//
//  TRAVERSE_844_D
//
//  Traverses the 8:4:4 translation table for the given wide character.  It
//  fills in the final word values, Value1 and Value2.  The final value of the
//  8:4:4 table is a DWORD, so both Value1 and Value2 are filled in.
//
//    Broken Down Version:
//    --------------------
//        Incr = pTable[GET8(wch)];
//        Incr = pTable[Incr + GETHI4(wch)];
//        pTable += Incr + (GETLO4(wch) * 2);
//        Value1 = pTable[0];
//        Value2 = pTable[1];
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define TRAVERSE_844_D(pTable, wch, Value1, Value2)                        \
{                                                                          \
    pTable += pTable[pTable[GET8(wch)] + GETHI4(wch)] + (GETLO4(wch) * 2); \
    Value1 = pTable[0];                                                    \
    Value2 = pTable[1];                                                    \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_INCR_VALUE
//
//  Gets the value of a given wide character from the given 8:4:4 table.  It
//  then uses the value as an increment by adding it to the given wide
//  character code point.
//
//  NOTE:  Whenever there is no translation for the given code point, the
//         tables will return an increment value of 0.  This way, the
//         wide character passed in is the same value that is returned.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_INCR_VALUE(p844Tbl, wch)                                       \
     ((WCHAR)(wch + TRAVERSE_844_W(p844Tbl, wch)))


////////////////////////////////////////////////////////////////////////////
//
//  GET_LOWER_UPPER_CASE
//
//  Gets the lower/upper case value of a given wide character.  If a
//  lower/upper case value exists, it returns the lower/upper case wide
//  character.  Otherwise, it returns the same character passed in wch.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_LOWER_UPPER_CASE(pCaseTbl, wch)                                \
    (GET_INCR_VALUE(pCaseTbl, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_ASCII_DIGITS
//
//  Gets the ascii translation for the given digit character.  If no
//  translation is found, then the given character is returned.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_ASCII_DIGITS(pADigit, wch)                                     \
    (GET_INCR_VALUE(pADigit, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_FOLD_CZONE
//
//  Gets the translation for the given compatibility zone character.  If no
//  translation is found, then the given character is returned.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_FOLD_CZONE(pCZone, wch)                                        \
    (GET_INCR_VALUE(pCZone, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_KANA
//
//  Gets the Hiragana/Katakana equivalent for the given Katakana/Hiragana
//  character.  If no translation is found, then the given character is
//  returned.
//
//  DEFINED AS A MACRO.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_KANA(pKana, wch)                                               \
    (GET_INCR_VALUE(pKana, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_HALF_WIDTH
//
//  Gets the Half Width equivalent for the given Full Width character.  If no
//  translation is found, then the given character is returned.
//
//  DEFINED AS A MACRO.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_HALF_WIDTH(pHalf, wch)                                         \
    (GET_INCR_VALUE(pHalf, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_FULL_WIDTH
//
//  Gets the Full Width equivalent for the given Half Width character.  If no
//  translation is found, then the given character is returned.
//
//  DEFINED AS A MACRO.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_FULL_WIDTH(pFull, wch)                                         \
    (GET_INCR_VALUE(pFull, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_CHINESE
//
//  Gets the Traditional/Simplified Chinese translation for the given
//  Simplified/Traditional Chinese character.  If no translation is found,
//  then the given character is returned.
//
//  DEFINED AS A MACRO.
//
//  05-07-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_CHINESE(pChinese, wch)                                         \
    (GET_INCR_VALUE(pChinese, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_CTYPE
//
//  Gets the ctype information for a given wide character.  If the ctype
//  information exists, it returns it.  Otherwise, it returns 0.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_CTYPE(wch, offset)                                             \
    ((((PCT_VALUES)(pTblPtrs->pCTypeMap)) +                                \
      (TRAVERSE_844_B((pTblPtrs->pCType844), wch)))->offset)


////////////////////////////////////////////////////////////////////////////
//
//  GET_BASE_CHAR
//
//  Gets the base character of a given precomposed character.  If the
//  composite form is found, it returns the base character.  Otherwise,
//  it returns 0 for failure.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_BASE_CHAR(wch, Base)                                           \
{                                                                          \
    WCHAR NonSp;                  /* nonspacing character */               \
    WCHAR NewBase;                /* base character - temp holder */       \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Get composite characters.                                          \
     */                                                                    \
    if (GetCompositeChars(wch, &NonSp, &Base))                             \
    {                                                                      \
        while (GetCompositeChars(Base, &NonSp, &NewBase))                  \
        {                                                                  \
            Base = NewBase;                                                \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Return failure - no composite form.                            \
         */                                                                \
        Base = 0;                                                          \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  SORTKEY WEIGHT MACROS
//
//  Parse out the different sortkey weights from a DWORD value.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_SCRIPT_MEMBER(pwt)  ( (BYTE)(((PSORTKEY)(pwt))->UW.SM_AW.Script) )
#define GET_ALPHA_NUMERIC(pwt)  ( (BYTE)(((PSORTKEY)(pwt))->UW.SM_AW.Alpha) )

#define GET_UNICODE(pwt)        ( (WORD)(((PSORTKEY)(pwt))->UW.Unicode) )

#define GET_UNICODE_SM(pwt, sm) ( (WORD)(((PSORTKEY)(pwt))->UW.Unicode) )

#define GET_UNICODE_MOD(pwt, modify_sm)                                    \
    ( (modify_sm) ?                                                        \
        ((WORD)                                                            \
         ((((WORD)((pTblPtrs->SMWeight)[GET_SCRIPT_MEMBER(pwt)])) << 8) |  \
          (WORD)GET_ALPHA_NUMERIC(pwt))) :                                 \
        ((WORD)(((PSORTKEY)(pwt))->UW.Unicode)) )

#define GET_UNICODE_SM_MOD(pwt, sm, modify_sm)                             \
    ( (modify_sm) ?                                                        \
        ((WORD)                                                            \
         ((((WORD)((pTblPtrs->SMWeight)[sm])) << 8) |                      \
          (WORD)GET_ALPHA_NUMERIC(pwt))) :                                 \
        ((WORD)(((PSORTKEY)(pwt))->UW.Unicode)) )

#define MAKE_UNICODE_WT(sm, aw, modify_sm)                                 \
    ( (modify_sm) ?                                                        \
        ((WORD)((((WORD)((pTblPtrs->SMWeight)[sm])) << 8) | (WORD)(aw))) : \
        ((WORD)((((WORD)(sm)) << 8) | (WORD)(aw))) )

#define UNICODE_WT(pwt)           ( (WORD)(((PSORTKEY)(pwt))->UW.Unicode) )

#define GET_DIACRITIC(pwt)        ( (BYTE)(((PSORTKEY)(pwt))->Diacritic) )

#define GET_CASE(pwt)             ( (BYTE)((((PSORTKEY)(pwt))->Case) & CASE_MASK) )

#define CASE_WT(pwt)              ( (BYTE)(((PSORTKEY)(pwt))->Case) )

#define GET_COMPRESSION(pwt)      ( (BYTE)((((PSORTKEY)(pwt))->Case) & COMPRESS_3_MASK) )

#define GET_EXPAND_INDEX(pwt)     ( (BYTE)(((PSORTKEY)(pwt))->UW.SM_AW.Alpha) )

#define GET_SPECIAL_WEIGHT(pwt)   ( (WORD)(((PSORTKEY)(pwt))->UW.Unicode) )

//  position returned is backwards - byte reversal
#define GET_POSITION_SW(pos)      ( (WORD)(((pos) << 2) | SW_POSITION_MASK) )


#define GET_WT_FOUR(pwt)          ( (BYTE)(((PEXTRA_WT)(pwt))->Four) )
#define GET_WT_FIVE(pwt)          ( (BYTE)(((PEXTRA_WT)(pwt))->Five) )
#define GET_WT_SIX(pwt)           ( (BYTE)(((PEXTRA_WT)(pwt))->Six) )
#define GET_WT_SEVEN(pwt)         ( (BYTE)(((PEXTRA_WT)(pwt))->Seven) )


#define MAKE_SORTKEY_DWORD(wt)    ( (DWORD)(*((LPDWORD)(&(wt)))) )

#define MAKE_EXTRA_WT_DWORD(wt)   ( (DWORD)(*((LPDWORD)(&(wt)))) )

#define GET_DWORD_WEIGHT(pHashN, wch)                                      \
    ( MAKE_SORTKEY_DWORD(((pHashN)->pSortkey)[wch]) )

#define GET_EXPANSION_1(pwt)                                               \
    ( ((pTblPtrs->pExpansion)[GET_EXPAND_INDEX(pwt)]).UCP1 )

#define GET_EXPANSION_2(pwt)                                               \
    ( ((pTblPtrs->pExpansion)[GET_EXPAND_INDEX(pwt)]).UCP2 )




#define IS_SYMBOL(pSkey, wch)                                              \
    ( (GET_SCRIPT_MEMBER(&((pSkey)[wch])) >= PUNCTUATION) &&               \
      (GET_SCRIPT_MEMBER(&((pSkey)[wch])) <= SYMBOL_5) )

#define IS_NONSPACE_ONLY(pSkey, wch)                                       \
    ( GET_SCRIPT_MEMBER(&((pSkey)[wch])) == NONSPACE_MARK )

#define IS_NONSPACE(pSkey, wch)                                            \
    ( (GET_SCRIPT_MEMBER(&((pSkey)[wch])) == NONSPACE_MARK) ||             \
      (GET_DIACRITIC(&((pSkey)[wch])) > MIN_DW) )

#define IS_ALPHA(ctype1)          ( (ctype1) & C1_ALPHA )




#define IS_KOREAN(lcid)                                                    \
    ( LANGIDFROMLCID(lcid) == MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN) )




////////////////////////////////////////////////////////////////////////////
//
//  CHECK_SPECIAL_LOCALES
//
//  Checks for the special locale values and sets the Locale to the
//  appropriate value.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CHECK_SPECIAL_LOCALES(Locale, UseCachedLocaleId)                    \
{                                                                           \
    /*                                                                      \
     *  Check for special locale values.                                    \
     */                                                                     \
    if (Locale == LOCALE_SYSTEM_DEFAULT)                                    \
    {                                                                       \
        /*                                                                  \
         *  Get the System Default locale value.                            \
         */                                                                 \
        Locale = gSystemLocale;                                             \
    }                                                                       \
    else if ((Locale == LOCALE_NEUTRAL) || (Locale == LOCALE_USER_DEFAULT)) \
    {                                                                       \
        /*                                                                  \
         *  Get the User locale value.                                      \
         */                                                                 \
        if (!UseCachedLocaleId)                                             \
        {                                                                   \
            Locale = GetUserDefaultLCID();                                  \
        }                                                                   \
        else                                                                \
        {                                                                   \
            Locale = pNlsUserInfo->UserLocaleId;                            \
        }                                                                   \
    }                                                                       \
    /*                                                                      \
     *  Check for a valid primary language and a neutral sublanguage.       \
     */                                                                     \
    else if (SUBLANGID(LANGIDFROMLCID(Locale)) == SUBLANG_NEUTRAL)          \
    {                                                                       \
        /*                                                                  \
         *  Re-form the locale id using the primary language and the        \
         *  default sublanguage.                                            \
         */                                                                 \
        Locale = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(Locale)), \
                                     SUBLANG_DEFAULT),                      \
                          SORTIDFROMLCID(Locale));                          \
    }                                                                       \
}


////////////////////////////////////////////////////////////////////////////
//
//  IS_INVALID_LOCALE
//
//  Checks to see that only the proper bits are used in the locale.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_VALID_LOCALE_MASK          0x000fffff
#define IS_INVALID_LOCALE(Locale)      ( Locale & ~NLS_VALID_LOCALE_MASK )


////////////////////////////////////////////////////////////////////////////
//
//  VALIDATE_LANGUAGE
//
//  Checks that the given Locale contains a valid language id.  It does so
//  by making sure the appropriate casing and sorting tables are present.
//  If the language is valid, pLocHashN will be non-NULL.  Otherwise,
//  pLocHashN will be NULL.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define VALIDATE_LANGUAGE(Locale, pLocHashN, dwFlags, UseCachedLocaleId)   \
{                                                                          \
    /*                                                                     \
     *  Check the system locale first for speed.  This is the most         \
     *  likely one to be used.                                             \
     */                                                                    \
    if (Locale == gSystemLocale)                                           \
    {                                                                      \
        pLocHashN = gpSysLocHashN;                                         \
    }                                                                      \
    /*                                                                     \
     *  Check the invariant locale second for speed.  This is the second   \
     *  most likely one to be used.                                        \
     */                                                                    \
    else if (Locale == LOCALE_INVARIANT)                                   \
    {                                                                      \
        pLocHashN = gpInvLocHashN;                                         \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Check special locale values.                                   \
         */                                                                \
        CHECK_SPECIAL_LOCALES(Locale, UseCachedLocaleId);                  \
                                                                           \
        /*                                                                 \
         *  If the locale is the system default, then the hash node is     \
         *  already stored in a global.                                    \
         */                                                                \
        if (Locale == gSystemLocale)                                       \
        {                                                                  \
            pLocHashN = gpSysLocHashN;                                     \
        }                                                                  \
        else if (IS_INVALID_LOCALE(Locale))                                \
        {                                                                  \
            pLocHashN = NULL;                                              \
        }                                                                  \
        else                                                               \
        {                                                                  \
            /*                                                             \
             *  Need to make sure the locale value is valid.  Need to      \
             *  check the locale file to see if the locale is supported.   \
             */                                                            \
            pLocHashN = GetLocHashNode(Locale);                            \
                                                                           \
            if (pLocHashN != NULL)                                         \
            {                                                              \
                /*                                                         \
                 *  Make sure the appropriate casing and sorting tables    \
                 *  are in the system.                                     \
                 *                                                         \
                 *  NOTE:  If the call fails, pLocHashN will be NULL.      \
                 */                                                        \
                pLocHashN = GetLangHashNode(Locale, dwFlags);              \
            }                                                              \
        }                                                                  \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Make sure we don't need to get the linguistic tables.              \
     */                                                                    \
    if ((dwFlags) && (pLocHashN) && (pLocHashN->pLowerLinguist == NULL))   \
    {                                                                      \
        /*                                                                 \
         *  Get locale hash node to make sure the appropriate              \
         *  casing and sorting tables are in the system.                   \
         */                                                                \
        pLocHashN = GetLangHashNode(Locale, dwFlags);                      \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  VALIDATE_LOCALE
//
//  Checks that the given LCID contains a valid locale id.  It does so
//  by making sure the appropriate locale information is present.  If the
//  locale is valid, pLocHashN will be non-NULL.  Otherwise, pLocHashN
//  will be NULL.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define VALIDATE_LOCALE(Locale, pLocHashN, UseCachedLocaleId)              \
{                                                                          \
    /*                                                                     \
     *  Check the system locale first for speed.  This is the most         \
     *  likely one to be used.                                             \
     */                                                                    \
    if (Locale == gSystemLocale)                                           \
    {                                                                      \
        pLocHashN = gpSysLocHashN;                                         \
    }                                                                      \
    /*                                                                     \
     *  Check the invariant locale second for speed.  This is the second   \
     *  most likely one to be used.                                        \
     */                                                                    \
    else if (Locale == LOCALE_INVARIANT)                                   \
    {                                                                      \
        pLocHashN = gpInvLocHashN;                                         \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Check special locale values.                                   \
         */                                                                \
        CHECK_SPECIAL_LOCALES(Locale, UseCachedLocaleId);                  \
                                                                           \
        /*                                                                 \
         *  If the locale is the system default, then the hash node        \
         *  is already stored in a global.                                 \
         */                                                                \
        if (Locale == gSystemLocale)                                       \
        {                                                                  \
            pLocHashN = gpSysLocHashN;                                     \
        }                                                                  \
        else if (IS_INVALID_LOCALE(Locale))                                \
        {                                                                  \
            pLocHashN = NULL;                                              \
        }                                                                  \
        else                                                               \
        {                                                                  \
            /*                                                             \
             *  Get locale hash node to make sure the appropriate          \
             *  locale table is in the system.                             \
             *                                                             \
             *  NOTE:  If the call fails, pLocHashN will be NULL.          \
             */                                                            \
            pLocHashN = GetLocHashNode(Locale);                            \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_CODEPAGE_KEY
//
//  Opens the key for the code page section of the registry for read access.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_CODEPAGE_KEY(ReturnVal)                                       \
{                                                                          \
    /*                                                                     \
     *  Make sure code page key is open.                                   \
     */                                                                    \
    if (hCodePageKey == NULL)                                              \
    {                                                                      \
        RtlEnterCriticalSection(&gcsTblPtrs);                              \
        if (hCodePageKey == NULL)                                          \
        {                                                                  \
            if (OpenRegKey( &hCodePageKey,                                 \
                            NLS_HKLM_SYSTEM,                               \
                            NLS_CODEPAGE_KEY,                              \
                            KEY_READ ))                                    \
            {                                                              \
                SetLastError(ERROR_BADDB);                                 \
                RtlLeaveCriticalSection(&gcsTblPtrs);                      \
                return (ReturnVal);                                        \
            }                                                              \
        }                                                                  \
        RtlLeaveCriticalSection(&gcsTblPtrs);                              \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_LOCALE_KEY
//
//  Opens the key for the locale section of the registry for read access.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_LOCALE_KEY(ReturnVal)                                         \
{                                                                          \
    /*                                                                     \
     *  Make sure locale key is open.                                      \
     */                                                                    \
    if (hLocaleKey == NULL)                                                \
    {                                                                      \
        RtlEnterCriticalSection(&gcsTblPtrs);                              \
        if (hLocaleKey == NULL)                                            \
        {                                                                  \
            if (OpenRegKey( &hLocaleKey,                                   \
                            NLS_HKLM_SYSTEM,                               \
                            NLS_LOCALE_KEY,                                \
                            KEY_READ ))                                    \
            {                                                              \
                SetLastError(ERROR_BADDB);                                 \
                RtlLeaveCriticalSection(&gcsTblPtrs);                      \
                return (ReturnVal);                                        \
            }                                                              \
        }                                                                  \
        RtlLeaveCriticalSection(&gcsTblPtrs);                              \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_ALT_SORTS_KEY
//
//  Opens the key for the alternate sorts section of the registry for read
//  access.
//
//  DEFINED AS A MACRO.
//
//  11-15-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_ALT_SORTS_KEY(ReturnVal)                                      \
{                                                                          \
    /*                                                                     \
     *  Make sure alternate sorts key is open.                             \
     */                                                                    \
    if (hAltSortsKey == NULL)                                              \
    {                                                                      \
        RtlEnterCriticalSection(&gcsTblPtrs);                              \
        if (hAltSortsKey == NULL)                                          \
        {                                                                  \
            if (OpenRegKey( &hAltSortsKey,                                 \
                            NLS_HKLM_SYSTEM,                               \
                            NLS_ALT_SORTS_KEY,                             \
                            KEY_READ ))                                    \
            {                                                              \
                SetLastError(ERROR_BADDB);                                 \
                RtlLeaveCriticalSection(&gcsTblPtrs);                      \
                return (ReturnVal);                                        \
            }                                                              \
        }                                                                  \
        RtlLeaveCriticalSection(&gcsTblPtrs);                              \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_LANG_GROUPS_KEY
//
//  Opens the key for the language groups section of the registry for
//  read access.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_LANG_GROUPS_KEY(ReturnVal)                                    \
{                                                                          \
    /*                                                                     \
     *  Make sure language groups key is open.                             \
     */                                                                    \
    if (hLangGroupsKey == NULL)                                            \
    {                                                                      \
        RtlEnterCriticalSection(&gcsTblPtrs);                              \
        if (hLangGroupsKey == NULL)                                        \
        {                                                                  \
            if (OpenRegKey( &hLangGroupsKey,                               \
                            NLS_HKLM_SYSTEM,                               \
                            NLS_LANGUAGE_GROUPS_KEY,                       \
                            KEY_READ ))                                    \
            {                                                              \
                SetLastError(ERROR_BADDB);                                 \
                RtlLeaveCriticalSection(&gcsTblPtrs);                      \
                return (ReturnVal);                                        \
            }                                                              \
        }                                                                  \
        RtlLeaveCriticalSection(&gcsTblPtrs);                              \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_MUILANG_KEY
//
//  Opens the key for the multilingual UI language section of the registry
//  for read access.  It is acceptable if this key is not in the registry,
//  so do not call SetLastError if the key cannot be opened.
//
//  DEFINED AS A MACRO.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_MUILANG_KEY(hKey, ReturnVal)                                  \
{                                                                          \
    if ((hKey) == NULL)                                                    \
    {                                                                      \
        if (OpenRegKey( &(hKey),                                           \
                        NLS_HKLM_SYSTEM,                                   \
                        NLS_MUILANG_KEY,                                   \
                        KEY_READ ))                                        \
        {                                                                  \
            return (ReturnVal);                                            \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_CPANEL_INTL_KEY
//
//  Opens the key for the control panel international section of the
//  registry for the given access.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_CPANEL_INTL_KEY(hKey, ReturnVal, Access)                      \
{                                                                          \
    if ((hKey) == NULL)                                                    \
    {                                                                      \
        if (OpenRegKey( &(hKey),                                           \
                        NULL,                                              \
                        NLS_CTRL_PANEL_KEY,                                \
                        Access ))                                          \
        {                                                                  \
            SetLastError(ERROR_BADDB);                                     \
            return (ReturnVal);                                            \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_GEO_KEY
//
//  Opens the key for the geographic information section of the registry
//  for read access.
//
//  DEFINED AS A MACRO.
//
//  03-10-00    lguindon    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_GEO_KEY(hKey, ReturnVal, Access)                              \
{                                                                          \
    if ((hKey) == NULL)                                                    \
    {                                                                      \
        if (OpenRegKey( &(hKey),                                           \
                        NULL,                                              \
                        GEO_REG_KEY,                                       \
                        Access ))                                          \
        {                                                                  \
            SetLastError(ERROR_BADDB);                                     \
            return (ReturnVal);                                            \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  CLOSE_REG_KEY
//
//  Closes the given registry key.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CLOSE_REG_KEY(hKey)                                                \
{                                                                          \
    if ((hKey) != NULL)                                                    \
    {                                                                      \
        NtClose(hKey);                                                     \
        hKey = NULL;                                                       \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_ALLOC_MEM
//
//  Allocates the given number of bytes of memory from the process heap,
//  zeros the memory buffer, and returns the handle.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_ALLOC_MEM(dwBytes)                                             \
    ( RtlAllocateHeap( RtlProcessHeap(),                                   \
                       HEAP_ZERO_MEMORY,                                   \
                       dwBytes ) )


////////////////////////////////////////////////////////////////////////////
//
//  NLS_FREE_MEM
//
//  Frees the memory of the given handle from the process heap.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_FREE_MEM(hMem)                                                 \
    ( (hMem) ? (RtlFreeHeap( RtlProcessHeap(),                             \
                             0,                                            \
                             (PVOID)hMem ))                                \
             : 0 )


////////////////////////////////////////////////////////////////////////////
//
//  NLS_FREE_TMP_BUFFER
//
//  Checks to see if the buffer is the same as the static buffer.  If it
//  is NOT the same, then the buffer is freed.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_FREE_TMP_BUFFER(pBuf, pStaticBuf)                              \
{                                                                          \
    if (pBuf != pStaticBuf)                                                \
    {                                                                      \
        NLS_FREE_MEM(pBuf);                                                \
    }                                                                      \
}

////////////////////////////////////////////////////////////////////////////
//
//  ARRAYSIZE
//
//  Hnady utility macro to get the size of an array (such as an array of
//  WCHARs).
////////////////////////////////////////////////////////////////////////////
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))
#endif



////////////////////////////////////////////////////////////////////////////
//
//  Function Prototypes
//
////////////////////////////////////////////////////////////////////////////

//
//  Table Routines - tables.c.
//
ULONG
AllocTables(void);

ULONG
GetUnicodeFileInfo(void);

ULONG
GetGeoFileInfo(void);

ULONG
GetCTypeFileInfo(void);

ULONG
GetDefaultSortkeyFileInfo(void);

ULONG
GetDefaultSortTablesFileInfo(void);

ULONG
GetSortkeyFileInfo(
    LCID Locale,
    PLOC_HASH pHashN);

void
GetSortTablesFileInfo(
    LCID Locale,
    PLOC_HASH pHashN);

ULONG
GetCodePageFileInfo(
    UINT CodePage,
    PCP_HASH *ppNode);

ULONG
GetLanguageFileInfo(
    LCID Locale,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode,
    DWORD dwFlags);

ULONG
GetLocaleFileInfo(
    LCID Locale,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode);

ULONG
MakeCPHashNode(
    UINT CodePage,
    LPWORD pBaseAddr,
    PCP_HASH *ppNode,
    BOOL IsDLL,
    LPFN_CP_PROC pfnCPProc);

ULONG
MakeLangHashNode(
    LCID Locale,
    LPWORD pBaseAddr,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode);

ULONG
MakeLocHashNode(
    LCID Locale,
    LPWORD pBaseAddr,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode);

PCP_HASH FASTCALL
GetCPHashNode(
    UINT CodePage);

PLOC_HASH FASTCALL
GetLangHashNode(
    LCID Locale,
    DWORD dwFlags);

BOOL
IsCPHashNodeLoaded(
    UINT CodePage);

PLOC_HASH FASTCALL
GetLocHashNode(
    LCID Locale);

ULONG
GetCalendar(
    CALID Calendar,
    PCAL_INFO *ppCalInfo);


//
//  Section Routines - section.c.
//
ULONG
CreateNlsObjectDirectory(void);

ULONG
CreateRegKey(
    PHANDLE phKeyHandle,
    LPWSTR pBaseName,
    LPWSTR pKey,
    ULONG fAccess);

ULONG
OpenRegKey(
    PHANDLE phKeyHandle,
    LPWSTR pBaseName,
    LPWSTR pKey,
    ULONG fAccess);

ULONG
QueryRegValue(
    HANDLE hKeyHandle,
    LPWSTR pValue,
    PKEY_VALUE_FULL_INFORMATION *ppKeyValueFull,
    ULONG Length,
    LPBOOL pIfAlloc);

ULONG
SetRegValue(
    HANDLE hKeyHandle,
    LPCWSTR pValue,
    LPCWSTR pData,
    ULONG DataLength);

ULONG
CreateSectionTemp(
    HANDLE *phSec,
    LPWSTR pwszFileName);

ULONG
OpenSection(
    HANDLE *phSec,
    PUNICODE_STRING pObSectionName,
    PVOID *ppBaseAddr,
    ULONG AccessMask,
    BOOL bCloseHandle);

ULONG
MapSection(
    HANDLE hSec,
    PVOID *ppBaseAddr,
    ULONG PageProtection,
    BOOL bCloseHandle);

ULONG
UnMapSection(
    PVOID pBaseAddr);

ULONG
GetNlsSectionName(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pwszPrefix,
    LPWSTR pwszSecName,
    UINT cchSecName);

ULONG
GetCodePageDLLPathName(
    UINT CodePage,
    LPWSTR pDllName,
    USHORT cchLen);


//
//  Utility Routines - util.c.
//
BOOL GetCPFileNameFromRegistry(
    UINT    CodePage,
    LPWSTR  pResultBuf,
    UINT    Size);
    
BOOL GetUserInfoFromRegistry(
    LPWSTR pValue,
    LPWSTR pOutput,
    size_t cchOutput,
    LCID Locale);

int
GetStringTableEntry(
    UINT ResourceID,
    LANGID UILangId,
    LPWSTR pBuffer,
    int cchBuffer,
    int WhichString);

BOOL
IsValidSeparatorString(
    LPCWSTR pString,
    ULONG MaxLength,
    BOOL fCheckZeroLen);

BOOL
IsValidGroupingString(
    LPCWSTR pString,
    ULONG MaxLength,
    BOOL fCheckZeroLen);

LPWORD
IsValidCalendarType(
    PLOC_HASH pHashN,
    CALID CalId);

LPWORD
IsValidCalendarTypeStr(
    PLOC_HASH pHashN,
    LPCWSTR pCalStr);

BOOL
GetUserInfo(
    LCID Locale,
    LCTYPE LCType ,
    SIZE_T CacheOffset,
    LPWSTR pValue,
    LPWSTR pOutput,
    size_t cchOutput,
    BOOL fCheckNull);

WCHAR FASTCALL
GetPreComposedChar(
    WCHAR wcNonSp,
    WCHAR wcBase);

BOOL FASTCALL
GetCompositeChars(
    WCHAR wch,
    WCHAR *pNonSp,
    WCHAR *pBase);

int FASTCALL
InsertPreComposedForm(
    LPCWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPWSTR pPreComp);

int FASTCALL
InsertFullWidthPreComposedForm(
    LPCWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPWSTR pPreComp,
    PCASE pCase);

int FASTCALL
InsertCompositeForm(
    LPWSTR pWCStr,
    LPWSTR pEndWCStr);

ULONG
NlsConvertIntegerToString(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pResultBuf,
    UINT Size);

BOOL FASTCALL
NlsConvertIntegerToHexStringW(
    UINT Value,
    BOOL UpperCase,
    PWSTR Str,
    UINT Width);

BOOL FASTCALL
NlsConvertStringToIntegerW(
    PWSTR str,
    UINT Base,
    int CharCount,
    UINT* Result);

BOOL FASTCALL
NlsIsDll(
    LPCWSTR pFileName);

int FASTCALL
NlsStrLenW(
    LPCWSTR pwsz);

int FASTCALL
NlsStrEqualW(
    LPCWSTR pwszFirst,
    LPCWSTR pwszSecond);

int FASTCALL
NlsStrNEqualW(
    LPCWSTR pwszFirst,
    LPCWSTR pwszSecond,
    int Count);

BOOL FASTCALL
IsSortingCodePointDefined(
    LPNLSVERSIONINFO lpVersionInformation,
    LPCWSTR lpString,
    INT  cchSrc);

//
//  Security Routines - security.c.
//

NTSTATUS
NlsCheckForInteractiveUser();

NTSTATUS
NlsIsInteractiveUserProcess();

NTSTATUS
NlsGetUserLocale(
    LCID *Lcid);

NTSTATUS
NlsGetCurrentUserNlsInfo(
    LCID Locale,
    LCTYPE LCType,
    PWSTR RegistryValue,
    PWSTR pOutputBuffer,
    size_t cchOutputBuffer,
    BOOL IgnoreLocaleValue);


NTSTATUS
NlsQueryCurrentUserInfo(
    PNLS_LOCAL_CACHE pNlsCache,
    LPWSTR pValue,
    LPWSTR pOutput, 
    size_t cchOutput);

NTSTATUS
NlsFlushProcessCache(
    LCTYPE LCType);


//
//  Internal Enumeration routines - enum.c.
//
BOOL
Internal_EnumSystemLanguageGroups(
    NLS_ENUMPROC lpLanguageGroupEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam,
    BOOL fUnicodeVer);

BOOL
Internal_EnumLanguageGroupLocales(
    NLS_ENUMPROC lpLangGroupLocaleEnumProc,
    LGRPID LanguageGroup,
    DWORD dwFlags,
    LONG_PTR lParam,
    BOOL fUnicodeVer);

BOOL
Internal_EnumUILanguages(
    NLS_ENUMPROC lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam,
    BOOL fUnicodeVer);

BOOL
Internal_EnumSystemLocales(
    NLS_ENUMPROC lpLocaleEnumProc,
    DWORD dwFlags,
    BOOL fUnicodeVer);

BOOL
Internal_EnumSystemCodePages(
    NLS_ENUMPROC lpCodePageEnumProc,
    DWORD dwFlags,
    BOOL fUnicodeVer);

BOOL
Internal_EnumCalendarInfo(
    NLS_ENUMPROC lpCalInfoEnumProc,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    BOOL fUnicodeVer,
    BOOL fExVersion);

BOOL
Internal_EnumTimeFormats(
    NLS_ENUMPROC lpTimeFmtEnumProc,
    LCID Locale,
    DWORD dwFlags,
    BOOL fUnicodeVer);

BOOL
Internal_EnumDateFormats(
    NLS_ENUMPROC lpDateFmtEnumProc,
    LCID Locale,
    DWORD dwFlags,
    BOOL fUnicodeVer,
    BOOL fExVersion);


//
//  Ansi routines - ansi.c.
//
BOOL
NlsDispatchAnsiEnumProc(
    LCID Locale,
    NLS_ENUMPROC pNlsEnumProc,
    DWORD dwFlags,
    LPWSTR pUnicodeBuffer1,
    LPWSTR pUnicodeBuffer2,
    DWORD dwValue1,
    DWORD dwValue2,
    LONG_PTR lParam,
    BOOL fVersion);


//
//  Translation Routines - mbcs.c.
//
int
SpecialMBToWC(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar);


//
//  UTF Translation Routines - utf.c.
//
BOOL
UTFCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo,
    BOOL fExVer);

int
UTFToUnicode(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar);

int
UnicodeToUTF(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cbMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar);


//
// Locale/Calendar Info (locale.c)
//
BOOL
GetTwoDigitYearInfo(
    CALID Calendar,
    LPWSTR pYearInfo,
    size_t cchYearInfo,
    PWSTR pwszKeyPath);





////////////////////////////////////////////////////////////////////////////
//
//  Global Variables
//
//  All of the global variables for the NLSAPI should be put here.  These are
//  all instance-specific.  In general, there shouldn't be much reason to
//  create instance globals.
//
//  Globals are included last because they may require some of the types
//  being defined above.
//
////////////////////////////////////////////////////////////////////////////

extern PTBL_PTRS        pTblPtrs;           // ptr to structure of table ptrs
extern HANDLE           hModule;            // handle to module
extern RTL_CRITICAL_SECTION gcsTblPtrs;     // critical section for tbl ptrs

extern UINT             gAnsiCodePage;      // Ansi code page value
extern UINT             gOemCodePage;       // OEM code page value
extern UINT             gMacCodePage;       // MAC code page value
extern LCID             gSystemLocale;      // system locale value
extern LANGID           gSystemInstallLang; // system's original install language
extern PLOC_HASH        gpSysLocHashN;      // ptr to system loc hash node
extern PLOC_HASH        gpInvLocHashN;      // ptr to invariant loc hash node
extern PCP_HASH         gpACPHashN;         // ptr to ACP hash node
extern PCP_HASH         gpOEMCPHashN;       // ptr to OEMCP hash node
extern PCP_HASH         gpMACCPHashN;       // ptr to MAC hash node

extern HANDLE           hCodePageKey;       // handle to System\Nls\CodePage key
extern HANDLE           hLocaleKey;         // handle to System\Nls\Locale key
extern HANDLE           hAltSortsKey;       // handle to Locale\Alternate Sorts key
extern HANDLE           hLangGroupsKey;     // handle to System\Nls\Language Groups key

extern PNLS_USER_INFO   pNlsUserInfo;       // ptr to the user info cache
extern PNLS_USER_INFO   pServerNlsUserInfo;   // ptr to the user info cache in the csrss.exe.

extern BOOL gInteractiveLogonUserProcess;    // running in interactive user session or not.
extern RTL_CRITICAL_SECTION  gcsNlsProcessCache; // Nls process cache critical section





////////////////////////////////////////////////////////////////////////////
//
//   Functions used to communicate with CSRSS.
//
////////////////////////////////////////////////////////////////////////////

NTSTATUS
CsrBasepNlsGetUserInfo(
    IN PNLS_USER_INFO pNlsCache,
    IN ULONG DataLength);



NTSTATUS
CsrBasepNlsSetUserInfo(
    IN LCTYPE LCType,
    IN LPWSTR pData,
    IN ULONG DataLength);

NTSTATUS
CsrBasepNlsSetMultipleUserInfo(
    IN DWORD dwFlags,
    IN int cchData,
    IN LPCWSTR pPicture,
    IN LPCWSTR pSeparator,
    IN LPCWSTR pOrder,
    IN LPCWSTR pTLZero,
    IN LPCWSTR pTimeMarkPosn);

NTSTATUS
CsrBasepNlsCreateSection(
    IN UINT uiType,
    IN LCID Locale,
    OUT PHANDLE phSection);

NTSTATUS
CsrBasepNlsUpdateCacheCount(VOID);

#endif   // _NLS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\nlssafe.h ===
/*----
Copyright (c) 1991-2002,  Microsoft Corporation  All rights reserved.

Module Name:

    nlssafe.h

Abstract:

    This file is present for strsafe support. We cannot add this to nls.h
    as not all of the clients who include this file are "safe" in the
    strsafe sense.

Revision History:

    03-22-2002    v-michka    Created.

--*/

#ifndef _STRSAFE_H_INCLUDED_

// CONSIDER: Use the lib version of strsafe here?
//#define STRSAFE_LIB

#include <strsafe.h>
#endif _STRSAFE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\ntwow64n.h ===
NTSTATUS
NTAPI
NtWow64CsrBasepNlsGetUserInfo(
    IN PNLS_USER_INFO pNlsCache,
    IN ULONG DataLength
    );


NTSTATUS
NTAPI
NtWow64CsrBasepNlsSetUserInfo(
    IN LCTYPE   LCType,
    IN LPWSTR pData,
    IN ULONG DataLength
    );

NTSTATUS
NTAPI
NtWow64CsrBasepNlsSetMultipleUserInfo(
    IN DWORD dwFlags,
    IN int cchData,
    IN LPCWSTR pPicture,
    IN LPCWSTR pSeparator,
    IN LPCWSTR pOrder,
    IN LPCWSTR pTLZero,
    IN LPCWSTR pTimeMarkPosn
    );


NTSTATUS
NTAPI
NtWow64CsrBasepNlsCreateSection(
    IN UINT uiType,
    IN LCID Locale,
    OUT PHANDLE phSection
    );

NTSTATUS
NtWow64CsrBasepNlsUpdateCacheCount(
    VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\number.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    number.c

Abstract:

    This file contains functions that form properly formatted number and
    currency strings for a given locale.

    APIs found in this file:
      GetNumberFormatW
      GetCurrencyFormatW

Revision History:

    07-28-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"



//
//  Constant Declarations.
//

#define MAX_NUMBER_BUFFER    256                 // size of static buffer
#define MAX_GROUPS           5                   // max number of groupings
#define MAX_GROUPING_NUMBER  9999                // max value for groupings

//
//  Account for:
//    - number of fractional digits
//    - decimal seperator
//    - negative sign
//    - zero terminator
//
#define MAX_NON_INTEGER_PART ( MAX_VALUE_IDIGITS +                        \
                               MAX_SDECIMAL +                             \
                               MAX_SNEGSIGN +                             \
                               1 )
//
//  Account for:
//    - negative sign
//    - blank spaces
//    - one extra number from rounding
//    - one extra grouping separator from rounding
//
#define MAX_NUMBER_EXTRAS    ( MAX_SNEGSIGN +                             \
                               MAX_BLANKS +                               \
                               1 +                                        \
                               MAX_STHOUSAND )
//
//  Account for:
//    - negative sign
//    - currency sign
//    - blank spaces
//    - one extra number from rounding
//    - one extra grouping separator from rounding
//
#define MAX_CURRENCY_EXTRAS  ( MAX_SNEGSIGN +                             \
                               MAX_SCURRENCY +                            \
                               MAX_BLANKS +                               \
                               1 +                                        \
                               MAX_SMONTHOUSEP )




//
//  Forward Declarations.
//

BOOL
IsValidNumberFormat(
    CONST NUMBERFMTW *pFormat);

BOOL
IsValidCurrencyFormat(
    CONST CURRENCYFMTW *pFormat);

UINT
GetRegIntValue(
    LCID Locale,
    LCTYPE LCType,
    BOOL NoUserOverride,
    SIZE_T CacheOffset,
    LPWSTR pRegVal,
    LPWSTR pDefault,
    int DefaultVal,
    int UpperBound);

int
ConvertGroupingStringToInt(
    LPWSTR pGroupingSrc,
    LPWSTR pGroupingDest);

UINT
GetGroupingValue(
    LCID Locale,
    LCTYPE LCType,
    BOOL NoUserOverride,
    SIZE_T CacheOffset,
    LPWSTR pRegVal,
    LPWSTR pDefault,
    int DefaultVal);

int
GetNumberString(
    PLOC_HASH pHashN,
    LPWSTR pValue,
    LPNUMBERFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    BOOL *pfZeroValue,
    int *pNeededSizeToAllocate,
    BOOL fSetError);

int
ParseNumber(
    PLOC_HASH pHashN,
    BOOL NoUserOverride,
    LPWSTR pValue,
    LPNUMBERFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    int *pNeededSizeToAllocate,
    BOOL fSetError);

int
ParseCurrency(
    PLOC_HASH pHashN,
    BOOL NoUserOverride,
    LPWSTR pValue,
    LPCURRENCYFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    int *pNeededSizeToAllocate,
    BOOL fSetError);





//-------------------------------------------------------------------------//
//                            INTERNAL MACROS                              //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NLS_COPY_UNICODE_STR
//
//  Copies a zero terminated Unicode string from pSrc to the pDest buffer.
//  The pDest pointer is advanced to the end of the string.
//
//  DEFINED AS A MACRO.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_COPY_UNICODE_STR( pDest,                                       \
                              pSrc )                                       \
{                                                                          \
    LPWSTR pTmp;             /* temp pointer to source */                  \
                                                                           \
                                                                           \
    pTmp = pSrc;                                                           \
    while (*pTmp)                                                          \
    {                                                                      \
        *pDest = *pTmp;                                                    \
        pDest++;                                                           \
        pTmp++;                                                            \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_COPY_UNICODE_STR_NOADV
//
//  Copies a zero terminated Unicode string from pSrc to the pDest buffer.
//  The pDest pointer is NOT advanced to the end of the string.
//
//  DEFINED AS A MACRO.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_COPY_UNICODE_STR_TMP( pDest,                                   \
                                  pSrc )                                   \
{                                                                          \
    LPWSTR pSrcT;            /* temp pointer to source */                  \
    LPWSTR pDestT;           /* temp pointer to destination */             \
                                                                           \
                                                                           \
    pSrcT = pSrc;                                                          \
    pDestT = pDest;                                                        \
    while (*pSrcT)                                                         \
    {                                                                      \
        *pDestT = *pSrcT;                                                  \
        pDestT++;                                                          \
        pSrcT++;                                                           \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_ROUND_IT
//
//  Rounds the floating point number given as a string.
//
//  NOTE:  This function will reset the pBegin pointer if an
//         extra character is added to the string.
//
//  DEFINED AS A MACRO.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_ROUND_IT( pBegin,                                              \
                      pEnd,                                                \
                      IntPartGroup,                                        \
                      pSep )                                               \
{                                                                          \
    LPWSTR pRound = pEnd;         /* ptr to position in string */          \
    LPWSTR pEndSep;               /* ptr to end of group separator */      \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Round the digits in the string one by one, going backwards in      \
     *  the string.  Stop when either a value other than 9 is found,       \
     *  or the beginning of the string is reached.                         \
     */                                                                    \
    while (pRound >= pBegin)                                               \
    {                                                                      \
        if ((*pRound < NLS_CHAR_ZERO) || (*pRound > NLS_CHAR_NINE))        \
        {                                                                  \
            pRound--;                                                      \
        }                                                                  \
        else if (*pRound == NLS_CHAR_NINE)                                 \
        {                                                                  \
            *pRound = NLS_CHAR_ZERO;                                       \
            pRound--;                                                      \
        }                                                                  \
        else                                                               \
        {                                                                  \
            (*pRound)++;                                                   \
            break;                                                         \
        }                                                                  \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Make sure we don't have a number like 9.999, where we would need   \
     *  to add an extra character to the string and make it 10.00.         \
     */                                                                    \
    if (pRound < pBegin)                                                   \
    {                                                                      \
        /*                                                                 \
         *  All values to the right of the decimal are zero.  All values   \
         *  to the left of the decimal are either zero or the grouping     \
         *  separator.                                                     \
         */                                                                \
        if ((IntPartGroup) == 0)                                           \
        {                                                                  \
            /*                                                             \
             *  Adding another integer means we need to add another        \
             *  grouping separator.                                        \
             */                                                            \
            pEndSep = pSep + NlsStrLenW(pSep) - 1;                         \
            while (pEndSep >= pSep)                                        \
            {                                                              \
                (pBegin)--;                                                \
                *(pBegin) = *pEndSep;                                      \
                pEndSep--;                                                 \
            }                                                              \
        }                                                                  \
                                                                           \
        /*                                                                 \
         *  Store a 1 at the beginning of the string and reset the         \
         *  pointer to the beginning of the string.                        \
         */                                                                \
        (pBegin)--;                                                        \
        *(pBegin) = NLS_CHAR_ONE;                                          \
    }                                                                      \
}




//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetNumberFormatW
//
//  Returns a properly formatted number string for the given locale.
//  This call also indicates how much memory is necessary to contain
//  the desired information.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetNumberFormatW(
    LCID Locale,
    DWORD dwFlags,
    LPCWSTR lpValue,
    CONST NUMBERFMTW *lpFormat,
    LPWSTR lpNumberStr,
    int cchNumber)

{
    PLOC_HASH pHashN;                    // ptr to LOC hash node
    int Length = 0;                      // number of characters written
    LPNUMBERFMTW pFormat;                // ptr to number format struct
    NUMBERFMTW NumFmt;                   // number format
    WCHAR pString[MAX_NUMBER_BUFFER];    // ptr to temporary buffer
    LPWSTR pFinal;                       // ptr to the final string
    BOOL NoUserOverride;                 // if no user override flag set
    WCHAR pDecimal[MAX_REG_VAL_SIZE];    // temp buffer for decimal sep
    WCHAR pThousand[MAX_REG_VAL_SIZE];   // temp buffer for thousand sep
    int NeededSizeToAllocate = 0;        // size of buffer needed
    WCHAR *pTemp = NULL;                 // allocated temp storage buffer


    //
    //  Initialize UserOverride.
    //
    NoUserOverride = dwFlags & LOCALE_NOUSEROVERRIDE;

    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - count is negative
    //    - NULL src string
    //    - NULL data pointer AND count is not zero
    //    - ptrs to string buffers same
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ( (pHashN == NULL) ||
         (cchNumber < 0) ||
         (lpValue == NULL) ||
         ((lpNumberStr == NULL) && (cchNumber != 0)) ||
         (lpValue == lpNumberStr) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //    - flags other than valid ones
    //    - lpFormat not NULL AND NoUserOverride flag is set
    //
    if ( (dwFlags & GNF_INVALID_FLAG) ||
         ((lpFormat != NULL) && (NoUserOverride)) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  Set pFormat to point at the proper format structure.
    //
    if (lpFormat != NULL)
    {
        //
        //  Use the format structure given by the caller.
        //
        pFormat = (LPNUMBERFMTW)lpFormat;

        if (!IsValidNumberFormat(pFormat))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }
    else
    {
        //
        //  Use the format structure defined here.
        //
        pFormat = &NumFmt;

        //
        //  Get the number of decimal digits.
        //
        pFormat->NumDigits =
            GetRegIntValue( Locale,
                            LOCALE_IDIGITS,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iDigits),
                            NLS_VALUE_IDIGITS,
                            pHashN->pLocaleFixed->szIDigits,
                            2,
                            MAX_VALUE_IDIGITS );

        //
        //  Get the leading zero in decimal fields option.
        //
        pFormat->LeadingZero =
            GetRegIntValue( Locale,
                            LOCALE_ILZERO,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iLZero),
                            NLS_VALUE_ILZERO,
                            pHashN->pLocaleFixed->szILZero,
                            1,
                            MAX_VALUE_ILZERO );

        //
        //  Get the negative ordering.
        //
        pFormat->NegativeOrder =
            GetRegIntValue( Locale,
                            LOCALE_INEGNUMBER,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iNegNumber),
                            NLS_VALUE_INEGNUMBER,
                            pHashN->pLocaleFixed->szINegNumber,
                            1,
                            MAX_VALUE_INEGNUMBER );

        //
        //  Get the grouping left of the decimal.
        //
        pFormat->Grouping =
            GetGroupingValue( Locale,
                              LOCALE_SGROUPING,
                              NoUserOverride,
                              FIELD_OFFSET(NLS_USER_INFO, sGrouping),
                              NLS_VALUE_SGROUPING,
                              (LPWORD)(pHashN->pLocaleHdr) +
                                pHashN->pLocaleHdr->SGrouping,
                              3 );

        //
        //  Get the decimal separator.
        //
        //  NOTE:  This must follow the above calls because
        //         pDecSep is used as a temporary buffer above.
        //
        if ( (!NoUserOverride) &&
             GetUserInfo( Locale,
                          LOCALE_SDECIMAL,
                          FIELD_OFFSET(NLS_USER_INFO, sDecimal),
                          NLS_VALUE_SDECIMAL,
                          pDecimal,
                          ARRAYSIZE(pDecimal),
                          TRUE ) &&
             IsValidSeparatorString( pDecimal,
                                     MAX_SDECIMAL,
                                     FALSE ) )
        {
            pFormat->lpDecimalSep = pDecimal;
        }
        else
        {
            pFormat->lpDecimalSep = (LPWORD)(pHashN->pLocaleHdr) +
                                    pHashN->pLocaleHdr->SDecimal;
        }

        //
        //  Get the thousand separator.
        //  This string may be a null string.
        //
        if ( (!NoUserOverride) &&
             GetUserInfo( Locale,
                          LOCALE_STHOUSAND,
                          FIELD_OFFSET(NLS_USER_INFO, sThousand),
                          NLS_VALUE_STHOUSAND,
                          pThousand,
                          ARRAYSIZE(pThousand),
                          FALSE ) &&
             IsValidSeparatorString( pThousand,
                                     MAX_STHOUSAND,
                                     FALSE ) )
        {
            pFormat->lpThousandSep = pThousand;
        }
        else
        {
            pFormat->lpThousandSep = (LPWORD)(pHashN->pLocaleHdr) +
                                     pHashN->pLocaleHdr->SThousand;
        }
    }

    //
    //  Parse the number format string.
    //
    pFinal = pString;
    Length = ParseNumber( pHashN,
                          NoUserOverride,
                          (LPWSTR)lpValue,
                          pFormat,
                          &pFinal,
                          MAX_NUMBER_BUFFER,
                          &NeededSizeToAllocate,
                          FALSE );

    //
    //  If the failure is due to a stack variable size limitation, then
    //  try to satisfy the request from the local process heap.
    //
    if ((Length == 0) && (NeededSizeToAllocate > 0))
    {
        pTemp = RtlAllocateHeap( RtlProcessHeap(),
                                 0,
                                 NeededSizeToAllocate * sizeof(TCHAR) );
        if (pTemp)
        {
            pFinal = pTemp;
            Length = ParseNumber( pHashN,
                                  NoUserOverride,
                                  (LPWSTR)lpValue,
                                  pFormat,
                                  &pFinal,
                                  NeededSizeToAllocate,
                                  &NeededSizeToAllocate,
                                  TRUE );
        }
    }

    //
    //  Check cchNumber for size of given buffer.
    //
    if ((cchNumber == 0) || (Length == 0))
    {
        //
        //  If cchNumber is 0, then we can't use lpNumberStr.  In this
        //  case, we simply want to return the length (in characters) of
        //  the string to be copied.
        //
        Length = Length;
    }
    else if (cchNumber < Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        Length = 0;
    }
    else
    {
        //
        //  Copy the number string to lpNumberStr and null terminate it.
        //  Return the number of characters copied.
        //
        if(FAILED(StringCchCopyW(lpNumberStr, cchNumber, pFinal)))
        {
            //
            // Failure should in theory be impossible, but if we ignore the
            // return value, PREfast will complain.
            //
            SetLastError(ERROR_OUTOFMEMORY);
            Length = 0;
        }
    }

    //
    //  Free any dynamically allocated memory.
    //
    if (pTemp != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pTemp);
    }

    //
    //  Return the number of characters copied.
    //
    return (Length);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCurrencyFormatW
//
//  Returns a properly formatted currency string for the given locale.
//  This call also indicates how much memory is necessary to contain
//  the desired information.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetCurrencyFormatW(
    LCID Locale,
    DWORD dwFlags,
    LPCWSTR lpValue,
    CONST CURRENCYFMTW *lpFormat,
    LPWSTR lpCurrencyStr,
    int cchCurrency)

{
    PLOC_HASH pHashN;                    // ptr to LOC hash node
    int Length = 0;                      // number of characters written
    LPCURRENCYFMTW pFormat;              // ptr to currency format struct
    CURRENCYFMTW CurrFmt;                // currency format
    WCHAR pString[MAX_NUMBER_BUFFER];    // ptr to temporary buffer
    LPWSTR pFinal;                       // ptr to the final string
    BOOL NoUserOverride;                 // if no user override flag set
    WCHAR pDecimal[MAX_REG_VAL_SIZE];    // temp buffer for decimal sep
    WCHAR pThousand[MAX_REG_VAL_SIZE];   // temp buffer for thousand sep
    WCHAR pCurrency[MAX_REG_VAL_SIZE];   // temp buffer for currency symbol
    int NeededSizeToAllocate = 0;        // size of buffer needed
    WCHAR *pTemp = NULL;                 // allocated temp storage buffer


    //
    //  Initialize UserOverride.
    //
    NoUserOverride = dwFlags & LOCALE_NOUSEROVERRIDE;

    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - count is negative
    //    - NULL src string
    //    - NULL data pointer AND count is not zero
    //    - ptrs to string buffers same
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ( (pHashN == NULL) ||
         (cchCurrency < 0) ||
         (lpValue == NULL) ||
         ((lpCurrencyStr == NULL) && (cchCurrency != 0)) ||
         (lpValue == lpCurrencyStr) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //    - flags other than valid ones
    //    - lpFormat not NULL AND NoUserOverride flag is set
    //
    if ( (dwFlags & GCF_INVALID_FLAG) ||
         ((lpFormat != NULL) && (NoUserOverride)) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  Set pFormat to point at the proper format structure.
    //
    if (lpFormat != NULL)
    {
        //
        //  Use the format structure given by the caller.
        //
        pFormat = (LPCURRENCYFMTW)lpFormat;

        if (!IsValidCurrencyFormat(pFormat))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }
    else
    {
        //
        //  Use the format structure defined here.
        //
        pFormat = &CurrFmt;

        //
        //  Get the number of decimal digits.
        //
        pFormat->NumDigits =
            GetRegIntValue( Locale,
                            LOCALE_ICURRDIGITS,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iCurrDigits),
                            NLS_VALUE_ICURRDIGITS,
                            pHashN->pLocaleFixed->szICurrDigits,
                            2,
                            MAX_VALUE_ICURRDIGITS );

        //
        //  Get the leading zero in decimal fields option.
        //
        pFormat->LeadingZero =
            GetRegIntValue( Locale,
                            LOCALE_ILZERO,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iLZero),
                            NLS_VALUE_ILZERO,
                            pHashN->pLocaleFixed->szILZero,
                            1,
                            MAX_VALUE_ILZERO );

        //
        //  Get the positive ordering.
        //
        pFormat->PositiveOrder =
            GetRegIntValue( Locale,
                            LOCALE_ICURRENCY,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iCurrency),
                            NLS_VALUE_ICURRENCY,
                            pHashN->pLocaleFixed->szICurrency,
                            0,
                            MAX_VALUE_ICURRENCY );

        //
        //  Get the negative ordering.
        //
        pFormat->NegativeOrder =
            GetRegIntValue( Locale,
                            LOCALE_INEGCURR,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                            NLS_VALUE_INEGCURR,
                            pHashN->pLocaleFixed->szINegCurr,
                            1,
                            MAX_VALUE_INEGCURR );

        //
        //  Get the grouping left of the decimal.
        //
        pFormat->Grouping =
            GetGroupingValue( Locale,
                              LOCALE_SMONGROUPING,
                              NoUserOverride,
                              FIELD_OFFSET(NLS_USER_INFO, sMonGrouping),
                              NLS_VALUE_SMONGROUPING,
                              (LPWORD)(pHashN->pLocaleHdr) +
                                pHashN->pLocaleHdr->SMonGrouping,
                              3 );

        //
        //  Get the decimal separator.
        //
        //  NOTE:  This must follow the above calls because
        //         pDecSep is used as a temporary buffer.
        //
        if ( (!NoUserOverride) &&
             GetUserInfo( Locale,
                          LOCALE_SMONDECIMALSEP,
                          FIELD_OFFSET(NLS_USER_INFO, sMonDecSep),
                          NLS_VALUE_SMONDECIMALSEP,
                          pDecimal,
                          ARRAYSIZE(pDecimal),
                          TRUE ) &&
             IsValidSeparatorString( pDecimal,
                                     MAX_SDECIMAL,
                                     FALSE ) )
        {
            pFormat->lpDecimalSep = pDecimal;
        }
        else
        {
            pFormat->lpDecimalSep = (LPWORD)(pHashN->pLocaleHdr) +
                                    pHashN->pLocaleHdr->SMonDecSep;
        }

        //
        //  Get the thousand separator.
        //  This string may be a null string.
        //
        if ( (!NoUserOverride) &&
             GetUserInfo( Locale,
                          LOCALE_SMONTHOUSANDSEP,
                          FIELD_OFFSET(NLS_USER_INFO, sMonThouSep),
                          NLS_VALUE_SMONTHOUSANDSEP,
                          pThousand,
                          ARRAYSIZE(pThousand),
                          FALSE ) &&
             IsValidSeparatorString( pThousand,
                                     MAX_STHOUSAND,
                                     FALSE ) )
        {
            pFormat->lpThousandSep = pThousand;
        }
        else
        {
            pFormat->lpThousandSep = (LPWORD)(pHashN->pLocaleHdr) +
                                     pHashN->pLocaleHdr->SMonThousSep;
        }

        //
        //  Get the currency symbol.
        //  This string may be a null string.
        //
        if ( (!NoUserOverride) &&
             GetUserInfo( Locale,
                          LOCALE_SCURRENCY,
                          FIELD_OFFSET(NLS_USER_INFO, sCurrency),
                          NLS_VALUE_SCURRENCY,
                          pCurrency,
                          ARRAYSIZE(pCurrency),
                          FALSE ) &&
             IsValidSeparatorString( pCurrency,
                                     MAX_SCURRENCY,
                                     FALSE ) )
        {
            pFormat->lpCurrencySymbol = pCurrency;
        }
        else
        {
            pFormat->lpCurrencySymbol = (LPWORD)(pHashN->pLocaleHdr) +
                                        pHashN->pLocaleHdr->SCurrency;
        }
    }

    //
    //  Parse the currency format string.
    //
    pFinal = pString;
    Length = ParseCurrency( pHashN,
                            NoUserOverride,
                            (LPWSTR)lpValue,
                            pFormat,
                            &pFinal,
                            MAX_NUMBER_BUFFER,
                            &NeededSizeToAllocate,
                            FALSE );

    //
    //  If the failure is due to a stack variable size limitation, then
    //  try to satisfy the request from the local process heap.
    //
    if ((Length == 0) && (NeededSizeToAllocate > 0))
    {
        pTemp = RtlAllocateHeap( RtlProcessHeap(),
                                 0,
                                 NeededSizeToAllocate * sizeof(TCHAR) );
        if (pTemp)
        {
            pFinal = pTemp;
            Length = ParseCurrency( pHashN,
                                    NoUserOverride,
                                    (LPWSTR)lpValue,
                                    pFormat,
                                    &pFinal,
                                    NeededSizeToAllocate,
                                    &NeededSizeToAllocate,
                                    TRUE );
        }
    }

    //
    //  Check cchCurrency for size of given buffer.
    //
    if ((cchCurrency == 0) || (Length == 0))
    {
        //
        //  If cchCurrency is 0, then we can't use lpCurrencyStr.  In this
        //  case, we simply want to return the length (in characters) of
        //  the string to be copied.
        //
        Length = Length;
    }
    else if (cchCurrency < Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        Length = 0;
    }
    else
    {
        //
        //  Copy the currency string to lpCurrencyStr and null terminate it.
        //  Return the number of characters copied.
        //
        if(FAILED(StringCchCopyW(lpCurrencyStr, cchCurrency, pFinal)))
        {
            //
            // Failure should in theory be impossible, but if we ignore the
            // return value, PREfast will complain.
            //
            SetLastError(ERROR_OUTOFMEMORY);
            Length = 0;
        }
    }

    //
    //  Free any dynamically allocated memory.
    //
    if (pTemp != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pTemp);
    }

    //
    //  Return the number of characters copied.
    //
    return (Length);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  IsValidNumberFormat
//
//  Returns TRUE if the given format is valid.  Otherwise, it returns FALSE.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidNumberFormat(
    CONST NUMBERFMTW *pFormat)

{
    //
    //  Check for invalid values.
    //
    if ((pFormat->NumDigits > MAX_VALUE_IDIGITS) ||
        (pFormat->LeadingZero > MAX_VALUE_ILZERO) ||
        (pFormat->Grouping > MAX_GROUPING_NUMBER) ||
        (pFormat->NegativeOrder > MAX_VALUE_INEGNUMBER) ||
        (pFormat->lpDecimalSep == NULL) ||
        (!IsValidSeparatorString( pFormat->lpDecimalSep,
                                  MAX_SDECIMAL,
                                  (pFormat->NumDigits) ? TRUE : FALSE)) ||
        (pFormat->lpThousandSep == NULL) ||
        (!IsValidSeparatorString( pFormat->lpThousandSep,
                                  MAX_STHOUSAND,
                                  FALSE )))
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidCurrencyFormat
//
//  Returns TRUE if the given format is valid.  Otherwise, it returns FALSE.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidCurrencyFormat(
    CONST CURRENCYFMTW *pFormat)

{
    //
    //  Check for invalid values.
    //
    if ((pFormat->NumDigits > MAX_VALUE_IDIGITS) ||
        (pFormat->LeadingZero > MAX_VALUE_ILZERO) ||
        (pFormat->Grouping > MAX_GROUPING_NUMBER) ||
        (pFormat->lpDecimalSep == NULL) ||
        (!IsValidSeparatorString( pFormat->lpDecimalSep,
                                  MAX_SMONDECSEP,
                                  (pFormat->NumDigits) ? TRUE : FALSE)) ||
        (pFormat->lpThousandSep == NULL) ||
        (!IsValidSeparatorString( pFormat->lpThousandSep,
                                  MAX_SMONTHOUSEP,
                                  FALSE )) ||
        (pFormat->lpCurrencySymbol == NULL) ||
        (!IsValidSeparatorString( pFormat->lpCurrencySymbol,
                                  MAX_SCURRENCY,
                                  FALSE )) ||
        (pFormat->PositiveOrder > MAX_VALUE_ICURRENCY) ||
        (pFormat->NegativeOrder > MAX_VALUE_INEGCURR))
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetRegIntValue
//
//  Retrieves the specified locale information, converts the unicode string
//  to an integer value, and returns the value.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

UINT GetRegIntValue(
    LCID Locale,
    LCTYPE LCType,
    BOOL NoUserOverride,
    SIZE_T CacheOffset,
    LPWSTR pRegVal,
    LPWSTR pDefault,
    int DefaultVal,
    int UpperBound)
{
    UNICODE_STRING ObUnicodeStr;            // value string
    int Value;                              // value
    WCHAR pTemp[MAX_REG_VAL_SIZE];          // temp buffer


    //
    //  Initialize values.
    //
    Value = -1;

    //
    //  Try the user registry.
    //
    if ((!NoUserOverride) &&
         GetUserInfo( Locale,
                      LCType,
                      CacheOffset,
                      pRegVal,
                      pTemp,
                      ARRAYSIZE(pTemp),
                      TRUE ))
    {
        //
        //  Convert the user data to an integer.
        //
        RtlInitUnicodeString(&ObUnicodeStr, pTemp);
        if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value)) ||
            (Value < 0) || (Value > UpperBound))
        {
            //
            //  Bad value, so store -1 so that the system default
            //  will be used.
            //
            Value = -1;
        }
    }

    //
    //  See if the value obtained above is valid.
    //
    if (Value < 0)
    {
        //
        //  Convert system default data to an integer.
        //
        RtlInitUnicodeString(&ObUnicodeStr, pDefault);
        if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value)) ||
            (Value < 0) || (Value > UpperBound))
        {
            //
            //  Bad value, so use the chosen default value.
            //
            Value = DefaultVal;
        }
    }

    return ((UINT)Value);
}


////////////////////////////////////////////////////////////////////////////
//
//  ConvertGroupingStringToInt
//
//  Converts the given grouping string to an integer.
//  For example, 3;2;0 becomes 32 and 3;0 becomes 3 and 3;2 becomes 320.
//
//  NOTE: The pGrouping buffer will be modified.
//
//  01-05-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ConvertGroupingStringToInt(
    LPWSTR pGroupingSrc,
    LPWSTR pGroupingDest)
{
    LPWSTR pSrc  = pGroupingSrc;       // temp ptr to src position
    LPWSTR pDest = pGroupingDest;      // temp ptr to dest position
    UNICODE_STRING ObUnicodeStr;       // value string
    int Value;                         // value


    //
    //  Filter out all non-numeric values and all zero values.
    //  Store the result in the destination buffer.
    //
    while (*pSrc)
    {
        if ((*pSrc < NLS_CHAR_ONE) || (*pSrc > NLS_CHAR_NINE))
        {
            pSrc++;
        }
        else
        {
            if (pSrc != pDest)
            {
                *pDest = *pSrc;
            }
            pSrc++;
            pDest++;
        }
    }

    //
    //  Make sure there is something in the destination buffer.
    //  Also, see if we need to add a zero in the case of 3;2 becomes 320.
    //
    if ((pDest == pGroupingDest) || (*(pSrc - 1) != NLS_CHAR_ZERO))
    {
        *pDest = NLS_CHAR_ZERO;
        pDest++;
    }

    //
    //  Null terminate the buffer.
    //
    *pDest = 0;

    //
    //  Convert the string to an integer.
    //
    RtlInitUnicodeString(&ObUnicodeStr, pGroupingDest);
    RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value);

    //
    //  Return the integer value.
    //
    return (Value);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetGroupingValue
//
//  Retrieves the specified grouping information, converts the grouping
//  string to an integer value (eg. 3;2;0 -> 32), and returns the value.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

UINT GetGroupingValue(
    LCID Locale,
    LCTYPE LCType,
    BOOL NoUserOverride,
    SIZE_T CacheOffset,
    LPWSTR pRegVal,
    LPWSTR pDefault,
    int DefaultVal)
{
    int Value;                              // value
    WCHAR pTemp[MAX_REG_VAL_SIZE];          // temp buffer


    //
    //  Initialize values.
    //
    Value = -1;

    //
    //  Try the user registry.
    //
    if ((!NoUserOverride) &&
         GetUserInfo( Locale,
                      LCType,
                      CacheOffset,
                      pRegVal,
                      pTemp,
                      ARRAYSIZE(pTemp),
                      TRUE ))
    {
        //
        //  Convert the grouping string to an integer.
        //  3;0 becomes 3, 3;2;0 becomes 32, and 3;2 becomes 320.
        //
        Value = ConvertGroupingStringToInt(pTemp, pTemp);
        if (Value < 0)
        {
            //
            //  Bad value, so store -1 so that the system default
            //  will be used.
            //
            Value = -1;
        }
    }

    //
    //  See if the value obtained above is valid.
    //
    if (Value < 0)
    {
        //
        //  Convert the grouping string to an integer.
        //  3;0 becomes 3, 3;2;0 becomes 32, and 3;2 becomes 320.
        //
        Value = ConvertGroupingStringToInt(pDefault, pTemp);
        if (Value < 0)
        {
            //
            //  Bad value, so use the chosen default value.
            //
            Value = DefaultVal;
        }
    }

    //
    //  Return the value.
    //
    return ((UINT)Value);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetNumberString
//
//  Puts the properly formatted number string into the given string buffer.
//  It returns the number of characters written to the string buffer.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetNumberString(
    PLOC_HASH pHashN,
    LPWSTR pValue,
    LPNUMBERFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    BOOL *pfZeroValue,
    int *pNeededSizeToAllocate,
    BOOL fSetError)

{
    LPWSTR pDecPt;                // ptr to decimal point in given buffer
    LPWSTR pPos;                  // ptr to position in given buffer
    LPWSTR pPos2;                 // ptr to position in given buffer
    LPWSTR pPosBuf;               // ptr to position in final buffer
    int IntPartSize;              // size of integer part of string
    int GroupSize;                // size of groupings left of decimal
    int IntegerNum;               // number of integers left of decimal
    WCHAR wch;                    // wide character place holder
    int pGroupArray[MAX_GROUPS];  // array of groups
    int NumGroupings;             // number of groupings
    int NumSeparators;            // number of separators
    int NumDigits;                // number of digits
    int Ctr;                      // loop counter
    UINT NumRound = 1;            // # digits left before adding group separator


    //
    //  Reset to indicate no need to allocate memory dynamically.
    //
    *pNeededSizeToAllocate = 0;

    //
    //  Validate the string and find the decimal point in the string.
    //
    //  The only valid characters within the string are:
    //     negative sign - in first position only
    //     decimal point
    //     Unicode code points for integers 0 - 9
    //
    pPos = pValue;
    while ((wch = *pPos) && (wch != NLS_CHAR_PERIOD))
    {
        if ((wch < NLS_CHAR_ZERO) || (wch > NLS_CHAR_NINE))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
        pPos++;
    }
    pDecPt = pPos;

    if (*pPos)
    {
        pPos++;
        while (wch = *pPos)
        {
            if ((wch < NLS_CHAR_ZERO) || (wch > NLS_CHAR_NINE))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (0);
            }
            pPos++;
        }
    }

    //
    //  Remove any leading zeros in the integer part.
    //
    while (pValue < pDecPt)
    {
        if (*pValue != NLS_CHAR_ZERO)
        {
            break;
        }
        pValue++;
    }

    //
    //  Save the number of integers to the left of the decimal.
    //
    IntegerNum = (int)(pDecPt - pValue);

    //
    //  Make sure the value string passed in is not too large for
    //  the buffers.
    //
    IntPartSize = IntegerNum;
    NumGroupings = 0;
    NumSeparators = 0;
    if ((GroupSize = pFormat->Grouping) && (IntPartSize))
    {
        //
        //  Count the number of groupings and save them in an array to be
        //  used later.
        //
        while (GroupSize && (NumGroupings < MAX_GROUPS))
        {
            pGroupArray[NumGroupings] = GroupSize % 10;
            GroupSize /= 10;
            NumGroupings++;
        }

        //
        //  Count the number of groupings that apply to the given number
        //  string.
        //
        NumDigits = IntegerNum;
        Ctr = (NumGroupings != 0) ? (NumGroupings - 1) : 0;
        while (Ctr)
        {
            if (NumDigits > pGroupArray[Ctr])
            {
                NumDigits -= pGroupArray[Ctr];
                NumSeparators++;
            }
            else
            {
                if (NumDigits == pGroupArray[Ctr])
                {
                    NumRound = 0;
                }
                break;
            }
            Ctr--;
        }
        if ((Ctr == 0) && pGroupArray[0])
        {
            if (NumDigits > pGroupArray[0])
            {
                NumSeparators += (NumDigits - 1) / pGroupArray[0];
            }
            NumRound = NumDigits % pGroupArray[0];
        }

        IntPartSize += MAX_STHOUSAND * NumSeparators;
    }

    //
    //  Make sure the buffer is large enough.  If not, return the size
    //  needed.
    //
    if (IntPartSize > (BufSize - MAX_NON_INTEGER_PART))
    {
        if (fSetError)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
        }
        *pNeededSizeToAllocate = (IntPartSize + MAX_NON_INTEGER_PART);
        return (0);
    }

    //
    //  Initialize pointers.
    //
    pPosBuf = *ppBuf;
    pPos = pValue;
    *pfZeroValue = FALSE;

    //
    //  See if there are any digits before the decimal point.
    //
    if (pPos == pDecPt)
    {
        //
        //  Possibly a zero value.  All leading zeros were removed, so
        //  there is no integer part.
        //
        *pfZeroValue = TRUE;

        //
        //  No digits before decimal point, so add a leading zero
        //  to the final string if appropriate.
        //
        if (pFormat->LeadingZero)
        {
            *pPosBuf = NLS_CHAR_ZERO;
            pPosBuf++;
        }
    }
    else if (!NumSeparators)
    {
        //
        //  Grouping Size is zero or larger than the integer part of the
        //  string, so copy up to the decimal point (or end of string).
        //
        while (pPos < pDecPt)
        {
            *pPosBuf = *pPos;
            pPosBuf++;
            pPos++;
        }
    }
    else
    {
        //
        //  Copy up to where the first thousand separator should be.
        //  Use groupings of GroupSize numbers up to the decimal point.
        //
        NumDigits = IntegerNum;
        Ctr = (NumGroupings != 0) ? (NumGroupings - 1) : 0;
        while (Ctr)
        {
            if (NumDigits > pGroupArray[Ctr])
            {
                NumDigits -= pGroupArray[Ctr];
            }
            else
            {
                break;
            }
            Ctr--;
        }
        GroupSize = pGroupArray[Ctr];

        pPos2 = GroupSize
                  ? (pPos + (NumDigits % GroupSize))
                  : (pPos + NumDigits);
        if (pPos2 == pPos)
        {
            //
            //  Don't want to write thousand separator at the beginning
            //  of the string.  There's at least GroupSize numbers
            //  in the string, so just advance pPos2 so that GroupSize
            //  numbers will be copied.
            //
            pPos2 = pPos + GroupSize;
        }
        while (pPos < pPos2)
        {
            *pPosBuf = *pPos;
            pPosBuf++;
            pPos++;
            NumDigits--;
        }

        //
        //  Copy the thousand separator followed by GroupSize number of
        //  digits from the given string until the entire repeating
        //  GroupSize ends (or end of string).
        //
        while (NumDigits)
        {
            //
            //  Copy the localized thousand separator.
            //
            pPos2 = pFormat->lpThousandSep;
            while (*pPos2)
            {
                *pPosBuf = *pPos2;
                pPosBuf++;
                pPos2++;
            }

            //
            //  Copy GroupSize number of digits.
            //
            pPos2 = pPos + GroupSize;
            while (pPos < pPos2)
            {
                *pPosBuf = *pPos;
                pPosBuf++;
                pPos++;
                NumDigits--;
            }
        }

        //
        //  Copy the thousand separator followed by GroupSize number of
        //  digits from the given string - until the decimal point (or
        //  end of string) in the given string is reached.
        //
        if (pPos < pDecPt)
        {
            Ctr++;
            while (Ctr < NumGroupings)
            {
                //
                //  Copy the localized thousand separator.
                //
                pPos2 = pFormat->lpThousandSep;
                while (*pPos2)
                {
                    *pPosBuf = *pPos2;
                    pPosBuf++;
                    pPos2++;
                }

                //
                //  Copy GroupSize number of digits.
                //
                pPos2 = pPos + pGroupArray[Ctr];
                while (pPos < pPos2)
                {
                    *pPosBuf = *pPos;
                    pPosBuf++;
                    pPos++;
                }

                //
                //  Go to the next grouping.
                //
                Ctr++;
            }
        }
    }

    //
    //  See if there is a decimal separator in the given string.
    //
    if (pFormat->NumDigits > 0)
    {
        //
        //  Copy the localized decimal separator only if the number
        //  of digits right of the decimal is greater than zero.
        //
        pDecPt = pPosBuf;
        pPos2 = pFormat->lpDecimalSep;
        while (*pPos2)
        {
            *pPosBuf = *pPos2;
            pPosBuf++;
            pPos2++;
        }
    }

    //
    //  Skip over the decimal point in the given string and
    //  copy the rest of the digits from the given string.
    //
    if (*pPos)
    {
        pPos++;
    }
    pPos2 = pPos + pFormat->NumDigits;
    while ((*pPos) && (pPos < pPos2))
    {
        if (*pPos != NLS_CHAR_ZERO)
        {
            *pfZeroValue = FALSE;
        }
        *pPosBuf = *pPos;
        pPosBuf++;
        pPos++;
    }

    //
    //  Make sure some value is in the buffer.
    //
    if (*ppBuf == pPosBuf)
    {
        *pPosBuf = NLS_CHAR_ZERO;
        pPosBuf++;
    }

    //
    //  See if we need to round the number or pad it with zeros.
    //
    if (*pPos)
    {
        //
        //  Round the number if necessary.
        //
        if (*pPos2 > L'4')
        {
            *pfZeroValue = FALSE;

            //
            //  Round the number.  If GroupSize is 0, then we need to
            //  pass in a non-zero value so that the thousand separator
            //  will not be added to the front of the string (if it
            //  rounds that far).
            //
            pPosBuf--;
            NLS_ROUND_IT( *ppBuf,
                          pPosBuf,
                          NumRound,
                          pFormat->lpThousandSep );
            pPosBuf++;
        }
    }
    else
    {
        //
        //  Pad the string with the appropriate number of zeros.
        //
        while (pPos < pPos2)
        {
            *pPosBuf = NLS_CHAR_ZERO;
            pPosBuf++;
            pPos++;
        }
    }

    //
    //  Zero terminate the string.
    //
    *pPosBuf = 0;

    //
    //  Return the number of characters written to the buffer, including
    //  the null terminator.
    //
    return ((int)((pPosBuf - *ppBuf) + 1));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseNumber
//
//  Puts the properly formatted number string into the given string buffer.
//  It returns the number of characters written to the string buffer.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseNumber(
    PLOC_HASH pHashN,
    BOOL NoUserOverride,
    LPWSTR pValue,
    LPNUMBERFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    int *pNeededSizeToAllocate,
    BOOL fSetError)

{
    LPWSTR pBegin;                     // ptr to beginning of final buffer
    LPWSTR pEnd;                       // ptr to end of final buffer
    LPWSTR pNegSign;                   // ptr to negative sign string
    BOOL IsNeg;                        // if negative sign in string
    int Length;                        // length of number string
    BOOL fZeroValue = FALSE;           // if number is a zero value
    int NegSignSize;                   // size of negative sign string
    WCHAR pTemp[MAX_REG_VAL_SIZE];     // temp buffer


    //
    //  Initialize pointer.
    //
    //  Account for:
    //    - negative sign
    //    - blank spaces
    //    - one extra number from rounding
    //    - one extra grouping separator from rounding
    //
    pBegin = *ppBuf + MAX_NUMBER_EXTRAS;

    //
    //  If the first value is a negative, then increment past it.
    //
    if (IsNeg = (*pValue == NLS_CHAR_HYPHEN))
    {
        pValue++;
    }

    //
    //  Get the appropriate number string and place it in the buffer.
    //
    Length = GetNumberString( pHashN,
                              pValue,
                              pFormat,
                              &pBegin,
                              BufSize - MAX_NUMBER_EXTRAS,
                              &fZeroValue,
                              pNeededSizeToAllocate,
                              fSetError );
    if (!Length)
    {
        if (*pNeededSizeToAllocate > 0)
        {
            *pNeededSizeToAllocate += MAX_NUMBER_EXTRAS;
        }
        return (0);
    }

    //
    //  Advance pEnd position pointer to the end of the number string.
    //
    pEnd = pBegin + (Length - 1);

    //
    //  See if any characters should be put in the buffer BEFORE and
    //  AFTER the properly formatted number string.
    //      - negative sign or opening/closing parenthesis
    //      - blank space
    //
    if (!fZeroValue && IsNeg)
    {
        //
        //  Get the negative sign string.
        //
        if (pFormat->NegativeOrder != 0)
        {
            if ( (!NoUserOverride) &&
                 GetUserInfo( pHashN->Locale,
                              LOCALE_SNEGATIVESIGN,
                              FIELD_OFFSET(NLS_USER_INFO, sNegSign),
                              NLS_VALUE_SNEGATIVESIGN,
                              pTemp,
                              ARRAYSIZE(pTemp),
                              TRUE ) &&
                 IsValidSeparatorString( pTemp,
                                         MAX_SNEGSIGN,
                                         FALSE ) )
            {
                pNegSign = pTemp;
            }
            else
            {
                pNegSign = (LPWORD)(pHashN->pLocaleHdr) +
                           pHashN->pLocaleHdr->SNegativeSign;
            }
        }

        switch (pFormat->NegativeOrder)
        {
            case ( 0 ) :
            {
                //
                //  Put the opening parenthesis in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_OPEN_PAREN;

                //
                //  Put the closing parenthesis in the buffer.
                //
                *pEnd = NLS_CHAR_CLOSE_PAREN;
                pEnd++;

                break;
            }
            case ( 2 ) :
            {
                //
                //  Put the space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Fall through to case 1.
                //
            }
            case ( 1 ) :
            default :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                NegSignSize = NlsStrLenW(pNegSign);
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                break;
            }
            case ( 4 ) :
            {
                //
                //  Put the space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Fall Through to case 3.
                //
            }
            case ( 3 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                break;
            }
        }
    }

    //
    //  Zero terminate the string.
    //
    *pEnd = 0;

    //
    //  Return the pointer to the beginning of the string.
    //
    *ppBuf = pBegin;

    //
    //  Return the number of characters written to the buffer, including
    //  the null terminator.
    //
    return ((int)((pEnd - pBegin) + 1));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseCurrency
//
//  Puts the properly formatted currency string into the given string buffer.
//  It returns the number of characters written to the string buffer.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseCurrency(
    PLOC_HASH pHashN,
    BOOL NoUserOverride,
    LPWSTR pValue,
    LPCURRENCYFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    int *pNeededSizeToAllocate,
    BOOL fSetError)

{
    LPWSTR pBegin;                     // ptr to beginning of final buffer
    LPWSTR pEnd;                       // ptr to end of final buffer
    LPWSTR pNegSign;                   // ptr to negative sign string
    BOOL IsNeg;                        // if negative sign in string
    int Length;                        // length of number string
    BOOL fZeroValue = FALSE;           // if number is a zero value
    int NegSignSize;                   // size of negative sign string
    UINT NegOrder;                     // negative ordering
    int CurrSymSize;                   // size of currency symbol
    WCHAR pTemp[MAX_REG_VAL_SIZE];     // temp buffer


    //
    //  Initialize pointer.
    //
    //  Account for:
    //    - negative sign
    //    - currency sign
    //    - blank spaces
    //    - one extra number from rounding
    //    - one extra grouping separator from rounding
    //
    pBegin = *ppBuf + MAX_CURRENCY_EXTRAS;

    //
    //  If the first value is a negative, then increment past it.
    //
    if (IsNeg = (*pValue == NLS_CHAR_HYPHEN))
    {
        pValue++;
    }

    //
    //  Get the appropriate number string and place it in the buffer.
    //
    Length = GetNumberString( pHashN,
                              pValue,
                              (LPNUMBERFMTW)pFormat,
                              &pBegin,
                              BufSize - MAX_CURRENCY_EXTRAS,
                              &fZeroValue,
                              pNeededSizeToAllocate,
                              fSetError );
    if (!Length)
    {
        if (*pNeededSizeToAllocate > 0)
        {
            *pNeededSizeToAllocate += MAX_CURRENCY_EXTRAS;
        }
        return (0);
    }

    //
    //  Advance pEnd position pointer to the end of the number string.
    //
    pEnd = pBegin + (Length - 1);

    //
    //  Get the size of the currency symbol.
    //
    CurrSymSize = NlsStrLenW(pFormat->lpCurrencySymbol);

    //
    //  See if any characters should be put in the buffer BEFORE and
    //  AFTER the properly formatted number string.
    //      - currency symbol
    //      - negative sign or opening/closing parenthesis
    //      - blank space
    //
    if (!fZeroValue && IsNeg)
    {
        //
        //  Get the negative sign string and the size of it.
        //
        NegOrder = pFormat->NegativeOrder;
        if ((NegOrder != 0) && (NegOrder != 4) && (NegOrder < 14))
        {
            if ( (!NoUserOverride) &&
                 GetUserInfo( pHashN->Locale,
                              LOCALE_SNEGATIVESIGN,
                              FIELD_OFFSET(NLS_USER_INFO, sNegSign),
                              NLS_VALUE_SNEGATIVESIGN,
                              pTemp,
                              ARRAYSIZE(pTemp),
                              TRUE ) &&
                 IsValidSeparatorString( pTemp,
                                         MAX_SNEGSIGN,
                                         FALSE ) )
            {
                pNegSign = pTemp;
            }
            else
            {
                pNegSign = (LPWORD)(pHashN->pLocaleHdr) +
                           pHashN->pLocaleHdr->SNegativeSign;
            }

            NegSignSize = NlsStrLenW(pNegSign);
        }

        switch (NegOrder)
        {
            case ( 0 ) :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Put the opening parenthesis in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_OPEN_PAREN;

                //
                //  Put the closing parenthesis in the buffer.
                //
                *pEnd = NLS_CHAR_CLOSE_PAREN;
                pEnd++;

                break;
            }
            case ( 1 ) :
            default :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                break;
            }
            case ( 2 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 3 ) :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                break;
            }
            case ( 4 ) :
            {
                //
                //  Put the opening parenthesis in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_OPEN_PAREN;

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                //
                //  Put the closing parenthesis in the buffer.
                //
                *pEnd = NLS_CHAR_CLOSE_PAREN;
                pEnd++;

                break;
            }
            case ( 5 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 6 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 7 ) :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                break;
            }
            case ( 8 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                //
                //  Put a space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 9 ) :
            {
                //
                //  Put a space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                break;
            }
            case ( 10 ) :
            {
                //
                //  Put a space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                break;
            }
            case ( 11 ) :
            {
                //
                //  Put a space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                break;
            }
            case ( 12 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                //
                //  Put a space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 13 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                //
                //  Put a space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 14 ) :
            {
                //
                //  Put a space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Put the opening parenthesis in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_OPEN_PAREN;

                //
                //  Put the closing parenthesis in the buffer.
                //
                *pEnd = NLS_CHAR_CLOSE_PAREN;
                pEnd++;

                break;
            }
            case ( 15 ) :
            {
                //
                //  Put the opening parenthesis in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_OPEN_PAREN;

                //
                //  Put a space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                //
                //  Put the closing parenthesis in the buffer.
                //
                *pEnd = NLS_CHAR_CLOSE_PAREN;
                pEnd++;

                break;
            }
        }
    }
    else
    {
        //
        //  Positive value.  Store the currency symbol in the string
        //  if the positive order is either 0 or 2.  Otherwise, wait
        //  till the end.
        //
        switch (pFormat->PositiveOrder)
        {
            case ( 2 ) :
            {
                //
                //  Put a space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Fall through to case 0.
                //
            }
            case ( 0 ) :
            default :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 3 ) :
            {
                //
                //  Put a space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Fall through to case 1.
                //
            }
            case ( 1 ) :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                break;
            }
        }
    }

    //
    //  Zero terminate the string.
    //
    *pEnd = 0;

    //
    //  Return the pointer to the beginning of the string.
    //
    *ppBuf = pBegin;

    //
    //  Return the number of characters written to the buffer, including
    //  the null terminator.
    //
    return ((int)((pEnd - pBegin) + 1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\security.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    security.c

Abstract:

    This file handles the management of the NLS per-thread and process cache.
    The cache is only established when hitting an API that needs it. The process
    NLS cache is used when accessing NLS info for a process NOT running in the
    context of the interactive logged on user. The per-thread NLS cache is used
    when accssing NLS info and the thread is doing a user impersonation.

    External Routines found in this file:
      NlsFlushProcessCache
      NlsGetCurrentUserNlsInfo
      NlsIsInteractiveUserProcess
      NlsCheckForInteractiveUser
      NlsGetUserLocale

Revision History:

    03-29-1999    SamerA    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"




//
//  Global Variables.
//

//
//  Process Nls Cache.
//
PNLS_LOCAL_CACHE gpNlsProcessCache;

//
//  Whether the current running process is the same as the
//  interactive logged on user.
//
BOOL gInteractiveLogonUserProcess = (BOOL)-1;




//
//  Forward Declarations.
//

NTSTATUS FASTCALL
NlsGetCacheBuffer(
    PNLS_USER_INFO pNlsUserInfo,
    LCTYPE LCType,
    PWSTR *ppCache);

void FASTCALL
NlsInvalidateCache(
    PNLS_USER_INFO pNlsUserInfo);





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsFlushProcessCache
//
//  Invalidates an entry in the NLS process cache.
//
//  05-22-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsFlushProcessCache(
    LCTYPE LCType)
{
    PWSTR pOutputCache;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    //  If there is no thread impersonation, then flush the
    //  process entry cache.
    //
    if (NtCurrentTeb()->IsImpersonating != 0)
    {
        return (NtStatus);
    }

    if (gpNlsProcessCache)
    {
        NtStatus = NlsGetCacheBuffer( &gpNlsProcessCache->NlsInfo,
                                      LCType,
                                      &pOutputCache );
        if (NT_SUCCESS(NtStatus))
        {
            RtlEnterCriticalSection(&gcsNlsProcessCache);

            pOutputCache[0] = NLS_INVALID_INFO_CHAR;

            RtlLeaveCriticalSection(&gcsNlsProcessCache);
        }
    }

    return (NtStatus);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsGetCurrentUserNlsInfo
//
//  Retreive the NLS info correponding to the current security context.
//
//  03-29-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsGetCurrentUserNlsInfo(
    LCID Locale,
    LCTYPE LCType,
    PWSTR RegistryValue,
    PWSTR pOutputBuffer,
    size_t cchOutputBuffer,
    BOOL IgnoreLocaleValue)
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PNLS_LOCAL_CACHE pNlsThreadCache;
    PWSTR pOutputCache;

    //
    //  Possible NtCurrentTeb()->IsImpersonating values :
    //
    //  0  : Thread isn't impersonating any user.
    //
    //  1  : Thread has just started to do impersonation.
    //       Per thread cache needs to be allocated now.
    //
    //  2  : Thread is calling the NLS apis while its
    //       a context other than the interactive logged on user.
    //
    switch (NtCurrentTeb()->IsImpersonating)
    {
        case ( 0 ) :
        {
            //
            //  Thread is NOT impersonating any user. We check if the process
            //  belongs to the interactive user, then we retreive the info from
            //  the NLS cache in CSR.  Otherwise if the process is running in
            //  the context of a different user, then we retreive the NLS info
            //  from the process cache.
            //
            if (gInteractiveLogonUserProcess == (BOOL)-1)
            {
                NlsIsInteractiveUserProcess();
            }

            if (gInteractiveLogonUserProcess == FALSE)
            {
                if ((IgnoreLocaleValue) ||
                    (GetUserDefaultLCID() == Locale))
                {
                    if (!gpNlsProcessCache)
                    {
                        //
                        //  Allocate and invalidate the NLS process cache.
                        //
                        RtlEnterCriticalSection(&gcsNlsProcessCache);

                        if (!gpNlsProcessCache)
                        {
                            gpNlsProcessCache = RtlAllocateHeap(
                                                     RtlProcessHeap(),
                                                     0,
                                                     sizeof(NLS_LOCAL_CACHE) );
                            if (gpNlsProcessCache)
                            {
                                NlsInvalidateCache(&gpNlsProcessCache->NlsInfo);
                                gpNlsProcessCache->CurrentUserKeyHandle = NULL;
                            }
                        }

                        RtlLeaveCriticalSection(&gcsNlsProcessCache);
                    }

                    if (gpNlsProcessCache)
                    {
                        NtStatus = NlsGetCacheBuffer( &gpNlsProcessCache->NlsInfo,
                                                      LCType,
                                                      &pOutputCache);
                        if (NT_SUCCESS(NtStatus))
                        {
                            //
                            //  See if it is a valid cache.
                            //
                            if (pOutputCache[0] == NLS_INVALID_INFO_CHAR)
                            {
                                RtlEnterCriticalSection(&gcsNlsProcessCache);

                                if (GetUserInfoFromRegistry( RegistryValue,
                                                             pOutputCache,
                                                             MAX_REG_VAL_SIZE, 0 ) == FALSE)
                                {
                                    NtStatus = STATUS_UNSUCCESSFUL;
                                    pOutputCache[0] = NLS_INVALID_INFO_CHAR;
                                }

                                RtlLeaveCriticalSection(&gcsNlsProcessCache);
                            }

                            if (NT_SUCCESS(NtStatus))
                            {
                                if(FAILED((StringCchCopyW(pOutputBuffer, cchOutputBuffer, pOutputCache))))
                                {
                                    NtStatus = STATUS_UNSUCCESSFUL;
                                }
                            }
                        }
                    }
                }
            }
            break;
        }
        case ( 1 ) :
        {
            //
            //  Thread started to do impersonation.
            //
            pNlsThreadCache = NtCurrentTeb()->NlsCache;

            if (!pNlsThreadCache)
            {
                pNlsThreadCache = RtlAllocateHeap( RtlProcessHeap(),
                                                   0,
                                                   sizeof(NLS_LOCAL_CACHE) );
                if (pNlsThreadCache)
                {
                    pNlsThreadCache->CurrentUserKeyHandle = NULL;
                }

                NtCurrentTeb()->NlsCache = (PVOID) pNlsThreadCache;
            }

            if (pNlsThreadCache)
            {
                NlsInvalidateCache(&pNlsThreadCache->NlsInfo);
            }

            NtCurrentTeb()->IsImpersonating = 2;

            //
            //  Fall Thru...
            //
        }
        case ( 2 ) :
        {
            //
            //  Thread is impersonating a particular user.
            //
            pNlsThreadCache = NtCurrentTeb()->NlsCache;

            if (pNlsThreadCache)
            {

                if ((IgnoreLocaleValue) ||
                    (GetUserDefaultLCID() == Locale))
                {
                    NtStatus = NlsGetCacheBuffer( &pNlsThreadCache->NlsInfo,
                                                  LCType,
                                                  &pOutputCache );
                    if (NT_SUCCESS(NtStatus))
                    {
                        if (pOutputCache[0] == NLS_INVALID_INFO_CHAR)
                        {
                            //
                            //  Don't cache key handles - this will break
                            //  profile unload.
                            //
                            OPEN_CPANEL_INTL_KEY( pNlsThreadCache->CurrentUserKeyHandle,
                                                  STATUS_UNSUCCESSFUL,
                                                  KEY_READ );

                            NtStatus = NlsQueryCurrentUserInfo( pNlsThreadCache,
                                                                RegistryValue,
                                                                pOutputCache,
                                                                MAX_REG_VAL_SIZE );

                            CLOSE_REG_KEY(pNlsThreadCache->CurrentUserKeyHandle);

                            if (!NT_SUCCESS(NtStatus))
                            {
                                pOutputCache[0] = NLS_INVALID_INFO_CHAR;
                            }
                        }

                        if (NT_SUCCESS(NtStatus))
                        {
                            if(FAILED((StringCchCopyW(pOutputBuffer, cchOutputBuffer, pOutputCache))))
                            {
                                NtStatus = STATUS_UNSUCCESSFUL;
                            }
                        }
                    }
                }
            }
            break;
        }
    }

    return (NtStatus);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsIsInteractiveUserProcess
//
//  Read the process's authetication id out of its access token object and
//  cache it since it never changes.
//
//  12-27-98     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsIsInteractiveUserProcess()
{
    NTSTATUS NtStatus;
    TOKEN_STATISTICS TokenInformation;
    HANDLE TokenHandle;
    ULONG BytesRequired;
    BOOL IsInteractiveProcess = TRUE;


    //
    //  Get the process access token.
    //
    NtStatus = NtOpenProcessToken( NtCurrentProcess(),
                                   TOKEN_QUERY,
                                   &TokenHandle );
    if (NT_SUCCESS(NtStatus))
    {
        //
        //  Get the LUID.
        //
        NtStatus = NtQueryInformationToken( TokenHandle,
                                            TokenStatistics,
                                            &TokenInformation,
                                            sizeof(TokenInformation),
                                            &BytesRequired );
        if (NT_SUCCESS(NtStatus))
        {
            if (RtlEqualLuid( &pNlsUserInfo->InteractiveUserLuid,
                              &TokenInformation.AuthenticationId ) == FALSE)
            {
                IsInteractiveProcess = FALSE;
            }
        }

        NtClose(TokenHandle);
    }

    gInteractiveLogonUserProcess = IsInteractiveProcess;

    return (NtStatus);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsCheckForInteractiveUser
//
//  This function makes sure that the current thread isn't impersonating
//  anybody, but the interactive.  It compares the authentication-id of the
//  interactive user -cached in CSRSS at logon time- with the
//  authentication-id of the current thread or process.  It returns failure
//  ONLY if the current security context -session- isn't the same as the
//  interactive logged-on user.
//
//  12-16-98     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsCheckForInteractiveUser()
{
    NTSTATUS NtStatus, ReturnStatus = STATUS_SUCCESS;
    TOKEN_STATISTICS TokenInformation;
    HANDLE TokenHandle;
    ULONG BytesRequired;
    PLUID InteractiveUserLuid = &pNlsUserInfo->InteractiveUserLuid;


    //
    //  Get the Token Handle.
    //  Fast optimization to detect if a thread hasn't started to do any
    //  impersonation, which is the case for most GUI user apps.
    //
    if (NtCurrentTeb()->IsImpersonating == 0)
    {
        NtStatus = STATUS_NO_TOKEN;
    }
    else
    {
        NtStatus = NtOpenThreadToken( NtCurrentThread(),
                                      TOKEN_QUERY,
                                      FALSE,
                                      &TokenHandle );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        if (NtStatus != STATUS_NO_TOKEN)
        {
            KdPrint(("NLSAPI: Couldn't retreive thread token - %lx.\n", NtStatus));
            return (STATUS_SUCCESS);
        }

        //
        //  Get the process access token.
        //
        if (gInteractiveLogonUserProcess == (BOOL)-1)
        {
            NtStatus = NlsIsInteractiveUserProcess();

            if (!NT_SUCCESS(NtStatus))
            {
                KdPrint(("NLSAPI: Couldn't retreive process token - %lx\n", NtStatus));
                return (STATUS_SUCCESS);
            }
        }

        if (gInteractiveLogonUserProcess == FALSE)
        {
            ReturnStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        //
        //  Get the AuthenticationId of the current thread's security context.
        //
        NtStatus = NtQueryInformationToken( TokenHandle,
                                            TokenStatistics,
                                            &TokenInformation,
                                            sizeof(TokenInformation),
                                            &BytesRequired );

        //
        //  Close the thread token here.
        //
        NtClose(TokenHandle);

        if (NT_SUCCESS(NtStatus))
        {
            if (RtlEqualLuid( InteractiveUserLuid,
                              &TokenInformation.AuthenticationId ) == FALSE)
            {
                ReturnStatus = STATUS_UNSUCCESSFUL;
            }
        }
    }

    return (ReturnStatus);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsGetUserLocale
//
//  Retreives the user locale from the registry of the current security
//  context.  It is called ONLY when the running security context is
//  different from the interactive logged-on security context-(user).
//
//  12-16-98     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsGetUserLocale(
    LCID *Lcid)
{
    NTSTATUS NtStatus;
    WCHAR wszLocale[MAX_REG_VAL_SIZE];
    UNICODE_STRING ObLocaleString;
    PNLS_LOCAL_CACHE pNlsCache = NtCurrentTeb()->NlsCache;


    //
    //  Get the current user locale.
    //
    NtStatus = NlsGetCurrentUserNlsInfo( LOCALE_USER_DEFAULT,
                                         (LCTYPE)LOCALE_SLOCALE,
                                         L"Locale",
                                         wszLocale,
                                         ARRAYSIZE(wszLocale),
                                         TRUE );
    if ((NT_SUCCESS(NtStatus)) ||
        (GetUserInfoFromRegistry(L"Locale", wszLocale, ARRAYSIZE(wszLocale), 0)))
    {
        RtlInitUnicodeString(&ObLocaleString, wszLocale);
        NtStatus = RtlUnicodeStringToInteger( &ObLocaleString,
                                              16,
                                              (PULONG)Lcid);
    }

    return (NtStatus);
}





//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////
//
//  NlsGetCacheBuffer
//
//  Get a buffer pointer inside the cache for this LCTYPE.
//
//  03-29-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS FASTCALL NlsGetCacheBuffer(
    PNLS_USER_INFO pNlsUserInfo,
    LCTYPE LCType,
    PWSTR *ppCache)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    switch (LCType)
    {
        case ( LOCALE_SLANGUAGE ) :
        {
            *ppCache = pNlsUserInfo->sAbbrevLangName;
            break;
        }
        case ( LOCALE_ICOUNTRY ) :
        {
            *ppCache = pNlsUserInfo->iCountry;
            break;
        }
        case ( LOCALE_SCOUNTRY ) :
        {
            *ppCache = pNlsUserInfo->sCountry;
            break;
        }
        case ( LOCALE_SLIST ) :
        {
            *ppCache = pNlsUserInfo->sList;
            break;
        }
        case ( LOCALE_IMEASURE ) :
        {
            *ppCache = pNlsUserInfo->iMeasure;
            break;
        }
        case ( LOCALE_IPAPERSIZE ) :
        {
            *ppCache = pNlsUserInfo->iPaperSize;
            break;
        }
        case ( LOCALE_SDECIMAL ) :
        {
            *ppCache = pNlsUserInfo->sDecimal;
            break;
        }
        case ( LOCALE_STHOUSAND ) :
        {
            *ppCache = pNlsUserInfo->sThousand;
            break;
        }
        case ( LOCALE_SGROUPING ) :
        {
            *ppCache = pNlsUserInfo->sGrouping;
            break;
        }
        case ( LOCALE_IDIGITS ) :
        {
            *ppCache = pNlsUserInfo->iDigits;
            break;
        }
        case ( LOCALE_ILZERO ) :
        {
            *ppCache = pNlsUserInfo->iLZero;
            break;
        }
        case ( LOCALE_INEGNUMBER ) :
        {
            *ppCache = pNlsUserInfo->iNegNumber;
            break;
        }
        case ( LOCALE_SNATIVEDIGITS ) :
        {
            *ppCache = pNlsUserInfo->sNativeDigits;
            break;
        }
        case ( LOCALE_IDIGITSUBSTITUTION ) :
        {
            *ppCache = pNlsUserInfo->iDigitSubstitution;
            break;
        }
        case ( LOCALE_SCURRENCY ) :
        {
            *ppCache = pNlsUserInfo->sCurrency;
            break;
        }
        case ( LOCALE_SMONDECIMALSEP ) :
        {
            *ppCache = pNlsUserInfo->sMonDecSep;
            break;
        }
        case ( LOCALE_SMONTHOUSANDSEP ) :
        {
            *ppCache = pNlsUserInfo->sMonThouSep;
            break;
        }
        case ( LOCALE_SMONGROUPING ) :
        {
            *ppCache = pNlsUserInfo->sMonGrouping;
            break;
        }
        case ( LOCALE_ICURRDIGITS ) :
        {
            *ppCache = pNlsUserInfo->iCurrDigits;
            break;
        }
        case ( LOCALE_ICURRENCY ) :
        {
            *ppCache = pNlsUserInfo->iCurrency;
            break;
        }
        case ( LOCALE_INEGCURR ) :
        {
            *ppCache = pNlsUserInfo->iNegCurr;
            break;
        }
        case ( LOCALE_SPOSITIVESIGN ) :
        {
            *ppCache = pNlsUserInfo->sPosSign;
            break;
        }
        case ( LOCALE_SNEGATIVESIGN ) :
        {
            *ppCache = pNlsUserInfo->sNegSign;
            break;
        }
        case ( LOCALE_STIMEFORMAT ) :
        {
            *ppCache = pNlsUserInfo->sTimeFormat;
            break;
        }
        case ( LOCALE_STIME ) :
        {
            *ppCache = pNlsUserInfo->sTime;
            break;
        }
        case ( LOCALE_ITIME ) :
        {
            *ppCache = pNlsUserInfo->iTime;
            break;
        }
        case ( LOCALE_ITLZERO ) :
        {
            *ppCache = pNlsUserInfo->iTLZero;
            break;
        }
        case ( LOCALE_ITIMEMARKPOSN ) :
        {
            *ppCache = pNlsUserInfo->iTimeMarkPosn;
            break;
        }
        case ( LOCALE_S1159 ) :
        {
            *ppCache = pNlsUserInfo->s1159;
            break;
        }
        case ( LOCALE_S2359 ) :
        {
            *ppCache = pNlsUserInfo->s2359;
            break;
        }
        case ( LOCALE_SSHORTDATE ) :
        {
            *ppCache = pNlsUserInfo->sShortDate;
            break;
        }
        case ( LOCALE_SDATE ) :
        {
            *ppCache = pNlsUserInfo->sDate;
            break;
        }
        case ( LOCALE_IDATE ) :
        {
            *ppCache = pNlsUserInfo->iDate;
            break;
        }
        case ( LOCALE_SYEARMONTH ) :
        {
            *ppCache = pNlsUserInfo->sYearMonth;
            break;
        }
        case ( LOCALE_SLONGDATE ) :
        {
            *ppCache = pNlsUserInfo->sLongDate;
            break;
        }
        case ( LOCALE_ICALENDARTYPE ) :
        {
            *ppCache = pNlsUserInfo->iCalType;
            break;
        }
        case ( LOCALE_IFIRSTDAYOFWEEK ) :
        {
            *ppCache = pNlsUserInfo->iFirstDay;
            break;
        }
        case ( LOCALE_IFIRSTWEEKOFYEAR ) :
        {
            *ppCache = pNlsUserInfo->iFirstWeek;
            break;
        }
        case ( LOCALE_SLOCALE ) :
        {
            *ppCache = pNlsUserInfo->sLocale;
            break;
        }
        default :
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }
    }

    return (NtStatus);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsQueryCurrentUserInfo
//
//  Retreive the NLS info from the registry using a cached key.
//
//  04-07-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsQueryCurrentUserInfo(
    PNLS_LOCAL_CACHE pNlsCache,
    LPWSTR pValue,
    LPWSTR pOutput, 
    size_t cchOutput)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    ULONG rc;


    //
    //  Initialize the output string.
    //
    *pOutput = 0;

    //
    //  Query the registry value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    rc = QueryRegValue( pNlsCache->CurrentUserKeyHandle,
                        pValue,
                        &pKeyValueFull,
                        MAX_KEY_VALUE_FULLINFO,
                        NULL );

    //
    //  If the query failed or if the output buffer is not large enough,
    //  then return failure.
    //
    if ((rc != NO_ERROR) ||
        (pKeyValueFull->DataLength > (MAX_REG_VAL_SIZE * sizeof(WCHAR))))
    {
        return (STATUS_UNSUCCESSFUL);
    }

    //
    //  Save the string in pOutput.
    //
    if(FAILED(StringCchCopyW(pOutput, MAX_REG_VAL_SIZE, GET_VALUE_DATA_PTR(pKeyValueFull))))
    {
        return (STATUS_UNSUCCESSFUL);
    }

    //
    //  Return success.
    //
    return (STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsInvalidateCache
//
//  Invalidate an NLS Cache.
//
//  03-29-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

void FASTCALL NlsInvalidateCache(
    PNLS_USER_INFO pNlsUserInfo)
{
    pNlsUserInfo->sAbbrevLangName[0]    = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iCountry[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sCountry[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sList[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iMeasure[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iPaperSize[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sDecimal[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sThousand[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sGrouping[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iDigits[0]            = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iLZero[0]             = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iNegNumber[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sNativeDigits[0]      = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iDigitSubstitution[0] = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sCurrency[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sMonDecSep[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sMonThouSep[0]        = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sMonGrouping[0]       = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iCurrDigits[0]        = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iCurrency[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iNegCurr[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sPosSign[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sNegSign[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sTimeFormat[0]        = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sTime[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iTime[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iTLZero[0]            = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iTimeMarkPosn[0]      = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->s1159[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->s2359[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sShortDate[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sDate[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iDate[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sYearMonth[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sLongDate[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iCalType[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iFirstDay[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iFirstWeek[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sLocale[0]            = NLS_INVALID_INFO_CHAR;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\section.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    section.c

Abstract:

    This file contains functions that deal with creating, opening, or
    mapping a section for data table files for the NLS API.

    External Routines found in this file:
      CreateNlsObjectDirectory
      CreateRegKey
      OpenRegKey
      QueryRegValue
      SetRegValue
      CreateSectionFromReg
      CreateSectionOneValue
      CreateSectionTemp
      OpenSection
      MapSection
      UnMapSection
      GetNlsSectionName
      GetCodePageDLLPathName

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"




//
//  Forward Declarations.
//

ULONG
OpenDataFile(
    HANDLE *phFile,
    LPWSTR pFile);

ULONG
GetNTFileName(
    LPWSTR pFile,
    PUNICODE_STRING pFileName);

ULONG
CreateNlsSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    UINT                 SecurityDescriptorSize,
    ACCESS_MASK          AccessMask);

ULONG
AppendAccessAllowedACE(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ACCESS_MASK AccessMask);





//-------------------------------------------------------------------------//
//                           INTERNAL MACROS                               //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NLS_REG_BUFFER_ALLOC
//
//  Allocates the buffer used by the registry enumeration and query calls
//  and sets the pKeyValueFull variable to point at the newly created buffer.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_REG_BUFFER_ALLOC( pKeyValueFull,                               \
                              BufSize,                                     \
                              pBuffer,                                     \
                              CritSect )                                   \
{                                                                          \
    if ((pBuffer = (PVOID)NLS_ALLOC_MEM(BufSize)) == NULL)                 \
    {                                                                      \
        KdPrint(("NLSAPI: Could NOT Allocate Memory.\n"));                 \
        if (CritSect)                                                      \
        {                                                                  \
            RtlLeaveCriticalSection(&gcsTblPtrs);                          \
        }                                                                  \
        return ((ULONG)STATUS_NO_MEMORY);                                  \
    }                                                                      \
                                                                           \
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pBuffer;                  \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_REG_BUFFER_FREE
//
//  Frees the buffer used by the registry enumeration and query calls.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_REG_BUFFER_FREE(pBuffer)        (NLS_FREE_MEM(pBuffer))





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  CreateNlsObjectDirectory
//
//  This routine creates the object directory for the NLS memory mapped
//  sections.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG CreateNlsObjectDirectory()
{
    BYTE pSecurityDescriptor[MAX_SECURITY_BUF_LEN];  // security descriptor buffer (currently we use like 60 bytes or so of this)
    UNICODE_STRING ObDirName;                        // directory name
    OBJECT_ATTRIBUTES ObjA;                          // object attributes structure
    HANDLE hDirHandle;                               // directory handle
    ULONG rc = 0L;                                   // return code


    //
    //  Create the security descriptor with READ access to the world.
    //
    rc = CreateNlsSecurityDescriptor( pSecurityDescriptor,
                                   MAX_SECURITY_BUF_LEN,
                                   DIRECTORY_QUERY | DIRECTORY_TRAVERSE );
    if (!NT_SUCCESS(rc))
    {
        return (rc);
    }

    //
    //  Add Admin Access for Query.
    //
    rc = AppendAccessAllowedACE( pSecurityDescriptor,
                                 DIRECTORY_QUERY |
                                 DIRECTORY_TRAVERSE |
                                 DIRECTORY_CREATE_OBJECT );
    if (!NT_SUCCESS(rc))
    {
        return (rc);
    }

    //
    //  Create the object directory.
    //
    RtlInitUnicodeString(&ObDirName, NLS_OBJECT_DIRECTORY_NAME);
    InitializeObjectAttributes( &ObjA,
                                &ObDirName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
                                NULL,
                                pSecurityDescriptor );

    rc = NtCreateDirectoryObject( &hDirHandle,
                                  DIRECTORY_TRAVERSE | DIRECTORY_CREATE_OBJECT,
                                  &ObjA );

    //
    //  Close the directory handle.
    //
    NtClose(hDirHandle);

    //
    //  Check for error from NtCreateDirectoryObject.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create Object Directory %wZ - %lx.\n",
                 &ObDirName, rc));
        return (rc);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateRegKey
//
//  This routine creates a key in the registry.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG CreateRegKey(
    PHANDLE phKeyHandle,
    LPWSTR pBaseName,
    LPWSTR pKey,
    ULONG fAccess)
{
    WCHAR pwszKeyName[MAX_PATH_LEN];   // ptr to the full key name
    HANDLE UserKeyHandle;              // HKEY_CURRENT_USER equivalent
    OBJECT_ATTRIBUTES ObjA;            // object attributes structure
    UNICODE_STRING ObKeyName;          // key name
    ULONG rc = 0L;                     // return code


    //
    //  Get the full key name.
    //
    if (pBaseName == NULL)
    {
        //
        //  Get current user's key handle.
        //
        rc = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserKeyHandle);
        if (!NT_SUCCESS(rc))
        {
            KdPrint(("NLSAPI: Could NOT Open HKEY_CURRENT_USER - %lx.\n", rc));
            return (rc);
        }
        pwszKeyName[0] = UNICODE_NULL;
    }
    else
    {
        //
        //  Base name exists, so not current user.
        //
        UserKeyHandle = NULL;
        if(FAILED(StringCchCopyW(pwszKeyName, ARRAYSIZE(pwszKeyName), pBaseName)))
        {
            return(STATUS_UNSUCCESSFUL);
        }
    }

    if(FAILED(StringCchCatW(pwszKeyName, ARRAYSIZE(pwszKeyName), pKey)))
    {
        if (UserKeyHandle != NULL)
        {
            NtClose(UserKeyHandle);
        }
        return(STATUS_UNSUCCESSFUL);
    }

    //
    //  Create the registry key.
    //
    RtlInitUnicodeString(&ObKeyName, pwszKeyName);
    InitializeObjectAttributes( &ObjA,
                                &ObKeyName,
                                OBJ_CASE_INSENSITIVE,
                                UserKeyHandle,
                                NULL );
    rc = NtCreateKey( phKeyHandle,
                      fAccess,
                      &ObjA,
                      0,
                      NULL,
                      REG_OPTION_NON_VOLATILE,
                      NULL );

    //
    //  Close the current user handle, if necessary.
    //
    if (UserKeyHandle != NULL)
    {
        NtClose(UserKeyHandle);
    }

    //
    //  Check for error from NtCreateKey.
    //
    if (!NT_SUCCESS(rc))
    {
        *phKeyHandle = NULL;
    }

    //
    //  Return the status from NtCreateKey.
    //
    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  OpenRegKey
//
//  This routine opens a key in the registry.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG OpenRegKey(
    PHANDLE phKeyHandle,
    LPWSTR pBaseName,
    LPWSTR pKey,
    ULONG fAccess)
{
    WCHAR pwszKeyName[MAX_PATH_LEN];   // ptr to the full key name
    HANDLE UserKeyHandle;              // HKEY_CURRENT_USER equivalent
    OBJECT_ATTRIBUTES ObjA;            // object attributes structure
    UNICODE_STRING ObKeyName;          // key name
    ULONG rc = 0L;                     // return code


    //
    //  Get the full key name.
    //
    if (pBaseName == NULL)
    {
        //
        //  Get current user's key handle.
        //
        rc = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserKeyHandle);
        if (!NT_SUCCESS(rc))
        {
            KdPrint(("NLSAPI: Could NOT Open HKEY_CURRENT_USER - %lx.\n", rc));
            return (rc);
        }
        pwszKeyName[0] = UNICODE_NULL;
    }
    else
    {
        //
        //  Base name exists, so not current user.
        //
        UserKeyHandle = NULL;
        if(FAILED(StringCchCopyW(pwszKeyName, ARRAYSIZE(pwszKeyName), pBaseName)))
        {
            return(STATUS_UNSUCCESSFUL);
        }
    }

    if (pKey)
    {
        if(FAILED(StringCchCatW(pwszKeyName, ARRAYSIZE(pwszKeyName), pKey)))
        {
            if (UserKeyHandle != NULL)
            {
                NtClose(UserKeyHandle);
            }
            return(STATUS_UNSUCCESSFUL);
        }
    }

    //
    //  Open the registry key.
    //
    RtlInitUnicodeString(&ObKeyName, pwszKeyName);
    InitializeObjectAttributes( &ObjA,
                                &ObKeyName,
                                OBJ_CASE_INSENSITIVE,
                                UserKeyHandle,
                                NULL );
    rc = NtOpenKey( phKeyHandle,
                    fAccess,
                    &ObjA );

    //
    //  Close the current user handle, if necessary.
    //
    if (UserKeyHandle != NULL)
    {
        NtClose(UserKeyHandle);
    }

    //
    //  Check for error from NtOpenKey.
    //
    if (!NT_SUCCESS(rc))
    {
        *phKeyHandle = NULL;
    }

    //
    //  Return the status from NtOpenKey.
    //
    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  QueryRegValue
//
//  This routine queries the given value from the registry.
//
//  NOTE: If pIfAlloc is NULL, then no buffer will be allocated.
//        If this routine is successful, the CALLER must free the
//        ppKeyValueFull information buffer if *pIfAlloc is TRUE.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG QueryRegValue(
    HANDLE hKeyHandle,
    LPWSTR pValue,
    PKEY_VALUE_FULL_INFORMATION *ppKeyValueFull,
    ULONG Length,
    LPBOOL pIfAlloc)
{
    UNICODE_STRING ObValueName;        // value name
    PVOID pBuffer;                     // ptr to buffer for enum
    ULONG ResultLength;                // # bytes written
    ULONG rc = 0L;                     // return code


    //
    //  Set contents of pIfAlloc to FALSE to show that we did NOT do a
    //  memory allocation (yet).
    //
    if (pIfAlloc)
    {
        *pIfAlloc = FALSE;
    }

    //
    //  Query the value from the registry.
    //
    RtlInitUnicodeString(&ObValueName, pValue);

    RtlZeroMemory(*ppKeyValueFull, Length);
    rc = NtQueryValueKey( hKeyHandle,
                          &ObValueName,
                          KeyValueFullInformation,
                          *ppKeyValueFull,
                          Length,
                          &ResultLength );

    //
    //  Check the error code.  If the buffer is too small, allocate
    //  a new one and try the query again.
    //
    if ((rc == STATUS_BUFFER_OVERFLOW) && (pIfAlloc))
    {
        //
        //  Buffer is too small, so allocate a new one.
        //
        NLS_REG_BUFFER_ALLOC(*ppKeyValueFull, ResultLength, pBuffer, FALSE);
        RtlZeroMemory(*ppKeyValueFull, ResultLength);
        rc = NtQueryValueKey( hKeyHandle,
                              &ObValueName,
                              KeyValueFullInformation,
                              *ppKeyValueFull,
                              ResultLength,
                              &ResultLength );

        //
        //  Set contents of pIfAlloc to TRUE to show that we DID do
        //  a memory allocation.
        //
        *pIfAlloc = TRUE;
    }

    //
    //  If there is an error at this point, then the query failed.
    //
    if (rc != NO_ERROR)
    {
        if ((pIfAlloc) && (*pIfAlloc))
        {
            NLS_REG_BUFFER_FREE(pBuffer);
        }
        return (rc);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetRegValue
//
//  This routine sets the given value in the registry.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG SetRegValue(
    HANDLE hKeyHandle,
    LPCWSTR pValue,
    LPCWSTR pData,
    ULONG DataLength)
{
    UNICODE_STRING ObValueName;        // value name


    //
    //  Set the value in the registry.
    //
    RtlInitUnicodeString(&ObValueName, pValue);

    return (NtSetValueKey( hKeyHandle,
                           &ObValueName,
                           0,
                           REG_SZ,
                           (PVOID)pData,
                           DataLength ));
}

////////////////////////////////////////////////////////////////////////////
//
//  CreateSectionTemp
//
//  This routine creates a temporary memory mapped section for the given file
//  name and returns the handle to the section.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG CreateSectionTemp(
    HANDLE *phSec,
    LPWSTR pwszFileName)
{
    HANDLE hFile = (HANDLE)0;          // file handle
    OBJECT_ATTRIBUTES ObjA;            // object attributes structure
    ULONG rc = 0L;                     // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Open the data file.
    //
    if (rc = OpenDataFile( &hFile,
                           pwszFileName ))
    {
        return (rc);
    }

    //
    //  Create the section.
    //
    InitializeObjectAttributes( &ObjA,
                                NULL,
                                0,
                                NULL,
                                NULL );

    rc = NtCreateSection( phSec,
                          SECTION_MAP_READ,
                          &ObjA,
                          NULL,
                          PAGE_READONLY,
                          SEC_COMMIT,
                          hFile );

    //
    //  Close the file.
    //
    NtClose(hFile);

    //
    //  Check for error from NtCreateSection.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create Temp Section for %ws - %lx.\n",
                 pwszFileName, rc));
    }

    //
    //  Return success.
    //
    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  OpenSection
//
//  This routine opens the named memory mapped section for the given section
//  name and returns the handle to the section.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG OpenSection(
    HANDLE *phSec,
    PUNICODE_STRING pObSectionName,
    PVOID *ppBaseAddr,
    ULONG AccessMask,
    BOOL bCloseHandle)
{
    OBJECT_ATTRIBUTES ObjA;            // object attributes structure
    ULONG rc = 0L;                     // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Open the Section.
    //
    InitializeObjectAttributes( &ObjA,
                                pObSectionName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    rc = NtOpenSection( phSec,
                        AccessMask,
                        &ObjA );

    //
    //  Check for error from NtOpenSection.
    //
    if (!NT_SUCCESS(rc))
    {
        return (rc);
    }

    //
    //  Map a View of the Section.
    //
    if (rc = MapSection( *phSec,
                         ppBaseAddr,
                         PAGE_READONLY,
                         FALSE ))
    {
        NtClose(*phSec);
        return (rc);
    }

    //
    //  Close the handle to the section.  Once the section has been mapped,
    //  the pointer to the base address will remain valid until the section
    //  is unmapped.  It is not necessary to leave the handle to the section
    //  around.
    //
    if (bCloseHandle)
    {
        NtClose(*phSec);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapSection
//
//  This routine maps a view of the section to the current process and adds
//  the appropriate information to the hash table.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG MapSection(
    HANDLE hSec,
    PVOID *ppBaseAddr,
    ULONG PageProtection,
    BOOL bCloseHandle)
{
    SIZE_T ViewSize;                   // view size of mapped section
    ULONG rc = 0L;                     // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Map a View of the Section.
    //
    *ppBaseAddr = (PVOID)NULL;
    ViewSize = 0L;

    rc = NtMapViewOfSection( hSec,
                             NtCurrentProcess(),
                             ppBaseAddr,
                             0L,
                             0L,
                             NULL,
                             &ViewSize,
                             ViewUnmap,
                             0L,
                             PageProtection );

    //
    //  Close the handle to the section.  Once the section has been mapped,
    //  the pointer to the base address will remain valid until the section
    //  is unmapped.  It is not necessary to leave the handle to the section
    //  around.
    //
    if (bCloseHandle)
    {
        NtClose(hSec);
    }

    //
    //  Check for error from NtMapViewOfSection.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Map View of Section - %lx.\n", rc));
        return (rc);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnMapSection
//
//  This routine unmaps a view of the given section to the current process.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG UnMapSection(
    PVOID pBaseAddr)
{
    ULONG rc = 0L;                     // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  UnMap a View of the Section.
    //
    rc = NtUnmapViewOfSection( NtCurrentProcess(),
                               pBaseAddr );

    //
    //  Check for error from NtUnmapViewOfSection.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Unmap View of Section - %lx.\n", rc));
        return (rc);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetNlsSectionName
//
//  This routine returns a section name by concatenating the given
//  section prefix and the given integer value converted to a string.
//
//  05-31-1991  JulieB      Created.
//  06-04-2002  ShawnSte    Added more security
////////////////////////////////////////////////////////////////////////////

ULONG GetNlsSectionName(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pwszPrefix,
    LPWSTR pwszSecName,
    UINT cchSecName)
{
    size_t  cchUsed;

    // Copy the string, then count how many we copied over.
    if(FAILED(StringCchCopyW(pwszSecName, cchSecName, pwszPrefix)) ||
       FAILED(StringCchLengthW(pwszSecName, cchSecName, &cchUsed )))
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return ( NlsConvertIntegerToString( Value,
                                        Base,
                                        Padding,
                                        pwszSecName + NlsStrLenW(pwszSecName),
                                        cchSecName - cchUsed ));     // Some characters are already used
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCodePageDLLPathName
//
//  This routine returns the full path name for the DLL file found in
//  the CodePage section of the registry for the given code page value.
//
//  10-23-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetCodePageDLLPathName(
    UINT CodePage,
    LPWSTR pDllName,
    USHORT cchLen)
{
    WCHAR pTmpBuf[MAX_SMALL_BUF_LEN];            // temp buffer
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    BOOL IfAlloc = FALSE;                        // if buffer was allocated
    ULONG rc = 0L;                               // return code


    //
    //  Open the CodePage registry key.
    //
    OPEN_CODEPAGE_KEY(ERROR_BADDB);

    //
    //  Convert the code page value to a unicode string.
    //
    if (rc = NlsConvertIntegerToString( CodePage,
                                        10,
                                        0,
                                        pTmpBuf,
                                        MAX_SMALL_BUF_LEN ))
    {
        return (rc);
    }

    //
    //  Query the registry for the code page value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    if (rc = QueryRegValue( hCodePageKey,
                            pTmpBuf,
                            &pKeyValueFull,
                            MAX_KEY_VALUE_FULLINFO,
                            &IfAlloc ))
    {
        return (rc);
    }

    //
    //  Make sure there is data with this value.
    //
    if (pKeyValueFull->DataLength > 2)
    {
        //
        //  Get the full path name for the DLL file.
        //
        if((0 == GetSystemDirectoryW(pDllName, cchLen / 2)) ||
            FAILED(StringCchCatW(pDllName, cchLen, L"\\")) ||
            FAILED(StringCchCatW(pDllName, cchLen, GET_VALUE_DATA_PTR(pKeyValueFull))))
        {
            rc = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    else
    {
        rc = ERROR_INVALID_PARAMETER;
    }

    //
    //  Free the buffer used for the query.
    //
    if (IfAlloc)
    {
        NLS_FREE_MEM(pKeyValueFull);
    }

    //
    //  Return.
    //
    return (rc);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  OpenDataFile
//
//  This routine opens the data file for the specified file name and
//  returns the handle to the file.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG OpenDataFile(
    HANDLE *phFile,
    LPWSTR pFile)
{
    UNICODE_STRING ObFileName;         // file name
    OBJECT_ATTRIBUTES ObjA;            // object attributes structure
    IO_STATUS_BLOCK iosb;              // IO status block
    ULONG rc = 0L;                     // return code


    //
    //  Get the NT file name.
    //
    if (rc = GetNTFileName( pFile,
                            &ObFileName ))
    {
        return (rc);
    }

    //
    //  Open the file.
    //
    InitializeObjectAttributes( &ObjA,
                                &ObFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    rc = NtOpenFile( phFile,
                     FILE_READ_DATA | SYNCHRONIZE,
                     &ObjA,
                     &iosb,
                     FILE_SHARE_READ,
                     FILE_SYNCHRONOUS_IO_NONALERT );


    //
    //  Check for error from NtOpenFile.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Open File %wZ - %lx.\n", &ObFileName, rc));
        RtlFreeHeap(RtlProcessHeap(), 0, ObFileName.Buffer);
        return (rc);
    }
    if (!NT_SUCCESS(iosb.Status))
    {
        KdPrint(("NLSAPI: Could NOT Open File %wZ - Status = %lx.\n",
                 &ObFileName, iosb.Status));
        RtlFreeHeap(RtlProcessHeap(), 0, ObFileName.Buffer);
        return ((ULONG)iosb.Status);
    }

    //
    //  Return success.
    //
    RtlFreeHeap(RtlProcessHeap(), 0, ObFileName.Buffer);
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetNTFileName
//
//  This routine returns the full path name for the data file found in
//  the given registry information buffer.
//
//  NOTE: The pFileName parameter will contain a newly allocated buffer
//        that must be freed by the caller (pFileName->buffer).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetNTFileName(
    LPWSTR pFile,
    PUNICODE_STRING pFileName)
{
    WCHAR pwszFilePath[MAX_PATH_LEN];  // ptr to file path string
    UNICODE_STRING ObFileName;         // file name
    ULONG rc = 0L;                     // return code


    //
    //  Get the full path name for the file.
    //
    if((0 == GetSystemDirectoryW(pwszFilePath, ARRAYSIZE(pwszFilePath))) ||
        FAILED(StringCchCatW(pwszFilePath, ARRAYSIZE(pwszFilePath), L"\\")) ||
        FAILED(StringCchCatW(pwszFilePath, ARRAYSIZE(pwszFilePath), pFile)))
    {
        rc = ERROR_INSUFFICIENT_BUFFER;
    }

    //
    //  Make the file name an NT path name.
    //
    RtlInitUnicodeString(&ObFileName, pwszFilePath);
    if (!RtlDosPathNameToNtPathName_U( ObFileName.Buffer,
                                       pFileName,
                                       NULL,
                                       NULL ))
    {
        KdPrint(("NLSAPI: Could NOT convert %wZ to NT path name - %lx.\n",
                 &ObFileName, rc));
        return (ERROR_FILE_NOT_FOUND);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateNlsSecurityDescriptor
//
//  This routine creates the security descriptor needed to create the
//  memory mapped section for a data file and returns the world SID.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG CreateNlsSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    UINT SecurityDescriptorSize,
    ACCESS_MASK AccessMask)
{
    ULONG rc = STATUS_SUCCESS;         // return code (positive thinking)
    PACL pAclBuffer;                   // ptr to ACL buffer
    PSID pWorldSid = NULL;             // ptr to world SID
    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_WORLD_SID_AUTHORITY;

    //
    //  Create World SID.
    //
    rc = RtlAllocateAndInitializeSid( &SidAuth,
                                      1,
                                      SECURITY_WORLD_RID,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &pWorldSid );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create SID - %lx.\n", rc));
        goto CSD_Exit;
    }
    
    //
    //  Initialize Security Descriptor.
    //
    rc = RtlCreateSecurityDescriptor( pSecurityDescriptor,
                                      SECURITY_DESCRIPTOR_REVISION );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create Security Descriptor - %lx.\n", rc));
        goto CSD_Exit;
    }

    //
    //  Initialize ACL.
    //
    pAclBuffer = (PACL)((PBYTE)pSecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);
    rc = RtlCreateAcl( (PACL)pAclBuffer,
                       SecurityDescriptorSize - SECURITY_DESCRIPTOR_MIN_LENGTH,
                       ACL_REVISION2 );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create ACL - %lx.\n", rc));
        goto CSD_Exit;
    }

    //
    //  Add an ACE to the ACL that allows World GENERIC_READ to the
    //  section object.
    //
    rc = RtlAddAccessAllowedAce( (PACL)pAclBuffer,
                                 ACL_REVISION2,
                                 AccessMask,
                                 pWorldSid );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Add Access Allowed ACE - %lx.\n", rc));
        goto CSD_Exit;
    }

    //
    //  Assign the DACL to the security descriptor.
    //
    rc = RtlSetDaclSecurityDescriptor( (PSECURITY_DESCRIPTOR)pSecurityDescriptor,
                                       (BOOLEAN)TRUE,
                                       (PACL)pAclBuffer,
                                       (BOOLEAN)FALSE );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Set DACL Security Descriptor - %lx.\n", rc));
        goto CSD_Exit;
    }

CSD_Exit:
    //
    //  Free the Sid.
    //
    if (pWorldSid) RtlFreeHeap(RtlProcessHeap(), 0, pWorldSid);

    //
    //  Return the result.
    //
    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  AppendAccessAllowedACE
//
//  This routine adds an ACE to the ACL for administrators.
//
//  03-08-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG AppendAccessAllowedACE(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ACCESS_MASK AccessMask)
{
    ULONG rc = STATUS_SUCCESS;          // return code (positive thinking)
    PACL pDaclBuffer;                  // ptr to DACL buffer
    ULONG SidLength;                   // length of SID - 2 sub authorities
    PSID pLocalSystemSid = NULL;       // ptr to local system SID
    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_NT_AUTHORITY;
    BOOLEAN DaclPresent;
    BOOLEAN DaclDefaulted;

    //
    //  Create Local System Account SID.
    //
    rc = RtlAllocateAndInitializeSid( &SidAuth,
                                      1,
                                      SECURITY_LOCAL_SYSTEM_RID,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &pLocalSystemSid );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create SID - %lx.\n", rc));
        goto AAA_EXIT;
    }

    //
    //  Get DACL.
    //
    rc = RtlGetDaclSecurityDescriptor( pSecurityDescriptor,
                                       &DaclPresent,
                                       &pDaclBuffer,
                                       &DaclDefaulted );
    if (!NT_SUCCESS(rc) || !pDaclBuffer || !DaclPresent)
    {
        KdPrint(("NLSAPI: Could NOT Get DACL Security Descriptor - %lx.\n", rc));
        goto AAA_EXIT;
    }

    //
    //  Add an ACE to the ACL that allows Admin query access to the
    //  section object.
    //
    rc = RtlAddAccessAllowedAce( (PACL)pDaclBuffer,
                                 ACL_REVISION2,
                                 AccessMask,
                                 pLocalSystemSid );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Add Access Allowed ACE - %lx.\n", rc));
        goto AAA_EXIT;
    }

AAA_EXIT:
    //
    //  Free SID.
    //
    if (pLocalSystemSid) RtlFreeHeap(RtlProcessHeap(), 0, pLocalSystemSid);

    //
    //  Return condition.
    //
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\sources.inc ===
MAJORCOMP = nlsapi

TARGETNAME = nlslib
TARGETPATH = obj
TARGETTYPE = LIBRARY

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL = /W3
!ENDIF
MSC_WARNING_LEVEL = $(MSC_WARNING_LEVEL) /WX

C_DEFINES = $(C_DEFINES) -DUNICODE -D_KERNEL32_

INCLUDES = ..\..\inc;$(WINDOWS_INC_PATH)

SOURCES = ..\ansi.c       \
          ..\csrlocal.c   \
          ..\csrtables.c  \
          ..\datetime.c   \
          ..\enum.c       \
          ..\geo.c        \
          ..\init.c       \
          ..\jamo.c	  \
          ..\locale.c     \
          ..\map.c        \
          ..\mbcs.c       \
          ..\number.c     \
          ..\section.c    \
          ..\string.c     \
          ..\tables.c     \
          ..\utf.c        \
          ..\util.c       \
          ..\security.c

# No overflow checking for kernel32.dll
BUFFER_OVERFLOW_CHECKS=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\utf.h ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    utf.h

Abstract:

    This file contains the header information for the UTF module of NLS.

Revision History:

    02-06-96    JulieB    Created.

--*/



//
//  Constant Declarations.
//

#define ASCII                 0x007f

#define SHIFT_IN              '+'     // beginning of a shift sequence
#define SHIFT_OUT             '-'     // end       of a shift sequence

#define UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL            0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)       ((u) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)        ((u) & 0x003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff

/////////////////////////
//                     //
//  Unicode -> UTF-7   //
//                     //
/////////////////////////

//
//  Convert one Unicode to 2 2/3 Base64 chars in a shifted sequence.
//  Each char represents a 6-bit portion of the 16-bit Unicode char.
//
CONST char cBase64[] =

  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"  // A : 000000 .... 011001  ( 0 - 25)
  "abcdefghijklmnopqrstuvwxyz"  // a : 011010 .... 110011  (26 - 51)
  "0123456789"                  // 0 : 110100 .... 111101  (52 - 61)
  "+/";                         // + : 111110, / : 111111  (62 - 63)

//
//  To determine if an ASCII char needs to be shifted.
//    1 :     to be shifted
//    0 : not to be shifted
//
CONST BOOLEAN fShiftChar[] =
{
  0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1,    // Null, Tab, LF, CR
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,    // Space '() +,-./
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,    // 0123456789:    ?
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  ABCDEFGHIJKLMNO
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,    // PQRSTUVWXYZ
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  abcdefghijklmno
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1     // pqrstuvwxyz
};




/////////////////////////
//                     //
//  UTF-7 -> Unicode   //
//                     //
/////////////////////////

//
//  Convert a Base64 char in a shifted sequence to a 6-bit portion of a
//  Unicode char.
//  -1 means it is not a Base64
//
CONST char nBitBase64[] =
{
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,   //            +   /
  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,   // 0123456789
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,   //  ABCDEFGHIJKLMNO
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,   // PQRSTUVWXYZ
  -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,   //  abcdefghijklmno
  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1    // pqrstuvwxyz
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\tables.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    tables.c

Abstract:

    This file contains functions that manipulate or return information
    about the different tables used by the NLS API.

    External Routines found in this file:
      AllocTables
      GetUnicodeFileInfo
      GetGeoFileInfo
      GetCTypeFileInfo
      GetDefaultSortkeyFileInfo
      GetDefaultSortTablesFileInfo
      GetSortkeyFileInfo
      GetSortTablesFileInfo
      GetCodePageFileInfo
      GetLanguageFileInfo
      GetLocaleFileInfo
      MakeCPHashNode
      MakeLangHashNode
      MakeLocHashNode
      GetCPHashNode
      GetLangHashNode
      GetLocHashNode
      GetCalendar

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"




//
//  Constant Declarations.
//

#define SEM_NOERROR   (SEM_FAILCRITICALERRORS |     \
                       SEM_NOGPFAULTERRORBOX  |     \
                       SEM_NOOPENFILEERRORBOX)



//
//  Global Variables.
//

PTBL_PTRS  pTblPtrs;              // ptr to structure of table ptrs




//
//  Forward Declarations.
//

BOOL
IsValidSortId(
    LCID Locale);

ULONG
GetLanguageExceptionInfo(void);

LPWORD
GetLinguisticLanguageInfo(
    LCID Locale);

ULONG
CreateAndCopyLanguageExceptions(
    LCID Locale,
    LPWORD *ppBaseAddr);

BOOL FASTCALL
FindLanguageExceptionPointers(
    LCID Locale,
    PL_EXCEPT_HDR *ppExceptHdr,
    PL_EXCEPT *ppExceptTbl);

void FASTCALL
CopyLanguageExceptionInfo(
    LPWORD pBaseAddr,
    PL_EXCEPT_HDR pExceptHdr,
    PL_EXCEPT pExceptTbl);

BOOL FASTCALL
FindExceptionPointers(
    LCID Locale,
    PEXCEPT_HDR *ppExceptHdr,
    PEXCEPT *ppExceptTbl,
    PVOID *ppIdeograph,
    PULONG pReturn);

void FASTCALL
CopyExceptionInfo(
    PSORTKEY pSortkey,
    PEXCEPT_HDR pExceptHdr,
    PEXCEPT pExceptTbl,
    PVOID pIdeograph);

ULONG
WaitOnEvent(
    LPWORD pSem);





//-------------------------------------------------------------------------//
//                           INTERNAL MACROS                               //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GET_HASH_VALUE
//
//  Returns the hash value for given value and the given table size.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_HASH_VALUE(Value, TblSize)      (Value % TblSize)


////////////////////////////////////////////////////////////////////////////
//
//  CREATE_CODEPAGE_HASH_NODE
//
//  Creates a code page hash node and stores the pointer to it in pHashN.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CREATE_CODEPAGE_HASH_NODE( CodePage,                               \
                                   pHashN )                                \
{                                                                          \
    /*                                                                     \
     *  Allocate CP_HASH structure.                                        \
     */                                                                    \
    if ((pHashN = (PCP_HASH)NLS_ALLOC_MEM(sizeof(CP_HASH))) == NULL)       \
    {                                                                      \
        return (ERROR_OUTOFMEMORY);                                        \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Fill in the CodePage value.                                        \
     */                                                                    \
    pHashN->CodePage = CodePage;                                           \
                                                                           \
    /*                                                                     \
     *   Make sure the pfnCPProc value is NULL for now.                    \
     */                                                                    \
    pHashN->pfnCPProc = NULL;                                              \
}


////////////////////////////////////////////////////////////////////////////
//
//  CREATE_LOCALE_HASH_NODE
//
//  Creates a locale hash node and stores the pointer to it in pHashN.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CREATE_LOCALE_HASH_NODE( Locale,                                   \
                                 pHashN )                                  \
{                                                                          \
    /*                                                                     \
     *  Allocate LOC_HASH structure.                                       \
     */                                                                    \
    if ((pHashN = (PLOC_HASH)NLS_ALLOC_MEM(sizeof(LOC_HASH))) == NULL)     \
    {                                                                      \
        return (ERROR_OUTOFMEMORY);                                        \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Fill in the Locale value.                                          \
     */                                                                    \
    pHashN->Locale = Locale;                                               \
}


////////////////////////////////////////////////////////////////////////////
//
//  FIND_CP_HASH_NODE
//
//  Searches for the cp hash node for the given locale.  The result is
//  put in pHashN.  If no node exists, pHashN will be NULL.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define FIND_CP_HASH_NODE( CodePage,                                       \
                           pHashN )                                        \
{                                                                          \
    UINT Index;                   /* hash value */                         \
                                                                           \
    /*                                                                     \
     *  Get hash value.                                                    \
     */                                                                    \
    Index = GET_HASH_VALUE(CodePage, CP_TBL_SIZE);                         \
                                                                           \
    /*                                                                     \
     *  Make sure the hash node still doesn't exist in the table.          \
     */                                                                    \
    pHashN = (pTblPtrs->pCPHashTbl)[Index];                                \
    while ((pHashN != NULL) && (pHashN->CodePage != CodePage))             \
    {                                                                      \
        pHashN = pHashN->pNext;                                            \
    }                                                                      \
}

////////////////////////////////////////////////////////////////////////////
//
//  IsCPHashNodeLoaded
//
//  Wrapper for the FIND_CP_HASH_NODE macro so that we can call this from
//  mbcs.c.  Return TRUE if the node already exists, otherwise false.  False
//  could still indicate a valid code page, just not one already loaded.
//
//  05-31-02    ShawnSte    Created.
////////////////////////////////////////////////////////////////////////////
BOOL IsCPHashNodeLoaded( UINT CodePage )
{
    PCP_HASH pHashN;              // ptr to CP hash node

    //
    //  Get hash node.
    //
    FIND_CP_HASH_NODE(CodePage, pHashN);

    return (pHashN != NULL);
}

////////////////////////////////////////////////////////////////////////////
//
//  FIND_LOCALE_HASH_NODE
//
//  Searches for the locale hash node for the given locale.  The result is
//  put in pHashN.  If no node exists, pHashN will be NULL.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define FIND_LOCALE_HASH_NODE( Locale,                                     \
                               pHashN )                                    \
{                                                                          \
    UINT Index;                   /* hash value */                         \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Get hash value.                                                    \
     */                                                                    \
    Index = GET_HASH_VALUE(Locale, LOC_TBL_SIZE);                          \
                                                                           \
    /*                                                                     \
     *  Get hash node.                                                     \
     */                                                                    \
    pHashN = (pTblPtrs->pLocHashTbl)[Index];                               \
    while ((pHashN != NULL) && (pHashN->Locale != Locale))                 \
    {                                                                      \
        pHashN = pHashN->pNext;                                            \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  EXIST_LANGUAGE_INFO
//
//  Checks to see if the casing tables have been added to the locale
//  hash node.
//
//  Must check the LOWER CASE pointer, since that value is set last in
//  the hash node.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define EXIST_LANGUAGE_INFO(pHashN)         (pHashN->pLowerCase)


////////////////////////////////////////////////////////////////////////////
//
//  EXIST_LINGUIST_LANGUAGE_INFO
//
//  Checks to see if the linguistic casing tables have been added to the locale
//  hash node.
//
//  Must check the LOWER CASE pointer, since that value is set last in
//  the hash node.
//
//  DEFINED AS A MACRO.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define EXIST_LINGUIST_LANGUAGE_INFO(pHashN)  (pHashN->pLowerLinguist)


////////////////////////////////////////////////////////////////////////////
//
//  EXIST_LOCALE_INFO
//
//  Checks to see if the locale tables have been added to the locale
//  hash node.
//
//  Must check the FIXED locale pointer, since that value is set last in
//  the hash node.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define EXIST_LOCALE_INFO(pHashN)           (pHashN->pLocaleFixed)


////////////////////////////////////////////////////////////////////////////
//
//  INSERT_CP_HASH_NODE
//
//  Inserts a CP hash node into the global CP hash table.  It assumes that
//  all unused hash values in the table are pointing to NULL.  If there is
//  a collision, the new node will be added FIRST in the list.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define INSERT_CP_HASH_NODE( pHashN,                                       \
                             pBaseAddr )                                   \
{                                                                          \
    UINT Index;                   /* hash value */                         \
    PCP_HASH pSearch;             /* ptr to CP hash node for search */     \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Get hash value.                                                    \
     */                                                                    \
    Index = GET_HASH_VALUE(pHashN->CodePage, CP_TBL_SIZE);                 \
                                                                           \
    /*                                                                     \
     *  Enter table pointers critical section.                             \
     */                                                                    \
    RtlEnterCriticalSection(&gcsTblPtrs);                                  \
                                                                           \
    /*                                                                     \
     *  Make sure the hash node still doesn't exist in the table.          \
     */                                                                    \
    pSearch = (pTblPtrs->pCPHashTbl)[Index];                               \
    while ((pSearch != NULL) && (pSearch->CodePage != pHashN->CodePage))   \
    {                                                                      \
        pSearch = pSearch->pNext;                                          \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  If the hash node does not exist, insert the new one.               \
     *  Otherwise, free it.                                                \
     */                                                                    \
    if (pSearch == NULL)                                                   \
    {                                                                      \
        /*                                                                 \
         *  Insert hash node into hash table.                              \
         */                                                                \
        pHashN->pNext = (pTblPtrs->pCPHashTbl)[Index];                     \
        (pTblPtrs->pCPHashTbl)[Index] = pHashN;                            \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Free the resources allocated.                                  \
         */                                                                \
        if (pBaseAddr)                                                     \
        {                                                                  \
            UnMapSection(pBaseAddr);                                       \
        }                                                                  \
        NLS_FREE_MEM(pHashN);                                              \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Leave table pointers critical section.                             \
     */                                                                    \
    RtlLeaveCriticalSection(&gcsTblPtrs);                                  \
}


////////////////////////////////////////////////////////////////////////////
//
//  INSERT_LOC_HASH_NODE
//
//  Inserts a LOC hash node into the global LOC hash table.  It assumes
//  that all unused hash values in the table are pointing to NULL.  If
//  there is a collision, the new node will be added FIRST in the list.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define INSERT_LOC_HASH_NODE( pHashN,                                      \
                              pBaseAddr )                                  \
{                                                                          \
    UINT Index;                   /* hash value */                         \
    PLOC_HASH pSearch;            /* ptr to LOC hash node for search */    \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Get hash value.                                                    \
     */                                                                    \
    Index = GET_HASH_VALUE(pHashN->Locale, LOC_TBL_SIZE);                  \
                                                                           \
    /*                                                                     \
     *  Enter table pointers critical section.                             \
     */                                                                    \
    RtlEnterCriticalSection(&gcsTblPtrs);                                  \
                                                                           \
    /*                                                                     \
     *  Make sure the hash node still doesn't exist in the table.          \
     */                                                                    \
    pSearch = (pTblPtrs->pLocHashTbl)[Index];                              \
    while ((pSearch != NULL) && (pSearch->Locale != pHashN->Locale))       \
    {                                                                      \
        pSearch = pSearch->pNext;                                          \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  If the hash node does not exist, insert the new one.               \
     *  Otherwise, free it.                                                \
     */                                                                    \
    if (pSearch == NULL)                                                   \
    {                                                                      \
        /*                                                                 \
         *  Insert hash node into hash table.                              \
         */                                                                \
        pHashN->pNext = (pTblPtrs->pLocHashTbl)[Index];                    \
        (pTblPtrs->pLocHashTbl)[Index] = pHashN;                           \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Free the resources allocated.                                  \
         */                                                                \
        if (pBaseAddr)                                                     \
        {                                                                  \
            UnMapSection(pBaseAddr);                                       \
        }                                                                  \
        if ((pHashN->pSortkey != pTblPtrs->pDefaultSortkey) &&             \
            (pHashN->pSortkey != NULL))                                    \
        {                                                                  \
            UnMapSection(((LPWORD)(pHashN->pSortkey)) - SORTKEY_HEADER);   \
        }                                                                  \
        NLS_FREE_MEM(pHashN);                                              \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Leave table pointers critical section.                             \
     */                                                                    \
    RtlLeaveCriticalSection(&gcsTblPtrs);                                  \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_CP_SECTION_NAME
//
//  Gets the section name for a given code page.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_CP_SECTION_NAME( CodePage,                                     \
                             pwszSecName,                                  \
                             cchSecName,                                   \
                             pObSecName )                                  \
{                                                                          \
    if (rc = GetNlsSectionName( CodePage,                                  \
                                10,                                        \
                                0,                                         \
                                NLS_SECTION_CPPREFIX,                      \
                                pwszSecName,                               \
                                cchSecName))                               \
    {                                                                      \
        return (rc);                                                       \
    }                                                                      \
    RtlInitUnicodeString(pObSecName, pwszSecName);                         \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_SORTKEY_SECTION_NAME
//
//  Gets the sortkey section name for a given locale.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_SORTKEY_SECTION_NAME( Locale,                                  \
                                  pwszSecName,                             \
                                  cchSecName,                              \
                                  pObSecName )                             \
{                                                                          \
    if (rc = GetNlsSectionName( Locale,                                    \
                                16,                                        \
                                8,                                         \
                                NLS_SECTION_SORTKEY,                       \
                                pwszSecName,                               \
                                cchSecName))                               \
    {                                                                      \
        return (rc);                                                       \
    }                                                                      \
    RtlInitUnicodeString(pObSecName, pwszSecName);                         \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_LANG_SECTION_NAME
//
//  Gets the section name for a given language.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_LANG_SECTION_NAME( Locale,                                     \
                               pwszSecName,                                \
                               cchSecName,                                 \
                               pObSecName )                                \
{                                                                          \
    if (rc = GetNlsSectionName( Locale,                                    \
                                16,                                        \
                                8,                                         \
                                NLS_SECTION_LANGPREFIX,                    \
                                pwszSecName,                               \
                                cchSecName))                               \
    {                                                                      \
        return (rc);                                                       \
    }                                                                      \
    RtlInitUnicodeString(pObSecName, pwszSecName);                         \
}




//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  AllocTables
//
//  Allocates the global table pointers structure.  It then allocates the
//  code page and locale hash tables and saves the pointers to the tables
//  in the global table pointers structure.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG AllocTables()
{
    //
    //  Allocate global table pointers structure.
    //
    if ((pTblPtrs = (PTBL_PTRS)NLS_ALLOC_MEM(sizeof(TBL_PTRS))) == NULL)
    {
        KdPrint(("NLSAPI: Allocation for TABLE PTRS structure FAILED.\n"));
        return (ERROR_OUTOFMEMORY);
    }

    //
    //  Allocate code page hash table.
    //
    if ((pTblPtrs->pCPHashTbl =
         (PCP_HASH_TBL)NLS_ALLOC_MEM(sizeof(PCP_HASH) * CP_TBL_SIZE)) == NULL)
    {
        KdPrint(("NLSAPI: Allocation for CODE PAGE hash table FAILED.\n"));
        return (ERROR_OUTOFMEMORY);
    }

    //
    //  Allocate locale hash table.
    //
    if ((pTblPtrs->pLocHashTbl =
         (PLOC_HASH_TBL)NLS_ALLOC_MEM(sizeof(PLOC_HASH) * LOC_TBL_SIZE)) == NULL)
    {
        KdPrint(("NLSAPI: Allocation for LOCALE hash table FAILED.\n"));
        return (ERROR_OUTOFMEMORY);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUnicodeFileInfo
//
//  Opens and Maps a view of the section for the unicode file.  It then
//  fills in the appropriate fields of the global table pointers structure.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetUnicodeFileInfo()
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    ULONG rc = 0L;                // return code

    WORD offCZ;                   // offset to FOLDCZONE table
    WORD offHG;                   // offset to HIRAGANA table
    WORD offKK;                   // offset to KATAKANA table
    WORD offHW;                   // offset to HALFWIDTH table
    WORD offFW;                   // offset to FULLWIDTH table
    WORD offTR;                   // offset to TRADITIONAL table
    WORD offSP;                   // offset to SIMPLIFIED table
    WORD offPre;                  // offset to PRECOMPOSED table
    WORD offComp;                 // offset to COMPOSITE table
    PCOMP_INFO pComp;             // ptr to COMP_INFO structure


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Make sure the unicode information is not already there.
    //  If it is, return success.
    //
    //  Since we're already in the critical section here, there is no
    //  need to check ALL of the pointers set in this routine.  Just
    //  check one of them.
    //
    if (pTblPtrs->pADigit != NULL)
    {
        return (NO_ERROR);
    }

    //
    //  Open and Map a view of the section.
    //
    ObSecName.Buffer = NLS_SECTION_UNICODE;
    ObSecName.Length = sizeof (NLS_SECTION_UNICODE) - sizeof (WCHAR);
    ObSecName.MaximumLength = ObSecName.Length;
    
    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          TRUE ))
    {
        return (rc);
    }

    //
    //  Get the offsets.
    //
    offCZ   = pBaseAddr[0];
    offHG   = offCZ  + pBaseAddr[offCZ];
    offKK   = offHG  + pBaseAddr[offHG];
    offHW   = offKK  + pBaseAddr[offKK];
    offFW   = offHW  + pBaseAddr[offHW];
    offTR   = offFW  + pBaseAddr[offFW];
    offSP   = offTR  + pBaseAddr[offTR];
    offPre  = offSP  + pBaseAddr[offSP];
    offComp = offPre + pBaseAddr[offPre];

    //
    //  Allocate COMP_INFO structure.
    //
    if ((pComp = (PCOMP_INFO)NLS_ALLOC_MEM(sizeof(COMP_INFO))) == NULL)
    {
        return (ERROR_OUTOFMEMORY);
    }

    //
    //  Fill in the COMPOSITE information.
    //
    pComp->NumBase  = LOBYTE((pBaseAddr + offComp)[2]);
    pComp->NumNonSp = HIBYTE((pBaseAddr + offComp)[2]);
    pComp->pBase    = pBaseAddr + offComp + CO_HEADER;
    pComp->pNonSp   = pComp->pBase  + ((pBaseAddr + offComp)[0]);
    pComp->pGrid    = pComp->pNonSp + ((pBaseAddr + offComp)[1]);

    //
    //  Attach ASCIIDIGITS table to tbl ptrs structure.
    //
    pTblPtrs->pADigit = pBaseAddr + AD_HEADER;

    //
    //  Attach FOLDCZONE table to tbl ptrs structure.
    //
    pTblPtrs->pCZone = pBaseAddr + offCZ + CZ_HEADER;

    //
    //  Attach HIRAGANA table to tbl ptrs structure.
    //
    pTblPtrs->pHiragana = pBaseAddr + offHG + HG_HEADER;

    //
    //  Attach KATAKANA table to tbl ptrs structure.
    //
    pTblPtrs->pKatakana = pBaseAddr + offKK + KK_HEADER;

    //
    //  Attach HALFWIDTH table to tbl ptrs structure.
    //
    pTblPtrs->pHalfWidth = pBaseAddr + offHW + HW_HEADER;

    //
    //  Attach FULLWIDTH table to tbl ptrs structure.
    //
    pTblPtrs->pFullWidth = pBaseAddr + offFW + FW_HEADER;

    //
    //  Attach TRADITIONAL table to tbl ptrs structure.
    //
    pTblPtrs->pTraditional = pBaseAddr + offTR + TR_HEADER;

    //
    //  Attach SIMPLIFIED table to tbl ptrs structure.
    //
    pTblPtrs->pSimplified = pBaseAddr + offSP + SP_HEADER;

    //
    //  Attach PRECOMPOSED table to tbl ptrs structure.
    //
    pTblPtrs->pPreComposed = pBaseAddr + offPre + PC_HEADER;

    //
    //  Attach COMP_INFO to tbl ptrs structure.
    //
    pTblPtrs->pComposite = pComp;

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetGeoFileInfo
//
//  Opens and Maps a view of the section for the geo file.  It then
//  fills in the appropriate field of the global table pointers structure.
//  Before calling this function you should check pGeoInfo member.
//
////////////////////////////////////////////////////////////////////////////

ULONG GetGeoFileInfo()
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    ULONG rc = NO_ERROR;          // return code

    //
    //  Enter the critical section to set up the GEO tables.
    //
    RtlEnterCriticalSection(&gcsTblPtrs);

    //
    //  Make sure the Geographical Information table is
    //  not already there. If it is, return TRUE.
    //
    //  Since we're already in the critical section here, there is no
    //  need to check ALL of the pointers set in this routine.  Just
    //  check one of them.
    //
    if (pTblPtrs->pGeoInfo != NULL)
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (NO_ERROR);
    }

    //
    //  Create and map the section, and then save the pointer.
    //
    if ((rc = CsrBasepNlsCreateSection(NLS_CREATE_SECTION_GEO, 0, &hSec)) == NO_ERROR)
    {
        //
        //  Map a View of the Section.
        //
        if ((rc = MapSection( hSec,
                              &pBaseAddr,
                              PAGE_READONLY,
                              TRUE )) != NO_ERROR)
        {
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (rc);
        }
    }
    else
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Attach GeoInfo mapping table, GEO/LCID mapping table and
    //  GEO/ISO639 name mapping table to the tbl ptrs structure. We initialize
    //  the pGeoinfo member at the end so we don't get a race condition.
    //
    pTblPtrs->nGeoLCID = ((PGEOTABLEHDR)pBaseAddr)->nGeoLCID;
    pTblPtrs->pGeoLCID = (PGEOLCID)((PBYTE)pBaseAddr + ((PGEOTABLEHDR)pBaseAddr)->dwOffsetGeoLCID);
    pTblPtrs->nGeoInfo = ((PGEOTABLEHDR)pBaseAddr)->nGeoInfo;
    pTblPtrs->pGeoInfo = (PGEOINFO)((PBYTE)pBaseAddr + ((PGEOTABLEHDR)pBaseAddr)->dwOffsetGeoInfo);

    //
    //  Leave table pointers critical section.
    //
    RtlLeaveCriticalSection(&gcsTblPtrs);

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCTypeFileInfo
//
//  Opens and Maps a view of the section for the given ctype.  It then
//  fills in the appropriate field of the global table pointers structure.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetCTypeFileInfo()
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    ULONG rc = 0L;                // return code


    //
    //  Make sure the ctype information is not already there.
    //  If it is, return success.
    //
    //  Must check the 844 table rather than the mapping table, since
    //  the 844 table is set AFTER the mapping table below.  Otherwise,
    //  there is a race condition, since we're not in a critical section.
    //
    if (pTblPtrs->pCType844 != NULL)
    {
        return (NO_ERROR);
    }

    //
    //  Enter table pointers critical section.
    //
    RtlEnterCriticalSection(&gcsTblPtrs);
    if (pTblPtrs->pCType844 != NULL)
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (NO_ERROR);
    }

    //
    //  Open and Map a view of the section.
    //
    RtlInitUnicodeString(&ObSecName, NLS_SECTION_CTYPE);
    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          TRUE ))
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Attach CTYPE mapping table and 8:4:4 table to tbl ptrs structure.
    //
    //  The pCType844 value must be set LAST, since this is the pointer
    //  that is checked to see that the ctype information has been
    //  initialized.
    //
    pTblPtrs->pCTypeMap = (PCT_VALUES)(pBaseAddr + CT_HEADER);
    pTblPtrs->pCType844 = (PCTYPE)((LPBYTE)(pBaseAddr + 1) +
                                   ((PCTYPE_HDR)pBaseAddr)->MapSize);

    //
    //  Leave table pointers critical section.
    //
    RtlLeaveCriticalSection(&gcsTblPtrs);

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDefaultSortkeyFileInfo
//
//  Opens and Maps a view of the section for the default sortkey table.  It
//  then stores the pointer to the table in the global pointer table.
//
//  NOTE: THIS ROUTINE SHOULD ONLY BE CALLED AT PROCESS STARTUP.  If it is
//        called from other than process startup, a critical section must
//        be placed around the assigning of the pointers to pTblPtrs.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetDefaultSortkeyFileInfo()
{
    HANDLE hSec = (HANDLE)0;           // section handle
    UNICODE_STRING ObSecName;          // section name
    LPWORD pBaseAddr;                  // ptr to base address of section
    ULONG rc = 0L;                     // return code
    SECTION_BASIC_INFORMATION SecInfo; // section information - query


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Open and Map a view of the section if it hasn't been done yet.
    //
    if (pTblPtrs->pDefaultSortkey != NULL)
    {
        return (NO_ERROR);
    }

    ObSecName.Buffer = NLS_SECTION_SORTKEY;
    ObSecName.Length = sizeof (NLS_SECTION_SORTKEY) - sizeof (WCHAR);
    ObSecName.MaximumLength = ObSecName.Length;
    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ | SECTION_QUERY,
                          FALSE ))
    {
        KdPrint(("NLSAPI: Could NOT Open Section %wZ - %lx.\n", &ObSecName, rc));
        return (rc);
    }

    //
    //  Query size of default section.
    //
    rc = NtQuerySection( hSec,
                         SectionBasicInformation,
                         &SecInfo,
                         sizeof(SecInfo),
                         NULL );

    //
    //   Close the section handle.
    //
    NtClose(hSec);

    //
    //  Check for error from NtQuerySection.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Query Section %wZ - %lx.\n", &ObSecName, rc));
        return (rc);
    }

    //
    //  Get Default Sortkey Information.
    //
    pTblPtrs->pDefaultSortkey = (PSORTKEY)(pBaseAddr + SORTKEY_HEADER);
    pTblPtrs->DefaultSortkeySize = SecInfo.MaximumSize;

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDefaultSortTablesFileInfo
//
//  Opens and Maps a view of the section for the sort tables.  It then
//  stores the pointers to the various tables in the global pointer table.
//
//  NOTE: THIS ROUTINE SHOULD ONLY BE CALLED AT PROCESS STARTUP.  If it is
//        called from other than process startup, a critical section must
//        be placed around the assigning of the pointers to pTblPtrs.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetDefaultSortTablesFileInfo()
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // word ptr to base address of section
    DWORD Num;                    // number of entries in table
    PCOMPRESS_HDR pCompressHdr;   // ptr to compression header
    PEXCEPT_HDR pExceptHdr;       // ptr to exception header
    ULONG rc = 0L;                // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Open and Map a view of the section if it hasn't been done yet.
    //
    //  Since we're already in the critical section here, there is no
    //  need to check ALL of the pointers set in this routine.  Just
    //  check one of them.
    //
    if (pTblPtrs->pReverseDW != NULL)
    {
        return (NO_ERROR);
    }

    ObSecName.Buffer = NLS_SECTION_SORTTBLS;
    ObSecName.Length = sizeof (NLS_SECTION_SORTTBLS) - sizeof (WCHAR);
    ObSecName.MaximumLength = ObSecName.Length;

    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          TRUE ))
    {
        return (rc);
    }

    pTblPtrs->pSortingTableFileBase = pBaseAddr;
    
    //
    //  Get Defined Code Point version Information.
    //
    pTblPtrs->NumDefinedVersion = Num = *((LPDWORD)pBaseAddr);
    pBaseAddr += NLSDEFINED_HEADER;
    if (Num > 0)
    {
        pTblPtrs->pDefinedVersion = (PDEFVERINFO)pBaseAddr;        
        pBaseAddr += Num * sizeof(DEFVERINFO)/sizeof(WORD);
    } 
    else 
    {
        KdPrint(("NLSAPI: Appropriate Defined Code Point Table Not Loaded.\n"));
        pTblPtrs->pDefinedVersion = NULL;
    }
    
    //
    //  Get Sorting Version Information.
    //
    if ((pTblPtrs->NumSortVersion = *((LPDWORD)pBaseAddr)) > 0)
    {
        pTblPtrs->pSortVersion   = (PSORTVERINFO)(pBaseAddr + SORTVERINFO_HEADER);
    } else
    {
        pTblPtrs->pSortVersion = NULL;
    }
    pBaseAddr += SORTVERINFO_HEADER + (pTblPtrs->NumSortVersion * (sizeof(SORTVERINFO) / sizeof(WORD)));

    //
    //  Get Reverse Diacritic Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumReverseDW   = Num;
        pTblPtrs->pReverseDW     = (PREVERSE_DW)(pBaseAddr + REV_DW_HEADER);
    }
    pBaseAddr += REV_DW_HEADER + (Num * (sizeof(REVERSE_DW) / sizeof(WORD)));

    //
    //  Get Double Compression Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumDblCompression = Num;
        pTblPtrs->pDblCompression   = (PDBL_COMPRESS)(pBaseAddr + DBL_COMP_HEADER);
    }
    pBaseAddr += DBL_COMP_HEADER + (Num * (sizeof(DBL_COMPRESS) / sizeof(WORD)));

    //
    //  Get Ideograph Lcid Exception Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumIdeographLcid = Num;
        pTblPtrs->pIdeographLcid   = (PIDEOGRAPH_LCID)(pBaseAddr + IDEO_LCID_HEADER);
    }
    pBaseAddr += IDEO_LCID_HEADER + (Num * (sizeof(IDEOGRAPH_LCID) / sizeof(WORD)));

    //
    //  Get Expansion Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumExpansion   = Num;
        pTblPtrs->pExpansion     = (PEXPAND)(pBaseAddr + EXPAND_HEADER);
    }
    pBaseAddr += EXPAND_HEADER + (Num * (sizeof(EXPAND) / sizeof(WORD)));

    //
    //  Get Compression Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumCompression = Num;
        pTblPtrs->pCompressHdr   = (PCOMPRESS_HDR)(pBaseAddr + COMPRESS_HDR_OFFSET);
        pTblPtrs->pCompression   = (PCOMPRESS)(pBaseAddr + COMPRESS_HDR_OFFSET +
                                     (Num * (sizeof(COMPRESS_HDR) /
                                             sizeof(WORD))));
    }
    pCompressHdr = pTblPtrs->pCompressHdr;
    pBaseAddr = (LPWORD)(pTblPtrs->pCompression) +
                        (pCompressHdr[Num - 1]).Offset;

    pBaseAddr += (((pCompressHdr[Num - 1]).Num2) *
                  (sizeof(COMPRESS_2) / sizeof(WORD)));

    pBaseAddr += (((pCompressHdr[Num - 1]).Num3) *
                  (sizeof(COMPRESS_3) / sizeof(WORD)));

    //
    //  Get Exception Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumException = Num;
        pTblPtrs->pExceptHdr   = (PEXCEPT_HDR)(pBaseAddr + EXCEPT_HDR_OFFSET);
        pTblPtrs->pException   = (PEXCEPT)(pBaseAddr + EXCEPT_HDR_OFFSET +
                                   (Num * (sizeof(EXCEPT_HDR) /
                                           sizeof(WORD))));
    }
    pExceptHdr = pTblPtrs->pExceptHdr;
    pBaseAddr = (LPWORD)(pTblPtrs->pException) +
                        (pExceptHdr[Num - 1]).Offset;
    pBaseAddr += (((pExceptHdr[Num - 1]).NumEntries) *
                  (sizeof(EXCEPT) / sizeof(WORD)));

    //
    //  Get Multiple Weights Information.
    //
    Num = (DWORD)(*pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumMultiWeight = Num;
        pTblPtrs->pMultiWeight   = (PMULTI_WT)(pBaseAddr + MULTI_WT_HEADER);
    }
    pBaseAddr += MULTI_WT_HEADER + (Num * (sizeof(MULTI_WT) / sizeof(WORD)));

    //
    //  Get Jamo Index Table.
    //
    Num = (DWORD)(*pBaseAddr);
    if (Num > 0)
    {
        //
        //  The Jamo Index table size is (Num) bytes.
        //
        pTblPtrs->NumJamoIndex = Num;
        pTblPtrs->pJamoIndex = (PJAMO_TABLE)(pBaseAddr + JAMO_INDEX_HEADER);
    }
    pBaseAddr += JAMO_INDEX_HEADER + (Num * (sizeof(JAMO_TABLE) / sizeof(WORD)));

    //
    //  Get Jamo Composition State Machine Table.
    //
    Num = (DWORD)(*pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumJamoComposition = Num;
        pTblPtrs->pJamoComposition = (PJAMO_COMPOSE_STATE)(pBaseAddr + JAMO_COMPOSITION_HEADER);
    }
    //
    //  The following line is used to move pBaseAddr to the next field.
    //  Uncomment it if you are adding more fields.
    //
    //  pBaseAddr += JAMO_COMPOSITION_HEADER + (Num * (sizeof(JAMO_COMPOSE_STATE) / sizeof(WORD)));

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetSortkeyFileInfo
//
//  Opens and Maps a view of the section for the sortkey file.  It then
//  fills in the appropriate field of the global table pointers structure.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetSortkeyFileInfo(
    LCID Locale,
    PLOC_HASH pHashN)
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    ULONG rc = 0L;                // return code

    PEXCEPT_HDR pExceptHdr;       // ptr to exception header
    PEXCEPT pExceptTbl;           // ptr to exception table
    PVOID pIdeograph;             // ptr to ideograph exception table

    WCHAR wszSecName[MAX_SMALL_BUF_LEN];      // Place for the section name string                                                                          \

    NTSTATUS Status;

    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Make sure the default sortkey table is loaded.  If it's not, then
    //  we shouldn't bother to continue here since the sorting table won't
    //  be created properly.  pHashN->pSortkey will already be NULL, so
    //  we don't need to set it.  Return NO_ERROR here to allow kernel32
    //  to initialize in case this is winlogon.
    //
    if (pTblPtrs->pDefaultSortkey == NULL)
    {
        KdPrint(("NLSAPI: No Default Sorting Table Loaded.\n"));
        return (NO_ERROR);
    }

    //
    //  Try to Open and Map a view of the section (read only).
    //
    GET_SORTKEY_SECTION_NAME(Locale, wszSecName, MAX_SMALL_BUF_LEN, &ObSecName);

    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          FALSE ))
    {
        //
        //  Open failed.
        //  See if any exceptions exist for given Locale ID.
        //
        rc = NO_ERROR;
        if (!FindExceptionPointers( Locale,
                                    &pExceptHdr,
                                    &pExceptTbl,
                                    &pIdeograph,
                                    &rc ))
        {
            //
            //  No exceptions for locale, so attach the default sortkey
            //  table pointer to the hash node and return success.
            //
            pHashN->pSortkey = pTblPtrs->pDefaultSortkey;
            return (NO_ERROR);
        }
        else
        {
            //
            //  See if an error occurred.
            //
            if (rc != NO_ERROR)
            {
                //
                //  This occurs if the ideograph exception file could not be
                //  created or mapped.  Return an error in this case.
                //
                //  return (rc);
                //
                //  On second thought, don't return an error.  Returning an
                //  error can cause kernel32 to not initialize (which, if this
                //  is winlogon, leads to an unbootable system).  Let's just
                //  patch things up and move on.
                //
                //  LATER -- log an error in the logfile.
                //
                pHashN->IfIdeographFailure = TRUE;
                pHashN->pSortkey = pTblPtrs->pDefaultSortkey;
                return (NO_ERROR);
            }

            //
            //  Exceptions from default sortkey table exist for the given
            //  locale.  Need to get the correct sortkey table.
            //  Create a section and call the server to lock it in.
            //
            Status = CsrBasepNlsCreateSection( NLS_CREATE_SORT_SECTION,
                                               Locale,
                                               &hSec );

            //
            //  Check return from server call.
            //
            rc = (ULONG)Status;

            if (!NT_SUCCESS(rc))
            {
                if (hSec != NULL)
                {
                    NtClose(hSec);
                }
                return (rc);
            }

            //
            //  Map the section for ReadWrite.
            //
            if (rc = MapSection( hSec,
                                 (PVOID *)&pBaseAddr,
                                 PAGE_READWRITE,
                                 FALSE ))
            {
                NtClose(hSec);
                return (rc);
            }

            //
            //  Copy the Default Sortkey Table to the New Section.
            //
            RtlMoveMemory( (PVOID)pBaseAddr,
                           (PVOID)((LPWORD)(pTblPtrs->pDefaultSortkey) -
                                   SORTKEY_HEADER),
                           (ULONG)(pTblPtrs->DefaultSortkeySize.LowPart) );

            //
            //  Copy exception information to the table.
            //
            CopyExceptionInfo( (PSORTKEY)(pBaseAddr + SORTKEY_HEADER),
                               pExceptHdr,
                               pExceptTbl,
                               pIdeograph);

            //
            //  Write a 1 to the WORD semaphore (table may now be read).
            //
            *pBaseAddr = 1;

            //
            //  Unmap the section for Write and remap it for Read.
            //
            if ((rc = UnMapSection(pBaseAddr)) ||
                (rc = MapSection( hSec,
                                  (PVOID *)&pBaseAddr,
                                  PAGE_READONLY,
                                  FALSE )))
            {
                NtClose(hSec);
                return (rc);
            }
        }
    }

    //
    //  Close the section handle.
    //
    NtClose(hSec);

    //
    //  Check semaphore bit in file.  Make sure that the open
    //  succeeded AFTER all exceptions were added to the memory
    //  mapped section.
    //
    if (*pBaseAddr == 0)
    {
        //
        //  Another process is still adding the appropriate exception
        //  information.  Must wait for its completion.
        //
        if (rc = WaitOnEvent(pBaseAddr))
        {
            UnMapSection(pBaseAddr);
            return (rc);
        }
    }

    //
    //  Save pointer in hash node.
    //
    pHashN->pSortkey = (PSORTKEY)(pBaseAddr + SORTKEY_HEADER);

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetSortTablesFileInfo
//
//  Stores the appropriate sort table pointers for the given locale in
//  the given locale hash node.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void GetSortTablesFileInfo(
    LCID Locale,
    PLOC_HASH pHashN)
{
    DWORD ctr;                    // loop counter
    PREVERSE_DW pRevDW;           // ptr to reverse diacritic table
    PDBL_COMPRESS pDblComp;       // ptr to double compression table
    PCOMPRESS_HDR pCompHdr;       // ptr to compression header


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Check for Reverse Diacritic Locale.
    //
    pRevDW = pTblPtrs->pReverseDW;
    for (ctr = pTblPtrs->NumReverseDW; ctr > 0; ctr--, pRevDW++)
    {
        if (*pRevDW == (DWORD)Locale)
        {
            pHashN->IfReverseDW = TRUE;
            break;
        }
    }

    //
    //  Check for Compression.
    //
    pCompHdr = pTblPtrs->pCompressHdr;
    for (ctr = pTblPtrs->NumCompression; ctr > 0; ctr--, pCompHdr++)
    {
        if (pCompHdr->Locale == (DWORD)Locale)
        {
            pHashN->IfCompression = TRUE;
            pHashN->pCompHdr = pCompHdr;
            if (pCompHdr->Num2 > 0)
            {
                pHashN->pCompress2 = (PCOMPRESS_2)
                                       (((LPWORD)(pTblPtrs->pCompression)) +
                                        (pCompHdr->Offset));
            }
            if (pCompHdr->Num3 > 0)
            {
                pHashN->pCompress3 = (PCOMPRESS_3)
                                       (((LPWORD)(pTblPtrs->pCompression)) +
                                        (pCompHdr->Offset) +
                                        (pCompHdr->Num2 *
                                          (sizeof(COMPRESS_2) / sizeof(WORD))));
            }
            break;
        }
    }

    //
    //  Check for Double Compression.
    //
    if (pHashN->IfCompression)
    {
        pDblComp = pTblPtrs->pDblCompression;
        for (ctr = pTblPtrs->NumDblCompression; ctr > 0; ctr--, pDblComp++)
        {
            if (*pDblComp == (DWORD)Locale)
            {
                pHashN->IfDblCompression = TRUE;
                break;
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadCodePageAsDLL
//
//  Try to load a code page as a DLL. If succeeded, the CodePage procedure
//  is set.
//
//  05-27-99    SamerA    Created.
////////////////////////////////////////////////////////////////////////////

ULONG LoadCodePageAsDLL(
    UINT CodePage,
    LPFN_CP_PROC *ppfnCPProc)
{
    WCHAR pDllName[MAX_PATH_LEN];         // ptr to DLL name
    HANDLE hModCPDll;                      // module handle of code page DLL
    ULONG rc = ERROR_INVALID_PARAMETER;   // return code
    UINT ErrorMode;                         // error mode


    //
    //  Get the DLL name to load.
    //
    pDllName[0] = 0;
    *ppfnCPProc = NULL;
    
    if (NO_ERROR == GetCodePageDLLPathName(CodePage, pDllName, MAX_PATH_LEN) && 
        NlsIsDll(pDllName))
    {
        //
        //  Load the DLL and get the procedure address.
        //  Turn off hard error popups.
        //
        ErrorMode = SetErrorMode(SEM_NOERROR);
        SetErrorMode(SEM_NOERROR | ErrorMode);

        hModCPDll = LoadLibrary(pDllName);

        SetErrorMode(ErrorMode);

        if (hModCPDll)
        {
            *ppfnCPProc =
                (LPFN_CP_PROC)GetProcAddress( hModCPDll,
                                              NLS_CP_DLL_PROC_NAME );
        }

        if (*ppfnCPProc == NULL)
        {
            if (hModCPDll)
            {
                rc = TYPE_E_DLLFUNCTIONNOTFOUND;
                FreeLibrary(hModCPDll);
            }
            else
            {
                rc = TYPE_E_CANTLOADLIBRARY;
            }
        }
        else
        {
            rc = NO_ERROR;
        }
    }

    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCodePageFileInfo
//
//  Opens and Maps a view of the section for the given code page.  It then
//  creates and inserts a hash node into the global CP hash table.
//
//  If the section cannot be opened, it then queries the registry to see if
//  the information has been added since the initialization of the DLL.  If
//  so, then it creates the section and then opens and maps a view of it.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetCodePageFileInfo(
    UINT CodePage,
    PCP_HASH *ppNode)
{
    HANDLE hSec = (HANDLE)0;                  // section handle
    UNICODE_STRING ObSecName;                 // section name
    LPWORD pBaseAddr = NULL;                  // ptr to base address of section
    ULONG rc = 0L;                            // return code
    BOOL IsDLL;                               // true if dll instead of data file
    LPFN_CP_PROC pfnCPProc;                   // Code Page DLL Procedure
    WCHAR wszSecName[MAX_SMALL_BUF_LEN];      // Place for the section name string                                                                          \

    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  See if we're dealing with a DLL or an NLS data file.
    //
    IsDLL = ((CodePage >= NLS_CP_DLL_RANGE) &&
             (CodePage <  NLS_CP_ALGORITHM_RANGE));

    if (IsDLL)
    {
        //
        // Try loading the codepage DLL
        //
        ULONG _rc = LoadCodePageAsDLL(CodePage, &pfnCPProc);

        if (_rc)
        {
        
            if (ERROR_INVALID_PARAMETER == _rc)
            {
                //
                // Not a valid DLL, try loading it as a normal data file
                //
                IsDLL = FALSE;
            }
            else
            {
                //
                // Failed to load the DLL or can't find the function entry
                // Return the error code
                //
                return (rc);
            }
        }
    }

    if (!IsDLL)
    {
        //
        //  Open and Map a view of the section.
        //
        GET_CP_SECTION_NAME(CodePage, wszSecName, MAX_SMALL_BUF_LEN, &ObSecName);

        rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          TRUE );
        
        if (!NT_SUCCESS(rc))
        {
            //
            //  Open failed, so try to create the section.
            //  If the creation is successful, the section will be mapped
            //  to the current process.
            //

            rc = CsrBasepNlsCreateSection(NLS_CREATE_CODEPAGE_SECTION, CodePage,
                                               &hSec );

            if (NT_SUCCESS(rc))
            {
                rc = MapSection( hSec,
                         &pBaseAddr,
                         PAGE_READONLY,
                         TRUE );                // Close handle (even if fail)
            }

            if (!NT_SUCCESS(rc))
            {
                //
                //  Allow the default ACP and default OEMCP to work if
                //  it's only the registry that is corrupt.  If there is
                //  still an error, return the error code that was returned
                //  from the OpenSection call.
                //
                if (CodePage == NLS_DEFAULT_ACP)
                {
                    //
                    //  Create the default ACP section.
                    //
                    if (!NT_SUCCESS(CsrBasepNlsCreateSection(NLS_CREATE_SECTION_DEFAULT_ACP, 0,
                                               &hSec )))
                    {
                        return (rc);
                    }
                    else
                    {
                        //
                        //  Map the section.
                        //
                        if (!NT_SUCCESS(MapSection( hSec,
                                                    (PVOID *)&pBaseAddr,
                                                    PAGE_READONLY,
                                                    TRUE )))
                        {
                            return (rc);
                        }
                        KdPrint(("NLSAPI: Registry is corrupt - Default ACP.\n"));
                    }
                }
                else if (CodePage == NLS_DEFAULT_OEMCP)
                {
                    //
                    //  Create the default OEMCP section.
                    //
                    if (!NT_SUCCESS(CsrBasepNlsCreateSection( NLS_CREATE_SECTION_DEFAULT_OEMCP, 0,
                                               &hSec )))
                    {
                        return (rc);
                    }
                    else
                    {
                        //
                        //  Map the section.
                        //
                        if (!NT_SUCCESS(MapSection( hSec,
                                                    (PVOID *)&pBaseAddr,
                                                    PAGE_READONLY,
                                                    TRUE )))
                        {
                            return (rc);
                        }
                        KdPrint(("NLSAPI: Registry is corrupt - Default OEMCP.\n"));
                    }
                }
                else
                {
                    //
                    //  Return the error code that was returned from the
                    //  OpenSection call.
                    //
                    return (rc);
                }
            }
        }
    }

    //
    //  Make the hash node and return the result.
    //
    return (MakeCPHashNode( CodePage,
                            pBaseAddr,
                            ppNode,
                            IsDLL,
                            pfnCPProc ));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLanguageFileInfo
//
//  Opens and Maps a view of the section for the casing tables and sorting
//  tables for the given locale.
//
//  If the section cannot be opened, it then queries the registry to see if
//  the information has been added since the initialization of the DLL.  If
//  so, then it creates the section and then opens and maps a view of it.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetLanguageFileInfo(
    LCID Locale,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode,
    DWORD dwFlags)
{
    LPWORD pBaseAddr = NULL;      // ptr to base address of section
    MEMORY_BASIC_INFORMATION MemoryBasicInfo;


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  See if the default language table has been stored yet.
    //
    if (pTblPtrs->pDefaultLanguage == NULL)
    {
        //
        //  Save the default language table and its size in the
        //  table pointers structure.
        //
        pTblPtrs->pDefaultLanguage = NtCurrentPeb()->UnicodeCaseTableData;

        NtQueryVirtualMemory( NtCurrentProcess(),
                              pTblPtrs->pDefaultLanguage,
                              MemoryBasicInformation,
                              &MemoryBasicInfo,
                              sizeof(MEMORY_BASIC_INFORMATION),
                              NULL );
        pTblPtrs->LinguistLangSize.QuadPart = MemoryBasicInfo.RegionSize;
        ASSERT(MemoryBasicInfo.RegionSize > 0);
    }

    //
    //  See if we should load the culturally correct language table.
    //
    if (dwFlags)
    {
        if (pTblPtrs->pLangException == NULL)
        {
            GetLanguageExceptionInfo();
        }

        //
        //  Get the default linguistic language table for the given locale.
        //
        pBaseAddr = GetLinguisticLanguageInfo(Locale);
    }

    //
    //  Get the casing table and sorting table pointers.
    //
    return (MakeLangHashNode( Locale,
                              pBaseAddr,
                              ppNode,
                              fCreateNode ));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLocaleFileInfo
//
//  Opens and Maps a view of the section for the given locale.  It then
//  creates and inserts a hash node into the global LOCALE hash table.
//
//  If the section cannot be opened, it then queries the registry to see if
//  the information has been added since the initialization of the DLL.  If
//  so, then it creates the section and then opens and maps a view of it.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetLocaleFileInfo(
    LCID Locale,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode)
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    ULONG rc = 0L;                // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Open and Map a view of the section if it hasn't been done yet.
    //
    if ((pBaseAddr = pTblPtrs->pLocaleInfo) == NULL)
    {
        //
        //  Get the locale file section pointer.
        //
        ObSecName.Buffer = NLS_SECTION_LOCALE;
        ObSecName.Length = sizeof (NLS_SECTION_LOCALE) - sizeof (WCHAR);
        ObSecName.MaximumLength = ObSecName.Length;

        if (rc = OpenSection( &hSec,
                              &ObSecName,
                              (PVOID *)&pBaseAddr,
                              SECTION_MAP_READ,
                              TRUE ))
        {
            return (rc);
        }

        //
        //  Store pointer to locale file and calendar info in table
        //  structure.
        //
        pTblPtrs->pLocaleInfo = pBaseAddr;

        pTblPtrs->NumCalendars = ((PLOC_CAL_HDR)pBaseAddr)->NumCalendars;
        pTblPtrs->pCalendarInfo = pBaseAddr +
                                  ((PLOC_CAL_HDR)pBaseAddr)->CalOffset;
    }

    //
    //  Make the hash node and return the result.
    //
    return (MakeLocHashNode( Locale,
                             pBaseAddr,
                             ppNode,
                             fCreateNode ));
}


////////////////////////////////////////////////////////////////////////////
//
//  MakeCPHashNode
//
//  Creates the hash node for the code page and assigns the fields of the
//  hash node to point at the appropriate places in the file.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG MakeCPHashNode(
    UINT CodePage,
    LPWORD pBaseAddr,
    PCP_HASH *ppNode,
    BOOL IsDLL,
    LPFN_CP_PROC pfnCPProc)
{
    PCP_HASH pHashN;                   // ptr to CP hash node
    WORD offMB;                        // offset to MB table
    WORD offWC;                        // offset to WC table
    PGLYPH_TABLE pGlyph;               // ptr to glyph table info
    PDBCS_RANGE pRange;                // ptr to DBCS range

    //
    //  Allocate CP_HASH structure and fill in the CodePage value.
    //
    CREATE_CODEPAGE_HASH_NODE(CodePage, pHashN);

    //
    //  See if we're dealing with a DLL or an NLS data file.
    //
    if (IsDLL)
    {
        if (pfnCPProc == NULL)
        {
            NLS_FREE_MEM(pHashN);
            return (ERROR_INVALID_PARAMETER);
        }

        pHashN->pfnCPProc = pfnCPProc;
    }
    else
    {
        //
        //  Get the offsets.
        //
        offMB = pBaseAddr[0];
        offWC = offMB + pBaseAddr[offMB];

        //
        //  Attach CP Info to CP hash node.
        //
        pHashN->pCPInfo = (PCP_TABLE)(pBaseAddr + CP_HEADER);

        //
        //  Attach MB table to CP hash node.
        //
        pHashN->pMBTbl = pBaseAddr + offMB + MB_HEADER;

        //
        //  Attach Glyph table to CP hash node (if it exists).
        //  Also, set the pointer to the DBCS ranges based on whether or
        //  not the GLYPH table is present.
        //
        pGlyph = pHashN->pMBTbl + MB_TBL_SIZE;
        if (pGlyph[0] != 0)
        {
            pHashN->pGlyphTbl = pGlyph + GLYPH_HEADER;
            pRange = pHashN->pDBCSRanges = pHashN->pGlyphTbl + GLYPH_TBL_SIZE;
        }
        else
        {
            pRange = pHashN->pDBCSRanges = pGlyph + GLYPH_HEADER;
        }

        //
        //  Attach DBCS information to CP hash node.
        //
        if (pRange[0] > 0)
        {
            //
            //  Set the pointer to the offsets section.
            //
            pHashN->pDBCSOffsets = pRange + DBCS_HEADER;
        }

        //
        //  Attach WC table to CP hash node.
        //
        pHashN->pWC = pBaseAddr + offWC + WC_HEADER;
        
    }

    //
    //  Insert hash node into hash table.
    //
    INSERT_CP_HASH_NODE(pHashN, pBaseAddr);

    //
    //  Save the pointer to the hash node.
    //
    if (ppNode != NULL)
    {
        *ppNode = pHashN;
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  MakeLangHashNode
//
//  Gets the pointers to the casing tables and the sorting tables and
//  stores them in the locale hash node given.
//
//  If fCreateNode is FALSE, then *ppNode should contain a valid pointer
//  to a LOC hash node.  Also, the table critical section must be entered
//  before calling this routine.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG MakeLangHashNode(
    LCID Locale,
    LPWORD pBaseAddr,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode)
{
    LPWORD pBaseDefault;          // ptr to default language section
    PLOC_HASH pHashN;             // ptr to LOC hash node
    ULONG rc = 0L;                // return code


    //
    //  If fCreateNode is TRUE, then allocate LOC_HASH structure.
    //
    if (fCreateNode)
    {
        CREATE_LOCALE_HASH_NODE(Locale, pHashN);
    }
    else
    {
        pHashN = *ppNode;
    }

    //
    //  See if the sorting tables still need to be attached.
    //
    if (pHashN->pSortkey == NULL)
    {
        //
        //  Get the sortkey table and attach it to the hash node.
        //
        if (rc = GetSortkeyFileInfo(Locale, pHashN))
        {
            if (fCreateNode)
            {
                NLS_FREE_MEM(pHashN);
            }
            return (rc);
        }

        //
        //  Get the appropriate sorting tables for the locale.
        //
        GetSortTablesFileInfo(Locale, pHashN);
    }

    //
    //  See if the default casing tables still need to be attached.
    //
    if (!EXIST_LANGUAGE_INFO(pHashN))
    {
        //
        //  Get the pointer to the base of the default table.
        //
        pBaseDefault = pTblPtrs->pDefaultLanguage;

        //
        //  Attach the UPPERCASE table to the hash node.
        //
        pHashN->pUpperCase = pBaseDefault + LANG_HEADER + UP_HEADER;

        //
        //  Attach the LOWERCASE table to the hash node.
        //
        //  This value must be set LAST, since this is the pointer that
        //  is checked to see that the language information has been
        //  initialized.
        //
        pHashN->pLowerCase = pBaseDefault + LANG_HEADER +
                             pBaseDefault[LANG_HEADER] + LO_HEADER;
    }

    //
    //  See if there is a linguistic table to attach.
    //
    if (pBaseAddr)
    {
        //
        //  Attach the UPPERCASE Linguistic table to the hash node.
        //
        pHashN->pUpperLinguist = pBaseAddr + LANG_HEADER + UP_HEADER;

        //
        //  Attach the LOWERCASE Linguistic table to the hash node.
        //
        //  This value must be set LAST, since this is the pointer that
        //  is checked to see that the language information has been
        //  initialized.
        //
        pHashN->pLowerLinguist = pBaseAddr + LANG_HEADER +
                                 pBaseAddr[LANG_HEADER] + LO_HEADER;
    }

    //
    //  If fCreateNode is TRUE, then insert hash node and save pointer.
    //
    if (fCreateNode)
    {
        //
        //  Insert LOC hash node into hash table.
        //
        INSERT_LOC_HASH_NODE(pHashN, pBaseAddr);

        //
        //  Save the pointer to the hash node.
        //
        if (ppNode != NULL)
        {
            *ppNode = pHashN;
        }
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  MakeLocHashNode
//
//  Gets the pointers to the locale tables and stores them in the locale
//  hash node given.
//
//  NOTE:  If a critical section is needed to touch pHashN, then the
//         critical section must be entered before calling this routine.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG MakeLocHashNode(
    LCID Locale,
    LPWORD pBaseAddr,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode)
{
    LANGID Language;              // language id
    PLOC_HASH pHashN;             // ptr to LOC hash node
    DWORD Num;                    // total number of locales
    PLOCALE_HDR pFileHdr;         // ptr to locale header entry
    ULONG rc = 0L;                // return code


    //
    //  Save the language id.
    //
    Language = LANGIDFROMLCID(Locale);

    //
    //  Search for the right locale id information.
    //
    Num = ((PLOC_CAL_HDR)pBaseAddr)->NumLocales;
    pFileHdr = (PLOCALE_HDR)(pBaseAddr + LOCALE_HDR_OFFSET);
    for (; (Num != 0) && (pFileHdr->Locale != Language); Num--, pFileHdr++)
        ;

    //
    //  See if the locale was found in the file.
    //
    if (Num != 0)
    {
        //
        //  Locale id was found, so increment the pointer to point at
        //  the beginning of the locale information.
        //
        pBaseAddr += pFileHdr->Offset;
    }
    else
    {
        //
        //  Return an error.  The given locale is not supported.
        //
        return (ERROR_INVALID_PARAMETER);
    }

    //
    //  If fCreateNode is TRUE, then allocate LOC_HASH structure.
    //
    if (fCreateNode)
    {
        CREATE_LOCALE_HASH_NODE(Locale, pHashN);
    }
    else
    {
        pHashN = *ppNode;
    }

    //
    //  Attach Information to structure.
    //
    //  The pLocaleFixed value must be set LAST, since this is the pointer
    //  that is checked to see that the locale information has been
    //  initialized.
    //
    pHashN->pLocaleHdr   = (PLOCALE_VAR)pBaseAddr;
    pHashN->pLocaleFixed = (PLOCALE_FIXED)(pBaseAddr +
                                           (sizeof(LOCALE_VAR) / sizeof(WORD)));

    //
    //  If fCreateNode is TRUE, then insert hash node and save pointer.
    //
    if (fCreateNode)
    {
        //
        //  Insert LOC hash node into hash table.
        //
        INSERT_LOC_HASH_NODE(pHashN, pBaseAddr);

        //
        //  Save the pointer to the hash node.
        //
        if (ppNode != NULL)
        {
            *ppNode = pHashN;
        }
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCPHashNode
//
//  Returns a pointer to the appropriate CP hash node given the codepage.
//  If no table could be found for the given codepage, NULL is returned.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

PCP_HASH FASTCALL GetCPHashNode(
    UINT CodePage)
{
    PCP_HASH pHashN;              // ptr to CP hash node


    //
    //  Get hash node.
    //
    FIND_CP_HASH_NODE(CodePage, pHashN);

    //
    //  If the hash node does not exist, try to get the tables
    //  from the appropriate data file.
    //
    //  NOTE:  No need to check error code from GetCodePageFileInfo,
    //         because pHashN is not touched if there was an
    //         error.  Thus, pHashN will still be NULL, and an
    //         "error" will be returned from this routine.
    //
    if (pHashN == NULL)
    {
        //
        //  Hash node does NOT exist.
        //
        RtlEnterCriticalSection(&gcsTblPtrs);
        FIND_CP_HASH_NODE(CodePage, pHashN);
        if (pHashN == NULL)
        {
            GetCodePageFileInfo(CodePage, &pHashN);
        }
        RtlLeaveCriticalSection(&gcsTblPtrs);
    }

    //
    //  Return pointer to hash node.
    //
    return (pHashN);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLangHashNode
//
//  Returns a pointer to the appropriate LOC hash node given the locale.
//  If no table could be found for the given locale, NULL is returned.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

PLOC_HASH FASTCALL GetLangHashNode(
    LCID Locale,
    DWORD dwFlags)
{
    PLOC_HASH pHashN;             // ptr to LOC hash node


    //
    //  Get hash node.
    //
    FIND_LOCALE_HASH_NODE(Locale, pHashN);

    //
    //  If the hash node does not exist, try to get the tables
    //  from the appropriate data file.
    //
    //  NOTE:  No need to check error code from GetLanguageFileInfo,
    //         because pHashN is not touched if there was an
    //         error.  Thus, pHashN will still be NULL, and an
    //         "error" will be returned from this routine.
    //
    if (pHashN == NULL)
    {
        //
        //  If a sort id exists, make sure it's valid.
        //
        if (SORTIDFROMLCID(Locale))
        {
            if (!IsValidSortId(Locale))
            {
                return (NULL);
            }
        }

        //
        //  Hash node does NOT exist.
        //
        RtlEnterCriticalSection(&gcsTblPtrs);
        FIND_LOCALE_HASH_NODE(Locale, pHashN);
        if (pHashN == NULL)
        {
            //
            //  Hash node still does NOT exist.
            //
            GetLanguageFileInfo(Locale, &pHashN, TRUE, dwFlags);
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (pHashN);
        }
        RtlLeaveCriticalSection(&gcsTblPtrs);
    }

    //
    //  Hash node DOES exist.
    //
    if (!EXIST_LANGUAGE_INFO(pHashN) ||
        ((dwFlags != 0) && !EXIST_LINGUIST_LANGUAGE_INFO(pHashN)))
    {
        //
        //  Casing tables and sorting tables not yet stored in
        //  hash node.
        //
        RtlEnterCriticalSection(&gcsTblPtrs);
        if (!EXIST_LANGUAGE_INFO(pHashN) ||
            ((dwFlags != 0) && !EXIST_LINGUIST_LANGUAGE_INFO(pHashN)))
        {
            if (GetLanguageFileInfo(Locale, &pHashN, FALSE, dwFlags))
            {
                RtlLeaveCriticalSection(&gcsTblPtrs);
                return (NULL);
            }
        }
        RtlLeaveCriticalSection(&gcsTblPtrs);
    }

    //
    //  Return pointer to hash node.
    //
    return (pHashN);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLocHashNode
//
//  Returns a pointer to the appropriate LOC hash node given the locale.
//  If no table could be found for the given locale, NULL is returned.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

PLOC_HASH FASTCALL GetLocHashNode(
    LCID Locale)
{
    PLOC_HASH pHashN;             // ptr to LOC hash node


    //
    //  Get hash node.
    //
    FIND_LOCALE_HASH_NODE(Locale, pHashN);

    //
    //  If the hash node does not exist, try to get the table
    //  from locale.nls.
    //
    //  NOTE:  No need to check error code from GetLocaleFileInfo,
    //         because pHashN is not touched if there was an
    //         error.  Thus, pHashN will still be NULL, and an
    //         "error" will be returned from this routine.
    //
    if (pHashN == NULL)
    {
        //
        //  If a sort id exists, make sure it's valid.
        //
        if (SORTIDFROMLCID(Locale))
        {
            if (!IsValidSortId(Locale))
            {
                return (NULL);
            }
        }

        //
        //  Hash node does NOT exist.
        //
        RtlEnterCriticalSection(&gcsTblPtrs);
        FIND_LOCALE_HASH_NODE(Locale, pHashN);
        if (pHashN == NULL)
        {
            //
            //  Hash node still does NOT exist.
            //
            GetLocaleFileInfo(Locale, &pHashN, TRUE);
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (pHashN);
        }
        RtlLeaveCriticalSection(&gcsTblPtrs);
    }

    //
    //  Hash node DOES exist.
    //
    if (!EXIST_LOCALE_INFO(pHashN))
    {
        //
        //  Locale tables not yet stored in hash node.
        //
        RtlEnterCriticalSection(&gcsTblPtrs);
        if (!EXIST_LOCALE_INFO(pHashN))
        {
            if (GetLocaleFileInfo(Locale, &pHashN, FALSE))
            {
                RtlLeaveCriticalSection(&gcsTblPtrs);
                return (NULL);
            }
        }
        RtlLeaveCriticalSection(&gcsTblPtrs);
    }

    //
    //  Return pointer to hash node.
    //
    return (pHashN);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCalendar
//
//  Gets the pointer to the specific calendar table.  It stores it in the
//  calendar information array in the global table pointers structure if it
//  was not done yet.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetCalendar(
    CALID Calendar,
    PCAL_INFO *ppCalInfo)
{
    PCALENDAR_HDR pCalHdr;        // ptr to beginning of calendar header
    DWORD Num;                    // total number of calendars


    //
    //  Get number of calendars.
    //
    Num = pTblPtrs->NumCalendars;

    //
    //  Make sure calendar id is within the appropriate range.
    //
    if (Calendar > Num)
    {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    //  Check to see if calendar info has already been found.
    //
    if ((*ppCalInfo = (pTblPtrs->pCalTbl)[Calendar]) != NULL)
    {
        //
        //  Return success.  Calendar info was found.
        //
        return (NO_ERROR);
    }

    RtlEnterCriticalSection(&gcsTblPtrs);

    if ((*ppCalInfo = (pTblPtrs->pCalTbl)[Calendar]) != NULL)
    {
        //
        //  Return success.  Calendar info was found.
        //
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (NO_ERROR);
    }

    //
    //  Search for the appropriate calendar id information.
    //
    pCalHdr = (PCALENDAR_HDR)(pTblPtrs->pCalendarInfo);
    while ((Num != 0) && (pCalHdr->Calendar != Calendar))
    {
        Num--;
        pCalHdr++;
    }

    //
    //  See if the calendar was found in the file.
    //
    if (Num != 0)
    {
        //
        //  Calendar id was found.
        //
        //  Store the pointer to the beginning of the calendar info
        //  in the calendar table array.
        //
        *ppCalInfo = (PCAL_INFO)((LPWORD)(pTblPtrs->pCalendarInfo) +
                                 pCalHdr->Offset);
        (pTblPtrs->pCalTbl)[Calendar] = *ppCalInfo;

        //
        //  Return success.  Calendar info was found.
        //
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (NO_ERROR);
    }

    RtlLeaveCriticalSection(&gcsTblPtrs);

    //
    //  Calendar id was not found in the locale.nls file.
    //  Return an error.  The given calendar is not supported.
    //
    return (ERROR_INVALID_PARAMETER);
}





//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  IsValidSortId
//
//  Checks to see if the given locale has a valid sort id.
//
//  11-15-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidSortId(
    LCID Locale)
{
    WCHAR pTmpBuf[MAX_PATH];                     // temp buffer
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    BOOL IfAlloc = FALSE;                        // if buffer was allocated
    ULONG rc = 0L;                               // return code


    //
    //  Make sure there is a sort id.
    //
    if (!SORTIDFROMLCID(Locale))
    {
        return (TRUE);
    }

    //
    //  Open the Alternate Sorts registry key.
    //
    OPEN_ALT_SORTS_KEY(FALSE);


    //
    //  Convert locale value to Unicode string.
    //
    if (NlsConvertIntegerToString(Locale, 16, 8, pTmpBuf, MAX_PATH))
    {
        return (FALSE);
    }

    //
    //  Query the registry for the value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    if (rc = QueryRegValue( hAltSortsKey,
                            pTmpBuf,
                            &pKeyValueFull,
                            MAX_KEY_VALUE_FULLINFO,
                            &IfAlloc ))
    {
        return (FALSE);
    }

    //
    //  Free the buffer used for the query.
    //
    if (IfAlloc)
    {
        NLS_FREE_MEM(pKeyValueFull);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLanguageExceptionInfo
//
//  Opens and Maps a view of the section for the language exception file.
//  It then fills in the appropriate fields of the global table pointers
//  structure.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetLanguageExceptionInfo()
{
    HANDLE hSec = (HANDLE)0;           // section handle
    LPWORD pBaseAddr;                  // ptr to base address of section
    DWORD Num;                         // number of entries in table
    ULONG rc = 0L;                     // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Make sure the table isn't already there.
    //
    if (pTblPtrs->pLangException != NULL)
    {
        return (NO_ERROR);
    }

    //
    //  Create and map the section, and then save the pointer.
    //
    if ((rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_LANG_EXCEPT, 0,
                                               &hSec )) == NO_ERROR)
    {
        //
        //  Map a View of the Section.
        //
        if ((rc = MapSection( hSec,
                              &pBaseAddr,
                              PAGE_READONLY,
                              TRUE )) != NO_ERROR)
        {
            return (rc);
        }
    }
    else
    {
        return (rc);
    }

    //
    //  Save the pointers to the exception information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumLangException = Num;
        pTblPtrs->pLangExceptHdr   = (PL_EXCEPT_HDR)(pBaseAddr +
                                                     L_EXCEPT_HDR_OFFSET);
        pTblPtrs->pLangException   = (PL_EXCEPT)(pBaseAddr +
                                                 L_EXCEPT_HDR_OFFSET +
                                                 (Num * (sizeof(L_EXCEPT_HDR) /
                                                         sizeof(WORD))));
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLinguisticLanguageInfo
//
//  Opens and Maps a view of the section for the default linguistic language
//  table.  It then stores the pointer to the table in the global pointer
//  table.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LPWORD GetLinguisticLanguageInfo(
    LCID Locale)
{
    HANDLE hSec = (HANDLE)0;           // section handle
    UNICODE_STRING ObSecName;          // section name
    LPWORD pBaseAddr;                  // ptr to base address of section
    ULONG rc = 0L;                     // return code
    SECTION_BASIC_INFORMATION SecInfo; // section information - query


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Create/Open and Map a view of the section if it hasn't been done yet.
    //
    if (pTblPtrs->pLinguistLanguage == NULL)
    {
        //
        //  See if we can simply open the section.
        //
        RtlInitUnicodeString(&ObSecName, NLS_SECTION_LANG_INTL);
        if (rc = OpenSection( &hSec,
                              &ObSecName,
                              (PVOID *)&pBaseAddr,
                              SECTION_MAP_READ,
                              TRUE ))
        {
            //
            //  Need to create the default linguistic language section.
            //
            if (CreateAndCopyLanguageExceptions(0L, &pBaseAddr))
            {
                return (NULL);
            }
        }

        //
        //  Get Default Linguistic Language Information.
        //
        pTblPtrs->pLinguistLanguage = (P844_TABLE)(pBaseAddr);
    }

    //
    //  Now see if there are any exceptions for the given locale.
    //
    if (CreateAndCopyLanguageExceptions(Locale, &pBaseAddr))
    {
        return (pTblPtrs->pLinguistLanguage);
    }

    //
    //  Return success.
    //
    return (pBaseAddr);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateAndCopyLanguageExceptions
//
//  Creates the section for the new language table (if necessary) and then
//  copies the exceptions to the table.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG CreateAndCopyLanguageExceptions(
    LCID Locale,
    LPWORD *ppBaseAddr)

{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    P844_TABLE pLangDefault;      // ptr to default table to copy from
    ULONG rc = 0L;                // return code

    PL_EXCEPT_HDR pExceptHdr;     // ptr to exception header
    PL_EXCEPT pExceptTbl;         // ptr to exception table

    WCHAR wszSecName[MAX_SMALL_BUF_LEN];      // Place for the section name string                                                                          \

    NTSTATUS Status;

    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    if (Locale == 0)
    {
        //
        //  Creating the default section.
        //
        RtlInitUnicodeString(&ObSecName, NLS_SECTION_LANG_INTL);
        pLangDefault = pTblPtrs->pDefaultLanguage;

    }
    else
    {
        GET_LANG_SECTION_NAME(Locale, wszSecName, MAX_SMALL_BUF_LEN, &ObSecName);
        pLangDefault = pTblPtrs->pLinguistLanguage;
    }

    //
    //  Try to Open and Map a view of the section (read only).
    //
    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          FALSE ))
    {
        //
        //  Open failed.
        //  See if any exceptions exist for given Locale ID.
        //
        if (!FindLanguageExceptionPointers( Locale,
                                            &pExceptHdr,
                                            &pExceptTbl ) &&
            (Locale != 0))
        {
            //
            //  No exceptions for locale and we're not trying to create
            //  the default table, so return the pointer to the default
            //  table (which should always be created at this point).
            //
            *ppBaseAddr = pTblPtrs->pLinguistLanguage;
            return (NO_ERROR);
        }
        else
        {
            //
            //  Exceptions exist for the given locale.  Need to create the
            //  new section (and call the server to make it permanent).
            //

            Status = CsrBasepNlsCreateSection( NLS_CREATE_LANG_EXCEPTION_SECTION,
                                               Locale,
                                               &hSec );
            //
            //  Check return from server call.
            //
            rc = (ULONG)Status;

            if (!NT_SUCCESS(rc))
            {
                if (hSec != NULL)
                {
                    NtClose(hSec);
                }
                return (rc);
            }

            //
            //  Map the section for ReadWrite.
            //
            if (rc = MapSection( hSec,
                                 (PVOID *)&pBaseAddr,
                                 PAGE_READWRITE,
                                 FALSE ))
            {
                NtClose(hSec);
                return (rc);
            }

            //
            //  Put a 0 in the semaphore part to denote that the file
            //  is not ready yet.
            //
            *pBaseAddr = 0;

            //
            //  Copy the Default Language Table to the New Section.
            //
            RtlMoveMemory( (PVOID)((LPWORD)pBaseAddr + LANG_HEADER),
                           (PVOID)((LPWORD)(pLangDefault) + LANG_HEADER),
                           (ULONG)(pTblPtrs->LinguistLangSize.LowPart -
                                   (LANG_HEADER * sizeof(WORD))) );

            //
            //  Copy exception information to the table.
            //
            CopyLanguageExceptionInfo( pBaseAddr,
                                       pExceptHdr,
                                       pExceptTbl );

            //
            //  Write a 1 to the WORD semaphore (table may now be read).
            //
            *pBaseAddr = 1;

            //
            //  Unmap the section for Write and remap it for Read.
            //
            if ((rc = UnMapSection(pBaseAddr)) ||
                (rc = MapSection( hSec,
                                  (PVOID *)&pBaseAddr,
                                  PAGE_READONLY,
                                  FALSE )))
            {
                NtClose(hSec);
                return (rc);
            }
        }
    }

    //
    //   Close the section handle.
    //
    NtClose(hSec);

    //
    //  Check semaphore bit in file.  Make sure that the open
    //  succeeded AFTER all exceptions were added to the memory
    //  mapped section.
    //
    if (*pBaseAddr == 0)
    {
        //
        //  Another process is still adding the appropriate exception
        //  information.  Must wait for its completion.
        //
        if (rc = WaitOnEvent(pBaseAddr))
        {
            UnMapSection(pBaseAddr);
            return (rc);
        }
    }

    //
    //  Return the pointer to the section.
    //
    *ppBaseAddr = pBaseAddr;

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  FindLanguageExceptionPointers
//
//  Checks to see if any exceptions exist for the given locale id.  If
//  exceptions exist, then TRUE is returned and the pointer to the exception
//  header and the pointer to the exception table are stored in the given
//  parameters.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL FindLanguageExceptionPointers(
    LCID Locale,
    PL_EXCEPT_HDR *ppExceptHdr,
    PL_EXCEPT *ppExceptTbl)
{
    DWORD ctr;                         // loop counter
    PL_EXCEPT_HDR pHdr;                // ptr to exception header
    BOOL rc = FALSE;                   // return value


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Initialize pointers.
    //
    *ppExceptHdr = NULL;
    *ppExceptTbl = NULL;

    //
    //  Need to search down the exception header for the given locale.
    //
    pHdr = pTblPtrs->pLangExceptHdr;
    for (ctr = pTblPtrs->NumLangException; ctr > 0; ctr--, pHdr++)
    {
        if (pHdr->Locale == (DWORD)Locale)
        {
            //
            //  Found the locale id, so set the pointers.
            //
            *ppExceptHdr = pHdr;
            *ppExceptTbl = (PL_EXCEPT)(((LPWORD)(pTblPtrs->pLangException)) +
                                       pHdr->Offset);

            //
            //  Set the return code for success.
            //
            rc = TRUE;
            break;
        }
    }

    //
    //  Return the value in rc.
    //
    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  CopyLanguageExceptionInfo
//
//  Copies the language exception information to the given language table.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void FASTCALL CopyLanguageExceptionInfo(
    LPWORD pBaseAddr,
    PL_EXCEPT_HDR pExceptHdr,
    PL_EXCEPT pExceptTbl)
{
    DWORD ctr;                    // loop counter
    P844_TABLE pUpCase;           // ptr to upper case table
    P844_TABLE pLoCase;           // ptr to lower case table


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    if (pExceptTbl)
    {
        //
        //  Get the pointers to the upper and lower case table.
        //
        pUpCase = pBaseAddr + LANG_HEADER + UP_HEADER;
        pLoCase = pBaseAddr + LANG_HEADER + pBaseAddr[LANG_HEADER] + LO_HEADER;

        //
        //  For each entry in the exception table, copy the information to the
        //  sortkey table.
        //
        for (ctr = pExceptHdr->NumUpEntries; ctr > 0; ctr--, pExceptTbl++)
        {
            TRAVERSE_844_W(pUpCase, pExceptTbl->UCP) = pExceptTbl->AddAmount;
        }
        for (ctr = pExceptHdr->NumLoEntries; ctr > 0; ctr--, pExceptTbl++)
        {
            TRAVERSE_844_W(pLoCase, pExceptTbl->UCP) = pExceptTbl->AddAmount;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FindExceptionPointers
//
//  Checks to see if any exceptions exist for the given locale id.  If
//  exceptions exist, then TRUE is returned and the pointer to the exception
//  header and the pointer to the exception table are stored in the given
//  parameters.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL FindExceptionPointers(
    LCID Locale,
    PEXCEPT_HDR *ppExceptHdr,
    PEXCEPT *ppExceptTbl,
    PVOID *ppIdeograph,
    PULONG pReturn)
{
    HANDLE hSec = (HANDLE)0;           // section handle
    DWORD ctr;                         // loop counter
    PEXCEPT_HDR pHdr;                  // ptr to exception header
    BOOL bFound = FALSE;               // if an exception is found

    PIDEOGRAPH_LCID pIdeoLcid;         // ptr to ideograph lcid entry
    PVOID pBaseAddr;                   // ptr to base address of section


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Initialize pointers.
    //
    *ppExceptHdr = NULL;
    *ppExceptTbl = NULL;
    *ppIdeograph = NULL;
    *pReturn = NO_ERROR;

    //
    //  Need to search down the exception header for the given locale.
    //
    pHdr = pTblPtrs->pExceptHdr;
    for (ctr = pTblPtrs->NumException; ctr > 0; ctr--, pHdr++)
    {
        if (pHdr->Locale == (DWORD)Locale)
        {
            //
            //  Found the locale id, so set the pointers.
            //
            *ppExceptHdr = pHdr;
            *ppExceptTbl = (PEXCEPT)(((LPWORD)(pTblPtrs->pException)) +
                                     pHdr->Offset);

            //
            //  Set the return code to show that an exception has been
            //  found.
            //
            bFound = TRUE;
            break;
        }
    }

    //
    //  Need to search down the ideograph lcid exception list for the
    //  given locale.
    //
    pIdeoLcid = pTblPtrs->pIdeographLcid;
    for (ctr = pTblPtrs->NumIdeographLcid; ctr > 0; ctr--, pIdeoLcid++)
    {
        if (pIdeoLcid->Locale == (DWORD)Locale)
        {
            //
            //  Found the locale id, so create/open and map the section
            //  for the appropriate file.
            //
            if (*pReturn = CreateSectionTemp(&hSec, pIdeoLcid->pFileName))
            {
                //
                //  Ideograph file section could not be created, so return
                //  the error.
                //
                return (TRUE);
            }
            if (*pReturn = MapSection(hSec, &pBaseAddr, PAGE_READONLY, TRUE))
            {
                //
                //  Ideograph file section could not be mapped, so close
                //  the created section and return the error.
                //
                NtClose(hSec);
                return (TRUE);
            }

            //
            //  Set the pointer to the ideograph information.
            //
            *ppIdeograph = pBaseAddr;

            //
            //  Set the return code to show that an exception has been
            //  found.
            //
            bFound = TRUE;
            break;
        }
    }

    //
    //  Return the appropriate value.
    //
    return (bFound);
}


////////////////////////////////////////////////////////////////////////////
//
//  CopyExceptionInfo
//
//  Copies the exception information to the given sortkey table.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void FASTCALL CopyExceptionInfo(
    PSORTKEY pSortkey,
    PEXCEPT_HDR pExceptHdr,
    PEXCEPT pExceptTbl,
    PVOID pIdeograph)
{
    DWORD ctr;                    // loop counter
    PIDEOGRAPH_EXCEPT_HDR pHdrIG; // ptr to ideograph exception header
    PIDEOGRAPH_EXCEPT pEntryIG;   // ptr to ideograph exception entry
    PEXCEPT pEntryIGEx;           // ptr to ideograph exception entry ex


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  For each entry in the exception table, copy the information to the
    //  sortkey table.
    //
    if (pExceptTbl)
    {
        for (ctr = pExceptHdr->NumEntries; ctr > 0; ctr--, pExceptTbl++)
        {
            (pSortkey[pExceptTbl->UCP]).UW.Unicode = pExceptTbl->Unicode;
            (pSortkey[pExceptTbl->UCP]).Diacritic  = pExceptTbl->Diacritic;
            (pSortkey[pExceptTbl->UCP]).Case       = pExceptTbl->Case;
        }
    }

    //
    //  For each entry in the ideograph exception table, copy the
    //  information to the sortkey table.
    //
    if (pIdeograph)
    {
        pHdrIG = (PIDEOGRAPH_EXCEPT_HDR)pIdeograph;
        ctr = pHdrIG->NumEntries;

        if (pHdrIG->NumColumns == 2)
        {
            pEntryIG = (PIDEOGRAPH_EXCEPT)( ((LPBYTE)pIdeograph) +
                                            sizeof(IDEOGRAPH_EXCEPT_HDR) );
            for (; ctr > 0; ctr--, pEntryIG++)
            {
                (pSortkey[pEntryIG->UCP]).UW.Unicode = pEntryIG->Unicode;
            }
        }
        else
        {
            pEntryIGEx = (PEXCEPT)( ((LPBYTE)pIdeograph) +
                                    sizeof(IDEOGRAPH_EXCEPT_HDR) );
            for (; ctr > 0; ctr--, pEntryIGEx++)
            {
                (pSortkey[pEntryIGEx->UCP]).UW.Unicode = pEntryIGEx->Unicode;
                (pSortkey[pEntryIGEx->UCP]).Diacritic  = pEntryIGEx->Diacritic;
                (pSortkey[pEntryIGEx->UCP]).Case       = pEntryIGEx->Case;
            }
        }

        //
        //  Unmap and Close the ideograph section.
        //
        UnMapSection(pIdeograph);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  WaitOnEvent
//
//  Waits (via timeout) for the semaphore dword to be set to a non-zero
//  value.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG WaitOnEvent(
    LPWORD pSem)
{
    TIME TimeOut;                 // ptr to timeout


    //
    //  Set up the TIME structure.
    //
    TimeOut.QuadPart = -100000;

    //
    //  Wait on the event until the semaphore is set to non-zero.
    //  Use a timeout on the wait.
    //
    do
    {
        NtDelayExecution(FALSE, &TimeOut);

    } while (*pSem == 0);

    //
    //  Return success.
    //
    return (NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\utf.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    utf.c

Abstract:

    This file contains functions that convert UTF strings to Unicode
    strings and Unicode string to UTF strings.

    External Routines found in this file:
      UTFCPInfo
      UTFToUnicode
      UnicodeToUTF

Revision History:

    02-06-96    JulieB    Created.
    03-20-99    SamerA    Surrogate support.
--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"
#include "utf.h"




//
//  Forward Declarations.
//

int
UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);

int
UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest,
    DWORD dwFlags);

int
UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);

int
UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UTFCPInfo
//
//  Gets the CPInfo for the given UTF code page.
//
//  10-23-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL UTFCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo,
    BOOL fExVer)
{
    int ctr;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - lpCPInfo is NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (lpCPInfo == NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            lpCPInfo->MaxCharSize = 5;
            break;
        }
        case ( CP_UTF8 ) :
        {
            lpCPInfo->MaxCharSize = 4;
            break;
        }
    }

    (lpCPInfo->DefaultChar)[0] = '?';
    (lpCPInfo->DefaultChar)[1] = (BYTE)0;

    for (ctr = 0; ctr < MAX_LEADBYTES; ctr++)
    {
        (lpCPInfo->LeadByte)[ctr] = (BYTE)0;
    }

    if (fExVer)
    {
        LPCPINFOEXW lpCPInfoEx = (LPCPINFOEXW)lpCPInfo;

        lpCPInfoEx->UnicodeDefaultChar = L'?';
        lpCPInfoEx->CodePage = CodePage;
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UTFToUnicode
//
//  Maps a UTF character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTFToUnicode(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of MB string is 0
    //     - wide char buffer size is negative
    //     - MB string is NULL
    //     - length of WC string is NOT zero AND
    //         (WC string is NULL OR src and dest pointers equal)
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cbMultiByte == 0) || (cchWideChar < 0) ||
         (lpMultiByteStr == NULL) ||
         ((cchWideChar != 0) &&
          ((lpWideCharStr == NULL) ||
           (lpMultiByteStr == (LPSTR)lpWideCharStr))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - UTF7: flags not 0.
    //     - UTF8: flags not 0 nor MB_ERR_INVALID_CHARS.
    //
    if (CodePage == CP_UTF8) 
    {
        // UTF8        
        if ((dwFlags & ~MB_ERR_INVALID_CHARS) != 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
    } 
    else if (dwFlags != 0)
    {
        // UTF7
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cbMultiByte is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cbMultiByte <= -1)
    {
        cbMultiByte = strlen(lpMultiByteStr) + 1;
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UTF7ToUnicode( lpMultiByteStr,
                                cbMultiByte,
                                lpWideCharStr,
                                cchWideChar );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UTF8ToUnicode( lpMultiByteStr,
                                cbMultiByte,
                                lpWideCharStr,
                                cchWideChar,
                                dwFlags);
            break;
        }
    }

    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF
//
//  Maps a Unicode character string to its UTF string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cbMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of WC string is 0
    //     - multibyte buffer size is negative
    //     - WC string is NULL
    //     - length of WC string is NOT zero AND
    //         (MB string is NULL OR src and dest pointers equal)
    //     - lpDefaultChar and lpUsedDefaultChar not NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cchWideChar == 0) || (cbMultiByte < 0) ||
         (lpWideCharStr == NULL) ||
         ((cbMultiByte != 0) &&
          ((lpMultiByteStr == NULL) ||
           (lpWideCharStr == (LPWSTR)lpMultiByteStr))) ||
         (lpDefaultChar != NULL) || (lpUsedDefaultChar != NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - flags not 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cchWideChar is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cchWideChar <= -1)
    {
        cchWideChar = NlsStrLenW(lpWideCharStr) + 1;
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UnicodeToUTF7( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cbMultiByte );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UnicodeToUTF8( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cbMultiByte );
            break;
        }
    }

    return (rc);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UTF7ToUnicode
//
//  Maps a UTF-7 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    //CHAR is signed, so we have to cast lpSrcStr to an unsigned char below.
    BYTE* pUTF7 = (BYTE*)lpSrcStr;    
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer to hold temporary bits
    int iPos = 0;                 // 6-bit position pointer in the buffer
    int cchWC = 0;                // # of Unicode code points generated


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        if (*pUTF7 > ASCII)
        {
            //
            //  Error - non ASCII char, so zero extend it.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF7;
            }
            cchWC++;
            // Terminate the shifted sequence.
            fShift = FALSE;
        }
        else if (!fShift)
        {
            //
            //  Not in shifted sequence.
            //
            if (*pUTF7 == SHIFT_IN)
            {
                if (cchSrc && (pUTF7[1] == SHIFT_OUT))
                {
                    //
                    //  "+-" means "+"
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    pUTF7++;
                    cchSrc--;
                    cchWC++;
                }
                else
                {
                    //
                    //  Start a new shift sequence.
                    //
                    fShift = TRUE;
                }
            }
            else
            {
                //
                //  No need to shift.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = (WCHAR)*pUTF7;
                }
                cchWC++;
            }
        }
        else
        {
            //
            //  Already in shifted sequence.
            //
            if (nBitBase64[*pUTF7] == -1)
            {
                //
                //  Any non Base64 char also ends shift state.
                //
                if (*pUTF7 != SHIFT_OUT)
                {
                    //
                    //  Not "-", so write it to the buffer.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    cchWC++;
                }

                //
                //  Reset bits.
                //
                fShift = FALSE;
                dwBit = 0;
                iPos = 0;
            }
            else
            {
                //
                //  Store the bits in the 6-bit buffer and adjust the
                //  position pointer.
                //
                dwBit |= ((DWORD)nBitBase64[*pUTF7]) << (26 - iPos);
                iPos += 6;
            }

            //
            //  Output the 16-bit Unicode value.
            //
            while (iPos >= 16)
            {
                if (cchDest)
                {
                    if (cchWC < cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)(dwBit >> 16);
                    }
                    else
                    {
                        break;
                    }
                }
                cchWC++;

                dwBit <<= 16;
                iPos -= 16;
            }
            if (iPos >= 16)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }

        pUTF7++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        if (cchSrc == 0 && fShift && *(pUTF7--) == SHIFT_OUT)
        {
            //
            // Do nothing here.
            // If we are in shift-in mode previously, and the last byte is a shift-out byte ('-'),
            // we should absorb this byte.  So don't set error.
            //
        } else
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  04-22-2002    ShawnSte  Fix bug 533476 where final characters are broken.
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest,
    DWORD dwFlags
    )
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    CONST BYTE* pUTF8 = (CONST BYTE*)lpSrcStr;
    DWORD dwUnicodeChar;           // Our character with room for full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    BOOL bCheckInvalidBytes = (dwFlags & MB_ERR_INVALID_CHARS);
    BYTE UTF8;

    // Note that we can't test destination buffer length here because we may have to
    // iterate through thousands of broken characters which won't be output, even though
    // the buffer has no more room.
    while (cchSrc--)
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                // In this function always test buffer size before using it
                if (cchWC >= cchDest)
                {
                    // Error: Buffer too small, we didn't process this character
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            nTB = bSurrogatePair = 0;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                // Add room for trail byte and add the trail byte falue
                dwUnicodeChar <<= 6;
                dwUnicodeChar |= LOWER_6_BIT(*pUTF8);

                // If we're done then we may need to store the data
                if (nTB == 0)
                {
                    if (bSurrogatePair)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) >= cchDest)
                            {
                                // Error: Buffer too small, we didn't process this character
                                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                                return (0);
                            }                                

                            lpDestStr[cchWC]   = (WCHAR)
                                                 (((dwUnicodeChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                            lpDestStr[cchWC+1] = (WCHAR)
                                                 ((dwUnicodeChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                        }

                        //
                        //  End of sequence.  Advance the output counter, turn off surrogateness
                        //
                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                    else
                    {
                        if (cchDest)
                        {
                            
                            if (cchWC >= cchDest)
                            {
                                // Error: Buffer too small, we didn't process this character
                                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                                return (0);
                            }

                            lpDestStr[cchWC] = (WCHAR)dwUnicodeChar;            
                        }

                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                      
                }
                        
            }
            else
            {
                if (bCheckInvalidBytes) 
                {
                    SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                    return (0);
                }
                
                // error - not expecting a trail byte. That is, there is a trailing byte without leading byte.
                bSurrogatePair = FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                // error - A leading byte before the previous sequence is completed.
                if (bCheckInvalidBytes) 
                {
                    SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                    return (0);
                }            
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                bSurrogatePair = FALSE;
                // Put this character back so that we can start over another sequence.
                cchSrc++;
                pUTF8--;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                // Recover the data from the byte
                UTF8 >>= nTB;

                //
                // Check for non-shortest form.
                // 
                switch (nTB)
                {
                    case 1:
                        nTB = 0;
                        break;
                    case 2:
                        // Make sure that bit 8 ~ bit 11 is not all zero.
                        // 110XXXXx 10xxxxxx
                        if ((*pUTF8 & 0x1e) == 0)
                        {
                            nTB = 0;
                        }
                        break;
                    case 3:
                        // Look ahead to check for non-shortest form.
                        // 1110XXXX 10Xxxxxx 10xxxxxx
                        if (cchSrc >= 2)
                        {
                            if (((*pUTF8 & 0x0f) == 0) && (*(pUTF8 + 1) & 0x20) == 0)
                            {
                                nTB = 0;
                            }
                        }
                        break;
                    case 4:                    
                        //
                        // This is a surrogate unicode pair
                        //
                        if (cchSrc >= 3)
                        {
                            WORD word = (((WORD)*pUTF8) << 8) | *(pUTF8 + 1);
                            // Look ahead to check for non-shortest form.
                            // 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx                        
                            // Check if the 5 X bits are all zero.
                            // 0x0730 == 00000111 00110000
                            if ( (word & 0x0730) == 0 ||
                                  // If the 21st bit is 1, we have extra work
                                  ( (word & 0x0400) == 0x0400 &&
                                     // The 21st bit is 1.
                                     // Make sure that the resulting Unicode is within the valid surrogate range.
                                     // The 4 byte code sequence can hold up to 21 bits, and the maximum valid code point range
                                     // that Unicode (with surrogate) could represent are from U+000000 ~ U+10FFFF.
                                     // Therefore, if the 21 bit (the most significant bit) is 1, we should verify that the 17 ~ 20
                                     // bit are all zero.
                                     // I.e., in 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx,
                                     // XXXXX can only be 10000.    
                                     // 0x0330 = 0000 0011 0011 0000
                                    (word & 0x0330) != 0 ) )
                            {
                                // Not shortest form
                                nTB = 0;
                            }                              
                            else
                            { 
                                // A real surrogate pair
                                bSurrogatePair = TRUE;
                            }
                        }                        
                        break;
                    default:                    
                        // 
                        // If the bits is greater than 4, this is an invalid
                        // UTF8 lead byte.
                        //
                        nTB = 0;
                        break;
                }

                if (nTB != 0) 
                {
                    //
                    //  Store the value from the first byte and decrement
                    //  the number of bytes to follow.
                    //
                    dwUnicodeChar = UTF8;
                    nTB--;
                } else 
                {
                    if (bCheckInvalidBytes) 
                    {
                        SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                        return (0);
                    }                 
                }
            }
        }
        pUTF8++;
    }

    if ((bCheckInvalidBytes && nTB != 0) || (cchWC == 0)) 
    {
        // About (cchWC == 0):
        // Because we now throw away non-shortest form, it is possible that we generate 0 chars.
        // In this case, we have to set error to ERROR_NO_UNICODE_TRANSLATION so that we conform
        // to the spec of MultiByteToWideChar.
        SetLastError(ERROR_NO_UNICODE_TRANSLATION);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF7
//
//  Maps a Unicode character string to its UTF-7 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer
    int iPos = 0;                 // 6-bit position in buffer
    int cchU7 = 0;                // # of UTF7 chars generated


    while ((cchSrc--) && ((cchDest == 0) || (cchU7 < cchDest)))
    {
        if ((*lpWC > ASCII) || (fShiftChar[*lpWC]))
        {
            //
            //  Need shift.  Store 16 bits in buffer.
            //
            dwBit |= ((DWORD)*lpWC) << (16 - iPos);
            iPos += 16;

            if (!fShift)
            {
                //
                //  Not in shift state, so add "+".
                //
                if (cchDest)
                {
                    lpDestStr[cchU7] = SHIFT_IN;
                }
                cchU7++;

                //
                //  Go into shift state.
                //
                fShift = TRUE;
            }

            //
            //  Output 6 bits at a time as Base64 chars.
            //
            while (iPos >= 6)
            {
                if (cchDest)
                {
                    if (cchU7 < cchDest)
                    {
                        //
                        //  26 = 32 - 6
                        //
                        lpDestStr[cchU7] = cBase64[(int)(dwBit >> 26)];
                    }
                    else
                    {
                        break;
                    }
                }

                cchU7++;
                dwBit <<= 6;           // remove from bit buffer
                iPos -= 6;             // adjust position pointer
            }
            if (iPos >= 6)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }
        else
        {
            //
            //  No need to shift.
            //
            if (fShift)
            {
                //
                //  End the shift sequence.
                //
                fShift = FALSE;

                if (iPos != 0)
                {
                    //
                    //  Some bits left in dwBit.
                    //
                    if (cchDest)
                    {
                        if ((cchU7 + 1) < cchDest)
                        {
                            lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                    else
                    {
                        cchU7 += 2;
                    }

                    dwBit = 0;         // reset bit buffer
                    iPos  = 0;         // reset postion pointer
                }
                else
                {
                    //
                    //  Simply end the shift sequence.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchU7++] = SHIFT_OUT;
                    }
                    else
                    {
                        cchU7++;
                    }
                }
            }

            //
            //  Write the character to the buffer.
            //  If the character is "+", then write "+-".
            //
            if (cchDest)
            {
                if (cchU7 < cchDest)
                {
                    lpDestStr[cchU7++] = (char)*lpWC;

                    if (*lpWC == SHIFT_IN)
                    {
                        if (cchU7 < cchDest)
                        {
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU7++;

                if (*lpWC == SHIFT_IN)
                {
                    cchU7++;
                }
            }
        }

        lpWC++;
    }

    //
    //  See if we're still in the shift state.
    //
    if (fShift)
    {
        if (iPos != 0)
        {
            //
            //  Some bits left in dwBit.
            //
            if (cchDest)
            {
                if ((cchU7 + 1) < cchDest)
                {
                    lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                    lpDestStr[cchU7++] = SHIFT_OUT;
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                }
            }
            else
            {
                cchU7 += 2;
            }
        }
        else
        {
            //
            //  Simply end the shift sequence.
            //
            if (cchDest)
            {
                if (cchU7 < cchDest) 
                {
                    lpDestStr[cchU7++] = SHIFT_OUT;
                } 
                else 
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                }
            }
            else
            {
                cchU7++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-7 characters written.
    //
    return (cchU7);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    int     cchU8 = 0;                // # of UTF8 chars generated
    DWORD   dwSurrogateChar;
    WCHAR   wchHighSurrogate = 0;
    BOOL    bHandled;


    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 |
                                               (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte

                         lpDestStr[cchU8++] =  (UTF8_TRAIL |
                                                (unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 ++;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= ASCII)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    if (cchU8 < cchDest) 
                    {
                        lpDestStr[cchU8] = (char)*lpWC;
                    } 
                    else 
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\util.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    util.c

Abstract:

    This file contains utility functions that are shared across NLS's code
    modules, but are not necessarily part of any of the existing code
    modules.

    Private APIs found in this file:
      NlsGetCacheUpdateCount

    External Routines found in this file:
      IsValidSeparatorString
      IsValidGroupingString
      IsValidCalendarType
      IsValidCalendarTypeStr
      GetUserInfo
      GetPreComposedChar
      GetCompositeChars
      InsertPreComposedForm
      InsertFullWidthPreComposedForm
      InsertCompositeForm
      NlsConvertIntegerToString
      NlsConvertIntegerToHexStringW
      NlsConvertStringToIntegerW      
      NlsStrLenW
      NlsStrEqualW
      NlsStrNEqualW
      GetStringTableEntry
      NlsIsDll
      
      
Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"



//-------------------------------------------------------------------------//
//                         PRIVATE API ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsGetCacheUpdateCount
//
//  Returns the current cache update count.  The cache update count is
//  updated whenever the HKCU\Control Panel\International settings are
//  modified.  This count allows the caller to see if the cache has been
//  updated since the last time this function was called.
//
//  This private api is needed by the Complex Script Language Pack
//  (CSLPK) to enable it to quickly see if the international section of
//  the registry has been modified.
//
////////////////////////////////////////////////////////////////////////////

ULONG WINAPI NlsGetCacheUpdateCount(void)
{
    return (pNlsUserInfo->ulCacheUpdateCount);
}





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  IsValidSeparatorString
//
//  Returns TRUE if the given string is valid.  Otherwise, it returns FALSE.
//
//  A valid string is one that does NOT contain any code points between
//  L'0' and L'9', and does NOT have a length greater than the maximum.
//
//  NOTE:  The string must be a null terminated string.
//
//  10-12-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidSeparatorString(
    LPCWSTR pString,
    ULONG MaxLength,
    BOOL fCheckZeroLen)
{
    ULONG Length;            // string length
    LPWSTR pCur;             // ptr to current position in string


    //
    //  Search down the string to see if the chars are valid.
    //  Save the length of the string.
    //
    pCur = (LPWSTR)pString;
    while (*pCur)
    {
        if ((*pCur >= NLS_CHAR_ZERO) && (*pCur <= NLS_CHAR_NINE))
        {
            //
            //  String is NOT valid.
            //
            return (FALSE);
        }
        pCur++;
    }
    Length = (ULONG)(pCur - (LPWSTR)pString);

    //
    //  Make sure the length is not greater than the maximum allowed.
    //  Also, check for 0 length string (if appropriate).
    //
    if ((Length >= MaxLength) ||
        ((fCheckZeroLen) && (Length == 0)))
    {
        //
        //  String is NOT valid.
        //
        return (FALSE);
    }

    //
    //  String is valid.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidGroupingString
//
//  Returns TRUE if the given string is valid.  Otherwise, it returns FALSE.
//
//  A valid string is one that begins and ends with a number between
//  L'0' and L'9', alternates between a number and a semicolon, and does
//  NOT have a length greater than the maximum.
//        (eg. 3;2;0  or  3;0  or  0  or  3)
//
//  NOTE:  The string must be a null terminated string.
//
//  01-05-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidGroupingString(
    LPCWSTR pString,
    ULONG MaxLength,
    BOOL fCheckZeroLen)
{
    ULONG Length;            // string length
    LPWSTR pCur;             // ptr to current position in string


    //
    //  Search down the string to see if the chars are valid.
    //  Save the length of the string.
    //
    pCur = (LPWSTR)pString;
    while (*pCur)
    {
        if ((*pCur < NLS_CHAR_ZERO) || (*pCur > NLS_CHAR_NINE))
        {
            //
            //  String is NOT valid.
            //
            return (FALSE);
        }
        pCur++;

        if (*pCur)
        {
            if ((*pCur != NLS_CHAR_SEMICOLON) || (*(pCur + 1) == 0))
            {
                //
                //  String is NOT valid.
                //
                return (FALSE);
            }
            pCur++;
        }
    }
    Length = (ULONG)(pCur - (LPWSTR)pString);

    //
    //  Make sure the length is not greater than the maximum allowed.
    //  Also, check for 0 length string (if appropriate).
    //
    if ((Length >= MaxLength) ||
        ((fCheckZeroLen) && (Length == 0)))
    {
        //
        //  String is NOT valid.
        //
        return (FALSE);
    }

    //
    //  String is valid.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidCalendarType
//
//  Returns the pointer to the optional calendar structure if the given
//  calendar type is valid for the given locale.  Otherwise, it returns
//  NULL.
//
//  10-12-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LPWORD IsValidCalendarType(
    PLOC_HASH pHashN,
    CALID CalId)
{
    LPWORD pOptCal;          // ptr to list of optional calendars
    LPWORD pEndOptCal;       // ptr to end of list of optional calendars


    //
    //  Make sure the Cal Id is not zero, since that may be in the
    //  optional calendar section (meaning no optional calendars).
    //
    if (CalId == 0)
    {
        return (NULL);
    }

    //
    //  Search down the list of optional calendars.
    //
    pOptCal = (LPWORD)(pHashN->pLocaleHdr) + pHashN->pLocaleHdr->IOptionalCal;
    pEndOptCal = (LPWORD)(pHashN->pLocaleHdr) + pHashN->pLocaleHdr->SDayName1;
    while (pOptCal < pEndOptCal)
    {
        //
        //  Check the calendar ids.
        //
        if (CalId == ((POPT_CAL)pOptCal)->CalId)
        {
            //
            //  Calendar id is valid for the given locale.
            //
            return (pOptCal);
        }

        //
        //  Increment to the next optional calendar.
        //
        pOptCal += ((POPT_CAL)pOptCal)->Offset;
    }

    //
    //  Calendar id is NOT valid if this point is reached.
    //
    return (NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidCalendarTypeStr
//
//  Converts the calendar string to an integer and validates the calendar
//  id for the given locale.  It return a pointer to the optional calendar
//  structure, or null if the calendar id was invalid.
//
//  10-19-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LPWORD IsValidCalendarTypeStr(
    PLOC_HASH pHashN,
    LPCWSTR pCalStr)
{
    UNICODE_STRING ObUnicodeStr;       // value string
    CALID CalNum;                      // calendar id


    //
    //  Convert the string to an integer value.
    //
    RtlInitUnicodeString(&ObUnicodeStr, pCalStr);
    if (RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &CalNum))
    {
        return (NULL);
    }

    //
    //  Validate the calendar id and return the pointer to the
    //  optional calendar structure.
    //
    return (IsValidCalendarType(pHashN, CalNum));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCPFileNameFromRegistry
//
//  Gets the name of the code page file from the registry.  If pResultBuf
//  or Size == 0, then just return true if it exists in the registry, but
//  don't return the actual value.
//
//  05-31-2002  ShawnSte    Created.
////////////////////////////////////////////////////////////////////////////

BOOL GetCPFileNameFromRegistry(
    UINT    CodePage,
    LPWSTR  pResultBuf,
    UINT    Size)
{
    // Working things.
    WCHAR pTmpBuf[MAX_SMALL_BUF_LEN];            // temp buffer
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer

    //
    //  Convert value to unicode string.
    //
    if (!NT_SUCCESS(NlsConvertIntegerToString( CodePage,
                                               10,
                                               0,
                                               pTmpBuf,
                                               MAX_SMALL_BUF_LEN )))
    {
        // Didn't work.  (Don't bother closing key though, its used globally)
        return (FALSE);
    }

    // Open hCodePageKey, return false if it fails
    OPEN_CODEPAGE_KEY(FALSE);

    //
    //  Query the registry value for that code page.
    //    
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic; 
    if ( NO_ERROR != QueryRegValue( hCodePageKey,
                                    pTmpBuf,
                                    &pKeyValueFull,
                                    MAX_KEY_VALUE_FULLINFO,
                                    NULL ) )
    {
        // Didn't work.  (Don't bother closing key though, its used globally)
        return (FALSE);
    }                     

    //
    //  Make sure there is data with this value.
    //
    if (GET_VALUE_DATA_PTR(pKeyValueFull)[0] == 0)
    {
        // Nope, no file name for this code page.  (Not installed).
        return (FALSE);
    }      

    // It worked, see if that's all they wanted.
    if (!pResultBuf || Size == 0)
    {
        // Caller didn't want the name, just to know if it was there
        return (TRUE);
    }

    // Now we have to copy the name to their buffer for them.
    if ( FAILED(StringCchCopyW(pResultBuf, Size, GET_VALUE_DATA_PTR(pKeyValueFull))))
    {
        // Couldn't make the string right, so fail
        return (FALSE);
    }

    // Yea, it worked
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  GetUserInfoFromRegistry
//
//  Gets the information from the registry for the given value entry.
//
//  06-11-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL GetUserInfoFromRegistry(
    LPWSTR pValue,
    LPWSTR pOutput,
    size_t cchOutput,
    LCID Locale)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    HANDLE hKey = NULL;                          // handle to intl key
    ULONG rc = 0L;                               // return code


    //
    //  Open the Control Panel International registry key.
    //
    OPEN_CPANEL_INTL_KEY(hKey, FALSE, KEY_READ);

    //
    //  Initialize the output string.
    //
    *pOutput = 0;

    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;

    //
    //  Check to be sure the current user is running in the given locale.
    //    
    if (Locale)
    {
        if (NO_ERROR == QueryRegValue( hKey,
                    L"Locale",
                    &pKeyValueFull,
                    MAX_KEY_VALUE_FULLINFO,
                    NULL ))
        {
            UINT uiLocale;
            
            if (NlsConvertStringToIntegerW(GET_VALUE_DATA_PTR(pKeyValueFull), 16, -1, &uiLocale) &&
               uiLocale != Locale)
            {
                CLOSE_REG_KEY(hKey);
                return FALSE;
            }
        }            
    }

    //
    //  Query the registry value.
    //    
    rc = QueryRegValue( hKey,
                        pValue,
                        &pKeyValueFull,
                        MAX_KEY_VALUE_FULLINFO,
                        NULL );

    //
    //  Close the registry key.
    //
    CLOSE_REG_KEY(hKey);

    //
    //  If the query failed or if the output buffer is not large enough,
    //  then return failure.
    //
    if ((rc != NO_ERROR) ||
        (pKeyValueFull->DataLength > (MAX_REG_VAL_SIZE * sizeof(WCHAR))))
    {
        return (FALSE);
    }

    //
    //  Save the string in pOutput.
    //
    if(FAILED(StringCchCopyW(pOutput, cchOutput, GET_VALUE_DATA_PTR(pKeyValueFull))))
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUserInfo
//
//  Gets the information from the registry for the given locale and user
//  value entry.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL GetUserInfo(
    LCID Locale,
    LCTYPE LCType,
    SIZE_T CacheOffset,
    LPWSTR pValue,
    LPWSTR pOutput,
    size_t cchOutput,
    BOOL fCheckNull)
{
    LCID UserLocale; 
    HRESULT hr;                   // return val for string copy
    LPWSTR pCacheString;


    //
    // Check if the current thread/process is impersonating
    // or running in the context of a user other than the
    // interactive one.
    //
    if (NT_SUCCESS( NlsGetCurrentUserNlsInfo( Locale,
                                              LCType,
                                              pValue,
                                              pOutput,
                                              cchOutput,
                                              FALSE )))
    {
        //
        //  See if we need to check for a null string.
        //
        if ((fCheckNull) && (*pOutput == 0))
        {
            return (FALSE);
        }

        return (TRUE);
    }

    //
    // Running in the same security context as the logged-on user.
    //


    RtlEnterCriticalSection(&gcsNlsProcessCache);
    if (pNlsUserInfo->ulCacheUpdateCount != pServerNlsUserInfo->ulCacheUpdateCount) 
    {
        //
        // The cache content is out of date.  Server has the latest copy of the cache, call server to update the
        // the cache.
        //
        {
            if (!NT_SUCCESS(CsrBasepNlsGetUserInfo(pNlsUserInfo, sizeof(NLS_USER_INFO))))
            {
                RtlLeaveCriticalSection(&gcsNlsProcessCache);
                //
                // The call to client failed, try to get the data from table.
                return (FALSE);
            }
        }
        //
        // If the call to server side succeeds, now we garantee that we have a complete
        // cache data, that is copied from the server side cache.  It will have the same
        // ulCacheUpdateCount in the time when the call to server side happens.
        //
    }

    //
    // We are in critical section here to check UserLocale to make sure that LCID and the data are in sync.
    //
    UserLocale = pNlsUserInfo->UserLocaleId;    

    //
    //  Check to be sure cached user locale is the same as the given locale.
    //
    if (Locale != UserLocale)
    {
        RtlLeaveCriticalSection(&gcsNlsProcessCache);
        return (FALSE);
    }
    
    pCacheString = (LPWSTR)((LPBYTE)pNlsUserInfo + CacheOffset);
    hr = StringCchCopyW(pOutput, MAX_REG_VAL_SIZE, pCacheString);
    RtlLeaveCriticalSection(&gcsNlsProcessCache);
    
    //
    //  Make sure the cache is valid.
    //
    //  Also, check for an invalid entry.  An invalid entry is marked
    //  with NLS_INVALID_INFO_CHAR in the first position of the string
    //  array.
    //
    if (FAILED(hr) || (*pOutput == NLS_INVALID_INFO_CHAR))
    {
        //
        //  The cache is invalid, so try getting the information directly
        //  from the registry.
        //
        return (GetUserInfoFromRegistry(pValue, pOutput, cchOutput, Locale));
    }

    //
    //  See if we need to check for a null string.
    //
    if ((fCheckNull) && (*pOutput == 0))
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPreComposedChar
//
//  Gets the precomposed character form of a given base character and
//  nonspacing character.  If there is no precomposed form for the given
//  character, it returns 0.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

WCHAR FASTCALL GetPreComposedChar(
    WCHAR wcNonSp,
    WCHAR wcBase)
{
    PCOMP_INFO pComp;             // ptr to composite information
    WORD BSOff = 0;               // offset of base char in grid
    WORD NSOff = 0;               // offset of nonspace char in grid
    int Index;                    // index into grid


    //
    //  Store the ptr to the composite information.  No need to check if
    //  it's a NULL pointer since all tables in the Unicode file are
    //  constructed during initialization.
    //
    pComp = pTblPtrs->pComposite;

    //
    //  Traverse 8:4:4 table for Base character offset.
    //
    BSOff = TRAVERSE_844_W(pComp->pBase, wcBase);
    if (!BSOff)
    {
        return (0);
    }

    //
    //  Traverse 8:4:4 table for NonSpace character offset.
    //
    NSOff = TRAVERSE_844_W(pComp->pNonSp, wcNonSp);
    if (!NSOff)
    {
        return (0);
    }

    //
    //  Get wide character value out of 2D grid.
    //  If there is no precomposed character at the location in the
    //  grid, it will return 0.
    //
    Index = (BSOff - 1) * pComp->NumNonSp + (NSOff - 1);
    return ((pComp->pGrid)[Index]);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCompositeChars
//
//  Gets the composite characters of a given wide character.  If the
//  composite form is found, it returns TRUE.  Otherwise, it returns
//  FALSE.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL GetCompositeChars(
    WCHAR wch,
    WCHAR *pNonSp,
    WCHAR *pBase)
{
    PPRECOMP pPreComp;            // ptr to precomposed information


    //
    //  Store the ptr to the precomposed information.  No need to check if
    //  it's a NULL pointer since all tables in the Unicode file are
    //  constructed during initialization.
    //
    pPreComp = pTblPtrs->pPreComposed;

    //
    //  Traverse 8:4:4 table for base and nonspace character translation.
    //
    TRAVERSE_844_D(pPreComp, wch, *pNonSp, *pBase);

    //
    //  Return success if found.  Otherwise, error.
    //
    return ((*pNonSp) && (*pBase));
}

////////////////////////////////////////////////////////////////////////////
//
//  InsertPreComposedForm
//
//  Gets the precomposed form of a given wide character string, places it in
//  the given wide character, and returns the number of composite characters
//  used to form the precomposed form.  If there is no precomposed form for
//  the given character, nothing is written into pPreComp and it returns 1
//  for the number of characters used.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL InsertPreComposedForm(
    LPCWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPWSTR pPreComp)
{
    WCHAR wch;                    // precomposed character
    LPWSTR pPos;                  // ptr to position in string


    //
    //  If no precomposed form can be found, return 1 character used
    //  (base character).
    //
    if (((pWCStr + 1) >= pEndWCStr) ||
        (!(wch = GetPreComposedChar(*(pWCStr + 1), *pWCStr))))
    {
        return (1);
    }

    //
    //  Get the precomposed character from the given wide character string.
    //  Must check for multiple nonspacing characters for the same
    //  precomposed character.
    //
    *pPreComp = wch;
    pPos = (LPWSTR)pWCStr + 2;
    while ((pPos < pEndWCStr) &&
           (wch = GetPreComposedChar(*pPos, *pPreComp)))
    {
        *pPreComp = wch;
        pPos++;
    }

    //
    //  Return the number of characters used to form the precomposed
    //  character.
    //
    return ((int)(pPos - (LPWSTR)pWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  InsertFullWidthPreComposedForm
//
//  Gets the full width precomposed form of a given wide character string,
//  places it in the given wide character, and returns the number of
//  composite characters used to form the precomposed form.  If there is
//  no precomposed form for the given character, only the full width conversion
//  of the first code point is written into pPreComp and it returns 1 for
//  the number of characters used.
//
//  11-04-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL InsertFullWidthPreComposedForm(
    LPCWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPWSTR pPreComp,
    PCASE pCase)
{
    WCHAR wch;                    // nonspace character
    LPWSTR pPos;                  // ptr to position in string


    //
    //  Get the case (if necessary).
    //
    *pPreComp = (pCase) ? GET_LOWER_UPPER_CASE(pCase, *pWCStr) : *pWCStr;

    //
    //  Get the full width.
    //
    *pPreComp = GET_FULL_WIDTH(pTblPtrs->pFullWidth, *pPreComp);

    if ((pPos = ((LPWSTR)pWCStr + 1)) >= pEndWCStr)
    {
        return (1);
    }

    while (pPos < pEndWCStr)
    {
        wch = (pCase) ? GET_LOWER_UPPER_CASE(pCase, *pPos) : *pPos;
        wch = GET_FULL_WIDTH(pTblPtrs->pFullWidth, wch);
        if (wch = GetPreComposedChar(wch, *pPreComp))
        {
            *pPreComp = wch;
            pPos++;
        }
        else
        {
            break;
        }
    }

    //
    //  Return the number of characters used to form the precomposed
    //  character.
    //
    return ((int)(pPos - (LPWSTR)pWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  InsertCompositeForm
//
//  Gets the composite form of a given wide character, places it in the
//  wide character string, and returns the number of characters written.
//  If there is no composite form for the given character, the wide character
//  string is not touched.  It will return 1 for the number of characters
//  written, since the base character was already written.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL InsertCompositeForm(
    LPWSTR pWCStr,
    LPWSTR pEndWCStr)
{
    WCHAR Base;                   // base character
    WCHAR NonSp;                  // non space character
    int wcCount = 0;              // number of wide characters written
    LPWSTR pEndComp;              // ptr to end of composite form
    int ctr;                      // loop counter


    //
    //  If no composite form can be found, return 1 for the base
    //  character that was already written.
    //
    if (!GetCompositeChars(*pWCStr, &NonSp, &Base))
    {
        return (1);
    }

    //
    //  Get the composite characters and write them to the pWCStr
    //  buffer.  Must check for multiple breakdowns of the precomposed
    //  character into more than 2 characters (multiple nonspacing
    //  characters).
    //
    pEndComp = pWCStr;
    do
    {
        //
        //  Make sure pWCStr is big enough to hold the nonspacing
        //  character.
        //
        if (pEndComp < (pEndWCStr - 1))
        {
            //
            //  Addition of next breakdown of nonspacing characters
            //  are to be added right after the base character.  So,
            //  move all nonspacing characters ahead one position
            //  to make room for the next nonspacing character.
            //
            pEndComp++;
            for (ctr = 0; ctr < wcCount; ctr++)
            {
                *(pEndComp - ctr) = *(pEndComp - (ctr + 1));
            }

            //
            //  Fill in the new base form and the new nonspacing character.
            //
            *pWCStr = Base;
            *(pWCStr + 1) = NonSp;
            wcCount++;
        }
        else
        {
            //
            //  Make sure we don't get into an infinite loop if the
            //  destination buffer isn't large enough.
            //
            break;
        }
    } while (GetCompositeChars(*pWCStr, &NonSp, &Base));

    //
    //  Return number of wide characters written.  Add 1 to include the
    //  base character.
    //
    return (wcCount + 1);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsConvertIntegerToString
//
//  This routine converts an integer to a Unicode string.
//
//  11-15-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG NlsConvertIntegerToString(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pResultBuf,
    UINT Size)
{
    UNICODE_STRING ObString;                // value string
    UINT ctr;                               // loop counter
    LPWSTR pBufPtr;                         // ptr to result buffer
    WCHAR pTmpBuf[MAX_PATH_LEN];            // ptr to temp buffer
    ULONG rc = 0L;                          // return code

    //
    //  Set up the Unicode string structure.
    //
    ObString.Length = (USHORT)(Size * sizeof(WCHAR));
    ObString.MaximumLength = (USHORT)(Size * sizeof(WCHAR));
    ObString.Buffer = pTmpBuf;

    //
    //  Get the value as a string.
    //
    if (rc = RtlIntegerToUnicodeString(Value, Base, &ObString))
    {
        return (rc);
    }

    //
    //  Pad the string with the appropriate number of zeros.
    //
    pBufPtr = pResultBuf;
    for (ctr = GET_WC_COUNT(ObString.Length);
         ctr < Padding;
         ctr++, pBufPtr++, Size--)
    {
        if( Size < 1 )
        {
            return(STATUS_UNSUCCESSFUL);
        }

        *pBufPtr = NLS_CHAR_ZERO;
    }

    if(FAILED(StringCchCopyW(pBufPtr, Size, ObString.Buffer)))
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////////
//
//  NlsConvertIntegerToHexStringW
//      Convert an integer value to an Unicode null-terminated string WITH 
//      leading zeros.  E.g. 0x409 with Width 5 will be converted to L"0409".
//      This function is faster than NlsConvertIntegerToString(), but it
//      only supports hex numbers.
//
//  Parameters:
//      Value   The number to be converted.
//      UpperCase   If TRUE, the hex digit will be uppercase.
//      Str     The buffer for the converted Unicode string.
//      Width   The character count of the buffer.  The value should be the total 
//              heximal digit number plus one for null-terminiated.
//              E.g. if the value is from 0x0000 - 0xffff, the Width should be 5.
//
//  Return:
//      TRUE if successful.  FALSE if the width is not big enough to hold the converted string.    
//
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL NlsConvertIntegerToHexStringW(UINT Value, BOOL UpperCase, PWSTR Str, UINT CharCount)
{
    int Digit;
    PWSTR p;

    if(Str == NULL)
    {
        return (FALSE);
    }
    
    p = Str + CharCount - 1;
    *p-- = L'\0';
    while (p >= Str)
    {
        Digit = Value & 0xf;
        if (Digit < 10)
        {
            Digit = Digit + L'0';
        }
        else
        {
            Digit = Digit - 10 + (UpperCase ? L'A' : L'a');
        }
        *p-- = (WCHAR)Digit;
        Value >>= 4;
    }    

    if (Value > 0)
    {
        //
        // There are still digit remaining.
        //
        return (FALSE);
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsConvertStringToIntegerW
//
//  Parameters:
//      Str     the hex string to be converted.
//      Base    base
//      CharCount   
//              the character count of the string (excluding the terminiated-null, if any). 
//              If the value is -1, this function assumes that
//              Str is a null-terminated string.
//      Result  the pointer to the result.
//
//  Result:
//      TRUE if the operation is successful.  FALSE if there is non-hex
//      character in the string.
//
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL NlsConvertStringToIntegerW(PWSTR Str, UINT Base, int CharCount, UINT* Result)
{
    int i;
    WCHAR Digit;
    WCHAR c;

    if (Str == NULL || Result == NULL)
    {
        return (FALSE);
    }
    
    *Result = 0;

    if (CharCount == -1)
    {
        while (c = *Str)
        {
            c = *Str;
            if (c >= L'0' && c <= L'9') 
            {
                Digit = c - L'0';
            }
            else if(Base == 16)
            {
                if (c >= L'A' && c <= L'F') 
                {
                    Digit = c - L'A' + 10;
                }
                else if (c >= L'a' && c <= L'f') 
                {
                    Digit = c - L'a' + 10;
                }
                else 
                {
                    return (FALSE);
                }
            }
            else
            {
                return (FALSE);
            }

            if (Base == 16)
            {
                *Result = (*Result << 4) | Digit;
            }
            else
            {
                *Result = *Result*10 + Digit;
            }

            Str++;
        }
    } else
    {
        for (i=0; i< CharCount; i++) {
            c = *Str++;
            if (c >= L'0' && c <= L'9') 
            {
                Digit = c - L'0';
            }
            else if(Base == 16)
            {
                if (c >= L'A' && c <= L'F') 
                {
                    Digit = c - L'A' + 10;
                }
                else if (c >= L'a' && c <= L'f') 
                {
                    Digit = c - L'a' + 10;
                }
                else 
                {
                    return (FALSE);
                }
            }
            else
            {
                return (FALSE);
            }

            if (Base == 16)
            {
                *Result = (*Result << 4) | Digit;
            }
            else
            {
                *Result = *Result*10 + Digit;
            }
        }
    }
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  NlsStrLenW
//
//  This routine returns the length of the given wide character string.
//  The length does NOT include the null terminator.
//
//  NOTE: This routine is here to avoid any dependencies on other DLLs
//        during initialization.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL NlsStrLenW(
    LPCWSTR pwsz)
{
    LPCWSTR pwszStart = pwsz;          // ptr to beginning of string

    loop:
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;

        goto loop;

    done:
        return ((int)(pwsz - pwszStart));
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsStrEqualW
//
//  This routine compares two strings to see if they are exactly identical.
//  It returns 1 if they are identical, 0 if they are different.
//
//  NOTE: This routine is here to avoid any dependencies on other DLLs
//        during initialization.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL NlsStrEqualW(
    LPCWSTR pwszFirst,
    LPCWSTR pwszSecond)
{
    loop:
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        goto loop;

    error:
        //
        //  Return error.
        //
        return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsStrNEqualW
//
//  This routine compares two strings to see if they are exactly identical
//  for the count of characters given.
//  It returns 1 if they are identical, 0 if they are different.
//
//  NOTE: This routine is here to avoid any dependencies on other DLLs
//        during initialization.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL NlsStrNEqualW(
    LPCWSTR pwszFirst,
    LPCWSTR pwszSecond,
    int Count)
{
    loop:
        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        goto loop;

    error:
        //
        //  Return error.
        //
        return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDefaultSortkeySize
//
////////////////////////////////////////////////////////////////////////////

ULONG GetDefaultSortkeySize(
    PLARGE_INTEGER pSize)
{
    *pSize = pTblPtrs->DefaultSortkeySize;
    return (STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLinguistLangSize
//
////////////////////////////////////////////////////////////////////////////

ULONG GetLinguistLangSize(
    PLARGE_INTEGER pSize)
{
    *pSize = pTblPtrs->LinguistLangSize;
    return (STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  ValidateLocale
//
//  Internal routine, called from server.  Validates that a locale is
//  present in the registry.  This code comes from IsValidLocale, but
//  does not check the internal data to prevent recursive calls to the
//  server.
//
////////////////////////////////////////////////////////////////////////////

BOOL ValidateLocale(
    LCID Locale)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;
    BYTE pStatic1[MAX_KEY_VALUE_FULLINFO];
    BYTE pStatic2[MAX_KEY_VALUE_FULLINFO];

    WCHAR pTmpBuf[MAX_PATH];           // temp buffer
    UNICODE_STRING ObUnicodeStr;       // registry data value string
    DWORD Data;                        // registry data value
    LPWSTR pData;                      // ptr to registry data
    BOOL bResult = FALSE;              // result value

    //
    //  Invalid Locale Check.
    //
    if (IS_INVALID_LOCALE(Locale))
    {
        return (FALSE);
    }

    //
    //  Open the Locale, the Alternate Sorts, and the Language Groups
    //  registry keys.
    //
    OPEN_LOCALE_KEY(FALSE);
    OPEN_ALT_SORTS_KEY(FALSE);
    OPEN_LANG_GROUPS_KEY(FALSE);

    //
    //  Convert locale value to Unicode string.
    //
    if (NlsConvertIntegerToString(Locale, 16, 8, pTmpBuf, MAX_PATH))
    {
        return (FALSE);
    }

    //
    //  Query the registry for the value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic1;
    if (((QueryRegValue( hLocaleKey,
                         pTmpBuf,
                         &pKeyValueFull,
                         MAX_KEY_VALUE_FULLINFO,
                         NULL ) == NO_ERROR) ||
         (QueryRegValue( hAltSortsKey,
                         pTmpBuf,
                         &pKeyValueFull,
                         MAX_KEY_VALUE_FULLINFO,
                         NULL ) == NO_ERROR)) &&
        (pKeyValueFull->DataLength > 2))
    {
        RtlInitUnicodeString(&ObUnicodeStr, GET_VALUE_DATA_PTR(pKeyValueFull));
        if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 16, &Data) == NO_ERROR) &&
            (Data != 0))
        {
            pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic2;
            if ((QueryRegValue( hLangGroupsKey,
                                ObUnicodeStr.Buffer,
                                &pKeyValueFull,
                                MAX_KEY_VALUE_FULLINFO,
                                NULL ) == NO_ERROR) &&
                (pKeyValueFull->DataLength > 2))
            {
                pData = GET_VALUE_DATA_PTR(pKeyValueFull);
                if ((pData[0] == L'1') && (pData[1] == 0))
                {
                    bResult = TRUE;
                }
            }
        }
    }

    //
    //  Return the result.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ValidateLCType
//
//  This routine is called from the server (and also from locale.c) in
//  order to get a Registry key name and a field pointer in the NlsInfo
//  structure given an LCType.
//
////////////////////////////////////////////////////////////////////////////

BOOL ValidateLCType(
    PNLS_USER_INFO pInfo,
    LCTYPE LCType,
    LPWSTR *ppwReg,
    LPWSTR *ppwCache)
{
    switch (LCType)
    {
        case ( LOCALE_IFIRSTWEEKOFYEAR ) :
        {
            *ppwReg = NLS_VALUE_IFIRSTWEEKOFYEAR;
            *ppwCache = pInfo->iFirstWeek;
            break;
        }
        case ( LOCALE_IFIRSTDAYOFWEEK ) :
        {
            *ppwReg = NLS_VALUE_IFIRSTDAYOFWEEK;
            *ppwCache = pInfo->iFirstDay;
            break;
        }
        case ( LOCALE_ICALENDARTYPE ) :
        {
            *ppwReg = NLS_VALUE_ICALENDARTYPE;
            *ppwCache = pInfo->iCalType;
            break;
        }
        case ( LOCALE_SLONGDATE ) :
        {
            *ppwReg = NLS_VALUE_SLONGDATE;
            *ppwCache = pInfo->sLongDate;
            break;
        }
        case ( LOCALE_SYEARMONTH ) :
        {
            *ppwReg = NLS_VALUE_SYEARMONTH;
            *ppwCache = pInfo->sYearMonth;
            break;
        }
        case ( LOCALE_S1159 ) :
        {
            *ppwReg = NLS_VALUE_S1159;
            *ppwCache = pInfo->s1159;
            break;
        }
        case ( LOCALE_SNEGATIVESIGN ) :
        {
            *ppwReg = NLS_VALUE_SNEGATIVESIGN;
            *ppwCache = pInfo->sNegSign;
            break;
        }
        case ( LOCALE_SPOSITIVESIGN ) :
        {
            *ppwReg = NLS_VALUE_SPOSITIVESIGN;
            *ppwCache = pInfo->sPosSign;
            break;
        }
        case ( LOCALE_INEGCURR ) :
        {
            *ppwReg = NLS_VALUE_INEGCURR;
            *ppwCache = pInfo->iNegCurr;
            break;
        }
        case ( LOCALE_ICURRENCY ) :
        {
            *ppwReg = NLS_VALUE_ICURRENCY;
            *ppwCache = pInfo->iCurrency;
            break;
        }
        case ( LOCALE_ICURRDIGITS ) :
        {
            *ppwReg = NLS_VALUE_ICURRDIGITS;
            *ppwCache = pInfo->iCurrDigits;
            break;
        }
        case ( LOCALE_SMONGROUPING ) :
        {
            *ppwReg = NLS_VALUE_SMONGROUPING;
            *ppwCache = pInfo->sMonGrouping;
            break;
        }
        case ( LOCALE_SMONTHOUSANDSEP ) :
        {
            *ppwReg = NLS_VALUE_SMONTHOUSANDSEP;
            *ppwCache = pInfo->sMonThouSep;
            break;
        }
        case ( LOCALE_SMONDECIMALSEP ) :
        {
            *ppwReg = NLS_VALUE_SMONDECIMALSEP;
            *ppwCache = pInfo->sMonDecSep;
            break;
        }
        case ( LOCALE_SCURRENCY ) :
        {
            *ppwReg = NLS_VALUE_SCURRENCY;
            *ppwCache = pInfo->sCurrency;
            break;
        }
        case ( LOCALE_IDIGITSUBSTITUTION ) :
        {
            *ppwReg = NLS_VALUE_IDIGITSUBST;
            *ppwCache = pInfo->iDigitSubstitution;
            break;
        }
        case ( LOCALE_SNATIVEDIGITS ) :
        {
            *ppwReg = NLS_VALUE_SNATIVEDIGITS;
            *ppwCache = pInfo->sNativeDigits;
            break;
        }
        case ( LOCALE_INEGNUMBER ) :
        {
            *ppwReg = NLS_VALUE_INEGNUMBER;
            *ppwCache = pInfo->iNegNumber;
            break;
        }
        case ( LOCALE_ILZERO ) :
        {
            *ppwReg = NLS_VALUE_ILZERO;
            *ppwCache = pInfo->iLZero;
            break;
        }
        case ( LOCALE_IDIGITS ) :
        {
            *ppwReg = NLS_VALUE_IDIGITS;
            *ppwCache = pInfo->iDigits;
            break;
        }
        case ( LOCALE_SGROUPING ) :
        {
            *ppwReg = NLS_VALUE_SGROUPING;
            *ppwCache = pInfo->sGrouping;
            break;
        }
        case ( LOCALE_STHOUSAND ) :
        {
            *ppwReg = NLS_VALUE_STHOUSAND;
            *ppwCache = pInfo->sThousand;
            break;
        }
        case ( LOCALE_SDECIMAL ) :
        {
            *ppwReg = NLS_VALUE_SDECIMAL;
            *ppwCache = pInfo->sDecimal;
            break;
        }
        case ( LOCALE_IPAPERSIZE ) :
        {
            *ppwReg = NLS_VALUE_IPAPERSIZE;
            *ppwCache = pInfo->iPaperSize;
            break;
        }
        case ( LOCALE_IMEASURE ) :
        {
            *ppwReg = NLS_VALUE_IMEASURE;
            *ppwCache = pInfo->iMeasure;
            break;
        }
        case ( LOCALE_SLIST ) :
        {
            *ppwReg = NLS_VALUE_SLIST;
            *ppwCache = pInfo->sList;
            break;
        }
        case ( LOCALE_S2359 ) :
        {
            *ppwReg = NLS_VALUE_S2359;
            *ppwCache = pInfo->s2359;
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStringTableEntry
//
//  Returns the localized version of the strings for the given resource
//  id.  It gets the information from the resource file in the language that
//  the current user is using.
//
//  The string table contains a series of strings in the following order:
//      Language Name
//      Country Name
//      Language Group Name
//      Code Page Name               (decimal values converted to hex values)
//      Region (Geo) Friendly Name   (decimal values converted to hex values)
//      Region (Geo) Official Name   (decimal values converted to hex values)
//      Sorting Names                (in order starting with 0, separated by $)
//
//  Each string is separated by $.  The final string is terminated with
//  a null.
//
//  The sorting names are in order of the sort ids, starting with 0.
//
//  For example,
//    "Language$Country$LangGrp$CodePage$Geo1$Geo2$Sort0$Sort1"      or
//    "Language$Country"                                             or
//    "$$LangGrp$CodePage"                                           or
//    "$$$CodePage"                                                  or
//    "$$$$Geo1$Geo2"
//
//  11-17-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetStringTableEntry(
    UINT ResourceID,
    LANGID UILangId,
    LPWSTR pBuffer,
    int cchBuffer,
    int WhichString)
{
    HANDLE hFindRes;                   // handle from find resource
    HANDLE hLoadRes;                   // handle from load resource
    LPWSTR pSearch, pSearchEnd;        // ptrs to search for correct string
    LPWSTR pString;                    // ptr to final string
    int cchCount = 0;                  // count of characters


    //
    //  Make sure the buffer is ok.
    //
    if ((pBuffer == NULL) || (cchBuffer == 0))
    {
        return (0);
    }

    //
    //  Make sure we're not hitting the GEO ID that is out of bounds.
    //
    //  !!! NOTE !!! This is needed because the East Timor Geo Id
    //               is out of bounds and wraps to 0x60e7.
    //
    if (ResourceID == 0x60e7)
    {
        return (0);
    }

    //
    //  Set the UI Language Id.
    //
    if (UILangId == 0)
    {
        UILangId = GetUserDefaultUILanguage();
    }

    //
    //  String Tables are broken up into 16 string segments.  Find the
    //  resource containing the string we want.
    //
    if ((!(hFindRes = FindResourceExW( hModule,
                                       RT_STRING,
                                       (LPWSTR)UlongToPtr((ULONG)(((USHORT)ResourceID >> 4) + 1)),
                                       (WORD)UILangId ))))
    {
        //
        //  Could not find resource.  Try NEUTRAL language id.
        //
        if ((!(hFindRes = FindResourceExW( hModule,
                                           RT_STRING,
                                           (LPWSTR)UlongToPtr((ULONG)(((USHORT)ResourceID >> 4) + 1)),
                                           (WORD)0 ))))
        {
            //
            //  Could not find resource.  Return 0.
            //
            return (0);
        }
    }

    //
    //  Load the resource.
    //
    if (hLoadRes = LoadResource(hModule, hFindRes))
    {
        //
        //  Lock the resource.  Store the found pointer in the given
        //  pointer.
        //
        if (pSearch = (LPWSTR)LockResource(hLoadRes))
        {
            //
            //  Move past the other strings in this segment.
            //     (16 strings in a segment -> & 0x0F)
            //
            ResourceID &= 0x0F;

            //
            //  Find the correct string in this segment.
            //
            while (TRUE)
            {
                cchCount = *((WORD *)pSearch++);
                if (ResourceID-- == 0)
                {
                    break;
                }
                pSearch += cchCount;
            }

            //
            //  Mark the end of the resource string since it is not
            //  NULL terminated.
            //
            pSearchEnd = pSearch + cchCount;

            //
            //  Get to the appropriate string.
            //
            while ((WhichString > 0) && (pSearch < pSearchEnd))
            {
                do
                {
                    if (*pSearch == RC_STRING_SEPARATOR)
                    {
                        pSearch++;
                        break;
                    }
                    pSearch++;

                } while (pSearch < pSearchEnd);

                WhichString--;
            }

            //
            //  Count the number of characters for this string.
            //
            pString = pSearch;
            cchCount = 0;
            while ((pSearch < pSearchEnd) && (*pSearch != RC_STRING_SEPARATOR))
            {
                pSearch++;
                cchCount++;
            }

            //
            //  See if there is anything to copy.
            //
            if (cchCount > 0)
            {
                //
                //  Don't copy more than the max allowed.
                //
                if (cchCount >= cchBuffer)
                {
                    cchCount = cchBuffer - 1;
                }

                //
                //  Copy the string into the buffer and NULL terminate it.
                //
                CopyMemory(pBuffer, pString, cchCount * sizeof(WCHAR));
                pBuffer[cchCount] = 0;

                //
                //  Return the number of characters in the string, not
                //  including the NULL terminator.
                //
                return (cchCount);
            }
        }
    }

    //
    //  Return failure.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsIsDll
//
//  Check if file extension is DLL
//
////////////////////////////////////////////////////////////////////////////

#define DLL_SUFFIX_LENGTH 4 // (.XXX)

BOOL FASTCALL NlsIsDll(
    LPCWSTR pFileName
)
{
    BOOL bIsDll = FALSE;
    

    if (pFileName)
    {
        size_t iLen = 0;

        if(SUCCEEDED(StringCchLengthW(pFileName, MAX_PATH, &iLen)))
        { 
            //
            // Check DLL extension, save the trouble of calling lstricmpW
            //
            // REVIEW: lstricmpW would not be an appropriate function to
            //         call here anyway, since user locale collation 
            //         semantics != file system collation semantics.
            //        
            if (iLen > DLL_SUFFIX_LENGTH)
            {
                pFileName += iLen - DLL_SUFFIX_LENGTH;

                // 
                // File names are lower case in setup, so optimize for that
                // by putting them first.
                //
                if ((pFileName[0] == L'.') &&
                   (pFileName[1] == L'd' || pFileName[1] == L'D') &&
                   (pFileName[2] == L'l' || pFileName[2] == L'L') &&
                   (pFileName[3] == L'l' || pFileName[3] == L'L'))            
                {
                   bIsDll = TRUE;
                }
            }
        }
    }

    return bIsDll;
}

////////////////////////////////////////////////////////////////////////////
//
//  IsCodePointDefined
//
//  Check if the code point is defined.
//
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL IsSortingCodePointDefined(
    LPNLSVERSIONINFO lpVersionInformation,
    LPCWSTR lpString,
    INT cchStr
    )
{
    PNLSDEFINED pDefinedCodePoints = NULL;
    LPCWSTR pStringEnd;

    //
    //  Make sure the appropriate tables are available.  If not,
    //  return an error.
    //
    if ((pTblPtrs->pDefinedVersion == NULL) ||
        (pTblPtrs->pSortingTableFileBase == NULL) ||
        (pTblPtrs->pDefaultSortkey == NULL))
    {
        KdPrint(("NLSAPI: Appropriate Tables (Defined, Base and/or Default) Not Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (FALSE);
    }

    //
    //  Get the version.
    //
    if (lpVersionInformation != NULL)
    {
        UINT idx;

        //
        //  Buffer size check.
        //
        if (lpVersionInformation->dwNLSVersionInfoSize != sizeof(NLSVERSIONINFO)) 
        {
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            return (FALSE);
        }

        if ((lpVersionInformation->dwDefinedVersion == 0L) ||
           (lpVersionInformation->dwDefinedVersion == (pTblPtrs->pDefinedVersion)[0].Version))
        {
            // Use the current version.
            // Do nothing here. We let pDefinedCodePoints to be NULL, so that current table is used.
        } 
        else 
        {
            if (lpVersionInformation->dwDefinedVersion < pTblPtrs->NumDefinedVersion) {
                //
                //  Not the default version, get the the requested version.
                //
                pDefinedCodePoints = (PNLSDEFINED)(pTblPtrs->pSortingTableFileBase + (pTblPtrs->pDefinedVersion)[lpVersionInformation->dwDefinedVersion].dwOffset);
            }
            //
            //  Check if the version requested is valid.
            //
            if (pDefinedCodePoints == NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }
        }
    }

    pStringEnd = lpString + cchStr;
    //
    //  Check if we deal with the current version.
    //
    if (pDefinedCodePoints == NULL)
    {
        //
        //  Use the default table.                
        //
        //  For each code point verify is they exist
        //  in the table.
        //
        while (lpString < pStringEnd)
        {
            //
            //  Check is the fist script member is defined for this codepoint.
            //
            if ((pTblPtrs->pDefaultSortkey)[*lpString].UW.SM_AW.Script == UNSORTABLE)
            {
                //
                //  Check for the NULL case and formatting characters case. Not
                //  defined but valid.
                //
                if ((*lpString == L'\x0000') ||
                    (*lpString == L'\x0640') ||
                    ((*lpString >= L'\x180B') && (*lpString <= L'\x180E')) ||
                    ((*lpString >= L'\x200C') && (*lpString <= L'\x200F')) ||
                    ((*lpString >= L'\x202A') && (*lpString <= L'\x202E')) ||
                    ((*lpString >= L'\x206A') && (*lpString <= L'\x206F')) ||
                    (*lpString == L'\xFEFF') ||
                    (*lpString == L'\xFFF9') ||
                    ((*lpString >= L'\xFFFA') && (*lpString <= L'\xFFFD'))) 
                {
                    lpString++;
                    continue;
                }
                else
                {
                    return (FALSE);
                }
            }

            //
            //  Eliminate Private Use characters. They are defined but cannot be considered
            //  valid.
            //
            if ((*lpString >= L'\xE000') && (*lpString <= L'\xF8FF'))
            {
                return (FALSE);
            }

            //
            //  Eliminate invalid surogates pairs or single surrogates.
            //
            if ((*lpString >= L'\xDC00') && (*lpString <= L'\xDFFF')) // Leading low surrogate
            {
                return (FALSE);
            }
            else if ((*lpString >= L'\xD800') && (*lpString <= L'\xDBFF')) // Leading high surrogate
            {
                if ( ((lpString + 1) < pStringEnd) &&  // Surrogates not the last character
                     (*(lpString + 1) >= L'\xDC00') && (*(lpString + 1) <= L'\xDFFF')) // Low surrogate
                {
                    lpString++; // Valid surrogates pair, High followed by a low surrogate. Skip the pair!
                }
                else
                {
                    return (FALSE);
                }
            }

            lpString++;
        }
    }
    else
    {
        WORD wIndex;
        BYTE wMod32Val;

        while (lpString < pStringEnd)
        {
            //
            //  Compute the modulo 32 of the code point value.
            //
            wMod32Val = (BYTE)(*lpString & 0x0000001f); // 0x1fff => 5 bits

            //
            //  Compute the DWORD index that contain the desired code point.
            //
            wIndex = (WORD)(*lpString >> 5);
            
            //
            //  Get the DWORD aligned entry that contain the desired code point.
            //
            //  Note: We need to get a DWORD aligned value to make sure that we 
            //  that we don't access memory outside the table especially at the
            //  end of the table.
            //

            //
            //  Shift the value to retrieve information about code point at the
            //  position 0.
            //
            //
            //  Check is the code point is defined or not.
            //
            if ((pDefinedCodePoints[wIndex] >> wMod32Val) == 0)
            {
                // NOTENOTE YSLin: In NLSTrans, make sure that we mark U+0000 as 1, instead of 0.
                // NOTENOTE lguindon: In NLSTrans, make sure that we mark U+E000-U+F8FF as 0.
                // NOTENOTE lguindon: In NLSTrans, make sure that we mark U+070F as 1.
                // NOTENOTE lguindon: In NLSTrans, make sure that we mark U+0640 as 1.
                // NOTENOTE lguindon: In NLSTrans, make sure that we mark U+180B-U+180E as 1.
                // NOTENOTE lguindon: In NLSTrans, make sure that we mark U+200C-U+200F as 1.
                // NOTENOTE lguindon: In NLSTrans, make sure that we mark U+202A-U+202E as 1.
                // NOTENOTE lguindon: In NLSTrans, make sure that we mark U+206A-U+206F as 1.
                // NOTENOTE lguindon: In NLSTrans, make sure that we mark U+FEFF as 1.
                // NOTENOTE lguindon: In NLSTrans, make sure that we mark U+FFF9 as 1.
                // NOTENOTE lguindon: In NLSTrans, make sure that we mark U+FFFA-U+FFFD as 1.
                return (FALSE);
            }

            //
            //  Eliminate invalid surogates pairs or single surrogates.
            //
            if ((*lpString >= L'\xDC00') && (*lpString <= L'\xDFFF')) // Leading low surrogate
            {
                return (FALSE);
            }
            else if ((*lpString >= L'\xD800') && (*lpString <= L'\xDBFF')) // Leading high surrogate
            {
                if ( ((lpString + 1) < pStringEnd) &&  // Surrogates not the last character
                     (*(lpString + 1) >= L'\xDC00') && (*(lpString + 1) <= L'\xDFFF')) // Low surrogate
                {
                    lpString++; // Valid surrogates pair, High followed by a low surrogate. Skip the pair!
                }
                else
                {
                    return (FALSE);
                }
            }

            lpString++;
        }
    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\string.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    string.c

Abstract:

    This file contains functions that deal with characters and strings.

    APIs found in this file:
      CompareStringW
      GetStringTypeExW
      GetStringTypeW

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "nlssafe.h"
#include "jamo.h"




//
//  Constant Declarations.
//

//
//  State Table.
//
#define STATE_DW                  1    // normal diacritic weight state
#define STATE_REVERSE_DW          2    // reverse diacritic weight state
#define STATE_CW                  4    // case weight state
#define STATE_JAMO_WEIGHT         8    // jamo weight state


//
//  Invalid weight value.
//
#define CMP_INVALID_WEIGHT        0xffffffff
#define CMP_INVALID_FAREAST       0xffff0000
#define CMP_INVALID_UW            0xffff




//
//  Forward Declarations.
//

int
LongCompareStringW(
    PLOC_HASH pHashN,
    DWORD dwCmpFlags,
    LPCWSTR lpString1,
    int cchCount1,
    LPCWSTR lpString2,
    int cchCount2,
    BOOL fModify);

int
FindJamoDifference(
    PLOC_HASH pHashN,
    LPCWSTR* ppString1,
    int* ctr1,
    int cchCount1,
    DWORD* pWeight1,
    LPCWSTR* ppString2,
    int* ctr2,
    int cchCount2,
    DWORD* pWeight2,
    LPCWSTR* pLastJamo,
    WORD* uw1,
    WORD* uw2,
    int* pState,
    int* WhichJamo,
    BOOL fModify);





//-------------------------------------------------------------------------//
//                           INTERNAL MACROS                               //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NOT_END_STRING
//
//  Checks to see if the search has reached the end of the string.
//  It returns TRUE if the counter is not at zero (counting backwards) and
//  the null termination has not been reached (if -1 was passed in the count
//  parameter.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NOT_END_STRING(ct, ptr, cchIn)                                     \
    ((ct != 0) && (!((*(ptr) == 0) && (cchIn == -2))))


////////////////////////////////////////////////////////////////////////////
//
//  AT_STRING_END
//
//  Checks to see if the pointer is at the end of the string.
//  It returns TRUE if the counter is zero or if the null termination
//  has been reached (if -2 was passed in the count parameter).
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define AT_STRING_END(ct, ptr, cchIn)                                      \
    ((ct == 0) || ((*(ptr) == 0) && (cchIn == -2)))


////////////////////////////////////////////////////////////////////////////
//
//  REMOVE_STATE
//
//  Removes the current state from the state table.  This should only be
//  called when the current state should not be entered for the remainder
//  of the comparison.  It decrements the counter going through the state
//  table and decrements the number of states in the table.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define REMOVE_STATE(value)            (State &= ~value)


////////////////////////////////////////////////////////////////////////////
//
//  POINTER_FIXUP
//
//  Fixup the string pointers if expansion characters were found.
//  Then, advance the string pointers and decrement the string counters.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define POINTER_FIXUP()                                                    \
{                                                                          \
    /*                                                                     \
     *  Fixup the pointers (if necessary).                                 \
     */                                                                    \
    if (pSave1 && (--cExpChar1 == 0))                                      \
    {                                                                      \
        /*                                                                 \
         *  Done using expansion temporary buffer.                         \
         */                                                                \
        pString1 = pSave1;                                                 \
        pSave1 = NULL;                                                     \
    }                                                                      \
                                                                           \
    if (pSave2 && (--cExpChar2 == 0))                                      \
    {                                                                      \
        /*                                                                 \
         *  Done using expansion temporary buffer.                         \
         */                                                                \
        pString2 = pSave2;                                                 \
        pSave2 = NULL;                                                     \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Advance the string pointers.                                       \
     */                                                                    \
    pString1++;                                                            \
    pString2++;                                                            \
}


////////////////////////////////////////////////////////////////////////////
//
//  SCAN_LONGER_STRING
//
//  Scans the longer string for diacritic, case, and special weights.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define SCAN_LONGER_STRING( ct,                                            \
                            ptr,                                           \
                            cchIn,                                         \
                            ret )                                          \
{                                                                          \
    /*                                                                     \
     *  Search through the rest of the longer string to make sure          \
     *  all characters are not to be ignored.  If find a character that    \
     *  should not be ignored, return the given return value immediately.  \
     *                                                                     \
     *  The only exception to this is when a nonspace mark is found.  If   \
     *  another DW difference has been found earlier, then use that.       \
     */                                                                    \
    while (NOT_END_STRING(ct, ptr, cchIn))                                 \
    {                                                                      \
        Weight1 = GET_DWORD_WEIGHT(pHashN, *ptr);                          \
        switch (GET_SCRIPT_MEMBER(&Weight1))                               \
        {                                                                  \
            case ( UNSORTABLE ):                                           \
            {                                                              \
                break;                                                     \
            }                                                              \
            case ( NONSPACE_MARK ):                                        \
            {                                                              \
                if ((!fIgnoreDiacritic) && (!WhichDiacritic))              \
                {                                                          \
                    return (ret);                                          \
                }                                                          \
                break;                                                     \
            }                                                              \
            case ( PUNCTUATION ) :                                         \
            case ( SYMBOL_1 ) :                                            \
            case ( SYMBOL_2 ) :                                            \
            case ( SYMBOL_3 ) :                                            \
            case ( SYMBOL_4 ) :                                            \
            case ( SYMBOL_5 ) :                                            \
            {                                                              \
                if (!fIgnoreSymbol)                                        \
                {                                                          \
                    return (ret);                                          \
                }                                                          \
                break;                                                     \
            }                                                              \
            case ( EXPANSION ) :                                           \
            case ( FAREAST_SPECIAL ) :                                     \
            case ( JAMO_SPECIAL ) :                                        \
            case ( EXTENSION_A ) :                                         \
            default :                                                      \
            {                                                              \
                return (ret);                                              \
            }                                                              \
        }                                                                  \
                                                                           \
        /*                                                                 \
         *  Advance pointer and decrement counter.                         \
         */                                                                \
        ptr++;                                                             \
        ct--;                                                              \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Need to check diacritic, case, extra, and special weights for      \
     *  final return value.  Still could be equal if the longer part of    \
     *  the string contained only characters to be ignored.                \
     *                                                                     \
     *  NOTE:  The following checks MUST REMAIN IN THIS ORDER:             \
     *            Diacritic, Case, Extra, Punctuation.                     \
     */                                                                    \
    if (WhichDiacritic)                                                    \
    {                                                                      \
        return (WhichDiacritic);                                           \
    }                                                                      \
    if (WhichCase)                                                         \
    {                                                                      \
        return (WhichCase);                                                \
    }                                                                      \
    if (WhichExtra)                                                        \
    {                                                                      \
        if (!fIgnoreDiacritic)                                             \
        {                                                                  \
            if (GET_WT_FOUR(&WhichExtra))                                  \
            {                                                              \
                return (GET_WT_FOUR(&WhichExtra));                         \
            }                                                              \
            if (GET_WT_FIVE(&WhichExtra))                                  \
            {                                                              \
                return (GET_WT_FIVE(&WhichExtra));                         \
            }                                                              \
        }                                                                  \
        if (GET_WT_SIX(&WhichExtra))                                       \
        {                                                                  \
            return (GET_WT_SIX(&WhichExtra));                              \
        }                                                                  \
        if (GET_WT_SEVEN(&WhichExtra))                                     \
        {                                                                  \
            return (GET_WT_SEVEN(&WhichExtra));                            \
        }                                                                  \
    }                                                                      \
    if (WhichJamo)                                                         \
    {                                                                      \
        return (WhichJamo);                                                \
    }                                                                      \
    if (WhichPunct1)                                                       \
    {                                                                      \
        return (WhichPunct1);                                              \
    }                                                                      \
    if (WhichPunct2)                                                       \
    {                                                                      \
        return (WhichPunct2);                                              \
    }                                                                      \
                                                                           \
    return (CSTR_EQUAL);                                                   \
}


////////////////////////////////////////////////////////////////////////////
//
//  QUICK_SCAN_LONGER_STRING
//
//  Scans the longer string for diacritic, case, and special weights.
//  Assumes that both strings are null-terminated.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define QUICK_SCAN_LONGER_STRING( ptr,                                     \
                                  ret )                                    \
{                                                                          \
    /*                                                                     \
     *  Search through the rest of the longer string to make sure          \
     *  all characters are not to be ignored.  If find a character that    \
     *  should not be ignored, return the given return value immediately.  \
     *                                                                     \
     *  The only exception to this is when a nonspace mark is found.  If   \
     *  another DW difference has been found earlier, then use that.       \
     */                                                                    \
    while (*ptr != 0)                                                      \
    {                                                                      \
        switch (GET_SCRIPT_MEMBER(&(pHashN->pSortkey[*ptr])))              \
        {                                                                  \
            case ( UNSORTABLE ):                                           \
            {                                                              \
                break;                                                     \
            }                                                              \
            case ( NONSPACE_MARK ):                                        \
            {                                                              \
                if (!WhichDiacritic)                                       \
                {                                                          \
                    return (ret);                                          \
                }                                                          \
                break;                                                     \
            }                                                              \
            default :                                                      \
            {                                                              \
                return (ret);                                              \
            }                                                              \
        }                                                                  \
                                                                           \
        /*                                                                 \
         *  Advance pointer.                                               \
         */                                                                \
        ptr++;                                                             \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Need to check diacritic, case, extra, and special weights for      \
     *  final return value.  Still could be equal if the longer part of    \
     *  the string contained only unsortable characters.                   \
     *                                                                     \
     *  NOTE:  The following checks MUST REMAIN IN THIS ORDER:             \
     *            Diacritic, Case, Extra, Punctuation.                     \
     */                                                                    \
    if (WhichDiacritic)                                                    \
    {                                                                      \
        return (WhichDiacritic);                                           \
    }                                                                      \
    if (WhichCase)                                                         \
    {                                                                      \
        return (WhichCase);                                                \
    }                                                                      \
    if (WhichExtra)                                                        \
    {                                                                      \
        if (GET_WT_FOUR(&WhichExtra))                                      \
        {                                                                  \
            return (GET_WT_FOUR(&WhichExtra));                             \
        }                                                                  \
        if (GET_WT_FIVE(&WhichExtra))                                      \
        {                                                                  \
            return (GET_WT_FIVE(&WhichExtra));                             \
        }                                                                  \
        if (GET_WT_SIX(&WhichExtra))                                       \
        {                                                                  \
            return (GET_WT_SIX(&WhichExtra));                              \
        }                                                                  \
        if (GET_WT_SEVEN(&WhichExtra))                                     \
        {                                                                  \
            return (GET_WT_SEVEN(&WhichExtra));                            \
        }                                                                  \
    }                                                                      \
    if (WhichJamo)                                                         \
    {                                                                      \
        return (WhichJamo);                                                \
    }                                                                      \
    if (WhichPunct1)                                                       \
    {                                                                      \
        return (WhichPunct1);                                              \
    }                                                                      \
    if (WhichPunct2)                                                       \
    {                                                                      \
        return (WhichPunct2);                                              \
    }                                                                      \
                                                                           \
    return (CSTR_EQUAL);                                                   \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_FAREAST_WEIGHT
//
//  Returns the weight for the far east special case in "wt".  This currently
//  includes the Cho-on, the Repeat, and the Kana characters.
//
//  08-19-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_FAREAST_WEIGHT( wt,                                            \
                            uw,                                            \
                            mask,                                          \
                            pBegin,                                        \
                            pCur,                                          \
                            ExtraWt,                                       \
                            fModify )                                      \
{                                                                          \
    int ct;                       /* loop counter */                       \
    BYTE PrevSM;                  /* previous script member value */       \
    BYTE PrevAW;                  /* previous alphanumeric value */        \
    BYTE PrevCW;                  /* previous case value */                \
    BYTE AW;                      /* alphanumeric value */                 \
    BYTE CW;                      /* case value */                         \
    DWORD PrevWt;                 /* previous weight */                    \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Get the alphanumeric weight and the case weight of the             \
     *  current code point.                                                \
     */                                                                    \
    AW = GET_ALPHA_NUMERIC(&wt);                                           \
    CW = GET_CASE(&wt);                                                    \
    ExtraWt = (DWORD)0;                                                    \
                                                                           \
    /*                                                                     \
     *  Special case Repeat and Cho-On.                                    \
     *    AW = 0  =>  Repeat                                               \
     *    AW = 1  =>  Cho-On                                               \
     *    AW = 2+ =>  Kana                                                 \
     */                                                                    \
    if (AW <= MAX_SPECIAL_AW)                                              \
    {                                                                      \
        /*                                                                 \
         *  If the script member of the previous character is              \
         *  invalid, then give the special character an                    \
         *  invalid weight (highest possible weight) so that it            \
         *  will sort AFTER everything else.                               \
         */                                                                \
        ct = 1;                                                            \
        PrevWt = CMP_INVALID_FAREAST;                                      \
        while ((pCur - ct) >= pBegin)                                      \
        {                                                                  \
            PrevWt = GET_DWORD_WEIGHT(pHashN, *(pCur - ct));               \
            PrevWt &= mask;                                                \
            PrevSM = GET_SCRIPT_MEMBER(&PrevWt);                           \
            if (PrevSM < FAREAST_SPECIAL)                                  \
            {                                                              \
                if (PrevSM == EXPANSION)                                   \
                {                                                          \
                    PrevWt = CMP_INVALID_FAREAST;                          \
                }                                                          \
                else                                                       \
                {                                                          \
                    /*                                                     \
                     *  UNSORTABLE or NONSPACE_MARK.                       \
                     *                                                     \
                     *  Just ignore these, since we only care about the    \
                     *  previous UW value.                                 \
                     */                                                    \
                    PrevWt = CMP_INVALID_FAREAST;                          \
                    ct++;                                                  \
                    continue;                                              \
                }                                                          \
            }                                                              \
            else if (PrevSM == FAREAST_SPECIAL)                            \
            {                                                              \
                PrevAW = GET_ALPHA_NUMERIC(&PrevWt);                       \
                if (PrevAW <= MAX_SPECIAL_AW)                              \
                {                                                          \
                    /*                                                     \
                     *  Handle case where two special chars follow         \
                     *  each other.  Keep going back in the string.        \
                     */                                                    \
                    PrevWt = CMP_INVALID_FAREAST;                          \
                    ct++;                                                  \
                    continue;                                              \
                }                                                          \
                                                                           \
                UNICODE_WT(&PrevWt) =                                      \
                    MAKE_UNICODE_WT(KANA, PrevAW, fModify);                \
                                                                           \
                /*                                                         \
                 *  Only build weights 4, 5, 6, and 7 if the               \
                 *  previous character is KANA.                            \
                 *                                                         \
                 *  Always:                                                \
                 *    4W = previous CW  &  ISOLATE_SMALL                   \
                 *    6W = previous CW  &  ISOLATE_KANA                    \
                 *                                                         \
                 */                                                        \
                PrevCW = GET_CASE(&PrevWt);                                \
                GET_WT_FOUR(&ExtraWt) = PrevCW & ISOLATE_SMALL;            \
                GET_WT_SIX(&ExtraWt)  = PrevCW & ISOLATE_KANA;             \
                                                                           \
                if (AW == AW_REPEAT)                                       \
                {                                                          \
                    /*                                                     \
                     *  Repeat:                                            \
                     *    UW = previous UW                                 \
                     *    5W = WT_FIVE_REPEAT                              \
                     *    7W = previous CW  &  ISOLATE_WIDTH               \
                     */                                                    \
                    uw = UNICODE_WT(&PrevWt);                              \
                    GET_WT_FIVE(&ExtraWt)  = WT_FIVE_REPEAT;               \
                    GET_WT_SEVEN(&ExtraWt) = PrevCW & ISOLATE_WIDTH;       \
                }                                                          \
                else                                                       \
                {                                                          \
                    /*                                                     \
                     *  Cho-On:                                            \
                     *    UW = previous UW  &  CHO_ON_UW_MASK              \
                     *    5W = WT_FIVE_CHO_ON                              \
                     *    7W = current  CW  &  ISOLATE_WIDTH               \
                     */                                                    \
                    uw = UNICODE_WT(&PrevWt) & CHO_ON_UW_MASK;             \
                    GET_WT_FIVE(&ExtraWt)  = WT_FIVE_CHO_ON;               \
                    GET_WT_SEVEN(&ExtraWt) = CW & ISOLATE_WIDTH;           \
                }                                                          \
            }                                                              \
            else                                                           \
            {                                                              \
                uw = GET_UNICODE_MOD(&PrevWt, fModify);                    \
            }                                                              \
                                                                           \
            break;                                                         \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Kana:                                                          \
         *    SM = KANA                                                    \
         *    AW = current AW                                              \
         *    4W = current CW  &  ISOLATE_SMALL                            \
         *    5W = WT_FIVE_KANA                                            \
         *    6W = current CW  &  ISOLATE_KANA                             \
         *    7W = current CW  &  ISOLATE_WIDTH                            \
         */                                                                \
        uw = MAKE_UNICODE_WT(KANA, AW, fModify);                           \
        GET_WT_FOUR(&ExtraWt)  = CW & ISOLATE_SMALL;                       \
        GET_WT_FIVE(&ExtraWt)  = WT_FIVE_KANA;                             \
        GET_WT_SIX(&ExtraWt)   = CW & ISOLATE_KANA;                        \
        GET_WT_SEVEN(&ExtraWt) = CW & ISOLATE_WIDTH;                       \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Get the weight for the far east special case and store it in wt.   \
     */                                                                    \
    if ((AW > MAX_SPECIAL_AW) || (PrevWt != CMP_INVALID_FAREAST))          \
    {                                                                      \
        /*                                                                 \
         *  Always:                                                        \
         *    DW = current DW                                              \
         *    CW = minimum CW                                              \
         */                                                                \
        UNICODE_WT(&wt) = uw;                                              \
        CASE_WT(&wt) = MIN_CW;                                             \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        uw = CMP_INVALID_UW;                                               \
        wt = CMP_INVALID_FAREAST;                                          \
        ExtraWt = 0;                                                       \
    }                                                                      \
}




//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  CompareStringW
//
//  Compares two wide character strings of the same locale according to the
//  supplied locale handle.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI CompareStringW(
    LCID Locale,
    DWORD dwCmpFlags,
    LPCWSTR lpString1,
    int cchCount1,
    LPCWSTR lpString2,
    int cchCount2)
{
    register LPWSTR pString1;     // ptr to go thru string 1
    register LPWSTR pString2;     // ptr to go thru string 2
    PLOC_HASH pHashN;             // ptr to LOC hash node
    BOOL fIgnorePunct;            // flag to ignore punctuation (not symbol)
    BOOL fModify;                 // flag to use modified script member weights
    DWORD State;                  // state table
    DWORD Mask;                   // mask for weights
    DWORD Weight1;                // full weight of char - string 1
    DWORD Weight2;                // full weight of char - string 2

    int JamoFlag = FALSE;
    LPCWSTR pLastJamo = lpString1;

    int WhichDiacritic;           // DW => 1 = str1 smaller, 3 = str2 smaller
    int WhichCase;                // CW => 1 = str1 smaller, 3 = str2 smaller
    int WhichJamo;                // XW for Jamo
    int WhichPunct1;              // SW => 1 = str1 smaller, 3 = str2 smaller
    int WhichPunct2;              // SW => 1 = str1 smaller, 3 = str2 smaller
    LPWSTR pSave1;                // ptr to saved pString1
    LPWSTR pSave2;                // ptr to saved pString2
    int cExpChar1, cExpChar2;     // ct of expansions in tmp

    DWORD ExtraWt1, ExtraWt2;     // extra weight values (for far east)
    DWORD WhichExtra;             // XW => wts 4, 5, 6, 7 (for far east)

    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - either string is null
    //
    VALIDATE_LANGUAGE(Locale, pHashN, 0, TRUE);
    if ((pHashN == NULL) ||
        (lpString1 == NULL) || (lpString2 == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Make sure the appropriate sorting tables are available.  If not,
    //  return an error.
    //
    if ((pHashN->pSortkey == NULL) ||
        (pHashN->IfIdeographFailure == TRUE))
    {
        KdPrint(("NLSAPI: Appropriate Sorting Tables Not Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  Call longer compare string if any of the following is true:
    //     - compression locale
    //     - either count is not -1
    //     - dwCmpFlags is not 0 or ignore case   (see NOTE below)
    //     - locale is Korean - script member weight adjustment needed
    //
    //  NOTE:  If the value of NORM_IGNORECASE ever changes, this
    //         code should check for:
    //            ( (dwCmpFlags != 0)  &&  (dwCmpFlags != NORM_IGNORECASE) )
    //         Since NORM_IGNORECASE is equal to 1, we can optimize this
    //         by checking for > 1.
    //
    dwCmpFlags &= (~LOCALE_USE_CP_ACP);
    fModify = IS_KOREAN(Locale);
    if ( (pHashN->IfCompression) ||
         (cchCount1 > -1) || (cchCount2 > -1) ||
         (dwCmpFlags > NORM_IGNORECASE) ||
         (fModify == TRUE) )
    {
        return (LongCompareStringW( pHashN,
                                    dwCmpFlags,
                                    lpString1,
                                    ((cchCount1 <= -1) ? -2 : cchCount1),
                                    lpString2,
                                    ((cchCount2 <= -1) ? -2 : cchCount2),
                                    fModify ));
    }

    //
    //  Initialize string pointers.
    //
    pString1 = (LPWSTR)lpString1;
    pString2 = (LPWSTR)lpString2;

    //
    //  Do a wchar by wchar compare.
    //
    while (TRUE)
    {
        //
        //  See if characters are equal.
        //  If characters are equal, increment pointers and continue
        //  string compare.
        //
        //  NOTE: Loop is unrolled 8 times for performance.
        //
        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;
    }

    //
    //  If strings are both at null terminators, return equal.
    //
    if (*pString1 == *pString2)
    {
        return (CSTR_EQUAL);
    }

    //
    //  Initialize flags, pointers, and counters.
    //
    fIgnorePunct = FALSE;
    WhichDiacritic = 0;
    WhichCase = 0;
    WhichJamo = 0;
    WhichPunct1 = 0;
    WhichPunct2 = 0;
    pSave1 = NULL;
    pSave2 = NULL;
    ExtraWt1 = (DWORD)0;
    WhichExtra = (DWORD)0;

    //
    //  Switch on the different flag options.  This will speed up
    //  the comparisons of two strings that are different.
    //
    //  The only two possibilities in this optimized section are
    //  no flags and the ignore case flag.
    //
    if (dwCmpFlags == 0)
    {
        Mask = CMP_MASKOFF_NONE;
    }
    else
    {
        Mask = CMP_MASKOFF_CW;
    }
    State = (pHashN->IfReverseDW) ? STATE_REVERSE_DW : STATE_DW;
    State |= (STATE_CW | STATE_JAMO_WEIGHT);

    //
    //  Compare each character's sortkey weight in the two strings.
    //
    while ((*pString1 != 0) && (*pString2 != 0))
    {
        Weight1 = GET_DWORD_WEIGHT(pHashN, *pString1);
        Weight2 = GET_DWORD_WEIGHT(pHashN, *pString2);
        Weight1 &= Mask;
        Weight2 &= Mask;

        if (Weight1 != Weight2)
        {
            BYTE sm1 = GET_SCRIPT_MEMBER(&Weight1);     // script member 1
            BYTE sm2 = GET_SCRIPT_MEMBER(&Weight2);     // script member 2
            WORD uw1 = GET_UNICODE_SM(&Weight1, sm1);   // unicode weight 1
            WORD uw2 = GET_UNICODE_SM(&Weight2, sm2);   // unicode weight 2
            BYTE dw1;                                   // diacritic weight 1
            BYTE dw2;                                   // diacritic weight 2
            BOOL fContinue;                             // flag to continue loop
            DWORD Wt;                                   // temp weight holder
            WCHAR pTmpBuf1[MAX_TBL_EXPANSION];          // temp buffer for exp 1
            WCHAR pTmpBuf2[MAX_TBL_EXPANSION];          // temp buffer for exp 2


            //
            //  If Unicode Weights are different and no special cases,
            //  then we're done.  Otherwise, we need to do extra checking.
            //
            //  Must check ENTIRE string for any possibility of Unicode Weight
            //  differences.  As soon as a Unicode Weight difference is found,
            //  then we're done.  If no UW difference is found, then the
            //  first Diacritic Weight difference is used.  If no DW difference
            //  is found, then use the first Case Difference.  If no CW
            //  difference is found, then use the first Extra Weight
            //  difference.  If no XW difference is found, then use the first
            //  Special Weight difference.
            //
            if ((uw1 != uw2) ||
                (sm1 == FAREAST_SPECIAL) ||
                (sm1 == EXTENSION_A))
            {
                //
                //  Initialize the continue flag.
                //
                fContinue = FALSE;

                //
                //  Check for Unsortable characters and skip them.
                //  This needs to be outside the switch statement.  If EITHER
                //  character is unsortable, must skip it and start over.
                //
                if (sm1 == UNSORTABLE)
                {
                    pString1++;
                    fContinue = TRUE;
                }
                if (sm2 == UNSORTABLE)
                {
                    pString2++;
                    fContinue = TRUE;
                }
                if (fContinue)
                {
                    continue;
                }

                //
                //  Switch on the script member of string 1 and take care
                //  of any special cases.
                //
                switch (sm1)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if ((WhichDiacritic == 0) ||
                            (State & STATE_REVERSE_DW))
                        {
                            WhichDiacritic = CSTR_GREATER_THAN;

                            //
                            //  Remove state from state machine.
                            //
                            REMOVE_STATE(STATE_DW);
                        }

                        //
                        //  Adjust pointer and set flags.
                        //
                        pString1++;
                        fContinue = TRUE;

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then skip
                        //  over the punctuation.
                        //
                        if (fIgnorePunct)
                        {
                            pString1++;
                            fContinue = TRUE;
                        }
                        else if (sm2 != PUNCTUATION)
                        {
                            //
                            //  The character in the second string is
                            //  NOT punctuation.
                            //
                            if (WhichPunct2)
                            {
                                //
                                //  Set WP 2 to show that string 2 is smaller,
                                //  since a punctuation char had already been
                                //  found at an earlier position in string 2.
                                //
                                //  Set the Ignore Punctuation flag so we just
                                //  skip over any other punctuation chars in
                                //  the string.
                                //
                                WhichPunct2 = CSTR_GREATER_THAN;
                                fIgnorePunct = TRUE;
                            }
                            else
                            {
                                //
                                //  Set WP 1 to show that string 2 is smaller,
                                //  and that string 1 has had a punctuation
                                //  char - since no punctuation chars have
                                //  been found in string 2.
                                //
                                WhichPunct1 = CSTR_GREATER_THAN;
                            }

                            //
                            //  Advance pointer 1, and set flag to true.
                            //
                            pString1++;
                            fContinue = TRUE;
                        }

                        //
                        //  Do NOT want to advance the pointer in string 1 if
                        //  string 2 is also a punctuation char.  This will
                        //  be done later.
                        //
                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be
                        //  restored.
                        //
                        if (pSave1 == NULL)
                        {
                            pSave1 = pString1;
                        }
                        pString1 = pTmpBuf1;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf1[0] = GET_EXPANSION_1(&Weight1);
                        pTmpBuf1[1] = GET_EXPANSION_2(&Weight1);

                        //
                        //  Set cExpChar1 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar1 = MAX_TBL_EXPANSION;

                        fContinue = TRUE;

                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm2 != EXPANSION) 
                        {
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight1.
                            //
                            GET_FAREAST_WEIGHT( Weight1,
                                                uw1,
                                                Mask,
                                                lpString1,
                                                pString1,
                                                ExtraWt1,
                                                FALSE );

                            if (sm2 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the second string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 2 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt1) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt1) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt1) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt1) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        int ctr1;     // dummy variables for FindJamoDifference
                        LPWSTR pStr1 = pString1;
                        LPWSTR pStr2 = pString2;

                        //
                        //  Set the JamoFlag so we don't handle it again.
                        //
                        JamoFlag = TRUE;
                        fContinue = FindJamoDifference(
                            pHashN,
                            &pStr1, &ctr1, -2, &Weight1,
                            &pStr2, &ctr1, -2, &Weight2,
                            &pLastJamo,
                            &uw1, &uw2,
                            &State,
                            &WhichJamo,
                            fModify );
                        if (WhichJamo)
                        {
                            return (WhichJamo);
                        }    

                        pString1 = pStr1;
                        pString2 = pStr2;

                        break;
                    }
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  Compare the weights.
                        //
                        if (Weight1 == Weight2)
                        {
                            //
                            //  Adjust pointers and set flag.
                            //
                            pString1++;  pString2++;
                            fContinue = TRUE;
                        }
                        else
                        {
                            //
                            //  Get the actual UW to compare.
                            //
                            if (sm2 == EXTENSION_A)
                            {
                                //
                                //  Set the UW values to be the AW and DW since
                                //  both strings contain an extension A char.
                                //
                                uw1 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight1),
                                                       GET_DIACRITIC(&Weight1),
                                                       FALSE );
                                uw2 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight2),
                                                       GET_DIACRITIC(&Weight2),
                                                       FALSE );
                            }
                            else
                            {
                                //
                                //  Only string1 contains an extension A char,
                                //  so set the UW value to be the first UW
                                //  value for extension A (default values):
                                //    SM_EXT_A, AW_EXT_A
                                //
                                uw1 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A, fModify);
                            }
                        }

                        break;
                    }
                    case ( UNSORTABLE ) :
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  Switch on the script member of string 2 and take care
                //  of any special cases.
                //
                switch (sm2)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if ((WhichDiacritic == 0) ||
                            (State & STATE_REVERSE_DW))
                        {
                            WhichDiacritic = CSTR_LESS_THAN;

                            //
                            //  Remove state from state machine.
                            //
                            REMOVE_STATE(STATE_DW);
                        }

                        //
                        //  Adjust pointer and set flags.
                        //
                        pString2++;
                        fContinue = TRUE;

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then skip
                        //  over the punctuation.
                        //
                        if (fIgnorePunct)
                        {
                            //
                            //  Pointer 2 will be advanced after if-else
                            //  statement.
                            //
                            ;
                        }
                        else if (sm1 != PUNCTUATION)
                        {
                            //
                            //  The character in the first string is
                            //  NOT punctuation.
                            //
                            if (WhichPunct1)
                            {
                                //
                                //  Set WP 1 to show that string 1 is smaller,
                                //  since a punctuation char had already
                                //  been found at an earlier position in
                                //  string 1.
                                //
                                //  Set the Ignore Punctuation flag so we just
                                //  skip over any other punctuation in the
                                //  string.
                                //
                                WhichPunct1 = CSTR_LESS_THAN;
                                fIgnorePunct = TRUE;
                            }
                            else
                            {
                                //
                                //  Set WP 2 to show that string 1 is smaller,
                                //  and that string 2 has had a punctuation
                                //  char - since no punctuation chars have
                                //  been found in string 1.
                                //
                                WhichPunct2 = CSTR_LESS_THAN;
                            }

                            //
                            //  Pointer 2 will be advanced after if-else
                            //  statement.
                            //
                        }
                        else
                        {
                            //
                            //  Both code points are punctuation.
                            //
                            //  See if either of the strings has encountered
                            //  punctuation chars previous to this.
                            //
                            if (WhichPunct1)
                            {
                                //
                                //  String 1 has had a punctuation char, so
                                //  it should be the smaller string (since
                                //  both have punctuation chars).
                                //
                                WhichPunct1 = CSTR_LESS_THAN;
                            }
                            else if (WhichPunct2)
                            {
                                //
                                //  String 2 has had a punctuation char, so
                                //  it should be the smaller string (since
                                //  both have punctuation chars).
                                //
                                WhichPunct2 = CSTR_GREATER_THAN;
                            }
                            else
                            {
                                //
                                //  Position is the same, so compare the
                                //  special weights.  Set WhichPunct1 to
                                //  the smaller special weight.
                                //
                                WhichPunct1 = (((GET_ALPHA_NUMERIC(&Weight1) <
                                                 GET_ALPHA_NUMERIC(&Weight2)))
                                                 ? CSTR_LESS_THAN
                                                 : CSTR_GREATER_THAN);
                            }

                            //
                            //  Set the Ignore Punctuation flag so we just
                            //  skip over any other punctuation in the string.
                            //
                            fIgnorePunct = TRUE;

                            //
                            //  Advance pointer 1.  Pointer 2 will be
                            //  advanced after if-else statement.
                            //
                            pString1++;
                        }

                        //
                        //  Advance pointer 2 and set flag to true.
                        //
                        pString2++;
                        fContinue = TRUE;

                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be
                        //  restored.
                        //
                        if (pSave2 == NULL)
                        {
                            pSave2 = pString2;
                        }
                        pString2 = pTmpBuf2;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf2[0] = GET_EXPANSION_1(&Weight2);
                        pTmpBuf2[1] = GET_EXPANSION_2(&Weight2);

                        //
                        //  Set cExpChar2 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar2 = MAX_TBL_EXPANSION;

                        fContinue = TRUE;

                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm1 != EXPANSION) 
                        {
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight2.
                            //
                            GET_FAREAST_WEIGHT( Weight2,
                                                uw2,
                                                Mask,
                                                lpString2,
                                                pString2,
                                                ExtraWt2,
                                                FALSE );

                            if (sm1 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the first string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 1 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt2) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt2) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt2) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt2) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_LESS_THAN;
                                }
                            }
                            else
                            {
                                //
                                //  Characters in both strings are fareast
                                //  special chars.
                                //
                                //  Set each of weights 4, 5, 6, and 7
                                //  appropriately (if not already set).
                                //
                                if ( (GET_WT_FOUR(&WhichExtra) == 0) &&
                                     ( GET_WT_FOUR(&ExtraWt1) !=
                                       GET_WT_FOUR(&ExtraWt2) ) )
                                {
                                    GET_WT_FOUR(&WhichExtra) =
                                      ( GET_WT_FOUR(&ExtraWt1) <
                                        GET_WT_FOUR(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_FIVE(&WhichExtra) == 0) &&
                                     ( GET_WT_FIVE(&ExtraWt1) !=
                                       GET_WT_FIVE(&ExtraWt2) ) )
                                {
                                    GET_WT_FIVE(&WhichExtra) =
                                      ( GET_WT_FIVE(&ExtraWt1) <
                                        GET_WT_FIVE(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SIX(&WhichExtra) == 0) &&
                                     ( GET_WT_SIX(&ExtraWt1) !=
                                       GET_WT_SIX(&ExtraWt2) ) )
                                {
                                    GET_WT_SIX(&WhichExtra) =
                                      ( GET_WT_SIX(&ExtraWt1) <
                                        GET_WT_SIX(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SEVEN(&WhichExtra) == 0) &&
                                     ( GET_WT_SEVEN(&ExtraWt1) !=
                                       GET_WT_SEVEN(&ExtraWt2) ) )
                                {
                                    GET_WT_SEVEN(&WhichExtra) =
                                      ( GET_WT_SEVEN(&ExtraWt1) <
                                        GET_WT_SEVEN(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        if (!JamoFlag)
                        {
                            int ctr1, ctr2;   // dummy variables for FindJamoDifference
                            LPWSTR pStr1 = pString1;
                            LPWSTR pStr2 = pString2;

                            //
                            //  Set the JamoFlag so we don't handle it again.
                            //
                            JamoFlag = TRUE;
                            fContinue = FindJamoDifference(
                                pHashN,
                                &pStr1, &ctr1, -2, &Weight1,
                                &pStr2, &ctr2, -2, &Weight2,
                                &pLastJamo,
                                &uw1, &uw2,
                                &State,
                                &WhichJamo,
                                fModify );
                            if (WhichJamo)
                            {
                                return (WhichJamo);
                            }
                            pString1 = pStr1;
                            pString2 = pStr2;
                        }
                        else
                        {
                            JamoFlag = FALSE;
                        }

                        break;
                    }
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  If sm1 is an extension A character, then
                        //  both sm1 and sm2 have been handled.  We should
                        //  only get here when either sm1 is not an
                        //  extension A character or the two extension A
                        //  characters are different.
                        //
                        if (sm1 != EXTENSION_A)
                        {
                            //
                            //  Get the actual UW to compare.
                            //
                            //  Only string2 contains an extension A char,
                            //  so set the UW value to be the first UW
                            //  value for extension A (default values):
                            //    SM_EXT_A, AW_EXT_A
                            //
                            uw2 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A, fModify);
                        }

                        //
                        //  We should then fall through to the comparison
                        //  of the Unicode weights.
                        //

                        break;
                    }
                    case ( UNSORTABLE ) :
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  See if the comparison should start again.
                //
                if (fContinue)
                {
                    continue;
                }

                //
                //  We're not supposed to drop down into the state table if
                //  unicode weights are different, so stop comparison and
                //  return result of unicode weight comparison.
                //
                if (uw1 != uw2)
                {
                    return ((uw1 < uw2) ? CSTR_LESS_THAN : CSTR_GREATER_THAN);
                }
            }

            //
            //  For each state in the state table, do the appropriate
            //  comparisons.     (UW1 == UW2)
            //
            if (State & (STATE_DW | STATE_REVERSE_DW))
            {
                //
                //  Get the diacritic weights.
                //
                dw1 = GET_DIACRITIC(&Weight1);
                dw2 = GET_DIACRITIC(&Weight2);

                if (dw1 != dw2)
                {
                    //
                    //  Look ahead to see if diacritic follows a
                    //  minimum diacritic weight.  If so, get the
                    //  diacritic weight of the nonspace mark.
                    //
                    while (*(pString1 + 1) != 0)
                    {
                        Wt = GET_DWORD_WEIGHT(pHashN, *(pString1 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw1 += GET_DIACRITIC(&Wt);
                            pString1++;
                        }
                        else
                        {
                            break;
                        }
                    }

                    while (*(pString2 + 1) != 0)
                    {
                        Wt = GET_DWORD_WEIGHT(pHashN, *(pString2 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw2 += GET_DIACRITIC(&Wt);
                            pString2++;
                        }
                        else
                        {
                            break;
                        }
                    }

                    //
                    //  Save which string has the smaller diacritic
                    //  weight if the diacritic weights are still
                    //  different.
                    //
                    if (dw1 != dw2)
                    {
                        WhichDiacritic = (dw1 < dw2)
                                           ? CSTR_LESS_THAN
                                           : CSTR_GREATER_THAN;

                        //
                        //  Remove state from state machine.
                        //
                        REMOVE_STATE(STATE_DW);
                    }
                }
            }
            if (State & STATE_CW)
            {
                //
                //  Get the case weights.
                //
                if (GET_CASE(&Weight1) != GET_CASE(&Weight2))
                {
                    //
                    //  Save which string has the smaller case weight.
                    //
                    WhichCase = (GET_CASE(&Weight1) < GET_CASE(&Weight2))
                                  ? CSTR_LESS_THAN
                                  : CSTR_GREATER_THAN;

                    //
                    //  Remove state from state machine.
                    //
                    REMOVE_STATE(STATE_CW);
                }
            }
        }

        //
        //  Fixup the pointers.
        //
        POINTER_FIXUP();
    }

    //
    //  If the end of BOTH strings has been reached, then the unicode
    //  weights match exactly.  Check the diacritic, case and special
    //  weights.  If all are zero, then return success.  Otherwise,
    //  return the result of the weight difference.
    //
    //  NOTE:  The following checks MUST REMAIN IN THIS ORDER:
    //            Diacritic, Case, Punctuation.
    //
    if (*pString1 == 0)
    {
        if (*pString2 == 0)
        {
            if (WhichDiacritic)
            {
                return (WhichDiacritic);
            }
            if (WhichCase)
            {
                return (WhichCase);
            }
            if (WhichExtra)
            {
                if (GET_WT_FOUR(&WhichExtra))
                {
                    return (GET_WT_FOUR(&WhichExtra));
                }
                if (GET_WT_FIVE(&WhichExtra))
                {
                    return (GET_WT_FIVE(&WhichExtra));
                }
                if (GET_WT_SIX(&WhichExtra))
                {
                    return (GET_WT_SIX(&WhichExtra));
                }
                if (GET_WT_SEVEN(&WhichExtra))
                {
                    return (GET_WT_SEVEN(&WhichExtra));
                }
            }
            if (WhichPunct1)
            {
                return (WhichPunct1);
            }
            if (WhichPunct2)
            {
                return (WhichPunct2);
            }

            return (CSTR_EQUAL);
        }
        else
        {
            //
            //  String 2 is longer.
            //
            pString1 = pString2;
        }
    }

    //
    //  Scan to the end of the longer string.
    //
    QUICK_SCAN_LONGER_STRING( pString1,
                              ((*pString2 == 0)
                                ? CSTR_GREATER_THAN
                                : CSTR_LESS_THAN) );
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStringTypeExW
//
//  Returns character type information about a particular Unicode string.
//
//  01-18-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetStringTypeExW(
    LCID Locale,
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType)
{
    PLOC_HASH pHashN;             // ptr to LOC hash node


    //
    //  Invalid Parameter Check:
    //    - Validate LCID
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if (pHashN == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Return the result of GetStringTypeW.
    //
    return (GetStringTypeW( dwInfoType,
                            lpSrcStr,
                            cchSrc,
                            lpCharType ));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStringTypeW
//
//  Returns character type information about a particular Unicode string.
//
//  NOTE:  The number of parameters is different from GetStringTypeA.
//         The 16-bit OLE product shipped GetStringTypeA with the wrong
//         parameters (ported from Chicago) and now we must support it.
//
//         Use GetStringTypeEx to get the same set of parameters between
//         the A and W version.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetStringTypeW(
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType)
{
    int Ctr;                      // loop counter


    //
    //  Invalid Parameter Check:
    //    - lpSrcStr NULL
    //    - cchSrc is 0
    //    - lpCharType NULL
    //    - same buffer - src and destination
    //    - (flags will be checked in switch statement below)
    //
    if ( (lpSrcStr == NULL) || (cchSrc == 0) ||
         (lpCharType == NULL) || (lpSrcStr == lpCharType) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  If cchSrc is -1, then the source string is null terminated and we
    //  need to get the length of the source string.  Add one to the
    //  length to include the null termination.
    //  (This will always be at least 1.)
    //
    if (cchSrc <= -1)
    {
        cchSrc = NlsStrLenW(lpSrcStr) + 1;
    }

    //
    //  Make sure the ctype table is mapped in.
    //
    if (GetCTypeFileInfo())
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (FALSE);
    }

    //
    //  Return the appropriate information in the lpCharType parameter
    //  based on the dwInfoType parameter.
    //
    switch (dwInfoType)
    {
        case ( CT_CTYPE1 ) :
        {
            //
            //  Return the ctype 1 information for the string.
            //
            for (Ctr = 0; Ctr < cchSrc; Ctr++)
            {
                lpCharType[Ctr] = GET_CTYPE(lpSrcStr[Ctr], CType1);
            }
            break;
        }
        case ( CT_CTYPE2 ) :
        {
            //
            //  Return the ctype 2 information.
            //
            for (Ctr = 0; Ctr < cchSrc; Ctr++)
            {
                lpCharType[Ctr] = GET_CTYPE(lpSrcStr[Ctr], CType2);
            }
            break;
        }
        case ( CT_CTYPE3 ) :
        {
            //
            //  Return the ctype 3 information.
            //
            for (Ctr = 0; Ctr < cchSrc; Ctr++)
            {
                lpCharType[Ctr] = GET_CTYPE(lpSrcStr[Ctr], CType3);
            }
            break;
        }
        default :
        {
            //
            //  Invalid flag parameter, so return failure.
            //
            SetLastError(ERROR_INVALID_FLAGS);
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  LongCompareStringW
//
//  Compares two wide character strings of the same locale according to the
//  supplied locale handle.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int LongCompareStringW(
    PLOC_HASH pHashN,
    DWORD dwCmpFlags,
    LPCWSTR lpString1,
    int cchCount1,
    LPCWSTR lpString2,
    int cchCount2,
    BOOL fModify)
{
    int ctr1 = cchCount1;         // loop counter for string 1
    int ctr2 = cchCount2;         // loop counter for string 2
    register LPWSTR pString1;     // ptr to go thru string 1
    register LPWSTR pString2;     // ptr to go thru string 2
    BOOL IfCompress;              // if compression in locale
    BOOL IfDblCompress1;          // if double compression in string 1
    BOOL IfDblCompress2;          // if double compression in string 2
    BOOL fEnd1;                   // if at end of string 1
    BOOL fIgnorePunct;            // flag to ignore punctuation (not symbol)
    BOOL fIgnoreDiacritic;        // flag to ignore diacritics
    BOOL fIgnoreSymbol;           // flag to ignore symbols
    BOOL fStringSort;             // flag to use string sort
    DWORD State;                  // state table
    DWORD Mask;                   // mask for weights
    DWORD Weight1;                // full weight of char - string 1
    DWORD Weight2;                // full weight of char - string 2

    int JamoFlag = FALSE;
    LPCWSTR pLastJamo = lpString1;

    int WhichDiacritic;           // DW => 1 = str1 smaller, 3 = str2 smaller
    int WhichCase;                // CW => 1 = str1 smaller, 3 = str2 smaller
    int WhichJamo;                // XW for Jamo
    int WhichPunct1;              // SW => 1 = str1 smaller, 3 = str2 smaller
    int WhichPunct2;              // SW => 1 = str1 smaller, 3 = str2 smaller
    LPWSTR pSave1;                // ptr to saved pString1
    LPWSTR pSave2;                // ptr to saved pString2
    int cExpChar1, cExpChar2;     // ct of expansions in tmp

    DWORD ExtraWt1, ExtraWt2;     // extra weight values (for far east)
    DWORD WhichExtra;             // XW => wts 4, 5, 6, 7 (for far east)

    //
    //  Initialize string pointers.
    //
    pString1 = (LPWSTR)lpString1;
    pString2 = (LPWSTR)lpString2;

    //
    //  Invalid Flags Check:
    //    - invalid flags
    //
    if (dwCmpFlags & CS_INVALID_FLAG)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  See if we should stop on the null terminator regardless of the
    //  count values.  The original count values are stored in ctr1 and ctr2
    //  above, so it's ok to set these here.
    //
    if (dwCmpFlags & NORM_STOP_ON_NULL)
    {
        cchCount1 = cchCount2 = -2;
    }

    //
    //  Check if compression in the given locale.  If not, then
    //  try a wchar by wchar compare.  If strings are equal, this
    //  will be quick.
    //
    if ((IfCompress = pHashN->IfCompression) == FALSE)
    {
        //
        //  Compare each wide character in the two strings.
        //
        while ( NOT_END_STRING(ctr1, pString1, cchCount1) &&
                NOT_END_STRING(ctr2, pString2, cchCount2) )
        {
            //
            //  See if characters are equal.
            //
            if (*pString1 == *pString2)
            {
                //
                //  Characters are equal, so increment pointers,
                //  decrement counters, and continue string compare.
                //
                pString1++;
                pString2++;
                ctr1--;
                ctr2--;
            }
            else
            {
                //
                //  Difference was found.  Fall into the sortkey
                //  check below.
                //
                break;
            }
        }

        //
        //  If the end of BOTH strings has been reached, then the strings
        //  match exactly.  Return success.
        //
        if ( AT_STRING_END(ctr1, pString1, cchCount1) &&
             AT_STRING_END(ctr2, pString2, cchCount2) )
        {
            return (CSTR_EQUAL);
        }
    }

    //
    //  Initialize flags, pointers, and counters.
    //
    fIgnorePunct = dwCmpFlags & NORM_IGNORESYMBOLS;
    fIgnoreDiacritic = dwCmpFlags & NORM_IGNORENONSPACE;
    fIgnoreSymbol = fIgnorePunct;
    fStringSort = dwCmpFlags & SORT_STRINGSORT;
    WhichDiacritic = 0;
    WhichCase = 0;
    WhichJamo = 0;
    WhichPunct1 = 0;
    WhichPunct2 = 0;
    pSave1 = NULL;
    pSave2 = NULL;
    ExtraWt1 = (DWORD)0;
    WhichExtra = (DWORD)0;

    //
    //  Set the weights to be invalid.  This flags whether or not to
    //  recompute the weights next time through the loop.  It also flags
    //  whether or not to start over (continue) in the loop.
    //
    Weight1 = CMP_INVALID_WEIGHT;
    Weight2 = CMP_INVALID_WEIGHT;

    //
    //  Switch on the different flag options.  This will speed up
    //  the comparisons of two strings that are different.
    //
    State = STATE_CW | STATE_JAMO_WEIGHT;
    switch (dwCmpFlags & (NORM_IGNORECASE | NORM_IGNORENONSPACE))
    {
        case ( 0 ) :
        {
            Mask = CMP_MASKOFF_NONE;
            State |= (pHashN->IfReverseDW) ? STATE_REVERSE_DW : STATE_DW;

            break;
        }

        case ( NORM_IGNORECASE ) :
        {
            Mask = CMP_MASKOFF_CW;
            State |= (pHashN->IfReverseDW) ? STATE_REVERSE_DW : STATE_DW;

            break;
        }

        case ( NORM_IGNORENONSPACE ) :
        {
            Mask = CMP_MASKOFF_DW;

            break;
        }

        case ( NORM_IGNORECASE | NORM_IGNORENONSPACE ) :
        {
            Mask = CMP_MASKOFF_DW_CW;

            break;
        }
    }

    switch (dwCmpFlags & (NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH))
    {
        case ( 0 ) :
        {
            break;
        }

        case ( NORM_IGNOREKANATYPE ) :
        {
            Mask &= CMP_MASKOFF_KANA;

            break;
        }

        case ( NORM_IGNOREWIDTH ) :
        {
            Mask &= CMP_MASKOFF_WIDTH;

            if (dwCmpFlags & NORM_IGNORECASE)
            {
                REMOVE_STATE(STATE_CW);
            }

            break;
        }

        case ( NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH ) :
        {
            Mask &= CMP_MASKOFF_KANA_WIDTH;

            if (dwCmpFlags & NORM_IGNORECASE)
            {
                REMOVE_STATE(STATE_CW);
            }

            break;
        }
    }

    //
    //  Compare each character's sortkey weight in the two strings.
    //
    while ( NOT_END_STRING(ctr1, pString1, cchCount1) &&
            NOT_END_STRING(ctr2, pString2, cchCount2) )
    {
        if (Weight1 == CMP_INVALID_WEIGHT)
        {
            Weight1 = GET_DWORD_WEIGHT(pHashN, *pString1);
            Weight1 &= Mask;
        }
        if (Weight2 == CMP_INVALID_WEIGHT)
        {
            Weight2 = GET_DWORD_WEIGHT(pHashN, *pString2);
            Weight2 &= Mask;
        }

        //
        //  If compression locale, then need to check for compression
        //  characters even if the weights are equal.  If it's not a
        //  compression locale, then we don't need to check anything
        //  if the weights are equal.
        //
        if ( (IfCompress) &&
             (GET_COMPRESSION(&Weight1) || GET_COMPRESSION(&Weight2)) )
        {
            int ctr;                   // loop counter
            PCOMPRESS_3 pComp3;        // ptr to compress 3 table
            PCOMPRESS_2 pComp2;        // ptr to compress 2 table
            int If1;                   // if compression found in string 1
            int If2;                   // if compression found in string 2
            int CompVal;               // compression value
            int IfEnd1;                // if exists 1 more char in string 1
            int IfEnd2;                // if exists 1 more char in string 2


            //
            //  Check for compression in the weights.
            //
            If1 = GET_COMPRESSION(&Weight1);
            If2 = GET_COMPRESSION(&Weight2);
            CompVal = ((If1 > If2) ? If1 : If2);

            IfEnd1 = AT_STRING_END(ctr1 - 1, pString1 + 1, cchCount1);
            IfEnd2 = AT_STRING_END(ctr2 - 1, pString2 + 1, cchCount2);

            if (pHashN->IfDblCompression == FALSE)
            {
                //
                //  NO double compression, so don't check for it.
                //
                switch (CompVal)
                {
                    //
                    //  Check for 3 characters compressing to 1.
                    //
                    case ( COMPRESS_3_MASK ) :
                    {
                        //
                        //  Check character in string 1 and string 2.
                        //
                        if ( ((If1) && (!IfEnd1) &&
                              !AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1)) ||
                             ((If2) && (!IfEnd2) &&
                              !AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2)) )
                        {
                            ctr = pHashN->pCompHdr->Num3;
                            pComp3 = pHashN->pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ( (If1) && (!IfEnd1) &&
                                     !AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1) &&
                                     (pComp3->UCP1 == *pString1) &&
                                     (pComp3->UCP2 == *(pString1 + 1)) &&
                                     (pComp3->UCP3 == *(pString1 + 2)) )
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight1 &= Mask;
                                    pString1 += 2;
                                    ctr1 -= 2;

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If2 == 0)
                                    {
                                        break;
                                    }
                                }

                                //
                                //  Check character in string 2.
                                //
                                if ( (If2) && (!IfEnd2) &&
                                     !AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2) &&
                                     (pComp3->UCP1 == *pString2) &&
                                     (pComp3->UCP2 == *(pString2 + 1)) &&
                                     (pComp3->UCP3 == *(pString2 + 2)) )
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight2 &= Mask;
                                    pString2 += 2;
                                    ctr2 -= 2;

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If1 == 0)
                                    {
                                        break;
                                    }
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }
                        //
                        //  Fall through if not found.
                        //
                    }

                    //
                    //  Check for 2 characters compressing to 1.
                    //
                    case ( COMPRESS_2_MASK ) :
                    {
                        //
                        //  Check character in string 1 and string 2.
                        //
                        if ( ((If1) && (!IfEnd1)) ||
                             ((If2) && (!IfEnd2)) )
                        {
                            ctr = pHashN->pCompHdr->Num2;
                            pComp2 = pHashN->pCompress2;
                            for (; ((ctr > 0) && (If1 || If2)); ctr--, pComp2++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ( (If1) &&
                                     (!IfEnd1) &&
                                     (pComp2->UCP1 == *pString1) &&
                                     (pComp2->UCP2 == *(pString1 + 1)) )
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight1 &= Mask;
                                    pString1++;
                                    ctr1--;

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If2 == 0)
                                    {
                                        break;
                                    }
                                }

                                //
                                //  Check character in string 2.
                                //
                                if ( (If2) &&
                                     (!IfEnd2) &&
                                     (pComp2->UCP1 == *pString2) &&
                                     (pComp2->UCP2 == *(pString2 + 1)) )
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight2 &= Mask;
                                    pString2++;
                                    ctr2--;

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If1 == 0)
                                    {
                                        break;
                                    }
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }
                    }
                }
            }
            else if (!IfEnd1 && !IfEnd2)
            {
                //
                //  Double Compression exists, so must check for it.
                //
                if (IfDblCompress1 =
                       ((GET_DWORD_WEIGHT(pHashN, *pString1) & CMP_MASKOFF_CW) ==
                        (GET_DWORD_WEIGHT(pHashN, *(pString1 + 1)) & CMP_MASKOFF_CW)))
                {
                    //
                    //  Advance past the first code point to get to the
                    //  compression character.
                    //
                    pString1++;
                    ctr1--;
                    IfEnd1 = AT_STRING_END(ctr1 - 1, pString1 + 1, cchCount1);
                }

                if (IfDblCompress2 =
                       ((GET_DWORD_WEIGHT(pHashN, *pString2) & CMP_MASKOFF_CW) ==
                        (GET_DWORD_WEIGHT(pHashN, *(pString2 + 1)) & CMP_MASKOFF_CW)))
                {
                    //
                    //  Advance past the first code point to get to the
                    //  compression character.
                    //
                    pString2++;
                    ctr2--;
                    IfEnd2 = AT_STRING_END(ctr2 - 1, pString2 + 1, cchCount2);
                }

                switch (CompVal)
                {
                    //
                    //  Check for 3 characters compressing to 1.
                    //
                    case ( COMPRESS_3_MASK ) :
                    {
                        //
                        //  Check character in string 1.
                        //
                        if ( (If1) && (!IfEnd1) &&
                             !AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1) )
                        {
                            ctr = pHashN->pCompHdr->Num3;
                            pComp3 = pHashN->pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ( (pComp3->UCP1 == *pString1) &&
                                     (pComp3->UCP2 == *(pString1 + 1)) &&
                                     (pComp3->UCP3 == *(pString1 + 2)) )
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight1 &= Mask;
                                    if (!IfDblCompress1)
                                    {
                                        pString1 += 2;
                                        ctr1 -= 2;
                                    }

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;

                                    break;
                                }
                            }
                        }

                        //
                        //  Check character in string 2.
                        //
                        if ( (If2) && (!IfEnd2) &&
                             !AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2) )
                        {
                            ctr = pHashN->pCompHdr->Num3;
                            pComp3 = pHashN->pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                //
                                //  Check character in string 2.
                                //
                                if ( (pComp3->UCP1 == *pString2) &&
                                     (pComp3->UCP2 == *(pString2 + 1)) &&
                                     (pComp3->UCP3 == *(pString2 + 2)) )
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight2 &= Mask;
                                    if (!IfDblCompress2)
                                    {
                                        pString2 += 2;
                                        ctr2 -= 2;
                                    }

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;

                                    break;
                                }
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                        if ((If1 == 0) && (If2 == 0))
                        {
                            break;
                        }
                    }

                    //
                    //  Check for 2 characters compressing to 1.
                    //
                    case ( COMPRESS_2_MASK ) :
                    {
                        //
                        //  Check character in string 1.
                        //
                        if ((If1) && (!IfEnd1))
                        {
                            ctr = pHashN->pCompHdr->Num2;
                            pComp2 = pHashN->pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ((pComp2->UCP1 == *pString1) &&
                                    (pComp2->UCP2 == *(pString1 + 1)))
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight1 &= Mask;
                                    if (!IfDblCompress1)
                                    {
                                        pString1++;
                                        ctr1--;
                                    }

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;

                                    break;
                                }
                            }
                        }

                        //
                        //  Check character in string 2.
                        //
                        if ((If2) && (!IfEnd2))
                        {
                            ctr = pHashN->pCompHdr->Num2;
                            pComp2 = pHashN->pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                //
                                //  Check character in string 2.
                                //
                                if ((pComp2->UCP1 == *pString2) &&
                                    (pComp2->UCP2 == *(pString2 + 1)))
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight2 &= Mask;
                                    if (!IfDblCompress2)
                                    {
                                        pString2++;
                                        ctr2--;
                                    }

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;

                                    break;
                                }
                            }
                        }
                    }
                }

                //
                //  Reset the pointer back to the beginning of the double
                //  compression.  Pointer fixup at the end will advance
                //  them correctly.
                //
                //  If double compression, we advanced the pointer at
                //  the beginning of the switch statement.  If double
                //  compression character was actually found, the pointer
                //  was NOT advanced.  We now want to decrement the pointer
                //  to put it back to where it was.
                //
                //  The next time through, the pointer will be pointing to
                //  the regular compression part of the string.
                //
                if (IfDblCompress1)
                {
                    pString1--;
                    ctr1++;
                }
                if (IfDblCompress2)
                {
                    pString2--;
                    ctr2++;
                }
            }
        }

        //
        //  Check the weights again.
        //
        if ((Weight1 != Weight2) ||
            (GET_SCRIPT_MEMBER(&Weight1) == EXTENSION_A))
        {
            //
            //  Weights are still not equal, even after compression
            //  check, so compare the different weights.
            //
            BYTE sm1 = GET_SCRIPT_MEMBER(&Weight1);                // script member 1
            BYTE sm2 = GET_SCRIPT_MEMBER(&Weight2);                // script member 2
            WORD uw1 = GET_UNICODE_SM_MOD(&Weight1, sm1, fModify); // unicode weight 1
            WORD uw2 = GET_UNICODE_SM_MOD(&Weight2, sm2, fModify); // unicode weight 2
            BYTE dw1;                                              // diacritic weight 1
            BYTE dw2;                                              // diacritic weight 2
            DWORD Wt;                                              // temp weight holder
            WCHAR pTmpBuf1[MAX_TBL_EXPANSION];                     // temp buffer for exp 1
            WCHAR pTmpBuf2[MAX_TBL_EXPANSION];                     // temp buffer for exp 2


            //
            //  If Unicode Weights are different and no special cases,
            //  then we're done.  Otherwise, we need to do extra checking.
            //
            //  Must check ENTIRE string for any possibility of Unicode Weight
            //  differences.  As soon as a Unicode Weight difference is found,
            //  then we're done.  If no UW difference is found, then the
            //  first Diacritic Weight difference is used.  If no DW difference
            //  is found, then use the first Case Difference.  If no CW
            //  difference is found, then use the first Extra Weight
            //  difference.  If no XW difference is found, then use the first
            //  Special Weight difference.
            //
            if ((uw1 != uw2) ||
                ((sm1 <= SYMBOL_5) && (sm1 >= FAREAST_SPECIAL)))
            {
                //
                //  Check for Unsortable characters and skip them.
                //  This needs to be outside the switch statement.  If EITHER
                //  character is unsortable, must skip it and start over.
                //
                if (sm1 == UNSORTABLE)
                {
                    pString1++;
                    ctr1--;
                    Weight1 = CMP_INVALID_WEIGHT;
                }
                if (sm2 == UNSORTABLE)
                {
                    pString2++;
                    ctr2--;
                    Weight2 = CMP_INVALID_WEIGHT;
                }

                //
                //  Check for Ignore Nonspace and Ignore Symbol.  If
                //  Ignore Nonspace is set and either character is a
                //  nonspace mark only, then we need to advance the
                //  pointer to skip over the character and continue.
                //  If Ignore Symbol is set and either character is a
                //  punctuation char, then we need to advance the
                //  pointer to skip over the character and continue.
                //
                //  This step is necessary so that a string with a
                //  nonspace mark and a punctuation char following one
                //  another are properly ignored when one or both of
                //  the ignore flags is set.
                //
                if (fIgnoreDiacritic)
                {
                    if (sm1 == NONSPACE_MARK)
                    {
                        pString1++;
                        ctr1--;
                        Weight1 = CMP_INVALID_WEIGHT;
                    }
                    if (sm2 == NONSPACE_MARK)
                    {
                        pString2++;
                        ctr2--;
                        Weight2 = CMP_INVALID_WEIGHT;
                    }
                }
                if (fIgnoreSymbol)
                {
                    if (sm1 == PUNCTUATION)
                    {
                        pString1++;
                        ctr1--;
                        Weight1 = CMP_INVALID_WEIGHT;
                    }
                    if (sm2 == PUNCTUATION)
                    {
                        pString2++;
                        ctr2--;
                        Weight2 = CMP_INVALID_WEIGHT;
                    }
                }
                if ((Weight1 == CMP_INVALID_WEIGHT) || (Weight2 == CMP_INVALID_WEIGHT))
                {
                    continue;
                }

                //
                //  Switch on the script member of string 1 and take care
                //  of any special cases.
                //
                switch (sm1)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if (!fIgnoreDiacritic)
                        {
                            if ((WhichDiacritic == 0) ||
                                (State & STATE_REVERSE_DW))
                            {
                                WhichDiacritic = CSTR_GREATER_THAN;

                                //
                                //  Remove state from state machine.
                                //
                                REMOVE_STATE(STATE_DW);
                            }
                        }

                        //
                        //  Adjust pointer and counter and set flags.
                        //
                        pString1++;
                        ctr1--;
                        Weight1 = CMP_INVALID_WEIGHT;

                        break;
                    }
                    case ( SYMBOL_1 ) :
                    case ( SYMBOL_2 ) :
                    case ( SYMBOL_3 ) :
                    case ( SYMBOL_4 ) :
                    case ( SYMBOL_5 ) :
                    {
                        //
                        //  If the ignore symbol flag is set, then skip over
                        //  the symbol.
                        //
                        if (fIgnoreSymbol)
                        {
                            pString1++;
                            ctr1--;
                            Weight1 = CMP_INVALID_WEIGHT;
                        }

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then skip
                        //  over the punctuation char.
                        //
                        if (fIgnorePunct)
                        {
                            pString1++;
                            ctr1--;
                            Weight1 = CMP_INVALID_WEIGHT;
                        }
                        else if (!fStringSort)
                        {
                            //
                            //  Use WORD sort method.
                            //
                            if (sm2 != PUNCTUATION)
                            {
                                //
                                //  The character in the second string is
                                //  NOT punctuation.
                                //
                                if (WhichPunct2)
                                {
                                    //
                                    //  Set WP 2 to show that string 2 is
                                    //  smaller, since a punctuation char had
                                    //  already been found at an earlier
                                    //  position in string 2.
                                    //
                                    //  Set the Ignore Punctuation flag so we
                                    //  just skip over any other punctuation
                                    //  chars in the string.
                                    //
                                    WhichPunct2 = CSTR_GREATER_THAN;
                                    fIgnorePunct = TRUE;
                                }
                                else
                                {
                                    //
                                    //  Set WP 1 to show that string 2 is
                                    //  smaller, and that string 1 has had
                                    //  a punctuation char - since no
                                    //  punctuation chars have been found
                                    //  in string 2.
                                    //
                                    WhichPunct1 = CSTR_GREATER_THAN;
                                }

                                //
                                //  Advance pointer 1 and decrement counter 1.
                                //
                                pString1++;
                                ctr1--;
                                Weight1 = CMP_INVALID_WEIGHT;
                            }

                            //
                            //  Do NOT want to advance the pointer in string 1
                            //  if string 2 is also a punctuation char.  This
                            //  will be done later.
                            //
                        }

                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be
                        //  restored.
                        //
                        if (pSave1 == NULL)
                        {
                            pSave1 = pString1;
                        }
                        pString1 = pTmpBuf1;

                        //
                        //  Add one to counter so that subtraction doesn't end
                        //  comparison prematurely.
                        //
                        ctr1++;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf1[0] = GET_EXPANSION_1(&Weight1);
                        pTmpBuf1[1] = GET_EXPANSION_2(&Weight1);

                        //
                        //  Set cExpChar1 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar1 = MAX_TBL_EXPANSION;

                        Weight1 = CMP_INVALID_WEIGHT;

                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm2 != EXPANSION) 
                        {
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight1.
                            //
                            GET_FAREAST_WEIGHT( Weight1,
                                                uw1,
                                                Mask,
                                                lpString1,
                                                pString1,
                                                ExtraWt1,
                                                fModify );

                            if (sm2 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the second string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 2 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt1) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt1) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt1) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt1) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        LPWSTR pStr1 = pString1;
                        LPWSTR pStr2 = pString2;

                        //
                        //  Set the JamoFlag so we don't handle it again.
                        //
                        JamoFlag = TRUE;
                        FindJamoDifference(
                            pHashN,
                            &pStr1, &ctr1, cchCount1, &Weight1,
                            &pStr2, &ctr2, cchCount2, &Weight2,
                            &pLastJamo,
                            &uw1, &uw2,
                            &State,
                            &WhichJamo,
                            fModify );

                        if (WhichJamo) 
                        {
                            return (WhichJamo);
                        }                            
                        pString1 = pStr1;
                        pString2 = pStr2;

                        break;
                    }
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  Get the full weight in case DW got masked.
                        //
                        Weight1 = GET_DWORD_WEIGHT(pHashN, *pString1);
                        if (sm2 == EXTENSION_A)
                        {
                            Weight2 = GET_DWORD_WEIGHT(pHashN, *pString2);
                        }

                        //
                        //  Compare the weights.
                        //
                        if (Weight1 == Weight2)
                        {
                            //
                            //  Adjust pointers and counters and set flags.
                            //
                            pString1++;  pString2++;
                            ctr1--;  ctr2--;
                            Weight1 = CMP_INVALID_WEIGHT;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }
                        else
                        {
                            //
                            //  Get the actual UW to compare.
                            //
                            if (sm2 == EXTENSION_A)
                            {
                                //
                                //  Set the UW values to be the AW and DW since
                                //  both strings contain an extension A char.
                                //
                                uw1 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight1),
                                                       GET_DIACRITIC(&Weight1),
                                                       FALSE );
                                uw2 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight2),
                                                       GET_DIACRITIC(&Weight2),
                                                       FALSE );
                            }
                            else
                            {
                                //
                                //  Only string1 contains an extension A char,
                                //  so set the UW value to be the first UW
                                //  value for extension A (default values):
                                //    SM_EXT_A, AW_EXT_A
                                //
                                uw1 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A, fModify);
                            }
                        }

                        break;
                    }
                    case ( UNSORTABLE ) :
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  Switch on the script member of string 2 and take care
                //  of any special cases.
                //
                switch (sm2)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if (!fIgnoreDiacritic)
                        {
                            if ((WhichDiacritic == 0) ||
                                (State & STATE_REVERSE_DW))

                            {
                                WhichDiacritic = CSTR_LESS_THAN;

                                //
                                //  Remove state from state machine.
                                //
                                REMOVE_STATE(STATE_DW);
                            }
                        }

                        //
                        //  Adjust pointer and counter and set flags.
                        //
                        pString2++;
                        ctr2--;
                        Weight2 = CMP_INVALID_WEIGHT;

                        break;
                    }
                    case ( SYMBOL_1 ) :
                    case ( SYMBOL_2 ) :
                    case ( SYMBOL_3 ) :
                    case ( SYMBOL_4 ) :
                    case ( SYMBOL_5 ) :
                    {
                        //
                        //  If the ignore symbol flag is set, then skip over
                        //  the symbol.
                        //
                        if (fIgnoreSymbol)
                        {
                            pString2++;
                            ctr2--;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then
                        //  skip over the punctuation char.
                        //
                        if (fIgnorePunct)
                        {
                            //
                            //  Advance pointer 2 and decrement counter 2.
                            //
                            pString2++;
                            ctr2--;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }
                        else if (!fStringSort)
                        {
                            //
                            //  Use WORD sort method.
                            //
                            if (sm1 != PUNCTUATION)
                            {
                                //
                                //  The character in the first string is
                                //  NOT punctuation.
                                //
                                if (WhichPunct1)
                                {
                                    //
                                    //  Set WP 1 to show that string 1 is
                                    //  smaller, since a punctuation char had
                                    //  already been found at an earlier
                                    //  position in string 1.
                                    //
                                    //  Set the Ignore Punctuation flag so we
                                    //  just skip over any other punctuation
                                    //  chars in the string.
                                    //
                                    WhichPunct1 = CSTR_LESS_THAN;
                                    fIgnorePunct = TRUE;
                                }
                                else
                                {
                                    //
                                    //  Set WP 2 to show that string 1 is
                                    //  smaller, and that string 2 has had
                                    //  a punctuation char - since no
                                    //  punctuation chars have been found
                                    //  in string 1.
                                    //
                                    WhichPunct2 = CSTR_LESS_THAN;
                                }

                                //
                                //  Pointer 2 and counter 2 will be updated
                                //  after if-else statement.
                                //
                            }
                            else
                            {
                                //
                                //  Both code points are punctuation chars.
                                //
                                //  See if either of the strings has encountered
                                //  punctuation chars previous to this.
                                //
                                if (WhichPunct1)
                                {
                                    //
                                    //  String 1 has had a punctuation char, so
                                    //  it should be the smaller string (since
                                    //  both have punctuation chars).
                                    //
                                    WhichPunct1 = CSTR_LESS_THAN;
                                }
                                else if (WhichPunct2)
                                {
                                    //
                                    //  String 2 has had a punctuation char, so
                                    //  it should be the smaller string (since
                                    //  both have punctuation chars).
                                    //
                                    WhichPunct2 = CSTR_GREATER_THAN;
                                }
                                else
                                {
                                    BYTE aw1 = GET_ALPHA_NUMERIC(&Weight1);
                                    BYTE aw2 = GET_ALPHA_NUMERIC(&Weight2);

                                    if (aw1 == aw2) 
                                    {
                                        BYTE cw1 = GET_CASE(&Weight1);
                                        BYTE cw2 = GET_CASE(&Weight2);
                                        if (cw1 < cw2) 
                                        {
                                            WhichPunct1 = CSTR_LESS_THAN;
                                        } else if (cw1 > cw2)
                                        {
                                            WhichPunct1 = CSTR_GREATER_THAN;
                                        }
                                    } else 
                                    {                                
                                        //
                                        //  Position is the same, so compare the
                                        //  special weights.   Set WhichPunct1 to
                                        //  the smaller special weight.
                                        //
                                        WhichPunct1 = (aw1 < aw2
                                                        ? CSTR_LESS_THAN
                                                        : CSTR_GREATER_THAN);
                                    }
                                }

                                //
                                //  Set the Ignore Punctuation flag.
                                //
                                fIgnorePunct = TRUE;

                                //
                                //  Advance pointer 1 and decrement counter 1.
                                //  Pointer 2 and counter 2 will be updated
                                //  after if-else statement.
                                //
                                pString1++;
                                ctr1--;
                                Weight1 = CMP_INVALID_WEIGHT;
                            }

                            //
                            //  Advance pointer 2 and decrement counter 2.
                            //
                            pString2++;
                            ctr2--;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }

                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be restored.
                        //
                        if (pSave2 == NULL)
                        {
                            pSave2 = pString2;
                        }
                        pString2 = pTmpBuf2;

                        //
                        //  Add one to counter so that subtraction doesn't end
                        //  comparison prematurely.
                        //
                        ctr2++;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf2[0] = GET_EXPANSION_1(&Weight2);
                        pTmpBuf2[1] = GET_EXPANSION_2(&Weight2);

                        //
                        //  Set cExpChar2 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar2 = MAX_TBL_EXPANSION;

                        Weight2 = CMP_INVALID_WEIGHT;

                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm1 != EXPANSION) 
                        {                        
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight2.
                            //
                            GET_FAREAST_WEIGHT( Weight2,
                                                uw2,
                                                Mask,
                                                lpString2,
                                                pString2,
                                                ExtraWt2,
                                                fModify );

                            if (sm1 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the first string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 1 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt2) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt2) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt2) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt2) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_LESS_THAN;
                                }
                            }
                            else
                            {
                                //
                                //  Characters in both strings are fareast
                                //  special chars.
                                //
                                //  Set each of weights 4, 5, 6, and 7
                                //  appropriately (if not already set).
                                //
                                if ( (GET_WT_FOUR(&WhichExtra) == 0) &&
                                     ( GET_WT_FOUR(&ExtraWt1) !=
                                       GET_WT_FOUR(&ExtraWt2) ) )
                                {
                                    GET_WT_FOUR(&WhichExtra) =
                                      ( GET_WT_FOUR(&ExtraWt1) <
                                        GET_WT_FOUR(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_FIVE(&WhichExtra) == 0) &&
                                     ( GET_WT_FIVE(&ExtraWt1) !=
                                       GET_WT_FIVE(&ExtraWt2) ) )
                                {
                                    GET_WT_FIVE(&WhichExtra) =
                                      ( GET_WT_FIVE(&ExtraWt1) <
                                        GET_WT_FIVE(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SIX(&WhichExtra) == 0) &&
                                     ( GET_WT_SIX(&ExtraWt1) !=
                                       GET_WT_SIX(&ExtraWt2) ) )
                                {
                                    GET_WT_SIX(&WhichExtra) =
                                      ( GET_WT_SIX(&ExtraWt1) <
                                        GET_WT_SIX(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SEVEN(&WhichExtra) == 0) &&
                                     ( GET_WT_SEVEN(&ExtraWt1) !=
                                       GET_WT_SEVEN(&ExtraWt2) ) )
                                {
                                    GET_WT_SEVEN(&WhichExtra) =
                                      ( GET_WT_SEVEN(&ExtraWt1) <
                                        GET_WT_SEVEN(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        if (!JamoFlag)
                        {
                            LPWSTR pStr1 = pString1;
                            LPWSTR pStr2 = pString2;

                            FindJamoDifference(
                                pHashN,
                                &pStr1, &ctr1, cchCount1, &Weight1,
                                &pStr2, &ctr2, cchCount2, &Weight2,
                                &pLastJamo,
                                &uw1, &uw2,
                                &State,
                                &WhichJamo,
                                fModify );
                            if (WhichJamo) 
                            {
                                return (WhichJamo);
                            }                                                            
                            pString1 = pStr1;
                            pString2 = pStr2;
                        }
                        else
                        {
                            //
                            //  Reset the Jamo flag.
                            //
                            JamoFlag = FALSE;
                        }

                        break;
                    }
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  If sm1 is an extension A character, then
                        //  both sm1 and sm2 have been handled.  We should
                        //  only get here when either sm1 is not an
                        //  extension A character or the two extension A
                        //  characters are different.
                        //
                        if (sm1 != EXTENSION_A)
                        {
                            //
                            //  Get the full weight in case DW got masked.
                            //  Also, get the actual UW to compare.
                            //
                            //  Only string2 contains an extension A char,
                            //  so set the UW value to be the first UW
                            //  value for extension A (default values):
                            //    SM_EXT_A, AW_EXT_A
                            //
                            Weight2 = GET_DWORD_WEIGHT(pHashN, *pString2);
                            uw2 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A, fModify);
                        }

                        //
                        //  We should then fall through to the comparison
                        //  of the Unicode weights.
                        //

                        break;
                    }
                    case ( UNSORTABLE ) :
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  See if the comparison should start again.
                //
                if ((Weight1 == CMP_INVALID_WEIGHT) || (Weight2 == CMP_INVALID_WEIGHT))
                {
                    //
                    //  Check to see if we're modifying the script value.
                    //  If so, then we need to reset the fareast weight
                    //  (if applicable) so that it doesn't get modified
                    //  again.
                    //
                    if (fModify == TRUE)
                    {
                        if (sm1 == FAREAST_SPECIAL)
                        {
                            Weight1 = CMP_INVALID_WEIGHT;
                        }
                        else if (sm2 == FAREAST_SPECIAL)
                        {
                            Weight2 = CMP_INVALID_WEIGHT;
                        }
                    }
                    continue;
                }

                //
                //  We're not supposed to drop down into the state table if
                //  the unicode weights are different, so stop comparison
                //  and return result of unicode weight comparison.
                //
                if (uw1 != uw2)
                {
                    return ((uw1 < uw2) ? CSTR_LESS_THAN : CSTR_GREATER_THAN);
                }
            }

            //
            //  For each state in the state table, do the appropriate
            //  comparisons.
            //
            if (State & (STATE_DW | STATE_REVERSE_DW))
            {
                //
                //  Get the diacritic weights.
                //
                dw1 = GET_DIACRITIC(&Weight1);
                dw2 = GET_DIACRITIC(&Weight2);

                if (dw1 != dw2)
                {
                    //
                    //  Look ahead to see if diacritic follows a
                    //  minimum diacritic weight.  If so, get the
                    //  diacritic weight of the nonspace mark.
                    //
                    while (!AT_STRING_END(ctr1 - 1, pString1 + 1, cchCount1))
                    {
                        Wt = GET_DWORD_WEIGHT(pHashN, *(pString1 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw1 += GET_DIACRITIC(&Wt);
                            pString1++;
                            ctr1--;
                        }
                        else
                        {
                            break;
                        }
                    }

                    while (!AT_STRING_END(ctr2 - 1, pString2 + 1, cchCount2))
                    {
                        Wt = GET_DWORD_WEIGHT(pHashN, *(pString2 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw2 += GET_DIACRITIC(&Wt);
                            pString2++;
                            ctr2--;
                        }
                        else
                        {
                            break;
                        }
                    }

                    //
                    //  Save which string has the smaller diacritic
                    //  weight if the diacritic weights are still
                    //  different.
                    //
                    if (dw1 != dw2)
                    {
                        WhichDiacritic = (dw1 < dw2)
                                           ? CSTR_LESS_THAN
                                           : CSTR_GREATER_THAN;

                        //
                        //  Remove state from state machine.
                        //
                        REMOVE_STATE(STATE_DW);
                    }
                }
            }
            if (State & STATE_CW)
            {
                //
                //  Get the case weights.
                //
                if (GET_CASE(&Weight1) != GET_CASE(&Weight2))
                {
                    //
                    //  Save which string has the smaller case weight.
                    //
                    WhichCase = (GET_CASE(&Weight1) < GET_CASE(&Weight2))
                                  ? CSTR_LESS_THAN
                                  : CSTR_GREATER_THAN;

                    //
                    //  Remove state from state machine.
                    //
                    REMOVE_STATE(STATE_CW);
                }
            }
        }

        //
        //  Fixup the pointers and counters.
        //
        POINTER_FIXUP();
        ctr1--;
        ctr2--;

        //
        //  Reset the weights to be invalid.
        //
        Weight1 = CMP_INVALID_WEIGHT;
        Weight2 = CMP_INVALID_WEIGHT;
    }

    //
    //  If the end of BOTH strings has been reached, then the unicode
    //  weights match exactly.  Check the diacritic, case and special
    //  weights.  If all are zero, then return success.  Otherwise,
    //  return the result of the weight difference.
    //
    //  NOTE:  The following checks MUST REMAIN IN THIS ORDER:
    //            Diacritic, Case, Punctuation.
    //
    if (AT_STRING_END(ctr1, pString1, cchCount1))
    {
        if (AT_STRING_END(ctr2, pString2, cchCount2))
        {
            if (WhichDiacritic)
            {
                return (WhichDiacritic);
            }
            if (WhichCase)
            {
                return (WhichCase);
            }
            if (WhichExtra)
            {
                if (!fIgnoreDiacritic)
                {
                    if (GET_WT_FOUR(&WhichExtra))
                    {
                        return (GET_WT_FOUR(&WhichExtra));
                    }
                    if (GET_WT_FIVE(&WhichExtra))
                    {
                        return (GET_WT_FIVE(&WhichExtra));
                    }
                }
                if (GET_WT_SIX(&WhichExtra))
                {
                    return (GET_WT_SIX(&WhichExtra));
                }
                if (GET_WT_SEVEN(&WhichExtra))
                {
                    return (GET_WT_SEVEN(&WhichExtra));
                }
            }
            if (WhichPunct1)
            {
                return (WhichPunct1);
            }
            if (WhichPunct2)
            {
                return (WhichPunct2);
            }

            return (CSTR_EQUAL);
        }
        else
        {
            //
            //  String 2 is longer.
            //
            pString1 = pString2;
            ctr1 = ctr2;
            cchCount1 = cchCount2;
            fEnd1 = CSTR_LESS_THAN;
        }
    }
    else
    {
        fEnd1 = CSTR_GREATER_THAN;
    }

    //
    //  Scan to the end of the longer string.
    //
    SCAN_LONGER_STRING( ctr1,
                        pString1,
                        cchCount1,
                        fEnd1 );
}


////////////////////////////////////////////////////////////////////////////
//
//  FindJamoDifference
//
////////////////////////////////////////////////////////////////////////////

int FindJamoDifference(
    PLOC_HASH pHashN,
    LPCWSTR* ppString1, int* ctr1, int cchCount1, DWORD* pWeight1,
    LPCWSTR* ppString2, int* ctr2, int cchCount2, DWORD* pWeight2,
    LPCWSTR* pLastJamo,
    WORD* uw1,
    WORD* uw2,
    int* pState,
    int* WhichJamo,
    BOOL fModify)
{
    int bRestart = 0;            // if string compare should restart again
    int oldHangulsFound1 = 0;    // # of valid old Hangul Jamo compositions found
    int oldHangulsFound2 = 0;    // # of valid old Hangul Jamo compositions found
    WORD UW;
    BYTE JamoWeight1[3];         // extra weight for first old Hangul composition
    BYTE JamoWeight2[3];         // extra weight for second old Hangul composition

    //
    //  Roll back to the first Jamo.  We know that these Jamos in both strings
    //  should be equal, so we can decrement both strings at once.
    //
    while ((*ppString1 > *pLastJamo) && IsJamo(*(*ppString1 - 1)))
    {
        (*ppString1)--; (*ppString2)--; (*ctr1)++; (*ctr2)++;
    }

    //
    //  Now we are at the beginning of two groups of Jamo characters.
    //  Compare Jamo unit (either a single Jamo or a valid old Hangul Jamo
    //  composition) until we run out Jamo units in either strings.
    //  We also exit when we reach the ends of either string.
    //
    //  while (NOT_END_STRING(*ctr1, *ppString1, cchCount1) &&
    //         NOT_END_STRING(*ctr2, *ppString2, cchCount2))
    //
    for (;;)
    {
        if (IsJamo(**ppString1))
        {
            if (IsLeadingJamo(**ppString1))
            {
                if ((oldHangulsFound1 = MapOldHangulSortKey( pHashN,
                                                             *ppString1,
                                                             *ctr1,
                                                             &UW,
                                                             JamoWeight1,
                                                             fModify )) > 0)
                {
                    *uw1 = UW;

                    //
                    //  Mark *pWeight1 so that it is not CMP_INVALID_WEIGHT.
                    //  0202 is the DW/CW.
                    //
                    *pWeight1 = ((DWORD)UW | 0x02020000);

                    //
                    //  We always increment ppString1/ctr1 at the end of the
                    //  loop, so we need to subtract 1 here.
                    //
                    *ppString1 += (oldHangulsFound1 - 1);
                    *ctr1 -= (oldHangulsFound1 - 1);
                }
            }
            if (oldHangulsFound1 == 0)
            {
                //
                //  No valid old Hangul compositions are found.  Get the UW
                //  for the Jamo instead.
                //
                *pWeight1 = GET_DWORD_WEIGHT(pHashN, **ppString1);

                //
                //  The SMs in PSORTKEY for Jamos are not really SMs. They
                //  are all 4 (for JAMO_SPECIAL).
                //  Here we get the real Jamo Unicode weight. The actual SM
                //  is stored in DW.
                //
                *uw1 = MAKE_UNICODE_WT( GET_DIACRITIC(pWeight1),
                                        GET_ALPHA_NUMERIC(pWeight1),
                                        fModify );
                ((PSORTKEY)pWeight1)->Diacritic = MIN_DW;
            }
        }

        if (IsJamo(**ppString2))
        {
            if (IsLeadingJamo(**ppString2))
            {
                if ((oldHangulsFound2 = MapOldHangulSortKey( pHashN,
                                                             *ppString2,
                                                             *ctr2,
                                                             &UW,
                                                             JamoWeight2,
                                                             fModify )) > 0)
                {
                    *uw2 = UW;
                    *pWeight2 = ((DWORD)UW | 0x02020000);
                    *ppString2 += (oldHangulsFound2 - 1);
                    *ctr2 -= (oldHangulsFound2 - 1);
                }
            }
            if (oldHangulsFound2 == 0)
            {
                *pWeight2 = GET_DWORD_WEIGHT(pHashN, **ppString2);
                *uw2 = MAKE_UNICODE_WT( GET_DIACRITIC(pWeight2),
                                        GET_ALPHA_NUMERIC(pWeight2),
                                        fModify );
                ((PSORTKEY)pWeight2)->Diacritic = MIN_DW;                                        
            }
        }

        //
        //  See if either weight is invalid.
        // A weight can be invalid when the character is not a Jamo.
        //
        if (*pWeight1 == CMP_INVALID_WEIGHT)
        {
            //
            //  The current character is not a Jamo.  Set the Weight to
            //  be CMP_INVALID_WEIGHT, so that the string comparision can
            //  restart within the loop of CompareString().
            //
            *pWeight1 = CMP_INVALID_WEIGHT;
            bRestart = 1;
            goto FindJamoDifferenceExit;
        }
        if (*pWeight2 == CMP_INVALID_WEIGHT)
        {
            //
            //  The current character is not a Jamo.  Set the Weight to
            //  be CMP_INVALID_WEIGHT, so that the string comparision can
            //  restart within the loop of CompareString().
            //
            *pWeight2 = CMP_INVALID_WEIGHT;
            bRestart = 1;
            goto FindJamoDifferenceExit;
        }
        if (*uw1 != *uw2)
        {
            //
            //  Found differences in Unicode weight.  We can stop the
            //  processing now.
            //
            goto FindJamoDifferenceExit;
        }

        //
        //  When we get here, we know that we have the same Unicode Weight.
        //  Check if we need to record the WhichJamo.
        //
        if ((*pState & STATE_JAMO_WEIGHT) &&
            ((oldHangulsFound1 > 0) || (oldHangulsFound2 > 0)))
        {
            if ((oldHangulsFound1 > 0) && (oldHangulsFound2 > 0))
            {
                *WhichJamo = (int)memcmp( JamoWeight1,
                                                    JamoWeight2,
                                                    sizeof(JamoWeight1) ) + 2;
            }
            else if (oldHangulsFound1 > 0)
            {
                *WhichJamo = CSTR_GREATER_THAN;
            }
            else
            {
                *WhichJamo = CSTR_LESS_THAN;
            }
            *pState &= ~STATE_JAMO_WEIGHT;
            oldHangulsFound1 = oldHangulsFound2 = 0;
        }
        (*ppString1)++; (*ctr1)--;
        (*ppString2)++; (*ctr2)--;

        if (AT_STRING_END(*ctr1, *ppString1, cchCount1) ||
            AT_STRING_END(*ctr2, *ppString2, cchCount2))
        {
            break;
        }
        *pWeight1 = *pWeight2 = CMP_INVALID_WEIGHT;
    }

    //
    //  If we drop out of the while loop because we reach the end of strings,
    //  decrement the pointers by one because loops in CompareString() will
    //  increase the pointers at the end of the loop.
    //
    //  If we drop out of the while loop because the goto's in it, we are
    //  already off by one.
    //
    if (AT_STRING_END(*ctr1, *ppString1, cchCount1))
    {
        (*ppString1)--; (*ctr1)++;
    }
    if (AT_STRING_END(*ctr2, *ppString2, cchCount2))
    {
        (*ppString2)--; (*ctr2)++;
    }

FindJamoDifferenceExit:
    *pLastJamo = *ppString1;
    return (bRestart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\data\dlls\share.h ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    share.h

Abstract:

    This file contains the header information shared by all of code page
    DLL modules.

Revision History:

    10-30-96    JulieB    Created.

--*/



#ifndef _NLS_DLLS_
#define _NLS_DLLS_




////////////////////////////////////////////////////////////////////////////
//
//  RTL Includes Files.
//
////////////////////////////////////////////////////////////////////////////

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif




////////////////////////////////////////////////////////////////////////////
//
//  Include Files.
//
////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <winnlsp.h>




////////////////////////////////////////////////////////////////////////////
//
//  Constant Declarations.
//
////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////
//
//  Typedef Declarations.
//
////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////
//
//  Macro Definitions.
//
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
//
//  NLS_ALLOC_MEM
//
//  Allocates the given number of bytes of memory from the process heap,
//  zeros the memory buffer, and returns the handle.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_ALLOC_MEM(dwBytes)                                             \
    ( RtlAllocateHeap( RtlProcessHeap(),                                   \
                       HEAP_ZERO_MEMORY,                                   \
                       dwBytes ) )


////////////////////////////////////////////////////////////////////////////
//
//  NLS_FREE_MEM
//
//  Frees the memory of the given handle from the process heap.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_FREE_MEM(hMem)                                                 \
    ( (hMem) ? (RtlFreeHeap( RtlProcessHeap(),                             \
                             0,                                            \
                             (PVOID)hMem ))                                \
             : 0 )




////////////////////////////////////////////////////////////////////////////
//
//  Function Prototypes
//
////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////
//
//  Global Variables
//
//  Globals are included last because they may require some of the types
//  being defined above.
//
////////////////////////////////////////////////////////////////////////////



#endif   // _NLS_DLLS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\winnls\data\dlls\gb18030\c_gb18030.cpp ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    c_gb18030.c

Abstract:

    This file contains functions to convert GB18030-2000 (code page 54936) into Unicode, and vice versa.
    The target module is c_g18030.dll.  This will be the external DLL used by WideCharToMultiByte()
    and MultiByteToWideChar() to perform the conversion for GB18030 codepage.

    External Routines in this file:
      DllEntry
      NlsDllCodePageTranslation

Notes:
    GB18030-2000 (aka GBK2K) is designed to be mostly compatible with GBK (codepage 936), 
    while supports the full range of Unicode code points (BMP + 16 supplementary planes).

    The structure for GB18030 is:
        * Single byte: 
            0x00 ~ 0x7f
        * Two-byte: 
            0x81 ~ 0xfe, 0x40 ~ 0x7e    (leading byte, trailing byte)
            0x81 ~ 0xfe, 0x80 ~ 0xfe    (leading byte, trailing byte)
        * Four-byte:
            0x81 ~ 0xfe, 0x30 ~ 0x39, 0x81 ~ 0xfe, 0x30 ~ 0x39.
            The surrogare pair will be encoded from 0x90, 0x30, 0x81, 0x30

    The BMP range is fully supported in GB18030 using 1-byte, 2-byte and 4-byte sequences.
    In valid 4-byte GB18030, there are two gaps that can not be mapped to Unicode characters.
        0x84, 0x31, 0xa5, 0x30 (just after the GB18030 bytes for U+FFFF(*)) ~ 0x8f, 0x39, 0xfe, 0x39 (just before the first GB18030 bytes for U+D800,U+DC00)
        0xe3, 0x32, 0x9a, 0x36 (just after the GB18030 bytes for U+DBFF U+DFFF(**)) ~ 0xfe, 0x39, 0xfe, 0x39
        

        Note1: U+FFFF = 0x84, 0x31, 0xa4, 0x39
        Note2: U+DBFF U+DFFF = 0xe3, 0x32, 0x9a, 0x35

    Tables used in c_g18030.dll:
        * From Unicode to bytes:
            * g_wUnicodeToGB:
                Used to convert Unicode character to 2-byte GBK, 2-byte GB18030, or 4-byte GB18030.
                The index is 0x0000 ~ 0xffff, for Unicode BMP range.
                When the valures are:
                
                    Value       Meaning
                    ======      =======
                    0xffff      2-byte GB18030, which is compatible with GBK.  Call WC2MB(936,...) to convert.
                    0xfffe ~ [0xfffe - (ARRAYSIZE(g_wUnicodeToGBTwoBytes))+1]
                                2-byte GB18030, which is NOT compatible with GBK.  (0xfffe - Value) will be indexed into
                                a second table g_wUnicodeToGBTwoBytes, which contains the two-byte GB18030 values.
                                E.g. if the value is 0xfffe, the index into g_wUnicodeToGBTwoBytes is 0, so the two-byte
                                GB18030 will be 0xa8, 0xbf (which are stored g_wUnicodeToGBTwoBytes[0],g_wUnicodeToGBTwoBytes[1])
                    0x0000 ~ 0x99fb
                                An offset value that can be used to convert to 4-byte GB18030
                                If the value is 0x000, the 4-byte GB18030 is 0x81, 0x30, 0x81, 0x30.
                                
        * From bytes to Unicode
            * Two-byte GB18030 to Unicode:
                * g_wGBLeadByteOffset
                    The index into this table is lead byte 0x80 ~ 0xff (converted to index 0x00 ~ 0x7f).  
                    If the value is 0x0000, it means that this lead byte is compatible with GBK.  
                    Otherwise, the value can be:
                    0x0100  This is used to indexed into g_wUnicodeFromGBTwoBytes[0x0000 ~ 0x00ff].  
                            The value of g_wUnicodeFromGBTwoBytesis the Unicode value for this lead byte with the next valid trailing byte.
                    0x0200  This is used to indexed into g_wUnicodeFromGBTwoBytes[0x0100 ~ 0x01ff].  
                    0x0300  This is used to indexed into g_wUnicodeFromGBTwoBytes[0x0200 ~ 0x02ff].  
                    0x0400  This is used to indexed into g_wUnicodeFromGBTwoBytes[0x0300 ~ 0x03ff].  
                    
                    E.g. g_wGBLeadByteOffset[0x07] = 0x0000. It means that GB18030 two-byte lead byte 0x87 is compatible with GBK.
                    g_wGBLeadByteOffset[0x28] = 0x0200.  It means that GB18030 two-byte lead byte 0xa8 (0x28+0x80 = 0xa8) is NOT compatible with GBK.
                    The Unicode value for 0xa8, <trail byte> will be stored in g_wUnicodeFromGBTwoBytes[0x0100+<trail byte>]
                    
            * Four-byte GB18030 to Unicode:
                * g_wGBFourBytesToUnicode
                    The table is used to convert 4-byte GB18030 into a Unicode.
                    
                    The index value is the offset of the 4-byte GB18030.

                    4-byte GB18030      Index value
                    ==============      ===========
                    81,30,81,30         0
                    81,30,81,31         1
                    81,30,81,32         2
                    ...                 ...

                    The value of g_wGBFourBytesToUnicode cotains the Unicode codepoint for the offset of the 
                    corresponding 4-byte GB18030.

                    E.g. g_wGBFourBytesToUnicode[0] = 0x0080.  This means that GB18030 0x81, 0x30, 0x81, 0x30 will be converted to Unicode U+0800.
    
Revision History:

    02-20-2001    YSLin    Created.
    
--*/




//
//  Include Files.
//

#include <share.h>
#include "c_gb18030.h"

//
//  Constant Declarations.
//


//
// Structure used in GetCPInfo().
//
CPINFO g_CPInfo = 
{
    //UINT    MaxCharSize;
    4,
    //BYTE    DefaultChar[MAX_DEFAULTCHAR];
    {0x3f, 0x00},
    //BYTE    LeadByte[MAX_LEADBYTES];
    // Since GBK2K can have up to 4 bytes, we don't return
    // 0x81-0xfe as lead bytes here.
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    
};

// This is the offset for the start of surrogate U+D800, U+DC00
#define SURROGATE_OFFSET        GET_FOUR_BYTES_OFFSET_FROM_BYTES(0x90, 0x30, 0x81, 0x30)
// This is the offset for the end of surrogate U+DBFF, U+DFFF
#define SURROGATE_MAX_OFFSET    GET_FOUR_BYTES_OFFSET_FROM_BYTES(0xe3, 0x32, 0x9a, 0x35)


//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsDllCodePageTranslation
//
//  This routine is the main exported procedure for the functionality in
//  this DLL.  All calls to this DLL must go through this function.
//
//  02-20-2001    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

STDAPI_(DWORD) NlsDllCodePageTranslation(
    DWORD CodePage,
    DWORD dwFlags,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar,
    LPCPINFO lpCPInfo)
{

    //
    //  Error out if internally needed c_*.nls file is not installed.
    //
    if (!IsValidCodePage(CODEPAGE_GBK))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    switch (dwFlags)
    {
        case ( NLS_CP_CPINFO ) :
        {
            memcpy(lpCPInfo, &g_CPInfo, sizeof(CPINFO));
            return (TRUE);
        }
        case ( NLS_CP_MBTOWC ) :
        {
            return (BytesToUnicode((BYTE*)lpMultiByteStr, cchMultiByte, NULL, lpWideCharStr, cchWideChar));
        }
        case ( NLS_CP_WCTOMB ) :
        {
            return (UnicodeToBytes(lpWideCharStr, cchWideChar, lpMultiByteStr, cchMultiByte));
        }
    }

    //
    //  This shouldn't happen since this gets called by the NLS APIs.
    //
    SetLastError(ERROR_INVALID_PARAMETER);
    return (0);
}

//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////
//
//  GetBytesToUnicodeCount
//
//  Return the Unicode character count needed to convert the specified
//  GB18030 multi-byte string.
//
//  Parameters:
//      lpMultiByteStr  The multi-byte string to be converted.
//      cchMultiByte    The byte size of the multi-byte string to be converted
//      bSupportEncoder If TRUE and we have a lead byte at the end of string,
//                      we will not convert that lead byte.  Otherwise,
//                      convert it to the default character.
//
//  02-21-2001    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

DWORD GetBytesToUnicodeCount(BYTE* lpMultiByteStr, int cchMultiByte, BOOL bSupportEncoder)
{
    int i = 0;
    BYTE ch;
    DWORD cchWCCount = 0;
    WORD wOffset;
    BYTE offset1, offset2, offset3, offset4;
    DWORD dwFourBytesOffset;
    
    if (cchMultiByte == -1)
    {
        cchMultiByte = strlen((LPSTR)lpMultiByteStr);
    }
    
    while (i < cchMultiByte)
    {
        ch = lpMultiByteStr[i];
        if (ch <= 0x7f)
        {
            cchWCCount++;
            i++;
        } else if (IS_GB_LEAD_BYTE(ch))
        {
            offset1 = (ch - GBK2K_BYTE1_MIN);
            //
            // If this is a lead byte, look ahead to see if this is
            // a two-byte GB18030 or four-byte GB18030.
            //
            if (i+1 < cchMultiByte)
            {
                if (IS_GB_TWO_BYTES_TRAILING(lpMultiByteStr[i+1]))
                {
                    
                    //
                    // The trailing byte is a GB18030 two-byte.
                    //
                    cchWCCount++;
                    i += 2;                        
                } else if (i+3 < cchMultiByte) 
                {
                    //
                    // Check if this is a four-byte GB18030.
                    //
                    if (IS_GB_FOUR_BYTES_TRAILING(lpMultiByteStr[i+1]) &&
                        IS_GB_LEAD_BYTE(lpMultiByteStr[i+2]) &&
                        IS_GB_FOUR_BYTES_TRAILING(lpMultiByteStr[i+3]))
                    {
                        offset2 = lpMultiByteStr[i+1] - GBK2K_BYTE2_MIN;
                        offset3 = lpMultiByteStr[i+2] - GBK2K_BYTE3_MIN;
                        offset4 = lpMultiByteStr[i+3] - GBK2K_BYTE4_MIN;
                        //
                        // Four-byte GB18030
                        //
                        dwFourBytesOffset = GET_FOUR_BYTES_OFFSET(offset1, offset2, offset3, offset4);
                        if (dwFourBytesOffset <= g_wMax4BytesOffset) 
                        {
                            //
                            // The Unicode will be in the BMP range.
                            //
                            cchWCCount++;                            
                        } else if (dwFourBytesOffset >= SURROGATE_OFFSET && dwFourBytesOffset <= SURROGATE_MAX_OFFSET)
                        {
                            //
                            // This will be converted to a surrogate pair.
                            //
                            cchWCCount+=2;
                        } else {
                            //
                            // Valid GBK2K code point, but can not be mapped to Unicode.
                            //
                            cchWCCount++;
                        }                        
                        i += 4;
                    } else 
                    {
                        if (bSupportEncoder)
                        {
                            // Set i to cchMultiByte so that we will bail out the while loop.
                            i = cchMultiByte;
                        } else 
                        {
                            //
                            // We have a lead byte, but do have have a valid trailing byte.
                            //
                            // Use default Unicode char.
                            i++;
                            cchWCCount++;
                        }                    
                    }
                }else
                {
                    if (bSupportEncoder)
                    {
                        // Set i to cchMultiByte so that we will bail out the while loop.
                        i = cchMultiByte;
                    } else 
                    {
                        //
                        // We have a lead byte, but do have have a valid trailing byte.
                        //
                        // Use default Unicode char.
                        i++;
                        cchWCCount++;
                    }
                }
            } else
            {
                //
                // We have a lead byte at the end of the string.
                //
                if (bSupportEncoder)
                {
                    i++;
                } else
                {
                    // Use default Unicode char.
                    i++;
                    cchWCCount++;
                }
            }
        }else
        {
            //
            // This byte is NOT between 0x00 ~ 0x7f, and not a lead byte.
            // Use the default character.
            //
            i++;
            cchWCCount++;
        }
    }

    return (cchWCCount);
    
}

BOOL __forceinline PutDefaultCharacter(UINT* pCchWCCount, UINT cchWideChar, LPWSTR lpWideCharStr)
{
    //
    // This byte is NOT between 0x00 ~ 0x7f, not a lead byte.
    //
    if (*pCchWCCount >= cchWideChar)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (FALSE);
    }
    lpWideCharStr[(*pCchWCCount)++] = GB18030_DEFAULT_UNICODE_CHAR; 
    return (TRUE);
}

STDAPI_(DWORD) BytesToUnicode(
    BYTE* lpMultiByteStr,
    UINT cchMultiByte,
    UINT* pcchLeftOverBytes,
    LPWSTR lpWideCharStr,
    UINT cchWideChar)
{

    UINT i = 0;
    BYTE ch;
    UINT cchWCCount = 0;
    BYTE offset1, offset2, offset3, offset4;
    WORD wOffset;
    DWORD dwOffset;
    int nResult;
    
    if ((lpWideCharStr == NULL) || (cchWideChar == 0))
    {
        return (GetBytesToUnicodeCount(lpMultiByteStr, cchMultiByte, (pcchLeftOverBytes != NULL)));
    }
    
    if (cchMultiByte == -1)
    {
        cchMultiByte = strlen((LPSTR)lpMultiByteStr);
    }

    if (pcchLeftOverBytes != NULL)
    {
        *pcchLeftOverBytes = 0;
    }

    //
    // NOTENOTE YSLin:
    // If you make fix in the following code, remember to make the appropriate fix
    // in GetBytesToUnicodeCount() as well.
    //
    while (i < cchMultiByte)
    {
        ch = lpMultiByteStr[i];
        if (ch <= 0x7f)
        {
            // 
            // This byte is from 0x00 ~ 0x7f.
            //
            if (cchWCCount >= cchWideChar)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }                
            lpWideCharStr[cchWCCount++] = ch;
            i++;
        } else if (IS_GB_LEAD_BYTE(ch))
        {
            offset1 = ch - GBK2K_BYTE1_MIN;
            //
            // If this is a lead byte, just look ahead to see if this is
            // a two-byte GB18030 or four-byte GB18030.
            //
            if (i+1 < cchMultiByte)
            {
                if (IS_GB_TWO_BYTES_TRAILING(lpMultiByteStr[i+1]))
                {
                    //
                    // The trailing byte is a GB18030 two-byte.
                    //
                
                    //
                    // Look up the table to see if we have the table for
                    // the mapping Unicode character.
                    //                
                    wOffset = g_wGBLeadByteOffset[ch - 0x80];
                    if (wOffset == 0x0000)
                    {
                        if (cchWCCount == cchWideChar)
                        {
                            SetLastError(ERROR_INSUFFICIENT_BUFFER);
                            return (0);
                        }
                        //
                        // We don't have the table, because this is a GBK compatible two-byte GB18030.
                        //
                        
                        //
                        // Two-byte GB18030
                        //
                        nResult = MultiByteToWideChar(CODEPAGE_GBK, 0, (LPCSTR)(lpMultiByteStr+i), 2, lpWideCharStr+cchWCCount, 1);
                        if (nResult == 0)
                        {
                            return (0);
                        }
                        cchWCCount++; 
                        i += 2;                        
                    } else
                    {
                        if (cchWCCount == cchWideChar)
                        {
                            SetLastError(ERROR_INSUFFICIENT_BUFFER);
                            return (0);
                        }                                    
                        wOffset -= 0x0100;
                        lpWideCharStr[cchWCCount++] = g_wUnicodeFromGBTwoBytes[wOffset + lpMultiByteStr[i+1]];
                        i+= 2;
                    }                
                } else if (i+3 < cchMultiByte) 
                {
                    if (IS_GB_FOUR_BYTES_TRAILING(lpMultiByteStr[i+1]) &&
                        IS_GB_LEAD_BYTE(lpMultiByteStr[i+2]) &&
                        IS_GB_FOUR_BYTES_TRAILING(lpMultiByteStr[i+3]))
                    {
                        offset2 = lpMultiByteStr[i+1] - GBK2K_BYTE2_MIN;
                        offset3 = lpMultiByteStr[i+2] - GBK2K_BYTE3_MIN;
                        offset4 = lpMultiByteStr[i+3] - GBK2K_BYTE4_MIN;
                        
                        //
                        // Four-byte GB18030
                        //
                        dwOffset = GET_FOUR_BYTES_OFFSET(offset1, offset2, offset3, offset4);
                        if (dwOffset <= g_wMax4BytesOffset) 
                        {
                            if (cchWCCount == cchWideChar)
                            {
                                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                                return (0);
                            }                                    
                        
                            //
                            // The Unicode will be in the BMP range.
                            //
                            lpWideCharStr[cchWCCount++] = g_wGBFourBytesToUnicode[dwOffset];
                        } else if (dwOffset >= SURROGATE_OFFSET && dwOffset <= SURROGATE_MAX_OFFSET) 
                        {
                            if (cchWCCount + 2 > cchWideChar)
                            {
                                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                                return (0);
                            }                                    
                            //
                            // This will be converted to a surrogate pair.
                            //
                            dwOffset -= SURROGATE_OFFSET;
                            lpWideCharStr[cchWCCount++] = 0xd800 + (WORD)(dwOffset / 0x400);
                            lpWideCharStr[cchWCCount++] = 0xdc00 + (WORD)(dwOffset % 0x400);
                        } else
                        {
                            //
                            // Valid GBK2K code point, but can not be mapped to Unicode.
                            //
                            if (!PutDefaultCharacter(&cchWCCount, cchWideChar, lpWideCharStr))
                            {
                                return (0);
                            }    
                        }   
                        i += 4;
                    }else
                    {
                        if (!PutDefaultCharacter(&cchWCCount, cchWideChar, lpWideCharStr))
                        {
                            return (0);
                        }
                        i++;
                    }                    
                }else
                {
                    if (pcchLeftOverBytes != NULL)
                    {
                        *pcchLeftOverBytes = cchMultiByte - i;
                        // Set i to cchMultiByte so that we will bail out the while loop.
                        i = cchMultiByte;
                    } else 
                    {
                        //
                        // We have a lead byte, but do have have a valid trailing byte.
                        //
                        // Use default Unicode char.
                        if (!PutDefaultCharacter(&cchWCCount, cchWideChar, lpWideCharStr))
                        {
                            return (0);
                        }
                        i++;
                    }
                }
            } else
            {
                if (pcchLeftOverBytes != NULL) 
                {
                    *pcchLeftOverBytes = 1;
                    i++;
                } else
                {
                    // We have a lead byte, but do have have a trailing byte.
                    // Use default Unicode char.
                    if (!PutDefaultCharacter(&cchWCCount, cchWideChar, lpWideCharStr))
                    {
                        return (0);
                    }
                    i++;
                }
            }
        } else 
        {
            if (!PutDefaultCharacter(&cchWCCount, cchWideChar, lpWideCharStr))
            {
                return (0);
            }
            i++;
        }
    }
    return (cchWCCount);
}

DWORD GetUnicodeToBytesCount(LPWSTR lpWideCharStr, int cchWideChar)
{
    int i;
    WORD wch;
    int cchMBCount = 0;
    DWORD wOffset;

    if (cchWideChar == -1)
    {
        cchWideChar = wcslen(lpWideCharStr);
    }
    
    for (i = 0; i < cchWideChar; i++) 
    {
        wch = lpWideCharStr[i];

        if (wch <= 0x7f)
        {
            // One-byte GB18030.
            cchMBCount++;
        } else if (IS_HIGH_SURROGATE(wch))
        {
            //
            // Look ahead one character to see if the next char is a low surrogate.
            //
            if (i + 1 < cchWideChar)
            {
                if (IS_LOW_SURROGATE(lpWideCharStr[ i+1 ]))
                {
                    //
                    // Found a surrogate pair.  This will be a four-byte GB18030.
                    //
                    cchMBCount += 4;    
                    i++;
                } else
                {
                    //
                    // A High surrogate character without a trailing low surrogate character.
                    // In this case, we will convert this character to a default character.
                    //
                    cchMBCount++;
                }
            } else
            {
                //
                // A High surrogate character without a valid trailing low surrogate character.
                // In this case, we will convert this character to a default character.  
                //
                cchMBCount++;
            }
        } else if (IS_LOW_SURROGATE(wch))
        {
            //
            // Only a low surrogate character without a leading high surrogate.
            // In this case, we will convert this character to a default character.  
            //
            cchMBCount++;
        } else
        {
            //
            // Not a surrogate character.  Look up the table to see this BMP Unicode character
            // will be converted to a two-byte GB18030 or four-byte GB18030.
            //
            wOffset = g_wUnicodeToGB[wch];

            if (wOffset == 0xFFFF)
            {
                //
                // This Unicode character will be converted to GBK compatible two-byte code.
                //
                cchMBCount += 2;
            } else if (wOffset <= g_wMax4BytesOffset)
            {
                //
                // This Unicode character will be converted to four-byte GB18030.
                //
                cchMBCount += 4;                    
            } else
            {
                //
                // This Unicode character will be converted to two-byte GB18030, which is not compatible
                // with GBK.
                //
                cchMBCount += 2;
            }
        }                
    }
    return (cchMBCount);
}

STDAPI_(DWORD) UnicodeToBytes(
    LPWSTR lpWideCharStr,
    UINT cchWideChar,
    LPSTR lpMultiByteStr,
    UINT cchMultiByte)
{
    UINT i;
    WORD wch;
    UINT cchMBCount = 0;
    CHAR MBTwoBytes[2];
    BYTE MBFourBytes[4];
    WORD wOffset;
    DWORD dwSurrogateOffset;
    int nResult;

    if ((lpMultiByteStr == NULL) || (cchMultiByte == 0))
    {
        return (GetUnicodeToBytesCount(lpWideCharStr, cchWideChar));
    }

    if (cchWideChar == -1)
    {
        cchWideChar = wcslen(lpWideCharStr);
    }
    //
    // NOTENOTE YSLin:
    // If you make fix in the following code, remember to make the appropriate fix
    // in GetUnicodeToBytesCount() as well.
    //
    for (i = 0; i < cchWideChar; i++) 
    {
        wch = lpWideCharStr[i];

        if (wch <= 0x7f)
        {
            if (cchMBCount == cchMultiByte)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }
            lpMultiByteStr[cchMBCount++] = (BYTE)wch;
        } else if (IS_HIGH_SURROGATE(wch))
        {
            //
            // Look ahead one character to see if the next char is a low surrogate.
            //
            if (i + 1 < cchWideChar)
            {
                if (IS_LOW_SURROGATE(lpWideCharStr[ i+1 ]))
                {
                    if (cchMBCount + 4 > cchMultiByte)
                    {
                        SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        return (0);
                    }
                
                    i++;
                    //
                    // A surrogate pair will be converted to GB 18030 four-byte from
                    // 0x90308130 ~ 0xe339fe39.
                    //                
                    dwSurrogateOffset = (wch - 0xd800) * 0x0400 + (lpWideCharStr[i] - 0xdc00);
                    lpMultiByteStr[cchMBCount+3] = (BYTE)(dwSurrogateOffset % GBK2K_BYTE4_RANGE) + GBK2K_BYTE4_MIN;
                    dwSurrogateOffset /= GBK2K_BYTE4_RANGE;
                    lpMultiByteStr[cchMBCount+2] = (BYTE)(dwSurrogateOffset % GBK2K_BYTE3_RANGE) + GBK2K_BYTE3_MIN;
                    dwSurrogateOffset /= GBK2K_BYTE3_RANGE;
                    lpMultiByteStr[cchMBCount+1] = (BYTE)(dwSurrogateOffset % GBK2K_BYTE2_RANGE) + GBK2K_BYTE2_MIN;
        